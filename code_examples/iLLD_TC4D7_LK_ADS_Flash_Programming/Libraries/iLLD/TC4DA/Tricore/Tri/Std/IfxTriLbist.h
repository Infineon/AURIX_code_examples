/**
 * \file IfxTribist.h
 * \brief LBIST  basic functionality
 * \ingroup IfxLld_Lbist
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * LBIST module scans and tests the digital circutary within the microcontroller.
 * This driver provides LBIST APIs which are used to trigger the Logic BIST module.
 * Caution: Draft implementation, APIs may change.
 *
 * \defgroup IfxLld_Lbist_Std_Lbist Lbist Basic Functionality
 * \ingroup IfxLld_Lbist_Std
 */

#ifndef IFXTRILBIST_H
#define IFXTRILBIST_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include "Cpu/Std/Ifx_Types.h"
#include "IfxTri_reg.h"
#include "IfxTri_bf.h"
#include "IfxPms_reg.h"
#include "Ap/Std/IfxApProt.h"

#define IFXTRILBIST_CFG_NUM_DOMAINS (7U) /* Domain #7 does not exist in TC4Dx product*/

#define IFXTRILBIST_DOMX_FAILED       0x00FFU
#define IFXTRILBIST_NOT_DONE          0x0100U
#define IFXTRILBIST_NOT_TERMINATED    0x0200U
#define IFXTRILBIST_EARLY_TERMINATED  0x0400U
#define IFXTRILBIST_SUCCESS           0x0000U

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief Key on/off indicator
 */
typedef enum
{
    IfxTriLbist_Keyoff_on   = 0, 
    IfxTriLbist_Keyoff_off  = 1          
} IfxTriLbist_Keyoff;

/** \brief LBIST transaction frequency selection (iJTAG interface Freq)
 */
typedef enum
{
    IfxTriLbist_TransactionFreq_disabled  = 0,   /**< \brief LBIST transaction Frequency, clock disabled */
    IfxTriLbist_TransactionFreq_50Mhz  = 1,      /**< \brief LBIST transaction Frequency, iJTAG interface runs at 50MHz */
    IfxTriLbist_TransactionFreq_33Mhz  = 2,      /**< \brief LBIST transaction Frequency, iJTAG interface runs at 33MHz */
    IfxTriLbist_TransactionFreq_25Mhz  = 3,      /**< \brief LBIST transaction Frequency, iJTAG interface runs at 25MHz */
} IfxTriLbist_TransactionFreq;

/** \brief prescaler values to divide the EVR frequency for the LBIST operational clock
 */
typedef enum
{
    IfxTriLbist_Freq_div1  = 0,   /**< \brief LBIST Frequency, EVR Clock Divided by 1 */
    IfxTriLbist_Freq_div2  = 1,   /**< \brief LBIST Frequency, EVR Clock Divided by 2 */
    IfxTriLbist_Freq_div3  = 2,   /**< \brief LBIST Frequency, EVR Clock Divided by 3 */
    IfxTriLbist_Freq_div4  = 3,   /**< \brief LBIST Frequency, EVR Clock Divided by 4 */
    IfxTriLbist_Freq_div5  = 4,   /**< \brief LBIST Frequency, EVR Clock Divided by 5 */
    IfxTriLbist_Freq_div6  = 5,   /**< \brief LBIST Frequency, EVR Clock Divided by 6 */
    IfxTriLbist_Freq_div7  = 6,   /**< \brief LBIST Frequency, EVR Clock Divided by 7 */
    IfxTriLbist_Freq_div8  = 7,   /**< \brief LBIST Frequency, EVR Clock Divided by 8 */
    IfxTriLbist_Freq_div9  = 8,   /**< \brief LBIST Frequency, EVR Clock Divided by 9 */
    IfxTriLbist_Freq_div10 = 9,   /**< \brief LBIST Frequency, EVR Clock Divided by 10 */
    IfxTriLbist_Freq_div11 = 10,  /**< \brief LBIST Frequency, EVR Clock Divided by 11 */
    IfxTriLbist_Freq_div12 = 11,  /**< \brief LBIST Frequency, EVR Clock Divided by 12 */
    IfxTriLbist_Freq_div13 = 12,  /**< \brief LBIST Frequency, EVR Clock Divided by 13 */
    IfxTriLbist_Freq_div14 = 13,  /**< \brief LBIST Frequency, EVR Clock Divided by 14 */
    IfxTriLbist_Freq_div15 = 14,  /**< \brief LBIST Frequency, EVR Clock Divided by 15 */
    IfxTriLbist_Freq_div16 = 15   /**< \brief LBIST Frequency, EVR Clock Divided by 16 */
} IfxTriLbist_Freq;

/** \brief Split Shift Selection
 */
typedef enum
{
    IfxTriLbist_SplitShiftSel_allScanPartitions  = 0,  /**< \brief LBIST Split-Shift Concurrent Scan-Shift Selection */
    IfxTriLbist_SplitShiftSel_fourScanPartitions = 2,  /**< \brief LBIST Split-Shift Four Scan-Shift Selection */
    IfxTriLbist_SplitShiftSel_twoScanPartitions  = 3   /**< \brief LBIST Split-Shift Two Scan-Shift Selection */
} IfxTriLbist_SplitShiftSel;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief configuration data structure for the LBIST parameters
 */
typedef struct
{
    uint32                      pattern;                                            /**< \brief LBIST Pattern Number for the scan loads */
    uint8                       scanChainLength[IFXTRILBIST_CFG_NUM_DOMAINS];          /**< \brief LBIST maximum scan chain length */
    uint8                       safetyScanChainLength[IFXTRILBIST_CFG_NUM_DOMAINS];    /**< \brief LBIST maximum scan chain length */
    uint32                      signature[IFXTRILBIST_CFG_NUM_DOMAINS];        /**< \brief LBIST Signature Value to compare with MISR signature from the last LBIST */
    IfxTriLbist_Keyoff             keyoffEnable;                               /**< \brief LBIST Keyon or Keyoff Indicator */
    IfxTriLbist_Freq               freq;                                       /**< \brief LBIST Frequency Selection. Pre-scaler value to derive LBIST operation clock from EVR oscillator */
    IfxTriLbist_TransactionFreq    transactionFreq;                            /**< \brief LBIST Transaction Frequency Selection. */
    IfxTriLbist_SplitShiftSel      splitShiftSel;                              /**< \brief LBIST Split-Shift Selection */
    uint8                       domainSelVal;                               /**< \brief LBIST Domain Selection value */
    boolean                     safetySelEnable;                            /**< \brief LBIST Safety LBIST test indicator */
    boolean                     parallelExeEnable;                          /**< \brief LBIST Parallel LBIST execution indicator */
} IfxTriLbist_ParameterSet;

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Evaluate Previous LBIST result.
 * Note: LBIST trigger normally resets the controller to have warm power on reset.
 * \param signature result signature to be evaulated
 * \return False :If the previous LBIST is not done or if the previous LBIST signature did not match with configured value.
 * 0 : LBIST Successful , Non-Zero : LBIST failure/Not executed.
 */
IFX_INLINE uint16 IfxTriLbist_evaluateResult(const uint32 *signature);

/** \brief Init the default config parameter set
 * \param parameterSet pointer to the datastructure which is used for triggering the latest LBIST activity.
 * \return None
 */
IFX_INLINE void IfxTriLbist_initParameterSetInline(IfxTriLbist_ParameterSet *parameterSet);

/** \brief the api returns Lbist done status
 * \return True: Lbist done. False: Lbist not done
 */
IFX_INLINE boolean IfxTriLbist_isDone(void);

/** \brief trigger a fresh LBIST irrespective of previous LBIST
 * Note: For Domain 3 (SRI2) LBIST can only be triggered if VDDPHYx power supplies are connected either to a dedicated external
 * source or to the VDD supply voltage.
 * \param parameterSet pointer to the datastructure which is used for triggering the latest LBIST activity.
 * \return None
 */
IFX_INLINE void IfxTriLbist_triggerInline(const IfxTriLbist_ParameterSet *parameterSet);

/** \brief the api resets the Tri module
 * \return None
 */
IFX_INLINE void IfxTriLbist_resetLbist(void);

/** \brief the api enables the Tri module
 * \return None
 */IFX_INLINE void IfxTriLbist_enableModule(void);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
/** \brief default configuration data for the LBIST Key ON
 */
IFX_EXTERN IFX_CONST IfxTriLbist_ParameterSet IfxTriLbist_keyOnDefaultConfig;

/** \brief default configuration data for the LBIST Key OFF
 */
IFX_EXTERN IFX_CONST IfxTriLbist_ParameterSet IfxTriLbist_keyOffDefaultConfig;

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/
IFX_INLINE uint16 IfxTriLbist_evaluateResult(const uint32 *signature)
{
    uint16 result = IFXTRILBIST_SUCCESS;
    int i;
    
    //TODO: anything else to do??
    if (PMS_CLDRSTRIG.B.LBPORST != 0)
    {
    	/* LBIST termination due to warm PORST */
    	 result = IFXTRILBIST_EARLY_TERMINATED;
    }
    if (PMS_CLDRSTRIG.B.LBTERM != 1)
    {
    	/* LBIST was not properly terminated for respective domains */
        result = IFXTRILBIST_NOT_TERMINATED;
    }
    else if (!IfxTriLbist_isDone()){
    	 /* No LBIST executed since last power-on-reset or LBISTcontroller has been restarted (via LBIST_CTRL_REQ.RESET
    	                   function) or LBIST was interrupted by external PORST during runtime */
    	result = IFXTRILBIST_NOT_DONE;
    }
    else{
		for(i=0;i<IFXTRILBIST_CFG_NUM_DOMAINS;i++)
		{
		  if (MODULE_TRI.LBIST.STAT.RES[i].SIG.U != signature[i])
		  {
			result = IFXTRILBIST_DOMX_FAILED;
			break;
		  }
		}
    }
    return result;

}

IFX_INLINE void IfxTriLbist_initParameterSetInline(IfxTriLbist_ParameterSet *parameterSet)
{
    *parameterSet = IfxTriLbist_keyOnDefaultConfig;
}


IFX_INLINE boolean IfxTriLbist_isDone(void)
{
    uint32 status = 0;

    if ((MODULE_TRI.LBIST.STAT.TEST.B.DONE == 1) && 
        (MODULE_TRI.LBIST.STAT.TEST.B.DOMDONE0 == 1) &&
        (MODULE_TRI.LBIST.STAT.TEST.B.DOMDONE1 == 1) &&
        (MODULE_TRI.LBIST.STAT.TEST.B.DOMDONE2 == 1) &&
        (MODULE_TRI.LBIST.STAT.TEST.B.DOMDONE3 == 1) &&
        (MODULE_TRI.LBIST.STAT.TEST.B.DOMDONE4 == 1) &&
        (MODULE_TRI.LBIST.STAT.TEST.B.DOMDONE5 == 1) &&
        (MODULE_TRI.LBIST.STAT.TEST.B.DOMDONE6 == 1) )
    {
        status = 1;
    }

   return (boolean) status;
}


IFX_INLINE void IfxTriLbist_triggerInline(const IfxTriLbist_ParameterSet *parameterSet)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_config);
#endif

    /* PROT/APU Check to be added */
    MODULE_TRI.LBIST.CTRL.CFGA.U = 
        (parameterSet->pattern << IFX_TRI_LBIST_CTRL_CFGA_PATTERNS_OFF) |
        (parameterSet->freq << IFX_TRI_LBIST_CTRL_CFGA_FREQU_OFF) |
        (parameterSet->transactionFreq << IFX_TRI_LBIST_CTRL_CFGA_TFREQU_OFF) |
        (parameterSet->splitShiftSel << IFX_TRI_LBIST_CTRL_CFGA_SPLITSH_OFF) |
        (parameterSet->safetySelEnable << IFX_TRI_LBIST_CTRL_CFGA_SAFESEL_OFF) |
        (parameterSet->parallelExeEnable << IFX_TRI_LBIST_CTRL_CFGA_ENPARA_OFF) |
        (parameterSet->keyoffEnable << IFX_TRI_LBIST_CTRL_CFGA_KEYOFF_OFF);

    MODULE_TRI.LBIST.CTRL.DOM.U = parameterSet->domainSelVal;

    {
        Ifx_TRI_LBIST_CTRL_REQ  lbist_ctrl_req;
        lbist_ctrl_req.U          = TRI_LBIST_CTRL_REQ.U;
        lbist_ctrl_req.B.REQ      = 1;				// LBIST Request - REQ
        lbist_ctrl_req.B.REQ_RED  = 1;				// LBIST Request Redundancy - REQ_RED
        TRI_LBIST_CTRL_REQ.U = lbist_ctrl_req.U; 	// write
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_run);
#endif

    
}

IFX_INLINE void IfxTriLbist_enableModule(void)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_config);
#endif
    //enable clock
    TRI_CLC.B.DISR = 0;
    while (TRI_CLC.B.DISS == 1) ;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_run);
#endif
    
}

IFX_INLINE void IfxTriLbist_resetLbist(void)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_config);
#endif
    MODULE_TRI.LBIST.CTRL.REQ.B.RESET = 1;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_run);
#endif
    
}

IFX_INLINE void IfxTriLbist_incrementFailCount(void)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_config);
#endif

	/* increment Fail count */
    uint8 fail_cnt = TRI_LBIST_STAT_TEST.B.FAILCOUT +1;
    TRI_LBIST_CTRL_REQ.B.FAILCIN = fail_cnt;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTE, IfxApProt_State_run);
#endif
    
}

IFX_INLINE uint8 IfxTriLbist_getFailCount(void)
{
	/* get Fail count */
    return TRI_LBIST_STAT_TEST.B.FAILCOUT;
}
#endif /* IFXTRILBIST_H */
