/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
 /*\title ADC filtering
 * \abstract Four EVADC channels are used to convert the same analog signal with different filters enabled.
 * \description The Enhanced Versatile Analog-to-Digital Converter (EVADC) module is configured to convert four
 *              channels. The data resulting from the conversions of three channels is automatically modified: one
 *              channel computes an average on 4 results, another channel applies a 3rd order Finite Impulse
 *              Response (FIR) filter and another channel applies a 1st order Infinite Impulse Response (IIR) filter.
 *              Finally, the last channel measures the same signal without Data Modification.
 *              The channels are continuously converted and, for each of them, the maximum and minimum
 *              values are stored, which are then sent through UART in order to be compared.
 *
 * \name ADC_Filtering_1_KIT_TC397_TFT
 * \version V2.0.0
 * \board APPLICATION KIT TC3X7 V2.0, KIT_A2G_TC397_5V_TFT, TC39xXX_B-Step
 * \keywords ADC, ADC_Filtering_1, AURIX, Average, DMM, DRCTR, Difference Mode, FIR, Filter, IIR, Result Filtering Mode, Standard Data Reduction Mode, Subtraction, EVADC
 * \documents README.MD
 * \documents https://www.infineon.com/aurix-expert-training/TC39B_iLLD_UM_1_0_1_17_0.chm
 * \lastUpdated 2024-01-31
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "ADC_Filtering.h"
#include "Bsp.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define WAIT_TIME   100             /* Number of milliseconds to wait between each conversion                       */

IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;

void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
    
    /* Initialize a counter for the number of conversions that have been read */
    uint32 cnt = 0;

    /* Initialize a time variable */
    Ifx_TickTime ticksFor100ms = IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME);

    /* Initialize the UART communication */
    initUART();

    /* Initialize the EVADC module and start the background scan */
    initADC();

    /* Create and initialize the structures to store the processed values of each channel */
    measureStats FIRmeasure;
    FIRmeasure.max = EVADC_MIN;
    FIRmeasure.min = EVADC_MAX;

    measureStats IIRmeasure;
    IIRmeasure.max = EVADC_MIN;
    IIRmeasure.min = EVADC_MAX;

    measureStats AVRGmeasure;
    AVRGmeasure.max = EVADC_MIN;
    AVRGmeasure.min = EVADC_MAX;

    measureStats NORMmeasure;
    NORMmeasure.max = EVADC_MIN;
    NORMmeasure.min = EVADC_MAX;

    char rxData[RX_LENGTH]; /* Placeholder for the data received over UART */

    /* Introduce a delay to avoid reading spikes due to the initialization of the device */
    wait(ticksFor100ms);

    while(1)
    {
        /* Reset the received command */
        rxData[0] = RESET_CHARACTER;

        /* Get the current conversions */
        AVRGmeasure.currentValue = readADCValue(AN0) / DIV_FACTOR_AVRG;
        IIRmeasure.currentValue  = readADCValue(AN3) / DIV_FACTOR_IIR;
        FIRmeasure.currentValue  = readADCValue(AN13) / DIV_FACTOR_FIR;
        NORMmeasure.currentValue = readADCValue(AN21);

        /* Update the counter */
        cnt++;

        /* Check if the minimum or maximum values have to be updated */
        if(AVRGmeasure.max < AVRGmeasure.currentValue)
        {
            AVRGmeasure.max = AVRGmeasure.currentValue;
        }
        if(AVRGmeasure.min > AVRGmeasure.currentValue)
        {
            AVRGmeasure.min = AVRGmeasure.currentValue;
        }
        if(FIRmeasure.max < FIRmeasure.currentValue)
        {
            FIRmeasure.max = FIRmeasure.currentValue;
        }
        if(FIRmeasure.min > FIRmeasure.currentValue)
        {
            FIRmeasure.min = FIRmeasure.currentValue;
        }
        if(IIRmeasure.max < IIRmeasure.currentValue)
        {
            IIRmeasure.max = IIRmeasure.currentValue;
        }
        if(IIRmeasure.min > IIRmeasure.currentValue)
        {
            IIRmeasure.min = IIRmeasure.currentValue;
        }
        if(NORMmeasure.max < NORMmeasure.currentValue)
        {
            NORMmeasure.max = NORMmeasure.currentValue;
        }
        if(NORMmeasure.min > NORMmeasure.currentValue)
        {
            NORMmeasure.min = NORMmeasure.currentValue;
        }

        /* If any data has been received over UART, read it */
        if(isDataAvailable())
        {
            receiveData(rxData, RX_LENGTH); /* Read one byte */
        }

        /* If the correct character was received, print the stored values */
        if(rxData[0] == PASS_CHARACTER)
        {
            IfxStdIf_DPipe_print(&g_stdInterface, "FIR max:\t%d\tFIR min:\t%d\tFIR Vpp:\t%.3f V\r\n", FIRmeasure.max, FIRmeasure.min, (FIRmeasure.max - FIRmeasure.min) * VOLT_CONVERSION);
            IfxStdIf_DPipe_print(&g_stdInterface, "IIR max:\t%d\tIIR min:\t%d\tIIR Vpp:\t%.3f V\r\n", IIRmeasure.max, IIRmeasure.min, (IIRmeasure.max - IIRmeasure.min) * VOLT_CONVERSION);
            IfxStdIf_DPipe_print(&g_stdInterface, "AVRG max:\t%d\tAVRG min:\t%d\tAVRG Vpp:\t%.3f V\r\n", AVRGmeasure.max, AVRGmeasure.min, (AVRGmeasure.max - AVRGmeasure.min) * VOLT_CONVERSION);
            IfxStdIf_DPipe_print(&g_stdInterface, "NORM max:\t%d\tNORM min:\t%d\tNORM Vpp:\t%.3f V\r\n", NORMmeasure.max, NORMmeasure.min, (NORMmeasure.max - NORMmeasure.min) * VOLT_CONVERSION);
            IfxStdIf_DPipe_print(&g_stdInterface, "Number of measurements for each channel: %d\r\n\r\n", cnt);
        }

        /* Delay between each conversion to not overload the CPU */
        wait(ticksFor100ms);
    }
}

