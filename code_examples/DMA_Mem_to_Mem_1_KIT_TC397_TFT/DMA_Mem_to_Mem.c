/********************************************************************************************************************
 * \file DMA_Mem_to_Mem.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "DMA_Mem_to_Mem.h"

/*********************************************************************************************************************/
/*-------------------------------------------------------Macros------------------------------------------------------*/
/*********************************************************************************************************************/
#define DMA_CHANNEL_ID      IfxDma_ChannelId_0     /* DMA Channel Id used to transfer data              */
#define DATA_ARRAY_LENGTH   10                     /* Data Length of the DMA transaction in words       */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
dmaParams g_DMA;                                    /* Global DMA configuration and control structure   */

#ifdef __TASKING__
    /* DMA Source buffer for DMA transfer stored inside DSPR0 */
    uint32 g_dataForDmaTransfer[DATA_ARRAY_LENGTH] __at(0x70000000);

    /* DMA Destination buffer stored inside DLMU RAM (of CPU0) */
    uint32  g_dmaLmuDestination[DATA_ARRAY_LENGTH] __at(0xB0000000);
#endif

#ifdef __GNUC__
    /* DMA Source buffer for DMA transfer stored inside DSPR0 */
    #pragma section .bss_cpu0 awc0
    uint32 g_dataForDmaTransfer[DATA_ARRAY_LENGTH] __attribute__((section(".bss_cpu0")));
    #pragma section

    /* DMA Destination buffer stored inside DLMU RAM (of CPU0) */
    #pragma section .lmubss_cpu0 awc0
    uint32 g_dmaLmuDestination[DATA_ARRAY_LENGTH] __attribute__((section(".lmubss_cpu0")));
    #pragma section
#endif

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/
static void fillSourceBuffer(uint32 *srcBuffer, uint32 arrayLength);
static void triggerDMATransfer(void);
static uint32 verifyDMACopiedData(void);

static void initLED(void);
static void turnLEDOn(Ifx_P *port, uint8 pinIndex);
static void turnLEDOff(Ifx_P *port, uint8 pinIndex);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Initialize the DMA module */
void initDMA(void)
{
    /* Load default module configuration into configuration structure */
    IfxDma_Dma_initModuleConfig(&g_DMA.dmaConfig, &MODULE_DMA);

    /* Initialize module with configuration. */
    IfxDma_Dma_initModule(&g_DMA.dmaHandle, &g_DMA.dmaConfig);

    /* Get/initialize DMA channel configuration for all DMA channels otherwise use &g_Dma.dmaChannel as target */
    IfxDma_Dma_initChannelConfig(&g_DMA.dmaChNCfg, &g_DMA.dmaHandle);

    /* Set desired DMA channel: Channel 0 is used */
    g_DMA.dmaChNCfg.channelId = DMA_CHANNEL_ID;

    /* Setup the operation mode/settings for DMA channel */
    g_DMA.dmaChNCfg.moveSize = IfxDma_ChannelMoveSize_32bit;
    /* Set the number of DMA transfers */
    g_DMA.dmaChNCfg.transferCount = (uint16)MEMORY_TRANSFER_NUM_DATA;

    /* Execute the DMA transaction with only one trigger */
    g_DMA.dmaChNCfg.requestMode = IfxDma_ChannelRequestMode_completeTransactionPerRequest;

    /* Setup the specific DMA channel configuration */
    IfxDma_Dma_initChannel(&g_DMA.dmaChannel, &g_DMA.dmaChNCfg);

    /* Save start address of source and destination buffers, into the Application global variable */
    g_DMA.pSourceAddressForDmaTransfer      = g_dataForDmaTransfer;
    g_DMA.pDestinationAddressForDmaTransfer = g_dmaLmuDestination;

    /* Initialize LED for DMA status signaling purpose */
    initLED();
    /* Signaling END of initialization with LEDs ON on SUCCESS and FAIURE LED */
    turnLEDOn(LED_DMA_FAILURE);
    turnLEDOn(LED_DMA_SUCCESS);
}

/* Run the example:
 * Trigger a DMA SW request
 * Wait until transfer complete flag is set
 * Verify Data & Signal result with LEDs
 */
void runDMA(void)
{
    /* Trigger the DMA Transaction */
    triggerDMATransfer();

    /* Wait until the end of the DMA Transaction
     * Clear the interrupt status when the flag is SET
     */
    while(IfxDma_Dma_getAndClearChannelInterrupt(&g_DMA.dmaChannel) != TRUE)
    {
        __nop(); /* NOP == Do nothing - No operation */
    }

    /* Start verification of data content */
    if(verifyDMACopiedData() == TRUE)
    {
        /* DMA data transfer is successfully done, increase successful DMA data transfer counter */
        g_DMA.successfulDmaTransaction++;

        /* Signaling end of DMA data transfer with success with LED ON on P13.1 (SUCCESS) and P13.0 LED OFF(FAILURE) */
        turnLEDOn(LED_DMA_SUCCESS);
        turnLEDOff(LED_DMA_FAILURE);
    }

    else
    {
        /* Increase failure counter of fault DMA data transfers */
        g_DMA.failedDmaTransaction++;

        /* Signaling end of DMA data transfer with failure with LED ON on P13.0 (FAILURE) and P13.1 LED OFF(SUCCESS) */
        turnLEDOn(LED_DMA_FAILURE);
        turnLEDOff(LED_DMA_SUCCESS);
    }
}

/* Trigger a DMA transaction via SW request */
static void triggerDMATransfer(void)
{
    /* Signaling a new DMA data transfer request by switching off the LEDs on Port 13 Pin 0 and Port 13 Pin 1 */
    turnLEDOff(LED_DMA_FAILURE);
    turnLEDOff(LED_DMA_SUCCESS);

    fillSourceBuffer(g_DMA.pSourceAddressForDmaTransfer, MEMORY_TRANSFER_NUM_DATA);

    /* Set destination and source address data to DMA channel */
    g_DMA.dmaChNCfg.sourceAddress      = (uint32) g_DMA.pSourceAddressForDmaTransfer;
    g_DMA.dmaChNCfg.destinationAddress = (uint32) g_DMA.pDestinationAddressForDmaTransfer;
    IfxDma_Dma_initChannel(&g_DMA.dmaChannel, &g_DMA.dmaChNCfg);

    /* Request start of DMA Transaction channel 0 */
    IfxDma_Dma_startChannelTransaction(&g_DMA.dmaChannel);
}

/* Fill source buffer */
static void fillSourceBuffer(uint32 *dataLocation, uint32 arrayLength)
{
    /* Modify each array content value in steps on updateValueStep */
    for(uint32 i = 0 ; i < arrayLength ; i++)
    {
        dataLocation[i] =  (i+1)* 0x10000000U + g_DMA.successfulDmaTransaction;
    }
}

/* Verify the transferred data after the end of the DMA transaction */
static uint32 verifyDMACopiedData(void)
{
    uint32 returnValue    = FALSE;                  /* To provide possibility of single return statement             */
    uint32 failureCounter = NO_FAILURE;             /* Counts number of non equal copied bytes. No overflow possible */
    uint8 *pSource        = g_DMA.pSourceAddressForDmaTransfer; /* Location of DMA data transfer source              */
    uint8 *pDestination   = g_DMA.pDestinationAddressForDmaTransfer; /* Location where DMA has to copy the source    */
    uint8  source;                                  /* Only for easier understanding byte verification               */
    uint8  destination;                             /* Only for easier understanding byte verification               */

    /* Bitwise step through to check, if correct copied or not. */
    for(uint32 byteCounter = 0; byteCounter < g_DMA.dmaChNCfg.transferCount; byteCounter++)
    {
        source      = *pSource;
        destination = *pDestination;

        /* Check current selected byte if source and destination memory locations are equal or not */
        if(source != destination)
        {
            failureCounter++;
        }
        pSource++;
        pDestination++;
    }

    /* In case of any failure, return FALSE, otherwise TRUE */
    if(failureCounter == NO_FAILURE)
    {
        returnValue = TRUE;
    }
    else
    {
        returnValue = FALSE;
    }

    return (returnValue);
}

/* Initialize LEDs */
static void initLED(void)
{
    /* Setup Port Pin working mode to control the LEDs */
    IfxPort_setPinMode(LED_DMA_SUCCESS, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(LED_DMA_FAILURE, IfxPort_Mode_outputPushPullGeneral);
}

/* Switch on a specific LED */
static void turnLEDOn(Ifx_P *port, uint8 pinIndex)
{
    /* LEDs are low active == LED ON. For LED ON set LED Port Pin to LOW. */
    IfxPort_setPinLow(port, pinIndex);
}

/* Switch off a specific LED */
static void turnLEDOff(Ifx_P *port, uint8 pinIndex)
{
    /* LEDs are low active == LED ON. For LED OFF set LED Port Pin to HIGH. */
    IfxPort_setPinHigh(port, pinIndex);
}
