/**
 * \file IfxPmsEvr.h
 * \brief PMS  basic functionality
 * \ingroup IfxLld_Pms
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pms_Std_Evr EVR
 * \ingroup IfxLld_Pms_Std
 * \defgroup IfxLld_Pms_Std_Evr_Enum Enumerations
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Module Module Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_EVRC EVRC Functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Data Structures Data Structures
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Primary Monitor Primary Monitor functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_Secondary Monitor Secondary Monitor functions
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_PeakVoltage Peak Voltage Detection
 * \ingroup IfxLld_Pms_Std_Evr
 * \defgroup IfxLld_Pms_Std_Evr_DriftMonitor Drift Monitoring
 * \ingroup IfxLld_Pms_Std_Evr
 */

#ifndef IFXPMSEVR_H
#define IFXPMSEVR_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxPms_cfg.h"
#include "Cpu/Std/IfxCpu.h"
#include "IfxPms_bf.h"
#include "IfxPms_reg.h"
#include "IfxScu_reg.h"
#include "Clock/Std/IfxClock.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"
#include "Smu/Std/IfxSmuStdby.h"
#include "Stm/Timer/IfxStm_Timer.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

#define IFXPMSEVR_SARHVLSB_MV   (2.830f)

#define IFXPMSEVR_SARCORELSB_MV (0.586f)

#define IFXPMSEVR_TRKHVLSB_MV   (11.32f)

/** \brief Timeout period for SDVOK to set 20us
 */
#define IFXPMSEVR_SDVOK_TIMEOUT (2000U)

#define IFXPMSEVR_TRKCORELSB_MV (2.830f)

#define IFXPMSEVR_SARMVLSB_MV   (2.83f)

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Error handler if voltage scaling is not successful
 * \return None
 */
typedef void (*IfxPmsEvr_ErrorHandler)(void);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pms_Std_Evr_Enum
 * \{ */
/** \brief Enumeration for DCDC synchronisation for input/output
 */
typedef enum
{
    IfxPmsEvr_DcdcSynchronization_input  = 0, /**< \brief The EVRC input synchronization to the external DCDCSYNCI input signal */
    IfxPmsEvr_DcdcSynchronization_output = 1  /**< \brief The synchronization output DCDCSYNCO of the EVRC, to synchronize an external SMPS regulator to the internal EVRC regulator */
} IfxPmsEvr_DcdcSynchronization;

/** \brief Enumeration for Drift Monitoring Voltage Source
 */
typedef enum
{
    IfxPmsEvr_DriftMonitorVoltageSource_vdd      = 0,  /**< \brief vdd drift monitor status register */
    IfxPmsEvr_DriftMonitorVoltageSource_vddext   = 1,  /**< \brief vddext drift monitor status register */
    IfxPmsEvr_DriftMonitorVoltageSource_vddextdc = 2,  /**< \brief vddextdc drift monitor status register */
    IfxPmsEvr_DriftMonitorVoltageSource_vddm     = 3,  /**< \brief vddm drift monitor status register */
    IfxPmsEvr_DriftMonitorVoltageSource_vddpms0  = 4,  /**< \brief vddpms0 drift monitor status register */
    IfxPmsEvr_DriftMonitorVoltageSource_vddpms2  = 5   /**< \brief vddpms2 drift monitor status register */
} IfxPmsEvr_DriftMonitorVoltageSource;

/** \brief Enumeration for Switching frequency division factor for external synchronisation.
 */
typedef enum
{
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_1  = 0,  /**< \brief fDCDCSYNC = fDCDC. The actual duty cycle is routed. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_2  = 1,  /**< \brief fDCDCSYNC = fDCDC/2. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_4  = 2,  /**< \brief fDCDCSYNC = fDCDC/4. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_8  = 3,  /**< \brief fDCDCSYNC = fDCDC/8. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_16 = 4,  /**< \brief fDCDCSYNC = fDCDC/16. Duty cycle is constant at 50%. */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_32 = 5   /**< \brief fDCDCSYNC = fDCDC/32. Duty cycle is constant at 50%. */
} IfxPmsEvr_ExtSyncSwitchingFreqDivFactor;

/** \brief Configure respective interrupts define in register INT_CON0 and INT_CON1
 */
typedef enum
{
    IfxPmsEvr_Interrupt_ovvdevrsb   = 0,   /**< \brief OVVDDEVRSB Interrupt enable */
    IfxPmsEvr_Interrupt_uvvdevrsb   = 1,   /**< \brief UVVDDEVRSB Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddext    = 2,   /**< \brief OVVDDEXT Interrupt enable */
    IfxPmsEvr_Interrupt_uvvdext     = 3,   /**< \brief UVVDDEXT Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddm      = 4,   /**< \brief OVVDDM Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddm      = 5,   /**< \brief UVVDDM Interrupt enable */
    IfxPmsEvr_Interrupt_ovvdd       = 8,   /**< \brief OVVDD Interrupt enable */
    IfxPmsEvr_Interrupt_uvvdd       = 9,   /**< \brief UVVDD Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddpms0   = 10,  /**< \brief OVVDDPMS0 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddpms0   = 11,  /**< \brief UVVDDPMS0 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddpms1   = 12,  /**< \brief OVVDDPMS1 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddpms1   = 13,  /**< \brief UVVDDPMS1 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddpms2   = 14,  /**< \brief OVVDDPMS2 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddpms2   = 15,  /**< \brief UVVDDPMS2 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddsbram  = 16,  /**< \brief OVVDDSBRAM Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddsbram  = 17,  /**< \brief UVVDDSBRAM Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddpad    = 18,  /**< \brief OVVDDPAD Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddpad    = 19,  /**< \brief OVVDDPAD Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddextdc  = 20,  /**< \brief OVVDDEXTDC Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddextdc  = 21,  /**< \brief UVVDDEXTDC Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddphphy0 = 32,  /**< \brief OVVDDPHPHY0 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddphphy0 = 33,  /**< \brief UVVDDPHPHY0 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddphphy1 = 34,  /**< \brief OVVDDPHPHY1 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddphphy1 = 35,  /**< \brief UVVDDPHPHY1 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddphphy2 = 36,  /**< \brief OVVDDPHPHY2 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddphphy2 = 37,  /**< \brief UVVDDPHPHY2 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddhsif   = 38,  /**< \brief OVVDDHSIF Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddhsif   = 39,  /**< \brief UVVDDHSIF Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddphy0   = 42,  /**< \brief OVVDDPHY0 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddphy0   = 43,  /**< \brief UVVDDPHY0 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddphy1   = 44,  /**< \brief OVVDDPHY1 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddphy1   = 45,  /**< \brief UVVDDPHY1 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddphy2   = 46,  /**< \brief OVVDDPHY2 Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddphy2   = 47,  /**< \brief UVVDDPHY2 Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddlmu0   = 48,  /**< \brief OVVDDLMU Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddlmu0   = 49,  /**< \brief UVVDDLMU Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddlmu1   = 50,  /**< \brief OVVDDLMU Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddlmu1   = 51,  /**< \brief UVVDDLMU Interrupt enable */
    IfxPmsEvr_Interrupt_ovvddppu    = 52,  /**< \brief OVVDDPPU Interrupt enable */
    IfxPmsEvr_Interrupt_uvvddppu    = 53,  /**< \brief UVVDDPPU Interrupt enable */
    IfxPmsEvr_Interrupt_rtccmp0     = 64,  /**< \brief RTCCMP0 Interrupt enable */
    IfxPmsEvr_Interrupt_rtccmp1     = 65,  /**< \brief RTCCMP1 Interrupt enable */
    IfxPmsEvr_Interrupt_wutwkp      = 66,  /**< \brief WUTWKP Interrupt enable */
    IfxPmsEvr_Interrupt_esr0wkp     = 67,  /**< \brief ESR0WKP Interrupt enable */
    IfxPmsEvr_Interrupt_esr1wkp     = 68,  /**< \brief ESR1WKP Interrupt enable */
    IfxPmsEvr_Interrupt_esr2wkp     = 69,  /**< \brief ESR2WKP Interrupt enable */
    IfxPmsEvr_Interrupt_pinawkp     = 70,  /**< \brief PINAWKP Interrupt enable */
    IfxPmsEvr_Interrupt_pinbwkp     = 71,  /**< \brief PINBWKP Interrupt enable */
    IfxPmsEvr_Interrupt_pincwkp     = 72,  /**< \brief PINCWKP Interrupt enable */
    IfxPmsEvr_Interrupt_pinssbwkp   = 73,  /**< \brief PINSSBWKP Interrupt enable */
    IfxPmsEvr_Interrupt_pinsextwkp  = 74,  /**< \brief PINSEXTWKP Interrupt enable */
    IfxPmsEvr_Interrupt_scrint0     = 75,  /**< \brief SCRINT0 Interrupt enable */
    IfxPmsEvr_Interrupt_scrint1     = 76,  /**< \brief SCRINT1 Interrupt enable */
    IfxPmsEvr_Interrupt_scrrst      = 77,  /**< \brief SCR RST Interrupt enable */
    IfxPmsEvr_Interrupt_screcc      = 78,  /**< \brief SCR ECC Interrupt enable */
    IfxPmsEvr_Interrupt_scrwdt      = 79,  /**< \brief SCRWDT Interrupt enable */
    IfxPmsEvr_Interrupt_scrpinrst   = 80,  /**< \brief SCRPINRST Interrupt enable */
    IfxPmsEvr_Interrupt_dcdcvok     = 81,  /**< \brief DCDCVOK Interrupt enable */
    IfxPmsEvr_Interrupt_dcdcsynclck = 82,  /**< \brief DCDCSYNCLCK Interrupt enable */
    IfxPmsEvr_Interrupt_vddextdclvl = 83,  /**< \brief VDDEXTDCLVL Interrupt enable */
    IfxPmsEvr_Interrupt_fifoFull    = 84,  /**< \brief Fifo full Interrupt enable */
    IfxPmsEvr_Interrupt_fifoEmpty   = 85   /**< \brief Fifo empty Interrupt enable */
} IfxPmsEvr_Interrupt;

/** \brief Enumeration for over voltage monitoring mode
 */
typedef enum
{
    IfxPmsEvr_OverVoltageMonitoring_inactive                         = 0, /**< \brief Over-Voltage Monitoring inactive */
    IfxPmsEvr_OverVoltageMonitoring_lowToHighVoltageTransition       = 1, /**< \brief Over-Voltage event is generated when threshold is crossed in lower to higher voltage transition */
    IfxPmsEvr_OverVoltageMonitoring_highToLowVoltageTransition       = 2, /**< \brief Over-Voltage event is generated when threshold is crossed in higher to lower voltage transition */
    IfxPmsEvr_OverVoltageMonitoring_eitherDirectionVoltageTransition = 3  /**< \brief Over-Voltage event is generated when threshold is crossed in either direction */
} IfxPmsEvr_OverVoltageMonitoring;

/** \brief Enumeration for Peak Voltage Detection supply rails.
 */
typedef enum
{
    IfxPmsEvr_PeakDetectionVoltageSource_vdd      = 0, /**< \brief vdd peak voltage detection. */
    IfxPmsEvr_PeakDetectionVoltageSource_vddext   = 1, /**< \brief vddext peak voltage detection. */
    IfxPmsEvr_PeakDetectionVoltageSource_vddextdc = 2  /**< \brief vddextdc peak voltage detection. */
} IfxPmsEvr_PeakDetectionVoltageSource;

/** \brief Enumeratin for Peak Voltage Detection Status register
 */
typedef enum
{
    IfxPmsEvr_PeakDetectionVoltageStatus_vdd                = 0, /**< \brief vdd peak voltage detection status register */
    IfxPmsEvr_PeakDetectionVoltageStatus_vddext             = 1, /**< \brief vddext peak voltage detection status register. */
    IfxPmsEvr_PeakDetectionVoltageStatus_vddextdc           = 2, /**< \brief vddextdc peak voltage detection status register. */
    IfxPmsEvr_PeakDetectionVoltageStatus_vddhiststatus      = 3, /**< \brief vdd peak voltage detection history status register */
    IfxPmsEvr_PeakDetectionVoltageStatus_vddexthiststatus   = 4, /**< \brief vddext peak voltage detection history status register */
    IfxPmsEvr_PeakDetectionVoltageStatus_vddextdchiststatus = 5  /**< \brief vddextdc peak voltage detection hisotry status register */
} IfxPmsEvr_PeakDetectionVoltageStatus;

/** \brief Enum for PORST digital filter configuration
 */
typedef enum
{
    IfxPmsEvr_PorstDigitalFilter_analogfilter       = 0,  /**< \brief Analog PORST pad filter delay */
    IfxPmsEvr_PorstDigitalFilter_digitalfilter500ns = 1,  /**< \brief Analog PORST pad filter delay + digital filter delay. Digital filter delay is ~500ns */
    IfxPmsEvr_PorstDigitalFilter_digitalfilter5us   = 2   /**< \brief Analog PORST pad filter delay + digital filter delay. Digital filter delay is ~5us */
} IfxPmsEvr_PorstDigitalFilter;

/** \brief set TRIM Value For respective Voltages.
 */
typedef enum
{
    IfxPmsEvr_PrimaryAdcTrimValue_0 = 0,      /**< \brief Primary Adc Trim Value 0  */
    IfxPmsEvr_PrimaryAdcTrimValue_1,          /**< \brief Primary Adc Trim Value 1  */
    IfxPmsEvr_PrimaryAdcTrimValue_2,          /**< \brief Primary Adc Trim Value 2  */
    IfxPmsEvr_PrimaryAdcTrimValue_3,          /**< \brief Primary Adc Trim Value 3  */
    IfxPmsEvr_PrimaryAdcTrimValue_4,          /**< \brief Primary Adc Trim Value 4  */
    IfxPmsEvr_PrimaryAdcTrimValue_5,          /**< \brief Primary Adc Trim Value 5  */
    IfxPmsEvr_PrimaryAdcTrimValue_6,          /**< \brief Primary Adc Trim Value 6  */
    IfxPmsEvr_PrimaryAdcTrimValue_7,          /**< \brief Primary Adc Trim Value 7  */
    IfxPmsEvr_PrimaryAdcTrimValue_8,          /**< \brief Primary Adc Trim Value 8  */
    IfxPmsEvr_PrimaryAdcTrimValue_9,          /**< \brief Primary Adc Trim Value 9  */
    IfxPmsEvr_PrimaryAdcTrimValue_10,         /**< \brief Primary Adc Trim Value 10  */
    IfxPmsEvr_PrimaryAdcTrimValue_11,         /**< \brief Primary Adc Trim Value 11  */
    IfxPmsEvr_PrimaryAdcTrimValue_12,         /**< \brief Primary Adc Trim Value 12  */
    IfxPmsEvr_PrimaryAdcTrimValue_13,         /**< \brief Primary Adc Trim Value 13  */
    IfxPmsEvr_PrimaryAdcTrimValue_14,         /**< \brief Primary Adc Trim Value 14  */
    IfxPmsEvr_PrimaryAdcTrimValue_15,         /**< \brief Primary Adc Trim Value 15  */
    IfxPmsEvr_PrimaryAdcTrimValue_16,         /**< \brief Primary Adc Trim Value 16  */
    IfxPmsEvr_PrimaryAdcTrimValue_17,         /**< \brief Primary Adc Trim Value 17  */
    IfxPmsEvr_PrimaryAdcTrimValue_18,         /**< \brief Primary Adc Trim Value 18  */
    IfxPmsEvr_PrimaryAdcTrimValue_19,         /**< \brief Primary Adc Trim Value 19  */
    IfxPmsEvr_PrimaryAdcTrimValue_20,         /**< \brief Primary Adc Trim Value 20  */
    IfxPmsEvr_PrimaryAdcTrimValue_21,         /**< \brief Primary Adc Trim Value 21  */
    IfxPmsEvr_PrimaryAdcTrimValue_22,         /**< \brief Primary Adc Trim Value 22  */
    IfxPmsEvr_PrimaryAdcTrimValue_23,         /**< \brief Primary Adc Trim Value 23  */
    IfxPmsEvr_PrimaryAdcTrimValue_24,         /**< \brief Primary Adc Trim Value 24  */
    IfxPmsEvr_PrimaryAdcTrimValue_25,         /**< \brief Primary Adc Trim Value 25  */
    IfxPmsEvr_PrimaryAdcTrimValue_26,         /**< \brief Primary Adc Trim Value 26  */
    IfxPmsEvr_PrimaryAdcTrimValue_27,         /**< \brief Primary Adc Trim Value 27  */
    IfxPmsEvr_PrimaryAdcTrimValue_28,         /**< \brief Primary Adc Trim Value 28  */
    IfxPmsEvr_PrimaryAdcTrimValue_29,         /**< \brief Primary Adc Trim Value 29  */
    IfxPmsEvr_PrimaryAdcTrimValue_30,         /**< \brief Primary Adc Trim Value 30  */
    IfxPmsEvr_PrimaryAdcTrimValue_31,         /**< \brief Primary Adc Trim Value 31  */
    IfxPmsEvr_PrimaryAdcTrimValue_32,         /**< \brief Primary Adc Trim Value 32  */
    IfxPmsEvr_PrimaryAdcTrimValue_33,         /**< \brief Primary Adc Trim Value 33  */
    IfxPmsEvr_PrimaryAdcTrimValue_34,         /**< \brief Primary Adc Trim Value 34  */
    IfxPmsEvr_PrimaryAdcTrimValue_35,         /**< \brief Primary Adc Trim Value 35  */
    IfxPmsEvr_PrimaryAdcTrimValue_36,         /**< \brief Primary Adc Trim Value 36  */
    IfxPmsEvr_PrimaryAdcTrimValue_37,         /**< \brief Primary Adc Trim Value 37  */
    IfxPmsEvr_PrimaryAdcTrimValue_38,         /**< \brief Primary Adc Trim Value 38  */
    IfxPmsEvr_PrimaryAdcTrimValue_39,         /**< \brief Primary Adc Trim Value 39  */
    IfxPmsEvr_PrimaryAdcTrimValue_40,         /**< \brief Primary Adc Trim Value 40  */
    IfxPmsEvr_PrimaryAdcTrimValue_41,         /**< \brief Primary Adc Trim Value 41  */
    IfxPmsEvr_PrimaryAdcTrimValue_42,         /**< \brief Primary Adc Trim Value 42  */
    IfxPmsEvr_PrimaryAdcTrimValue_43,         /**< \brief Primary Adc Trim Value 43  */
    IfxPmsEvr_PrimaryAdcTrimValue_44,         /**< \brief Primary Adc Trim Value 44  */
    IfxPmsEvr_PrimaryAdcTrimValue_45,         /**< \brief Primary Adc Trim Value 45  */
    IfxPmsEvr_PrimaryAdcTrimValue_46,         /**< \brief Primary Adc Trim Value 46  */
    IfxPmsEvr_PrimaryAdcTrimValue_47,         /**< \brief Primary Adc Trim Value 47  */
    IfxPmsEvr_PrimaryAdcTrimValue_48,         /**< \brief Primary Adc Trim Value 48  */
    IfxPmsEvr_PrimaryAdcTrimValue_49,         /**< \brief Primary Adc Trim Value 49  */
    IfxPmsEvr_PrimaryAdcTrimValue_50,         /**< \brief Primary Adc Trim Value 50  */
    IfxPmsEvr_PrimaryAdcTrimValue_51,         /**< \brief Primary Adc Trim Value 51  */
    IfxPmsEvr_PrimaryAdcTrimValue_52,         /**< \brief Primary Adc Trim Value 52  */
    IfxPmsEvr_PrimaryAdcTrimValue_53,         /**< \brief Primary Adc Trim Value 53  */
    IfxPmsEvr_PrimaryAdcTrimValue_54,         /**< \brief Primary Adc Trim Value 54  */
    IfxPmsEvr_PrimaryAdcTrimValue_55,         /**< \brief Primary Adc Trim Value 55  */
    IfxPmsEvr_PrimaryAdcTrimValue_56,         /**< \brief Primary Adc Trim Value 56  */
    IfxPmsEvr_PrimaryAdcTrimValue_57,         /**< \brief Primary Adc Trim Value 57  */
    IfxPmsEvr_PrimaryAdcTrimValue_58,         /**< \brief Primary Adc Trim Value 58  */
    IfxPmsEvr_PrimaryAdcTrimValue_59,         /**< \brief Primary Adc Trim Value 59  */
    IfxPmsEvr_PrimaryAdcTrimValue_60,         /**< \brief Primary Adc Trim Value 60  */
    IfxPmsEvr_PrimaryAdcTrimValue_61,         /**< \brief Primary Adc Trim Value 61  */
    IfxPmsEvr_PrimaryAdcTrimValue_62,         /**< \brief Primary Adc Trim Value 62  */
    IfxPmsEvr_PrimaryAdcTrimValue_63          /**< \brief Primary Adc Trim Value 63  */
} IfxPmsEvr_PrimaryAdcTrimValue;

/** \brief Enumeration for Primary monitor supply rails
 */
typedef enum
{
    IfxPmsEvr_PrimaryMonitorVoltageSource_vdd       = 0,   /**< \brief 0.9 V/0.95 V/1.0 V (external supply or
                                                            * generated by EVRC) */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddext    = 1,   /**< \brief 3.3V/5V IO pad supply for ports and pins */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs   = 2,   /**< \brief 1.5V EVRC MOSFET driver supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc  = 3,   /**< \brief 3.3V/5V/6.5V EVRC MOSFET driver supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls   = 4,   /**< \brief 3.3V/5V */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb  = 5,   /**< \brief 3.3V/5V Standby domain supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddm      = 6,   /**< \brief VDDM - Analog supply for ADCs */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0 = 7,   /**< \brief 1.8V Ethernet SGMII0 supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1 = 8,   /**< \brief 1.8V Ethernet SGMII1 or PCIE supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif   = 9,   /**< \brief 1.8V/3.3V RGMII or NOR Flash I/F supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu    = 14,  /**< \brief 0.9 V/0.95 V/1.0 V Switchable PPU power supply. */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0   = 15,  /**< \brief ETH SGMII core supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1   = 16,  /**< \brief PCIe core supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2   = 17,  /**< \brief Debugging interface core supply */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2 = 18,  /**< \brief dedicated IO and module supply for SGBT debugging module */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad    = 19,  /**< \brief pads supply voltage */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0   = 20,  /**< \brief LMU0 supply voltage */
    IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1   = 21   /**< \brief LMU1 supply voltage */
} IfxPmsEvr_PrimaryMonitorVoltageSource;

/** \brief Enumeration for Secondary monitor supply rails
 */
typedef enum
{
    IfxPmsEvr_SecondaryMonitorVoltageSource_vdd       = 0,   /**< \brief 0.9 V/0.95 V/1.0 V (external supply or
                                                              * generated by EVRC) */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddext    = 1,   /**< \brief 3.3V/5V IO pad supply for ports and pins */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc  = 2,   /**< \brief 3.3V/5V/6.5V EVRC MOSFET driver supply */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb  = 3,   /**< \brief 3.3V/5V Standby domain supply */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddm      = 4,   /**< \brief VDDM - Analog supply for ADCs */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0 = 5,   /**< \brief 1.8V Ethernet SGMII0 supply */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1 = 6,   /**< \brief 1.8V Ethernet SGMII1 or PCIE supply */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif   = 8,   /**< \brief 1.8V/3.3V RGMII or NOR Flash I/F supply */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram  = 9,   /**< \brief Internal core supply for Standby RAMs */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu    = 13,  /**< \brief 0.9 V/0.95 V/1.0 V Switchable PPU power supply. */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0   = 14,  /**< \brief ETH SGMII core supply */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1   = 15,  /**< \brief PCIe core supply */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0   = 17,  /**< \brief Internal core supply for PMS0 domain */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1   = 18,  /**< \brief Internal core supply for PMS1 domain */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2   = 19,  /**< \brief Internal core supply for PMS2 domain */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2 = 20,  /**< \brief Separate dedicated IO and module supply for SGBT debugging module */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2   = 21,  /**< \brief Separate dedicated core supply for SGBT debugging module */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad    = 23,  /**< \brief PAD supply voltage */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0   = 24,  /**< \brief LMU0 supply voltage */
    IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1   = 25   /**< \brief LMU1 supply voltage */
} IfxPmsEvr_SecondaryMonitorVoltageSource;

/** \brief Enum for status register.
 */
typedef enum
{
    IfxPmsEvr_StatusRegister_interrupt     = 0,  /**< \brief Interrupt status register */
    IfxPmsEvr_StatusRegister_pad           = 1,  /**< \brief PAD status regsiter */
    IfxPmsEvr_StatusRegister_wakeupstat0   = 2,  /**< \brief wakeup status regsiter0 */
    IfxPmsEvr_StatusRegister_wakeupstat1   = 3,  /**< \brief wakeup status regsiter1 */
    IfxPmsEvr_StatusRegister_wakeuptimer   = 4,  /**< \brief wakeup timer status register */
    IfxPmsEvr_StatusRegister_scr           = 5,  /**< \brief scr status register */
    IfxPmsEvr_StatusRegister_evrcstat0     = 6,  /**< \brief EVRC Status 0 register */
    IfxPmsEvr_StatusRegister_evrcstat1     = 7,  /**< \brief EVRC Status 1 register */
    IfxPmsEvr_StatusRegister_powerdomain   = 8,  /**< \brief Power domain Status Register 0 */
    IfxPmsEvr_StatusRegister_vmonslvlsel   = 9,  /**< \brief Secondary monitor level selection status register */
    IfxPmsEvr_StatusRegister_coldreset     = 10, /**< \brief cold reset status register */
    IfxPmsEvr_StatusRegister_dietempstatus = 11  /**< \brief Die Temperature Sensor Status Register */
} IfxPmsEvr_StatusRegister;

/** \brief Enumeartion for Synchronisation Input Multiplexer
 */
typedef enum
{
    IfxPmsEvr_SyncInputMultiplexer_open = 0,  /**< \brief Synchronization input open or unconnected */
    IfxPmsEvr_SyncInputMultiplexer_egtm = 1,  /**< \brief eGTM input forwarded to EVRC SMPS regulator */
    IfxPmsEvr_SyncInputMultiplexer_gtm  = 2   /**< \brief GTM input forwarded to EVRC SMPS regulator */
} IfxPmsEvr_SyncInputMultiplexer;

/** \brief Enumeration for over voltage monitoring mode
 */
typedef enum
{
    IfxPmsEvr_UnderVoltageMonitoring_inactive                         = 0, /**< \brief Under-Voltage Monitoring inactive */
    IfxPmsEvr_UnderVoltageMonitoring_lowToHighVoltageTransition       = 1, /**< \brief under-Voltage event is generated when threshold is crossed in lower to higher voltage transition */
    IfxPmsEvr_UnderVoltageMonitoring_highToLowVoltageTransition       = 2, /**< \brief Under-Voltage event is generated when threshold is crossed in higher to lower voltage transition */
    IfxPmsEvr_UnderVoltageMonitoring_eitherDirectionVoltageTransition = 3  /**< \brief Under-Voltage event is generated when threshold is crossed in either direction */
} IfxPmsEvr_UnderVoltageMonitoring;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

typedef struct
{
    volatile void *regAddr;       /**< \brief Register Address to be updated. */
    uint32         value;         /**< \brief Register value to be updated. */
    uint32         mask;          /**< \brief Mask to select the bit fields to be updated. */
} IfxPmsEvr_StepDownRegulatorRegConfig;

typedef struct
{
    uint8                                           numOfRegisters;      /**< \brief Number of Register. */
    IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;           /**< \brief Register configuration. */
    uint32                                          waitInMicroSec;      /**< \brief Wait in microseconds. */
} IfxPmsEvr_InitSequencePhase;

/** \brief Register configuration
 */
typedef struct
{
    volatile void *reg;          /**< \brief Register address */
    uint32         value;        /**< \brief Value to be written to register */
} IfxPmsEvr_RegConfig;

/** \addtogroup IfxLld_Pms_Std_Evr_Module
 * \{ */
/** \brief Configuration of DCDC
 */
typedef struct
{
    uint16                                  samplingFactor;       /**< \brief Regulator Switching Frequency EVRC_CON1.SDFREQ */
    uint8                                   freqSprdValue;        /**< \brief Frequency spreading configuration. EVRC_CON1.SDFREQSPRD */
    uint8                                   hystWindow;           /**< \brief Hysteresis Window. EVRC_CON1.SYNCHYST */
    uint8                                   maxDeviation;         /**< \brief Maximum Deviation of the Synchronization Input Frequency.EVRC_CON1.SYNMAXDEV */
    IfxPmsEvr_SyncInputMultiplexer          syncInput;            /**< \brief Synchronisation Input Multiplexer.EVRC_CON3.SYNCMUXSEL */
    IfxPmsEvr_ExtSyncSwitchingFreqDivFactor divider;              /**< \brief Switching frequency division factor for external synchronisation.EVRC_CON3.SYNCDIVFAC */
    boolean                                 dcdcSyncInput;        /**< \brief EVRC Input Synchronization Enable/Disable.EVRC_CON3.SYNCIN */
} IfxPmsEvr_DcdcConfig;

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_Data Structures
 * \{ */
/** \brief Configuration of Primary Monitor
 */
typedef struct
{
    float32 underVoltage;             /**< \brief Under Voltage threshold value in milli Volts . */
    float32 overVoltage;              /**< \brief Over Voltage threshold value in mili Volts */
    uint8   filter;                   /**< \brief Alarm Spike Filter */
    boolean underVoltageEnable;       /**< \brief Under Voltage Alarm Enable. */
    boolean overVoltageEnable;        /**< \brief Over Voltage Alarm Enable. */
} IfxPmsEvr_PrimaryMonitorConfig;

/** \brief Configuration of Secondary monitor
 */
typedef struct
{
    float32                          underVoltage;           /**< \brief Under Voltage threshold value in milli Volt */
    float32                          overVoltage;            /**< \brief Over Voltage threshold value in milli Volts */
    uint8                            filter;                 /**< \brief Secondary ADC Supply Filter */
    IfxPmsEvr_UnderVoltageMonitoring underVoltageMode;       /**< \brief Under-Voltage Monitoring Mode */
    IfxPmsEvr_OverVoltageMonitoring  overVoltageMode;        /**< \brief Over-Voltage Monitoring Mode */
} IfxPmsEvr_SecondaryMonitorConfig;

/** \brief TRISTATE configuration
 */
typedef struct
{
    boolean                      tristateEnable_All;           /**< \brief Tristate Enable for all Pads */
    boolean                      tristateEnable_Standby;       /**< \brief Tristate Enable for Standby Pads */
    boolean                      esr0PullDown;                 /**< \brief ESR0 Pull-Down Enable */
    boolean                      esr2PullDown;                 /**< \brief ESR2 is Pulled Down in Case of STBY to RUN Transition */
    IfxPmsEvr_PorstDigitalFilter digitalFilterEnable;          /**< \brief PORST Digital Filter Enable */
} IfxPmsEvr_TristateConfig;

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_PeakVoltage
 * \{ */
/** \brief Configuration for Peak Voltage detection for Vdd,Vddext and Vddextdc
 */
typedef struct
{
    uint16                               threshold;            /**< \brief Threshold for Peak voltage detection */
    IfxPmsEvr_PeakDetectionVoltageSource source;               /**< \brief Peak detection voltage source */
    boolean                              lpfEnable;            /**< \brief low pass filter enable. */
    boolean                              swReset;              /**< \brief Restart the peak voltage detection cycle. */
    boolean                              enablePeakVolt;       /**< \brief Enable/Disable peak volt detection. */
} IfxPmsEvr_PeakVoltageConfig;

/** \} */

typedef struct
{
    uint8                                           numOfRegisters;      /**< \brief Number of Register. */
    IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;           /**< \brief Register configuration. */
} IfxPmsEvr_CheckRegConfig;

/** \brief Configuration for voltage scaling of EVRC
 */
typedef struct
{
    float32                          secondaryOverVoltage;        /**< \brief Secondary over Voltage threshold value in milli Volt */
    float32                          secondaryUnderVoltage;       /**< \brief Secondary under Voltage threshold value in milli Volts */
    float32                          primaryOverVoltage;          /**< \brief Primary Over Voltage threshold value in milli Volt */
    float32                          primaryUnderVoltage;         /**< \brief Primary Under Voltage threshold value in milli Volt */
    float32                          resetTrimValue;              /**< \brief VDD supply reset trim value for new set point voltage */
    IfxPmsEvr_ErrorHandler           errorHandler;                /**< \brief Callback if SDVOK is not set( new output setpoint is not reached). */
    IfxPmsEvr_UnderVoltageMonitoring underVoltageMode;            /**< \brief Secondary Under-Voltage Monitoring Mode to be set after successful voltage scaling */
    IfxPmsEvr_OverVoltageMonitoring  overVoltageMode;             /**< \brief Secondary Over-Voltage Monitoring Mode to be set after successful voltage scaling */
} IfxPmsEvr_EvrcVoltScalingConfig;

/** \brief Configuration for voltage scaling
 */
typedef struct
{
    float32 secondaryOverVoltage;        /**< \brief Secondary over Voltage threshold value in milli Volt */
    float32 secondaryUnderVoltage;       /**< \brief Secondary under Voltage threshold value in milli Volts */
    float32 primaryOverVoltage;          /**< \brief Primary Over Voltage threshold value in milli Volt */
    float32 primaryUnderVoltage;         /**< \brief Primary under Voltage threshold value in milli Volt */
    float32 resetTrimValue;              /**< \brief VDD supply reset trim value for new set point voltage in milli Volt */
} IfxPmsEvr_ExternalVoltScalingConfig;

typedef struct
{
    uint8                                  numOfPhases;       /**< \brief Number of Phases. */
    IFX_CONST IfxPmsEvr_InitSequencePhase *phaseConfig;       /**< \brief Phase configuration. */
} IfxPmsEvr_InitSequence;

typedef struct
{
    IFX_CONST IfxPmsEvr_RegConfig *regConfig;       /**< \brief Register configuration */
    uint32                         numOfReg;        /**< \brief Number of registers */
} IfxPmsEvr_SecMonSupplyRailsConfig;

/** \addtogroup IfxLld_Pms_Std_Evr_Module
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disable Interrupts
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_disableInterrupt(&MODULE_PMS, IfxPmsEvr_Interrupt_ovvdevrsb);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_disableInterrupt(Ifx_PMS *pms, IfxPmsEvr_Interrupt interruptType);

/** \brief Enable Interrupts
 * \param pms Pointer to PMS Module
 * \param interruptType Select The Interrupt Type
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_enableInterrupt(&MODULE_PMS, IfxPmsEvr_Interrupt_uvvdevrsb);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_enableInterrupt(Ifx_PMS *pms, IfxPmsEvr_Interrupt interruptType);

/** \brief Returns the status value of peak voltage detection status register for the selected supply or the history status register of the supply.
 * \param pms Pointer to PMS module.
 * \param source Enum for Peak detection voltage source
 * \return Returns status value of Peak voltage detection status register,
 *
 * Coding example:
 * \code
 *   uint32 status;
 *   status = IfxPmsEvr_getPeakVoltageDetectionStatusRegister(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageStatus_vdd);
 * \endcode
 *
 */
IFX_INLINE uint32 IfxPmsEvr_getPeakVoltageDetectionStatusRegister(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageStatus source);

/** \brief Returns the status value of drift monitor status register for the selected supply.
 * \param pms Pointer to PMS module
 * \param source Enum for drift monitor voltage source
 * \return Returns status value of drift monitor status register,
 *
 * Coding example:
 * \code
 *   uint32 status;
 *   status = IfxPmsEvr_getDriftMonitorStatusRegister(&MODULE_PMS, IfxPmsEvr_DriftMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE uint32 IfxPmsEvr_getDriftMonitorStatusRegister(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source);

/** \brief Return the value of the selected status register.
 * \param pms Pointer to PMS module.
 * \param reg Enum for status regsiter.
 * \return Returns status value of selected status register,
 *
 * Coding example:
 * \code
 *   uint32 status;
 *   status = IfxPmsEvr_getStatusRegister(&MODULE_PMS, IfxPmsEvr_StatusRegister_pad);
 * \endcode
 *
 */
IFX_INLINE uint32 IfxPmsEvr_getStatusRegister(Ifx_PMS *pms, IfxPmsEvr_StatusRegister reg);

/** \brief Function clears the cold reset status register. (CLDRSTRIGL, CLDRSTRIG, CLDRSTSTAT)
 * \param pms Pointer to PMS module sfr.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_clearColdResetStatusReg(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_clearColdResetStatusRegister(Ifx_PMS *pms);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure tristate
 * \param pms Pointer to PMS module.
 * \param config Configuration for TRISTATE.
 * \return None
 *
 * Coding example:
 * \code
 *   //Declare global
 *   IfxPmsEvr_TristateConfig tristateConfig;
 *   tristateConfig.tristateEnable_All     = FALSE;
 *   tristateConfig.tristateEnable_Standby = FALSE;
 *   tristateConfig.esr0PullDown           = FALSE;
 *   tristateConfig.esr2PullDown           = FALSE;
 *   tristateConfig.digitalFilterEnable    = IfxPmsEvr_PorstDigitalFilter_analogfilter;
 *
 *   IfxPmsEvr_configureTristate(&MODULE_PMS, &tristateConfig);
 *
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsEvr_configureTristate(Ifx_PMS *pms, IfxPmsEvr_TristateConfig *config);

/** \brief Configuration for DCDC synchronisation
 * \param pms Pointer to PMS module
 * \param dcdcConfig Pointer to DCDC configuration
 * \return 0 --> DCDC configuration was successful.
 * 1 --> DCDC configuration was not successful. EVRC is off.
 *
 * Coding example:
 * \code
 *  //Declare global
 *  IfxPmsEvr_DcdcConfig config;
 *  config.outputVoltage = miili_volt;
 *  config.samplingFactor = 0x100;
 *  conifg.freqSprdValue  = 0;
 *  config.hystWindow     = 0;
 *  config.maxDeviation   = 0;
 *  config.syncInput      = IfxPmsEvr_SyncInputMultiplexer_open;
 *  config.divider        = IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_1;
 *  config.dcdcSyncInput  = FALSE;
 *
 *   boolean status;
 *   status = IfxPmsEvr_DcdcConfiguration(&MODULE_PMS, &config);
 *
 * \endcode
 *
 * \see IfxPmsEvr_setSdRegulatorOutputLevel(), IfxPmsEvr_setFrequencySpread(), IfxPmsEvr_setRegulatorSwitchingFrequency()
 *   IfxPmsEvr_setSyncHysteresisWindow(), IfxPmsEvr_setMaxDeviationOfSyncFreq(), IfxPmsEvr_selectSyncInputMultiplexer()
 *   IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(), IfxPmsEvr_enableDcdcSynchronisation()
 *
 */
IFX_EXTERN boolean IfxPmsEvr_dcdcConfiguration(Ifx_PMS *pms, IfxPmsEvr_DcdcConfig *dcdcConfig);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_EVRC
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function enables the DCDC synchronisation for input/output
 * \param pms Pointer to PMS Module
 * \param sync Selection for input or output DCDC synchronisation enable
 * \param enabled enable/disable DC-DC synchronisation
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_enableDcdcSynchronisation(&MODULE_PMS, IfxPmsEvr_DcdcSynchronization_input, TRUE); //To enable
 *   IfxPmsEvr_enableDcdcSynchronisation(&MODULE_PMS, IfxPmsEvr_DcdcSynchronization_input, FALSE); //To disable
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_enableDcdcSynchronisation(Ifx_PMS *pms, IfxPmsEvr_DcdcSynchronization sync, boolean enabled);

/** \brief get EVRC Regulator Voltage OK status
 * \param pms Pointer to PMS Module Space
 * \return EVRC Regulator Voltage OK status
 *
 * Coding example:
 * \code
 *   if( IfxPmsEvr_getEvrcVoltageRegulatorStatus(&MODULE_PMS) )
 *   {
 *     //
 *   }
 * \endcode
 *
 */
IFX_INLINE boolean IfxPmsEvr_getEvrcVoltageRegulatorStatus(Ifx_PMS *pms);

/** \brief set frequency spread threshold
 * \param pms pointer to PMS module
 * \param freqSprdValue maximum frequency spreading value
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_setFrequencySpread(&MODULE_PMS, usr_value);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setFrequencySpread(Ifx_PMS *pms, uint8 freqSprdValue);

/** \brief Sets the switching frequency during closed-loop PWM phase
 * \param pms Pointer to PMS Module
 * \param samplingFactor Over-sampling Factor
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_setRegulatorSwitchingFrequency(&MODULE_PMS, usr_value);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setRegulatorSwitchingFrequency(Ifx_PMS *pms, uint16 samplingFactor);

/** \brief EVRC Regulator Output Voltage Target Value
 * \param pms Pointer to PMS Module
 * \param outputVoltage The VDD output voltage in mv of the Step down regulator
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_setSdRegulatorOutputLevel(&MODULE_PMS, usr_value);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setSdRegulatorOutputLevel(Ifx_PMS *pms, float32 outputVoltage);

/** \brief Set Switching frequency division factor for external synchronisation.
 * \param pms Pointer To PMS Module
 * \param divider Switching frequency division factor for external synchronisation
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(&MODULE_PMS, IfxPmsEvr_ExtSyncSwitchingFreqDivFactor_1);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(Ifx_PMS *pms, IfxPmsEvr_ExtSyncSwitchingFreqDivFactor divider);

/** \brief Set hysteresis window for synchronization locking and unlocking.
 * \param pms Pointer To PMS Module
 * \param hystWindow Lock Unlock Hysteresis Window
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_setSyncHysteresisWindow(&MODULE_PMS, usr_value);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setSyncHysteresisWindow(Ifx_PMS *pms, uint8 hystWindow);

/** \brief Set the maximum allowed frequency deviation of the synchronization input signal frequency.
 * \param pms Pointer To PMS Module
 * \param maxDeviation Maximum Deviation of the Synchronization Input Frequency
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_setMaxDeviationOfSyncFreq(&MODULE_PMS, usr_value);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setMaxDeviationOfSyncFreq(Ifx_PMS *pms, uint8 maxDeviation);

/** \brief Set synchronisation input either from GTM or eGTM inputs to be forwarded to EVRC SMPS regulator.
 * \param pms Pointer To PMS Module
 * \param syncInput Options for Synchronisation Input Multiplexer
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_selectSyncInputMultiplexer(&MODULE_PMS, IfxPmsEvr_SyncInputMultiplexer_open);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_selectSyncInputMultiplexer(Ifx_PMS *pms, IfxPmsEvr_SyncInputMultiplexer syncInput);

/** \brief Function to get EVRC synchronization lock status
 * \param pms Pointer To PMS Module
 * \return Returns lock status
 * TRUE --> EVRC and VGATE output edge is synchronized to external DCDCSYNCI input signal.
 * FALSE --> EVRC is not currently synchronized to external DCDCSYNCI input signal.
 *
 * Coding example:
 *  \code
 *    while(!IfxPmsEvr_getSyncLockStatus(&MODULE_PMS))
 *    {
 *      //wait
 *    }
 *  \endcode
 *
 */
IFX_INLINE boolean IfxPmsEvr_getSyncLockStatus(Ifx_PMS *pms);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_Primary Monitor
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Get ADC result for selected primary monitor voltage source.
 * \param pms Pointer to PMS Module
 * \param source Enumeration for Primary monitor voltage source
 * \return Returns ADC conversion result for selected supply.
 *
 * Coding example:
 * \code
 *  uint16 result;
 *  result = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE uint16 IfxPmsEvr_getPrimaryMonitorResult(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource source);

/** \brief Returns the status value of primary monitor status register for the  selected supply.
 * \param pms Pointer to PMS module.
 * \param source Enum for Primary monitor volatge source.
 * \return Returns status value of Primary Monitor status register,
 *
 * Coding example:
 * \code
 *  uint32 status;
 *  status = IfxPmsEvr_getPrimaryMonitorStatusRegister(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE uint32 IfxPmsEvr_getPrimaryMonitorStatusRegister(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource source);

/** \brief Get ADC converted result for selected primary monitor voltage source in milli Volts.
 * \param pms Pointer to PMS module.
 * \param source Enum for Primary monitor volatge source.
 * \return Primary monitor voltage conversion result.
 *
 * Coding example:
 * \code
 *  float32 volt_value;
 *  volt_value = IfxPmsEvr_getPrimaryMonitorResultMv(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE float32 IfxPmsEvr_getPrimaryMonitorResultMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource source);

/** \brief Set Primary monitor under voltage threshold.
 * \param pms Pointer to PMS module.
 * \param underVoltage Primary monitor under voltage threshold in millivolts.
 * \param supply Primary monitor voltage source.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setPrimaryUnderVoltageThresholdMv(&MODULE_PMS, usr_value, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setPrimaryUnderVoltageThresholdMv(Ifx_PMS *pms, float32 underVoltage, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief Set Primary monitor over voltage threshold.
 * \param pms Pointer to PMS module.
 * \param overVoltage Primary monitor over voltage threshold in milliVolts.
 * \param supply Primary monitor voltage source.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setPrimaryOverVoltageThresholdMv(&MODULE_PMS, usr_value, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setPrimaryOverVoltageThresholdMv(Ifx_PMS *pms, float32 overVoltage, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief Enable Primary monitor under voltage alarm.
 * \param pms Pointer to PMS module
 * \param supply Primary monitor voltage source
 * \param enable Enable/Disable under voltage alarm.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_enablePrimaryUnderVoltageAlarm(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd, TRUE);
 *  // To disable
 *  IfxPmsEvr_enablePrimaryUnderVoltageAlarm(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd, FALSE);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_enablePrimaryUnderVoltageAlarm(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply, boolean enable);

/** \brief Enable/Disable Primary monitor over voltage alarm
 * \param pms Pointer to PMS module.
 * \param supply Primary monitor voltage source.
 * \param enable Enable/Disable over voltage alarm.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_enablePrimaryOverVoltageAlarm(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd, TRUE);
 *  // To disable
 *  IfxPmsEvr_enablePrimaryOverVoltageAlarm(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd, FALSE);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_enablePrimaryOverVoltageAlarm(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply, boolean enable);

/** \brief API to get primary under voltage threshold in mV.
 * \param pms Pointer to PMS module.
 * \param supply Primary monitor voltage source.
 * \return Returns primary under voltage in milli-Volts.
 *
 * Coding example:
 * \code
 *  uint16 vddUvMv;
 *  vddUvMv = IfxPmsEvr_getPrimaryUnderVoltageThresholdMv(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE uint16 IfxPmsEvr_getPrimaryUnderVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief API to get primary over voltage threshold in mV.
 * \param pms Pointer to PMS module.
 * \param supply Primary monitor voltage source.
 * \return Returns primary over voltage in milli-Volts.
 *
 * Coding example:
 * \code
 *  uint16 vddOvMv;
 *  vddOvMv = IfxPmsEvr_getPrimaryOverVoltageThresholdMv(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE uint16 IfxPmsEvr_getPrimaryOverVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief API to get primary reset voltage threshold in mV.
 * \param pms Pointer to PMS module.
 * \param supply Primary monitor voltage source.
 * \return Returns primary reset voltage in milli-Volts.
 *
 * Coding example:
 * \code
 *  uint16 vddRstMv;
 *  vddRstMv = IfxPmsEvr_getRstVoltageThresholdMv(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE uint16 IfxPmsEvr_getRstVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief API to set primary reset voltage threshold.
 * \param pms Pointer to PMS module.
 * \param voltage Voltage value in mV.
 * \param supply Primary monitor voltage source.
 * \return None
 */
IFX_INLINE void IfxPmsEvr_setRstVoltageThresholdMv(Ifx_PMS *pms, uint16 voltage, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief API to get primary under voltage alarm enable status
 * \param pms Pointer to PMS module.
 * \param supply Primary monitor voltage source.
 * \return TRUE --> Under voltage alarm enabled
 *  FALSE --> Under voltage alarm disabled
 *
 * Coding example:
 * \code
 * boolean uvAlmStatus;
 *  uvAlmStatus = IfxPmsEvr_getPrimaryUnderVoltageAlarmEnabledStatus(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE boolean IfxPmsEvr_getPrimaryUnderVoltageAlarmEnabledStatus(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief API to get primary over voltage alarm enable status
 * \param pms Pointer to PMS module.
 * \param supply Primary monitor voltage source.
 * \return TRUE --> Over voltage alarm enabled
 *  FALSE --> Over voltage alarm disabled
 *
 * Coding example:
 * \code
 * boolean ovAlmStatus;
 *  ovAlmStatus = IfxPmsEvr_getPrimaryUnderVoltageAlarmEnabledStatus(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE boolean IfxPmsEvr_getPrimaryOverVoltageAlarmEnabledStatus(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure primary monitor for selected voltage source with configured values.
 * \param pms Pointer to PMS module.
 * \param source Enum for Primary monitor volatge source.
 * \param config Pointer to the configuration of VMONP.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_PrimaryMonitorConfig config;
 *  config.underVoltage        = uv_mv;
 *  config.overVoltage         = ov_mv;
 *  config.filter              = filt_value;
 *  config.underVoltageEnable  = FALSE;
 *  config.overVoltageEnable   = FALSE;
 *  IfxPmsEvr_configurePrimaryMonitor(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd, &config);
 *
 * OR
 *
 * IfxPmsEvr_PrimaryMonitorConfig config = {uv_mv, ov_mv, filt_value, FALSE, FALSE};
 * IfxPmsEvr_configurePrimaryMonitor(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd, &config);
 * \endcode
 *
 * \see IfxPmsEvr_setPrimaryUnderVoltageThresholdMv(), IfxPmsEvr_setPrimaryOverVoltageThresholdMv()
 *
 */
IFX_EXTERN void IfxPmsEvr_configurePrimaryMonitor(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource source, IfxPmsEvr_PrimaryMonitorConfig *config);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_Secondary Monitor
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief set Over Voltage Monitoring Mode
 * \param pms pointer to the Module space
 * \param mode specifies the monitoring mode
 * \param supply select secondary monitor voltage source
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setOverVoltageMonitoringMode(&MODULE_PMS, IfxPmsEvr_OverVoltageMonitoring_inactive, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_OverVoltageMonitoring mode, IfxPmsEvr_SecondaryMonitorVoltageSource supply);

/** \brief set Secondary Over Voltage Threshold level
 * \param pms Pointer to PMS Module
 * \param inputVoltage Over-voltage value in millivolts.
 * \param supply select secondary monitor voltage source.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setSecondaryOverVoltageThresholdMv(&MODULE_PMS, usr_value, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setSecondaryOverVoltageThresholdMv(Ifx_PMS *pms, float32 inputVoltage, IfxPmsEvr_SecondaryMonitorVoltageSource supply);

/** \brief set Secondary under Voltage Threshold level
 * \param pms Pointer to PMS Module space
 * \param inputVoltage Under-voltage value in millivolts.
 * \param supply select secondary monitor voltage source.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(&MODULE_PMS, usr_value, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(Ifx_PMS *pms, float32 inputVoltage, IfxPmsEvr_SecondaryMonitorVoltageSource supply);

/** \brief set Under Voltage Monitoring mode
 * \param pms Pointer to the PMS Module space
 * \param mode specifies the monitoring mode
 * \param supply select secondary monitor voltage source.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setUnderVoltageMonitoringMode(&MODULE_PMS, IfxPmsEvr_UnderVoltageMonitoring_inactive, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_UnderVoltageMonitoring mode, IfxPmsEvr_SecondaryMonitorVoltageSource supply);

/** \brief Get ADC result for secondary monitor voltage source.
 * \param pms Pointer to PMS module
 * \param source Enumeration for Secondary monitor voltage source.
 * \return Returns ADC conversion result for selected supply.
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_getSecondaryMonitorResult(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE uint16 IfxPmsEvr_getSecondaryMonitorResult(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source);

/** \brief Returns the status value of secondary monitor status register for the selected supply.
 * \param pms Pointer to PMS module.
 * \param source Enum for Secondary monitor volatge source.
 * \return Returns status value of Secondary Monitor status register,
 *
 * Coding example:
 * \code
 *  uint32 status;
 *  status = IfxPmsEvr_getSecondaryMonitorStatusRegister(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE uint32 IfxPmsEvr_getSecondaryMonitorStatusRegister(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source);

/** \brief Get ADC converted result for selected secondary monitor voltage source in milli Volts.
 * \param pms Pointer to PMS module.
 * \param source Enum for Secondary monitor voltage source.
 * \return Secondary monitor voltage conversion result.
 *
 * Coding example:
 * \code
 *  float32 result;
 *  result = IfxPmsEvr_getSecondaryMonitorResultMv(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE float32 IfxPmsEvr_getSecondaryMonitorResultMv(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source);

/** \brief Get secondary monitor under voltage threshold in milli Volts.
 * \param pms Pointer to PMS module.
 * \param source Enum for Secondary monitor voltage source.
 * \return Secondary monitor under voltage in milli-volts
 *
 * Coding example:
 * \code
 *  uint16 vddUvMv;
 *  vddUvMv = IfxPmsEvr_getSecondaryUnderVoltageThresholdMv(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE uint16 IfxPmsEvr_getSecondaryUnderVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source);

/** \brief Get secondary monitor over voltage threshold in milli Volts.
 * \param pms Pointer to PMS module.
 * \param source Enum for Secondary monitor voltage source.
 * \return Secondary monitor over voltage in milli-volts
 *
 * Coding example:
 * \code
 *  uint16 vddOvMv;
 *  vddOvMv = IfxPmsEvr_getSecondaryOverVoltageThresholdMv(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE uint16 IfxPmsEvr_getSecondaryOverVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source);

/** \brief Get secondary monitor over voltage monitor mode.
 * \param pms Pointer to PMS module.
 * \param supply Enum for Secondary monitor voltage source.
 * \return Returns over voltage monitor mode
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_OverVoltageMonitoring mode;
 *  mode = IfxPmsEvr_getOverVoltageMonitoringMode(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE IfxPmsEvr_OverVoltageMonitoring IfxPmsEvr_getOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource supply);

/** \brief Get secondary monitor under voltage monitor mode.
 * \param pms Pointer to PMS module.
 * \param supply Enum for Secondary monitor voltage source.
 * \return Returns under voltage monitor mode
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_UnderVoltageMonitoring mode;
 *  mode = IfxPmsEvr_getUnderVoltageMonitoringMode(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
 * \endcode
 */
IFX_INLINE IfxPmsEvr_UnderVoltageMonitoring IfxPmsEvr_getUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource supply);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure secondary monitor for selected voltage source with configured values.
 * \param pms Pointer to PMS module.
 * \param source Enum for Secondary monitor volatge source.
 * \param config Pointer to the configuration of VMONS.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_SecondaryMonitorConfig config;
 *  config.underVoltage        = uv_mv;
 *  config.overVoltage         = ov_mv;
 *  config.filter              = filt_value;
 *  config.underVoltageMode    = IfxPmsEvr_UnderVoltageMonitoring_inactive;
 *  config.overVoltageMode     = IfxPmsEvr_OverVoltageMonitoring_inactive;
 *  IfxPmsEvr_configureSecondaryMonitor(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd, &config);
 *
 * OR
 *
 * IfxPmsEvr_SecondaryMonitorConfig config = {uv_mv, ov_mv, filt_value, IfxPmsEvr_UnderVoltageMonitoring_inactive, IfxPmsEvr_OverVoltageMonitoring_inactive};
 * IfxPmsEvr_configureSecondaryMonitor(&MODULE_PMS, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd, &config);
 * \endcode
 *
 * \see IfxPmsEvr_setUnderVoltageMonitoringMode(), IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(),
 *      IfxPmsEvr_setSecondaryOverVoltageThresholdMv(), IfxPmsEvr_setOverVoltageMonitoringMode()
 *
 */
IFX_EXTERN void IfxPmsEvr_configureSecondaryMonitor(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source, IfxPmsEvr_SecondaryMonitorConfig *config);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_PeakVoltage
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable/Disable the Peak detection voltage for the given supply rail.
 * \param pms Pointer to PMS module.
 * \param supply Peak detection voltage source selection for Vdd,Vddext and Vddextdc
 * \param enable enable/disable voltage peak detection
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setPeakVoltageDetectionEnable(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageSource_vdd, TRUE);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionEnable(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply, boolean enable);

/** \brief Enable/Disable the Low-Pass Filtering of the recorded peak values for the given supply rail.
 * \param pms Pointer to PMS module.
 * \param supply Peak detection voltage source selection for Vdd,Vddext and Vddextdc
 * \param enable enable/disable the low pass filter.
 * \return None
 *
 * Coding example:
 * \code
 *  IfxPmsEvr_setPeakVoltageDetectionLpfEnable(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageSource_vddext, TRUE);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionLpfEnable(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply, boolean enable);

/** \brief Set threshold value for Peak Voltage Detection.
 * \param pms Pointer to PMS module.
 * \param supply Peak detection voltage source selection for Vdd,Vddext and Vddextdc
 * \param threshold Threshold value for Peak Voltage Detection.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPmsEvr_setpeakVoltageDetectionThreshold(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageSource_vddext, 0x8532);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionThreshold(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply, uint16 threshold);

/** \brief This api will restart the peak voltage detection cycle for the given supply rail.
 * \param pms Pointer to PMS module.
 * \param supply Peak detection voltage source selection for Vdd,Vddext and Vddextdc
 * \return None
 *
 * Coding example:
 * \code
 * IfxPmsEvr_setPeakVoltageDetectionReset(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageSource_vddext);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionReset(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply);

/** \brief Returns the PEAKVOLT value for the selected supply .
 * \param pms Pointer to PMS module.
 * \param supply Peak detection voltage source selection for Vdd,Vddext and Vddextdc
 * \return Returns PEAKVOLT value from PEAK.VxxSTAT.B.PEAKVOLT
 *
 * Coding example:
 * \code
 * uint16 volt_value
 * volt_value = IfxPmsEvr_getPeakVoltageDetectedValue(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageSource_vddext);
 * \endcode
 *
 */
IFX_INLINE uint16 IfxPmsEvr_getPeakVoltageDetectedValue(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply);

/** \brief Returns the PEAKVOLT value for the selected supply in the  milliVolts.
 * \param pms Pointer to PMS module.
 * \param supply Peak detection voltage source selection for Vdd,Vddext and Vddextdc
 * \return Returns PEAKVOLT value in MV.
 *
 * Coding example:
 * \code
 * float32 volt_value
 * volt_value = IfxPmsEvr_getPeakVoltageDetectedValueinMv(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageSource_vddext);
 * \endcode
 *
 */
IFX_INLINE float32 IfxPmsEvr_getPeakVoltageDetectedValueinMv(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply);

/** \brief Returns the threshold count value for the selected supply .
 * \param pms Pointer to PMS module.
 * \param supply Peak detection voltage source selection for Vdd,Vddext and Vddextdc
 * \return Returns theshold count value from PEAK.VxxSTAT.B.THRESCOUNT
 *
 * Coding example:
 * \code
 * IfxPmsEvr_getPeakVoltageDetectionThresCount(&MODULE_PMS, IfxPmsEvr_PeakDetectionVoltageSource_vddext);
 * \endcode
 *
 */
IFX_INLINE uint32 IfxPmsEvr_getPeakVoltageDetectionThresCount(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configuration of the selected supply for peak voltage detection.
 * \param pms Pointer to PMS module.
 * \param config Configuration values for peak voltage detection
 * \return None
 *
 * Coding example:
 * \code
 * IfxPmsEvr_PeakVoltageConfig config;
 * config.threshold        = usr_value;
 * config.source           = IfxPmsEvr_PeakDetectionVoltageSource_vdd;
 * config.lpfEnable        = FALSE;
 * config.swReset          = FALSE;
 * config.enablePeakVolt   = FALSE;
 * IfxPmsEvr_peakVoltageDetectionConfiguration(&MODULE_PMS, &config);
 * \endcode
 *
 * \see  IfxPmsEvr_setPeakVoltageDetectionReset(), IfxPmsEvr_setPeakVoltageDetectionThreshold()
 *      IfxPmsEvr_setPeakVoltageDetectionLpfEnable(), IfxPmsEvr_setPeakVoltageDetectionEnable()
 *
 */
IFX_EXTERN void IfxPmsEvr_peakVoltageDetectionConfiguration(Ifx_PMS *pms, IfxPmsEvr_PeakVoltageConfig *config);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Evr_DriftMonitor
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable/Disable drift monitoring for the selected supply rail.
 * \param pms Pointer to PMS module
 * \param source Drift Monioring voltage source selection
 * \param enable Enable/Disable drift monitoring.
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsEvr_enableDriftMonitoring(&MODULE_PMS, IfxPmsEvr_DriftMonitoringVoltageSource_vdd, TRUE);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_enableDriftMonitoring(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source, boolean enable);

/** \brief Set drift monitoring down sampling factor for the selected supply rail.
 * \param pms Pointer to PMS module
 * \param source Drift Monioring voltage source selection
 * \param downSamplingfactor Drift monitoring downsampling factor.
 * \return None
 *
 * Coding example:
 * \code
 * IfxPmsEvr_setDriftMonitoringFactor(&MODULE_PMS, IfxPmsEvr_DriftMonitoringVoltageSource_vdd, factor);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsEvr_setDriftMonitoringFactor(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source, uint8 downSamplingfactor);

/** \brief Get drift monitoring average for the selected supply rail.
 * \param pms Pointer to PMS module
 * \param source Drift Monioring voltage source selection
 * \return Returns Average value for the selected supply.
 *
 * Coding example:
 * \code
 * uint16 avg_value;
 * avg_value = IfxPmsEvr_getDriftMonitoringAverage(&MODULE_PMS, IfxPmsEvr_DriftMonitoringVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE uint16 IfxPmsEvr_getDriftMonitoringAverage(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source);

/** \brief Get drift monitoring average voltage in mv for the selected supply rail.
 * \param pms Pointer to PMS module
 * \param source Drift Monioring voltage source selection
 * \return Returns Average value for the selected supply.
 *
 * Coding example:
 * \code
 * float32 avg_value_mv;
 * avg_value_mv = IfxPmsEvr_getDriftMonitoringAverageVoltageMv(&MODULE_PMS, IfxPmsEvr_DriftMonitoringVoltageSource_vdd);
 * \endcode
 *
 */
IFX_INLINE float32 IfxPmsEvr_getDriftMonitoringAverageVoltageMv(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to enable MONBIST
 * \param config Pointer to the configuration structure
 * \return None
 */
IFX_INLINE void IfxPmsEvr_startMonBist(const IfxPmsEvr_SecMonSupplyRailsConfig *config);

/** \brief Function to run initialization sequence
 * \param sequence Pointer to the sequence of configuration
 * \return None
 */
IFX_INLINE boolean IfxPmsEvr_runInitSequence(const IfxPmsEvr_InitSequence *const sequence);

/** \brief Function to get delay in microseconds.
 * \param waitInMicroSec wait period in micro seconds.
 * \return None
 */
IFX_INLINE void IfxPmsEvr_wait(uint32 waitInMicroSec);

/** \brief Function to verify Evr values.
 * \param checkConfig wait period in micro seconds.
 * \return Returns status
 * True --> Init values configured correctly.
 * False --> Init values not configured correctly.
 */
IFX_INLINE boolean IfxPmsEvr_areInitValuesRight(const IfxPmsEvr_CheckRegConfig *const checkConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function provides internal monitoring threshold adaption.
 * Intialization of external interface and subsequent steps has to be taken care by the application.
 * \param pms Pointer to PMS module sfr
 * \param config Pointer to configuration
 * \return Voltage identification value (VID_CON)
 */
IFX_EXTERN uint32 IfxPmsEvr_scaleExtVoltageSetup(Ifx_PMS *pms, IfxPmsEvr_ExternalVoltScalingConfig *config);

/** \brief Function does internal monitoring threshold adaptation and voltage scaling trigger. API will poll for 20us for SDVOK bit to set. If it takes more than 20us error handler will be invoked if configured by the user. If the voltage scaling is successful then monitor alarms will be renabled.
 * \param pms Pointer to pms module sfr
 * \param config Evr voltage scaling configuration
 * \return Returs TRUE   --> Volage scaling is successful
 *             FALSE --> Voltage scaling not successful
 */
IFX_EXTERN boolean IfxPmsEvr_scaleEvrVoltage(Ifx_PMS *pms, IfxPmsEvr_EvrcVoltScalingConfig *config);

/** \brief Enable voltage rail in ASSW.
 * \param pms Pointer to PMS Module space
 * \param supply select primary monitor voltage source. Refer User Manual for valid supply source.
 * \return TRUE --> Returns TRUE if supply selected is valid for the API.
 *  FALSE --> Returns FALSE if invalid supply selected
 *
 * Coding example:
 * \code
 *  boolean status;
 *  if(TRUE != IfxPmsEvr_enableVoltageRail(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0)
 *  {
 *      //Invalid supply
 *  }
 * \endcode
 */
IFX_EXTERN boolean IfxPmsEvr_enableVoltageRail(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply);

/** \brief Configures access to all masters to all the PMS in the device
 * \param apConfig pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxPmsEvr_configureAccessToPms(IfxApApu_ApuConfig *apConfig);

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase1Default[];

IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase2Default[];

IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_cfgPhase3Default[];

IFX_EXTERN IFX_CONST IfxPmsEvr_InitSequencePhase          IfxPmsEvr_cfgPhasesDefault[];

IFX_EXTERN IFX_CONST IfxPmsEvr_InitSequence               IfxPmsEvr_cfgSequenceDefault;

IFX_EXTERN IFX_CONST IfxPmsEvr_StepDownRegulatorRegConfig IfxPmsEvr_checkRegValuesDefault[];

IFX_EXTERN IFX_CONST IfxPmsEvr_RegConfig                  IfxPmsEvr_defaultSecondaryMonitorRegConfig[];

IFX_EXTERN IFX_CONST IfxPmsEvr_SecMonSupplyRailsConfig    IfxPmsEvr_defaultSecondaryMonitorSupplyConfig;

IFX_EXTERN IFX_CONST IfxPmsEvr_CheckRegConfig             IfxPmsEvr_verifyRegCfgDefault;

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxPmsEvr_disableInterrupt(Ifx_PMS *pms, IfxPmsEvr_Interrupt interruptType)
{
    uint32 mask;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    if (interruptType < 32)
    {
        mask             = (1U << interruptType);
        pms->INT.CON0.U &= (~mask);
    }
    else if (interruptType < 64)
    {
        mask             = (1U << (interruptType - 32));
        pms->INT.CON1.U &= (~mask);
    }
    else
    {
        mask             = (1U << (interruptType - 64));
        pms->INT.CON2.U &= (~mask);
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_enableDcdcSynchronisation(Ifx_PMS *pms, IfxPmsEvr_DcdcSynchronization sync, boolean enabled)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (sync)
    {
    case IfxPmsEvr_DcdcSynchronization_input:
        pms->EVRC.CON3.B.SYNCIN = enabled;
        break;
    case IfxPmsEvr_DcdcSynchronization_output:
        pms->EVRC.CON3.B.SYNCOUT = enabled;
        break;
    default:
        /* Invalid sync selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_enableInterrupt(Ifx_PMS *pms, IfxPmsEvr_Interrupt interruptType)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    if (interruptType < 32)
    {
        pms->INT.CON0.U |= (1U << interruptType);
    }
    else if (interruptType < 64)
    {
        pms->INT.CON1.U |= (1U << (interruptType - 32));
    }
    else
    {
        pms->INT.CON2.U |= (1U << (interruptType - 64));
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxPmsEvr_getEvrcVoltageRegulatorStatus(Ifx_PMS *pms)
{
    return (boolean)pms->EVRC.STAT0.B.SDVOK;
}


IFX_INLINE void IfxPmsEvr_setFrequencySpread(Ifx_PMS *pms, uint8 freqSprdValue)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->EVRC.CON1.B.SDFREQSPRD = freqSprdValue;
    pms->EVRC.CON0.B.UP         = 1u;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_OverVoltageMonitoring mode, IfxPmsEvr_SecondaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        pms->VMONS.VDDCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        pms->VMONS.VDDEXTCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        pms->VMONS.VDDEXTDCCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        pms->VMONS.VDDEVRSBCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        pms->VMONS.VDDMCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        pms->VMONS.VDDPHPHY0CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        pms->VMONS.VDDPHPHY1CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        pms->VMONS.VDDHSIFCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        pms->VMONS.VDDPPUCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        pms->VMONS.VDDPHY0CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        pms->VMONS.VDDPHY1CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        pms->VMONS.VDDPMS0CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        pms->VMONS.VDDPMS1CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        pms->VMONS.VDDPMS2CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        pms->VMONS.VDDLMU0CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        pms->VMONS.VDDLMU1CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        pms->VMONS.VDDPHPHY2CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        pms->VMONS.VDDPHY2CON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        pms->VMONS.VDDSBRAMCON.B.OVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        pms->VMONS.VDDPADCON.B.OVMOD = mode;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setRegulatorSwitchingFrequency(Ifx_PMS *pms, uint16 samplingFactor)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->EVRC.CON1.B.SDFREQ = samplingFactor;
    pms->EVRC.CON0.B.UP     = 1u;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setSdRegulatorOutputLevel(Ifx_PMS *pms, float32 outputVoltage)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->EVRC.CON0.B.SDVOUTSEL = (uint16)(outputVoltage / IFXPMSEVR_SARHVLSB_MV);
    pms->EVRC.CON0.B.UP        = 1;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setSecondaryOverVoltageThresholdMv(Ifx_PMS *pms, float32 inputVoltage, IfxPmsEvr_SecondaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        pms->VMONS.VDDCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        pms->VMONS.VDDEXTCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        pms->VMONS.VDDEXTDCCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        pms->VMONS.VDDEVRSBCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        pms->VMONS.VDDMCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        pms->VMONS.VDDPHPHY0CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        pms->VMONS.VDDPHPHY1CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        pms->VMONS.VDDHSIFCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        pms->VMONS.VDDPPUCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        pms->VMONS.VDDPHY0CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        pms->VMONS.VDDPHY1CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        pms->VMONS.VDDPMS0CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        pms->VMONS.VDDPMS1CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        pms->VMONS.VDDPMS2CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        pms->VMONS.VDDLMU0CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        pms->VMONS.VDDLMU1CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        pms->VMONS.VDDPHPHY2CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        pms->VMONS.VDDPHY2CON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        pms->VMONS.VDDSBRAMCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        pms->VMONS.VDDPADCON.B.OVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(Ifx_PMS *pms, float32 inputVoltage, IfxPmsEvr_SecondaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        pms->VMONS.VDDCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        pms->VMONS.VDDEXTCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        pms->VMONS.VDDEXTDCCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        pms->VMONS.VDDEVRSBCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        pms->VMONS.VDDMCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        pms->VMONS.VDDPHPHY0CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        pms->VMONS.VDDPHPHY1CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        pms->VMONS.VDDHSIFCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        pms->VMONS.VDDPPUCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        pms->VMONS.VDDPHY0CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        pms->VMONS.VDDPHY1CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        pms->VMONS.VDDPMS0CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        pms->VMONS.VDDPMS1CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        pms->VMONS.VDDPMS2CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        pms->VMONS.VDDLMU0CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        pms->VMONS.VDDLMU1CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        pms->VMONS.VDDPHPHY2CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        pms->VMONS.VDDPHY2CON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        pms->VMONS.VDDSBRAMCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        pms->VMONS.VDDPADCON.B.UVVAL = (uint16)(inputVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setSwitchingFreqDivFactorForExternalsync(Ifx_PMS *pms, IfxPmsEvr_ExtSyncSwitchingFreqDivFactor divider)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->EVRC.CON3.B.SYNCDIVFAC = divider;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_UnderVoltageMonitoring mode, IfxPmsEvr_SecondaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        pms->VMONS.VDDCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        pms->VMONS.VDDEXTCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        pms->VMONS.VDDEXTDCCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        pms->VMONS.VDDEVRSBCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        pms->VMONS.VDDMCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        pms->VMONS.VDDPHPHY0CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        pms->VMONS.VDDPHPHY1CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        pms->VMONS.VDDHSIFCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        pms->VMONS.VDDPPUCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        pms->VMONS.VDDPHY0CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        pms->VMONS.VDDPHY1CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        pms->VMONS.VDDPMS0CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        pms->VMONS.VDDPMS1CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        pms->VMONS.VDDPMS2CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        pms->VMONS.VDDLMU0CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        pms->VMONS.VDDLMU1CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        pms->VMONS.VDDPHPHY2CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        pms->VMONS.VDDPHY2CON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        pms->VMONS.VDDSBRAMCON.B.UVMOD = mode;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        pms->VMONS.VDDPADCON.B.UVMOD = mode;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE uint16 IfxPmsEvr_getPrimaryMonitorResult(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource source)
{
    uint16 result = 0U;

    switch (source)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        result = pms->VMONP.VDDSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        result = pms->VMONP.VDDEXTSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        result = pms->VMONP.VSSDCHSSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        result = pms->VMONP.VDDEXTDCSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        result = pms->VMONP.VDDDCLSSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        result = pms->VMONP.VDDEVRSBSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        result = pms->VMONP.VDDMSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        result = pms->VMONP.VDDPHPHY0STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        result = pms->VMONP.VDDPHPHY1STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        result = pms->VMONP.VDDHSIFSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        result = pms->VMONP.VDDPPUSTAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        result = pms->VMONP.VDDPHY0STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        result = pms->VMONP.VDDPHY1STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        result = pms->VMONP.VDDPHY2STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        result = pms->VMONP.VDDLMU0STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        result = pms->VMONP.VDDLMU1STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        result = pms->VMONP.VDDPHPHY2STAT.B.RESULT;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        result = pms->VMONP.VDDPADSTAT.B.RESULT;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return result;
}


IFX_INLINE uint16 IfxPmsEvr_getSecondaryMonitorResult(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source)
{
    uint16 result = 0U;

    switch (source)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        result = pms->VMONS.VDDSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        result = pms->VMONS.VDDEXTSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        result = pms->VMONS.VDDEXTDCSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        result = pms->VMONS.VDDEVRSBSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        result = pms->VMONS.VDDMSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        result = pms->VMONS.VDDPHPHY0STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        result = pms->VMONS.VDDPHPHY1STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        result = pms->VMONS.VDDHSIFSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        result = pms->VMONS.VDDPPUSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        result = pms->VMONS.VDDPHY0STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        result = pms->VMONS.VDDPHY1STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        result = pms->VMONS.VDDPMS0STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        result = pms->VMONS.VDDPMS1STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        result = pms->VMONS.VDDPMS2STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        result = pms->VMONS.VDDLMU0STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        result = pms->VMONS.VDDLMU1STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        result = pms->VMONS.VDDPHPHY2STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        result = pms->VMONS.VDDPHY2STAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        result = pms->VMONS.VDDSBRAMSTAT.B.RESULT;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        result = pms->VMONS.VDDPADSTAT.B.RESULT;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return result;
}


IFX_INLINE uint32 IfxPmsEvr_getPrimaryMonitorStatusRegister(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource source)
{
    uint32 status = 0U;

    switch (source)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        status = pms->VMONP.VDDSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        status = pms->VMONP.VDDEXTSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        status = pms->VMONP.VSSDCHSSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        status = pms->VMONP.VDDEXTDCSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        status = pms->VMONP.VDDDCLSSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        status = pms->VMONP.VDDEVRSBSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        status = pms->VMONP.VDDMSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        status = pms->VMONP.VDDPHPHY0STAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        status = pms->VMONP.VDDPHPHY1STAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        status = pms->VMONP.VDDHSIFSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        status = pms->VMONP.VDDPPUSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        status = pms->VMONP.VDDPHY0STAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        status = pms->VMONP.VDDPHY1STAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        status = pms->VMONP.VDDLMU0STAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        status = pms->VMONP.VDDLMU1STAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        status = pms->VMONP.VDDPADSTAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        status = pms->VMONP.VDDPHPHY2STAT.U;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        status = pms->VMONP.VDDPHY2STAT.U;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return status;
}


IFX_INLINE uint32 IfxPmsEvr_getSecondaryMonitorStatusRegister(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source)
{
    uint32 status = 0U;

    switch (source)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        status = pms->VMONS.VDDSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        status = pms->VMONS.VDDEXTSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        status = pms->VMONS.VDDEXTDCSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        status = pms->VMONS.VDDEVRSBSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        status = pms->VMONS.VDDMSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        status = pms->VMONS.VDDPHPHY0STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        status = pms->VMONS.VDDPHPHY1STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        status = pms->VMONS.VDDHSIFSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        status = pms->VMONS.VDDPPUSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        status = pms->VMONS.VDDPHY0STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        status = pms->VMONS.VDDPHY1STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        status = pms->VMONS.VDDPMS0STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        status = pms->VMONS.VDDPMS1STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        status = pms->VMONS.VDDPMS2STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        status = pms->VMONS.VDDLMU0STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        status = pms->VMONS.VDDLMU1STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        status = pms->VMONS.VDDPHPHY2STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        status = pms->VMONS.VDDPHY2STAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        status = pms->VMONS.VDDSBRAMSTAT.U;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        status = pms->VMONS.VDDPADSTAT.U;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return status;
}


IFX_INLINE uint32 IfxPmsEvr_getPeakVoltageDetectionStatusRegister(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageStatus source)
{
    uint32 status = 0U;

    switch (source)
    {
    case IfxPmsEvr_PeakDetectionVoltageStatus_vdd:
        status = pms->PEAK.VDDSTAT.U;
        break;
    case IfxPmsEvr_PeakDetectionVoltageStatus_vddext:
        status = pms->PEAK.VDDEXTSTAT.U;
        break;
    case IfxPmsEvr_PeakDetectionVoltageStatus_vddextdc:
        status = pms->PEAK.VDDEXTDCSTAT.U;
        break;
    case IfxPmsEvr_PeakDetectionVoltageStatus_vddhiststatus:
        status = pms->PEAK.VDDHISTSTAT.U;
        break;
    case IfxPmsEvr_PeakDetectionVoltageStatus_vddexthiststatus:
        status = pms->PEAK.VDDEXTHISTSTAT.U;
        break;
    case IfxPmsEvr_PeakDetectionVoltageStatus_vddextdchiststatus:
        status = pms->PEAK.VDDEXTDCHISTSTAT.U;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return status;
}


IFX_INLINE uint32 IfxPmsEvr_getDriftMonitorStatusRegister(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source)
{
    uint32 status = 0U;

    switch (source)
    {
    case IfxPmsEvr_DriftMonitorVoltageSource_vdd:
        status = pms->DRMON.VDDSTAT.U;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddext:
        status = pms->DRMON.VDDEXTSTAT.U;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddextdc:
        status = pms->DRMON.VDDEXTDCSTAT.U;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddm:
        status = pms->DRMON.VDDMSTAT.U;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms0:
        status = pms->DRMON.VDDPMS0STAT.U;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms2:
        status = pms->DRMON.VDDPMS2STAT.U;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return status;
}


IFX_INLINE uint32 IfxPmsEvr_getStatusRegister(Ifx_PMS *pms, IfxPmsEvr_StatusRegister reg)
{
    uint32 status = 0U;

    switch (reg)
    {
    case IfxPmsEvr_StatusRegister_interrupt:
        status = pms->INT.STAT.U;
        break;
    case IfxPmsEvr_StatusRegister_pad:
        status = pms->PAD.STAT.U;
        break;
    case IfxPmsEvr_StatusRegister_wakeupstat0:
        status = pms->WAKEUP.STAT0.U;
        break;
    case IfxPmsEvr_StatusRegister_wakeupstat1:
        status = pms->WAKEUP.STAT1.U;
        break;
    case IfxPmsEvr_StatusRegister_wakeuptimer:
        status = pms->WUT.STAT.U;
        break;
    case IfxPmsEvr_StatusRegister_scr:
        status = pms->SCR.STAT.U;
        break;
    case IfxPmsEvr_StatusRegister_evrcstat0:
        status = pms->EVRC.STAT0.U;
        break;
    case IfxPmsEvr_StatusRegister_evrcstat1:
        status = pms->EVRC.STAT1.U;
        break;
    case IfxPmsEvr_StatusRegister_powerdomain:
        status = pms->PD.STAT0.U;
        break;
    case IfxPmsEvr_StatusRegister_vmonslvlsel:
        status = pms->VMONS.LVLSTAT.U;
        break;
    case IfxPmsEvr_StatusRegister_coldreset:
        status = pms->CLDRSTSTAT.U;
        break;
    case IfxPmsEvr_StatusRegister_dietempstatus:
        status = pms->DTS.STAT.U;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return status;
}


IFX_INLINE float32 IfxPmsEvr_getPrimaryMonitorResultMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource source)
{
    float32 result = 0U;

    switch (source)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        result = (pms->VMONP.VDDSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        result = (pms->VMONP.VDDEXTSTAT.B.RESULT) * IFXPMSEVR_TRKHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        result = (pms->VMONP.VSSDCHSSTAT.B.RESULT) * IFXPMSEVR_TRKHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        result = (pms->VMONP.VDDEXTDCSTAT.B.RESULT) * IFXPMSEVR_TRKHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        result = (pms->VMONP.VDDDCLSSTAT.B.RESULT) * IFXPMSEVR_TRKHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        result = (pms->VMONP.VDDEVRSBSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        result = (pms->VMONP.VDDMSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        result = (pms->VMONP.VDDPHPHY0STAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        result = (pms->VMONP.VDDPHPHY1STAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        result = (pms->VMONP.VDDHSIFSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        result = (pms->VMONP.VDDPPUSTAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        result = (pms->VMONP.VDDPHY0STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        result = (pms->VMONP.VDDPHY1STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        result = (pms->VMONP.VDDLMU0STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        result = (pms->VMONP.VDDLMU1STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        result = (pms->VMONP.VDDPADSTAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        result = (pms->VMONP.VDDPHPHY2STAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        result = (pms->VMONP.VDDPHY2STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return result;
}


IFX_INLINE float32 IfxPmsEvr_getSecondaryMonitorResultMv(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source)
{
    float32 result = 0U;

    switch (source)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        result = (pms->VMONS.VDDSTAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        result = (pms->VMONS.VDDEXTSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        result = (pms->VMONS.VDDEXTDCSTAT.B.RESULT) * IFXPMSEVR_TRKHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        result = (pms->VMONS.VDDEVRSBSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        result = (pms->VMONS.VDDMSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        result = (pms->VMONS.VDDPHPHY0STAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        result = (pms->VMONS.VDDPHPHY1STAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        result = (pms->VMONS.VDDHSIFSTAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        result = (pms->VMONS.VDDPPUSTAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        result = (pms->VMONS.VDDPHY0STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        result = (pms->VMONS.VDDPHY1STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        result = (pms->VMONS.VDDPMS0STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        result = (pms->VMONS.VDDPMS1STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        result = (pms->VMONS.VDDPMS2STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        result = (pms->VMONS.VDDLMU0STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        result = (pms->VMONS.VDDLMU1STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        result = (pms->VMONS.VDDPHPHY2STAT.B.RESULT) * IFXPMSEVR_SARHVLSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        result = (pms->VMONS.VDDPHY2STAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        result = (pms->VMONS.VDDSBRAMSTAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        result = (pms->VMONS.VDDPADSTAT.B.RESULT) * IFXPMSEVR_SARCORELSB_MV;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return result;
}


IFX_INLINE void IfxPmsEvr_setPrimaryUnderVoltageThresholdMv(Ifx_PMS *pms, float32 underVoltage, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        pms->VMONP.VDDCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        pms->VMONP.VDDEXTCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        pms->VMONP.VSSDCHSCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        pms->VMONP.VDDEXTDCCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        pms->VMONP.VDDDCLSCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        pms->VMONP.VDDEVRSBCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        pms->VMONP.VDDMCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        pms->VMONP.VDDPHPHY0CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        pms->VMONP.VDDPHPHY1CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        pms->VMONP.VDDHSIFCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        pms->VMONP.VDDPPUCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        pms->VMONP.VDDPHY0CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        pms->VMONP.VDDPHY1CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        pms->VMONP.VDDLMU0CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        pms->VMONP.VDDLMU1CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        pms->VMONP.VDDPADCON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        pms->VMONP.VDDPHPHY2CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        pms->VMONP.VDDPHY2CON.B.UVVAL = (uint16)(underVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setPrimaryOverVoltageThresholdMv(Ifx_PMS *pms, float32 overVoltage, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        pms->VMONP.VDDCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        pms->VMONP.VDDEXTCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        pms->VMONP.VSSDCHSCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        pms->VMONP.VDDEXTDCCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        pms->VMONP.VDDDCLSCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        pms->VMONP.VDDEVRSBCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        pms->VMONP.VDDMCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        pms->VMONP.VDDPHPHY0CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        pms->VMONP.VDDPHPHY1CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        pms->VMONP.VDDHSIFCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        pms->VMONP.VDDPPUCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        pms->VMONP.VDDPHY0CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        pms->VMONP.VDDPHY1CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        pms->VMONP.VDDLMU0CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        pms->VMONP.VDDLMU1CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        pms->VMONP.VDDPADCON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        pms->VMONP.VDDPHPHY2CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        pms->VMONP.VDDPHY2CON.B.OVVAL = (uint16)(overVoltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionEnable(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply, boolean enable)
{
    switch (supply)
    {
    case IfxPmsEvr_PeakDetectionVoltageSource_vdd:
        pms->PEAK.VDD.B.ENABLE = enable;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddext:
        pms->PEAK.VDDEXT.B.ENABLE = enable;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddextdc:
        pms->PEAK.VDDEXTDC.B.ENABLE = enable;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }
}


IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionLpfEnable(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply, boolean enable)
{
    switch (supply)
    {
    case IfxPmsEvr_PeakDetectionVoltageSource_vdd:
        pms->PEAK.VDD.B.LPFENABLE = enable;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddext:
        pms->PEAK.VDDEXT.B.LPFENABLE = enable;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddextdc:
        pms->PEAK.VDDEXTDC.B.LPFENABLE = enable;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }
}


IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionThreshold(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply, uint16 threshold)
{
    switch (supply)
    {
    case IfxPmsEvr_PeakDetectionVoltageSource_vdd:
        pms->PEAK.VDD.B.THRESHOLD = threshold;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddext:
        pms->PEAK.VDDEXT.B.THRESHOLD = threshold;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddextdc:
        pms->PEAK.VDDEXTDC.B.THRESHOLD = threshold;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }
}


IFX_INLINE void IfxPmsEvr_setPeakVoltageDetectionReset(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply)
{
    switch (supply)
    {
    case IfxPmsEvr_PeakDetectionVoltageSource_vdd:
        pms->PEAK.VDD.B.RESET = 1;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddext:
        pms->PEAK.VDDEXT.B.RESET = 1;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddextdc:
        pms->PEAK.VDDEXTDC.B.RESET = 1;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }
}


IFX_INLINE uint16 IfxPmsEvr_getPeakVoltageDetectedValue(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply)
{
    uint16 result;

    switch (supply)
    {
    case IfxPmsEvr_PeakDetectionVoltageSource_vdd:
        result = pms->PEAK.VDDSTAT.B.PEAKVOLT;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddext:
        result = pms->PEAK.VDDEXTSTAT.B.PEAKVOLT;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddextdc:
        result = pms->PEAK.VDDEXTDCSTAT.B.PEAKVOLT;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return result;
}


IFX_INLINE float32 IfxPmsEvr_getPeakVoltageDetectedValueinMv(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply)
{
    float32 result;

    switch (supply)
    {
    case IfxPmsEvr_PeakDetectionVoltageSource_vdd:
        result = ((pms->PEAK.VDDSTAT.B.PEAKVOLT) * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddext:
        result = ((pms->PEAK.VDDEXTSTAT.B.PEAKVOLT) * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddextdc:
        result = ((pms->PEAK.VDDEXTDCSTAT.B.PEAKVOLT) * IFXPMSEVR_TRKHVLSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return result;
}


IFX_INLINE uint32 IfxPmsEvr_getPeakVoltageDetectionThresCount(Ifx_PMS *pms, IfxPmsEvr_PeakDetectionVoltageSource supply)
{
    uint32 thresCount;

    switch (supply)
    {
    case IfxPmsEvr_PeakDetectionVoltageSource_vdd:
        thresCount = pms->PEAK.VDDSTAT.B.THRESCOUNT;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddext:
        thresCount = pms->PEAK.VDDEXTSTAT.B.THRESCOUNT;
        break;
    case IfxPmsEvr_PeakDetectionVoltageSource_vddextdc:
        thresCount = pms->PEAK.VDDEXTDCSTAT.B.THRESCOUNT;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return thresCount;
}


IFX_INLINE void IfxPmsEvr_setSyncHysteresisWindow(Ifx_PMS *pms, uint8 hystWindow)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->EVRC.CON1.B.SYNCHYST = hystWindow;
    pms->EVRC.CON0.B.UP       = 1u;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_setMaxDeviationOfSyncFreq(Ifx_PMS *pms, uint8 maxDeviation)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->EVRC.CON1.B.SYNCMAXDEV = maxDeviation;
    pms->EVRC.CON0.B.UP         = 1u;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_selectSyncInputMultiplexer(Ifx_PMS *pms, IfxPmsEvr_SyncInputMultiplexer syncInput)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->EVRC.CON3.B.SYNCMUXSEL = syncInput;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_enableDriftMonitoring(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source, boolean enable)
{
    switch (source)
    {
    case IfxPmsEvr_DriftMonitorVoltageSource_vdd:
        pms->DRMON.VDD.B.ENABLE = enable;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddext:
        pms->DRMON.VDDEXT.B.ENABLE = enable;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddextdc:
        pms->DRMON.VDDEXTDC.B.ENABLE = enable;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddm:
        pms->DRMON.VDDM.B.ENABLE = enable;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms0:
        pms->DRMON.VDDPMS0.B.ENABLE = enable;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms2:
        pms->DRMON.VDDPMS2.B.ENABLE = enable;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }
}


IFX_INLINE void IfxPmsEvr_setDriftMonitoringFactor(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source, uint8 downSamplingfactor)
{
    switch (source)
    {
    case IfxPmsEvr_DriftMonitorVoltageSource_vdd:
        pms->DRMON.VDD.B.FACTOR = downSamplingfactor;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddext:
        pms->DRMON.VDDEXT.B.FACTOR = downSamplingfactor;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddextdc:
        pms->DRMON.VDDEXTDC.B.FACTOR = downSamplingfactor;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddm:
        pms->DRMON.VDDM.B.FACTOR = downSamplingfactor;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms0:
        pms->DRMON.VDDPMS0.B.FACTOR = downSamplingfactor;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms2:
        pms->DRMON.VDDPMS2.B.FACTOR = downSamplingfactor;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }
}


IFX_INLINE uint16 IfxPmsEvr_getDriftMonitoringAverage(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source)
{
    uint16 average;

    switch (source)
    {
    case IfxPmsEvr_DriftMonitorVoltageSource_vdd:
        average = pms->DRMON.VDDSTAT.B.VALUE;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddext:
        average = pms->DRMON.VDDEXTSTAT.B.VALUE;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddextdc:
        average = pms->DRMON.VDDEXTDCSTAT.B.VALUE;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddm:
        average = pms->DRMON.VDDMSTAT.B.VALUE;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms0:
        average = pms->DRMON.VDDPMS0STAT.B.VALUE;
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms2:
        average = pms->DRMON.VDDPMS2STAT.B.VALUE;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return average;
}


IFX_INLINE float32 IfxPmsEvr_getDriftMonitoringAverageVoltageMv(Ifx_PMS *pms, IfxPmsEvr_DriftMonitorVoltageSource source)
{
    float32 average;

    switch (source)
    {
    case IfxPmsEvr_DriftMonitorVoltageSource_vdd:
        average = (pms->DRMON.VDDSTAT.B.VALUE * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddext:
        average = (pms->DRMON.VDDEXTSTAT.B.VALUE * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddextdc:
        average = (pms->DRMON.VDDEXTDCSTAT.B.VALUE * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddm:
        average = (pms->DRMON.VDDMSTAT.B.VALUE * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms0:
        average = (pms->DRMON.VDDPMS0STAT.B.VALUE * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_DriftMonitorVoltageSource_vddpms2:
        average = (pms->DRMON.VDDPMS2STAT.B.VALUE * IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

    return average;
}


IFX_INLINE void IfxPmsEvr_startMonBist(const IfxPmsEvr_SecMonSupplyRailsConfig *config)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(MODULE_PMS.PROTE), IfxApProt_State_config);
#endif
    /* Secondary Monitor configuration */
    const IfxPmsEvr_RegConfig *regConfig;

    for (regConfig = &(config->regConfig[0]); regConfig < &(config->regConfig[config->numOfReg]); regConfig++)
    {
        (*(volatile uint32 *)regConfig->reg) = regConfig->value;
    }

    /* Disable over and under voltage interrupts*/
    PMS_INT_CON0.U = 0;
    PMS_INT_CON1.U = 0;

    /* Disabled to avoid triggering standby entry when the MONBIST test simulates the occurrence of undervoltage on the Vddext and vdd supply rails */
    PMS_STANDBY_CON0.B.VDDEXTSBEN = 0u;
    PMS_STANDBY_CON1.B.VDDSBEN    = 0u;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(MODULE_PMS.PROTE), IfxApProt_State_run);
#endif

    /* Enable Standby SMU */
    if (!SMUSTDBY_CMDSTDBY.B.SMUEN)
    {
        IfxSmuStdby_enableSmuStdby(IfxSmuStdby_SmuStdbyModuleState_enable);
    }

    /* Avoid spurious error pin activation */
    IfxSmuStdby_setFspErrorPinActive(IfxSmuStdby_FspIndex_0, IfxSmuStdby_FspErrorPinState_inactive);
    IfxSmuStdby_setFspErrorPinActive(IfxSmuStdby_FspIndex_1, IfxSmuStdby_FspErrorPinState_inactive);
    IfxSmuStdby_setFspErrorPinActive(IfxSmuStdby_FspIndex_2, IfxSmuStdby_FspErrorPinState_inactive);
    IfxSmuStdby_setFspErrorPinActive(IfxSmuStdby_FspIndex_3, IfxSmuStdby_FspErrorPinState_inactive);
    IfxSmuStdby_enableAlarmStatusClear();

    /* Clearing previous test results */
    IfxSmuStdby_clearSmuStdbyMonBistFlags();

    /* Disable FSP reactions in standby SMU */
    IfxSmuStdby_clearFaultSignalAlarmConfigEventFlags(&MODULE_SMUSTDBY.AGSTDBY[0]);  /* AGSTBY0 */
    IfxSmuStdby_clearFaultSignalAlarmConfigEventFlags(&MODULE_SMUSTDBY.AGSTDBY[1]);  /* AGSTDBY1*/
    IfxSmuStdby_clearFaultSignalAlarmConfigEventFlags(&MODULE_SMUSTDBY.AGSTDBY[2]);  /* AGSTDBY2 */
    IfxSmuStdby_clearFaultSignalAlarmConfigEventFlags(&MODULE_SMUSTDBY.AGSTDBY[3]);  /* AGSTDBY3 */
    IfxSmuStdby_clearFaultSignalAlarmConfigEventFlags(&MODULE_SMUSTDBY.AGSTDBY[4]);  /* AGSTDBY4 */

    /*Enable MONBIST */
    IfxSmuStdby_enableSmuStdbyMonBist();
}


IFX_INLINE void IfxPmsEvr_enablePrimaryUnderVoltageAlarm(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply, boolean enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        pms->VMONP.VDDCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        pms->VMONP.VDDEXTCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        pms->VMONP.VSSDCHSCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        pms->VMONP.VDDEXTDCCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        pms->VMONP.VDDDCLSCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        pms->VMONP.VDDEVRSBCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        pms->VMONP.VDDMCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        pms->VMONP.VDDPHPHY0CON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        pms->VMONP.VDDPHPHY1CON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        pms->VMONP.VDDHSIFCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        pms->VMONP.VDDPPUCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        pms->VMONP.VDDPHY0CON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        pms->VMONP.VDDPHY1CON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        pms->VMONP.VDDLMU0CON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        pms->VMONP.VDDLMU1CON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        pms->VMONP.VDDPADCON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        pms->VMONP.VDDPHPHY2CON.B.UVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        pms->VMONP.VDDPHY2CON.B.UVENABLE = enable;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_enablePrimaryOverVoltageAlarm(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply, boolean enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        pms->VMONP.VDDCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        pms->VMONP.VDDEXTCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        pms->VMONP.VSSDCHSCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        pms->VMONP.VDDEXTDCCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        pms->VMONP.VDDDCLSCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        pms->VMONP.VDDEVRSBCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        pms->VMONP.VDDMCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        pms->VMONP.VDDPHPHY0CON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        pms->VMONP.VDDPHPHY1CON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        pms->VMONP.VDDHSIFCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        pms->VMONP.VDDPPUCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        pms->VMONP.VDDPHY0CON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        pms->VMONP.VDDPHY1CON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        pms->VMONP.VDDLMU0CON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        pms->VMONP.VDDLMU1CON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        pms->VMONP.VDDPADCON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        pms->VMONP.VDDPHPHY2CON.B.OVENABLE = enable;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        pms->VMONP.VDDPHY2CON.B.OVENABLE = enable;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsEvr_clearColdResetStatusRegister(Ifx_PMS *pms)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->CLDRSTSTATCLR.B.CLEAR = 1U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxPmsEvr_getSyncLockStatus(Ifx_PMS *pms)
{
    return (boolean)pms->EVRC.STAT0.B.SYNCLCK;
}


IFX_INLINE boolean IfxPmsEvr_runInitSequence(const IfxPmsEvr_InitSequence *const sequence)
{
    boolean                                     pmsInitDone = TRUE;
    uint32                                      regVal;
    const IfxPmsEvr_InitSequencePhase          *phaseConfig;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;

    if (PMS_EVRC_STAT0.B.EVRC == 1U)
    {
        /*Loop through each configured phase*/
        for (phaseConfig = &sequence->phaseConfig[0];
             phaseConfig < &sequence->phaseConfig[sequence->numOfPhases];
             phaseConfig++)
        {
#if (IFX_PROT_ENABLED == 1U)
            IfxApProt_setState((Ifx_PROT_PROT *)&(MODULE_PMS.PROTE), IfxApProt_State_config);
#endif

            /*Loop through each register which is configured in the phase configuration*/
            for (regConfig = &phaseConfig->regConfig[0];
                 regConfig < &phaseConfig->regConfig[phaseConfig->numOfRegisters];
                 regConfig++)
            {
                regVal  = (*((volatile uint32 *)regConfig->regAddr));
                regVal &= ~regConfig->mask;
                regVal |= regConfig->value;

                /** During normal running one must wait for the LCK bit.
                 * However, for this function, as this is used only with CPU0 startup no wait required
                 */
                (*((volatile uint32 *)regConfig->regAddr)) = regVal; /*Write to the physical register*/
            }

            PMS_EVRC_CON0.B.UP = 1;

#if (IFX_PROT_ENABLED == 1U)
            IfxApProt_setState((Ifx_PROT_PROT *)&(MODULE_PMS.PROTE), IfxApProt_State_run);
#endif

            IfxPmsEvr_wait(phaseConfig->waitInMicroSec);        // wait for configured time

            /* Check if UP bit is deasserted if yes the continue with next configuration */
            if (PMS_EVRC_CON0.B.UP != 0u)
            {
                pmsInitDone = FALSE;
                break;
            }
        }
    }

    /*return the status*/
    return pmsInitDone;
}


IFX_INLINE void IfxPmsEvr_wait(uint32 waitInMicroSec)
{
    uint64 waitTicks;
    uint64 stmCountBegin;
    waitTicks     = IfxStm_getTicksFromMicroseconds(waitInMicroSec);
    stmCountBegin = IfxStm_get(&MODULE_CPU0);

    while ((IfxStm_get(&MODULE_CPU0) - stmCountBegin) < waitTicks)
    {}
}


IFX_INLINE boolean IfxPmsEvr_areInitValuesRight(const IfxPmsEvr_CheckRegConfig *const checkConfig)
{
    boolean                                     allRight = TRUE;
    const IfxPmsEvr_StepDownRegulatorRegConfig *regConfig;
    sint32                                      regCfgCount;
    uint32                                      regVal;

    if (PMS_EVRC_STAT0.B.EVRC == 1U)
    {
        for (regCfgCount = 0; regCfgCount < checkConfig->numOfRegisters; regCfgCount++)
        {
            regConfig = &checkConfig->regConfig[regCfgCount];
            regVal    = (*((volatile uint32 *)regConfig->regAddr));
            regVal   &= regConfig->mask;

            if (regVal != regConfig->value)
            {
                allRight = FALSE;
            }
        }

        /*Check if EVRSTAT.SDVOK is set*/
        if (allRight == TRUE)
        {
            if (PMS_EVRC_STAT0.B.SDVOK != 1)
            {
                allRight = FALSE;
            }
        }
    }

    return allRight;
}


IFX_INLINE uint16 IfxPmsEvr_getPrimaryUnderVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    uint16 mV = 0;

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        mV = (uint16)(pms->VMONP.VDDCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        mV = (uint16)(pms->VMONP.VDDEXTCON.B.UVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        mV = (uint16)(pms->VMONP.VSSDCHSCON.B.UVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        mV = (uint16)(pms->VMONP.VDDEXTDCCON.B.UVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        mV = (uint16)(pms->VMONP.VDDDCLSCON.B.UVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        mV = (uint16)(pms->VMONP.VDDEVRSBCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        mV = (uint16)(pms->VMONP.VDDMCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        mV = (uint16)(pms->VMONP.VDDPHPHY0CON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        mV = (uint16)(pms->VMONP.VDDPHPHY1CON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        mV = (uint16)(pms->VMONP.VDDHSIFCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        mV = (uint16)(pms->VMONP.VDDPPUCON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        mV = (uint16)(pms->VMONP.VDDPHY0CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        mV = (uint16)(pms->VMONP.VDDPHY1CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        mV = (uint16)(pms->VMONP.VDDLMU0CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        mV = (uint16)(pms->VMONP.VDDLMU1CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        mV = (uint16)(pms->VMONP.VDDPADCON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        mV = (uint16)(pms->VMONP.VDDPHPHY2CON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        mV = (uint16)(pms->VMONP.VDDPHY2CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return mV;
}


IFX_INLINE uint16 IfxPmsEvr_getPrimaryOverVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    uint16 mV = 0;

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        mV = (uint16)(pms->VMONP.VDDCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        mV = (uint16)(pms->VMONP.VDDEXTCON.B.OVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        mV = (uint16)(pms->VMONP.VSSDCHSCON.B.OVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        mV = (uint16)(pms->VMONP.VDDEXTDCCON.B.OVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        mV = (uint16)(pms->VMONP.VDDDCLSCON.B.OVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        mV = (uint16)(pms->VMONP.VDDEVRSBCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        mV = (uint16)(pms->VMONP.VDDMCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        mV = (uint16)(pms->VMONP.VDDPHPHY0CON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        mV = (uint16)(pms->VMONP.VDDPHPHY1CON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        mV = (uint16)(pms->VMONP.VDDHSIFCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        mV = (uint16)(pms->VMONP.VDDPPUCON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        mV = (uint16)(pms->VMONP.VDDPHY0CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        mV = (uint16)(pms->VMONP.VDDPHY1CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        mV = (uint16)(pms->VMONP.VDDLMU0CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        mV = (uint16)(pms->VMONP.VDDLMU1CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        mV = (uint16)(pms->VMONP.VDDPADCON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        mV = (uint16)(pms->VMONP.VDDPHPHY2CON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        mV = (uint16)(pms->VMONP.VDDPHY2CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return mV;
}


IFX_INLINE uint16 IfxPmsEvr_getRstVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    uint16 mV = 0;

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        mV = (uint16)(pms->VMONP.VDDRST.B.RESETTRIM * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        mV = (uint16)(pms->VMONP.VDDEXTRST.B.RESETTRIM * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        mV = (uint16)(pms->VMONP.VSSDCHSRST.B.RESETTRIM * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        mV = (uint16)(pms->VMONP.VDDEXTDCRST.B.RESETTRIM * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        mV = (uint16)(pms->VMONP.VDDDCLSRST.B.RESETTRIM * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        mV = (uint16)(pms->VMONP.VDDEVRSBRST.B.RESETTRIM * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        mV = (uint16)(pms->VMONP.VDDMRST.B.RESETTRIM * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        mV = (uint16)(pms->VMONP.VDDPHPHY0RST.B.RESETTRIM * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        mV = (uint16)(pms->VMONP.VDDPHPHY1RST.B.RESETTRIM * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        mV = (uint16)(pms->VMONP.VDDHSIFRST.B.RESETTRIM * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        mV = (uint16)(pms->VMONP.VDDPPURST.B.RESETTRIM * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        mV = (uint16)(pms->VMONP.VDDPHY0RST.B.RESETTRIM * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        mV = (uint16)(pms->VMONP.VDDPHY1RST.B.RESETTRIM * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        mV = (uint16)(pms->VMONP.VDDLMU0RST.B.RESETTRIM * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        mV = (uint16)(pms->VMONP.VDDLMU1RST.B.RESETTRIM * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        mV = (uint16)(pms->VMONP.VDDPADRST.B.RESETTRIM * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        mV = (uint16)(pms->VMONP.VDDPHPHY2RST.B.RESETTRIM * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        mV = (uint16)(pms->VMONP.VDDPHY2RST.B.RESETTRIM * IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return mV;
}


IFX_INLINE void IfxPmsEvr_setRstVoltageThresholdMv(Ifx_PMS *pms, uint16 voltage, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        pms->VMONP.VDDRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        pms->VMONP.VDDEXTRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        pms->VMONP.VSSDCHSRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        pms->VMONP.VDDEXTDCRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        pms->VMONP.VDDDCLSRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        pms->VMONP.VDDEVRSBRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        pms->VMONP.VDDMRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        pms->VMONP.VDDPHPHY0RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        pms->VMONP.VDDPHPHY1RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        pms->VMONP.VDDHSIFRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        pms->VMONP.VDDPPURST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        pms->VMONP.VDDPHY0RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        pms->VMONP.VDDPHY1RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        pms->VMONP.VDDLMU0RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        pms->VMONP.VDDLMU1RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        pms->VMONP.VDDPADRST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        pms->VMONP.VDDPHPHY2RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        pms->VMONP.VDDPHY2RST.B.RESETTRIM = (uint16)(voltage / IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxPmsEvr_getPrimaryUnderVoltageAlarmEnabledStatus(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    boolean flag = 0;

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        flag = pms->VMONP.VDDCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        flag = pms->VMONP.VDDEXTCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        flag = pms->VMONP.VSSDCHSCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        flag = pms->VMONP.VDDEXTDCCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        flag = pms->VMONP.VDDDCLSCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        flag = pms->VMONP.VDDEVRSBCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        flag = pms->VMONP.VDDMCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        flag = pms->VMONP.VDDPHPHY0CON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        flag = pms->VMONP.VDDPHPHY1CON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        flag = pms->VMONP.VDDHSIFCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        flag = pms->VMONP.VDDPPUCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        flag = pms->VMONP.VDDPHY0CON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        flag = pms->VMONP.VDDPHY1CON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        flag = pms->VMONP.VDDLMU0CON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        flag = pms->VMONP.VDDLMU1CON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        flag = pms->VMONP.VDDPADCON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        flag = pms->VMONP.VDDPHPHY2CON.B.UVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        flag = pms->VMONP.VDDPHY2CON.B.UVENABLE;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return flag;
}


IFX_INLINE boolean IfxPmsEvr_getPrimaryOverVoltageAlarmEnabledStatus(Ifx_PMS *pms, IfxPmsEvr_PrimaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    boolean flag = 0;

    switch (supply)
    {
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdd:
        flag = pms->VMONP.VDDCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddext:
        flag = pms->VMONP.VDDEXTCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vssdchs:
        flag = pms->VMONP.VSSDCHSCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddextdc:
        flag = pms->VMONP.VDDEXTDCCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vdddcls:
        flag = pms->VMONP.VDDDCLSCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb:
        flag = pms->VMONP.VDDEVRSBCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddm:
        flag = pms->VMONP.VDDMCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0:
        flag = pms->VMONP.VDDPHPHY0CON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1:
        flag = pms->VMONP.VDDPHPHY1CON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif:
        flag = pms->VMONP.VDDHSIFCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddppu:
        flag = pms->VMONP.VDDPPUCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0:
        flag = pms->VMONP.VDDPHY0CON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1:
        flag = pms->VMONP.VDDPHY1CON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu0:
        flag = pms->VMONP.VDDLMU0CON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddlmu1:
        flag = pms->VMONP.VDDLMU1CON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddpad:
        flag = pms->VMONP.VDDPADCON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy2:
        flag = pms->VMONP.VDDPHPHY2CON.B.OVENABLE;
        break;
    case IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy2:
        flag = pms->VMONP.VDDPHY2CON.B.OVENABLE;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return flag;
}


IFX_INLINE uint16 IfxPmsEvr_getSecondaryUnderVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    uint16 mV = 0;

    switch (source)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        mV = (uint16)(pms->VMONS.VDDCON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        mV = (uint16)(pms->VMONS.VDDEXTCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        mV = (uint16)(pms->VMONS.VDDEXTDCCON.B.UVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        mV = (uint16)(pms->VMONS.VDDEVRSBCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        mV = (uint16)(pms->VMONS.VDDMCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        mV = (uint16)(pms->VMONS.VDDPHPHY0CON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        mV = (uint16)(pms->VMONS.VDDPHPHY1CON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        mV = (uint16)(pms->VMONS.VDDHSIFCON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        mV = (uint16)(pms->VMONS.VDDPPUCON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        mV = (uint16)(pms->VMONS.VDDPHY0CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        mV = (uint16)(pms->VMONS.VDDPHY1CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        mV = (uint16)(pms->VMONS.VDDPMS0CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        mV = (uint16)(pms->VMONS.VDDPMS1CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        mV = (uint16)(pms->VMONS.VDDPMS2CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        mV = (uint16)(pms->VMONS.VDDLMU0CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        mV = (uint16)(pms->VMONS.VDDLMU1CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        mV = (uint16)(pms->VMONS.VDDPHPHY2CON.B.UVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        mV = (uint16)(pms->VMONS.VDDPHY2CON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        mV = (uint16)(pms->VMONS.VDDSBRAMCON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        mV = (uint16)(pms->VMONS.VDDPADCON.B.UVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return mV;
}


IFX_INLINE uint16 IfxPmsEvr_getSecondaryOverVoltageThresholdMv(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource source)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    uint16 mV = 0;

    switch (source)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        mV = (uint16)(pms->VMONS.VDDCON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        mV = (uint16)(pms->VMONS.VDDEXTCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        mV = (uint16)(pms->VMONS.VDDEXTDCCON.B.OVVAL * IFXPMSEVR_TRKHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        mV = (uint16)(pms->VMONS.VDDEVRSBCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        mV = (uint16)(pms->VMONS.VDDMCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        mV = (uint16)(pms->VMONS.VDDPHPHY0CON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        mV = (uint16)(pms->VMONS.VDDPHPHY1CON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        mV = (uint16)(pms->VMONS.VDDHSIFCON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        mV = (uint16)(pms->VMONS.VDDPPUCON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        mV = (uint16)(pms->VMONS.VDDPHY0CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        mV = (uint16)(pms->VMONS.VDDPHY1CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        mV = (uint16)(pms->VMONS.VDDPMS0CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        mV = (uint16)(pms->VMONS.VDDPMS1CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        mV = (uint16)(pms->VMONS.VDDPMS2CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        mV = (uint16)(pms->VMONS.VDDLMU0CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        mV = (uint16)(pms->VMONS.VDDLMU1CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        mV = (uint16)(pms->VMONS.VDDPHPHY2CON.B.OVVAL * IFXPMSEVR_SARHVLSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        mV = (uint16)(pms->VMONS.VDDPHY2CON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        mV = (uint16)(pms->VMONS.VDDSBRAMCON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        mV = (uint16)(pms->VMONS.VDDPADCON.B.OVVAL * IFXPMSEVR_SARCORELSB_MV);
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return mV;
}


IFX_INLINE IfxPmsEvr_OverVoltageMonitoring IfxPmsEvr_getOverVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    IfxPmsEvr_OverVoltageMonitoring mode = IfxPmsEvr_OverVoltageMonitoring_inactive;

    switch (supply)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDEXTCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDEXTDCCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDEVRSBCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDMCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPHPHY0CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPHPHY1CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDHSIFCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPPUCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPHY0CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPHY1CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPMS0CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPMS1CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPMS2CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDLMU0CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDLMU1CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPHPHY2CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPHY2CON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDSBRAMCON.B.OVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        mode = (IfxPmsEvr_OverVoltageMonitoring)pms->VMONS.VDDPADCON.B.OVMOD;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return mode;
}


IFX_INLINE IfxPmsEvr_UnderVoltageMonitoring IfxPmsEvr_getUnderVoltageMonitoringMode(Ifx_PMS *pms, IfxPmsEvr_SecondaryMonitorVoltageSource supply)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    IfxPmsEvr_UnderVoltageMonitoring mode = IfxPmsEvr_UnderVoltageMonitoring_inactive;

    switch (supply)
    {
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vdd:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddext:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDEXTCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddextdc:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDEXTDCCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddevrsb:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDEVRSBCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddm:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDMCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy0:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPHPHY0CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy1:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPHPHY1CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddhsif:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDHSIFCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddppu:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPPUCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy0:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPHY0CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy1:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPHY1CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms0:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPMS0CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms1:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPMS1CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpms2:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPMS2CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu0:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDLMU0CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddlmu1:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDLMU1CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphphy2:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPHPHY2CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddphy2:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPHY2CON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddsbram:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDSBRAMCON.B.UVMOD;
        break;
    case IfxPmsEvr_SecondaryMonitorVoltageSource_vddpad:
        mode = (IfxPmsEvr_UnderVoltageMonitoring)pms->VMONS.VDDPADCON.B.UVMOD;
        break;
    default:
        /* Invalid Supply selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return mode;
}


#endif /* IFXPMSEVR_H */
