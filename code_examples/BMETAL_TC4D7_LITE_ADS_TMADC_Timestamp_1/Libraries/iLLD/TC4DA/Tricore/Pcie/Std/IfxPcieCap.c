/**
 * \file IfxPcieCap.c
 * \brief PCIE  basic functionality
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxPcieCap.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxPcieCap_getMsixTableBaseOffset(IfxPcieCap_MsixCap *capPtr, uint32 *tableOffset, uint8 *barIndex)
{
    *tableOffset = (uint32)(capPtr->tableOffset & ~((uint32)(0x7u)));
    *barIndex    = (uint8)((capPtr->tableOffset) & 0x7u);
}


void IfxPcieCap_enableMsix(IfxPcieCap_MsixCap *capPtr)
{
    volatile IfxPcieCap_MsixMsgCtrl msgCtrl;
    msgCtrl.U            = capPtr->msgControl.U;
    msgCtrl.B.msixEnable = 1u;
    msgCtrl.B.funcMask   = 0u;
    capPtr->msgControl.U = msgCtrl.U;
}


void IfxPcieCap_enableMsi(IfxPcieCap_MsiCap *capPtr)
{
    capPtr->msgControl.B.msiEnable = 1u;
}


boolean IfxPcieCap_isMsixVectorMasked(IfxPcieCap_MsixCap *capPtr, IfxPcieCap_MsixTableEntry *tableAddr)
{
    boolean vectorMasked = TRUE;

    if (((tableAddr->vectorCtrl) & (uint32)0x1u) != 0x1u)
    {
        vectorMasked = FALSE;
    }

    return vectorMasked;
}


uint8 IfxPcieCap_getNumMsixInterrupt(IfxPcieCap_MsixCap *capPtr, IfxPcieCap_MsixTableEntry *tableAddr)
{
    uint8 numMsixInt = 0u;
    uint8 tableIndex = 0u;

    for (tableIndex = 0; tableIndex < capPtr->msgControl.B.tableSize; tableIndex++)
    {
        if (((tableAddr->vectorCtrl) & (uint32)0x1u) != 0x1u)           /* Entry is not masked */
        {
            numMsixInt++;
        }

        tableAddr++;
    }

    return numMsixInt;
}


IfxPcieCap_PmPwrState IfxPcieCap_getPwrState(IfxPcieCap_PmCap *pciePmCap)
{
    return (IfxPcieCap_PmPwrState)(pciePmCap->pmcsr.B.pwrState);
}


boolean IfxPcieCap_setPwrState(IfxPcieCap_PmCap *pciePmCap, IfxPcieCap_PmPwrState pwrState)
{
    boolean status = FALSE;

    if ((pwrState != IfxPcieCap_PmPwrState_none)
        && (pwrState != IfxPcieCap_PmPwrState_d3Cold))
    {
        pciePmCap->pmcsr.B.pwrState = (uint32)pwrState;
        status                      = TRUE;
    }

    return status;
}


boolean IfxPcieCap_isPwrStateSupported(IfxPcieCap_PmCap *pciePmCap, IfxPcieCap_PmPwrState pwrState)
{
    boolean support     = FALSE;
    uint16  supportBits = 0u;

    if ((pwrState > IfxPcieCap_PmPwrState_d0)
        && (pwrState < IfxPcieCap_PmPwrState_d3Hot))
    {
        supportBits = ((pciePmCap->pmc.U & ((uint16)3u << 9u)) >> 8u);
        support     = ((supportBits & (1u << (uint16)pwrState)) != 0u) ? TRUE : FALSE;
    }
    else if (pwrState != IfxPcieCap_PmPwrState_none)
    {
        support = TRUE;
    }

    return support;
}


void IfxPcieCap_setPmeActive(IfxPcieCap_PmCap *pciePmCap, boolean enable)
{
    if (pciePmCap != NULL_PTR)
    {
        if (pciePmCap->pmc.B.pmeSupport != 0u)
        {
            pciePmCap->pmcsr.B.pme = 1u;
        }
    }
}


void IfxPcieCap_setAspmLnkState(IfxPcieCap_PcieCap *pcieCap, IfxPcieCap_PcieAspmLevel aspmLevel)
{
    pcieCap->linkCtrl.B.aspmCtrl = (uint16)aspmLevel;
}


void IfxPcieCap_setLnkRetrain(IfxPcieCap_PcieCap *pcieCap)
{
    pcieCap->linkCtrl.B.retrainLink = 1u;
}


boolean IfxPcieCap_setAerCapability(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerCapabilities capability, boolean enable)
{
    boolean               status = TRUE;
    IfxPcieCap_AerCapCtrl capCtrlReg;
    capCtrlReg.U = aerCap->capControl.U;

    if (enable == TRUE)
    {
        if ((capCtrlReg.U & ((uint32)1u << (0x5u + (uint32)(capability << 1u)))) != 0x0u)
        {
            capCtrlReg.U |= ((uint32)1u << (0x6u + (uint32)(capability << 1u)));
        }
        else
        {
            status = FALSE;
        }
    }
    else
    {
        capCtrlReg.U &= ~((uint32)1u << (0x6u + (uint32)(capability << 1u)));
    }

    aerCap->capControl.U = capCtrlReg.U;

    return status;
}


boolean IfxPcieCap_getAerCapabilitySupport(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerCapabilities capability)
{
    boolean               supported = FALSE;
    IfxPcieCap_AerCapCtrl capCtrlReg;
    capCtrlReg.U = aerCap->capControl.U;

    if ((capCtrlReg.U & ((uint32)1u << (0x5u + (uint32)(capability << 1u)))) != 0x0u)
    {
        supported = TRUE;
    }

    return supported;
}


uint32 IfxPcieCap_getAerPendingErrors(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, uint32 mask)
{
    uint32 errorStatus = 0u;

    if (errorType == IfxPcieCap_AerErrorType_uncorrectable)
    {
        errorStatus = aerCap->uncorrErrorStatus.U;
    }
    else
    {
        errorStatus = aerCap->corrErrorStatus.U;
    }

    errorStatus &= ~(mask);

    return errorStatus;
}


void IfxPcieCap_serAerErrorMask(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, uint32 mask)
{
    if (errorType == IfxPcieCap_AerErrorType_uncorrectable)
    {
        aerCap->uncorrErrorStatus.U |= mask;
    }
    else
    {
        aerCap->corrErrorStatus.U |= mask;
    }
}


void IfxPcieCap_getAerTLPHeaderLog(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, void *headerPtr)
{
    uint8 index = 0u;

    for (index = 0u; index < 4u; index++)
    {
        *(((uint32 *)headerPtr) + index) = aerCap->tlpHeaderLog[index];
    }
}


void IfxPcieCap_getAerTLPPrefix(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, void *prefixPtr)
{
    uint8 index = 0u;

    if (aerCap->capControl.B.tlpPrefixLogPresent == 1u)
    {
        for (index = 0u; index < 4u; index++)
        {
            *(((uint32 *)prefixPtr) + index) = aerCap->tlpPrefixLog[index];
        }
    }
}


void IfxPcieCap_setRasDpAutoLinkDown(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, boolean enabled)
{
    uint32 enable = (enabled == TRUE) ? 1u : 0u;
    rasdpSFR->RASDP_ERROR_MODE_EN_OFF.B.AUTO_LINK_DOWN_EN = enable;
}


void IfxPcieCap_exitRasDpErrorMode(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR)
{
    rasdpSFR->RASDP_ERROR_MODE_CLEAR_OFF.B.ERROR_MODE_CLEAR = 1u;
}


void IfxPcieCap_disableRasDpErrorProt(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, uint32 disableMask)
{
    rasdpSFR->RASDP_ERROR_PROT_CTRL_OFF.U |= disableMask;
}


uint32 IfxPcieCap_getRasDpRamErrorAddr(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, IfxPcieCap_AerErrorType errorType)
{
    uint32 ramAddress = 0u;

    if (errorType == IfxPcieCap_AerErrorType_uncorrectable)
    {
        ramAddress = rasdpSFR->RASDP_RAM_ADDR_UNCORR_ERROR_OFF.B.RAM_ADDR_UNCORR_ERROR;
    }
    else
    {
        ramAddress = rasdpSFR->RASDP_RAM_ADDR_CORR_ERROR_OFF.B.RAM_ADDR_CORR_ERROR;
    }

    return ramAddress;
}


uint32 IfxPcieCap_getRasDpRamErrorIndex(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, IfxPcieCap_AerErrorType errorType)
{
    uint32 ramId = 0u;

    if (errorType == IfxPcieCap_AerErrorType_uncorrectable)
    {
        ramId = rasdpSFR->RASDP_RAM_ADDR_UNCORR_ERROR_OFF.B.RAM_INDEX_UNCORR_ERROR;
    }
    else
    {
        ramId = rasdpSFR->RASDP_RAM_ADDR_CORR_ERROR_OFF.B.RAM_INDEX_CORR_ERROR;
    }

    return ramId;
}


void IfxPcieCap_enableRasDesErrorInjection(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesErrorType errorType)
{
    rasdesSFR->EINJ_ENABLE_REG.U |= ((uint32)1u << (uint32)errorType);
}


void IfxPcieCap_configureRasDesCrcError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesCrcErrorType errorType, uint8 count)
{
    Ifx_PCIE_DSP_RASDESCAP_EINJ0_CRC_REG errReg;
    errReg.U                   = rasdesSFR->EINJ0_CRC_REG.U;

    errReg.B.EINJ0_CRC_TYPE    = (uint32)errorType;
    errReg.B.EINJ0_COUNT       = (uint32)count;

    rasdesSFR->EINJ0_CRC_REG.U = errReg.U;
}


void IfxPcieCap_configureRasDesSeqError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesSeqErrorType errorType, uint32 badSeqNum, uint8 count)
{
    Ifx_PCIE_DSP_RASDESCAP_EINJ1_SEQNUM_REG errReg;
    errReg.U                      = rasdesSFR->EINJ1_SEQNUM_REG.U;

    errReg.B.EINJ1_SEQNUM_TYPE    = (uint32)errorType;
    errReg.B.EINJ1_COUNT          = (uint32)count;
    errReg.B.EINJ1_BAD_SEQNUM     = badSeqNum;

    rasdesSFR->EINJ1_SEQNUM_REG.U = errReg.U;
}


void IfxPcieCap_configureRasDesDllpError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesDllpErrorType errorType, uint8 count)
{
    Ifx_PCIE_DSP_RASDESCAP_EINJ2_DLLP_REG errReg;
    errReg.U                    = rasdesSFR->EINJ2_DLLP_REG.U;

    errReg.B.EINJ2_DLLP_TYPE    = (uint32)errorType;
    errReg.B.EINJ2_COUNT        = (uint32)count;

    rasdesSFR->EINJ2_DLLP_REG.U = errReg.U;
}


void IfxPcieCap_configureRasDesSymError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesSymErrorType errorType, uint8 count)
{
    Ifx_PCIE_DSP_RASDESCAP_EINJ3_SYMBOL_REG errReg;
    errReg.U                      = rasdesSFR->EINJ3_SYMBOL_REG.U;

    errReg.B.EINJ3_SYMBOL_TYPE    = (uint32)errorType;
    errReg.B.EINJ3_COUNT          = (uint32)count;

    rasdesSFR->EINJ3_SYMBOL_REG.U = errReg.U;
}


void IfxPcieCap_configureRasDesFcError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesFcType fcType, uint32 badFcValue, uint8 vcNum, uint8 count)
{
    Ifx_PCIE_DSP_RASDESCAP_EINJ4_FC_REG errReg;
    errReg.U                       = rasdesSFR->EINJ4_FC_REG.U;

    errReg.B.EINJ4_UPDFC_TYPE      = (uint32)fcType;
    errReg.B.EINJ4_BAD_UPDFC_VALUE = badFcValue;
    errReg.B.EINJ4_VC_NUMBER       = (uint32)vcNum;
    errReg.B.EINJ4_COUNT           = (uint32)count;

    rasdesSFR->EINJ4_FC_REG.U      = errReg.U;
}


void IfxPcieCap_configureRasDesTlpInsertError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesTlpInsertType tlpType, uint8 count)
{
    Ifx_PCIE_DSP_RASDESCAP_EINJ5_SP_TLP_REG errReg;
    errReg.U                      = rasdesSFR->EINJ5_SP_TLP_REG.U;

    errReg.B.EINJ5_SPECIFIED_TLP  = (uint32)tlpType;
    errReg.B.EINJ5_COUNT          = (uint32)count;

    rasdesSFR->EINJ5_SP_TLP_REG.U = errReg.U;
}


void IfxPcieCap_setLtrEnable(IfxPcieCap_PcieCap *pcieCapPtr, boolean ltrEnable)
{
    pcieCapPtr->deviceCtrl2.B.ltr = (uint16)ltrEnable;
}


boolean IfxPcieCap_isLtrEnabled(IfxPcieCap_PcieCap *pcieCapPtr)
{
    boolean ltrEnabled = FALSE;

    if (pcieCapPtr->deviceCtrl2.B.ltr == (uint16)1)
    {
        ltrEnabled = TRUE;
    }

    return ltrEnabled;
}


boolean IfxPcieCap_isLtrSupported(IfxPcieCap_PcieCap *pcieCapPtr)
{
    boolean ltrEnabled = FALSE;

    if (pcieCapPtr->deviceCap2.B.ltr == (uint16)1)
    {
        ltrEnabled = TRUE;
    }

    return ltrEnabled;
}


void IfxPcieCap_setLtrMaxLatencies(IfxPcieCap_LtrCap *ltrCapPtr, uint16 noSnoopLatency, IfxPcieCap_LtrLatencyScale noSnoopScale, uint16 snoopLatency, IfxPcieCap_LtrLatencyScale snoopScale)
{
    uint32  ltrLatencyValues = ((uint32)snoopLatency) | ((uint32)(snoopScale) << (uint32)10) | ((((uint32)noSnoopLatency) | ((uint32)(noSnoopScale) << (uint32)10)) << (uint32)16);

    uint32 *ltrLatPtr        = (uint32 *)&(ltrCapPtr->maxSnoopLatency);

    *ltrLatPtr = ltrLatencyValues;
}


void IfxPcieCap_setObffEnable(IfxPcieCap_PcieCap *pcieCapPtr, IfxPcieCap_ObffType obffType)
{
    pcieCapPtr->deviceCtrl2.B.obff = (uint16)obffType;
}


IfxPcieCap_ObffCapability IfxPcieCap_GetObffCapability(IfxPcieCap_PcieCap *pcieCapPtr)
{
    return (IfxPcieCap_ObffCapability)pcieCapPtr->deviceCap2.B.obff;
}


IfxPcieCap_ObffType IfxPcieCap_GetObffType(IfxPcieCap_PcieCap *pcieCapPtr)
{
    return (IfxPcieCap_ObffType)pcieCapPtr->deviceCtrl2.B.obff;
}
