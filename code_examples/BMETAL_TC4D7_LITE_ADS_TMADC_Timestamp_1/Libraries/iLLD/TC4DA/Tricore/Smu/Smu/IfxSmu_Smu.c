/**
 * \file IfxSmu_Smu.c
 * \brief SMU SMU details
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxSmu_Smu.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxSmu_Smu_initSafetyModuleConfig(IfxSmu_Smu_SafetyConfig *config)
{
    const IfxSmu_Smu_SafetyConfig IfxSmu_Smu_defaultConfig = {
        .fsp                                 = {
            {
                .prescalar1             = IfxSmu_FspPrescalar1_referenceClockDiv2,
                .prescalar2             = IfxSmu_FspPrescalar2_referenceClockDiv512,
                .mode                   = IfxSmu_FspMode_BiStableProtocol,
                .faultStateDurationHigh = 0,
                .faultStateDurationLow  = 0
            },
            {
                .prescalar1             = IfxSmu_FspPrescalar1_referenceClockDiv2,
                .prescalar2             = IfxSmu_FspPrescalar2_referenceClockDiv512,
                .mode                   = IfxSmu_FspMode_BiStableProtocol,
                .faultStateDurationHigh = 0,
                .faultStateDurationLow  = 0
            }
        },
        .globalConfig                        = {
            .alarmGlobalConfig               = {
                .igcs0                       = 0,
                .igcs1                       = 0,
                .igcs2                       = 0,
                .resetConfigSet0             = 0,
                .resetConfigSet1             = 0,
                .enableFaultToRunTransition0 = FALSE,
                .enableFaultToRunTransition1 = FALSE,
                .enableStartToRunState       = FALSE
            },
            .safetyRecoveryTimerConfig       = {
                .enableRecoveryTimer0        = FALSE,
                .enableRecoveryTimer1        = FALSE,
                .PrescalarRecoveryTimerClock = 0,
                .recoveryTimerDuration       = 0
            },
            .recoveryTimerAlarmConfig        = {
                {
                    .groupIndex0 = 0,
                    .alarmId0    = 0,
                    .groupIndex1 = 0,
                    .alarmId1    = 0,
                    .groupIndex2 = 0,
                    .alarmId2    = 0,
                    .groupIndex3 = 0,
                    .alarmId3    = 0
                },
                {
                    .groupIndex0 = 0,
                    .alarmId0    = 0,
                    .groupIndex1 = 0,
                    .alarmId1    = 0,
                    .groupIndex2 = 0,
                    .alarmId2    = 0,
                    .groupIndex3 = 0,
                    .alarmId3    = 0
                },
            },
        },
        .alarmConfigRegister[0][0]  = 0,
        .alarmConfigRegister[0][1]  = 0,
        .alarmConfigRegister[0][2]  = 0,
        .alarmConfigRegister[0][3]  = 0,
        .alarmConfigRegister[1][0]  = 0,
        .alarmConfigRegister[1][1]  = 0,
        .alarmConfigRegister[1][2]  = 0,
        .alarmConfigRegister[1][3]  = 0,
        .alarmConfigRegister[2][0]  = 0,
        .alarmConfigRegister[2][1]  = 0,
        .alarmConfigRegister[2][2]  = 0,
        .alarmConfigRegister[2][3]  = 0,
        .alarmConfigRegister[3][0]  = 0,
        .alarmConfigRegister[3][1]  = 0,
        .alarmConfigRegister[3][2]  = 0,
        .alarmConfigRegister[3][3]  = 0,
        .alarmConfigRegister[4][0]  = 0,
        .alarmConfigRegister[4][1]  = 0,
        .alarmConfigRegister[4][2]  = 0,
        .alarmConfigRegister[4][3]  = 0,
        .alarmConfigRegister[5][0]  = 0,
        .alarmConfigRegister[5][1]  = 0,
        .alarmConfigRegister[5][2]  = 0,
        .alarmConfigRegister[5][3]  = 0,
        .alarmConfigRegister[6][0]  = 0,
        .alarmConfigRegister[6][1]  = 0,
        .alarmConfigRegister[6][2]  = 0,
        .alarmConfigRegister[6][3]  = 0,
        .alarmConfigRegister[7][0]  = 0,
        .alarmConfigRegister[7][1]  = 0,
        .alarmConfigRegister[7][2]  = 0,
        .alarmConfigRegister[7][3]  = 0,
        .alarmConfigRegister[8][0]  = 0,
        .alarmConfigRegister[8][1]  = 0,
        .alarmConfigRegister[8][2]  = 0,
        .alarmConfigRegister[8][3]  = 0,
        .alarmConfigRegister[9][0]  = 0,
        .alarmConfigRegister[9][1]  = 0,
        .alarmConfigRegister[9][2]  = 0,
        .alarmConfigRegister[9][3]  = 0,
        .alarmConfigRegister[10][0] = 0,
        .alarmConfigRegister[10][1] = 0,
        .alarmConfigRegister[10][2] = 0,
        .alarmConfigRegister[10][3] = 0,
        .alarmConfigRegister[11][0] = 0,
        .alarmConfigRegister[11][1] = 0,
        .alarmConfigRegister[11][2] = 0,
        .alarmConfigRegister[11][3] = 0,
        .alarmConfigRegister[12][0] = 0,
        .alarmConfigRegister[12][1] = 0,
        .alarmConfigRegister[12][2] = 0,
        .alarmConfigRegister[12][3] = 0,
        .alarmConfigRegister[13][0] = 0,
        .alarmConfigRegister[13][1] = 0,
        .alarmConfigRegister[13][2] = 0,
        .alarmConfigRegister[13][3] = 0,

        .fspConfigRegister[0][0]    = 0,
        .fspConfigRegister[0][1]    = 0,
        .fspConfigRegister[1][0]    = 0,
        .fspConfigRegister[1][1]    = 0,
        .fspConfigRegister[2][0]    = 0,
        .fspConfigRegister[2][1]    = 0,
        .fspConfigRegister[3][0]    = 0,
        .fspConfigRegister[3][1]    = 0,
        .fspConfigRegister[4][0]    = 0,
        .fspConfigRegister[4][1]    = 0,
        .fspConfigRegister[5][0]    = 0,
        .fspConfigRegister[5][1]    = 0,
        .fspConfigRegister[6][0]    = 0,
        .fspConfigRegister[6][1]    = 0,
        .fspConfigRegister[7][0]    = 0,
        .fspConfigRegister[7][1]    = 0,
        .fspConfigRegister[8][0]    = 0,
        .fspConfigRegister[8][1]    = 0,
        .fspConfigRegister[9][0]    = 0,
        .fspConfigRegister[9][1]    = 0,
        .fspConfigRegister[10][0]   = 0,
        .fspConfigRegister[10][1]   = 0,
        .fspConfigRegister[11][0]   = 0,
        .fspConfigRegister[11][1]   = 0,
        .fspConfigRegister[12][0]   = 0,
        .fspConfigRegister[12][1]   = 0,
        .fspConfigRegister[13][0]   = 0,
        .fspConfigRegister[13][1]   = 0,
    };

    *config = IfxSmu_Smu_defaultConfig;
}


void IfxSmu_Smu_initSafetyModule(IfxSmu_Smu_SafetyConfig *config, boolean smuSafeIndex)
{
    uint8                alarmGroupIndex = 0U;
    Ifx_SMU_SAFE_FSP_CON fspSfr0;
    Ifx_SMU_SAFE_FSP_CON fspSfr1;

    /* Configure SMU module register as per the requested configuration */
    fspSfr0.U           = MODULE_SMU.SAFE[smuSafeIndex].FSP[0].CON.U;
    fspSfr0.B.PRE1      = config->fsp[0].prescalar1;
    fspSfr0.B.PRE2      = config->fsp[0].prescalar2;
    fspSfr0.B.MODE      = config->fsp[0].mode;
    fspSfr0.B.TFSP_LOW  = config->fsp[0].faultStateDurationLow;
    fspSfr0.B.TFSP_HIGH = config->fsp[0].faultStateDurationHigh;

    fspSfr1.U           = MODULE_SMU.SAFE[smuSafeIndex].FSP[1].CON.U;
    fspSfr1.B.PRE1      = config->fsp[1].prescalar1;
    fspSfr1.B.PRE2      = config->fsp[1].prescalar2;
    fspSfr1.B.MODE      = config->fsp[1].mode;
    fspSfr1.B.TFSP_LOW  = config->fsp[1].faultStateDurationLow;
    fspSfr1.B.TFSP_HIGH = config->fsp[1].faultStateDurationHigh;

    /* Initialize the Global SMU SAFE configurations */
    IfxSmu_Smu_initSafetyGlobal(&config->globalConfig, smuSafeIndex);

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSSE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.SAFE[smuSafeIndex].KEYS.U       = (uint32)0x000000bc;

    MODULE_SMU.SAFE[smuSafeIndex].FSP[0].CON.U = fspSfr0.U;
    MODULE_SMU.SAFE[smuSafeIndex].FSP[1].CON.U = fspSfr1.U;

    for (alarmGroupIndex = 0U; alarmGroupIndex < IFXSMU_NUM_OF_SAFETY_ALARM_GROUPS; alarmGroupIndex++)
    {
        /* Configure the alarms */
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroupIndex].CON[0].U = config->alarmConfigRegister[alarmGroupIndex][0];
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroupIndex].CON[1].U = config->alarmConfigRegister[alarmGroupIndex][1];
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroupIndex].CON[2].U = config->alarmConfigRegister[alarmGroupIndex][2];
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroupIndex].CON[3].U = config->alarmConfigRegister[alarmGroupIndex][3];

        /* Configure the FSP Enable registers */
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroupIndex].FSP[0].U = config->fspConfigRegister[alarmGroupIndex][0];
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroupIndex].FSP[1].U = config->fspConfigRegister[alarmGroupIndex][1];
    }

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.SAFE[smuSafeIndex].KEYS.U = 0;

    /* Write SMU_ASCE(0) in CMD register */
    MODULE_SMU.SAFE[smuSafeIndex].CMD.U = IfxSmu_Command_alarmStatusClear;

    /* Clear all SAFE SMU Alarms */
    for (alarmGroupIndex = 0U; alarmGroupIndex < IFXSMU_NUM_OF_SAFETY_ALARM_GROUPS; alarmGroupIndex++)
    {
        /* Write 1 in AGSF bit to clear alarm */
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroupIndex].STS.U = 0xFFFFFFFFU;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSSE, IfxApProt_State_run);
#endif
}


boolean IfxSmu_Smu_isSafetyAlarmTriggered(boolean smuSafeIndex, uint8 groupNo)
{
    boolean result = FALSE;

    if ((MODULE_SMU.SAFE[smuSafeIndex].AGSF[groupNo].STS.U != 0))
    {
        result = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}


void IfxSmu_Smu_initSecurityModuleConfig(IfxSmu_Smu_SecurityConfig *config)
{
    const IfxSmu_Smu_SecurityConfig IfxSmu_Smu_defaultConfig = {
        .globalConfig                        = {
            .securityRecoveryTimerConfig     = {
                .enableRecoveryTimer0        = FALSE,
                .PrescalarRecoveryTimerClock = 0,
                .recoveryTimerDuration       = 0
            },
            .recoveryTimerAlarmConfig        = {
                .groupIndex0 = 0,
                .alarmId0    = 0,
                .groupIndex1 = 0,
                .alarmId1    = 0,
                .groupIndex2 = 0,
                .alarmId2    = 0,
                .groupIndex3 = 0,
                .alarmId3    = 0
            },
        },
        .alarmConfigRegister[0][0] = 0,
        .alarmConfigRegister[0][1] = 0,
        .alarmConfigRegister[0][2] = 0,
        .alarmConfigRegister[1][0] = 0,
        .alarmConfigRegister[1][1] = 0,
        .alarmConfigRegister[1][2] = 0,
    };

    *config = IfxSmu_Smu_defaultConfig;
}


void IfxSmu_Smu_initSecurityModule(IfxSmu_Smu_SecurityConfig *config)
{
    uint8 alarmGroupIndex = 0U;

    /* Initialize the Global SMU SECURE configurations */
    IfxSmu_Smu_initSecurityGlobal(&config->globalConfig);

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.CS.KEYS.U = (uint32)0x000000bc;

    for (alarmGroupIndex = 0U; alarmGroupIndex < IFXSMU_NUM_OF_SECURITY_ALARM_GROUPS; alarmGroupIndex++)
    {
        MODULE_SMU.CS.AGCS[alarmGroupIndex].CON[0].U = config->alarmConfigRegister[alarmGroupIndex][0];
        MODULE_SMU.CS.AGCS[alarmGroupIndex].CON[1].U = config->alarmConfigRegister[alarmGroupIndex][1];
        MODULE_SMU.CS.AGCS[alarmGroupIndex].CON[2].U = config->alarmConfigRegister[alarmGroupIndex][2];
    }

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.CS.KEYS.U = 0;

    /* Write SMU_ASCE(0) in CSCMD register */
    MODULE_SMU.CS.CMD.U = IfxSmu_Command_alarmStatusClear;

    /* disable the write-protection for registers */

    /* Clear all SECURE SMU Alarms */
    for (alarmGroupIndex = 0U; alarmGroupIndex < IFXSMU_NUM_OF_SECURITY_ALARM_GROUPS; alarmGroupIndex++)
    {
        /* Write 1 in AGCS bit to clear alarm */
        MODULE_SMU.CS.AGCS[alarmGroupIndex].STS.U = 0xFFFFFFFFU;
    }
}


boolean IfxSmu_Smu_isSecurityAlarmTriggered(uint8 groupNo)
{
    boolean result = FALSE;

    if ((MODULE_SMU.CS.AGCS[groupNo].STS.U != 0))
    {
        result = TRUE;
    }
    else
    {
        result = FALSE;
    }

    return result;
}


boolean IfxSmu_Smu_isSharedAlarmTriggered(IfxSmu_SharedType SharedType, boolean smuSafeIndex, uint8 groupNo)
{
    boolean result = FALSE;

    if (SharedType == IfxSmu_SharedType_safety)
    {
        result = IfxSmu_Smu_isSafetyAlarmTriggered(smuSafeIndex, groupNo);
    }
    else
    {
        result = IfxSmu_Smu_isSecurityAlarmTriggered(groupNo);
    }

    return result;
}


void IfxSmu_Smu_initSafetyGlobal(IfxSmu_Smu_SafetyGlobalConfig *config, boolean smuSafeIndex)
{
    Ifx_SMU_SAFE_AGC    agcSfr;
    Ifx_SMU_SAFE_RTC    rtcSfr;

    Ifx_SMU_SAFE_RT0ACA rtacSfr0A;
    Ifx_SMU_SAFE_RT0ACB rtacSfr0B;
    Ifx_SMU_SAFE_RT1ACA rtacSfr1A;
    Ifx_SMU_SAFE_RT1ACB rtacSfr1B;

    agcSfr.U        = MODULE_SMU.SAFE[smuSafeIndex].AGC.U;
    agcSfr.B.IGCS0  = config->alarmGlobalConfig.igcs0;
    agcSfr.B.IGCS1  = config->alarmGlobalConfig.igcs1;
    agcSfr.B.IGCS2  = config->alarmGlobalConfig.igcs2;
    agcSfr.B.RCS0   = config->alarmGlobalConfig.resetConfigSet0;
    agcSfr.B.RCS1   = config->alarmGlobalConfig.resetConfigSet1;
    agcSfr.B.EFRST0 = config->alarmGlobalConfig.enableFaultToRunTransition0;
    agcSfr.B.EFRST1 = config->alarmGlobalConfig.enableFaultToRunTransition1;
    agcSfr.B.ESSM1  = config->alarmGlobalConfig.enableStartToRunState;

    rtcSfr.U        = MODULE_SMU.SAFE[smuSafeIndex].RTC.U;
    rtcSfr.B.RT0E   = config->safetyRecoveryTimerConfig.enableRecoveryTimer0;
    rtcSfr.B.RT1E   = config->safetyRecoveryTimerConfig.enableRecoveryTimer1;
    rtcSfr.B.PRE    = config->safetyRecoveryTimerConfig.PrescalarRecoveryTimerClock;
    rtcSfr.B.RTD    = config->safetyRecoveryTimerConfig.recoveryTimerDuration;

    /* Recovery Timer 0 Alarm Configuration 0 */
    rtacSfr0A.U       = MODULE_SMU.SAFE[smuSafeIndex].RT0ACA.U;

    rtacSfr0A.B.GID0  = config->recoveryTimerAlarmConfig[0].groupIndex0;
    rtacSfr0A.B.ALID0 = config->recoveryTimerAlarmConfig[0].alarmId0;
    rtacSfr0A.B.GID1  = config->recoveryTimerAlarmConfig[0].groupIndex1;
    rtacSfr0A.B.ALID1 = config->recoveryTimerAlarmConfig[0].alarmId1;

    /* Recovery Timer 0 Alarm Configuration 1 */
    rtacSfr0B.U       = MODULE_SMU.SAFE[smuSafeIndex].RT0ACB.U;

    rtacSfr0B.B.GID2  = config->recoveryTimerAlarmConfig[0].groupIndex2;
    rtacSfr0B.B.ALID2 = config->recoveryTimerAlarmConfig[0].alarmId2;
    rtacSfr0B.B.GID3  = config->recoveryTimerAlarmConfig[0].groupIndex3;
    rtacSfr0B.B.ALID3 = config->recoveryTimerAlarmConfig[0].alarmId3;

    /* Recovery Timer 1 Alarm Configuration 0 */
    rtacSfr1A.U       = MODULE_SMU.SAFE[smuSafeIndex].RT1ACA.U;

    rtacSfr1A.B.GID0  = config->recoveryTimerAlarmConfig[1].groupIndex0;
    rtacSfr1A.B.ALID0 = config->recoveryTimerAlarmConfig[1].alarmId0;
    rtacSfr1A.B.GID1  = config->recoveryTimerAlarmConfig[1].groupIndex1;
    rtacSfr1A.B.ALID1 = config->recoveryTimerAlarmConfig[1].alarmId1;

    /* Recovery Timer 1 Alarm Configuration 1 */
    rtacSfr1B.U       = MODULE_SMU.SAFE[smuSafeIndex].RT1ACB.U;

    rtacSfr1B.B.GID2  = config->recoveryTimerAlarmConfig[1].groupIndex2;
    rtacSfr1B.B.ALID2 = config->recoveryTimerAlarmConfig[1].alarmId2;
    rtacSfr1B.B.GID3  = config->recoveryTimerAlarmConfig[1].groupIndex3;
    rtacSfr1B.B.ALID3 = config->recoveryTimerAlarmConfig[1].alarmId3;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSSE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.SAFE[smuSafeIndex].KEYS.U   = (uint32)0x000000bc;

    MODULE_SMU.SAFE[smuSafeIndex].AGC.U    = agcSfr.U;
    MODULE_SMU.SAFE[smuSafeIndex].RTC.U    = rtcSfr.U;
    MODULE_SMU.SAFE[smuSafeIndex].RT0ACA.U = rtacSfr0A.U;
    MODULE_SMU.SAFE[smuSafeIndex].RT0ACB.U = rtacSfr0B.U;
    MODULE_SMU.SAFE[smuSafeIndex].RT1ACA.U = rtacSfr1A.U;
    MODULE_SMU.SAFE[smuSafeIndex].RT1ACB.U = rtacSfr1B.U;

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.SAFE[smuSafeIndex].KEYS.U = 0;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSSE, IfxApProt_State_run);
#endif
}


void IfxSmu_Smu_initSecurityGlobal(IfxSmu_Smu_SecurityGlobalConfig *config)
{
    Ifx_SMU_CS_RTC    rtcSfr;

    Ifx_SMU_CS_RT0ACA rtacSfr0A;
    Ifx_SMU_CS_RT0ACB rtacSfr0B;

    /* Configure SMU module register as per the requested configuration */
    rtcSfr.U      = MODULE_SMU.CS.RTC.U;
    rtcSfr.B.RT0E = config->securityRecoveryTimerConfig.enableRecoveryTimer0;
    rtcSfr.B.PRE  = config->securityRecoveryTimerConfig.PrescalarRecoveryTimerClock;
    rtcSfr.B.RTD  = config->securityRecoveryTimerConfig.recoveryTimerDuration;

    /* Recovery Timer 0 Alarm Configuration 0 */
    rtacSfr0A.U       = MODULE_SMU.CS.RT0ACA.U;

    rtacSfr0A.B.GID0  = config->recoveryTimerAlarmConfig.groupIndex0;
    rtacSfr0A.B.ALID0 = config->recoveryTimerAlarmConfig.alarmId0;
    rtacSfr0A.B.GID1  = config->recoveryTimerAlarmConfig.groupIndex1;
    rtacSfr0A.B.ALID1 = config->recoveryTimerAlarmConfig.alarmId1;

    /* Recovery Timer 0 Alarm Configuration 1 */
    rtacSfr0B.U       = MODULE_SMU.CS.RT0ACB.U;

    rtacSfr0B.B.GID2  = config->recoveryTimerAlarmConfig.groupIndex2;
    rtacSfr0B.B.ALID2 = config->recoveryTimerAlarmConfig.alarmId2;
    rtacSfr0B.B.GID3  = config->recoveryTimerAlarmConfig.groupIndex3;
    rtacSfr0B.B.ALID3 = config->recoveryTimerAlarmConfig.alarmId3;

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.CS.KEYS.U   = (uint32)0x000000bc;

    MODULE_SMU.CS.RTC.U    = rtcSfr.U;
    MODULE_SMU.CS.RT0ACA.U = rtacSfr0A.U;
    MODULE_SMU.CS.RT0ACB.U = rtacSfr0B.U;

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.CS.KEYS.U = 0;
}


void IfxSmu_Smu_setSharedSelectionRegister(IfxSmu_SharedType SharedType, IfxSmu_Alarm alarm)
{
    uint16 alarmGroup = ((int)alarm >> 5);
    uint8  alarmPos   = (int)alarm & 0x1F;
    uint32 mask       = 0U;

    if (SharedType == IfxSmu_SharedType_safety)
    {
        MODULE_SMU.GCC.AGSH[alarmGroup].SEL.U |= (uint32)(1 << alarmPos);
    }
    else
    {
        /* If Alarm mapped to safety and user trying to re-configure to secure
         * then reset the bit in GCC and proceed with configuration
         */
        if (((MODULE_SMU.GCC.AGSH[alarmGroup].SEL.U & (uint32)(1 << alarmPos)) >> alarmPos) != 0U)
        {
            mask                                   = (uint32)(1 << alarmPos);
            MODULE_SMU.GCC.AGSH[alarmGroup].SEL.U &= ~(mask);
        }

        MODULE_SMU.CS.AGSH[alarmGroup].SEL.U |= (uint32)(1 << alarmPos);
    }
}
