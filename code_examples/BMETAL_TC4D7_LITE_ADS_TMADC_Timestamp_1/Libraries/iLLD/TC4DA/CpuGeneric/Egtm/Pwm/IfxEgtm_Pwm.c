/**
 * \file IfxEgtm_Pwm.c
 * \brief EGTM PWM details
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxEgtm_Pwm.h"

/******************************************************************************/
/*----------------------------------Macros------------------------------------*/
/******************************************************************************/

/** \brief This macro enables the respective PWM channel of the requested PWM module
 */
#define IFXEGTM_PWM_OUTPUT_STAT_ENABLE  (2u)

/** \brief This macro disables the respective PWM channel of the requested PWM module
 */
#define IFXEGTM_PWM_OUTPUT_STAT_DISABLE (1u)

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Get pointer to DTM
 * \param clusterSFR Cluster SFR
 * \param subModule GTM Sub Module
 * \param channel PWM channel
 * \return Returns pointer to DTM if available for given configuration
 */
IFX_INLINE Ifx_EGTM_CLS_CDTM_DTM *IfxEgtm_Pwm_getDtmPtr(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel);

/** \brief Enable Synchronous update of compare registers from shadow registers of the specified channel
 * \param glbCtrl Global control register
 * \param upenMask UPEN Mask of channel
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_enableChannelSyncUpdate(volatile Ifx_UReg_32Bit *glbCtrl, uint32 upenMask);

/** \brief Disable Synchronous update of compare registers from shadow registers of the specified channel
 * \param glbCtrl Global control register
 * \param upenMask UPEN Mask of channel
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_disableChannelSyncUpdate(volatile Ifx_UReg_32Bit *glbCtrl, uint32 upenMask);

/** \brief Enable Synchronous update of all configured channels in AGC/TGC0/TGC1
 * \param pwm PWM handle
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_enableChannelsSyncUpdate(IfxEgtm_Pwm *pwm);

/** \brief Disable Synchronous update of all configured channels in AGC/TGC0/TGC1
 * \param pwm PWM handle
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_disableChannelsSyncUpdate(IfxEgtm_Pwm *pwm);

/** \brief Enable the (A)TOM channel to start the counter when trigger is received
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_enableChannel(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel);

/** \brief Enables the (A)TOM channel PWM output
 * Note: Channel starts generating PWM after receiving trigger
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_enableChannelOutput(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel);

/** \brief Sets the (A)TOM channel clock source
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \param clockSource Configured clock source
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_setClockSource(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, IfxEgtm_Pwm_ClockSource clockSource);

/** \brief Set counter to reset either on CM0 match or when trigger is received
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \param event Reset event
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_setCounterResetEvent(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, IfxEgtm_Pwm_ResetEvent event);

/** \brief Set counter mode according to PWM signal alignment
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \param alignment PWM signal alignment
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_setCounterMode(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, IfxEgtm_Pwm_Alignment alignment);

/** \brief Generate a trigger when CN0 = CM0
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \param enabled TRUE: Generate trigger
 * FALSE: Forward trigger
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_generateTrigger(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, boolean enabled);

/** \brief Initializes pin for base/sync channel based on submodule
 * \param pwm PWM handle
 * \param pin Pin configuration
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_initPin(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_Pin *pin);

/** \brief Function to configure Time base register with default values to generate trigger
 * \param clusterSFR Pointer to the Cluster object
 * \param subModule ATOM/TOM
 * \param channel Channel index
 * \param compareValue Generate trigger when counter reaches this value
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_configureTimeBaseTrigger(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, uint32 compareValue);

/** \brief Update base channel frequency with requested value at the end of period (synchronously)
 * \param pwm PWM handle
 * \param requestFrequency Requested frequency in Hz
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_updateBaseChannelFrequency(IfxEgtm_Pwm *pwm, float32 requestFrequency);

/** \brief Update base channel frequency with requested value immediately (asynchronously)
 * \param pwm PWM handle
 * \param requestFrequency Requested frequency in Hz
 * \return None
 */
IFX_INLINE void IfxEgtm_Pwm_updateBaseChannelFrequencyImmediate(IfxEgtm_Pwm *pwm, float32 requestFrequency);

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Returns clock frequency in Hz of the clock source configured for Atom/Tom
 * \param pwm PWM handle
 * \param egtmSFR egtmSFR
 * \param clockSource Clock configuration
 * \return Clock frequency in Hz
 */
IFX_STATIC float32 IfxEgtm_Pwm_getSubModuleClockFrequency(IfxEgtm_Pwm *pwm, Ifx_EGTM *egtmSFR, IfxEgtm_Pwm_ClockSource clockSource);

/** \brief Returns clock frequency in Hz of the clock source configured for Dtm
 * \param pwm PWM handle
 * \param egtmSFR egtmSFR
 * \param clockSource Clock configuration
 * \return Clock frequency in Hz
 */
IFX_STATIC float32 IfxEgtm_Pwm_getDtmClockFrequency(IfxEgtm_Pwm *pwm, Ifx_EGTM *egtmSFR, IfxEgtm_Dtm_ClockSource clockSource);

/** \brief Initializes the base/sync channel with user configuration for PWM generation
 * \param pwm PWM handle
 * \param config Configuration structure
 * \param configIndex Index of channel to be initialized
 * \return None
 */
IFX_STATIC void IfxEgtm_Pwm_initChannel(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_Config *config, IfxEgtm_Pwm_SyncChannelIndex configIndex);

/** \brief Initializes interrupt for base/sync channel
 * \param pwm PWM handle
 * \param interrupt Interrupt configuration
 * \param channel Channel Handle
 * \return None
 */
IFX_STATIC void IfxEgtm_Pwm_initInterrupts(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_InterruptConfig *interrupt, IfxEgtm_Pwm_Channel *channel);

/** \brief Updates PWM handle with pointers and masks for TGC/AGC after channel configuration
 * This data is used dusring run time for fast access
 * \param pwm PWM handle
 * \return None
 */
IFX_STATIC void IfxEgtm_Pwm_updateGlobalControlUnitData(IfxEgtm_Pwm *pwm);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE Ifx_EGTM_CLS_CDTM_DTM *IfxEgtm_Pwm_getDtmPtr(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel)
{
    Ifx_EGTM_CLS_CDTM_DTM *dtmSFR;

    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        /* ATOM 0..7 connects to DTM 4..5 */
        dtmSFR = &clusterSFR->CDTM.DTM[(uint8)((uint8)channel >> (uint8)2u) + 4u];
    }
    else    /* TOM */
    {
        /* TOM 0..15 connects to DTM 0..3 */
        dtmSFR = &clusterSFR->CDTM.DTM[(uint8)((uint8)channel >> (uint8)2u)];
    }

    return dtmSFR;
}


IFX_INLINE void IfxEgtm_Pwm_enableChannelSyncUpdate(volatile Ifx_UReg_32Bit *glbCtrl, uint32 upenMask)
{
    *glbCtrl = upenMask & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;
}


IFX_INLINE void IfxEgtm_Pwm_disableChannelSyncUpdate(volatile Ifx_UReg_32Bit *glbCtrl, uint32 upenMask)
{
    *glbCtrl = upenMask & (uint32)IFXEGTM_PWM_UPEN_DISABLE_VALUE;
}


IFX_INLINE void IfxEgtm_Pwm_enableChannelsSyncUpdate(IfxEgtm_Pwm *pwm)
{
    IfxEgtm_Pwm_GlobalControl *globalctrl = &pwm->globalControl;

    /* Enable UPEN in TGC0/1 or AGC if all channels are in one control unit */
    if (pwm->globalControl.reg1 == NULL_PTR)
    {
        *globalctrl->reg0 = pwm->globalControl.upenMask0 & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;
    }
    /* Enable UPEN in TGC0,1 if all channels not in one control unit */
    else
    {
        *globalctrl->reg0 = pwm->globalControl.upenMask0 & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;
        *globalctrl->reg1 = pwm->globalControl.upenMask1 & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;
    }
}


IFX_INLINE void IfxEgtm_Pwm_disableChannelsSyncUpdate(IfxEgtm_Pwm *pwm)
{
    IfxEgtm_Pwm_GlobalControl *globalctrl = &pwm->globalControl;

    /* Disable UPEN in TGC0/1 or AGC if all channels are in one control unit */
    if (pwm->globalControl.reg1 == NULL_PTR)
    {
        *globalctrl->reg0 = pwm->globalControl.upenMask0 & (uint32)IFXEGTM_PWM_UPEN_DISABLE_VALUE;
    }
    /* Disable UPEN in TGC0,1 if all channels not in one control unit */
    else
    {
        *globalctrl->reg0 = pwm->globalControl.upenMask0 & (uint32)IFXEGTM_PWM_UPEN_DISABLE_VALUE;
        *globalctrl->reg1 = pwm->globalControl.upenMask1 & (uint32)IFXEGTM_PWM_UPEN_DISABLE_VALUE;
    }
}


IFX_INLINE void IfxEgtm_Pwm_enableChannel(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel)
{
    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        IfxEgtm_Atom_Agc_enableChannel(&clusterSFR->ATOM.AGC, (IfxEgtm_Atom_Ch)channel, TRUE, FALSE);
    }
    else    /* TOM */
    {
        IfxEgtm_Tom_Tgc_enableChannel(&clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(channel)], (IfxEgtm_Tom_Ch)channel, TRUE, FALSE);
    }
}


IFX_INLINE void IfxEgtm_Pwm_enableChannelOutput(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel)
{
    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        IfxEgtm_Atom_Agc_enableChannelOutput(&clusterSFR->ATOM.AGC, (IfxEgtm_Atom_Ch)channel, TRUE, FALSE);
    }
    else    /* TOM */
    {
        IfxEgtm_Tom_Tgc_enableChannelOutput(&clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(channel)], (IfxEgtm_Tom_Ch)channel, TRUE, FALSE);
    }
}


IFX_INLINE void IfxEgtm_Pwm_setClockSource(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, IfxEgtm_Pwm_ClockSource clockSource)
{
    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        clusterSFR->ATOM.CH[channel].CTRL.B.CLK_SRC       = (uint8)clockSource.atom;
        clusterSFR->ATOM.CH[channel].CTRL_SR.B.CLK_SRC_SR = (uint8)clockSource.atom;
    }
    else    /* TOM */
    {
        clusterSFR->TOM.CH[channel].CTRL.B.CLK_SRC       = (uint8)clockSource.tom;
        clusterSFR->TOM.CH[channel].CTRL_SR.B.CLK_SRC_SR = (uint8)clockSource.tom;
    }
}


IFX_INLINE void IfxEgtm_Pwm_setCounterResetEvent(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, IfxEgtm_Pwm_ResetEvent event)
{
    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        clusterSFR->ATOM.CH[channel].CTRL.B.RST_CCU0 = (uint8)event;
    }
    else    /* TOM */
    {
        clusterSFR->TOM.CH[channel].CTRL.B.RST_CCU0 = (uint8)event;
    }
}


IFX_INLINE void IfxEgtm_Pwm_setCounterMode(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, IfxEgtm_Pwm_Alignment alignment)
{
    /* Edge aligned: b00 Count always up
     * Center aligned: b01 Count up and down and update CM0/1 when counter reaches 0 */
    uint8 counterMode = (alignment == IfxEgtm_Pwm_Alignment_center) ? 1u : 0u;

    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        clusterSFR->ATOM.CH[channel].CTRL.B.UDMODE = counterMode;
    }
    else    /* TOM */
    {
        clusterSFR->TOM.CH[channel].CTRL.B.UDMODE = counterMode;
    }
}


IFX_INLINE void IfxEgtm_Pwm_generateTrigger(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, boolean enabled)
{
    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        clusterSFR->ATOM.CH[channel].CTRL.B.TRIGOUT = (uint8)enabled;
    }
    else    /* TOM */
    {
        clusterSFR->TOM.CH[channel].CTRL.B.TRIGOUT = (uint8)enabled;
    }
}


IFX_INLINE void IfxEgtm_Pwm_initPin(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_Pin *pin)
{
    if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        IfxEgtm_PinMap_setAtomTout(&pin->outputPin->atom, pin->outputMode, pin->padDriver);
    }
    else    /* TOM */
    {
        IfxEgtm_PinMap_setTomTout(&pin->outputPin->tom, pin->outputMode, pin->padDriver);
    }
}


IFX_INLINE void IfxEgtm_Pwm_configureTimeBaseTrigger(Ifx_EGTM_CLS *clusterSFR, IfxEgtm_Pwm_SubModule subModule, IfxEgtm_Pwm_SubModule_Ch channel, uint32 compareValue)
{
    Ifx_EGTM_CLS_ATOM_AGC_ACT_TB actTbReg;

    actTbReg.B.ACT_TB  = compareValue;      /* Compare Value */
    actTbReg.B.TBU_SEL = 0x0u;              /* TBU_TS0 */
    actTbReg.B.TB_TRIG = 0x1u;              /* Trigger when compare value matches */

    if (subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        clusterSFR->ATOM.AGC.ACT_TB.U = actTbReg.U;
    }
    else
    {
        clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(channel)].ACT_TB.U = actTbReg.U;
    }
}


IFX_INLINE void IfxEgtm_Pwm_updateBaseChannelFrequency(IfxEgtm_Pwm *pwm, float32 requestFrequency)
{
    IfxEgtm_Pwm_Channel *channel = &pwm->channels[0];

    /* Calculate period ticks (round to nearest integer) */
    uint32               periodTicks = (uint32)((float32)((pwm->sourceFrequency / requestFrequency) + (float32)0.5f));

    /* Divide by 2 for center aligned and add 1 (to reach desired value) */
    if (pwm->alignment != IfxEgtm_Pwm_Alignment_edge)
    {
        periodTicks = (periodTicks >> 1) + 1;
    }

    /* Copy to handle */
    pwm->periodTicks = periodTicks;
    pwm->frequency   = requestFrequency;

    /* Update shadow register */
    *channel->registers.SR0 = periodTicks;
}


IFX_INLINE void IfxEgtm_Pwm_updateBaseChannelFrequencyImmediate(IfxEgtm_Pwm *pwm, float32 requestFrequency)
{
    IfxEgtm_Pwm_Channel *channel = &pwm->channels[0];

    /* Calculate period ticks (round to nearest integer) */
    uint32               periodTicks = (uint32)((float32)((pwm->sourceFrequency / requestFrequency) + (float32)0.5f));

    /* Divide by 2 for center aligned and add 1 (to reach desired value) */
    if (pwm->alignment != IfxEgtm_Pwm_Alignment_edge)
    {
        periodTicks = (periodTicks >> 1) + 1;
    }

    /* Copy to handle */
    pwm->periodTicks = periodTicks;
    pwm->frequency   = requestFrequency;

    /* Update compare register */
    *channel->registers.SR0 = periodTicks;
    *channel->registers.CM0 = periodTicks;
}


/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxEgtm_Pwm_initConfig(IfxEgtm_Pwm_Config *config, Ifx_EGTM *egtmSFR)
{
    IfxEgtm_Pwm_Config defaultConfig = {
        .egtmSFR     = NULL_PTR,
        .cluster     = IfxEgtm_Cluster_0,
        .subModule   = IfxEgtm_Pwm_SubModule_atom,
        .alignment   = IfxEgtm_Pwm_Alignment_center,
        .numChannels = 0,
        .channels    = NULL_PTR,
        .frequency   = IFXEGTM_PWM_DEFAULT_FREQUENCY,
        {
            .atom          = IfxEgtm_Cmu_Clk_0,
        },
        .dtmClockSource    = IfxEgtm_Dtm_ClockSource_systemClock,
        .syncUpdateEnabled = TRUE,
        .syncStart         = TRUE
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* Copy SFR */
    config->egtmSFR = egtmSFR;
}


void IfxEgtm_Pwm_initChannelConfig(IfxEgtm_Pwm_ChannelConfig *channelConfig)
{
    IfxEgtm_Pwm_ChannelConfig defaultConfig = {
        .timerCh   = IfxEgtm_Pwm_SubModule_Ch_0,
        .phase     = 0.0f,
        .duty      = 0.0f,
        .dtm       = NULL_PTR,
        .output    = NULL_PTR,
        .mscOut    = NULL_PTR,
        .interrupt = NULL_PTR,
    };

    /* Default Configuration */
    *channelConfig = defaultConfig;
}


void IfxEgtm_Pwm_init(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_Channel *channels, IfxEgtm_Pwm_Config *config)
{
    uint8 idx = 0;

    /* 1. Change state to unknown */
    pwm->state = IfxEgtm_Pwm_State_unknown;

    /* 2. Copy config data */
    pwm->egtmSFR           = config->egtmSFR;
    pwm->clusterSFR        = &config->egtmSFR->CLS[(uint32)config->cluster];
    pwm->alignment         = config->alignment;
    pwm->syncUpdateEnabled = config->syncUpdateEnabled;
    pwm->subModule         = config->subModule;
    pwm->channels          = channels;
    pwm->cluster           = config->cluster;
    pwm->numChannels       = 0u;
    pwm->frequency         = config->frequency;
    pwm->clockSource       = config->clockSource;
    pwm->dtmClockSource    = config->dtmClockSource;

    /* 3. Get Clock information */
    pwm->sourceFrequency = IfxEgtm_Pwm_getSubModuleClockFrequency(pwm, config->egtmSFR, config->clockSource);

    pwm->dtmFrequency    = IfxEgtm_Pwm_getDtmClockFrequency(pwm, config->egtmSFR, pwm->dtmClockSource);

    /* 4. Perform software reset of PWM channels */
    idx = (uint8)config->channels[0].timerCh;

    while (idx <= (uint8)config->channels[config->numChannels - 1u].timerCh)   /* Reset all channels in range even if not configured by user */
    {
        if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
        {
            pwm->clusterSFR->ATOM.AGC.GLB_CTRL.U = 1u << (IFX_EGTM_CLS_ATOM_AGC_GLB_CTRL_RST_CH0_OFF + idx);
        }
        else
        {
            pwm->clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(idx)].GLB_CTRL.U = 1u << (IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_RST_CH0_OFF + (idx & 0x7u));
        }

        idx++;
    }

    /* 5. Initialize PWM channels */
    for (idx = 0; idx < config->numChannels; idx++)
    {
        IfxEgtm_Pwm_initChannel(pwm, config, (IfxEgtm_Pwm_SyncChannelIndex)idx);

        /* Update handle */
        pwm->numChannels += 1;
    }

    /* 6. Update masks and pointers to GLB_CTRL registers */
    IfxEgtm_Pwm_updateGlobalControlUnitData(pwm);

    /* 7. Change state */
    pwm->state = IfxEgtm_Pwm_State_init;

    /* 8. Synchronously start the channels */
    if (config->syncStart == TRUE)
    {
        IfxEgtm_Pwm_startSyncedChannels(pwm);
    }
}


IFX_STATIC float32 IfxEgtm_Pwm_getSubModuleClockFrequency(IfxEgtm_Pwm *pwm, Ifx_EGTM *egtmSFR, IfxEgtm_Pwm_ClockSource clockSource)
{
    float32 frequency = 0.0f;

    /* Get PWM channel frequency */
    if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        frequency = IfxEgtm_Cmu_getClkFrequency(egtmSFR, clockSource.atom, FALSE);
    }
    else    /* TOM */
    {
        frequency = IfxEgtm_Cmu_getFxClkFrequency(egtmSFR, clockSource.tom, FALSE);
    }

    return frequency;
}


IFX_STATIC float32 IfxEgtm_Pwm_getDtmClockFrequency(IfxEgtm_Pwm *pwm, Ifx_EGTM *egtmSFR, IfxEgtm_Dtm_ClockSource clockSource)
{
    float32 dtmFrequency = 0.0f;

    /* Get DTM clock frequency */
    switch (clockSource)
    {
    case IfxEgtm_Dtm_ClockSource_systemClock:   /* SYS_CLK selected */
    {
        dtmFrequency = IfxEgtm_Cmu_getModuleFrequency(egtmSFR);
        break;
    }
    case IfxEgtm_Dtm_ClockSource_cmuClock0:     /* CMU_CLK0 selected */
    {
        dtmFrequency = IfxEgtm_Cmu_getClkFrequency(egtmSFR, IfxEgtm_Cmu_Clk_0, FALSE);
        break;
    }
    case IfxEgtm_Dtm_ClockSource_cmuClock1:
    {
        if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)   /* CMU_CLK1 selected (if DTM is connected to an ATOM) */
        {
            dtmFrequency = IfxEgtm_Cmu_getClkFrequency(egtmSFR, IfxEgtm_Cmu_Clk_1, FALSE);
        }
        else                                                /* CMU_FXCLK0 selected (if DTM is connected to a TOM) */
        {
            dtmFrequency = IfxEgtm_Cmu_getFxClkFrequency(egtmSFR, IfxEgtm_Cmu_Fxclk_0, FALSE);
        }

        break;
    }
    case IfxEgtm_Dtm_ClockSource_cmuClock2:
    {
        if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)   /* CMU_CLK2 selected (if DTM is connected to an ATOM) */
        {
            dtmFrequency = IfxEgtm_Cmu_getClkFrequency(egtmSFR, IfxEgtm_Cmu_Clk_2, FALSE);
        }
        else                                                /* CMU_FXCLK1 selected (if DTM is connected to a TOM) */
        {
            dtmFrequency = IfxEgtm_Cmu_getFxClkFrequency(egtmSFR, IfxEgtm_Cmu_Fxclk_1, FALSE);
        }

        break;
    }
    default:
        /* do nothing */
        break;
    }

    return dtmFrequency;
}


IFX_STATIC void IfxEgtm_Pwm_initChannel(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_Config *config, IfxEgtm_Pwm_SyncChannelIndex configIndex)
{
    boolean                    baseChannel   = (configIndex == IfxEgtm_Pwm_SyncChannelIndex_0) ? TRUE : FALSE;
    IfxEgtm_Pwm_ChannelConfig *channelConfig = &config->channels[configIndex];
    IfxEgtm_Pwm_SubModule      subModule     = pwm->subModule;
    Ifx_EGTM_CLS              *clusterSFR    = pwm->clusterSFR;
    IfxEgtm_Pwm_Channel       *channel       = &pwm->channels[configIndex];
    IfxEgtm_Pwm_SubModule_Ch   channelIndex  = channelConfig->timerCh;

    channel->timerCh = channelIndex;

    /* 0. Store pointers to registers for faster access later */
    {
        channel->upenMask = (uint32)((uint32)IFXEGTM_ATOM_AGC_CHANNEL_MASK << IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channelIndex, IFX_EGTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF));

        if (subModule == IfxEgtm_Pwm_SubModule_atom)
        {
            channel->registers.SR0        = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.CH[channelIndex].SR0.U;
            channel->registers.SR1        = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.CH[channelIndex].SR1.U;
            channel->registers.CM0        = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.CH[channelIndex].CM0.U;
            channel->registers.CM1        = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.CH[channelIndex].CM1.U;
            channel->registers.CN0        = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.CH[channelIndex].CN0.U;
            channel->registers.CTRL       = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.CH[channelIndex].CTRL.U;
            channel->registers.GLB_CTRL   = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.AGC.GLB_CTRL.U;
            channel->registers.IRQ_NOTIFY = (volatile Ifx_UReg_32Bit *)&clusterSFR->ATOM.CH[channelIndex].IRQ_NOTIFY.U;
        }
        else
        {
            channel->registers.SR0        = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.CH[channelIndex].SR0.U;
            channel->registers.SR1        = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.CH[channelIndex].SR1.U;
            channel->registers.CM0        = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.CH[channelIndex].CM0.U;
            channel->registers.CM1        = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.CH[channelIndex].CM1.U;
            channel->registers.CN0        = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.CH[channelIndex].CN0.U;
            channel->registers.CTRL       = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.CH[channelIndex].CTRL.U;
            channel->registers.GLB_CTRL   = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(channelIndex)].GLB_CTRL.U;
            channel->registers.IRQ_NOTIFY = (volatile Ifx_UReg_32Bit *)&clusterSFR->TOM.CH[channelIndex].IRQ_NOTIFY.U;
        }
    }

    /* 1. Configure global control unit */
    {
        /* 1.1 Enable update of CM0/1 from shadow registers */
        if (pwm->syncUpdateEnabled == TRUE)
        {
            IfxEgtm_Pwm_enableChannelSyncUpdate(channel->registers.GLB_CTRL, channel->upenMask);
        }
        else
        {
            IfxEgtm_Pwm_disableChannelSyncUpdate(channel->registers.GLB_CTRL, channel->upenMask);
        }

        /* 1.2 Set channel to start counter when trigger is received */
        IfxEgtm_Pwm_enableChannel(clusterSFR, subModule, channelIndex);

        /* 1.3 Set channel to start PWM output when trigger is received */
        IfxEgtm_Pwm_enableChannelOutput(clusterSFR, subModule, channelIndex);
    }

    /* 2. Configure TOM/ATOM channel */
    Ifx_ActiveState channelPolarity = (channelConfig->output != NULL_PTR) ? channelConfig->output->polarity : Ifx_ActiveState_high;
    {
        /* 2.1 Set channel clock source */
        IfxEgtm_Pwm_setClockSource(clusterSFR, subModule, channelIndex, pwm->clockSource);

        /* 2.2 Set Signal Polarity value here */
        IfxEgtm_Pwm_setChannelPolarity(clusterSFR, subModule, channelIndex, channelPolarity);

        if (subModule == IfxEgtm_Pwm_SubModule_atom)
        {
            /* 2.3 Set ATOM signal output mode as PWM */
            clusterSFR->ATOM.CH[channelIndex].CTRL.B.MODE = (uint8)IfxEgtm_Atom_Mode_outputPwm;
        }

        /* 2.4 If base channel then generate trigger when CN0 matches CM0. This trigger will be used by sync channels
         * else if sync channel then disable trigger (forward from last channel) */
        IfxEgtm_Pwm_generateTrigger(clusterSFR, subModule, channelIndex, baseChannel);
    }

    /* 3. Perform counter related configuration */
    {
        /* 3.1 Reset counter to 0 */
        *channel->registers.CN0 = 0x0u;

        /* 3.2 If base channel then reset counter value on CM0 match
         * else reset counter value on trigger from base channel */
        IfxEgtm_Pwm_ResetEvent resetEvent = (baseChannel == TRUE) ? IfxEgtm_Pwm_ResetEvent_onCm0 : IfxEgtm_Pwm_ResetEvent_onTrigger;
        IfxEgtm_Pwm_setCounterResetEvent(clusterSFR, subModule, channelIndex, resetEvent);

        /* 3.3 Set counter mode according to wave alignment */
        IfxEgtm_Pwm_setCounterMode(clusterSFR, subModule, channelIndex, pwm->alignment);
    }

    /* 4. Calculate and set compare value registers */
    {
        /* 4.1 Calculate and set channel PWM frequency. Frequency check already performed */
        if (baseChannel == TRUE)
        {
            IfxEgtm_Pwm_updateBaseChannelFrequency(pwm, pwm->frequency);
            channel->phaseTicks     = 0x0u;
            *channel->registers.CM0 = pwm->periodTicks;
        }
        /* 4.2 Calculate and set channel PWM phase shift for sync channels */
        else if (pwm->alignment == IfxEgtm_Pwm_Alignment_edge)
        {
            IfxEgtm_Pwm_updateChannelPhase(pwm, configIndex, channelConfig->phase);
            *channel->registers.CM0 = channel->phaseTicks;
        }
        else
        {}

        /* 4.3 Calculate and set channel PWM Duty */
        IfxEgtm_Pwm_updateChannelDuty(pwm, configIndex, channelConfig->duty);
        *channel->registers.CM1 = channel->dutyTicks;
    }

    /* 5. Configure Dead time module */
    {
        IfxEgtm_Dtm_Ch         dtmChannel = (IfxEgtm_Dtm_Ch)((uint8)((uint8)channelIndex & 0x3u));
        Ifx_EGTM_CLS_CDTM_DTM *dtmSFR     = IfxEgtm_Pwm_getDtmPtr(pwm->clusterSFR, subModule, channelIndex);

        if (channelConfig->dtm != NULL_PTR)
        {
            /* 5.1 Copy SFR to handle for later use */
            channel->registers.DTV    = (volatile Ifx_UReg_32Bit *)&dtmSFR->CH_DTV[dtmChannel].U;
            channel->registers.DTV_SR = (volatile Ifx_UReg_32Bit *)&dtmSFR->CH_DTV_SR[dtmChannel].U;

            /* 5.2 Set DTM Clock source */
            IfxEgtm_Dtm_setClockSource(dtmSFR, pwm->dtmClockSource);

            /* 5.3 Enable dead time insertion at OUTx and OUTx_N */
            IfxEgtm_Dtm_setOutput0DeadTimePath(dtmSFR, dtmChannel, IfxEgtm_Dtm_DeadTimePath_enable);
            IfxEgtm_Dtm_setOutput1DeadTimePath(dtmSFR, dtmChannel, IfxEgtm_Dtm_DeadTimePath_enable);

            /* 5.4 Invert the signal at OUTx_N */
            IfxEgtm_Dtm_setOutput1Select(dtmSFR, dtmChannel, IfxEgtm_Dtm_Output1Select_inverseDeadTime);

            /* 5.6 Configure dead time values */
            if (config->syncUpdateEnabled == TRUE)
            {
                Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR dtvSrReg;
                dtvSrReg.U                = 0u;   /* Clear register */
                dtvSrReg.B.RELRISE_UPD_EN = 1u;   /* update from shadow */
                dtvSrReg.B.RELFALL_UPD_EN = 1u;

                /* Update at rising edge if pulse is high during duty */
                if (channelPolarity == Ifx_ActiveState_high)
                {
                    dtvSrReg.B.RELRISE_UPD_FE0RE1 = 1u;
                    dtvSrReg.B.RELFALL_UPD_FE0RE1 = 1u;
                }

                *channel->registers.DTV_SR = dtvSrReg.U;
            }

            IfxEgtm_Pwm_updateChannelDeadTimeImmediate(pwm, configIndex, channelConfig->dtm->deadTime);

            /* 5.7 Set complementary pin output polarity
             * Note: By default output polarity of DTM is inverse of original output
             * If same polarity is needed then invert the DTM output
             */
            boolean outputPolarity = ((channelConfig->output != NULL_PTR) && (channelConfig->output->polarity == channelConfig->output->complementaryPolarity)) ? TRUE : FALSE;
            IfxEgtm_Dtm_setOutput1Polarity(dtmSFR, dtmChannel, (IfxEgtm_Dtm_OutputPolarity)outputPolarity);

            /* 5.8 Configure DTM fast shutoff */
            if (channelConfig->dtm->fastShutOff != NULL_PTR)
            {
                IfxEgtm_Pwm_FastShutoffConfig *fastShutoffConfig = channelConfig->dtm->fastShutOff;

                /* -- Use individual channel shutoff -- */
                IfxEgtm_Dtm_enableIndividualShutoff(dtmSFR);

                /* Set shutoff input signal */
                IfxEgtm_Dtm_setShutoffInput(dtmSFR, dtmChannel, fastShutoffConfig->inputSignal);

                /* Set whether input signal is inverted or not */
                IfxEgtm_Dtm_setShutoffInputInverter(dtmSFR, dtmChannel, fastShutoffConfig->invertInputSignal);

                /* Set shutoff update mode: signal sets internal signal SHUTOFF_SYNC_0; internal signal
                 * SHUTOFF_SYNC_0 is cleared by writing to bitfield SHUTOFF_RST_0 */
                IfxEgtm_Dtm_setShutoffUpdateMode(dtmSFR, dtmChannel, 0x1u);

                /* -- Modify DTM_CH2_SR bitfields whose value is transferred to DTM_CH2 once SHUTOFF_SYNC_x signal is activated -- */
                /* Generate constant output equal to shadow signal level once shutoff is activated */
                IfxEgtm_Dtm_setOutput0ShadowChannelControl(dtmSFR, dtmChannel, IfxEgtm_Dtm_ChannelControl_constantOutput);

                /* Generate constant output equal to shadow signal level once shutoff is activated */
                IfxEgtm_Dtm_setOutput1ShadowChannelControl(dtmSFR, dtmChannel, IfxEgtm_Dtm_ChannelControl_constantOutput);

                /* Define signal level at output 0 once shutoff is activated */
                IfxEgtm_Dtm_setOutput0ShadowSignalLevel(dtmSFR, dtmChannel, fastShutoffConfig->offState);

                /* Define signal level at output 1 once shutoff is activated */
                IfxEgtm_Dtm_setOutput1ShadowSignalLevel(dtmSFR, dtmChannel, fastShutoffConfig->complementaryOffState);
            }
        }
        /* Set complementary pin output polarity if Dead time path is not being used. */
        else if ((channelConfig->output != NULL_PTR) && (channelConfig->output->complementaryPin != NULL_PTR))
        {
            /* Invert output if both are not equal */
            boolean outputPolarity1 = ((channelConfig->output->polarity != channelConfig->output->complementaryPolarity)) ? TRUE : FALSE;
            IfxEgtm_Dtm_setOutput1Polarity(dtmSFR, dtmChannel, (IfxEgtm_Dtm_OutputPolarity)(outputPolarity1));
        }
        else
        {}
    }

    /* 6. Initialize Output */
    if (channelConfig->output != NULL_PTR)
    {
        IfxEgtm_Pwm_Pin pin;
        pin.outputMode = channelConfig->output->outputMode;
        pin.padDriver  = channelConfig->output->padDriver;
        pin.outputPin  = channelConfig->output->pin;

        /* Check pin availability and configure output pin */
        if (channelConfig->output->pin != NULL_PTR)
        {
            IfxEgtm_Pwm_initPin(pwm, &pin);
        }

        /* Check pin availability and configure complementary output pin */
        if (channelConfig->output->complementaryPin != NULL_PTR)
        {
            pin.outputPin = channelConfig->output->complementaryPin;
            IfxEgtm_Pwm_initPin(pwm, &pin);
        }
    }

    /* 7. Connect output to MSC */
    if (channelConfig->mscOut != NULL_PTR)
    {
        (void)IfxEgtm_ConnectToMsc(pwm->cluster, (subModule == IfxEgtm_Pwm_SubModule_tom) ? IfxEgtm_TrigSource_tom : IfxEgtm_TrigSource_atom, (IfxEgtm_TrigChannel)channelIndex, channelConfig->mscOut);
    }

    /* 8. Initialize Interrupts */
    IfxEgtm_Pwm_initInterrupts(pwm, channelConfig->interrupt, channel);
}


IFX_STATIC void IfxEgtm_Pwm_initInterrupts(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_InterruptConfig *interrupt, IfxEgtm_Pwm_Channel *channel)
{
    volatile Ifx_SRC_SRCR   *src;
    IfxEgtm_Pwm_SubModule_Ch channelIndex = channel->timerCh;

    if (interrupt != NULL_PTR)
    {
        boolean periodEventEnabled = (interrupt->periodEvent != NULL_PTR) ? TRUE : FALSE;
        boolean dutyEventEnabled   = (interrupt->dutyEvent != NULL_PTR) ? TRUE : FALSE;

        /* Copy callback function pointers */
        channel->periodEvent = interrupt->periodEvent;
        channel->dutyEvent   = interrupt->dutyEvent;

        /* Set notification and get src pointer */
        if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
        {
            IfxEgtm_Atom_Ch_setNotification(&pwm->clusterSFR->ATOM, (IfxEgtm_Atom_Ch)channelIndex, interrupt->mode, periodEventEnabled, dutyEventEnabled);
            src = IfxEgtm_Atom_Ch_getSrcPointer(NULL_PTR, pwm->cluster, (IfxEgtm_Atom_Ch)channelIndex);
        }
        else
        {
            IfxEgtm_Tom_Ch_setNotification(&pwm->clusterSFR->TOM, (IfxEgtm_Tom_Ch)channelIndex, interrupt->mode, periodEventEnabled, dutyEventEnabled);
            src = IfxEgtm_Tom_Ch_getSrcPointer(NULL_PTR, pwm->cluster, (IfxEgtm_Tom_Ch)channelIndex);
        }

        /* Initialize src node */
        IfxSrc_init(src, interrupt->isrProvider, interrupt->priority, interrupt->vmId);

        /* Enable Src node */
        IfxSrc_enable(src);
    }
    else
    {
        /* Set notification and get src pointer */
        if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
        {
            pwm->clusterSFR->ATOM.CH[channelIndex].IRQ_EN.U = 0x0u;
        }
        else
        {
            pwm->clusterSFR->TOM.CH[channelIndex].IRQ_EN.U = 0x0u;
        }
    }
}


IFX_STATIC void IfxEgtm_Pwm_updateGlobalControlUnitData(IfxEgtm_Pwm *pwm)
{
    IfxEgtm_Pwm_SubModule_Ch firstChannel = pwm->channels[0].timerCh;
    IfxEgtm_Pwm_SubModule_Ch lastChannel  = pwm->channels[pwm->numChannels - 1u].timerCh;
    uint32                   mask         = 0;
    uint8                    idx          = 0;
    uint8                    index        = 0;
    /* Initialize */
    pwm->globalControl.upenMask0     = 0u;
    pwm->globalControl.upenMask1     = 0u;
    pwm->globalControl.reg0          = NULL_PTR;
    pwm->globalControl.reg1          = NULL_PTR;
    pwm->globalControl.endisCtrlReg0 = NULL_PTR;
    pwm->globalControl.endisCtrlReg1 = NULL_PTR;

    /* Calculate Update enable mask for channels being used. Channels may not be consecutive. */
    for (idx = 0; idx < pwm->numChannels; idx++)
    {
        index = pwm->channels[idx].timerCh;

        if (pwm->channels[idx].timerCh > 7)
        {
            index = pwm->channels[idx].timerCh - 8;
        }

        mask |= 3u << (index << 1u);
    }

    if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        /* Get mask for channel range from first to last */
        pwm->globalControl.upenMask0     = (mask & 0xFFFFu) << (uint32)IFX_EGTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF;
        pwm->globalControl.reg0          = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->ATOM.AGC.GLB_CTRL.U;
        pwm->globalControl.endisCtrlReg0 = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->ATOM.AGC.ENDIS_CTRL.U;
    }
    else
    {
        /* Enable both control units If channels are in different cluster */
        if (IFXEGTM_PWM_GET_TGC_INDEX(firstChannel) != IFXEGTM_PWM_GET_TGC_INDEX(lastChannel))
        {
            /* Get masks and values for both control units */
            pwm->globalControl.upenMask0     = (mask & 0xFFFFu) << (uint32)IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF;
            pwm->globalControl.upenMask1     = mask & 0xFFFF0000u;
            pwm->globalControl.reg0          = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->TOM.TGC[0].GLB_CTRL.U;
            pwm->globalControl.reg1          = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->TOM.TGC[1].GLB_CTRL.U;
            pwm->globalControl.endisCtrlReg0 = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->TOM.TGC[0].ENDIS_CTRL.U;
            pwm->globalControl.endisCtrlReg1 = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->TOM.TGC[1].ENDIS_CTRL.U;
        }
        else
        {
            pwm->globalControl.upenMask0     = (mask & 0xFFFFu) << (uint32)IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF;
            pwm->globalControl.reg0          = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(lastChannel)].GLB_CTRL.U;
            pwm->globalControl.endisCtrlReg0 = (volatile Ifx_UReg_32Bit *)&pwm->clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(lastChannel)].ENDIS_CTRL.U;
        }
    }
}


void IfxEgtm_Pwm_startSyncedChannels(IfxEgtm_Pwm *pwm)
{
    Ifx_EGTM_CLS_TBU *tbuSFR          = &pwm->egtmSFR->CLS[0].TBU;
    Ifx_EGTM         *egtmSFR         = pwm->egtmSFR;
    boolean           cmuClockEnabled = FALSE;
    uint8             tbuClock;

    /* 1. Check if init is done */
    if ((pwm->state == IfxEgtm_Pwm_State_init) ||
        (pwm->state == IfxEgtm_Pwm_State_stopped))
    {
        /* 2. Use TBU to start different TGCs */
        if (pwm->globalControl.reg1 != NULL_PTR)
        {
            /* Enable channels on trigger */
            *pwm->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_ENABLE_VALUE & pwm->globalControl.upenMask0)) >> 16u;
            *pwm->globalControl.endisCtrlReg1 = (~(~IFXEGTM_PWM_UPEN_ENABLE_VALUE & pwm->globalControl.upenMask1)) >> 16u;

            /* 2.1. Find which CMU_CLK is enabled and use the first one for TBU */
            for (tbuClock = (uint8)IfxEgtm_Cmu_Clk_0; tbuClock < (uint8)IfxEgtm_Cmu_Clk_7; tbuClock++)
            {
                if (IfxEgtm_Cmu_isClkClockEnabled(egtmSFR, (IfxEgtm_Cmu_Clk)tbuClock) == TRUE)
                {
                    cmuClockEnabled = TRUE;
                    break;
                }
            }

            /* 2.2 If no CMU_CLK is enabled then enable CMU_CLK0 */
            if (cmuClockEnabled == FALSE)
            {
                egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_enable;
                tbuClock                             = (uint8)IfxEgtm_Cmu_Clk_0;
            }

            /* 2.3 Disable TBU_TS0 for configuration */
            tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

            /* 2.4 Configure AGC/TGC0/1 of pwm1 */
            IfxEgtm_Pwm_configureTimeBaseTrigger(pwm->clusterSFR, pwm->subModule, pwm->channels[0].timerCh, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

            IfxEgtm_Pwm_configureTimeBaseTrigger(pwm->clusterSFR, pwm->subModule, IfxEgtm_Pwm_SubModule_Ch_8, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

            /* 2.5 TBU Set up */
            /* Configure clock source and base value */
            tbuSFR->CH0_CTRL.B.LOW_RES    = 0x0u;
            tbuSFR->CH0_CTRL.B.CH_CLK_SRC = (uint8)tbuClock;
            tbuSFR->CH0_BASE.U            = 0x0u;

            /* Start TBU_TS0 counter */
            tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_enable;

            /* 2.6 Wait for trigger generation */
            while (tbuSFR->CH0_BASE.U < IFXEGTM_PWM_TBU_TIMEOUT_TICKS)
            {}

            /* 2.7 Disable TBU_TS0 */
            tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

            /* 2.8 Disable CM_CLK0 if enabled earlier */
            if (cmuClockEnabled == FALSE)
            {
                egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_disable;
            }
        }
        /* 2. Give trigger to start counter of channels */
        else
        {
            /* Enable channels on trigger */
            *pwm->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_ENABLE_VALUE & pwm->globalControl.upenMask0)) >> 16u;
            *pwm->globalControl.reg0          = 0x1u;
        }

        /* 3. Update handle */
        pwm->state = IfxEgtm_Pwm_State_run;
    }
}


void IfxEgtm_Pwm_stopSyncedChannels(IfxEgtm_Pwm *pwm)
{
    Ifx_EGTM_CLS_TBU *tbuSFR          = &pwm->egtmSFR->CLS[0].TBU;
    Ifx_EGTM         *egtmSFR         = pwm->egtmSFR;
    boolean           cmuClockEnabled = FALSE;
    uint8             tbuClock;

    /* 1. Check if PWM is running */
    if (pwm->state == IfxEgtm_Pwm_State_run)
    {
        /* 2. Use TBU to stop different TGCs */
        if (pwm->globalControl.reg1 != NULL_PTR)
        {
            /* Disable channel on trigger */
            *pwm->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_DISABLE_VALUE & pwm->globalControl.upenMask0)) >> 16u;
            *pwm->globalControl.endisCtrlReg1 = (~(~IFXEGTM_PWM_UPEN_DISABLE_VALUE & pwm->globalControl.upenMask1)) >> 16u;

            /* 2.1. Find which CMU_CLK is enabled and use the first one for TBU */
            for (tbuClock = (uint8)IfxEgtm_Cmu_Clk_0; tbuClock < (uint8)IfxEgtm_Cmu_Clk_7; tbuClock++)
            {
                if (IfxEgtm_Cmu_isClkClockEnabled(egtmSFR, (IfxEgtm_Cmu_Clk)tbuClock) == TRUE)
                {
                    cmuClockEnabled = TRUE;
                    break;
                }
            }

            /* 2.2 If no CMU_CLK is enabled then enable CMU_CLK0 */
            if (cmuClockEnabled == FALSE)
            {
                egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_enable;
                tbuClock                             = (uint8)IfxEgtm_Cmu_Clk_0;
            }

            /* 2.3 Disable TBU_TS0 for configuration */
            tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

            /* 2.4 Configure AGC/TGC0/1 of pwm1 */
            IfxEgtm_Pwm_configureTimeBaseTrigger(pwm->clusterSFR, pwm->subModule, pwm->channels[0].timerCh, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

            IfxEgtm_Pwm_configureTimeBaseTrigger(pwm->clusterSFR, pwm->subModule, IfxEgtm_Pwm_SubModule_Ch_8, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

            /* 2.5 TBU Set up */
            /* Configure clock source and base value */
            tbuSFR->CH0_CTRL.B.LOW_RES    = 0x0u;
            tbuSFR->CH0_CTRL.B.CH_CLK_SRC = (uint8)tbuClock;
            tbuSFR->CH0_BASE.U            = 0x0u;

            /* Start TBU_TS0 counter */
            tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_enable;

            /* 2.6 Wait for trigger generation */
            while (tbuSFR->CH0_BASE.U < IFXEGTM_PWM_TBU_TIMEOUT_TICKS)
            {}

            /* 2.7 Disable TBU_TS0 */
            tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

            /* 2.8 Disable CM_CLK0 if enabled earlier */
            if (cmuClockEnabled == FALSE)
            {
                egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_disable;
            }
        }
        /* 2. Give trigger to start counter of channels */
        else
        {
            /* Disable channel on trigger */
            *pwm->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_DISABLE_VALUE & pwm->globalControl.upenMask0)) >> 16u;
            *pwm->globalControl.reg0          = 0x1u;
        }

        /* 3. Update handle */
        pwm->state = IfxEgtm_Pwm_State_stopped;
    }
}


void IfxEgtm_Pwm_startSyncedGroups(IfxEgtm_Pwm *pwm1, IfxEgtm_Pwm *pwm2)
{
    Ifx_EGTM_CLS_TBU *tbuSFR          = &pwm1->egtmSFR->CLS[0].TBU;
    Ifx_EGTM         *egtmSFR         = pwm1->egtmSFR;
    boolean           cmuClockEnabled = FALSE;
    uint8             tbuClock;

    /* 1. Find which CMU_CLK is enabled and use the first one for TBU */
    for (tbuClock = (uint8)IfxEgtm_Cmu_Clk_0; tbuClock < (uint8)IfxEgtm_Cmu_Clk_7; tbuClock++)
    {
        if (IfxEgtm_Cmu_isClkClockEnabled(egtmSFR, (IfxEgtm_Cmu_Clk)tbuClock) == TRUE)
        {
            cmuClockEnabled = TRUE;
            break;
        }
    }

    /* 2. If no CMU_CLK is enabled then enable CMU_CLK0 */
    if (cmuClockEnabled == FALSE)
    {
        egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_enable;
        tbuClock                             = (uint8)IfxEgtm_Cmu_Clk_0;
    }

    /* 3. Disable TBU_TS0 for configuration */
    tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

    /* 4. Configure AGC/TGC0/1 of pwm1 */
    *pwm1->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_ENABLE_VALUE & pwm1->globalControl.upenMask0)) >> 16u;
    IfxEgtm_Pwm_configureTimeBaseTrigger(pwm1->clusterSFR, pwm1->subModule, pwm1->channels[0].timerCh, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

    if (pwm1->globalControl.reg1 != NULL_PTR)
    {
        *pwm1->globalControl.endisCtrlReg1 = (~(~IFXEGTM_PWM_UPEN_ENABLE_VALUE & pwm1->globalControl.upenMask1)) >> 16u;
        IfxEgtm_Pwm_configureTimeBaseTrigger(pwm1->clusterSFR, pwm1->subModule, IfxEgtm_Pwm_SubModule_Ch_8, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);
    }

    /* 5. Configure AGC/TGC0/1 of pwm1 */
    *pwm2->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_ENABLE_VALUE & pwm2->globalControl.upenMask0)) >> 16u;
    IfxEgtm_Pwm_configureTimeBaseTrigger(pwm2->clusterSFR, pwm2->subModule, pwm2->channels[0].timerCh, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

    if (pwm2->globalControl.reg1 != NULL_PTR)
    {
        *pwm2->globalControl.endisCtrlReg1 = (~(~IFXEGTM_PWM_UPEN_ENABLE_VALUE & pwm2->globalControl.upenMask1)) >> 16u;
        IfxEgtm_Pwm_configureTimeBaseTrigger(pwm2->clusterSFR, pwm2->subModule, IfxEgtm_Pwm_SubModule_Ch_8, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);
    }

    /* 6. TBU Set up */
    /* 6.1 Configure clock source and base value */
    tbuSFR->CH0_CTRL.B.LOW_RES    = 0x0u;
    tbuSFR->CH0_CTRL.B.CH_CLK_SRC = (uint8)tbuClock;
    tbuSFR->CH0_BASE.U            = 0x0u;

    /* 6.2 Start TBU_TS0 counter */
    tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_enable;

    /* 7. Wait for trigger generation */
    while (tbuSFR->CH0_BASE.U < IFXEGTM_PWM_TBU_TIMEOUT_TICKS)
    {}

    /* 8. Disable TBU_TS0 */
    tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

    /* 9. Disable CM_CLK0 if enabled earlier */
    if (cmuClockEnabled == FALSE)
    {
        egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_disable;
    }

    pwm1->state = IfxEgtm_Pwm_State_run;
    pwm2->state = IfxEgtm_Pwm_State_run;
}


void IfxEgtm_Pwm_stopSyncedGroups(IfxEgtm_Pwm *pwm1, IfxEgtm_Pwm *pwm2)
{
    Ifx_EGTM_CLS_TBU *tbuSFR          = &pwm1->egtmSFR->CLS[0].TBU;
    Ifx_EGTM         *egtmSFR         = pwm1->egtmSFR;
    boolean           cmuClockEnabled = FALSE;
    uint8             tbuClock;

    /* 1. Find which CMU_CLK is enabled and use the first one for TBU */
    for (tbuClock = (uint8)IfxEgtm_Cmu_Clk_0; tbuClock < (uint8)IfxEgtm_Cmu_Clk_7; tbuClock++)
    {
        if (IfxEgtm_Cmu_isClkClockEnabled(egtmSFR, (IfxEgtm_Cmu_Clk)tbuClock) == TRUE)
        {
            cmuClockEnabled = TRUE;
            break;
        }
    }

    /* 2. If no CMU_CLK is enabled then enable CMU_CLK0 */
    if (cmuClockEnabled == FALSE)
    {
        egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_enable;
        tbuClock                             = (uint8)IfxEgtm_Cmu_Clk_0;
    }

    /* 3. Disable TBU_TS0 for configuration */
    tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

    /* 4. Configure AGC/TGC0/1 of pwm1 */
    *pwm1->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_DISABLE_VALUE & pwm1->globalControl.upenMask0)) >> 16u;
    IfxEgtm_Pwm_configureTimeBaseTrigger(pwm1->clusterSFR, pwm1->subModule, pwm1->channels[0].timerCh, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

    if (pwm1->globalControl.reg1 != NULL_PTR)
    {
        *pwm1->globalControl.endisCtrlReg1 = (~(~IFXEGTM_PWM_UPEN_DISABLE_VALUE & pwm1->globalControl.upenMask1)) >> 16u;
        IfxEgtm_Pwm_configureTimeBaseTrigger(pwm1->clusterSFR, pwm1->subModule, IfxEgtm_Pwm_SubModule_Ch_8, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);
    }

    /* 5. Configure AGC/TGC0/1 of pwm1 */
    *pwm2->globalControl.endisCtrlReg0 = (~(~IFXEGTM_PWM_UPEN_DISABLE_VALUE & pwm2->globalControl.upenMask0)) >> 16u;
    IfxEgtm_Pwm_configureTimeBaseTrigger(pwm2->clusterSFR, pwm2->subModule, pwm2->channels[0].timerCh, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);

    if (pwm2->globalControl.reg1 != NULL_PTR)
    {
        *pwm2->globalControl.endisCtrlReg1 = (~(~IFXEGTM_PWM_UPEN_DISABLE_VALUE & pwm2->globalControl.upenMask1)) >> 16u;
        IfxEgtm_Pwm_configureTimeBaseTrigger(pwm2->clusterSFR, pwm2->subModule, IfxEgtm_Pwm_SubModule_Ch_8, IFXEGTM_PWM_TBU_TIMEOUT_TICKS);
    }

    /* 6. TBU Set up */
    /* 6.1 Configure clock source and base value */
    tbuSFR->CH0_CTRL.B.LOW_RES    = 0x0u;
    tbuSFR->CH0_CTRL.B.CH_CLK_SRC = (uint8)tbuClock;
    tbuSFR->CH0_BASE.U            = 0x0u;

    /* 6.2 Start TBU_TS0 counter */
    tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_enable;

    /* 7. Wait for trigger generation */
    while (tbuSFR->CH0_BASE.U < IFXEGTM_PWM_TBU_TIMEOUT_TICKS)
    {}

    /* 8. Disable TBU_TS0 */
    tbuSFR->CHEN.B.ENDIS_CH0 = (uint8)IfxEgtm_FeatureControl_disable;

    /* 9. Disable CM_CLK0 if enabled earlier */
    if (cmuClockEnabled == FALSE)
    {
        egtmSFR->CLS[0].CMU.CLK_EN.B.EN_CLK0 = (uint8)IfxEgtm_FeatureControl_disable;
    }

    pwm1->state = IfxEgtm_Pwm_State_stopped;
    pwm2->state = IfxEgtm_Pwm_State_stopped;
}


void IfxEgtm_Pwm_updateFrequency(IfxEgtm_Pwm *pwm, float32 requestFrequency)
{
    uint8                idx            = 0u;
    uint32               newDutyTicks   = 0u;
    uint32               newPhaseTicks  = 0u;
    float32              frequencyRatio = pwm->frequency / requestFrequency;
    IfxEgtm_Pwm_Channel *channel;

    /* 1. Disable UPEN */
    IfxEgtm_Pwm_disableChannelsSyncUpdate(pwm);

    /* 2. Calculate and set base channel PWM frequency */
    IfxEgtm_Pwm_updateBaseChannelFrequency(pwm, requestFrequency);

    /* 3. Calculate and set base channel PWM duty */
    channel                 = &(pwm->channels[0]);
    newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));
    channel->dutyTicks      = newDutyTicks;
    *channel->registers.SR1 = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;

    /* 4. If edge aligned, calculate and set phase and duty of sync channels */
    if (pwm->alignment == IfxEgtm_Pwm_Alignment_edge)
    {
        for (idx = 1; idx < pwm->numChannels; idx++)
        {
            channel                 = &(pwm->channels[idx]);

            newPhaseTicks           = (uint32)((float32)(((float32)channel->phaseTicks * frequencyRatio) + (float32)0.5f));
            newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));

            channel->phaseTicks     = newPhaseTicks;
            channel->dutyTicks      = newDutyTicks;

            *channel->registers.SR0 = newPhaseTicks;
            *channel->registers.SR1 = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;
        }
    }
    /* 5. If not edge aligned, only calculate and set duty of sync channels */
    else
    {
        for (idx = 1; idx < pwm->numChannels; idx++)
        {
            channel                 = &(pwm->channels[idx]);
            newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));
            channel->dutyTicks      = newDutyTicks;
            *channel->registers.SR1 = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;
        }
    }

    /* 6. Enable UPEN */
    IfxEgtm_Pwm_enableChannelsSyncUpdate(pwm);
}


void IfxEgtm_Pwm_updateSyncedGroupsFrequency(IfxEgtm_Pwm *pwm1, IfxEgtm_Pwm *pwm2, float32 requestFrequency)
{
    IfxEgtm_Pwm         *pwmArray[2] = {pwm1, pwm2};
    IfxEgtm_Pwm         *pwm;
    uint8                pwmIndex, idx;
    uint32               newDutyTicks;
    uint32               newPhaseTicks;
    float32              frequencyRatio;
    IfxEgtm_Pwm_Channel *channel;

    /* 1. Disable UPEN */
    IfxEgtm_Pwm_disableChannelsSyncUpdate(pwm1);
    IfxEgtm_Pwm_disableChannelsSyncUpdate(pwm2);

    /* 2. Update frequency of two groups */
    for (pwmIndex = 0; pwmIndex < 2; pwmIndex++)
    {
        pwm            = pwmArray[pwmIndex];
        frequencyRatio = pwm->frequency / requestFrequency;

        /* Calculate and set base channel PWM frequency */
        IfxEgtm_Pwm_updateBaseChannelFrequency(pwm, requestFrequency);

        /* Calculate and set base channel PWM duty */
        channel                 = &(pwm->channels[0]);
        newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));
        channel->dutyTicks      = newDutyTicks;
        *channel->registers.SR1 = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;

        /* If edge aligned, calculate and set phase and duty of sync channels */
        if (pwm->alignment == IfxEgtm_Pwm_Alignment_edge)
        {
            for (idx = 1; idx < pwm->numChannels; idx++)
            {
                channel                 = &(pwm->channels[idx]);

                newPhaseTicks           = (uint32)((float32)(((float32)channel->phaseTicks * frequencyRatio) + (float32)0.5f));
                newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));

                channel->phaseTicks     = newPhaseTicks;
                channel->dutyTicks      = newDutyTicks;

                *channel->registers.SR0 = newPhaseTicks;
                *channel->registers.SR1 = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;
            }
        }
        /* If not edge aligned, only calculate and set duty of sync channels */
        else
        {
            for (idx = 1; idx < pwm->numChannels; idx++)
            {
                channel                 = &(pwm->channels[idx]);
                newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));
                channel->dutyTicks      = newDutyTicks;
                *channel->registers.SR1 = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;
            }
        }
    }

    /* 5. Enable UPEN */
    /* Update first control unit to ensure counters don't get out of sync */
    IfxEgtm_Pwm_GlobalControl *globalctrl1 = &pwm1->globalControl;
    IfxEgtm_Pwm_GlobalControl *globalctrl2 = &pwm2->globalControl;
    *globalctrl1->reg0 = pwm1->globalControl.upenMask0 & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;
    *globalctrl2->reg0 = pwm2->globalControl.upenMask0 & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;

    /* If CM0 of 1st channel ggot updated before 2nd channel, immediately update the second base channel's CM0 */
    if (((*pwm1->channels[0].registers.CM0) == pwm1->periodTicks) &&    /* CM0 has been updated from SR0 (frequency update already happened) */
        ((*pwm2->channels[0].registers.CM0) != pwm2->periodTicks))      /* CM0 not updated from SR0 (frequency update not happened yet) */
    {
        *pwm2->channels[0].registers.CM0 = pwm2->periodTicks;           /* Immediately update CM0 to prevent de-synchronization */
    }

    /* Update other TGC if present */
    if (pwm1->globalControl.reg1 != NULL_PTR)
    {
        *globalctrl1->reg1 = pwm1->globalControl.upenMask1 & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;
    }

    if (pwm2->globalControl.reg1 != NULL_PTR)
    {
        *globalctrl2->reg1 = pwm2->globalControl.upenMask1 & (uint32)IFXEGTM_PWM_UPEN_ENABLE_VALUE;
    }
}


void IfxEgtm_Pwm_updateFrequencyImmediate(IfxEgtm_Pwm *pwm, float32 requestFrequency)
{
    uint8                idx            = 0u;
    uint32               newDutyTicks   = 0u;
    uint32               newPhaseTicks  = 0u;
    float32              frequencyRatio = pwm->frequency / requestFrequency;
    IfxEgtm_Pwm_Channel *channel;

    /* 1. Calculate and set base channel PWM frequency */
    IfxEgtm_Pwm_updateBaseChannelFrequencyImmediate(pwm, requestFrequency);

    /* 2. Calculate and set base channel PWM duty */
    channel                 = &(pwm->channels[0]);
    newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));
    channel->dutyTicks      = newDutyTicks;
    newDutyTicks            = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;
    *channel->registers.SR1 = newDutyTicks;
    *channel->registers.CM1 = newDutyTicks;

    /* 3. If edge aligned, calculate and set phase and duty of sync channels */
    if (pwm->alignment == IfxEgtm_Pwm_Alignment_edge)
    {
        for (idx = 1; idx < pwm->numChannels; idx++)
        {
            channel                 = &(pwm->channels[idx]);

            newPhaseTicks           = (uint32)((float32)(((float32)channel->phaseTicks * frequencyRatio) + (float32)0.5f));
            newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));

            channel->phaseTicks     = newPhaseTicks;
            channel->dutyTicks      = newDutyTicks;

            newDutyTicks            = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;

            *channel->registers.SR0 = newPhaseTicks;
            *channel->registers.SR1 = newDutyTicks;
            *channel->registers.CM0 = newPhaseTicks;
            *channel->registers.CM1 = newDutyTicks;
        }
    }
    /* 4. If not edge aligned, only calculate and set duty of sync channels */
    else
    {
        for (idx = 1; idx < pwm->numChannels; idx++)
        {
            channel                 = &(pwm->channels[idx]);
            newDutyTicks            = (uint32)((float32)(((float32)channel->dutyTicks * frequencyRatio) + (float32)0.5f));
            channel->dutyTicks      = newDutyTicks;
            newDutyTicks            = (newDutyTicks <= pwm->periodTicks) ? newDutyTicks : newDutyTicks - pwm->periodTicks;
            *channel->registers.SR1 = newDutyTicks;
            *channel->registers.CM1 = newDutyTicks;
        }
    }
}


void IfxEgtm_Pwm_updateChannelPulse(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase, float32 requestDuty)
{
    /* 1. Disable update from shadow register */
    IfxEgtm_Pwm_disableChannelSyncUpdate(pwm->channels[configIndex].registers.GLB_CTRL, pwm->channels[configIndex].upenMask);

    /* 2. Update phase if not base channel */
    if (configIndex != IfxEgtm_Pwm_SyncChannelIndex_0)
    {
        IfxEgtm_Pwm_updateChannelPhase(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestPhase);
    }

    /* 3. Update duty */
    IfxEgtm_Pwm_updateChannelDuty(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestDuty);

    /* 4. Enable update from shadow register */
    IfxEgtm_Pwm_enableChannelSyncUpdate(pwm->channels[configIndex].registers.GLB_CTRL, pwm->channels[configIndex].upenMask);
}


void IfxEgtm_Pwm_updateChannelPulseImmediate(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_SyncChannelIndex configIndex, float32 requestPhase, float32 requestDuty)
{
    /* 1. Update phase if not base channel */
    if (configIndex != IfxEgtm_Pwm_SyncChannelIndex_0)
    {
        IfxEgtm_Pwm_updateChannelPhaseImmediate(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestPhase);
    }

    /* 2. Update duty */
    IfxEgtm_Pwm_updateChannelDutyImmediate(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestDuty);
}


void IfxEgtm_Pwm_updateChannelsPhase(IfxEgtm_Pwm *pwm, float32 *requestPhase)
{
    uint8 configIndex = 0;

    /* 1. Disable update from shadow register */
    IfxEgtm_Pwm_disableChannelsSyncUpdate(pwm);

    /* 2. Loop over all channels and update duty */
    for (configIndex = 1; configIndex < pwm->numChannels; configIndex++)
    {
        IfxEgtm_Pwm_updateChannelPhase(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestPhase[configIndex]);
    }

    /* 3. Enable update from shadow register */
    IfxEgtm_Pwm_enableChannelsSyncUpdate(pwm);
}


void IfxEgtm_Pwm_updateChannelsDuty(IfxEgtm_Pwm *pwm, float32 *requestDuty)
{
    uint8 configIndex = 0;

    /* 1. Disable update from shadow register */
    IfxEgtm_Pwm_disableChannelsSyncUpdate(pwm);

    /* 2. Loop over all channels and update duty */
    for (configIndex = 0; configIndex < pwm->numChannels; configIndex++)
    {
        IfxEgtm_Pwm_updateChannelDuty(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestDuty[configIndex]);
    }

    /* 3. Enable update from shadow register */
    IfxEgtm_Pwm_enableChannelsSyncUpdate(pwm);
}


void IfxEgtm_Pwm_updateChannelsPulse(IfxEgtm_Pwm *pwm, float32 *requestPhase, float32 *requestDuty)
{
    uint8 configIndex = 0;

    /* 1. Disable update from shadow register */
    IfxEgtm_Pwm_disableChannelsSyncUpdate(pwm);

    /* 2. Update duty for base channel */
    IfxEgtm_Pwm_updateChannelDuty(pwm, IfxEgtm_Pwm_SyncChannelIndex_0, requestDuty[0]);

    /* 3. Loop over sync channels and update phase & duty */
    for (configIndex = 1; configIndex < pwm->numChannels; configIndex++)
    {
        IfxEgtm_Pwm_updateChannelPhase(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestPhase[configIndex]);

        IfxEgtm_Pwm_updateChannelDuty(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestDuty[configIndex]);
    }

    /* 4. Enable update from shadow register */
    IfxEgtm_Pwm_enableChannelsSyncUpdate(pwm);
}


void IfxEgtm_Pwm_updateChannelsDeadTime(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_DeadTime *requestDeadTime)
{
    uint8 configIndex = 0;

    /* Loop over all channels and update dead time */
    for (configIndex = 0; configIndex < pwm->numChannels; configIndex++)
    {
        IfxEgtm_Pwm_updateChannelDeadTime(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestDeadTime[configIndex]);
    }
}


void IfxEgtm_Pwm_updateChannelsPhaseImmediate(IfxEgtm_Pwm *pwm, float32 *requestPhase)
{
    uint8 configIndex = 0;

    /* Loop over all channels and update duty */
    for (configIndex = 1; configIndex < pwm->numChannels; configIndex++)
    {
        IfxEgtm_Pwm_updateChannelPhaseImmediate(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestPhase[configIndex]);
    }
}


void IfxEgtm_Pwm_updateChannelsDutyImmediate(IfxEgtm_Pwm *pwm, float32 *requestDuty)
{
    uint8 configIndex = 0;

    /* Loop over all channels and update duty */
    for (configIndex = 0; configIndex < pwm->numChannels; configIndex++)
    {
        IfxEgtm_Pwm_updateChannelDutyImmediate(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestDuty[configIndex]);
    }
}


void IfxEgtm_Pwm_updateChannelsPulseImmediate(IfxEgtm_Pwm *pwm, float32 *requestPhase, float32 *requestDuty)
{
    uint8 configIndex = 0;

    /* 1. Update duty for base channel */
    IfxEgtm_Pwm_updateChannelDutyImmediate(pwm, IfxEgtm_Pwm_SyncChannelIndex_0, requestDuty[0]);

    /* 2. Loop over sync channels and update phase & duty */
    for (configIndex = 1; configIndex < pwm->numChannels; configIndex++)
    {
        IfxEgtm_Pwm_updateChannelPhaseImmediate(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestPhase[configIndex]);

        IfxEgtm_Pwm_updateChannelDutyImmediate(pwm, (IfxEgtm_Pwm_SyncChannelIndex)configIndex, requestDuty[configIndex]);
    }
}


void IfxEgtm_Pwm_interruptHandler(IfxEgtm_Pwm_Channel *channel, void *data)
{
    /* Note: IRQ_NOTIFY is raised even for disabled IRQ_EN.CCUxTC_IRQ_EN
     * Therefore, check each bit individually
     */

    /* CCU0 interrupt handler */
    if ((*channel->registers.IRQ_NOTIFY & 0x1u) == 1u)
    {
        /* Call callback function */
        if (channel->periodEvent != NULL_PTR)
        {
            (channel->periodEvent)(data);
        }

        /* Clear only period interrupt */
        *channel->registers.IRQ_NOTIFY = 0x1u;
    }

    /* CCU1 interrupt handler */
    if ((*channel->registers.IRQ_NOTIFY & 0x2u) == 2u)
    {
        /* Call callback function */
        if (channel->dutyEvent != NULL_PTR)
        {
            (channel->dutyEvent)(data);
        }

        /* Clear only duty interrupt */
        *channel->registers.IRQ_NOTIFY = 0x2u;
    }
}


IfxEgtm_Pwm_ChannelState IfxEgtm_Pwm_getChannelState(IfxEgtm_Pwm *pwm, IfxEgtm_Pwm_SubModule_Ch channel)
{
    IfxEgtm_Pwm_ChannelState state = IfxEgtm_Pwm_ChannelState_stopped;
    uint32                   value;

    /* Channel enabled if ENDIS and OUTEN is enabled for a certain channel */
    if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        value = IFXEGTM_ATOM_AGC_CHANNEL_MASK &
                ((pwm->clusterSFR->ATOM.AGC.ENDIS_STAT.U & pwm->clusterSFR->ATOM.AGC.OUTEN_STAT.U) >>
                 IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, 0));
    }
    else
    {
        Ifx_EGTM_CLS_TOM_TGC *tgc = &pwm->clusterSFR->TOM.TGC[IFXEGTM_PWM_GET_TGC_INDEX(channel)];
        value = IFXEGTM_TOM_TGC_CHANNEL_MASK &
                ((tgc->ENDIS_STAT.U & tgc->OUTEN_STAT.U) >>
                 IFXEGTM_TOM_TGC_CHANNEL_SHIFT(channel, 0));
    }

    /* 0b11 means output and channel is enabled */
    if (value == 0x3u)
    {
        state = IfxEgtm_Pwm_ChannelState_running;
    }

    return state;
}


void IfxEgtm_Pwm_stopChannelOutputs(IfxEgtm_Pwm *pwm)
{
    uint32 mask  = 0u;
    uint8  idx   = 0u;
    uint8  index = 0u;

/* Calculate output enable mask for channels being used. Channels may not be consecutive. */
    for (idx = 0; idx < pwm->numChannels; idx++)
    {
        index = pwm->channels[idx].timerCh;

        mask |= IFXEGTM_PWM_OUTPUT_STAT_DISABLE << (index << 1u);
    }

/* Channel enabled if ENDIS and OUTEN is enabled for a certain channel */
    if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        pwm->clusterSFR->ATOM.AGC.OUTEN_STAT.U = mask & 0xFFFF;
    }
    else
    {
        pwm->clusterSFR->TOM.TGC[0].OUTEN_STAT.U = mask & 0xFFFF;
        pwm->clusterSFR->TOM.TGC[1].OUTEN_STAT.U = (mask >> 16u) & 0xFFFF;
    }
}


void IfxEgtm_Pwm_startChannelOutputs(IfxEgtm_Pwm *pwm)
{
    uint32 mask  = 0u;
    uint8  idx   = 0u;
    uint8  index = 0u;

/* Calculate output enable mask for channels being used. Channels may not be consecutive. */
    for (idx = 0; idx < pwm->numChannels; idx++)
    {
        index = pwm->channels[idx].timerCh;

        mask |= IFXEGTM_PWM_OUTPUT_STAT_ENABLE << (index << 1u);
    }

/* Channel enabled if ENDIS and OUTEN is enabled for a certain channel */
    if (pwm->subModule == IfxEgtm_Pwm_SubModule_atom)
    {
        pwm->clusterSFR->ATOM.AGC.OUTEN_STAT.U = mask & 0xFFFF;
    }
    else
    {
        pwm->clusterSFR->TOM.TGC[0].OUTEN_STAT.U = mask & 0xFFFF;
        pwm->clusterSFR->TOM.TGC[1].OUTEN_STAT.U = (mask >> 16u) & 0xFFFF;
    }
}
