/**********************************************************************************************************************
 * \file TMADC.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxAdc_reg.h"
#include "Bsp.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define IFX_INTPRIO_TMADC_SR2 123
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
volatile unsigned int g_TMADC0_RES0;
volatile unsigned int g_TMADC0_RES1;
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define the Interrupt Service Routine */
IFX_INTERRUPT(resultISR, 0, IFX_INTPRIO_TMADC_SR2);
/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

void init_TMADC(void)
{
    /* After reset, TMADC is in DISABLE state */

    /* Enable the clock for ADC cluster, so that registers can be accessed */
    ADC_CLC.B.DISR = 0;

    while(ADC_CLC.B.DISS == 1);

    /* Enable the clock for TMADC0 and switch TMADC0 from DISABLE to CONFIG state */
    ADC_CLKEN_TMADC.B.TMADCEN = 1 << 0;

    while(ADC_TMADC0_MODSTAT.B.DIS == 1);

    /* Configure TMADC0 when it is in CONFIG state */

    /* Start-up calibration will be executed when TMADC0 enters RUN state */
    ADC_TMADC0_MODCFG.B.SUCAL = 1;

    /* TC4D Lite Kit has VDDM = 3.3V */
    /* WARNING: for Boards with VDDM = 5V, this bit MUST BE SET to 0  */
    ADC_SUPLLEV.B.TMADCSUP = 1;

    /* Enable TMADC0.Ch0 and Ch1 */
    ADC_TMADC0_CH0_CFG.B.EN = 1;
    ADC_TMADC0_CH1_CFG.B.EN = 1;

    /* Set TMADC0.Ch0 and Ch1 in single shot mode */
    ADC_TMADC0_CH0_CFG.B.ATREN = 0;
    ADC_TMADC0_CH1_CFG.B.ATREN = 0;

    /* Select Result Register 0 and 1 for TMADC0.Ch0 and Ch1 respectively */
    ADC_TMADC0_CH0_CFG.B.RSEL = 0;
    ADC_TMADC0_CH1_CFG.B.RSEL = 1;

    /* Switch on TMADC Ch0 and Ch1 timestamp feature */
    ADC_TMADC0_CH0_CFG.B.TSEN = 1;
    ADC_TMADC0_CH1_CFG.B.TSEN = 1;

    /* Select 50ns sampling time for TMADC0.Ch0 */
    /* Refer to parameter "tmstc" in datasheet for timing requirement */
    /* Note, with VDDM = 3.3V, fADCI = 40MHz, not 80MHz */
    /* With VDDM = 3.3V and in single mode, sampling time shall be at least 200ns */
    /* ST = 23 means (7+1)*25ns = 200ns */
    /* Conversion time for VDDM = 3.3V is 16 * 25ns = 400ns */
    ADC_TMADC0_CH0_STC.B.ST = 7;
    ADC_TMADC0_CH1_STC.B.ST = 7;

    /* Assign TMADC0.Ch0 and Ch1 to SAR core 1 of TMADC0 */
    ADC_TMADC0_CMATCFG.B.CHCSEL = (1 << 0) | (1 << 1);

    /* Enable result event interrupt for TMADC0 result register 0 and 1 using service request line 2 */
    ADC_TMADC0_SR2_CFG.U = 0x80003;

    /* Select CPU0 to process interrupt request */
    SRC_TMADC0SR2.B.TOS = 0;
    /* Configure TMADC0 SR2 interrupt priority  */
    SRC_TMADC0SR2.B.SRPN = IFX_INTPRIO_TMADC_SR2;
    /* Clear potential interrupt request */
    SRC_TMADC0SR2.B.CLRR = 1;
    /* Enable interrupt for TMADC0 result event through request line 2 */
    SRC_TMADC0SR2.B.SRE = 1;

    /* Switch TMADC0 from CONFIG to RUN state and do start-up calibration*/
    ADC_TMADC0_MODCFG.B.RUN = 1;

    /* Wait until TMADC0 analog components are settled and start-up calibration is done */
    /* Refer to parameters "tWUDIS" and "tCAL" in datasheet for actual values */
    /* In preliminary version of the datasheet, tWUDIS = 8Âµs and tCAL = 3ms, in total 3008 microsecond */
    waitTime(IfxStm_getTicksFromMicroseconds(3008));

    /* Check if TMADC0 is already in READY state */
    if(ADC_TMADC0_MODSTAT.B.RUN != 1)
    {
        /* Failure happened */
        __debug();
    }

    /* Check if TMADC0 is already powered on */
    if(ADC_TMADC0_MODSTAT.B.PONPH != 2)
    {
        /* Failure happened */
        __debug();
    }

    /* Check if TMADC0 start-up calibration was successfully done */
    if(ADC_TMADC0_MODSTAT.B.CALPH != 2)
    {
        /* Failure happened */
        __debug();
    }

    /* Clear result event flags of all channels of TCMADC0 */
    ADC_TMADC0_RESFCLR.U = 0x3FFFF;

    /* Start TMADC0 timestamp counter */
    /* Note, its resolution is fixed to 200ns */
    ADC_TMADC0_MODCFG.B.TSCRUN = 1;

    waitTime(IfxStm_getTicksFromMicroseconds(100));

    /* Start TMADC0.Ch0 conversion */
    /* It produces conversion results in single shot mode */
    ADC_TMADC0_SWTRCFG.B.SCHSEL = 1 << 0;

    /* Start TMADC0.Ch1 conversion after 20us */
    /* It produces conversion results in single shot mode */
    waitTime(IfxStm_getTicksFromMicroseconds(20));
    ADC_TMADC0_SWTRCFG.B.SCHSEL = 1 << 1;
}

void resultISR(void)
{
    if((ADC_TMADC0_RESF.U & 0x1) == 0x1)
    {
        g_TMADC0_RES0 = ADC_TMADC0_AW0_TS0.B.TIMESTAMP;
        /* Clear CH0 result event flag i.e. mark as read */
        ADC_TMADC0_RESFCLR.U = 0x1;
    }
    else if((ADC_TMADC0_RESF.U & 0x2) == 0x2)
    {
        g_TMADC0_RES1 = ADC_TMADC0_AW0_TS1.B.TIMESTAMP;
        /* Clear CH1 result event flag i.e. mark as read */
        ADC_TMADC0_RESFCLR.U = 0x2;
    }
}
