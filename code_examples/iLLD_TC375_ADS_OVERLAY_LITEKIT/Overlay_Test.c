/**********************************************************************************************************************
 * \file Overlay_Test.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Overlay_Test.h"
#include <string.h>

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define RESULT_OK                                       0
#define RESULT_ERR                                      0xFF

#define BUF_SIZE                                        32                                 /* Byte                   */
#define BUF_SIZE_MAX                                    2048                               /* Byte                   */


#define IfxCpu_OverlayMemorySelect_lmu                  (IfxCpu_OverlayMemorySelect) 0x08

#define ledOn(LED)                                      IfxPort_setPinLow(LED)
#define ledOff(LED)                                     IfxPort_setPinHigh(LED)
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Buffer consists of new contents of PFlash */
uint8 ExpecteBufferContent[BUF_SIZE_MAX];

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/* Create a Ram buffer to read the variable from the Flash Range */

/* Global Variables (used in Test 1, 3) */
/* CPU0 PFLASH  */
IFX_ALIGN(32) const uint8 TEST_1_BUF_FLASH[BUF_SIZE] __at(0xA0002000) =
{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
};
/* CPU DLMU */
IFX_ALIGN(32) uint8 TEST_1_BUF_LMU[BUF_SIZE] __at(0xB0004000) = {0};


/* Global Variables (used in Test 2, 3) */
/* CPU0 PFLASH  */
IFX_ALIGN(32) const uint8 TEST_2_BUF_FLASH[BUF_SIZE] __at(0xA0002020) =
{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
};
/* CPU DLMU */
IFX_ALIGN(32) uint8 TEST_2_BUF_LMU[BUF_SIZE] __at(0xB0004020) = {0};


/* Global Variables (used in Test 4) */
/* CPU0 PFLASH  */
IFX_ALIGN(32) const uint8 TEST_4_BUF_FLASH[BUF_SIZE] __at(0xA0002040) =
{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
};
/* CPU0 DSPR */
IFX_ALIGN(32) uint8 TEST_4_BUF_DSPR[BUF_SIZE] __at(0x70004020) = {0};


/* Global Variables (used in Test 7) */
/* CPU0 PFLASH  */
IFX_ALIGN(32) const uint8 TEST_7_BUF_FLASH[BUF_SIZE * 2] __at(0xA0002060) =
{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
};
/* CPU0 DSPR */
IFX_ALIGN(32) uint8 TEST_7_BUF_DSPR[BUF_SIZE * 2] __at(0x70004040) = {0};
IFX_ALIGN(32) uint8 TEST_7_BUF_LMU[BUF_SIZE] __at(0xB0004040) = {0};


/* Global Variables (used in Test 8) */
/* CPU0 LMU */
IFX_ALIGN(32) uint8 TEST_8_BUF_TARGET[BUF_SIZE] __at(0xB0004100) =
{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
};
/* CPU0 LMU */
IFX_ALIGN(32) uint8 TEST_8_BUF_REDIRECT[BUF_SIZE] __at(0x70004120) = {0};


/* Global Variables - (used in Test 9) */
/* CPU0 PFLASH  */
IFX_ALIGN(32) const uint8 TEST_9_BUF_FLASH[BUF_SIZE_MAX] __at(0xA00E0000) =
{
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
        16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
};
/* CPU0 DLMU */
IFX_ALIGN(32) uint8 TEST_9_BUF_LMU[BUF_SIZE_MAX] __at(0x7000E000) = {0};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/* To verify access the overlaid memory
 * Check the Overlay value stored in RAM (Redirect Memory) instead of Flash (Target Memory)
 */
static uint8 Test_MemoryValidation(uint8* target, uint8* redirect, uint32 size);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void Test_init(void)
{
    /* Initialization of the LED used in this example */
    IfxPort_setPinModeOutput(LED_ERROR, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LED_SUCCESS, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Switch OFF the LED (low-level active) */
    ledOff(LED_ERROR);
    ledOff(LED_SUCCESS);
}

/*
 * Different test scenarios has been provided in this code example.
 * To ensure that the redirection of memory accesses is accurately configured.
 *
 *                                                The reaction for each Test
 * Test_1                                                LED Success ON
 * Test_2                                                LED Success ON
 * Test_3                                                LED Success ON
 * Test_4                                                LED Success ON
 * Test_5                                                LED Success ON
 * Test_6                                                LED Success ON
 * Test_7                          Expect to Trap (Class:4  Tin:3 - DAE)
 * Test_8                      (NO Overlay Functionality)- LED ERROR ON
 * Test_9                                                LED Success ON
 */

/* Test 1
 * Implementing Overlay with Registers Configuration (without using iLLD)
 * For 1 Block (32 Byte address range) where the Target Memory is any PFLASH bank (non-cached)
 * The Redirection Memory shall be LMU.
 */
void Test_1(void)
{
    /* Configure the Overlay */
    uint16 overlayBlock = 0;
    uint16 safetyWdtPw  = IfxScuWdt_getSafetyWatchdogPassword();

    /* Disable Overlay */
    boolean interruptState = IfxCpu_disableInterrupts();

    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);


    MODULE_SCU.OVCCON.U = (1 << 0)  | /* CSEL0   */
                          (0 << 1)  | /* CSEL1   */
                          (0 << 2)  | /* CSEL2   */
                          (0 << 16) | /* OVSTRT  */
                          (1 << 17) | /* OVSTP   */
                          (1 << 18) | /* DCINVAL */
                          (0 << 24) | /* OVCONF  */
                          (0 << 25);  /* POVCONF */

    /* Overlay disabled on CPU0 */
    MODULE_SCU.OVCENABLE.B.OVEN0 = 0;

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);

    MODULE_CPU0.BLK[overlayBlock].RABR.U  = 0;
    MODULE_CPU0.BLK[overlayBlock].OTAR.U  = 0;
    MODULE_CPU0.BLK[overlayBlock].OMASK.U = 0;

    /* Re-enable interrupts (optional)*/
    IfxCpu_restoreInterrupts(interruptState);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, sizeof(TEST_1_BUF_LMU));

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, BUF_SIZE))
    {
        /* Disable interrupts
         * We disable interrupts to ensure atomic access to the overlay registers.
         * Disabling Interrupt is considered for Test 1, and Test 2,
         * it can be applied also for other Tests, it is not mandatory.
         */
        interruptState = IfxCpu_disableInterrupts();

        /* Enable the overlay Block in the Overlay Range Select Register (OSEL) */
        MODULE_CPU0.OSEL.U |= 1 << overlayBlock;

        /* Configure Overlay Block */
        /* Set up the Redirected Address Base Register (RABR)  */
        /* Configure RABR fields */
        MODULE_CPU0.BLK[overlayBlock].RABR.U  = (1 << 31) |                         /* Configure OVEN (Overlay Enabled) */
                                                (0x08 << 24) |                /* Configure OMEM (Overlay Memory Select) */
                                                (((uint32) &TEST_1_BUF_LMU[0]) & 0x003FFFE0);  /* Configure OBASE (Overlay Base Address) */

        /* Set up the Overlay Target Address Register (OTAR) */
        MODULE_CPU0.BLK[overlayBlock].OTAR.U  = (uint32) &TEST_1_BUF_FLASH[0];

        /* Set up the Overlay Mask Register (OMASK)*/
        MODULE_CPU0.BLK[overlayBlock].OMASK.U = 0xFFF << 5;

        /* Enable Overlay in SCU */
        /* Clear Safety ENDINIT protection for modification of the configuration registers */
        IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

        /* Overlay enabled on CPU0 */
        MODULE_SCU.OVCENABLE.B.OVEN0 = 1;

        /* Turn on Overlay memory and enable block   */
        MODULE_SCU.OVCCON.U = (1 << 0)  | /* CSEL0   */
                              (0 << 1)  | /* CSEL1   */
                              (0 << 2)  | /* CSEL2   */
                              (1 << 16) | /* OVSTRT  */
                              (0 << 17) | /* OVSTP   */
                              (1 << 18) | /* DCINVAL */
                              (0 << 24) | /* OVCONF  */
                              (0 << 25);  /* POVCONF */

        /* Restore back the write-protection for registers */
        IfxScuWdt_setSafetyEndinit(safetyWdtPw);

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Re-enable interrupts */
        IfxCpu_restoreInterrupts(interruptState);

        /* Disable interrupts
         * We disable interrupts to ensure atomic access to the overlay registers. */
        interruptState = IfxCpu_disableInterrupts();

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf = (uint8*) TEST_1_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 11);
            pBuf[i] =  ExpecteBufferContent[i];
        }

        /* Disable Overlay */
        interruptState = IfxCpu_disableInterrupts();

        /* Clear Safety ENDINIT protection for modification of the configuration registers */
        IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

        MODULE_SCU.OVCCON.U = (1 << 0)  | /* CSEL0   */
                              (0 << 1)  | /* CSEL1   */
                              (0 << 2)  | /* CSEL2   */
                              (0 << 16) | /* OVSTRT  */
                              (1 << 17) | /* OVSTP   */
                              (1 << 18) | /* DCINVAL */
                              (0 << 24) | /* OVCONF  */
                              (0 << 25);  /* POVCONF */

        /* Overlay disabled on CPU0 */
        MODULE_SCU.OVCENABLE.B.OVEN0 = 0;

        /* Restore back the write-protection for registers */
        IfxScuWdt_setSafetyEndinit(safetyWdtPw);

        MODULE_CPU0.BLK[overlayBlock].RABR.U  = 0;
        MODULE_CPU0.BLK[overlayBlock].OTAR.U  = 0;
        MODULE_CPU0.BLK[overlayBlock].OMASK.U = 0;

        /* Re-enable interrupts (optional)*/
        IfxCpu_restoreInterrupts(interruptState);

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_1_BUF_FLASH, (uint8*) TEST_1_BUF_LMU, sizeof(TEST_1_BUF_FLASH));
    }
    else
    {
        ledOn(LED_ERROR);
    }
}

/* Test 2
 * Implementing Overlay (using illD)
 * For 1 Block (32 Byte address range) where the Target Memory is any PFLASH bank
 * The Redirection Memory shall be LMU.
 */
void Test_2(void)
{
    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_2_BUF_LMU, TEST_2_BUF_FLASH, BUF_SIZE);

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_2_BUF_LMU, TEST_2_BUF_FLASH, BUF_SIZE))
    {
        /* Disable interrupts
         * We disable interrupts to ensure atomic access to the overlay registers.
         * Disabling Interrupt is considered for Test 1, and Test 2, it can be applied also for other Tests, it is not mandatory.
         */
        boolean interruptState = IfxCpu_disableInterrupts();

        /* Configure Overlay */
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_lmu, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_2_BUF_FLASH, (uint32) TEST_2_BUF_LMU);

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Re-enable interrupts */
        IfxCpu_restoreInterrupts(interruptState);

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf = (uint8*) TEST_2_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 12);
            pBuf[i] =  ExpecteBufferContent[i];
        }

        /* Disable interrupts
         * We disable interrupts to ensure atomic access to the overlay registers. */
        interruptState = IfxCpu_disableInterrupts();

        /* Disable Overlay */
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

        /* Re-enable interrupts */
        IfxCpu_restoreInterrupts(interruptState);

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_2_BUF_FLASH, (uint8*) TEST_2_BUF_LMU, BUF_SIZE);
    }
    else
    {
        ledOn(LED_ERROR);
    }
}

/* Test 3
 * Multiple Overlay Blocks, simultaneously enable/disable
 * For 2 Block (32 Byte address range) where the Target Memory is any PFLASH bank - Non-cahced
 * Redirection Memory is LMU.
 */
void Test_3(void)
{
    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 1);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, sizeof(TEST_1_BUF_LMU));
    memcpy(TEST_2_BUF_LMU, TEST_2_BUF_FLASH, sizeof(TEST_2_BUF_LMU));

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, BUF_SIZE) && 0 == memcmp(TEST_2_BUF_LMU, TEST_2_BUF_FLASH, BUF_SIZE))
    {
        /* Configure Overlay */
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_lmu, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_1_BUF_FLASH, (uint32) TEST_1_BUF_LMU);
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 1, IfxCpu_OverlayMemorySelect_lmu, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_2_BUF_FLASH, (uint32) TEST_2_BUF_LMU);

        /* Enable All Overlay Blocks*/

        /* Select All Overlay Blocks */
        /* If we want to enable block0 and block1 OSEL value shall be 0x03  */
        /* All other blocks would be disabled  */
        MODULE_CPU0.OSEL.U = 0xFFFFFFFF;

        MODULE_SCU.OVCCON.U    |= (1 << 0)  | /* CSEL0   */
                                  (0 << 1)  | /* CSEL1   */
                                  (0 << 2)  | /* CSEL2   */
                                  (1 << 16) | /* OVSTRT  */
                                  (0 << 17) | /* OVSTP   */
                                  (0 << 18) | /* DCINVAL */
                                  (0 << 24) | /* OVCONF  */
                                  (0 << 25);  /* POVCONF */

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf1 = (uint8*) TEST_1_BUF_FLASH;
        uint8* pBuf2 = (uint8*) TEST_2_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 13);
            pBuf1[i] =  ExpecteBufferContent[i];
            pBuf2[i] =  ExpecteBufferContent[i];
        }

        /* Disable All Overlay Blocks*/
        MODULE_SCU.OVCCON.U   |= (1 << 0)  | /* CSEL0   */
                                 (0 << 1)  | /* CSEL1   */
                                 (0 << 2)  | /* CSEL2   */
                                 (0 << 16) | /* OVSTRT  */
                                 (1 << 17) | /* OVSTP   */
                                 (1 << 18) | /* DCINVAL */
                                 (0 << 24) | /* OVCONF  */
                                 (0 << 25);  /* POVCONF */

        /* To add latency (wait time) to observe the result of overlay block disabling */
        __isync();
        __dsync();


        /* Disable Overlay CPU0 */
        /* Check Overlay Disabled */
        if (MODULE_CPU0.BLK[0].RABR.B.OVEN != 0 || MODULE_CPU0.BLK[1].RABR.B.OVEN != 0)
        {
            ledOn(LED_ERROR);
        }

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_1_BUF_FLASH, (uint8*) TEST_1_BUF_LMU, sizeof(TEST_1_BUF_FLASH));
        Test_MemoryValidation((uint8*) TEST_2_BUF_FLASH, (uint8*) TEST_2_BUF_LMU, sizeof(TEST_2_BUF_FLASH));
    }
    else
    {
        ledOn(LED_ERROR);
    }
}

/* Test 4
 * 1 Block (32 Byte address range)
 * Target Memory is any PFLASH bank - Non-cahced
 * and Redirect memory is DSPR
 */
void Test_4(void)
{
    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_4_BUF_DSPR, TEST_4_BUF_FLASH, sizeof(TEST_4_BUF_DSPR));

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_4_BUF_DSPR, TEST_4_BUF_FLASH, BUF_SIZE))
    {
        /* Configure Overlay */
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_core0DsprPspr, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_4_BUF_FLASH, (uint32) TEST_4_BUF_DSPR);

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf = (uint8*) TEST_4_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 14);
            pBuf[i] =  ExpecteBufferContent[i];
        }

        /* Disable Overlay */
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_4_BUF_FLASH, (uint8*) TEST_4_BUF_DSPR, sizeof(TEST_4_BUF_FLASH));
    }
    else
    {
        ledOn(LED_ERROR);
    }
}
/* Test 5
 * 2 Blocks (32 Byte address range)
 * PFLASH target memory - Non-cached
 * Redirect memories are DSPR and LMU (1 block in LMU, and 1 block in DSPR).
 */
void Test_5(void)
{
    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 1);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, sizeof(TEST_1_BUF_LMU));
    memcpy(TEST_4_BUF_DSPR, TEST_4_BUF_FLASH, sizeof(TEST_4_BUF_DSPR));

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, BUF_SIZE) && 0 == memcmp(TEST_4_BUF_DSPR, TEST_4_BUF_FLASH, BUF_SIZE))
    {
        /* Configure Overlay */
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_lmu, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_1_BUF_FLASH, (uint32) TEST_1_BUF_LMU);
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 1, IfxCpu_OverlayMemorySelect_core0DsprPspr, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_4_BUF_FLASH, (uint32) TEST_4_BUF_DSPR);

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf1 = (uint8*) TEST_1_BUF_FLASH;
        uint8* pBuf2 = (uint8*) TEST_4_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 15);
            pBuf1[i] =  ExpecteBufferContent[i];
            pBuf2[i] =  ExpecteBufferContent[i];
        }

        /* Disable Overlay */
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 1);

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_1_BUF_FLASH, (uint8*) TEST_1_BUF_LMU, sizeof(TEST_1_BUF_FLASH));
        Test_MemoryValidation((uint8*) TEST_4_BUF_FLASH, (uint8*) TEST_4_BUF_DSPR, sizeof(TEST_4_BUF_FLASH));
    }
    else
    {
        ledOn(LED_ERROR);
    }
}
/* Test 6 (Test Overlay with cache invalidate (cache enabled))
 * 2 Blocks (32 Byte address range)
 * PFLASH target memory
 * Redirect memories are DSPR and LMU (1 block in LMU, and 1 block in DSPR)- Cached.
 */
void Test_6(void)
{
    /* Enable Cache Segments for 0xBxxxxxxx, 0x7xxxxxxx */
    IfxCpu_enableSegmentSpecificDataAccessCacheability(1 << 0x0B | 1 << 0x07, 1);

    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 1);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, sizeof(TEST_1_BUF_LMU));
    memcpy(TEST_4_BUF_DSPR, TEST_4_BUF_FLASH, sizeof(TEST_4_BUF_DSPR));

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_1_BUF_LMU, TEST_1_BUF_FLASH, BUF_SIZE) && 0 == memcmp(TEST_4_BUF_DSPR, TEST_4_BUF_FLASH, BUF_SIZE))
    {
        /* Configure Overlay */
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_lmu, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_1_BUF_FLASH, (uint32) TEST_1_BUF_LMU);
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 1, IfxCpu_OverlayMemorySelect_core0DsprPspr, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_4_BUF_FLASH, (uint32) TEST_4_BUF_DSPR);

        /* Invalidate Data */
        MODULE_SCU.OVCCON.U    |= (1 << 0)  | /* CSEL0   */
                                  (0 << 1)  | /* CSEL1   */
                                  (0 << 2)  | /* CSEL2   */
                                  (0 << 16) | /* OVSTRT  */
                                  (0 << 17) | /* OVSTP   */
                                  (1 << 18) | /* DCINVAL */
                                  (0 << 24) | /* OVCONF  */
                                  (0 << 25);  /* POVCONF */

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf1 = (uint8*) TEST_1_BUF_FLASH;
        uint8* pBuf2 = (uint8*) TEST_4_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 16);
            pBuf1[i] =  ExpecteBufferContent[i];
            pBuf2[i] =  ExpecteBufferContent[i];
        }

        /* Disable Overlay */
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 1);

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_1_BUF_FLASH, (uint8*) TEST_1_BUF_LMU, sizeof(TEST_1_BUF_FLASH));
        Test_MemoryValidation((uint8*) TEST_4_BUF_FLASH, (uint8*) TEST_4_BUF_DSPR, sizeof(TEST_4_BUF_FLASH));

        /* Disable Cache Segments for 0xBxxxxxxx, 0x7xxxxxxx */
        IfxCpu_enableSegmentSpecificDataAccessCacheability(1 << 0x0B | 1 << 0x07, 0);
    }
    else
    {
        ledOn(LED_ERROR);
    }

}
/* Test 7 (Target Overlap)
 * 2 Blocks (32 Byte address range)
 * PFLASH target memory - (Non-Cached)
 * Redirect memories are DSPR and LMU (1 block in LMU, and 1 block in DSPR).
 * Concurrent matches in more than one enabled overlay block are not supported.
 * Store operation raises Data Access Asynchronous Error (DAE) trap.
 */
void Test_7(void)
{
    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 1);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_7_BUF_LMU, TEST_7_BUF_FLASH, sizeof(TEST_7_BUF_LMU));
    memcpy(TEST_7_BUF_DSPR, TEST_7_BUF_FLASH, sizeof(TEST_7_BUF_DSPR));

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_7_BUF_LMU, TEST_7_BUF_FLASH, BUF_SIZE) && 0 == memcmp(TEST_7_BUF_DSPR, TEST_7_BUF_FLASH, BUF_SIZE))
    {
        /* Configure Overlay */
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_core0DsprPspr, IfxCpu_OverlayAddressMask_64byte, (uint32) TEST_7_BUF_FLASH, (uint32) TEST_7_BUF_DSPR);
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 1, IfxCpu_OverlayMemorySelect_lmu, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_7_BUF_FLASH, (uint32) TEST_7_BUF_LMU);

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf = (uint8*) TEST_7_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 17);
            pBuf[i] =  ExpecteBufferContent[i];
        }

        /* Disable Overlay */
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 1);

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_7_BUF_FLASH, (uint8*) TEST_7_BUF_DSPR, sizeof(TEST_7_BUF_DSPR));
        Test_MemoryValidation((uint8*) TEST_7_BUF_FLASH, (uint8*) TEST_7_BUF_LMU, sizeof(TEST_7_BUF_LMU));
    }
    else
    {
        ledOn(LED_ERROR);
    }
}
/* Test 8
 * 1 Block (32 Byte address range)
 * Target in LMU
 * Redirect in LMU
 * (In this scenario, the Overlay is not enabled, and the ERROR is occurred).
 */
void Test_8(void)
{
    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

    /* Copy Values from Target Address into Redirect Address */
    memset(TEST_8_BUF_REDIRECT, 0, sizeof(TEST_8_BUF_REDIRECT));

    /* Configure Overlay */
    IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_core0DsprPspr, IfxCpu_OverlayAddressMask_32byte, (uint32) TEST_8_BUF_TARGET, (uint32) TEST_8_BUF_REDIRECT);

    /* Flush the data cache to ensure consistency */
    __dsync();

    /* Write new contents of PFlash into ExpecteBufferContent
     * pBuf is the pointer that assign to the PFlash
     * pBuf for allowing access to PFlash
     */
    uint8* pBuf = (uint8*) TEST_8_BUF_TARGET;

    for (uint32 i = 0; i < BUF_SIZE; i++)
    {
        ExpecteBufferContent[i] = (uint8) (i + 18);
        pBuf[i] =  ExpecteBufferContent[i];
    }

    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

    /* Verification for Overlay functionality  */
    Test_MemoryValidation((uint8*) TEST_8_BUF_TARGET, (uint8*) TEST_8_BUF_REDIRECT, sizeof(TEST_8_BUF_REDIRECT));
}

/* Test 9
 * 1 Block (2K address range)
 * Target Memory is any PFLASH bank
 * Redirection Memory is DSPR
 */
void Test_9(void)
{
    /* Disable Overlay */
    IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

    /* Copy Values from Target Address into Redirect Address */
    memcpy(TEST_9_BUF_LMU, TEST_9_BUF_FLASH, sizeof(TEST_9_BUF_LMU));

    /* Verification of the data written from Target Address to the Redirect Address */
    if (0 == memcmp(TEST_9_BUF_LMU, TEST_9_BUF_FLASH, BUF_SIZE_MAX))
    {
        /* Configure Overlay */
        IfxCpu_enableOverlayBlock(IfxCpu_ResourceCpu_0, 0, IfxCpu_OverlayMemorySelect_core0DsprPspr, IfxCpu_OverlayAddressMask_2KB, (uint32) TEST_9_BUF_FLASH, (uint32) TEST_9_BUF_LMU);

        /* Flush the data cache to ensure consistency */
        __dsync();

        /* Write new contents of PFlash into ExpecteBufferContent
         * pBuf is the pointer that assign to the PFlash
         * pBuf for allowing access to PFlash
         */
        uint8* pBuf = (uint8*) TEST_9_BUF_FLASH;

        for (uint32 i = 0; i < BUF_SIZE_MAX; i++)
        {
            ExpecteBufferContent[i] = (uint8) (i + 19);
            pBuf[i] =  ExpecteBufferContent[i];
        }

        /* Disable Overlay */
        IfxCpu_disableOverlayBlock(IfxCpu_ResourceCpu_0, 0);

        /* Verification for Overlay functionality  */
        Test_MemoryValidation((uint8*) TEST_9_BUF_FLASH, (uint8*) TEST_9_BUF_LMU, sizeof(TEST_9_BUF_FLASH));
    }
    else
    {
        ledOn(LED_ERROR);
    }
}

/* Expectation is get the value stored in RAM instead of PFlash */

/* Compare the new contents of the PFlash, stored in the ExpectBuffer with RAM.
 * If the value written in "ExpecteBufferContent" and "SRAM" will not be equal then the error would be happened.
   else, LED_SUCCESS (LED2) will be toggling, which indicates overlay functionality. */
static uint8 Test_MemoryValidation(uint8* target, uint8* redirect, uint32 size)
{
    uint8* pTarget;
    uint8* pRedirect;
    uint8  result = RESULT_OK;

    pTarget = target;

    /* Verify Values of Target Address and Redirect Address */
    pTarget = &ExpecteBufferContent[0];
    pRedirect = redirect;

    for (uint32 i = 0; i < size; i++)
    {
        /* read from the redirect and target address and compare. */
        if (*pTarget++ != *pRedirect++)
        {
            /* Error Found */
            result = RESULT_ERR;
            break;
        }
    }
    if (result == RESULT_OK)
    {
        /* Enable LED Success */
        ledOn(LED_SUCCESS);
        return 1;
    }
    else
    {
        /* Enable LED Error */
        ledOn(LED_ERROR);
        return 0;
    }
}
