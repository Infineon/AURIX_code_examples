/**********************************************************************************************************************
 * \file    GPT12_Incremental_Encoder.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "GPT12_Incremental_Encoder.h"
#include "IfxPort.h"
#include "Bsp.h"
#include "IfxStm.h"
#include "Ifx_Types.h"
#include "IfxGpt12.h"
#include "Bsp.h"
#include "IfxGpt12_IncrEnc.h"
#include <stddef.h>
#include <float.h>
#include <math.h>

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_GPT12_TIMER    6                               /* GPT12 Timer interrupt priority                */
#define ISR_PROVIDER_GPT12_TIMER    IfxSrc_Tos_cpu0                 /* Interrupt provider                            */
#define UPDATE_FREQ_HZ              10000                           /* Encoder function update frequency.            */
#define SPEED_PULSE_COUNTING_RPM    1200                            /* Speed point when switching from one to
                                                                       another position sensing method value.        */
#define SPEED_MIN_RPM               (0.0f)                          /* Minimum speed limit value.                    */
#define SPEED_MAX_RPM               (2000.0f)                       /* Maximum speed limit value.                    */
#define ENCODER_GPT12_PIN_A         &IfxGpt120_T3INA_P02_6_IN       /* Encoder pin A                                 */
#define ENCODER_GPT12_PIN_B         &IfxGpt120_T3EUDA_P02_7_IN      /* Encoder pin B                                 */
#define ENCODER_GPT12_PIN_Z         &IfxGpt120_T4INA_P02_8_IN       /* Encoder pin Z                                 */
#define ENCODER_OFFSET              0                               /* Encoder offset                                */
#define ENCODER_REVERSED            TRUE                            /* Encoder reversed?                             */
#define ENCODER_RESOLUTION          2048                            /* Encoder resolution - pulses per revolution.   */
#define ENCODER_UPDATE_PERIOD       (1/ ((float32)UPDATE_FREQ_HZ))  /* Encoder function update period.               */
/* Use pulse counting if there is less than user defined counting rpm */
#define ENCODER_SPEED_MODE_THRESHOLD    2 * IFX_PI * SPEED_PULSE_COUNTING_RPM / 60
#define ENCODER_BASE_MIN_SPEED      (float32) (SPEED_MIN_RPM / 60.0 * 2 * IFX_PI) /* Minimum base speed              */
#define ENCODER_BASE_MAX_SPEED      (float32) (SPEED_MAX_RPM / 60.0 * 2 * IFX_PI) /* Maximum base speed              */
#define ENCODER_EMULATOR_PIN_A      &MODULE_P02, 6                  /* Encoder emulator pin A                        */
#define ENCODER_EMULATOR_PIN_B      &MODULE_P02, 7                  /* Encoder emulator pin B                        */
#define ENCODER_EMULATOR_PIN_Z      &MODULE_P02, 8                  /* Encoder emulator pin Z                        */
#define ENCODER_EMULATOR_SPEED      5                               /* Encoder emulator initial speed [rad/s]        */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
Encoder          g_encoderEmulation;    /* Encoder emulator structure                                                */
uint32           g_intCount;            /* Interrupt counter                                                         */
IfxGpt12_IncrEnc g_gpt12IncrEnc;        /* Incremental encoder handle                                                */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro makes following definitions:
 * 1) Define linker section as .intvec_tc<vector number>_<interrupt priority>.
 * 2) define compiler specific attribute for the interrupt functions.
 * 3) define the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */

IFX_INTERRUPT(interruptGpt12, 0, ISR_PRIORITY_GPT12_TIMER);

/* Function to initialize the GPT12 and start the timer */
void initGpt12Timer(void)
{
    /* Initialize global clocks */
    IfxGpt12_enableModule(&MODULE_GPT120);
    /* Set the GPT1 block prescaler */
    IfxGpt12_setGpt1BlockPrescaler(&MODULE_GPT120, IfxGpt12_Gpt1BlockPrescaler_8);
    /* Set the GPT2 block prescaler */
    IfxGpt12_setGpt2BlockPrescaler(&MODULE_GPT120, IfxGpt12_Gpt2BlockPrescaler_4);

    IfxGpt12_IncrEnc_Config gpt12Config;
    IfxGpt12_IncrEnc_initConfig(&gpt12Config, &MODULE_GPT120);

    /* Configure sensor, T3 used as position acquisition core */

    /* Configure position sensor offset */
    gpt12Config.base.offset             = ENCODER_OFFSET;
    /* The sensor direction is reversed */
    gpt12Config.base.reversed           = ENCODER_REVERSED;
    /* Sensor resolution (number of pulses per revolution) */
    gpt12Config.base.resolution         = ENCODER_RESOLUTION;
    /* Resolution multiplier for encoder interface, Timer T3 is clocked by each transition on both of the external
     * input pins. */
    gpt12Config.base.resolutionFactor   = IfxStdIf_Pos_ResolutionFactor_fourFold;

    /* Configure speed parameters */

    /* Threshold used for speed calculation using pulse count mode or time diff. mode in rad/s */
    gpt12Config.base.speedModeThreshold = ENCODER_SPEED_MODE_THRESHOLD;
    /* Absolute minimal allowed speed. below speed is recognized as 0 rad/s */
    gpt12Config.base.minSpeed           = ENCODER_BASE_MIN_SPEED;
    /* Absolute maximal allowed speed. Above speed is recognized as error */
    gpt12Config.base.maxSpeed           = ENCODER_BASE_MAX_SPEED;
    gpt12Config.base.speedFilterEnabled        = TRUE;
    gpt12Config.base.speedFilerCutOffFrequency = 1000;
    /* Configure Handler */

    /* Update period in seconds */
    gpt12Config.base.updatePeriod       = ENCODER_UPDATE_PERIOD;
    /* Interrupt isrPriority of the zero interrupt */
    gpt12Config.zeroIsrPriority    = ISR_PRIORITY_GPT12_TIMER;
    /* Interrupt service provider for the zero interrupt */
    gpt12Config.zeroIsrProvider    = ISR_PROVIDER_GPT12_TIMER;

    /* Configure Hardware Resources */
    gpt12Config.pinA               = ENCODER_GPT12_PIN_A;                   /* Encoder A signal, connected to T3IN   */
    gpt12Config.pinB               = ENCODER_GPT12_PIN_B;                   /* Encoder B signal, connected to T3EUD  */
    gpt12Config.pinZ               = ENCODER_GPT12_PIN_Z;                   /* Encoder Z signal, connected to T4IN   */
    gpt12Config.pinDriver          = IfxPort_PadDriver_cmosAutomotiveSpeed3;/* Pad Driver                            */

    /* Initialize the Incremental Encoder handle */
    IfxGpt12_IncrEnc_init(&g_gpt12IncrEnc, &gpt12Config);
    /* Calculate value for the T2 timer */
    sint32 resolution = g_gpt12IncrEnc.resolution - 1;
    /* Set the timer T2 mode of operation to reload mode */
    IfxGpt12_T2_setMode(&MODULE_GPT120, IfxGpt12_Mode_reload);
    /* Set value for the T2 timer */
    IfxGpt12_T2_setTimerValue(&MODULE_GPT120, (uint16)resolution);
    /* Set the input edge selection for the reload mode of the T2 timer */
    IfxGpt12_T2_setReloadInputMode(&MODULE_GPT120, IfxGpt12_ReloadInputMode_bothEdgesTxOTL);
}

/* Interrupt Service Routine of the GPT12 */
void interruptGpt12(void)
{
    g_intCount++;
    IfxGpt12_IncrEnc_onZeroIrq(&g_gpt12IncrEnc);
}

/* Function to initialize the incremental encoder simulation */
void initEncoderEmulation(void)
{
    /* Run encoder emulation after initialization */
    g_encoderEmulation.control.run                  = TRUE;
    /* Set initial direction */
    g_encoderEmulation.control.direction            = IfxStdIf_Pos_Dir_forward;
    /* Sensor resolution (number of pulses per revolution) */
    g_encoderEmulation.control.resolution           = ENCODER_RESOLUTION;
    /* Set initial step*/
    g_encoderEmulation.control.step                 = 3;
    /* Set initial expected raw position */
    g_encoderEmulation.control.rawPosition          = 0;
    /* Set initial requested encoder speed in rad/s */
    g_encoderEmulation.control.speed                = ENCODER_EMULATOR_SPEED;
    /* Set encoder multiplication factor */
    g_encoderEmulation.control.multiplicationFactor = IfxStdIf_Pos_ResolutionFactor_fourFold;
    /* Set refresh period */
    g_encoderEmulation.control.updatePeriod         = ENCODER_UPDATE_PERIOD;
    /* Set mask for rawPosition value */
    g_encoderEmulation.control.positionMask         = g_encoderEmulation.control.resolution * g_encoderEmulation.control.multiplicationFactor - 1;
    /* Initialize encoder emulator pins */
    IfxPort_setPinMode(ENCODER_EMULATOR_PIN_A, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(ENCODER_EMULATOR_PIN_B, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(ENCODER_EMULATOR_PIN_Z, IfxPort_Mode_outputPushPullGeneral);
}

/* Function to execute encoder emulator step */
void doEncoderEmulationStep(void)
{
    if (g_encoderEmulation.control.run)
    {
        sint32 rawPosition;
        rawPosition = g_encoderEmulation.control.rawPosition;

        if (g_encoderEmulation.control.direction == IfxStdIf_Pos_Dir_forward)
        {
            g_encoderEmulation.control.step++;
            g_encoderEmulation.control.step &= 0x3;
            rawPosition++;
        }
        else
        {
            g_encoderEmulation.control.step--;
            g_encoderEmulation.control.step &= 0x3;
            rawPosition--;
        }

        rawPosition &= g_encoderEmulation.control.positionMask;
        g_encoderEmulation.control.rawPosition = rawPosition;

        /* Handle zero pin */
        if (g_encoderEmulation.control.direction == IfxStdIf_Pos_Dir_forward)
        {
            if (rawPosition == 0)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_high);
            }
            else if (rawPosition == 1)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_low);
            }
        }
        else
        {
            if (rawPosition == g_encoderEmulation.control.positionMask)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_high);
            }
            else if (rawPosition == g_encoderEmulation.control.positionMask - 1)
            {
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_Z, IfxPort_State_low);
            }
        }
        /* Handle A and B pins */
        switch (g_encoderEmulation.control.step)
        {
            case 0:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_low);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_low);
                break;
            case 1:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_low);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_high);
                break;
            case 2:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_high);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_high);
                break;
            case 3:
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_A, IfxPort_State_high);
                IfxPort_setPinState(ENCODER_EMULATOR_PIN_B, IfxPort_State_low);
                break;
            default:
                break;
        }
    }
}

/* Function to execute encoder emulator */
void doEncoderEmulation(void)
{
    Ifx_TickTime tickPeriod;
    Ifx_TickTime tickRefresh;

    Ifx_TickTime refreshDeadLine;
    Ifx_TickTime tickDeadLine;

    tickRefresh     = g_encoderEmulation.control.updatePeriod * TimeConst_1s;

    refreshDeadLine = IfxStm_now(); /* Get the STM counter value */
    tickDeadLine    = refreshDeadLine;

    while (1)
    {
        g_encoderEmulation.control.run = g_encoderEmulation.control.speed != 0.0;

        if (!g_encoderEmulation.control.run)
        {}
        else
        {
            if(g_encoderEmulation.control.speed < 0)
            {
                g_encoderEmulation.control.speed = 0;
            }
            float32 roundDuration_s = (2.0 * IFX_PI) / g_encoderEmulation.control.speed;
            float32 tickDuration_s  = roundDuration_s / (g_encoderEmulation.control.positionMask + 1);

            tickPeriod = tickDuration_s * TimeConst_1s;

            /* Check if tick deadline has occurred */
            if (IfxStm_isDeadLine(tickDeadLine))
            {
                tickDeadLine = addTTime(tickDeadLine, tickPeriod);
                doEncoderEmulationStep(); /* Execute encoder emulator step */
            }
        }
        /* Check if refresh deadline has occurred */
        if (IfxStm_isDeadLine(refreshDeadLine))
        {
            refreshDeadLine = addTTime(refreshDeadLine, tickRefresh);
            /* Update encoder driver */
            IfxGpt12_IncrEnc_update(&g_gpt12IncrEnc);
            /* Get speed, raw position and direction */
            g_encoderEmulation.status.speed       = IfxGpt12_IncrEnc_getSpeed(&g_gpt12IncrEnc);
            g_encoderEmulation.status.rawPosition = IfxGpt12_IncrEnc_getRawPosition(&g_gpt12IncrEnc);
            g_encoderEmulation.status.direction   = IfxGpt12_IncrEnc_getDirection(&g_gpt12IncrEnc);
        }
    }
}
