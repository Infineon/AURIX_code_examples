/**
 * \file IfxPcie_Ep.c
 * \brief PCIE EP details
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxPcie_Ep.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxPcie_Ep_initConfig(Ifx_PCIE_USP *pcieEpSfr, IfxPcie_Ep_Config *config)
{
    const IfxPcie_Ep_Config defaultConfig = {
        .pcieSFR  = NULL_PTR,
        .hsphySFR = NULL_PTR,
        .index    = IfxPcie_Index_0,
        {
            .deviceId = 0xABCD,
            .vendorId = 0x0000,
        },
        {
            {                                                  /* BAR 0 */
                .enable       = TRUE,                          /**< \brief BAR0 enabled by default */
                .localMemBase = 0x0u,                          /**< \brief Local Memory hardcoded for BAR0, no need to configure */
                .size         = IFXPCIE_CFG_BAR0_DEFAULT_SIZE, /**< \brief Default size */
                .addressWidth = IfxPcie_AddressWidth_32,       /**< \brief 32 Bit */
                .prefetch     = FALSE,                         /**< \brief BAR0 is in volatile area */
                .atuRegion    = IfxPcie_AtuRegion_none         /**< \brief No ATU */
            },
            {                                                  /* BAR 1 */
                .enable       = FALSE,                         /**< \brief Disabled by default */
                .localMemBase = 0x0u,                          /**< \brief 0 */
                .size         = 0x0u,                          /**< \brief 0 */
                .addressWidth = IfxPcie_AddressWidth_32,       /**< \brief 32 Bit */
                .prefetch     = FALSE,                         /**< \brief BAR0 is in volatile area */
                .atuRegion    = IfxPcie_AtuRegion_none         /**< \brief No ATU */
            },
            {                                                  /* BAR 2 */
                .enable       = FALSE,                         /**< \brief Disabled by default */
                .localMemBase = 0x0u,                          /**< \brief 0 */
                .size         = 0x0u,                          /**< \brief 0 */
                .addressWidth = IfxPcie_AddressWidth_32,       /**< \brief 32 Bit */
                .prefetch     = FALSE,                         /**< \brief BAR0 is in volatile area */
                .atuRegion    = IfxPcie_AtuRegion_none         /**< \brief No ATU */
            },
            {                                                  /* BAR 3 */
                .enable       = FALSE,                         /**< \brief Disabled by default */
                .localMemBase = 0x0u,                          /**< \brief 0 */
                .size         = 0x0u,                          /**< \brief 0 */
                .addressWidth = IfxPcie_AddressWidth_32,       /**< \brief 32 Bit */
                .prefetch     = FALSE,                         /**< \brief BAR0 is in volatile area */
                .atuRegion    = IfxPcie_AtuRegion_none         /**< \brief No ATU */
            },
            {                                                  /* BAR 4 */
                .enable       = FALSE,                         /**< \brief Disabled by default */
                .localMemBase = 0x0u,                          /**< \brief 0 */
                .size         = 0x0u,                          /**< \brief 0 */
                .addressWidth = IfxPcie_AddressWidth_32,       /**< \brief 32 Bit */
                .prefetch     = FALSE,                         /**< \brief BAR0 is in volatile area */
                .atuRegion    = IfxPcie_AtuRegion_none         /**< \brief No ATU */
            },
            {                                                  /* BAR 5 */
                .enable       = FALSE,                         /**< \brief Disabled by default */
                .localMemBase = 0x0u,                          /**< \brief 0 */
                .size         = 0x0u,                          /**< \brief 0 */
                .addressWidth = IfxPcie_AddressWidth_32,       /**< \brief 32 Bit */
                .prefetch     = FALSE,                         /**< \brief BAR0 is in volatile area */
                .atuRegion    = IfxPcie_AtuRegion_none         /**< \brief No ATU */
            },
        },
        .outBoundRegion            = NULL_PTR,
        {
            .numTriggerVectors = 0x0u,
            .triggerEnableMask = 0xFFFFFFFFu,               /* Enable all */
            {
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                },
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                },
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                },
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                },
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                },
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                },
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                },
                {
                    .typeOfService = IfxSrc_Tos_cpu0,       /**< \brief CPU0 by default */
                    .priority      = 0x0u,                  /**< \brief 0 : Don't interrupt CPU */
                    .vmNumber      = IfxSrc_VmId_0,         /**< \brief VM ID 0 */
                    .intVector     = IfxPcie_IntVector_none /**< \brief No Vector configured */
                }
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                           /**< \brief CPU0 by default */
                .priority      = 0x0u,                                      /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                             /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_genError                 /**< \brief General Errors vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                           /**< \brief CPU0 by default */
                .priority      = 0x0u,                                      /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                             /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_aerError                 /**< \brief AER Errors vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                           /**< \brief CPU0 by default */
                .priority      = 0x0u,                                      /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                             /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_pmRequest                /**< \brief PM Errors Vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                           /**< \brief CPU0 by default */
                .priority      = 0x0u,                                      /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                             /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_link                     /**< \brief Link Errors vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                           /**< \brief CPU0 by default */
                .priority      = 0x0u,                                      /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                             /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_message                  /**< \brief Message Interrupt Vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                           /**< \brief CPU0 by default */
                .priority      = 0x0u,                                      /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                             /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_misc                     /**< \brief Misc Interrupt Vector */
            }
        },
        .numOutBoundRegions = 0x0u,
        .drsSupport         = FALSE,
        .pollForEnumeration = TRUE                                          /* By Default: Driver polls for enumeration to complete */
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* take over module pointer */
    config->pcieSFR = pcieEpSfr;
}


IfxPcie_Status IfxPcie_Ep_init(IfxPcie_Ep *epHandle, IfxPcie_Ep_Config *config)
{
    IfxPcie_Status status = IfxPcie_Status_success;

    status |= IfxPcie_Ep_initModule(epHandle, config);              /* Initialize the EP module */

    if (status == IfxPcie_Status_success)
    {
        epHandle->state = IfxPcie_Ep_State_initialized;
#if IFXPCIE_CFG_RTL_VIP == (0)
        IfxPcie_Ep_initLink(epHandle);                                  /* Initialize the link */

        while (IfxPcie_isLinkUp((IfxPcie *)epHandle->pcieSFR) == FALSE) /* check if Link is up */
        {}

#endif
    }

    if (status == IfxPcie_Status_success)
    {
        if (config->pollForEnumeration == TRUE)
        {
            status = IfxPcie_Ep_initPostEnumeration(epHandle);
        }
        else
        {
            epHandle->busMasterAccess = FALSE;
        }
    }

    if (status == IfxPcie_Status_failure)
    {
        epHandle->state = IfxPcie_Ep_State_configError;
    }

    return status;
}


IfxPcie_Status IfxPcie_Ep_initModule(IfxPcie_Ep *epHandle, IfxPcie_Ep_Config *config)
{
    IfxPcie_Status              initStatus = IfxPcie_Status_failure;
    IfxPcieLib_Device_EndPoint *epFunction = &(epHandle->epFunction);
    Ifx_PCIE_USP               *pcie       = config->pcieSFR;
    IfxPcieDevice_Type0CfgHdr  *cfgHdr     = (IfxPcieDevice_Type0CfgHdr *)&(pcie->TYPE0HDR);
    epHandle->state       = IfxPcie_Ep_State_unknown;
    epHandle->pcieSFR     = config->pcieSFR;
    epHandle->index       = config->index;
    epFunction->cfgHeader = cfgHdr;

    /* STEP 1: Enable the Module */
    IfxPcie_enableModule((IfxPcie *)pcie);

    /* STEP 2: Set device type to RC */
    IfxPcie_setDeviceMode((IfxPcie *)pcie, IfxPcie_DeviceMode_ep);
    epHandle->pcieSFR = config->pcieSFR;

    /* STEP 3: Reset the Module */
    IfxPcie_resetModule((IfxPcie *)pcie);

    /* STEP 4: Wait for HSPHY */
    if (config->hsphySFR != NULL_PTR)
    {
        epHandle->hsphySFR = config->hsphySFR;

        /* Wait for HSPHY to give the clock */
#if IFXPCIE_CFG_ENABLE_PHY == 1
        IfxHsphy_PhyIndex phyIndex = IFXPCIE_GET_PHY_INDEX(epHandle->index);
        IfxPcie_waitForHsphy(epHandle->hsphySFR, phyIndex);
#endif

        /* Enable Link Training */
#if IFXPCIE_CFG_RTL_VIP == (1)
        IfxPcie_enableLtssm((IfxPcie *)pcie);

        while (IfxPcie_isLinkUp((IfxPcie *)pcie) == FALSE)          /* check if Link is up */
        {
            /* TODO: Disable warning, this is needed */
        }

#endif
        initStatus = IfxPcie_Status_success;
    }

    if (initStatus == IfxPcie_Status_success)
    {
        /* STEP 5: Enable DBI access */
        IfxPcie_setDbiRoAccess((IfxPcie *)pcie, TRUE);
#if IFXPCIE_CFG_RTL_VIP == (0)
        /* STEP 6: Do not allow Link Training - setting up Device now */
        IfxPcieEp_resetLinkTraining(pcie);
#endif
        /* STEP 7: Initialize the EP Device for protocol */
        {
            /* 7.1 Write the device ID, vendor ID */
            IfxPcieDevice_setDeviceId((IfxPcieDevice_CfgHdr *)epFunction->cfgHeader, config->epFunction.deviceId);
            IfxPcieDevice_setVendorId((IfxPcieDevice_CfgHdr *)epFunction->cfgHeader, config->epFunction.vendorId);

            /* 7.2: PCIE Configure BAR */
            initStatus = IfxPcie_Ep_allocateBarMemories(epHandle, &(config->barRegion[0]));

            /* 7.3: Probe Capabilities */
            IfxPcieLib_Cap_probeCapabilities(&(epFunction->capabilities), (IfxPcieDevice_CfgHdr *)epFunction->cfgHeader);
        }

        if (initStatus == IfxPcie_Status_success)
        {
            /* STEP 8: Interrupt Reception Initialization */
            initStatus = IfxPcie_Ep_initInterrupts(epHandle, config);

            /* STEP 9: Update Handle with Memory Accesses (Before Enumeration) */
            if ((config->outBoundRegion != NULL_PTR)
                && (initStatus == IfxPcie_Status_success))
            {
                epHandle->numOutBoundMemRegions = config->numOutBoundRegions;
                uint8 memIndex;

                for (memIndex = 0; memIndex < config->numOutBoundRegions; memIndex++)
                {
                    IfxPcie_Ep_Mem    *memHandlePtr = &(epHandle->outBoundMemRegion[memIndex]);
                    IfxPcie_Ep_MemCfg *memCfgPtr    = &(config->outBoundRegion[memIndex]);
                    memHandlePtr->wireMemBase  = memCfgPtr->wireMemBase;
                    memHandlePtr->localMemBase = memCfgPtr->localMemBase;
                    memHandlePtr->size         = memCfgPtr->size;
                    memHandlePtr->atuRegion    = memCfgPtr->atuRegion;
                    memHandlePtr->enabled      = FALSE;                         /* Disable now, enable once we have BME access */
                }
            }
            else
            {
                epHandle->numOutBoundMemRegions = 0x0u;                         /* No outbound region configured */
            }
        }
    }

    /* STEP 10: Disable DBI access */
    IfxPcie_setDbiRoAccess((IfxPcie *)pcie, FALSE);

    return initStatus;
}


void IfxPcie_Ep_initLink(IfxPcie_Ep *epHandle)
{
    IfxPcie_enableLtssm((IfxPcie *)epHandle->pcieSFR);  /* Start the Link Training */
}


IfxPcie_Status IfxPcie_Ep_initPostEnumeration(IfxPcie_Ep *epHandle)
{
    IfxPcie_Status status = IfxPcie_Status_success;

    while (IfxPcie_isLinkUp((IfxPcie *)epHandle->pcieSFR) == FALSE)     /* check if Link is up */
    {
        /* TODO: Disable warning, this is needed */
    }

    epHandle->state = IfxPcie_Ep_State_linkUp;

    while (IfxPcieDevice_isMemorySpaceEnabled((IfxPcieDevice_CfgHdr *)epHandle->epFunction.cfgHeader) == FALSE)
    {
        /* Wait here for Enumeration */
        /* TODO: Timeout */
    }

    epHandle->state = IfxPcie_Ep_State_enumerated;

    status         |= IfxPcie_Ep_initInterruptGen(epHandle); /* Initialize the Interrupt Generation */

    status         |= IfxPcie_Ep_initOutBoundAccess(epHandle);

    if (status == IfxPcie_Status_failure)
    {
        epHandle->state = IfxPcie_Ep_State_error;
    }
    else
    {
        epHandle->state = IfxPcie_Ep_State_initPostEnumeration;
    }

    return status;
}


IfxPcie_Status IfxPcie_Ep_initOutBoundAccess(IfxPcie_Ep *epHandle)
{
    IfxPcie_Status status = IfxPcie_Status_success;
    epHandle->busMasterAccess = IfxPcieDevice_isBusMasterEnabled((IfxPcieDevice_CfgHdr *)epHandle->epFunction.cfgHeader);

    if (epHandle->numOutBoundMemRegions != 0u)
    {
        uint8 numMemRegions = epHandle->numOutBoundMemRegions;
        epHandle->numOutBoundMemRegions = 0u;                   /* Clear the number, update as initialized */

        if (epHandle->busMasterAccess == TRUE)
        {
            uint8 memIndex;

            for (memIndex = 0u; memIndex < numMemRegions; memIndex++)
            {
                IfxPcie_Ep_Mem *memHandlePtr = &(epHandle->outBoundMemRegion[memIndex]);
                status = IfxPcie_Ep_configureOutBoundAtu(epHandle, memHandlePtr->wireMemBase, memHandlePtr->localMemBase, memHandlePtr->size, memHandlePtr->atuRegion);

                if (status == IfxPcie_Status_failure)
                {
                    break;
                }
            }
        }
        else
        {
            status = IfxPcie_Status_failure;
        }
    }

    return status;
}


IfxPcie_Status IfxPcie_Ep_allocateBarMemories(IfxPcie_Ep *epHandle, IfxPcie_Ep_BarCfg *barCfgPtr)
{
    IfxPcie_Status  status   = IfxPcie_Status_success;
    uint8           barIndex = 0u;
    IfxPcie_Ep_Bar *barRegion, *previousBarRegion;

    barRegion = &(epHandle->barRegion[0]);                                                                                           /* For BAR0, we handle it separately here */

    if (barCfgPtr->size > IFXPCIE_CFG_BAR0_DEFAULT_SIZE)                                                                             /* User wants to increase size of BAR0 */
    {
        status |= IfxPcieEp_setBarMask(epHandle->pcieSFR, (IfxPcie_BarNum)barIndex, barCfgPtr->size, barCfgPtr->addressWidth, TRUE); /* Set BAR MASK */

        if (status == IfxPcie_Status_success)
        {
            IfxPcieEp_setBarParameters(epHandle->pcieSFR, (IfxPcie_BarNum)barIndex, barCfgPtr->addressWidth, FALSE);
            barRegion->size         = barCfgPtr->size;
            barRegion->prefetch     = FALSE;                                                        /* BAR0 lies in volatile space */
            barRegion->addressWidth = barCfgPtr->addressWidth;
            barRegion->atuRegion    = IfxPcie_AtuRegion_none;
            barRegion->enable       = TRUE;
        }
    }
    else
    {
        barRegion->size         = IFXPCIE_CFG_BAR0_DEFAULT_SIZE;
        barRegion->prefetch     = FALSE;                                                            /* BAR0 lies in volatile space */
        barRegion->addressWidth = IfxPcie_AddressWidth_32;
        barRegion->atuRegion    = IfxPcie_AtuRegion_none;
        barRegion->enable       = TRUE;
    }

    for (barIndex = 1u; barIndex < IFXPCIE_CFG_MAX_NUM_EP_BARS; barIndex++)                         /* Loop Through all remaining BARs */
    {
        previousBarRegion = barRegion;
        barRegion         = &(epHandle->barRegion[barIndex]);
        barCfgPtr++;

        if ((barCfgPtr->enable == TRUE)
            && (previousBarRegion->addressWidth != IfxPcie_AddressWidth_64))
        {
            status |= IfxPcieEp_setBarMask(epHandle->pcieSFR, (IfxPcie_BarNum)barIndex, barCfgPtr->size, barCfgPtr->addressWidth, TRUE);    /* Set BAR MASK */

            if (status == IfxPcie_Status_success)
            {
                IfxPcieEp_setBarParameters(epHandle->pcieSFR, (IfxPcie_BarNum)barIndex, barCfgPtr->addressWidth, barCfgPtr->prefetch);
                barRegion->size         = barCfgPtr->size;
                barRegion->prefetch     = barCfgPtr->prefetch;
                barRegion->addressWidth = barCfgPtr->addressWidth;

                /* Configure ATU only when region is specified */
                if (barCfgPtr->atuRegion != IfxPcie_AtuRegion_none)
                {
                    status |= IfxPcie_Ep_configureInBoundAtu(epHandle, (IfxPcie_BarNum)barIndex, barCfgPtr->localMemBase, barCfgPtr->atuRegion);
                }

                if (status == IfxPcie_Status_success)
                {
                    barRegion->enable = TRUE;
                }
            }
        }
        else
        {
            if (barCfgPtr->enable == FALSE)
            {
                (void)IfxPcieEp_setBarMask(epHandle->pcieSFR, (IfxPcie_BarNum)barIndex, 0u, IfxPcie_AddressWidth_32, FALSE);    /* Set BAR MASK, disable BAR */
                barRegion->enable       = FALSE;
                barRegion->localMemBase = 0u;
                barRegion->atuRegion    = IfxPcie_AtuRegion_none;
            }
        }
    }

    return status;
}


IfxPcie_Status IfxPcie_Ep_configureOutBoundAtu(IfxPcie_Ep *epHandle, uint64 wireMemBase, uint32 localMemBase, uint32 size, IfxPcie_AtuRegion region)
{
    IfxPcie_Status                 status    = IfxPcie_Status_failure;
    IfxPcieLib_Device_AtuRegionCfg atuRegionCfg;
    IfxPcieLib_Device_AtuRegion   *atuRegion = &(epHandle->atu.outboundRegion[region]);
    uint8                          memIndex  = epHandle->numOutBoundMemRegions;
    IfxPcie_Ep_Mem                *memHandle = &(epHandle->outBoundMemRegion[memIndex]);

    if ((region != IfxPcie_AtuRegion_none)                                                          /* Valid ATU Region */
        && (atuRegion->enabled == FALSE))                                                           /* Region is not already initialized */
    {
        atuRegionCfg.regionIndex                        = region;
        atuRegionCfg.direction                          = IfxPcie_AtuDirection_outBound;
        atuRegionCfg.barMapped                          = FALSE;
        atuRegionCfg.localMemBase                       = localMemBase;
        atuRegionCfg.wireMemBase                        = wireMemBase;
        atuRegionCfg.memSize                            = size;
        atuRegionCfg.outboundTlp.dmaBypass              = FALSE;
        atuRegionCfg.outboundTlp.tlpHeader.type         = IfxPcie_TlpType_memRequest;
        atuRegionCfg.outboundTlp.payloadInhibit         = FALSE;
        atuRegionCfg.outboundTlp.tlpHeader.tag          = 0;
        atuRegionCfg.outboundTlp.tlpHeader.orderingAttr = IfxPcie_TlpOrdering_default;
        atuRegionCfg.outboundTlp.tlpHeader.trafficClass = IfxPcie_TlpTrafficClass_0;
        atuRegionCfg.enable                             = TRUE;

        IfxPcieLib_Device_initAtuRegion((IfxPcie *)(epHandle->pcieSFR), atuRegion, &atuRegionCfg);  /* Initialize the Region */

        epHandle->numOutBoundMemRegions = memIndex + 1;

        memHandle->atuRegion            = region;
        memHandle->localMemBase         = localMemBase;
        memHandle->wireMemBase          = wireMemBase;
        memHandle->size                 = size;
        memHandle->enabled              = TRUE;
        status                          = IfxPcie_Status_success;
    }

    return status;
}


IfxPcie_Status IfxPcie_Ep_configureInBoundAtu(IfxPcie_Ep *epHandle, IfxPcie_BarNum barIndex, uint32 localMemBase, IfxPcie_AtuRegion region)
{
    IfxPcie_Status                 status    = IfxPcie_Status_failure;
    IfxPcieLib_Device_AtuRegionCfg atuRegionCfg;
    IfxPcieLib_Device_AtuRegion   *atuRegion = &(epHandle->atu.inboundRegion[region]);
    IfxPcie_Ep_Bar                *barRegion = &(epHandle->barRegion[barIndex]);

    if ((region != IfxPcie_AtuRegion_none)                                                          /* Valid ATU Region */
        && (barIndex != IfxPcie_BarNum_0)                                                           /* BAR0 cannot have ATU */
        && (atuRegion->enabled == FALSE))                                                           /* Region is not already initialized */
    {
        atuRegionCfg.regionIndex               = region;
        atuRegionCfg.direction                 = IfxPcie_AtuDirection_inBound;
        atuRegionCfg.barMapped                 = TRUE;
        atuRegionCfg.barIndex                  = barIndex;
        atuRegionCfg.localMemBase              = localMemBase;
        atuRegionCfg.wireMemBase               = 0u;
        atuRegionCfg.memSize                   = 0u;
        atuRegionCfg.inboundTlp.tlpHeader.type = IfxPcie_TlpType_memRequest;
        atuRegionCfg.enable                    = TRUE;

        IfxPcieLib_Device_initAtuRegion((IfxPcie *)(epHandle->pcieSFR), atuRegion, &atuRegionCfg);  /* Initialize the Region */

        barRegion->localMemBase = localMemBase;
        barRegion->atuRegion    = region;
        status                  = IfxPcie_Status_success;
    }

    return status;
}


void IfxPcie_Ep_disableBar(IfxPcie_Ep *epHandle, IfxPcie_BarNum barIndex)
{
    boolean         dbiAccess = IfxPcie_isDbiRoAccessEnabled((IfxPcie *)epHandle->pcieSFR);
    IfxPcie_Ep_Bar *barRegion = &(epHandle->barRegion[barIndex]);

    if (dbiAccess == FALSE)
    {
        IfxPcie_setDbiRoAccess((IfxPcie *)epHandle->pcieSFR, TRUE);                                                     /* Get DBI access */
    }

    (void)IfxPcieEp_setBarMask(epHandle->pcieSFR, barIndex, 0, IfxPcie_AddressWidth_32, FALSE);                         /* Disable BAR Region */

    if (dbiAccess == FALSE)
    {
        IfxPcie_setDbiRoAccess((IfxPcie *)epHandle->pcieSFR, FALSE);                                                        /* Restore DBI access */
    }

    if (barRegion->atuRegion != IfxPcie_AtuRegion_none)
    {
        IfxPcieLib_Device_freeAtuRegion((IfxPcie *)epHandle->pcieSFR, &(epHandle->atu.inboundRegion[barRegion->atuRegion]));    /* Disable ATU mapping */
    }

    barRegion->enable       = FALSE;
    barRegion->atuRegion    = IfxPcie_AtuRegion_none;
    barRegion->localMemBase = 0u;
}


IfxPcie_Status IfxPcie_Ep_initInterrupts(IfxPcie_Ep *epHandle, IfxPcie_Ep_Config *config)
{
    IfxPcie_Status           status      = IfxPcie_Status_success;
    uint8                    vectorIndex = 0u;
    IfxPcie_IntVector        intVector;
    IfxPcie_Ep_InterruptCfg *intCfg      = &(config->interrupt);
    IfxPcie_Ep_Int          *epInt       = &(epHandle->interrupt);

    /* STEP1: Initialize Remote Trigger interrupts */
    if (intCfg->numTriggerVectors > 0)
    {
        if (intCfg->numTriggerVectors <= IFXPCIE_CFG_MAX_NUM_EP_TRIGVECTORS)
        {
            for (vectorIndex = 0; vectorIndex < intCfg->numTriggerVectors; vectorIndex++)
            {
                intVector = intCfg->triggerIntNode[vectorIndex].intVector;

                if ((intVector > IfxPcie_IntVector_none)
                    && (intVector <= IfxPcie_IntVector_remote7MsiIntD))
                {
                    IfxPcieLib_Device_initSrcNode((IfxPcie *)epHandle->pcieSFR, epHandle->index, &(intCfg->triggerIntNode[vectorIndex]));
                }
                else
                {
                    status = IfxPcie_Status_failure;
                }
            }

            IfxPcieEp_enableTriggerInt(epHandle->pcieSFR, intCfg->triggerEnableMask);       /* Set the initial mask */
            IfxPcieEp_clearTriggerInt(epHandle->pcieSFR, 0xFFFFFFFFu);                      /* Clear all Interrupts */
            epInt->numTriggerVectors = intCfg->numTriggerVectors;
            epInt->triggerEnableMask = intCfg->triggerEnableMask;
            epInt->triggerPending    = 0u;
        }
        else
        {
            status = IfxPcie_Status_failure;
        }
    }
    else
    {
        IfxPcieEp_clearTriggerInt(epHandle->pcieSFR, 0xFFFFFFFFu);              /* Clear all Interrupts */
        epInt->numTriggerVectors = 0u;
        epInt->triggerEnableMask = 0u;
        epInt->triggerPending    = 0u;
    }

    /* STEP 2: Enable / initialize the other interrupts */
    /* NOTE: DMA Interrupts are taken care separately */

    IfxPcieLib_Device_IntNodeCfg *nodeCfg        = &(intCfg->errorIntnode);
    uint8                         interruptIndex = (uint8)IfxPcie_IntVector_genError;

    while (interruptIndex < (uint8)IfxPcie_IntVector_count)
    {
        if (nodeCfg->priority > 0u)
        {
            IfxPcieLib_Device_initSrcNode((IfxPcie *)epHandle->pcieSFR, epHandle->index, nodeCfg);
        }

        nodeCfg++;
        interruptIndex++;
    }

    return status;
}


IfxPcie_Status IfxPcie_Ep_initInterruptGen(IfxPcie_Ep *epHandle)
{
    IfxPcie_Status        status      = IfxPcie_Status_success;
    IfxPcie_InterruptType intTypeTemp = IfxPcie_InterruptType_none;
    IfxPcieLib_Cap       *cap         = &(epHandle->epFunction.capabilities);
    uint8                 intNumTemp  = 0u;
    boolean               typeFound   = FALSE;

    if (cap->msix.capPtr != NULL_PTR)                                   /* MSIX Capability Exists */
    {
        if (cap->msix.capPtr->msgControl.B.msixEnable == (uint16)1)     /* MSIX is enabled */
        {
            typeFound   = TRUE;
            intTypeTemp = IfxPcie_InterruptType_msix;
            intNumTemp  = IfxPcieCap_getNumMsixInterrupt(cap->msix.capPtr, (IfxPcieCap_MsixTableEntry *)&(epHandle->pcieSFR->MSIXTABLE[0]));
        }
    }

    if (cap->msi.capPtr != NULL_PTR)                                    /* MSI Capability Exists */
    {
        if (cap->msi.capPtr->msgControl.B.msiEnable == (uint16)1)       /* MSI is enabled */
        {
            typeFound = TRUE;

            if (intTypeTemp == IfxPcie_InterruptType_none)              /* MSIx is NOT already enabled */
            {
                intTypeTemp = IfxPcie_InterruptType_msi;
                intNumTemp  = IFXPCIE_GET_NUM_MSI_INTERRUPTS(cap->msi.capPtr->msgControl.B.multiMsgEnable);
            }
            else
            {
                intTypeTemp = IfxPcie_InterruptType_none;               /* Failure : Clash */
                status      = IfxPcie_Status_failure;
            }
        }
    }

    if (typeFound == FALSE)                                             /* Use Legacy */
    {
        intTypeTemp = IfxPcie_InterruptType_legacy;
        intNumTemp  = 1u;
    }

    epHandle->interrupt.remoteIntType = intTypeTemp;
    epHandle->interrupt.numRemoteInt  = intNumTemp;

    return status;
}


IfxPcie_Status IfxPcie_Ep_generateInterrupt(IfxPcie_Ep *epHandle, uint8 interruptIndex)
{
    IfxPcie_Status status = IfxPcie_Status_failure;

    if ((epHandle->interrupt.remoteIntType == IfxPcie_InterruptType_none)
        || (epHandle->interrupt.remoteIntType == IfxPcie_InterruptType_legacy))
    {
        status = IfxPcie_Ep_initInterruptGen(epHandle);                 /* Try to get Interrupt Gen Rules Again */
    }

    if (IfxPcieDevice_isInterruptEnabled((IfxPcieDevice_CfgHdr *)epHandle->epFunction.cfgHeader) == TRUE)
    {
        switch (epHandle->interrupt.remoteIntType)
        {
        case IfxPcie_InterruptType_msi:

            if (interruptIndex < epHandle->interrupt.numRemoteInt)
            {
                IfxPcieEp_setMsiInterrupt(epHandle->pcieSFR, interruptIndex);
                status = IfxPcie_Status_success;
            }

            break;
        case IfxPcie_InterruptType_msix:

            if (interruptIndex < IFXPCIE_CFG_MAX_NUM_EP_MSIX_INTERRUPTS)
            {
                if (IfxPcieCap_isMsixVectorMasked(epHandle->epFunction.capabilities.msix.capPtr, (IfxPcieCap_MsixTableEntry *)&(epHandle->pcieSFR->MSIXTABLE[interruptIndex])) == FALSE)
                {
                    IfxPcieEp_setMsixInterrupt(epHandle->pcieSFR, interruptIndex);
                    status = IfxPcie_Status_success;
                }
            }

            break;
        case IfxPcie_InterruptType_legacy:
            IfxPcieEp_setIntxInterrupt(epHandle->pcieSFR, TRUE);
            break;
        default:
            status = IfxPcie_Status_failure;                            /* No valid interrupts */
            break;
        }
    }
    else
    {
        status = IfxPcie_Status_failure;
    }

    return status;
}


void *IfxPcie_Ep_getCapabilityPtr(IfxPcie_Ep *epHandle, uint16 capId, boolean extendedCap)
{
    IfxPcieLib_Cap *capabilitiesPtr = &(epHandle->epFunction.capabilities);
    void           *returnPtr       = NULL_PTR;

    if (extendedCap == FALSE)
    {
        switch (capId)
        {
        case IFXPCIECAP_PCI_CAP_ID_MSI:
            returnPtr = (void *)capabilitiesPtr->msi.capPtr;
            break;
        case IFXPCIECAP_PCI_CAP_ID_MSIX:
            returnPtr = (void *)capabilitiesPtr->msix.capPtr;
            break;
        case IFXPCIECAP_PCI_CAP_ID_PCIE:
            returnPtr = (void *)capabilitiesPtr->pcie.capPtr;
            break;
        case IFXPCIECAP_PCI_CAP_ID_PM:
            returnPtr = (void *)capabilitiesPtr->pmc.capPtr;
            break;
        default:
            break;
        }
    }
    else
    {
        switch (capId)
        {
        case IFXPCIECAP_EXTENDED_CAP_ID_AER:
            returnPtr = (void *)capabilitiesPtr->extendedCap.aer.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_PTM:
            returnPtr = (void *)capabilitiesPtr->extendedCap.ptm.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_LTR:
            returnPtr = (void *)capabilitiesPtr->extendedCap.ltr.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_SN:
            returnPtr = (void *)capabilitiesPtr->extendedCap.sn.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_VSEC:
            returnPtr = (void *)(capabilitiesPtr->extendedCap.vsec[0].capPtr);      /* We can't handle VSEC here - this is specific to each vendor so we return the first */
            break;
        default:
            break;
        }
    }

    return returnPtr;
}


void IfxPcie_Ep_triggerWakeup(IfxPcie_Ep *epHandle)
{
    epHandle->pcieSFR->PM.CTRL.B.WKUPCMD = 1u;
}


IfxPcie_Status IfxPcie_Ep_sendLtrMessage(IfxPcie_Ep *epHandle, IfxPcieCap_LtrMessage *ltrMessagePtr)
{
    IfxPcie_Status status = IfxPcie_Status_failure;

    if (IfxPcieCap_isLtrEnabled(epHandle->epFunction.capabilities.pcie.capPtr) == TRUE)
    {
        epHandle->pcieSFR->LTR.GNRTN.U = *((uint32 *)ltrMessagePtr);

        IfxPcie_triggerLtrMessage((IfxPcie *)epHandle->pcieSFR);
        status = IfxPcie_Status_success;
    }

    return status;
}
