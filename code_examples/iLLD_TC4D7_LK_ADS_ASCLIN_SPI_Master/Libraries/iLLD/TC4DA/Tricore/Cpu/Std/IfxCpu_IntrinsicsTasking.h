/**
 * \file IfxCpu_IntrinsicsTasking.h
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Cpu_Intrinsics_Tasking Intrinsics for TASKING compiler
 * \ingroup IfxLld_Cpu_Intrinsics
 *
 */
#ifndef IFXCPU_INTRINSICSTASKING_H
#define IFXCPU_INTRINSICSTASKING_H 1
/******************************************************************************/
#include "Ifx_Types.h"
/******************************************************************************/
/* *INDENT-OFF* */
#ifdef __CTC__

#ifndef __cplusplus
/** Function call without return
 */
#define Ifx__non_return_call(fun)   __asm("\tji %0"::"a"(fun))

/** Jump and link
 */
IFX_INLINE void Ifx__jump_and_link(void (*fun)(void))
{
    __asm("jli %0"::"a"(fun));
}

IFX_INLINE void Ifx__moveToDataParam0(unsigned int var)
{
    __asm("mov d4, %0"::"d"(var) :"d4");
}

IFX_INLINE void Ifx__moveToAddrParam0(const void *var)
{
    __asm("mov.aa a4, %0"::"a"(var) :"a4");
}

IFX_INLINE unsigned int Ifx__getDataParamRet(void)
{
    unsigned int var;
    __asm(" mov\t %0, d2":"=d"(var)::"d2");
    return var;
}

IFX_INLINE void Ifx__moveToDataParamRet(unsigned int var)
{
    __asm("mov d2, %0"::"d"(var) :"d2");
}

IFX_INLINE void Ifx__jumpToFunction(const void *fun)
{
    Ifx__non_return_call(fun);
}

IFX_INLINE void Ifx__jumpToFunctionWithLink(const void *fun)
{
    Ifx__jump_and_link((void (*)(void))fun);
}

IFX_INLINE void Ifx__jumpBackToLink(void)
{
    __asm("ji a11":::"a11");
}
#endif
/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_any_type Cross type arithmetic operation
 *
 * Macro compatible with float, fix point, signed integer and unsigned integer
 *
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#define Ifx__minX(X,Y)                     ( ((X) < (Y)) ? (X) : (Y) )
#define Ifx__maxX(X,Y)                     ( ((X) > (Y)) ? (X) : (Y) )
#define Ifx__saturateX(X,Min,Max)          ( Ifx__minX(Ifx__maxX(X, Min), Max) )
#define Ifx__checkrangeX(X,Min,Max)        (((X) >= (Min)) && ((X) <= (Max)))
/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_singed_integer Signed integer operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#define Ifx__saturate(X,Min,Max)           ( __min(__max(X, Min), Max) )
/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_unsinged_integer Unsigned integer operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#define Ifx__saturateu(X,Min,Max)           ( __minu(__maxu(X, Min), Max) )
/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_float Floating point operation
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#define Ifx__checkrange(X,Min,Max)         (((X) >= (Min)) && ((X) <= (Max)))

#define Ifx__sqrf(X)                       ((X) * (X))
#define Ifx__sqrtf(X)                      sqrtf(X)

#define Ifx__roundf(X)                     ((((X) - (int)(X)) > 0.5f) ? (1 + (int)(X)) : ((int)(X)))
#define Ifx__absf(X)                       ( ((X) < 0.0f) ? -(X) : (X) )
#define Ifx__abs(a)                        __abs(a)
#define Ifx__minf(X,Y)                     ( ((X) < (Y)) ? (X) : (Y) )
#define Ifx__maxf(X,Y)                     ( ((X) > (Y)) ? (X) : (Y) )
#define Ifx__saturatef(X,Min,Max)          ( Ifx__minf(Ifx__maxf(X, Min), Max) )
#define Ifx__checkrangef(X,Min,Max)        (((X) >= (Min)) && ((X) <= (Max)))

#define Ifx__abs_stdreal(X)                ( ((X) > 0.0f) ? (X) : -(X) )
#define Ifx__min_stdreal(X,Y)              ( ((X) < (Y)) ? (X) : (Y) )
#define Ifx__max_stdreal(X,Y)              ( ((X) > (Y)) ? (X) : (Y) )
#define Ifx__saturate_stdreal(X,Min,Max)   ( Ifx__min_stdreal(Ifx__max_stdreal(X, Min), Max) )

#define Ifx__neqf(X,Y)                     ( ((X) > (Y)) ||  ((X) < (Y)) )     /**< X != Y */
#define Ifx__leqf(X,Y)                     ( !((X) > (Y)) )     /**< X <= Y */
#define Ifx__geqf(X,Y)                     ( !((X) < (Y)) )     /**< X >= Y */
/** \} */
/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_fractional Fractional Arithmetic Support
 The next table provides an overview of intrinsic functions to convert fractional values. Note that the
 TASKING VX-toolset C compiler for TriCore fully supports the fractional type so normally you should not
 need these intrinsic functions (except for __mulfractlong). For compatibility reasons the TASKING C
 compiler does support these functions.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#define Ifx__fract_to_float(value)  ((float)(value))

#define Ifx__mulfractlong __mulfractlong

#define Ifx__mulfractfract(fractvalue1,fractvalue2)  ((fractvalue1)*(fractvalue2))

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_insert Insert / Extract Bit-fields and Bits
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

#define Ifx__extru(a, p, w)            __extru(a,p,w)

#define Ifx__extr(a, p, w)             __extr(a,p,w)

#define Ifx__imaskldmst(a, v, b, p)    __imaskldmst((int*)a, v, b, p)

#define Ifx__insert(a,b,p,w)           __insert(a,b,p,w)

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_interrupt_handling Interrupt Handling
 The next table provides an overview of the intrinsic functions to read or set interrupt handling.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#define Ifx__disable_and_save __disable_and_save

#define Ifx__restore __restore

#define Ifx__cacheiwi __cacheiwi


#if defined(__CORE_TC18__)
#define Ifx__hvcall(hvcno) __hvcall(hvcno)
#define Ifx__rfh() __asm("rfh " : : : "memory")
#else
#define Ifx__hvcall(hvcno) \
switch (hvcno) \
{ \
case 1: \
{__asm volatile (".word 0x004010AD");}\
break; \
case 2: \
{__asm volatile (".word 0x004020AD");}\
break; \
case 3: \
{__asm volatile (".word 0x004030AD");}\
break; \
case 4: \
{__asm volatile (".word 0x004040AD");}\
break; \
case 5: \
{__asm volatile (".word 0x004050AD");}\
break; \
case 6: \
{__asm volatile (".word 0x004060AD");}\
break; \
case 7: \
{__asm volatile (".word 0x004070AD");}\
break; \
}
#define Ifx__rfh() \
__asm volatile (".word 0x05C0000D");
#endif
/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_miscellaneous Miscellaneous Intrinsic Functions
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#ifndef __cplusplus
/**  Return saturated byte
 */
IFX_INLINE sint8 Ifx__satb(sint32 a)
{
    sint8 res;
    __asm__ volatile ("sat.b %0,%1":"=d"(res):"d"(a));
    return res;
}

/**  Return saturated uint8
 */
IFX_INLINE uint8 Ifx__satbu(uint32 a)
{
    uint8 res;
    __asm__ volatile ("sat.bu %0,%1":"=d"(res):"d"(a));
    return res;
}

/**  Return saturated halfword
 */
IFX_INLINE sint16 Ifx__sath(sint32 a)
{
    sint16 res;
    __asm__ volatile ("sat.h %0,%1":"=d"(res):"d"(a));
    return res;
}

/**  Return saturated unsigned halfword
 */
IFX_INLINE uint16 Ifx__sathu(uint32 a)
{
    uint16 res;
    __asm__ volatile ("sat.hu %0,%1":"=d"(res):"d"(a));
    return res;
}
#endif
IFX_INLINE void Ifx__dsync(void)
{
    __dsync();
}

IFX_INLINE void Ifx__isync(void)
{
    __isync();
}

#define  Ifx__cmpAndSwap(address,value,condition) \
     __cmpswapw((address), ((unsigned long)value), (condition) )

#define Ifx__NOP(n)   __asm(".DUP " #n "\n\tnop16\n\t.ENDM\n")

/** \brief Convert a fixpoint value to float32
 *
 * This function converts a value from a fixpoint format to a float32 format.
 *
 *
 * \param value value to be converted.
 * \param shift position of the fix point. Range = [-256, 255] => (Qx.y format where x = shift+1).
 *
 * \return Returns the converted value in the float32 format.
 *
 */
#define Ifx__fract_to_sfract __round16

 #ifndef __cplusplus
IFX_INLINE float32 Ifx__fixpoint_to_float32(fract value, sint32 shift)
{
    float32 result;

    __asm(
        "   q31tof\t%0, %1, %2  \n"
        : "=d" (result)
        : "d" (value), "d" (shift));
    return result;
}

/** Convert float to fract
 */
IFX_INLINE fract Ifx__float_to_fract(float a)
{
    fract res;
    __asm("ftoq31  %0,%1,%2":"=d"(res):"d"(a), "d"(0):"memory");
    return res;
}

/** Convert float to sfract
 */
IFX_INLINE sfract Ifx__float_to_sfract(float a)
{
    fract tmp = Ifx__float_to_fract(a);
    return Ifx__fract_to_sfract(tmp);
}
#endif

/** Function to copy 128 bit data from source to destination
 * Addresses must be 128 bit aligned.
 */
#ifndef __cplusplus
IFX_INLINE void Ifx__copyDoubleDouble(volatile uint32 *src, volatile uint32 *dst)
{
    __asm ("\t ld.dd e0/e2, [%0] \n"
           "\t st.dd [%1], e0/e2 \n"
           ::"a" (src), "a" (dst): "e0", "e2");
}
#else
IFX_INLINE void Ifx__copyDoubleDouble(volatile uint32 *src, volatile uint32 *dst)
{
    volatile uint64 *src64 = (volatile uint64 *)src;
    volatile uint64 *dst64 = (volatile uint64 *)dst;

    *dst64 = *src64;
    *(dst64 + 1) = *(src64 + 1);
}
#endif
/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_packed Packed Data Type Support
 The next table provides an overview of the intrinsic functions for initialization of packed data type.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** \} */

#ifndef __cplusplus
/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_register Register Handling
 The next table provides an overview of the intrinsic functions that you can use to access control registers.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */
#define Ifx__mtcr_no_isync(reg, val)   \
    __asm("mtcr %0,%1"::"i"(reg),"d"(val));

/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_saturation Saturation Arithmetic Support
 These intrinsics support saturation arithmetic
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

/** add signed with saturation
 */
IFX_INLINE sint32 Ifx__adds(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("adds %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
    return res;
}

/** add unsigned with saturation
 */
IFX_INLINE uint32 Ifx__addsu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("adds.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
    return res;
}

/** substract signed with saturation
 */
IFX_INLINE sint32 Ifx__subs(sint32 a, sint32 b)
{
    sint32 res;
    __asm__ volatile ("subs %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
    return res;
}

/** substract unsigned with saturation
 */
IFX_INLINE uint32 Ifx__subsu(uint32 a, uint32 b)
{
    uint32 res;
    __asm__ volatile ("subs.u %0, %1, %2": "=d" (res) : "d" (a), "d" (b));
    return res;
}


/** \} */

/** \defgroup IfxLld_Cpu_Intrinsics_Tasking_single_assembly Insert Single Assembly Instruction
 The next table provides an overview of the intrinsic functions that you can use to insert a single assembly
 instruction.You can also use inline assembly but these intrinsics provide a shorthand for frequently used
 assembly instructions.
 * \ingroup IfxLld_Cpu_Intrinsics_Tasking
 * \{
 */

IFX_INLINE void Ifx__nops(void* cnt)
{
    __asm("nop16 \n\t"
          "loop %0,*-2"
          ::"a"(((char*)cnt) - 1));
}
/** Insert a memory barrier
 */
#define Ifx__mem_barrier __asm("":::"memory");

#if CPU_NO_LDMST
IFX_INLINE void Ifx__ldmstC(volatile void *addr, uint32 mask, uint32 data)
{
    *(volatile uint32 *)addr = (*(volatile uint32 *)addr & ~mask) | (mask & data);
}

#define Ifx__ldmst(a,b,c) Ifx__ldmstC(a,b,c)
#else

IFX_INLINE void Ifx__ldmstAsm(volatile void *addr, uint32 mask, uint32 data)
{
    __asm("\tmov d3, %1 \n"
          "\tmov d2, %2 \n"
          "\tldmst [%0],e2"
          ::"a"(addr), "d"(mask), "d"(data):"d2", "d3");

}

#define Ifx__ldmst(addr, mask, data) Ifx__ldmstAsm(addr, mask, data)
#endif

IFX_INLINE void Ifx__stopPerfCounters(void)
{ //__mtcr (CPU_CCTRL, 0);
    __asm(
            "    mov d0,#0\n"
            "    mtcr #0xFC00,d0\n"
            "    isync\n"
            :::"d0");
}

/** \} */

/* FIXME use inline instead of #define */
/* FIXME is it really required to have #define __setareg(areg,val) ___setareg(areg,val) or can __setareg() implemented directly */
#define Ifx___setareg(areg,val) \
    { __asm (" movh.a\t "#areg",#@his("#val")\n lea\t "#areg",["#areg"]@los("#val")"); }
#define Ifx__setareg(areg,val) Ifx___setareg(areg,val)

/** \brief This function is a implementation of a binary semaphore using compare and swap instruction
 * \param address address of resource.
 * \param value This variable is updated with status of address
 * \param condition if the value of address matches with the value of condition, then swap of value & address occurs.
 *
 */


IFX_INLINE void* Ifx__getA11(void)
{
    unsigned int *res;
    __asm("mov.aa %0, a11": "=a" (res) : :"a11");
    return res;
}

IFX_INLINE void Ifx__setStackPointer(void *stackAddr)
{
    __asm("mov.aa a10, %0": : "a" (stackAddr) :"a10");
}

IFX_INLINE uint32 IfxCpu_calculateCrc32(uint32 *startaddress, uint8 length)
{
    uint32 returnvalue = 0u;
    __asm("MOV d0, #0x0" : : : "d0"); /* set seed value to 0 */
    for (;length > 0; length--)
    {
        /*calculate the CRC over all data */
        __asm("MOV d1,%0" : : "d" (*startaddress) : "d0","d1");
        __asm__ volatile("CRC32B.W d0,d0,d1");
        startaddress++;
    }
    __asm("MOV %0,d0" : "=d" (returnvalue)); /* return result of CRC*/
    return returnvalue;
}


/** \brief Function calculates a user defined CRC
 *
 * Bit31    15      12         10       9        8                2         Bit0
 *  ---------------------------------------------------------------------------
 * |        |        |         |        |        |                |    input   |
 * | poly-  | CRC    |    0    | inver  | bit    |        0       |    data    |
 * | nomial | width  |         | sion   | order  |                |    width   |
 * |        | (1-16) |         |        |        |                |    (1-8)   |
 *  ---------------------------------------------------------------------------
 *
 * \param startaddress value to be converted.
 * \param seedValue Seed value for CRC.
 * \param length length of data.
 * \param value Parameters of CRC algorithm.
 * \return Returns the calculated CRC value.
 *
 */
IFX_INLINE uint16 Ifx__calculateCrcN(uint8 *startaddress, uint16 seedValue, uint8 length, uint32 value)
{
    uint16 returnvalue = 0u;
     __asm("MOV d0,%0" : : "d"(seedValue) : "d0"); /* set seed value */
    for (;length > 0; length--)
    {
        /*calculate the CRC over all data */
        __asm("MOV d1,%0" : : "d" (value) : "d1");
        __asm("MOV d2,%0" : : "d" (*startaddress) : "d2");
        __asm__ volatile("crcn d0,d0,d1,d2");
        startaddress++;
    }
    __asm("MOV %0,d0" : "=d"(returnvalue)); /* return result of CRC*/
    return returnvalue;
}


IFX_INLINE uint32 IfxCpu_getRandomVal(uint32 a, uint32 x, uint32 m)
{
    uint32 result;
    __asm("      mul.u     e14,%1,%2      ; d15 = Eh; d14 = El    \n"
        "        mov       d12,d14        ;   e12 = El            \n"
        "        mov       d13,#0         ;                       \n"
        "        madd.u    e14,e12,d15,#5 ; e14 = El + 5 * d15    \n"
        " 1:     jge.u     d14,%3,2n      ;                       \n"
        "        jz        d15,3n         ;                       \n"
        " 2:     subx      d14,d14,%3     ;  e12=e12-m            \n"
        "        subc      d15,d15,d13    ; d13=d13-0             \n"
        "        loopu     1p             ;                       \n"
        " 3:     mov       %0,d14         ;                       \n"
        : "=d"(result) : "d"(a), "d"(x), "d"(m) : "e14","e12");
    return result;
}

IFX_INLINE sint32 Ifx__popcnt(sint32 a)
{
    sint32 res;
    __asm("popcnt.w %0,%1":"=d"(res):"d"(a));
        return res;
}

#else

IFX_INLINE void Ifx__ldmstC(volatile void *addr, uint32 mask, uint32 data)
{
    *(volatile uint32 *)addr = (*(volatile uint32 *)addr & ~mask) | (mask & data);
}
#define Ifx__ldmst(a,b,c) Ifx__ldmstC((volatile void *)a,b,c)

#endif

/* Macros for backward compatibility of the intrinsics*/
/******************************************************************************/
#ifndef IFX_CFG_DISABLE_DEFAULT_INTRINSICS
#ifndef __non_return_call
#define __non_return_call Ifx__non_return_call
#endif

#ifndef __jump_and_link
#define __jump_and_link Ifx__jump_and_link
#endif

#ifndef __moveToDataParam0
#define __moveToDataParam0 Ifx__moveToDataParam0
#endif

#ifndef __moveToAddrParam0
#define __moveToAddrParam0 Ifx__moveToAddrParam0
#endif

#ifndef __getDataParamRet
#define __getDataParamRet Ifx__getDataParamRet
#endif

#ifndef __moveToDataParamRet
#define __moveToDataParamRet Ifx__moveToDataParamRet
#endif

#ifndef __jumpToFunction
#define __jumpToFunction Ifx__jumpToFunction
#endif

#ifndef __jumpToFunctionWithLink
#define __jumpToFunctionWithLink Ifx__jumpToFunctionWithLink
#endif

#ifndef __jumpBackToLink
#define __jumpBackToLink Ifx__jumpBackToLink
#endif

#ifndef __minX
#define __minX Ifx__minX
#endif

#ifndef __maxX
#define __maxX Ifx__maxX
#endif

#ifndef __saturateX
#define __saturateX Ifx__saturateX
#endif

#ifndef __checkrangeX
#define __checkrangeX Ifx__checkrangeX
#endif

#ifndef __saturate
#define __saturate Ifx__saturate
#endif

#ifndef __saturateu
#define __saturateu Ifx__saturateu
#endif

#ifndef __checkrange
#define __checkrange Ifx__checkrange
#endif

#ifndef __sqrtf
#define __sqrtf Ifx__sqrtf
#endif

#ifndef __sqrf
#define __sqrf Ifx__sqrf
#endif

#ifndef __roundf
#define __roundf Ifx__roundf
#endif

#ifndef __absf
#define __absf Ifx__absf
#endif

#ifndef __maxf
#define __maxf Ifx__maxf
#endif

#ifndef __saturatef
#define __saturatef Ifx__saturatef
#endif

#ifndef __minf
#define __minf Ifx__minf
#endif

#ifndef __checkrangef
#define __checkrangef Ifx__checkrangef
#endif

#ifndef __abs_stdreal
#define __abs_stdreal Ifx__abs_stdreal
#endif

#ifndef __saturate_stdreal
#define __saturate_stdreal Ifx__saturate_stdreal
#endif

#ifndef __min_stdreal
#define __min_stdreal Ifx__min_stdreal
#endif

#ifndef __max_stdreal
#define __max_stdreal Ifx__max_stdreal
#endif

#ifndef __neqf
#define __neqf Ifx__neqf
#endif

#ifndef __leqf
#define __leqf Ifx__leqf
#endif

#ifndef __geqf
#define __geqf Ifx__geqf
#endif

#ifndef __fract_to_float
#define __fract_to_float Ifx__fract_to_float
#endif

#ifndef __mulfractlong
#define __mulfractlong Ifx__mulfractlong
#endif

#ifndef __mulfractfract
#define __mulfractfract Ifx__mulfractfract
#endif

#ifndef __disable_and_save
#define __disable_and_save Ifx__disable_and_save
#endif

#ifndef __restore
#define __restore Ifx__restore
#endif

#ifndef __mtcr_no_isync
#define __mtcr_no_isync Ifx__mtcr_no_isync
#endif

#ifndef __satb
#define __satb Ifx__satb
#endif

#ifndef __satbu
#define __satbu Ifx__satbu
#endif

#ifndef __sath
#define __sath Ifx__sath
#endif

#ifndef __sathu
#define __sathu Ifx__sathu
#endif

#ifndef __adds
#define __adds Ifx__adds
#endif

#ifndef __addsu
#define __addsu Ifx__addsu
#endif

#ifndef __subs
#define __subs Ifx__subs
#endif

#ifndef __subsu
#define __subsu Ifx__subsu
#endif

#ifndef __nops
#define __nops Ifx__nops
#endif

#if ((!defined(NOP)) && (!defined(IFX_CFG_DISABLE_DEFAULT_INTRINSICS)))
#define NOP Ifx__NOP
#endif

#ifndef __mem_barrier
#define __mem_barrier Ifx__mem_barrier
#endif

#ifndef __ldmst
#define __ldmst Ifx__ldmst
#endif

#ifndef __ldmstC
#define __ldmstC Ifx__ldmstC
#endif

#ifndef __float_to_sfract
#define __float_to_sfract Ifx__float_to_sfract
#endif

#ifndef __float_to_fract
#define __float_to_fract Ifx__float_to_fract
#endif

#ifndef __fract_to_sfract
#define __fract_to_sfract Ifx__fract_to_sfract
#endif

#ifndef __ldmstAsm
#define __ldmstAsm Ifx__ldmstAsm
#endif

#ifndef __stopPerfCounters
#ifndef __cplusplus
#define __stopPerfCounters Ifx__stopPerfCounters
#else
#define __stopPerfCounters IfxCpu_stopPerfCounters
#endif
#endif

#ifndef __setareg
#define __setareg Ifx__setareg
#endif

#ifndef ___setareg
#define ___setareg Ifx___setareg
#endif

#ifndef __cmpAndSwap
#define __cmpAndSwap Ifx__cmpAndSwap
#endif

#ifndef __fixpoint_to_float32
#define __fixpoint_to_float32 Ifx__fixpoint_to_float32
#endif

#ifndef __getA11
#define __getA11 Ifx__getA11
#endif

#ifndef __setStackPointer
#define __setStackPointer Ifx__setStackPointer
#endif

#ifndef __popcnt
#define __popcnt Ifx__popcnt
#endif

#ifndef __dsync
#define __dsync Ifx__dsync
#endif

#ifndef __isync
#define __isync Ifx__isync
#endif

#endif

#endif

#ifdef __CARC__

IFX_INLINE void Ifx__imaskldmst(volatile void *address, uint32 value, uint32 bitoffset, uint32 bits)
{
	uint32 mask = (((1u << bits) - 1u) << bitoffset);
	uint32 shiftValue = (value << bitoffset);
	*(volatile uint32 *)address = (*(volatile uint32 *)address & ~(mask)) | (mask & shiftValue);
}

IFX_INLINE void Ifx__ldmstC(volatile void *addr, uint32 mask, uint32 data)
{
    *(volatile uint32 *)addr = (*(volatile uint32 *)addr & ~mask) | (mask & data);
}

#define Ifx__ldmst(a,b,c) Ifx__ldmstC(a,b,c)

IFX_INLINE uint32 __clz(sint32 x)
{
	uint32 n = 0;
    uint32 bits = sizeof(x) * 8;
    for (int i = 1; i < bits; i ++) {
        if (x < 0) break;
        n ++;
        x <<= 1;
    }
    return n;
}


#define __minu(X,Y)                     ( ((X) < (Y)) ? (X) : (Y) )
#define __maxu(X,Y)                     ( ((X) > (Y)) ? (X) : (Y) )
#define __absf(X)                       ( ((X) < 0.0f) ? -(X) : (X) )
#define __min(X,Y)                      ( ((X) < (Y)) ? (X) : (Y) )
#define __max(X,Y)                      ( ((X) > (Y)) ? (X) : (Y) )

#define Ifx__abs(X)                       ( ((X) < 0) ? -(X) : (X) )

#define Ifx__roundf(X)                     ((((X) - (int)(X)) > 0.5f) ? (1 + (int)(X)) : ((int)(X)))
#define __roundf(a) Ifx__roundf(a)

#endif
/******************************************************************************/
/* *INDENT-ON* */
/******************************************************************************/
#endif /* IFXCPU_INTRINSICSTASKING_H */
