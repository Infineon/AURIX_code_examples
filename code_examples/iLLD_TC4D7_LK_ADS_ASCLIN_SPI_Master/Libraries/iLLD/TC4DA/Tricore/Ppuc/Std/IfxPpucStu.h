/**
 * \file IfxPpucStu.h
 * \brief PPUC  basic functionality
 * \ingroup IfxLld_Ppuc
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * Streaming transfer unit
 *
 * \defgroup IfxLld_Ppuc_Usage How to use the Ppuc driver?
 * \ingroup IfxLld_Ppuc
 *
 * The Ppuc driver provides a default configuration for data moves
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_Ppuc_Preparation Preparation
 * \subsection IfxLld_Ppuc_Include Include Files
 *
 * Include following header file into your C code:
 *
 * \code
 *      #include <Ppuc/Std/IfxPpucStu.h>
 *      #define IFXPPUCSTU_TRANSFER_SIZE_BYTES	128U
 *      #define LMU_START	0x30000000U
 *      #define CSM_START	0xA0000000U
 * \endcode
 *
 *
 * \subsection IfxLld_Ppuc_STU	STU initialization
 *
 * Initialize the number of entries in FIFO with following code:
 * \code
 *  // Configure the number of entries in FIFO
 *  IfxPpucStu_setMaxChannels(&MODULE_PPUC,16U);
 * \endcode
 *
 * The above has to be only done once in the application.
 *
 * \subsection IfxLld_Ppuc_Simple LMU-to-CSM Transfers
 *
 * Channel configuration and handling for the data move:
 * \code
 *      // construct the channel configuration
 *      uint8 channelNum = 0U;
 *      IfxPpucStu_channelConfig chnCfg;
 *      IfxPpucStu_initChannelConfig(&chnCfg);
 *
 *      // Get the next free channel which should be used
 *      channelNum = IfxPpucStu_getNextFreeChannel(&MODULE_PPUC);
 *
 *      // source and destination address
 *      chnCfg.sourceAddress       = (uint32)LMU_START; // Provide src address
 *      chnCfg.destinationAddress  = (uint32)CSM_START; // Provide dst address
 *
 *      // Configure the transfer size
 *      chnCfg.transferSize		   =  IFXPPUCSTU_TRANSFER_SIZE_BYTES;
 *
 *      // Configure the start of descriptor area
 *      IfxPpucStu_setDescriptorBaseAddress(&MODULE_PPUC, CSM_START + IFXPPUCSTU_TRANSFER_SIZE_BYTES);
 *
 *
 *      // transfer configuration into STU registers
 *      IfxPpucStu_initChannel(&MODULE_PPUC, channelNum, (CSM_START + IFXPPUCSTU_TRANSFER_SIZE_BYTES), &chnCfg);
 *
 *      // start transfer and wait until it's finished
 *      IfxPpucStu_startTransfer(&MODULE_PPUC,1U);
 *
 *      while(IfxPpucStu_getChannelEvent(&MODULE_PPUC, channelNum) != 1U)
 *      {
 *
 *      }
 *
 *      // Clear the event flag
 *      IfxPpucStu_clearAllEvents(&MODULE_PPUC);
 *
 * \endcode
 *
 * \defgroup IfxLld_Ppuc_Std_Stu Stu Basic Functionality
 * \ingroup IfxLld_Ppuc_Std
 * \defgroup IfxLld_Ppuc_Std_Stu_Enum Stu_Enums
 * \ingroup IfxLld_Ppuc_Std_Stu
 * \defgroup IfxLld_Ppuc_Std_Stu_Stu Stu_Functions
 * \ingroup IfxLld_Ppuc_Std_Stu
 * \defgroup IfxLld_Ppuc_Std_Stu_Struct Stu_Struct
 * \ingroup IfxLld_Ppuc_Std_Stu
 */

#ifndef IFXPPUCSTU_H
#define IFXPPUCSTU_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxPpuc_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "IfxPpu_reg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Source memory type offset
 */
#define IFXPPUCSTU_SRC_MEMTYPE_OFFSET   (0U)

/** \brief Destination memory type offset
 */
#define IFXPPUCSTU_DST_MEMTYPE_OFFSET   (12U)

/** \brief Source LandeID offset
 */
#define IFXPPUCSTU_SRC_LANDEID_OFFSET   (4U)

/** \brief Destination LandeID offset
 */
#define IFXPPUCSTU_DST_LANDEID_OFFSET   (16U)

/** \brief Source Lane Width offset
 */
#define IFXPPUCSTU_SRC_LANEWIDTH_OFFSET (1U)

/** \brief Destination Lane Width offset
 */
#define IFXPPUCSTU_DST_LANEWIDTH_OFFSET (13U)

/** \brief Addressing mode offset
 */
#define IFXPPUCSTU_ADDR_MODE_OFFSET     (25U)

/** \brief Signal type offset
 */
#define IFXPPUCSTU_SIGNALTYPE_OFFSET    (24U)

/** \brief Get the VCCM local address, Since the STU sees it at 0xC0000000
 */
#define IFXPPUCSTU_VCCM_LOCAL_ADDRESS(x) ((uint32)((x & 0x0FFFFFFFU) | 0xC0000000U))

/** \brief Dst bitfield offset in width and stride registers
 */
#define IFXPPUCSTU_DSTWIDTH_OFFSET      (16U)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Ppuc_Std_Stu_Enum
 * \{ */
/** \brief Addressing mode of the transfer
 */
typedef enum
{
    IfxPpucStu_AddressingMode_linear = 0,  /**< \brief linear addressing mode for source/destination */
    IfxPpucStu_AddressingMode_block  = 1   /**< \brief block addressing mode for source/destination */
} IfxPpucStu_AddressingMode;

/** \brief Specifies the data width of lane
 */
typedef enum
{
    IfxPpucStu_LandeWidth_16 = 0,  /**< \brief 16 bits per lane */
    IfxPpucStu_LandeWidth_32 = 1   /**< \brief 32 bits per lane */
} IfxPpucStu_LandeWidth;

/** \brief The lane ID for private vector memory
 */
typedef enum
{
    IfxPpucStu_LaneId_0 = 0,      /**< \brief IfxPpucStu_LaneId0  */
    IfxPpucStu_LaneId_1,          /**< \brief IfxPpucStu_LaneId1  */
    IfxPpucStu_LaneId_2,          /**< \brief IfxPpucStu_LaneId2  */
    IfxPpucStu_LaneId_3,          /**< \brief IfxPpucStu_LaneId3  */
    IfxPpucStu_LaneId_4,          /**< \brief IfxPpucStu_LaneId4  */
    IfxPpucStu_LaneId_5,          /**< \brief IfxPpucStu_LaneId5  */
    IfxPpucStu_LaneId_6,          /**< \brief IfxPpucStu_LaneId6  */
    IfxPpucStu_LaneId_7,          /**< \brief IfxPpucStu_LaneId7  */
    IfxPpucStu_LaneId_8,          /**< \brief IfxPpucStu_LaneId8  */
    IfxPpucStu_LaneId_9,          /**< \brief IfxPpucStu_LaneId9  */
    IfxPpucStu_LaneId_10,         /**< \brief IfxPpucStu_LaneId10  */
    IfxPpucStu_LaneId_11,         /**< \brief IfxPpucStu_LaneId11  */
    IfxPpucStu_LaneId_12,         /**< \brief IfxPpucStu_LaneId12  */
    IfxPpucStu_LaneId_13,         /**< \brief IfxPpucStu_LaneId13  */
    IfxPpucStu_LaneId_14,         /**< \brief IfxPpucStu_LaneId14  */
    IfxPpucStu_LaneId_15,         /**< \brief IfxPpucStu_LaneId15  */
    IfxPpucStu_LaneId_16,         /**< \brief IfxPpucStu_LaneId16  */
    IfxPpucStu_LaneId_17,         /**< \brief IfxPpucStu_LaneId17  */
    IfxPpucStu_LaneId_18,         /**< \brief IfxPpucStu_LaneId18  */
    IfxPpucStu_LaneId_19,         /**< \brief IfxPpucStu_LaneId19  */
    IfxPpucStu_LaneId_20,         /**< \brief IfxPpucStu_LaneId20  */
    IfxPpucStu_LaneId_21,         /**< \brief IfxPpucStu_LaneId21  */
    IfxPpucStu_LaneId_22,         /**< \brief IfxPpucStu_LaneId22  */
    IfxPpucStu_LaneId_23,         /**< \brief IfxPpucStu_LaneId23  */
    IfxPpucStu_LaneId_24,         /**< \brief IfxPpucStu_LaneId24  */
    IfxPpucStu_LaneId_25,         /**< \brief IfxPpucStu_LaneId25  */
    IfxPpucStu_LaneId_26,         /**< \brief IfxPpucStu_LaneId26  */
    IfxPpucStu_LaneId_27,         /**< \brief IfxPpucStu_LaneId27  */
    IfxPpucStu_LaneId_28,         /**< \brief IfxPpucStu_LaneId28  */
    IfxPpucStu_LaneId_29,         /**< \brief IfxPpucStu_LaneId29  */
    IfxPpucStu_LaneId_30,         /**< \brief IfxPpucStu_LaneId30  */
    IfxPpucStu_LaneId_31,         /**< \brief IfxPpucStu_LaneId31  */
    IfxPpucStu_LaneId_32,         /**< \brief IfxPpucStu_LaneId32  */
    IfxPpucStu_LaneId_33,         /**< \brief IfxPpucStu_LaneId33  */
    IfxPpucStu_LaneId_34,         /**< \brief IfxPpucStu_LaneId34  */
    IfxPpucStu_LaneId_35,         /**< \brief IfxPpucStu_LaneId35  */
    IfxPpucStu_LaneId_36,         /**< \brief IfxPpucStu_LaneId36  */
    IfxPpucStu_LaneId_37,         /**< \brief IfxPpucStu_LaneId37  */
    IfxPpucStu_LaneId_38,         /**< \brief IfxPpucStu_LaneId38  */
    IfxPpucStu_LaneId_39,         /**< \brief IfxPpucStu_LaneId39  */
    IfxPpucStu_LaneId_40,         /**< \brief IfxPpucStu_LaneId40  */
    IfxPpucStu_LaneId_41,         /**< \brief IfxPpucStu_LaneId41  */
    IfxPpucStu_LaneId_42,         /**< \brief IfxPpucStu_LaneId42  */
    IfxPpucStu_LaneId_43,         /**< \brief IfxPpucStu_LaneId43  */
    IfxPpucStu_LaneId_44,         /**< \brief IfxPpucStu_LaneId44  */
    IfxPpucStu_LaneId_45,         /**< \brief IfxPpucStu_LaneId45  */
    IfxPpucStu_LaneId_46,         /**< \brief IfxPpucStu_LaneId46  */
    IfxPpucStu_LaneId_47,         /**< \brief IfxPpucStu_LaneId47  */
    IfxPpucStu_LaneId_48,         /**< \brief IfxPpucStu_LaneId48  */
    IfxPpucStu_LaneId_49,         /**< \brief IfxPpucStu_LaneId49  */
    IfxPpucStu_LaneId_50,         /**< \brief IfxPpucStu_LaneId50  */
    IfxPpucStu_LaneId_51,         /**< \brief IfxPpucStu_LaneId51  */
    IfxPpucStu_LaneId_52,         /**< \brief IfxPpucStu_LaneId52  */
    IfxPpucStu_LaneId_53,         /**< \brief IfxPpucStu_LaneId53  */
    IfxPpucStu_LaneId_54,         /**< \brief IfxPpucStu_LaneId54  */
    IfxPpucStu_LaneId_55,         /**< \brief IfxPpucStu_LaneId55  */
    IfxPpucStu_LaneId_56,         /**< \brief IfxPpucStu_LaneId56  */
    IfxPpucStu_LaneId_57,         /**< \brief IfxPpucStu_LaneId57  */
    IfxPpucStu_LaneId_58,         /**< \brief IfxPpucStu_LaneId58  */
    IfxPpucStu_LaneId_59,         /**< \brief IfxPpucStu_LaneId59  */
    IfxPpucStu_LaneId_60,         /**< \brief IfxPpucStu_LaneId60  */
    IfxPpucStu_LaneId_61,         /**< \brief IfxPpucStu_LaneId61  */
    IfxPpucStu_LaneId_62,         /**< \brief IfxPpucStu_LaneId62  */
    IfxPpucStu_LaneId_63,         /**< \brief IfxPpucStu_LaneId63  */
    IfxPpucStu_LaneId_64,         /**< \brief IfxPpucStu_LaneId64  */
    IfxPpucStu_LaneId_65,         /**< \brief IfxPpucStu_LaneId65  */
    IfxPpucStu_LaneId_66,         /**< \brief IfxPpucStu_LaneId66  */
    IfxPpucStu_LaneId_67,         /**< \brief IfxPpucStu_LaneId67  */
    IfxPpucStu_LaneId_68,         /**< \brief IfxPpucStu_LaneId68  */
    IfxPpucStu_LaneId_69,         /**< \brief IfxPpucStu_LaneId69  */
    IfxPpucStu_LaneId_70,         /**< \brief IfxPpucStu_LaneId70  */
    IfxPpucStu_LaneId_71,         /**< \brief IfxPpucStu_LaneId71  */
    IfxPpucStu_LaneId_72,         /**< \brief IfxPpucStu_LaneId72  */
    IfxPpucStu_LaneId_73,         /**< \brief IfxPpucStu_LaneId73  */
    IfxPpucStu_LaneId_74,         /**< \brief IfxPpucStu_LaneId74  */
    IfxPpucStu_LaneId_75,         /**< \brief IfxPpucStu_LaneId75  */
    IfxPpucStu_LaneId_76,         /**< \brief IfxPpucStu_LaneId76  */
    IfxPpucStu_LaneId_77,         /**< \brief IfxPpucStu_LaneId77  */
    IfxPpucStu_LaneId_78,         /**< \brief IfxPpucStu_LaneId78  */
    IfxPpucStu_LaneId_79,         /**< \brief IfxPpucStu_LaneId79  */
    IfxPpucStu_LaneId_80,         /**< \brief IfxPpucStu_LaneId80  */
    IfxPpucStu_LaneId_81,         /**< \brief IfxPpucStu_LaneId81  */
    IfxPpucStu_LaneId_82,         /**< \brief IfxPpucStu_LaneId82  */
    IfxPpucStu_LaneId_83,         /**< \brief IfxPpucStu_LaneId83  */
    IfxPpucStu_LaneId_84,         /**< \brief IfxPpucStu_LaneId84  */
    IfxPpucStu_LaneId_85,         /**< \brief IfxPpucStu_LaneId85  */
    IfxPpucStu_LaneId_86,         /**< \brief IfxPpucStu_LaneId86  */
    IfxPpucStu_LaneId_87,         /**< \brief IfxPpucStu_LaneId87  */
    IfxPpucStu_LaneId_88,         /**< \brief IfxPpucStu_LaneId88  */
    IfxPpucStu_LaneId_89,         /**< \brief IfxPpucStu_LaneId89  */
    IfxPpucStu_LaneId_90,         /**< \brief IfxPpucStu_LaneId90  */
    IfxPpucStu_LaneId_91,         /**< \brief IfxPpucStu_LaneId91  */
    IfxPpucStu_LaneId_92,         /**< \brief IfxPpucStu_LaneId92  */
    IfxPpucStu_LaneId_93,         /**< \brief IfxPpucStu_LaneId93  */
    IfxPpucStu_LaneId_94,         /**< \brief IfxPpucStu_LaneId94  */
    IfxPpucStu_LaneId_95,         /**< \brief IfxPpucStu_LaneId95  */
    IfxPpucStu_LaneId_96,         /**< \brief IfxPpucStu_LaneId96  */
    IfxPpucStu_LaneId_97,         /**< \brief IfxPpucStu_LaneId97  */
    IfxPpucStu_LaneId_98,         /**< \brief IfxPpucStu_LaneId98  */
    IfxPpucStu_LaneId_99,         /**< \brief IfxPpucStu_LaneId99  */
    IfxPpucStu_LaneId_100,        /**< \brief IfxPpucStu_LaneId100  */
    IfxPpucStu_LaneId_101,        /**< \brief IfxPpucStu_LaneId101  */
    IfxPpucStu_LaneId_102,        /**< \brief IfxPpucStu_LaneId102  */
    IfxPpucStu_LaneId_103,        /**< \brief IfxPpucStu_LaneId103  */
    IfxPpucStu_LaneId_104,        /**< \brief IfxPpucStu_LaneId104  */
    IfxPpucStu_LaneId_105,        /**< \brief IfxPpucStu_LaneId105  */
    IfxPpucStu_LaneId_106,        /**< \brief IfxPpucStu_LaneId106  */
    IfxPpucStu_LaneId_107,        /**< \brief IfxPpucStu_LaneId107  */
    IfxPpucStu_LaneId_108,        /**< \brief IfxPpucStu_LaneId108  */
    IfxPpucStu_LaneId_109,        /**< \brief IfxPpucStu_LaneId109  */
    IfxPpucStu_LaneId_110,        /**< \brief IfxPpucStu_LaneId110  */
    IfxPpucStu_LaneId_111,        /**< \brief IfxPpucStu_LaneId111  */
    IfxPpucStu_LaneId_112,        /**< \brief IfxPpucStu_LaneId112  */
    IfxPpucStu_LaneId_113,        /**< \brief IfxPpucStu_LaneId113  */
    IfxPpucStu_LaneId_114,        /**< \brief IfxPpucStu_LaneId114  */
    IfxPpucStu_LaneId_115,        /**< \brief IfxPpucStu_LaneId115  */
    IfxPpucStu_LaneId_116,        /**< \brief IfxPpucStu_LaneId116  */
    IfxPpucStu_LaneId_117,        /**< \brief IfxPpucStu_LaneId117  */
    IfxPpucStu_LaneId_118,        /**< \brief IfxPpucStu_LaneId118  */
    IfxPpucStu_LaneId_119,        /**< \brief IfxPpucStu_LaneId119  */
    IfxPpucStu_LaneId_120,        /**< \brief IfxPpucStu_LaneId120  */
    IfxPpucStu_LaneId_121,        /**< \brief IfxPpucStu_LaneId121  */
    IfxPpucStu_LaneId_122,        /**< \brief IfxPpucStu_LaneId122  */
    IfxPpucStu_LaneId_123,        /**< \brief IfxPpucStu_LaneId123  */
    IfxPpucStu_LaneId_124,        /**< \brief IfxPpucStu_LaneId124  */
    IfxPpucStu_LaneId_125,        /**< \brief IfxPpucStu_LaneId125  */
    IfxPpucStu_LaneId_126,        /**< \brief IfxPpucStu_LaneId126  */
    IfxPpucStu_LaneId_127         /**< \brief IfxPpucStu_LaneId127  */
} IfxPpucStu_LaneId;

/** \brief Describes the type of memory, system or private
 */
typedef enum
{
    IfxPpucStu_Memory_system  = 0, /**< \brief Source/Destination is in system memory */
    IfxPpucStu_Memory_private = 1  /**< \brief Source/Destination is in private memory */
} IfxPpucStu_Memory;

/** \brief Singal to be generated at end of transfer
 */
typedef enum
{
    IfxPpucStu_SignalType_event     = 0, /**< \brief Generate an event signal */
    IfxPpucStu_SignalType_interrupt = 1  /**< \brief Generate an interrupt signal */
} IfxPpucStu_SignalType;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Ppuc_Std_Stu_Struct
 * \{ */
/** \brief Channel configuration
 */
typedef struct
{
    uint32                    sourceAddress;            /**< \brief source address */
    uint32                    destinationAddress;       /**< \brief destination address */
    uint32                    transferSize;             /**< \brief Data size to be transferred in bytes */
    uint16                    srcWidth;                 /**< \brief In 2D Mode, Src width in bytes */
    uint16                    dstWidth;                 /**< \brief In 2D Mode, Dst width in bytes */
    uint16                    srcStride;                /**< \brief In 2D Mode, src stride in bytes */
    uint16                    dstStride;                /**< \brief In 2D Mode, dst stride in bytes */
    IfxPpucStu_AddressingMode addressingMode;           /**< \brief Addressing mode of the transfer */
    IfxPpucStu_SignalType     signalType;               /**< \brief Signal type to be generated at end of transfer */
    IfxPpucStu_Memory         srcMemType;               /**< \brief Source memory type */
    IfxPpucStu_Memory         dstMemType;               /**< \brief Destination memory type */
    IfxPpucStu_LaneId         srcLaneId;                /**< \brief Source lane ID */
    IfxPpucStu_LaneId         dstLaneId;                /**< \brief Destination lane ID */
    IfxPpucStu_LandeWidth     srcLaneWidth;             /**< \brief Source lane width */
    IfxPpucStu_LandeWidth     dstLaneWidth;             /**< \brief Destination Lane width */
} IfxPpucStu_channelConfig;

/** \} */

/** \addtogroup IfxLld_Ppuc_Std_Stu_Stu
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Sets the base adress for the STU descriptor
 * \param ppuc PPUC module pointer
 * \param address Base address of STU descriptor
 * \return None
 */
IFX_INLINE void IfxPpucStu_setDescriptorBaseAddress(Ifx_PPU *ppuc, uint32 address);

/** \brief Returns the next free channel that can be configured
 * \param ppuc PPUC module pointer
 * \return Returns the free channel number
 */
IFX_INLINE uint8 IfxPpucStu_getNextFreeChannel(Ifx_PPU *ppuc);

/** \brief Initiate the number of STU transfers
 * \param ppuc PPUC module pointer
 * \param numOfTransfers The number of data transfers to be triggered
 * \return None
 */
IFX_INLINE void IfxPpucStu_startTransfer(Ifx_PPU *ppuc, uint8 numOfTransfers);

/** \brief Returns the channel status
 * \param ppuc PPUC module pointer
 * \param channelNum The virtual channel number
 * \return Returns the channel status
 */
IFX_INLINE boolean IfxPpucStu_getChannelEvent(Ifx_PPU *ppuc, uint8 channelNum);

/** \brief Clears the channel event status
 * \param ppuc PPUC module pointer
 * \param channelNum The virtual channel number
 * \return None
 */
IFX_INLINE void IfxPpucStu_clearChannelEvent(Ifx_PPU *ppuc, uint8 channelNum);

/** \brief Clears the status of all the events
 * \param ppuc PPUC module pointer
 * \return None
 */
IFX_INLINE void IfxPpucStu_clearAllEvents(Ifx_PPU *ppuc);

/** \brief Returns the max number of entries configured per FIFO
 * \param ppuc PPUC Module pointer
 * \return Returns the max number of channels
 */
IFX_INLINE uint8 IfxPpucStu_getMaxChannels(Ifx_PPU *ppuc);

/** \brief Sets the maximum number of entries per transfer FIFO
 * \param ppuc PPUC Module pointer
 * \param maxChannels Max number of channels
 * \return None
 */
IFX_INLINE void IfxPpucStu_setMaxChannels(Ifx_PPU *ppuc, uint8 maxChannels);

/** \brief Returns TRUE if Done interrupt flag is set, FALSE if the flag is not set
 * \param ppuc PPUC module pointer
 * \param channelNum The virtual channel number
 * \return Returns the channel Interrupt Done status
 */
IFX_INLINE boolean IfxPpucStu_isChannelInterruptDone(Ifx_PPU *ppuc, uint8 channelNum);

/** \brief Returns TRUE if Error interrupt flag is set, FALSE if the flag is not set
 * \param ppuc PPUC module pointer
 * \param channelNum The virtual channel number
 * \return Returns the channel Error Interrupt status
 */
IFX_INLINE boolean IfxPpucStu_isChannelErrorInterrupt(Ifx_PPU *ppuc, uint8 channelNum);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initialize the Channel
 * \param ppuc PPUC module pointer
 * \param channelNum The virtual channel number
 * \param stuDescriptor Address of the STU memory mapped registers
 * \param channelConfig STU channel config
 * \return None
 */
IFX_EXTERN void IfxPpucStu_initChannel(Ifx_PPU *ppuc, uint8 channelNum, uint32 stuDescriptor, IfxPpucStu_channelConfig *channelConfig);

/** \brief Default values for the channel configuration
 * \param channelConfig Channel configuration pointer
 * \return None
 */
IFX_EXTERN void IfxPpucStu_initChannelConfig(IfxPpucStu_channelConfig *channelConfig);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxPpucStu_setDescriptorBaseAddress(Ifx_PPU *ppuc, uint32 address)
{
    PPU_STU_BASE_L.U = address;
}


IFX_INLINE uint8 IfxPpucStu_getNextFreeChannel(Ifx_PPU *ppuc)
{
    return (uint8)PPU_STU_NEXT_FREE.U;
}


IFX_INLINE void IfxPpucStu_startTransfer(Ifx_PPU *ppuc, uint8 numOfTransfers)
{
    PPU_STU_NEXT_FREE_INC.U = numOfTransfers;
}


IFX_INLINE boolean IfxPpucStu_getChannelEvent(Ifx_PPU *ppuc, uint8 channelNum)
{
    /* Select the entry */
    PPU_STU_ENTRY_SELECT.U = channelNum;
    /* Read the status register */
    return (boolean)((PPU_STU_ENTRY_STAT.U & (1U << 2U)) >> 2U);
}


IFX_INLINE void IfxPpucStu_clearChannelEvent(Ifx_PPU *ppuc, uint8 channelNum)
{
    /* Select the entry */
    PPU_STU_ENTRY_SELECT.U = channelNum;
    /* clear the event status of the selected entry */
    PPU_STU_EVENT.U        = 0U;
}


IFX_INLINE void IfxPpucStu_clearAllEvents(Ifx_PPU *ppuc)
{
    PPU_STU_EVENT.U = 0x80000000U;
}


IFX_INLINE uint8 IfxPpucStu_getMaxChannels(Ifx_PPU *ppuc)
{
    return (uint8)(PPU_STU_ENTRY_NUM.U);
}


IFX_INLINE void IfxPpucStu_setMaxChannels(Ifx_PPU *ppuc, uint8 maxChannels)
{
    PPU_STU_ENTRY_NUM.U = maxChannels;
}


IFX_INLINE boolean IfxPpucStu_isChannelInterruptDone(Ifx_PPU *ppuc, uint8 channelNum)
{
    /* Select the entry */
    PPU_STU_ENTRY_SELECT.U = channelNum;
    /* Read the status register */
    return (boolean)((PPU_STU_ENTRY_STAT.U & (1U << 3U)) >> 3U);
}


IFX_INLINE boolean IfxPpucStu_isChannelErrorInterrupt(Ifx_PPU *ppuc, uint8 channelNum)
{
    /* Select the entry */
    PPU_STU_ENTRY_SELECT.U = channelNum;
    /* Read the status register */
    return (boolean)((PPU_STU_ENTRY_STAT.U & (1U << 4U)) >> 4U);
}


#endif /* IFXPPUCSTU_H */
