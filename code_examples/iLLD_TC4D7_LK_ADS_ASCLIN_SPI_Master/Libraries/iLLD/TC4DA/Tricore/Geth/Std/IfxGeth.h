/**
 * \file IfxGeth.h
 * \brief GETH  basic functionality
 * \ingroup IfxLld_Geth
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Geth_Std_Enumerations Enumerations
 * \ingroup IfxLld_Geth_Std
 * \defgroup IfxLld_Geth_Std_Functions Std Functions
 * \ingroup IfxLld_Geth_Std
 * \defgroup IfxLld_Geth_Std_DataStructures DataStructures
 * \ingroup IfxLld_Geth_Std
 * \defgroup IfxLld_Geth_Std_Unions Unions
 * \ingroup IfxLld_Geth_Std
 */

#ifndef IFXGET_H
#define IFXGET_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxGeth_cfg.h"
#include "Src/Std/IfxSrc.h"
#include "IfxGeth_bf.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Max number of TX descriptors per list
 */
#ifndef IFXGETH_MAX_TX_DESCRIPTORS
#define IFXGETH_MAX_TX_DESCRIPTORS (8)
#endif

/** \brief Max number of RX descriptors per list
 */
#ifndef IFXGETH_MAX_RX_DESCRIPTORS
#define IFXGETH_MAX_RX_DESCRIPTORS (8)
#endif

/** \brief MDIO Wait Completion logic
 */
#define IFXGETH_MDIO_LOOP_TIMEOUT_CHECK(timeOutValue, timeOutStatus) \
    {                                                                \
        if (((uint32)--timeOutValue) <= 0)                           \
        {                                                            \
            timeOutStatus = TRUE;                                    \
            break;                                                   \
        }                                                            \
    }

/** \brief L3/L4 filter Register Transfer Wait Completion logic
 */
#define IFXGETH_L3L4FILTER_LOOP_TIMEOUT_CHECK(timeOutValue, timeOutStatus) IFXGETH_MDIO_LOOP_TIMEOUT_CHECK(timeOutValue, timeOutStatus)

/** \brief EEE LPI Mode entry/exit wait logic
 */
#define IFXGETH_LPIMODE_LOOP_TIMEOUT_CHECK(timeOutValue, timeOutStatus)    IFXGETH_MDIO_LOOP_TIMEOUT_CHECK(timeOutValue, timeOutStatus)

/** \brief Wait time for remote wake-up filter i.e bit RWKPTR to increment
 */
#define IFXGETH_RWKFILTPTR_LOOP_TIMEOUT_CHECK(timeOutValue, timeOutStatus) IFXGETH_MDIO_LOOP_TIMEOUT_CHECK(timeOutValue, timeOutStatus)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Geth_Std_Enumerations
 * \{ */
/** \brief Non default Address Filters. Filter 0 has different structure and hence not part of this enum.
 */
typedef enum
{
    IfxGeth_AddressFilter_1   = 1,  /**< \brief Address Filter Index 1 */
    IfxGeth_AddressFilter_2   = 2,  /**< \brief Address Filter Index 2 */
    IfxGeth_AddressFilter_3   = 3,  /**< \brief Address Filter Index 3 */
    IfxGeth_AddressFilter_4   = 4,  /**< \brief Address Filter Index 4 */
    IfxGeth_AddressFilter_5   = 5,  /**< \brief Address Filter Index 5 */
    IfxGeth_AddressFilter_6   = 6,  /**< \brief Address Filter Index 6 */
    IfxGeth_AddressFilter_7   = 7,  /**< \brief Address Filter Index 7 */
    IfxGeth_AddressFilter_8   = 8,  /**< \brief Address Filter Index 8 */
    IfxGeth_AddressFilter_9   = 9,  /**< \brief Address Filter Index 9 */
    IfxGeth_AddressFilter_10  = 10, /**< \brief Address Filter Index 10 */
    IfxGeth_AddressFilter_11  = 11, /**< \brief Address Filter Index 11 */
    IfxGeth_AddressFilter_12  = 12, /**< \brief Address Filter Index 12 */
    IfxGeth_AddressFilter_13  = 13, /**< \brief Address Filter Index 13 */
    IfxGeth_AddressFilter_14  = 14, /**< \brief Address Filter Index 14 */
    IfxGeth_AddressFilter_15  = 15, /**< \brief Address Filter Index 15 */
    IfxGeth_AddressFilter_16  = 16, /**< \brief Address Filter Index 16 */
    IfxGeth_AddressFilter_17  = 17, /**< \brief Address Filter Index 17 */
    IfxGeth_AddressFilter_18  = 18, /**< \brief Address Filter Index 18 */
    IfxGeth_AddressFilter_19  = 19, /**< \brief Address Filter Index 19 */
    IfxGeth_AddressFilter_20  = 20, /**< \brief Address Filter Index 20 */
    IfxGeth_AddressFilter_21  = 21, /**< \brief Address Filter Index 21 */
    IfxGeth_AddressFilter_22  = 22, /**< \brief Address Filter Index 22 */
    IfxGeth_AddressFilter_23  = 23, /**< \brief Address Filter Index 23 */
    IfxGeth_AddressFilter_24  = 24, /**< \brief Address Filter Index 24 */
    IfxGeth_AddressFilter_25  = 25, /**< \brief Address Filter Index 25 */
    IfxGeth_AddressFilter_26  = 26, /**< \brief Address Filter Index 26 */
    IfxGeth_AddressFilter_27  = 27, /**< \brief Address Filter Index 27 */
    IfxGeth_AddressFilter_28  = 28, /**< \brief Address Filter Index 28 */
    IfxGeth_AddressFilter_29  = 29, /**< \brief Address Filter Index 29 */
    IfxGeth_AddressFilter_30  = 30, /**< \brief Address Filter Index 30 */
    IfxGeth_AddressFilter_31  = 31, /**< \brief Address Filter Index 31 */
    IfxGeth_AddressFilter_max = 32  /**< \brief Extra enum value for max loop count, not to be used in API config */
} IfxGeth_AddressFilter;

/** \brief Bridge Port Loopback Control\n
 * Definition in PORT_FLUSH_AND_LOOPBACK_CONTROL.B.PORT_LPBK_EN
 */
typedef enum
{
    IfxGeth_BridgeLoopbackMode_disabled                 = 0, /**< \brief Loopback is disabled */
    IfxGeth_BridgeLoopbackMode_port0Enabled             = 1, /**< \brief Loopback enabled for Port 0 */
    IfxGeth_BridgeLoopbackMode_port1Enabled             = 2, /**< \brief Loopback enabled for Port 1 */
    IfxGeth_BridgeLoopbackMode_bothPort0AndPort1Enabled = 3  /**< \brief Loopback enabled for both Port 0 and Port 1 */
} IfxGeth_BridgeLoopbackMode;

/** \brief Bridge Port Mode\n
 * Definition in FORWARD_CONTROL.B.PORT_SEL and FORWARD_CONTROL.B.Q_CH_MAPPING_EN
 */
typedef enum
{
    IfxGeth_BridgePortMode_singlePort0 = 0,  /**< \brief Single Port Mode using Port 0 */
    IfxGeth_BridgePortMode_singlePort1 = 1,  /**< \brief Single Port Mode using Port 1 */
    IfxGeth_BridgePortMode_multiPort   = 2   /**< \brief Multi Port Mode using both Port 0 and Port 1 */
} IfxGeth_BridgePortMode;

/** \brief GETH Port's RxC Mapping to Rx DMA Channels or Tx Forward Paths\n
 * To do: Enum values currently unavailable from Synopsis, keeping it as place holders for future implementation.
 * Values taken after alignment with VEs.
 */
typedef enum
{
    IfxGeth_BridgeRxCMap_RxDma0          = 0,  /**< \brief Mapped to Rx Dma channel 0 */
    IfxGeth_BridgeRxCMap_RxDma1          = 1,  /**< \brief Mapped to Rx Dma channel 1 */
    IfxGeth_BridgeRxCMap_RxDma2          = 2,  /**< \brief Mapped to Rx Dma channel 2 */
    IfxGeth_BridgeRxCMap_RxDma3          = 3,  /**< \brief Mapped to Rx Dma channel 3 */
    IfxGeth_BridgeRxCMap_RxDma4          = 4,  /**< \brief Mapped to Rx Dma channel 4 */
    IfxGeth_BridgeRxCMap_RxDma5          = 5,  /**< \brief Mapped to Rx Dma channel 5 */
    IfxGeth_BridgeRxCMap_RxDma6          = 6,  /**< \brief Mapped to Rx Dma channel 6 */
    IfxGeth_BridgeRxCMap_RxDma7          = 7,  /**< \brief Mapped to Rx Dma channel 7 */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ0 = 0,  /**< \brief Mapped to Tx Queue 0 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ1 = 1,  /**< \brief Mapped to Tx Queue 1 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ2 = 2,  /**< \brief Mapped to Tx Queue 2 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ3 = 3,  /**< \brief Mapped to Tx Queue 3 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ4 = 4,  /**< \brief Mapped to Tx Queue 4 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ5 = 5,  /**< \brief Mapped to Tx Queue 5 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ6 = 6,  /**< \brief Mapped to Tx Queue 6 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeRxCMap_ForwardPortTxQ7 = 7   /**< \brief Mapped to Tx Queue 7 of other Port (in Forwarding Modes) */
} IfxGeth_BridgeRxCMap;

/** \brief GETH Port's Tx Queue Mapping to Tx DMA Channels or Rx Forward Paths\n
 * To do: Enum values currently unavailable from Synopsis, keeping it as place holders for future implementation.
 * Values taken after alignment with VEs.
 */
typedef enum
{
    IfxGeth_BridgeTxQueueMap_TxDma0          = 0,  /**< \brief Mapped to Tx Dma channel 0 */
    IfxGeth_BridgeTxQueueMap_TxDma1          = 1,  /**< \brief Mapped to Tx Dma channel 1 */
    IfxGeth_BridgeTxQueueMap_TxDma2          = 2,  /**< \brief Mapped to Tx Dma channel 2 */
    IfxGeth_BridgeTxQueueMap_TxDma3          = 3,  /**< \brief Mapped to Tx Dma channel 3 */
    IfxGeth_BridgeTxQueueMap_TxDma4          = 4,  /**< \brief Mapped to Tx Dma channel 4 */
    IfxGeth_BridgeTxQueueMap_TxDma5          = 5,  /**< \brief Mapped to Tx Dma channel 5 */
    IfxGeth_BridgeTxQueueMap_TxDma6          = 6,  /**< \brief Mapped to Tx Dma channel 6 */
    IfxGeth_BridgeTxQueueMap_TxDma7          = 7,  /**< \brief Mapped to Tx Dma channel 7 */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC0 = 0,  /**< \brief Mapped to RxC 0 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC1 = 1,  /**< \brief Mapped to RxC 1 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC2 = 2,  /**< \brief Mapped to RxC 2 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC3 = 3,  /**< \brief Mapped to RxC 3 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC4 = 4,  /**< \brief Mapped to RxC 4 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC5 = 5,  /**< \brief Mapped to RxC 5 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC6 = 6,  /**< \brief Mapped to RxC 6 of other Port (in Forwarding Modes) */
    IfxGeth_BridgeTxQueueMap_ForwardPortRxC7 = 7   /**< \brief Mapped to RxC 7 of other Port (in Forwarding Modes) */
} IfxGeth_BridgeTxQueueMap;

/** \brief Option for Checksum Insertion Control in Transmit Packets.
 * Definition in Tx Normal Descriptor TDES3.R.CIC
 */
typedef enum
{
    IfxGeth_ChecksumControl_disabled                            = 0,  /**< \brief Checksum Insertion Disabled. */
    IfxGeth_ChecksumControl_headerOnly                          = 1,  /**< \brief Only IP header checksum calculation and insertion are enabled. */
    IfxGeth_ChecksumControl_headerAndPayloadWithOutPseudoHeader = 2,  /**< \brief IP header checksum and payload checksum calculation and insertion are enabled, but pseudo-header checksum is not calculated in hardware. */
    IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader    = 3   /**< \brief IP Header checksum and payload checksum calculation and insertion are enabled, and pseudo-header checksum is calculated in hardware. */
} IfxGeth_ChecksumControl;

/** \brief Option for CRC Pad Control in Transmit Packets.
 * Definition in Tx Normal Descriptor TDES3.R.CPC
 */
typedef enum
{
    IfxGeth_CrcControl_insertCrcAndPad = 0,  /**< \brief CRC and Pad Insertion: The MAC appends the cyclic redundancy check (CRC) at the end of the transmitted packet of length greater than or equal to 60 bytes. The MAC automatically adds padding and CRC to a frame shorter than 60 bytes. */
    IfxGeth_CrcControl_insertCrc       = 1,  /**< \brief CRC Insertion (Disable Pad Insertion): The MAC appends the CRC at the end of the transmitted packet but it does not append padding. The application should ensure that the padding bytes are present in the packet being transferred from the Transmit Buffer, that is, the packet being transferred from the Transmit Buffer is of length greater than or equal to 60 bytes. */
    IfxGeth_CrcControl_disabled        = 2,  /**< \brief Disable CRC Insertion: The MAC does not append the CRC at the end of the transmitted packet. The application should ensure that the padding and CRC bytes are present in the packet being transferred from the Transmit Buffer. */
    IfxGeth_CrcControl_replaceCrc      = 3   /**< \brief CRC Replacement: The MAC replaces the last four bytes of the transmitted packet with recalculated CRC bytes. The application should ensure that the padding and CRC bytes are present in the packet being transferred from the Transmit Buffer. */
} IfxGeth_CrcControl;

/** \brief DMA burst length
 */
typedef enum
{
    IfxGeth_DmaBurstLength_unset = -1,  /**< \brief not configured */
    IfxGeth_DmaBurstLength_1     = 0,   /**< \brief maximum burst length 1 */
    IfxGeth_DmaBurstLength_4     = 1,   /**< \brief maximum burst length 4 */
    IfxGeth_DmaBurstLength_8     = 2,   /**< \brief maximum burst length 8 */
    IfxGeth_DmaBurstLength_16    = 3,   /**< \brief maximum burst length 16 */
    IfxGeth_DmaBurstLength_32    = 4,   /**< \brief maximum burst length 32 */
    IfxGeth_DmaBurstLength_64    = 5,   /**< \brief maximum burst length 64 */
    IfxGeth_DmaBurstLength_128   = 6,   /**< \brief maximum burst length 128 */
    IfxGeth_DmaBurstLength_256   = 7    /**< \brief maximum burst length 256 */
} IfxGeth_DmaBurstLength;

/** \brief DMA channel Index
 */
typedef enum
{
    IfxGeth_DmaChannel_0 = 0,  /**< \brief Dma Channel 0 */
    IfxGeth_DmaChannel_1 = 1,  /**< \brief Dma Channel 1 */
    IfxGeth_DmaChannel_2 = 2,  /**< \brief Dma Channel 2 */
    IfxGeth_DmaChannel_3 = 3,  /**< \brief Dma Channel 3 */
    IfxGeth_DmaChannel_4 = 4,  /**< \brief Dma Channel 4 */
    IfxGeth_DmaChannel_5 = 5,  /**< \brief Dma Channel 5 */
    IfxGeth_DmaChannel_6 = 6,  /**< \brief Dma Channel 6 */
    IfxGeth_DmaChannel_7 = 7   /**< \brief Dma Channel 7 */
} IfxGeth_DmaChannel;

/** \brief Duplex Mode\n
 * Definintion in PORT0_MAC_EXTENDED_CONFIGURATION.B.HD
 */
typedef enum
{
    IfxGeth_DuplexMode_fullDuplex = 0,  /**< \brief Full Duplex Mode */
    IfxGeth_DuplexMode_halfDuplex = 1   /**< \brief Half Duplex Mode */
} IfxGeth_DuplexMode;

/** \brief Option for Flexible Header Start Position.
 * Definition in Ifx_GETH_PORT_CORE_MAC_FLEX_HDR_CFG.B.FHSP.
 */
typedef enum
{
    IfxGeth_FlexHeaderStartPosition_byte0  = 0,   /**< \brief Flex header is inserted before DA at byte 0 */
    IfxGeth_FlexHeaderStartPosition_byte12 = 12,  /**< \brief Flex header is inserted after SA at byte 12 */
    IfxGeth_FlexHeaderStartPosition_byte14 = 14,  /**< \brief Flex header is inserted at byte 14 */
    IfxGeth_FlexHeaderStartPosition_byte15 = 15,  /**< \brief Flex header is inserted at byte 15 */
    IfxGeth_FlexHeaderStartPosition_byte16 = 16,  /**< \brief Flex header is inserted at byte 16 */
    IfxGeth_FlexHeaderStartPosition_byte17 = 17,  /**< \brief Flex header is inserted at byte 17 */
    IfxGeth_FlexHeaderStartPosition_byte18 = 18,  /**< \brief Flex header is inserted at byte 18 */
    IfxGeth_FlexHeaderStartPosition_byte19 = 19,  /**< \brief Flex header is inserted at byte 19 */
    IfxGeth_FlexHeaderStartPosition_byte20 = 20,  /**< \brief Flex header is inserted at byte 20 */
    IfxGeth_FlexHeaderStartPosition_byte21 = 21,  /**< \brief Flex header is inserted at byte 21 */
    IfxGeth_FlexHeaderStartPosition_byte22 = 22,  /**< \brief Flex header is inserted at byte 22 */
    IfxGeth_FlexHeaderStartPosition_byte23 = 23,  /**< \brief Flex header is inserted at byte 23 */
    IfxGeth_FlexHeaderStartPosition_byte24 = 24,  /**< \brief Flex header is inserted at byte 24 */
    IfxGeth_FlexHeaderStartPosition_byte25 = 25,  /**< \brief Flex header is inserted at byte 25 */
    IfxGeth_FlexHeaderStartPosition_byte26 = 26,  /**< \brief Flex header is inserted at byte 26 */
    IfxGeth_FlexHeaderStartPosition_byte27 = 27,  /**< \brief Flex header is inserted at byte 27 */
    IfxGeth_FlexHeaderStartPosition_byte28 = 28,  /**< \brief Flex header is inserted at byte 28 */
    IfxGeth_FlexHeaderStartPosition_byte29 = 29   /**< \brief Flex header is inserted at byte 29 */
} IfxGeth_FlexHeaderStartPosition;

/** \brief Tx Flexible PPS Output Control \n
 * Definition in Ifx_GETH_PORT_CORE_MAC_PPS_CONTROL.B.PPSCTRL0_PPSCMD0. Refer to PPSCMD0: Flexible PPS Output (ptp_pps_o[0]) Control
 */
typedef enum
{
    IfxGeth_FlexiblePPSControl_noCommand               = 0,  /**< \brief No Command */
    IfxGeth_FlexiblePPSControl_startSinglePulse        = 1,  /**< \brief Credit Based Shaper */
    IfxGeth_FlexiblePPSControl_startPulseTrain         = 2,  /**< \brief ETS Algorithm */
    IfxGeth_FlexiblePPSControl_cancelStart             = 3,
    IfxGeth_FlexiblePPSControl_timedStopPulseTrain     = 4,
    IfxGeth_FlexiblePPSControl_immediateStopPulseTrain = 5,
    IfxGeth_FlexiblePPSControl_cancelStopPulseTrain    = 6
} IfxGeth_FlexiblePPSControl;

/** \brief Layer 3 filter selection for IP destination addr match enable for perfect/inverse matching
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L3DAIM#(i)
 */
typedef enum
{
    IfxGeth_L3FilterDstAddrInvMatch_perfect = 0,  /**< \brief Layer 3 filter selection for IP destination addr match enable for perfect matching */
    IfxGeth_L3FilterDstAddrInvMatch_inverse = 1   /**< \brief Layer 3 filter selection for IP destination addr match enable for inverse matching */
} IfxGeth_L3FilterDstAddrInvMatch;

/** \brief Layer 3 filter selection for IP destination addr match enable/disable
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L3DAM#(i)
 */
typedef enum
{
    IfxGeth_L3FilterDstAddrMatch_disable = 0,  /**< \brief Layer 3 filter selection for IP destination addr match disable */
    IfxGeth_L3FilterDstAddrMatch_enable  = 1   /**< \brief Layer 3 filter selection for IP destination addr match enable */
} IfxGeth_L3FilterDstAddrMatch;

/** \brief Layer 3 filter selection for IPv4/IPv6 frame format
 * Definition in MAC_L3_L4_CONTROL#(i).B.L3PEN#(i)
 */
typedef enum
{
    IfxGeth_L3FilterProtocolEnable_ipV4 = 0,  /**< \brief Layer 3 filter selection for IPv4 frame format */
    IfxGeth_L3FilterProtocolEnable_ipV6 = 1   /**< \brief Layer 3 filter selection for IPv6 frame format */
} IfxGeth_L3FilterProtocolEnable;

/** \brief Layer 3 filter selection for IP source addr match enable for perfect/inverse matching
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L3SAIM#(i)
 */
typedef enum
{
    IfxGeth_L3FilterSrcAddrInvMatch_perfect = 0,  /**< \brief Layer 3 filter selection for IP source addr match enable for perfect matching */
    IfxGeth_L3FilterSrcAddrInvMatch_inverse = 1   /**< \brief Layer 3 filter selection for IP source addr match enable for inverse matching */
} IfxGeth_L3FilterSrcAddrInvMatch;

/** \brief Layer 3 filter selection for IP source addr match enable/disable
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L3SAM#(i)
 */
typedef enum
{
    IfxGeth_L3FilterSrcAddrMatch_disable = 0,  /**< \brief Layer 3 filter selection for IP source addr match disable */
    IfxGeth_L3FilterSrcAddrMatch_enable  = 1   /**< \brief Layer 3 filter selection for IP source addr match enable */
} IfxGeth_L3FilterSrcAddrMatch;

/** \brief Layer 3 filter value to mask the no's of lower bits in Src/dst Addr
 * Definition in MAC_L3_L4_CONTROL#(i).B.L3HSBM#(i) and  MAC_L3_L4_CONTROL#(i).B.L3HDBM#(i)
 */
typedef enum
{
    IfxGeth_L3FilterSrcDstAddrMask_none  = 0,   /**< \brief None of the bits are masked in Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to0  = 1,   /**< \brief value to mask the [0:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to1  = 2,   /**< \brief value to mask the [1:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to2  = 3,   /**< \brief value to mask the [2:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to3  = 4,   /**< \brief value to mask the [3:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to4  = 5,   /**< \brief value to mask the [4:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to5  = 6,   /**< \brief value to mask the [5:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to6  = 7,   /**< \brief value to mask the [6:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to7  = 8,   /**< \brief value to mask the [7:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to8  = 9,   /**< \brief value to mask the [8:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to9  = 10,  /**< \brief value to mask the [9:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to10 = 11,  /**< \brief value to mask the [10:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to11 = 12,  /**< \brief value to mask the [11:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to12 = 13,  /**< \brief value to mask the [12:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to13 = 14,  /**< \brief value to mask the [13:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to14 = 15,  /**< \brief value to mask the [14:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to15 = 16,  /**< \brief value to mask the [15:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to16 = 17,  /**< \brief value to mask the [16:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to17 = 18,  /**< \brief value to mask the [17:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to18 = 19,  /**< \brief value to mask the [18:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to19 = 20,  /**< \brief value to mask the [19:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to20 = 21,  /**< \brief value to mask the [20:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to21 = 22,  /**< \brief value to mask the [21:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to22 = 23,  /**< \brief value to mask the [22:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to23 = 24,  /**< \brief value to mask the [23:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to24 = 25,  /**< \brief value to mask the [24:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to25 = 26,  /**< \brief value to mask the [25:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to26 = 27,  /**< \brief value to mask the [26:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to27 = 28,  /**< \brief value to mask the [27:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to28 = 29,  /**< \brief value to mask the [28:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to29 = 30,  /**< \brief value to mask the [29:0] bits of Addr match */
    IfxGeth_L3FilterSrcDstAddrMask_0to30 = 31   /**< \brief value to mask the [30:0] bits of Addr match */
} IfxGeth_L3FilterSrcDstAddrMask;

/** \brief Layer 3/4 filter channel Index
 * Definition in MAC_L3_L4_CONTROL#(i).B.DMCHN
 */
typedef enum
{
    IfxGeth_L3L4FilterChannel_0 = 0,  /**< \brief Layer 3/4 filter channel Index 0 */
    IfxGeth_L3L4FilterChannel_1 = 1,  /**< \brief Layer 3/4 filter channel Index 1 */
    IfxGeth_L3L4FilterChannel_2 = 2,  /**< \brief Layer 3/4 filter channel Index 2 */
    IfxGeth_L3L4FilterChannel_3 = 3,  /**< \brief Layer 3/4 filter channel Index 3 */
    IfxGeth_L3L4FilterChannel_4 = 4,  /**< \brief Layer 3/4 filter channel Index 4 */
    IfxGeth_L3L4FilterChannel_5 = 5,  /**< \brief Layer 3/4 filter channel Index 5 */
    IfxGeth_L3L4FilterChannel_6 = 6,  /**< \brief Layer 3/4 filter channel Index 6 */
    IfxGeth_L3L4FilterChannel_7 = 7   /**< \brief Layer 3/4 filter channel Index 7 */
} IfxGeth_L3L4FilterChannel;

/** \brief Layer 3/4 filter channel selection enable/disable
 * Definition in MAC_L3_L4_CONTROL#(i).B.DMCHEN
 */
typedef enum
{
    IfxGeth_L3L4FilterChannelSel_disable = 0,  /**< \brief Layer 3/4 filter channel selection disable */
    IfxGeth_L3L4FilterChannelSel_enable  = 1   /**< \brief Layer 3/4 filter channel selection enable */
} IfxGeth_L3L4FilterChannelSel;

/** \brief Indirect access transfer type for L3L4 filter register's for read/write
 * Definition in MAC_L3_L4_ADDRESS_CONTROL.B.TT
 */
typedef enum
{
    IfxGeth_L3L4FilterCtrlTransferType_write = 0,  /**< \brief transfer type for L3L4 filter register's for write */
    IfxGeth_L3L4FilterCtrlTransferType_read        /**< \brief transfer type for L3L4 filter register's for read */
} IfxGeth_L3L4FilterCtrlTransferType;

/** \brief L3/L4 filter Index's
 * Definition in MAC_L3_L4_ADDRESS_CONTROL.B.IDDR[14:12]
 */
typedef enum
{
    IfxGeth_L3L4FilterNum_0 = 0,  /**< \brief L3/L4 filter Index 0 */
    IfxGeth_L3L4FilterNum_1 = 1,  /**< \brief L3/L4 filter Index 1 */
    IfxGeth_L3L4FilterNum_2 = 2,  /**< \brief L3/L4 filter Index 2 */
    IfxGeth_L3L4FilterNum_3 = 3,  /**< \brief L3/L4 filter Index 3 */
    IfxGeth_L3L4FilterNum_4 = 4,  /**< \brief L3/L4 filter Index 4 */
    IfxGeth_L3L4FilterNum_5 = 5,  /**< \brief L3/L4 filter Index 5 */
    IfxGeth_L3L4FilterNum_6 = 6,  /**< \brief L3/L4 filter Index 6 */
    IfxGeth_L3L4FilterNum_7 = 7   /**< \brief L3/L4 filter Index 7 */
} IfxGeth_L3L4FilterNum;

/** \brief Register type's for L3L4 filter register's
 * Definition in MAC_L3_L4_ADDRESS_CONTROL.B.IDDR[11:8]
 */
typedef enum
{
    IfxGeth_L3L4FilterRegType_controlReg = 0,  /**< \brief Register type for L3L4 filter register MAC_L3_L4_Control#(i) */
    IfxGeth_L3L4FilterRegType_l4AddrReg  = 1,  /**< \brief Register type for L3L4 filter register MAC_Layer4_Address#(i) */
    IfxGeth_L3L4FilterRegType_l3Addr0Reg = 4,  /**< \brief Register type for L3L4 filter register MAC_Layer3_Addr0_Reg#(i) */
    IfxGeth_L3L4FilterRegType_l3Addr1Reg = 5,  /**< \brief Register type for L3L4 filter register MAC_Layer3_Addr1_Reg#(i) */
    IfxGeth_L3L4FilterRegType_l3Addr2Reg = 6,  /**< \brief Register type for L3L4 filter register MAC_Layer3_Addr2_Reg#(i) */
    IfxGeth_L3L4FilterRegType_l3Addr3Reg = 7   /**< \brief Register type for L3L4 filter register MAC_Layer3_Addr3_Reg#(i) */
} IfxGeth_L3L4FilterRegType;

/** \brief enum for status returned by L3/L4 filter API
 */
typedef enum
{
    IfxGeth_L3L4FilterStatus_success       = 0, /**< \brief Enum element for successful return */
    IfxGeth_L3L4FilterStatus_timeoutError  = 1, /**< \brief Enum element for timeout error return */
    IfxGeth_L3L4FilterStatus_invalidConfig = 2  /**< \brief Enum element for invalid config return */
} IfxGeth_L3L4FilterStatus;

/** \brief Layer 4 filter selection for destination port match enable for perfect/inverse matching
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L4DPIM#(i)
 */
typedef enum
{
    IfxGeth_L4FilterDstPortInvMatch_perfect = 0,  /**< \brief Layer 4 filter selection for destination port match enable for perfect matching */
    IfxGeth_L4FilterDstPortInvMatch_inverse = 1   /**< \brief Layer 4 filter selection for destination port match enable for inverse matching */
} IfxGeth_L4FilterDstPortInvMatch;

/** \brief Layer 4 filter selection for destination Port number match enable/disable
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L4DPM#(i)
 */
typedef enum
{
    IfxGeth_L4FilterDstPortMatch_disable = 0,  /**< \brief Layer 4 filter selection for destination Port number match disable */
    IfxGeth_L4FilterDstPortMatch_enable  = 1   /**< \brief Layer 4 filter selection for destination Port number match enable */
} IfxGeth_L4FilterDstPortMatch;

/** \brief Layer 4 filter selection between TCP/UDP protocol
 * Definition in MAC_L3_L4_CONTROL#(i).B.L4PEN#(i)
 */
typedef enum
{
    IfxGeth_L4FilterProtocolEnable_tcpPackets = 0,  /**< \brief Layer 4 filter selection for TCP protocol */
    IfxGeth_L4FilterProtocolEnable_udpPackets = 1   /**< \brief Layer 4 filter selection for UDP protocol */
} IfxGeth_L4FilterProtocolEnable;

/** \brief Layer 4 filter selection for source port match enable for perfect/inverse matching
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L4SPIM#(i)
 */
typedef enum
{
    IfxGeth_L4FilterSrcPortInvMatch_perfect = 0,  /**< \brief Layer 4 filter selection for source port match enable for perfect matching */
    IfxGeth_L4FilterSrcPortInvMatch_inverse = 1   /**< \brief Layer 4 filter selection for source port match enable for inverse matching */
} IfxGeth_L4FilterSrcPortInvMatch;

/** \brief Layer 4 filter selection for source Port number match enable/disable
 * Definition in  MAC_L3_L4_CONTROL#(i).B.L4SPM#(i)
 */
typedef enum
{
    IfxGeth_L4FilterSrcPortMatch_disable = 0,  /**< \brief Layer 4 filter selection for source Port number match disable */
    IfxGeth_L4FilterSrcPortMatch_enable  = 1   /**< \brief Layer 4 filter selection for source Port number match enable */
} IfxGeth_L4FilterSrcPortMatch;

/** \brief Loopback Mode\n
 * Definition in PORT0_MAC_RX_CONFIGURATION.B.LM
 */
typedef enum
{
    IfxGeth_LoopbackMode_disable = 0,  /**< \brief Disable loopback */
    IfxGeth_LoopbackMode_enable  = 1   /**< \brief Enable loopback */
} IfxGeth_LoopbackMode;

/** \brief enum for LPI mode entry/exit return status
 * Software enum
 */
typedef enum
{
    IfxGeth_LpiConfigStatus_entry              = 0, /**< \brief Enum element LPI mode entry successful return */
    IfxGeth_LpiConfigStatus_timeoutError       = 1, /**< \brief Enum element for timeout error return */
    IfxGeth_LpiConfigStatus_exit               = 2, /**< \brief Enum element LPI mode exit successful return */
    IfxGeth_LpiConfigStatus_invalidConfigError = 3  /**< \brief Enum element LPI mode entry/exit failure return */
} IfxGeth_LpiConfigStatus;

/** \brief Selects Source/Destination Address for Mac Address Filters
 * Definition in GETH_PORT_CORE_MACADDRESS<n>_HIGH.B.SA, n > 0
 */
typedef enum
{
    IfxGeth_MacAddressSelect_destinationAddress = 0,  /**< \brief Configured MAC Address is compared with the DA fields of the received packet. */
    IfxGeth_MacAddressSelect_sourceAddress      = 1   /**< \brief Configured MAC Address is compared with the SA fields of the received packet. */
} IfxGeth_MacAddressSelect;

/** \brief Filtering of Control Packets
 * Definition in GETH_PORT_CORE_MAC_PACKET_FILTER.B.PCF
 */
typedef enum
{
    IfxGeth_MacPacketFilterPassControl_optionA = 0,  /**< \brief The MAC filters all control packets from reaching the application. */
    IfxGeth_MacPacketFilterPassControl_optionB = 1,  /**< \brief The MAC forwards all control packets except Pause packets to the application even if they fail the Address filter. */
    IfxGeth_MacPacketFilterPassControl_optionC = 2,  /**< \brief The MAC forwards all control packets to the application even if they fail the Address filter. */
    IfxGeth_MacPacketFilterPassControl_optionD = 3   /**< \brief The MAC forwards the control packets that pass the Address filter. */
} IfxGeth_MacPacketFilterPassControl;

/** \brief MDIO Clock range selection
 * Definition in SINGLE_COMMAND_CONTROL_DATA.B.CR
 */
typedef enum
{
    IfxGeth_MdioAppClockRangeSel_Crs0Divider62  = 0,  /**< \brief MDC clock is derived as clk_csr/62 Applicable only when CRS = 0 */
    IfxGeth_MdioAppClockRangeSel_Crs0Divider102 = 1,  /**< \brief MDC clock is derived as clk_csr/102 Applicable only when CRS = 0 */
    IfxGeth_MdioAppClockRangeSel_Crs0Divider122 = 2,  /**< \brief MDC clock is derived as clk_csr/122 Applicable only when CRS = 0 */
    IfxGeth_MdioAppClockRangeSel_Crs0Divider142 = 3,  /**< \brief MDC clock is derived as clk_csr/142 Applicable only when CRS = 0 */
    IfxGeth_MdioAppClockRangeSel_Crs0Divider162 = 4,  /**< \brief MDC clock is derived as clk_csr/162 Applicable only when CRS = 0 */
    IfxGeth_MdioAppClockRangeSel_Crs0Divider202 = 5,  /**< \brief MDC clock is derived as clk_csr/202 Applicable only when CRS = 0 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider4   = 0,  /**< \brief MDC clock is derived as clk_csr/4 Applicable only when CRS = 1 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider6   = 1,  /**< \brief MDC clock is derived as clk_csr/6 Applicable only when CRS = 1 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider8   = 2,  /**< \brief MDC clock is derived as clk_csr/8 Applicable only when CRS = 1 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider10  = 3,  /**< \brief MDC clock is derived as clk_csr/10 Applicable only when CRS = 1 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider12  = 4,  /**< \brief MDC clock is derived as clk_csr/12 Applicable only when CRS = 1 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider14  = 5,  /**< \brief MDC clock is derived as clk_csr/14 Applicable only when CRS = 1 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider16  = 6,  /**< \brief MDC clock is derived as clk_csr/16 Applicable only when CRS = 1 */
    IfxGeth_MdioAppClockRangeSel_Crs1Divider18  = 7   /**< \brief MDC clock is derived as clk_csr/18 Applicable only when CRS = 1 */
} IfxGeth_MdioAppClockRangeSel;

/** \brief MDIO Continuous Write Transfer Complete Interrupt Enable / Disable
 * Definition in Ifx_GETH_PORT_CORE_MDIO_INTERRUPT_ENABLE.B.CWCOMPIE
 */
typedef enum
{
    IfxGeth_MdioContWriteCmdComplIntr_disable = 0,  /**< \brief MDIO Continuous Write Transfer Complete Interrupt Disable */
    IfxGeth_MdioContWriteCmdComplIntr_enable        /**< \brief MDIO Continuous Write Transfer Complete Interrupt Enable */
} IfxGeth_MdioContWriteCmdComplIntr;

/** \brief MDIO single transfer mode selection
 * Definition in SINGLE_COMMAND_CONTROL_DATA.B.CMD
 */
typedef enum
{
    IfxGeth_MdioControlCommandType_singleWrite       = 1,  /**< \brief MDIO Single transfer mode select for single write */
    IfxGeth_MdioControlCommandType_postIncrementRead = 2,  /**< \brief MDIO Single transfer mode select for post addr increment after read */
    IfxGeth_MdioControlCommandType_singleRead        = 3   /**< \brief MDIO Single transfer mode select for single read */
} IfxGeth_MdioControlCommandType;

/** \brief MDIO Transfer Type selection for Single / Continuous
 * Refer to the parameter definition of IfxGeth_Eth_initMdio() API for more info
 */
typedef enum
{
    IfxGeth_MdioModeSelectionType_singleTransfer     = 0, /**< \brief MDIO mode selection for MDIO single transfer */
    IfxGeth_MdioModeSelectionType_continuousTransfer = 1  /**< \brief MDIO mode selection for MDIO continuous transfer */
} IfxGeth_MdioModeSelectionType;

/** \brief MDIO PortN Device Status Interrupt  Enable / Disable
 * Refer the register bit fields of Ifx_GETH_PORT_CORE_MDIO_INTERRUPT_ENABLE for more info
 */
typedef enum
{
    IfxGeth_MdioPortN_deviceStatusIntr_disable = 0,  /**< \brief MDIO PortN Device Status Interrupt  Disable */
    IfxGeth_MdioPortN_deviceStatusIntr_enable        /**< \brief MDIO PortN Device Status Interrupt  Enable */
} IfxGeth_MdioPortN_deviceStatusIntr;

/** \brief MDIO PortN Link Status Interrupt Enable / Disable
 * Refer the register bit fields of Ifx_GETH_PORT_CORE_MDIO_INTERRUPT_ENABLE for more info
 */
typedef enum
{
    IfxGeth_MdioPortN_linkStatusIntr_disable = 0,  /**< \brief MDIO PortN Link Status Interrupt Disable */
    IfxGeth_MdioPortN_linkStatusIntr_enable        /**< \brief MDIO PortN Link Status Interrupt Enable */
} IfxGeth_MdioPortN_linkStatusIntr;

/** \brief MDIO Port Range selection
 * Definition in PORT_NX4_INDIRECT_CONTROL.B.PRS
 */
typedef enum
{
    IfxGeth_MdioPortRangeSel_0to3   = 0,  /**< \brief MDIO Port Range selection 0:3 */
    IfxGeth_MdioPortRangeSel_4to7   = 1,  /**< \brief MDIO Port Range selection 4:7 */
    IfxGeth_MdioPortRangeSel_8to11  = 2,  /**< \brief MDIO Port Range selection 8:11 */
    IfxGeth_MdioPortRangeSel_12to15 = 3,  /**< \brief MDIO Port Range selection 12:15 */
    IfxGeth_MdioPortRangeSel_16to19 = 4,  /**< \brief MDIO Port Range selection 16:19 */
    IfxGeth_MdioPortRangeSel_20to23 = 5,  /**< \brief MDIO Port Range selection 20:23 */
    IfxGeth_MdioPortRangeSel_24to27 = 6,  /**< \brief MDIO Port Range selection 24:27 */
    IfxGeth_MdioPortRangeSel_28to31 = 7   /**< \brief MDIO Port Range selection 28:31 */
} IfxGeth_MdioPortRangeSel;

/** \brief MDIO frame format Preamble field suppression Enable/Disable
 * Definition in SINGLE_COMMAND_CONTROL_DATA.B.PSE
 */
typedef enum
{
    IfxGeth_MdioPreambleSuppression_disable = 0,  /**< \brief MDIO frame format Preamble field suppression disable */
    IfxGeth_MdioPreambleSuppression_enable        /**< \brief MDIO frame format Preamble field suppression Enable */
} IfxGeth_MdioPreambleSuppression;

/** \brief MDIO Single Write Transfer Complete Interrupt Enable / Disable
 * Definition in Ifx_GETH_PORT_CORE_MDIO_INTERRUPT_ENABLE.B.SNGLCOMPIE
 */
typedef enum
{
    IfxGeth_MdioSingleWriteCmdComplIntr_disable = 0,  /**< \brief MDIO Single Write Transfer Complete Interrupt Disable */
    IfxGeth_MdioSingleWriteCmdComplIntr_enable        /**< \brief MDIO Single Write Transfer Complete Interrupt Enable */
} IfxGeth_MdioSingleWriteCmdComplIntr;

/** \brief MDIO frame Addr skip Enable / disable
 * Definition in SINGLE_COMMAND_CONTROL_DATA.B.SAADR
 */
typedef enum
{
    IfxGeth_MdioSkipAddrFrame_disable = 0,  /**< \brief MDIO frame Addr skip Disable */
    IfxGeth_MdioSkipAddrFrame_enable        /**< \brief MDIO frame Addr skip Enable */
} IfxGeth_MdioSkipAddrFrame;

/** \brief Threshold values in terms of maximum  counter value
 * Definition in MMC_CONTROL.B.MCT
 */
typedef enum
{
    IfxGeth_MmcCounterThreshold_25pcOfMaxVal = 1,  /**< \brief Threshold values at 25% of maximum counter value */
    IfxGeth_MmcCounterThreshold_50pcOfMaxVal = 2,  /**< \brief Threshold values at 50% of maximum counter value */
    IfxGeth_MmcCounterThreshold_75pcOfMaxVal = 3   /**< \brief Threshold values at 75% of maximum counter value */
} IfxGeth_MmcCounterThreshold;

/** \brief MTL interrupt flags
 * Definition in Q(i)_INTERRUPT_STATUS.B.TXUNFIS, Q(i)_INTERRUPT_STATUS.B.ABPSIS, Q(i)_INTERRUPT_STATUS.B.RXOVFISRXOVFIS and
 *  Q(i)_INTERRUPT_ENABLE.B.TXUNFIS, Q(i)_INTERRUPT_ENABLE.B.ABPSIS , Q(i)_INTERRUPT_ENABLE.B.RXOVFIS
 */
typedef enum
{
    IfxGeth_MtlInterruptFlag_txQueueUnderflow   = 0,  /**< \brief Transmit Queue Underflow */
    IfxGeth_MtlInterruptFlag_averageBitsPerSlot = 1,  /**< \brief Average Bits Per Slot */
    IfxGeth_MtlInterruptFlag_rxQueueOverflow    = 16  /**< \brief Receive Queue Overflow */
} IfxGeth_MtlInterruptFlag;

/** \brief MTL Queue ID
 */
typedef enum
{
    IfxGeth_MtlQueue_0 = 0,  /**< \brief Mtl Queue 0 */
    IfxGeth_MtlQueue_1 = 1,  /**< \brief Mtl Queue 1 */
    IfxGeth_MtlQueue_2 = 2,  /**< \brief Mtl Queue 2 */
    IfxGeth_MtlQueue_3 = 3,  /**< \brief Mtl Queue 3 */
    IfxGeth_MtlQueue_4 = 4,  /**< \brief Mtl Queue 4 */
    IfxGeth_MtlQueue_5 = 5,  /**< \brief Mtl Queue 5 */
    IfxGeth_MtlQueue_6 = 6,  /**< \brief Mtl Queue 6 */
    IfxGeth_MtlQueue_7 = 7   /**< \brief Mtl Queue 7 */
} IfxGeth_MtlQueue;

/** \brief MTL Receive Queue Threshold Control
 * Definition in MTL_RXQi_OPERATION_MODE.B.RTC
 */
typedef enum
{
    IfxGeth_MtlReceiveThreshold_64  = 0, /**< \brief Threshold value is 64 */
    IfxGeth_MtlReceiveThreshold_96  = 2, /**< \brief Threshold value is 96 */
    IfxGeth_MtlReceiveThreshold_128 = 3  /**< \brief Threshold value is 128 */
} IfxGeth_MtlReceiveThreshold;

/** \brief MTL Transmit Threshold Control
 * Definition in MTL_TXQi_OPERATION_MODE.B.TTC
 */
typedef enum
{
    IfxGeth_MtlTransmitThreshold_64  = 0,  /**< \brief Threshold value is 64 */
    IfxGeth_MtlTransmitThreshold_96  = 2,  /**< \brief Threshold value is 96 */
    IfxGeth_MtlTransmitThreshold_128 = 3,  /**< \brief Threshold value is 128 */
    IfxGeth_MtlTransmitThreshold_192 = 4,  /**< \brief Threshold value is 192 */
    IfxGeth_MtlTransmitThreshold_256 = 5,  /**< \brief Threshold value is 256 */
    IfxGeth_MtlTransmitThreshold_384 = 6,  /**< \brief Threshold value is 384 */
    IfxGeth_MtlTransmitThreshold_512 = 7   /**< \brief Threshold value is 512 */
} IfxGeth_MtlTransmitThreshold;

/** \brief PPS Fixed mode frequency \n
 * Definition in Ifx_GETH_PORT_CORE_MAC_PPS_CONTROL.B.PPSCTRL0_PPSCMD0. Refer to PPSCTRL0: PPS Output Frequency Control.
 */
typedef enum
{
    IfxGeth_PPSFrequency_1     = 0,   /**< \brief Default PPS pulses with frequency of 1 Hz */
    IfxGeth_PPSFrequency_2     = 1,   /**< \brief The binary rollover is 2 Hz, and the digital rollover is 1 Hz */
    IfxGeth_PPSFrequency_4     = 2,   /**< \brief The binary rollover is 4 Hz, and the digital rollover is 2 Hz */
    IfxGeth_PPSFrequency_8     = 3,   /**< \brief The binary rollover is 8 Hz, and the digital rollover is 4 Hz */
    IfxGeth_PPSFrequency_16    = 4,   /**< \brief The binary rollover is 16 Hz, and the digital rollover is 8 Hz */
    IfxGeth_PPSFrequency_32    = 5,   /**< \brief The binary rollover is 32 Hz, and the digital rollover is 16 Hz */
    IfxGeth_PPSFrequency_64    = 6,   /**< \brief The binary rollover is 64 Hz, and the digital rollover is 32 Hz */
    IfxGeth_PPSFrequency_128   = 7,   /**< \brief The binary rollover is 128 Hz, and the digital rollover is 64 Hz */
    IfxGeth_PPSFrequency_256   = 8,   /**< \brief The binary rollover is 256 Hz, and the digital rollover is 128 Hz */
    IfxGeth_PPSFrequency_512   = 9,   /**< \brief The binary rollover is 512 Hz, and the digital rollover is 256 Hz */
    IfxGeth_PPSFrequency_1024  = 10,  /**< \brief The binary rollover is 1024 Hz, and the digital rollover is 512 Hz */
    IfxGeth_PPSFrequency_2048  = 11,  /**< \brief The binary rollover is 2048 Hz, and the digital rollover is 1024 Hz */
    IfxGeth_PPSFrequency_4096  = 12,  /**< \brief The binary rollover is 4096 Hz, and the digital rollover is 2048 Hz */
    IfxGeth_PPSFrequency_8192  = 13,  /**< \brief The binary rollover is 8192 Hz, and the digital rollover is 4096 Hz */
    IfxGeth_PPSFrequency_16384 = 14,  /**< \brief The binary rollover is 16384 Hz, and the digital rollover is 8192 Hz */
    IfxGeth_PPSFrequency_32768 = 15   /**< \brief The binary rollover is 32768 Hz, and the digital rollover is 16384 Hz */
} IfxGeth_PPSFrequency;

/** \brief PPS Target Time Register Mode \n
 * Definition in Ifx_GETH_PORT_CORE_MAC_PPS_CONTROL.B.TRGTMODSEL0.
 */
typedef enum
{
    IfxGeth_PPSTargetTimeMode_interruptOnly      = 0,  /**< \brief Target Time registers are configured only for generating the Target Time Reached interrupt event. The Flexible PPS function must not be enabled in this mode. */
    IfxGeth_PPSTargetTimeMode_interruptAndSignal = 2,  /**< \brief Target Time registers are programmed for generating the Target Time Reached interrupt event and starting or stopping the PPS output signal generation */
    IfxGeth_PPSTargetTimeMode_signalOnly         = 3   /**< \brief Target Time registers are programmed only for starting or stopping the PPS output signal generation without generation of Target Time Reached interrupt event. */
} IfxGeth_PPSTargetTimeMode;

/** \brief External Phy Interface and Speed in Mbps
 */
typedef enum
{
    IfxGeth_PhyInterfaceMode_mii_10     = 0,   /**< \brief MII mode with speed of 10M */
    IfxGeth_PhyInterfaceMode_mii_100    = 1,   /**< \brief MII mode with speed of 100M */
    IfxGeth_PhyInterfaceMode_rmii_10    = 2,   /**< \brief RMII mode with speed of 10M */
    IfxGeth_PhyInterfaceMode_rmii_100   = 3,   /**< \brief RMII mode with speed of 100M */
    IfxGeth_PhyInterfaceMode_gmii_1000  = 6,   /**< \brief GMII mode with speed of 1000M */
    IfxGeth_PhyInterfaceMode_gmii_2500  = 10,  /**< \brief GMII mode with speed of 2500M */
    IfxGeth_PhyInterfaceMode_rgmii_10   = 7,   /**< \brief RGMII mode with speed of 10M */
    IfxGeth_PhyInterfaceMode_rgmii_100  = 8,   /**< \brief RGMII mode with speed of 100M */
    IfxGeth_PhyInterfaceMode_rgmii_1000 = 9,   /**< \brief RGMII mode with speed of 1000M */
    IfxGeth_PhyInterfaceMode_xgmii_2500 = 11,  /**< \brief XGMII mode with speed of 2500M */
    IfxGeth_PhyInterfaceMode_xgmii_5000 = 12   /**< \brief XGMII mode with speed of 5000M */
} IfxGeth_PhyInterfaceMode;

/** \brief GETH Ports\n
 */
typedef enum
{
    IfxGeth_Port_0 = 0,  /**< \brief GETH Port 0 */
    IfxGeth_Port_1 = 1   /**< \brief GETH Port 1 */
} IfxGeth_Port;

/** \brief GETH PORT Index
 */
typedef enum
{
    IfxGeth_PortIndex_0 = 0,  /**< \brief Geth Port 0 */
    IfxGeth_PortIndex_1 = 1   /**< \brief Geth Port 1 */
} IfxGeth_PortIndex;

/** \brief enum for Remote wake-up mode return status
 * Software enum
 */
typedef enum
{
    IfxGeth_RwkConfigStatus_success            = 0, /**< \brief Enum element for remote wake-up power down mode entry successful return */
    IfxGeth_RwkConfigStatus_timeoutError       = 1, /**< \brief Enum element for timeout error return */
    IfxGeth_RwkConfigStatus_invalidConfigError = 2  /**< \brief Enum element for remote wake-up mode invalid configuration return */
} IfxGeth_RwkConfigStatus;

/** \brief FIFO pointer reference for PMT Remote wake-up filter register's type
 * Definition in MAC_PMT_CONTROL_STATUS.B.RWKPTR
 */
typedef enum
{
    IfxGeth_RwkFilterRegType_crc0_1    = 0,  /**< \brief RWKPTR pointer reference value for register RWK_FILTER0_1_CRC */
    IfxGeth_RwkFilterRegType_cmd0_3    = 1,  /**< \brief RWKPTR pointer reference value for register RWK_FILTER0_3_COMMAND */
    IfxGeth_RwkFilterRegType_offset0_3 = 2,  /**< \brief RWKPTR pointer reference value for register RWK_FILTER0_3_OFFSET */
    IfxGeth_RwkFilterRegType_mask0     = 3,  /**< \brief RWKPTR pointer reference value for register RWK_FILTER0_BYTE_MASK */
    IfxGeth_RwkFilterRegType_mask1     = 4,  /**< \brief RWKPTR pointer reference value for register RWK_FILTER1_BYTE_MASK */
    IfxGeth_RwkFilterRegType_crc2_3    = 5,  /**< \brief RWKPTR pointer reference value for register RWK_FILTER2_3_CRC */
    IfxGeth_RwkFilterRegType_mask2     = 6,  /**< \brief RWKPTR pointer reference value for register RWK_FILTER2_BYTE_MASK */
    IfxGeth_RwkFilterRegType_mask3     = 7   /**< \brief RWKPTR pointer reference value for register RWK_FILTER3_BYTE_MASK */
} IfxGeth_RwkFilterRegType;

/** \brief Receive Arbitration Algorithm for Rx Queues\n
 * Definition in PORT0_MTL_OPERATION_MODE.B.RAA
 */
typedef enum
{
    IfxGeth_RxArbitrationAlgorithm_sp  = 0, /**< \brief Strict Priority */
    IfxGeth_RxArbitrationAlgorithm_wsp = 1  /**< \brief Weighted Strict Priority */
} IfxGeth_RxArbitrationAlgorithm;

/** \brief DMA Rx channel burst length
 * Use multiplier DMA_CH0_CONTROL.B.PBLX8 to go for longer bursts.
 */
typedef enum
{
    IfxGeth_RxBurstLength_1  = 1,   /**< \brief maximum burst length 1 */
    IfxGeth_RxBurstLength_2  = 2,   /**< \brief maximum burst length 2 */
    IfxGeth_RxBurstLength_4  = 4,   /**< \brief maximum burst length 4 */
    IfxGeth_RxBurstLength_8  = 8,   /**< \brief maximum burst length 8 */
    IfxGeth_RxBurstLength_16 = 16,  /**< \brief maximum burst length 16 */
    IfxGeth_RxBurstLength_32 = 32   /**< \brief maximum burst length 32 */
} IfxGeth_RxBurstLength;

/** \brief Rx DMA channel
 */
typedef enum
{
    IfxGeth_RxDmaChannel_0 = 0,  /**< \brief Rx Dma Channel 0 */
    IfxGeth_RxDmaChannel_1 = 1,  /**< \brief Rx Dma Channel 1 */
    IfxGeth_RxDmaChannel_2 = 2,  /**< \brief Rx Dma Channel 2 */
    IfxGeth_RxDmaChannel_3 = 3,  /**< \brief Rx Dma Channel 3 */
    IfxGeth_RxDmaChannel_4 = 4,  /**< \brief Rx Dma Channel 4 */
    IfxGeth_RxDmaChannel_5 = 5,  /**< \brief Rx Dma Channel 5 */
    IfxGeth_RxDmaChannel_6 = 6,  /**< \brief Rx Dma Channel 6 */
    IfxGeth_RxDmaChannel_7 = 7   /**< \brief Rx Dma Channel 7 */
} IfxGeth_RxDmaChannel;

/** \brief Rx MTL Queue/Channel ID
 */
typedef enum
{
    IfxGeth_RxMtlQueue_0 = 0,  /**< \brief Rx Queue 0 */
    IfxGeth_RxMtlQueue_1 = 1,  /**< \brief Rx Queue 1 */
    IfxGeth_RxMtlQueue_2 = 2,  /**< \brief Rx Queue 2 */
    IfxGeth_RxMtlQueue_3 = 3,  /**< \brief Rx Queue 3 */
    IfxGeth_RxMtlQueue_4 = 4,  /**< \brief Rx Queue 4 */
    IfxGeth_RxMtlQueue_5 = 5,  /**< \brief Rx Queue 5 */
    IfxGeth_RxMtlQueue_6 = 6,  /**< \brief Rx Queue 6 */
    IfxGeth_RxMtlQueue_7 = 7   /**< \brief Rx Queue 7 */
} IfxGeth_RxMtlQueue;

/** \brief Geth service request index
 */
typedef enum
{
    IfxGeth_ServiceRequest_DMA_0  = 0,   /**< \brief Service Request DMA Tx Channel 0 */
    IfxGeth_ServiceRequest_DMA_1  = 1,   /**< \brief Service Request DMA Tx Channel 1 */
    IfxGeth_ServiceRequest_DMA_2  = 2,   /**< \brief Service Request DMA Tx Channel 2 */
    IfxGeth_ServiceRequest_DMA_3  = 3,   /**< \brief Service Request DMA Tx Channel 3 */
    IfxGeth_ServiceRequest_DMA_4  = 4,   /**< \brief Service Request DMA Tx Channel 4 */
    IfxGeth_ServiceRequest_DMA_5  = 5,   /**< \brief Service Request DMA Tx Channel 5 */
    IfxGeth_ServiceRequest_DMA_6  = 6,   /**< \brief Service Request DMA Tx Channel 6 */
    IfxGeth_ServiceRequest_DMA_7  = 7,   /**< \brief Service Request DMA Tx Channel 7 */
    IfxGeth_ServiceRequest_DMA_8  = 8,   /**< \brief Service Request DMA Rx Channel 0 */
    IfxGeth_ServiceRequest_DMA_9  = 9,   /**< \brief Service Request DMA Rx Channel 1 */
    IfxGeth_ServiceRequest_DMA_10 = 10,  /**< \brief Service Request DMA Rx Channel 2 */
    IfxGeth_ServiceRequest_DMA_11 = 11,  /**< \brief Service Request DMA Rx Channel 3 */
    IfxGeth_ServiceRequest_DMA_12 = 12,  /**< \brief Service Request DMA Rx Channel 4 */
    IfxGeth_ServiceRequest_DMA_13 = 13,  /**< \brief Service Request DMA Rx Channel 5 */
    IfxGeth_ServiceRequest_DMA_14 = 14,  /**< \brief Service Request DMA Rx Channel 6 */
    IfxGeth_ServiceRequest_DMA_15 = 15,  /**< \brief Service Request DMA Rx Channel 7 */
    IfxGeth_ServiceRequest_PPS_0  = 16,  /**< \brief Service Request PPS 0 (Port 0 PPS 0) */
    IfxGeth_ServiceRequest_PPS_1  = 17,  /**< \brief Service Request PPS 1 (Port 0 PPS 1) */
    IfxGeth_ServiceRequest_PPS_2  = 18,  /**< \brief Service Request PPS 2 (Port 1 PPS 0) */
    IfxGeth_ServiceRequest_PPS_3  = 19,  /**< \brief Service Request PPS 3 (Port 1 PPS 1) */
    IfxGeth_ServiceRequest_INTR   = 20   /**< \brief Service Request INTR */
} IfxGeth_ServiceRequest;

/** \brief 3 bit Option for Source Address Insertion Control in Transmit Packets.
 * Definition in Tx Normal Descriptor TDES3.R.SAIC. Bit 25 of TDES3 (SAIC[2]) specifies the MAC Address Register (1 or 0) value that is used for Source Address insertion or replacement.
 */
typedef enum
{
    IfxGeth_SourceAddressControl_notIncluded            = 0,  /**< \brief Do not include the source address. */
    IfxGeth_SourceAddressControl_insertMacAddress0      = 1,  /**< \brief Insert source address as specified in MAC Address Register 0. For reliable transmission, the application must provide frames without source address. */
    IfxGeth_SourceAddressControl_replaceWithMacAddress0 = 2,  /**< \brief Replace source address with the one specified in MAC Address Register 0. For reliable transmission, the application must provide frames with source addresses. */
    IfxGeth_SourceAddressControl_insertMacAddress1      = 5,  /**< \brief Insert source address as specified in MAC Address Register 1. For reliable transmission, the application must provide frames without source address. */
    IfxGeth_SourceAddressControl_replaceWithMacAddress1 = 6   /**< \brief Replace source address with the one specified in MAC Address Register 1. For reliable transmission, the application must provide frames with source addresses. */
} IfxGeth_SourceAddressControl;

/** \brief Tagged PTP over Ethernet Packets Queuing Control\n
 * Definition in Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL1.B.TPQC
 */
typedef enum
{
    IfxGeth_TaggedPtpQueueControl_psrqNonAV = 0,  /**< \brief VLAN Tagged PTP over Ethernet packets are routed as generic VLAN Tagged packet (only for the non-AV enabled Rx Queues based on the PSRQ field) */
    IfxGeth_TaggedPtpQueueControl_ptpq      = 1,  /**< \brief VLAN Tagged PTP over Ethernet packets are routed to Rx Queue specified by PTPQ field (The Rx Queue can be enabled for AV or non-AV packets) */
    IfxGeth_TaggedPtpQueueControl_psrqAV    = 2   /**< \brief VLAN Tagged PTP over Ethernet packets are routed to only AV enabled Rx Queues and is based on the PSRQ field */
} IfxGeth_TaggedPtpQueueControl;

/** \brief DMA Tx channel burst length
 * Use multiplier DMA_CH0_CONTROL.B.PBLX8 to go for longer bursts.
 */
typedef enum
{
    IfxGeth_TxBurstLength_0  = 0,   /**< \brief not configured */
    IfxGeth_TxBurstLength_1  = 1,   /**< \brief maximum burst length 1 */
    IfxGeth_TxBurstLength_2  = 2,   /**< \brief maximum burst length 2 */
    IfxGeth_TxBurstLength_4  = 4,   /**< \brief maximum burst length 4 */
    IfxGeth_TxBurstLength_8  = 8,   /**< \brief maximum burst length 8 */
    IfxGeth_TxBurstLength_16 = 16,  /**< \brief maximum burst length 16 */
    IfxGeth_TxBurstLength_32 = 32   /**< \brief maximum burst length 32 */
} IfxGeth_TxBurstLength;

/** \brief Tx DMA channel
 */
typedef enum
{
    IfxGeth_TxDmaChannel_0 = 0,  /**< \brief Tx Dma Channel 0 */
    IfxGeth_TxDmaChannel_1 = 1,  /**< \brief Tx Dma Channel 1 */
    IfxGeth_TxDmaChannel_2 = 2,  /**< \brief Tx Dma Channel 2 */
    IfxGeth_TxDmaChannel_3 = 3,  /**< \brief Tx Dma Channel 3 */
    IfxGeth_TxDmaChannel_4 = 4,  /**< \brief Tx Dma Channel 4 */
    IfxGeth_TxDmaChannel_5 = 5,  /**< \brief Tx Dma Channel 5 */
    IfxGeth_TxDmaChannel_6 = 6,  /**< \brief Tx Dma Channel 6 */
    IfxGeth_TxDmaChannel_7 = 7   /**< \brief Tx Dma Channel 7 */
} IfxGeth_TxDmaChannel;

/** \brief Tx MTL Queue ID
 */
typedef enum
{
    IfxGeth_TxMtlQueue_0 = 0,  /**< \brief Tx Queue 0 */
    IfxGeth_TxMtlQueue_1 = 1,  /**< \brief Tx Queue 1 */
    IfxGeth_TxMtlQueue_2 = 2,  /**< \brief Tx Queue 2 */
    IfxGeth_TxMtlQueue_3 = 3,  /**< \brief Tx Queue 3 */
    IfxGeth_TxMtlQueue_4 = 4,  /**< \brief Tx Queue 4 */
    IfxGeth_TxMtlQueue_5 = 5,  /**< \brief Tx Queue 5 */
    IfxGeth_TxMtlQueue_6 = 6,  /**< \brief Tx Queue 6 */
    IfxGeth_TxMtlQueue_7 = 7   /**< \brief Tx Queue 7 */
} IfxGeth_TxMtlQueue;

/** \brief Traffic Class's Transmission Selection Algorithm for the MTL Tx Queues\n
 * Definition in Porti_MTL_TCn_ETS_Control.B.TSA
 */
typedef enum
{
    IfxGeth_TxTransmissionSelectionAlgorithm_sp  = 0,  /**< \brief Strict Priority */
    IfxGeth_TxTransmissionSelectionAlgorithm_cbs = 1,  /**< \brief Credit Based Shaper */
    IfxGeth_TxTransmissionSelectionAlgorithm_ets = 2   /**< \brief ETS Algorithm */
} IfxGeth_TxTransmissionSelectionAlgorithm;

/** \brief Option for VLAN Tag Inclusion Control in Transmit Packets.
 * Definition in Ifx_GETH_PORT_CORE_MAC_INNER_VLAN_INCL.B.VLC, Ifx_GETH_PORT_CORE_MAC_VLAN_INCL.B.VLC, Tx Context Descriptor TDES3.C.IVTIR and Tx Normal Descriptor TDES2.R.VTIR
 */
typedef enum
{
    IfxGeth_VlanTagInclusionControl_none        = 0, /**< \brief No VLAN tag deletion, insertion, or replacement. */
    IfxGeth_VlanTagInclusionControl_deletion    = 1, /**< \brief The MAC removes the VLAN type (bytes 17 and 18) and VLAN tag (bytes 19 and 20) of all transmitted packets with VLAN tags. */
    IfxGeth_VlanTagInclusionControl_insertion   = 2, /**< \brief The MAC inserts VLT in bytes 19 and 20 of the packet after inserting the Type value (0x8100 or 0x88a8) in bytes 17 and 18. This operation is performed on all transmitted packets, irrespective of whether they already have a VLAN tag.. */
    IfxGeth_VlanTagInclusionControl_replacement = 3  /**< \brief The MAC replaces VLT in bytes 19 and 20 of all VLAN-type transmitted packets (Bytes 17 and 18 are 0x8100 or 0x88a8).. */
} IfxGeth_VlanTagInclusionControl;

/** \brief Option for VLAN Tag Stripping for Received Packets.
 * Definition in GETH_PORT_CORE_MAC_VLAN_TAG_CTRL.B.EVLS and GETH_PORT_CORE_MAC_VLAN_TAG_CTRL.B.EIVLS
 */
typedef enum
{
    IfxGeth_VlanTagStripType_doNotStrip  = 0,  /**< \brief The VLAN Tag is not removed. */
    IfxGeth_VlanTagStripType_stripOnPass = 1,  /**< \brief Strip the tag only if it passes VLAN filters. */
    IfxGeth_VlanTagStripType_stripOnFail = 2,  /**< \brief Strip the tag only if it fails VLAN filters. */
    IfxGeth_VlanTagStripType_stripAlways = 3   /**< \brief The VLAN Tag is always removed. */
} IfxGeth_VlanTagStripType;

/** \} */

/** \brief Traffic Class Slot Count Values\n
 * Definition in Porti_MTL_TCn_ETS_Control.B.SLC
 */
typedef enum
{
    IfxGeth_TxSlotCount_1  = 0, /**< \brief 1 Slot */
    IfxGeth_TxSlotCount_2  = 1, /**< \brief 2 Slots */
    IfxGeth_TxSlotCount_4  = 2, /**< \brief 4 Slots */
    IfxGeth_TxSlotCount_8  = 3, /**< \brief 8 Slots */
    IfxGeth_TxSlotCount_16 = 4  /**< \brief 16 Slots */
} IfxGeth_TxSlotCount;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Geth_Std_DataStructures
 * \{ */
/** \brief Bit Fields of RDES0 Context Descriptor
 */
typedef struct
{
    uint32 RTSL : 32;       /**< \brief Receive Packet Timestamp Low */
} IfxGeth_RxContextDescr0_Bits;

/** \brief Bit Fields of RDES1 Context Descriptor
 */
typedef struct
{
    uint32 RTSH : 32;       /**< \brief Receive Packet Timestamp High */
} IfxGeth_RxContextDescr1_Bits;

/** \brief Bit Fields of RDES2 Context Descriptor
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxGeth_RxContextDescr2_Bits;

/** \brief Bit Fields of RDES3 Context Descriptor
 */
typedef struct
{
    uint32 PMT : 4;               /**< \brief PTP Message Type */
    uint32 TSA : 1;               /**< \brief Timestamp Available */
    uint32 reserved_5 : 1;        /**< \brief Reserved */
    uint32 TSD : 1;               /**< \brief Timestamp Dropped */
    uint32 reserved_7 : 23;       /**< \brief Reserved */
    uint32 CTXT : 1;              /**< \brief Receive Context Descriptor */
    uint32 OWN : 1;               /**< \brief Own Bit */
} IfxGeth_RxContextDescr3_Bits;

/** \brief Bit Fields of RDES0 in Read Format
 */
typedef struct
{
    uint32 BUF1AP : 32;       /**< \brief Header or Buffer 1 Address Pointer */
} IfxGeth_RxDescr0_RF_Bits;

/** \brief Bit Fields of RDES0 in Write back Format
 */
typedef struct
{
    uint32 OVT : 16;       /**< \brief Outer VLAN Tag */
    uint32 IVT : 16;       /**< \brief Inner VLAN Tag */
} IfxGeth_RxDescr0_WF_Bits;

/** \brief Bit Fields of RDES1 in Read Format
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxGeth_RxDescr1_RF_Bits;

/** \brief Bit Fields of RDES1 in Write back Format. The Status fields in write-back format are valid only for the last descriptor (RDES3[26] is set).
 */
typedef struct
{
    uint32 FRPLI : 32;       /**< \brief FRP last instruction. This field contains the FRP Last Instruction number where FRP result is generated. */
} IfxGeth_RxDescr1_WF_Bits;

/** \brief Bit Fields of RDES2 in Read Format
 */
typedef struct
{
    uint32 BUF2AP : 32;       /**< \brief Buffer 2 Address Pointer */
} IfxGeth_RxDescr2_RF_Bits;

/** \brief Bit Fields of RDES2 in Write back Format
 */
typedef struct
{
    uint32 AVTCP : 1;             /**< \brief AV Tagged Control Packet */
    uint32 AVTDP : 1;             /**< \brief AV Tagged Data Packet */
    uint32 HL : 8;                /**< \brief L3/L4 Header Length */
    uint32 FRPSM : 1;             /**< \brief Flexible Receive Parser Status MSB bit */
    uint32 reserved_11 : 4;       /**< \brief Reserved */
    uint32 VF : 1;                /**< \brief VLAN Filter Status */
    uint32 SAF : 1;               /**< \brief SA Address Filter Fail */
    uint32 DAF : 1;               /**< \brief Destination Address Filter Fail */
    uint32 reserved_18 : 1;       /**< \brief Reserved */
    uint32 MADRM : 8;             /**< \brief MAC Address Match Value */
    uint32 L3FM : 1;              /**< \brief Layer 3 Filter Match */
    uint32 L4FM : 1;              /**< \brief Layer 4 Filter Match */
    uint32 L3L4FM : 3;            /**< \brief Layer 3 and Layer 4 Filter Number Matched */
} IfxGeth_RxDescr2_WF_Bits;

/** \brief Bit Fields of RDES3 in Read Format
 */
typedef struct
{
    uint32 reserved_0 : 30;       /**< \brief Reserved */
    uint32 IOC : 1;               /**< \brief Interrupt on Completion */
    uint32 OWN : 1;               /**< \brief Own bit */
} IfxGeth_RxDescr3_RF_Bits;

/** \brief Bit Fields of RDES3 in Write back Format
 */
typedef struct
{
    uint32 PL : 14;               /**< \brief Packet Length */
    uint32 FRPSL : 1;             /**< \brief Flexible Receive Parser Status LSB bit */
    uint32 ES : 1;                /**< \brief Error Summary */
    uint32 ET_LT : 4;             /**< \brief Error if ES=1 else Length/Type Field */
    uint32 L34T : 4;              /**< \brief Layer3 or Layer4 packet Type */
    uint32 ETM : 1;               /**< \brief Ether Type Match */
    uint32 reserved_25 : 2;       /**< \brief Reserved */
    uint32 CDA : 1;               /**< \brief Context Descriptor Available */
    uint32 LD : 1;                /**< \brief Last Descriptor */
    uint32 FD : 1;                /**< \brief First Descriptor */
    uint32 CTXT : 1;              /**< \brief Receive Context Descriptor */
    uint32 OWN : 1;               /**< \brief Own Bit */
} IfxGeth_RxDescr3_WF_Bits;

/** \brief Bit Fields of TDES0 Context Descriptor
 */
typedef struct
{
    uint32 TTSL : 32;       /**< \brief Transmit Packet Timestamp Low */
} IfxGeth_TxContextDescr0_Bits;

/** \brief Bit Fields of TDES1 Context Descriptor
 */
typedef struct
{
    uint32 TTSH : 32;       /**< \brief Transmit Packet Timestamp High */
} IfxGeth_TxContextDescr1_Bits;

/** \brief Bit Fields of TDES2 Context Descriptor
 */
typedef struct
{
    uint32 reserved_0 : 16;       /**< \brief Reserved */
    uint32 IVT : 16;              /**< \brief Inner VLAN Tag */
} IfxGeth_TxContextDescr2_Bits;

/** \brief Bit Fields of TDES3 Context Descriptor
 */
typedef struct
{
    uint32 VT : 16;               /**< \brief VLAN Tag */
    uint32 VLTV : 1;              /**< \brief VLAN Tag Valid */
    uint32 IVLTV : 1;             /**< \brief Inner VLAN Tag Valid */
    uint32 IVTIR : 2;             /**< \brief Inner VLAN Tag Insert or Replace */
    uint32 reserved_20 : 5;       /**< \brief Reserved */
    uint32 PIDV : 1;              /**< \brief Packet ID valid */
    uint32 TCMSSV : 1;            /**< \brief One-Step Timestamp Correction Input or MSS Valid */
    uint32 OSTC : 1;              /**< \brief One-Step Timestamp Correction Enable */
    uint32 reserved_28 : 1;       /**< \brief Reserved */
    uint32 CDE : 1;               /**< \brief Context Descriptor Error */
    uint32 CTXT : 1;              /**< \brief Context Type */
    uint32 OWN : 1;               /**< \brief Own Bit */
} IfxGeth_TxContextDescr3_Bits;

/** \brief Bit Fields of TDES0 in Read Format
 */
typedef struct
{
    uint32 BUF1AP : 32;       /**< \brief Buffer 1 Address Pointer */
} IfxGeth_TxDescr0_RF_Bits;

/** \brief Bit Fields of TDES0 in Write-back Format
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxGeth_TxDescr0_WF_Bits;

/** \brief Bit Fields of TDES1 in Read Format
 */
typedef struct
{
    uint32 BUF2AP : 32;       /**< \brief Buffer 2 Pointer */
} IfxGeth_TxDescr1_RF_Bits;

/** \brief Bit Fields of TDES1 in Write-back Format
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxGeth_TxDescr1_WF_Bits;

/** \brief Bit Fields of TDES2 in Read Format
 */
typedef struct
{
    uint32 B1L : 14;       /**< \brief Header Length or Buffer 1 Length */
    uint32 VTIR : 2;       /**< \brief VLAN Tag Insertion or Replacement */
    uint32 B2L : 14;       /**< \brief Buffer 2 Length */
    uint32 TTSE : 1;       /**< \brief Transmit Timestamp Enable */
    uint32 IOC : 1;        /**< \brief Interrupt on Completion */
} IfxGeth_TxDescr2_RF_Bits;

/** \brief Bit Fields of TDES2 in Write-back Format
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxGeth_TxDescr2_WF_Bits;

/** \brief Bit Fields of TDES3 in Read Format
 */
typedef struct
{
    uint32 FL : 15;               /**< \brief Packet Length */
    uint32 reserved_15 : 1;       /**< \brief Reserved */
    uint32 CIC : 2;               /**< \brief Checksum Insertion Control */
    uint32 reserved_18 : 1;       /**< \brief Reserved */
    uint32 SLOTNUM : 4;           /**< \brief SLOTNUM: Slot Number Control Bits in AV Mode */
    uint32 SAIC : 3;              /**< \brief SA Insertion Control */
    uint32 CPC : 2;               /**< \brief CRC Pad Control */
    uint32 LD : 1;                /**< \brief Last Descriptor */
    uint32 FD : 1;                /**< \brief First Descriptor */
    uint32 CTXT : 1;              /**< \brief Context Type, this bit should be set to 1'b0 for normal descriptor */
    uint32 OWN : 1;               /**< \brief Own Bit */
} IfxGeth_TxDescr3_RF_Bits;

/** \brief Bit Fields of TDES3 in Write-back Format
 */
typedef struct
{
    uint32 reserved_0 : 27;       /**< \brief Reserved */
    uint32 DERR : 1;              /**< \brief Descriptor Error */
    uint32 LD : 1;                /**< \brief Last Descriptor */
    uint32 FD : 1;                /**< \brief First Descriptor */
    uint32 CTXT : 1;              /**< \brief Context Type */
    uint32 OWN : 1;               /**< \brief Own bit */
} IfxGeth_TxDescr3_WF_Bits;

/** \} */

/** \addtogroup IfxLld_Geth_Std_Unions
 * \{ */
/** \brief RDES0
 */
typedef union
{
    IfxGeth_RxDescr0_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_RxDescr0_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxGeth_RxContextDescr0_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_RxDescr0;

/** \brief RDES1
 */
typedef union
{
    IfxGeth_RxDescr1_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_RxDescr1_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxGeth_RxContextDescr1_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_RxDescr1;

/** \brief RDES2
 */
typedef union
{
    IfxGeth_RxDescr2_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_RxDescr2_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxGeth_RxContextDescr2_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_RxDescr2;

/** \brief RDES3
 */
typedef union
{
    IfxGeth_RxDescr3_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_RxDescr3_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxGeth_RxContextDescr3_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_RxDescr3;

/** \brief TDES0
 */
typedef union
{
    IfxGeth_TxDescr0_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_TxDescr0_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxGeth_TxContextDescr0_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_TxDescr0;

/** \brief TDES1
 */
typedef union
{
    IfxGeth_TxDescr1_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_TxDescr1_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxGeth_TxContextDescr1_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_TxDescr1;

/** \brief TDES2
 */
typedef union
{
    IfxGeth_TxDescr2_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_TxDescr2_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxGeth_TxContextDescr2_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_TxDescr2;

/** \brief TDES3
 */
typedef union
{
    IfxGeth_TxDescr3_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxGeth_TxDescr3_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxGeth_TxContextDescr3_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxGeth_TxDescr3;

/** \} */

/** \addtogroup IfxLld_Geth_Std_DataStructures
 * \{ */
/** \brief Structure for Bridge Dma Channel to Port map
 */
typedef struct
{
    IfxGeth_Port dmaChannel0 : 1;       /**< \brief port map for dma channel 0 */
    IfxGeth_Port dmaChannel1 : 1;       /**< \brief port map for dma channel 1 */
    IfxGeth_Port dmaChannel2 : 1;       /**< \brief port map for dma channel 2 */
    IfxGeth_Port dmaChannel3 : 1;       /**< \brief port map for dma channel 3 */
    IfxGeth_Port dmaChannel4 : 1;       /**< \brief port map for dma channel 4 */
    IfxGeth_Port dmaChannel5 : 1;       /**< \brief port map for dma channel 5 */
    IfxGeth_Port dmaChannel6 : 1;       /**< \brief port map for dma channel 6 */
    IfxGeth_Port dmaChannel7 : 1;       /**< \brief port map for dma channel 7 */
} IfxGeth_Bridge_DmaPortMap;

/** \brief MDIO frame format type selection between Clause22 or Clause45
 */
typedef struct
{
    uint32 Port0CL22 : 1;        /**< \brief Enable bit for PORT0 Clause22 frame format selection */
    uint32 Port1CL22 : 1;        /**< \brief Enable bit for PORT1 Clause22 frame format selection */
    uint32 Port2CL22 : 1;        /**< \brief Enable bit for PORT2 Clause22 frame format selection */
    uint32 Port3CL22 : 1;        /**< \brief Enable bit for PORT3 Clause22 frame format selection */
    uint32 Port4CL22 : 1;        /**< \brief Enable bit for PORT4 Clause22 frame format selection */
    uint32 Port5CL22 : 1;        /**< \brief Enable bit for PORT5 Clause22 frame format selection */
    uint32 Port6CL22 : 1;        /**< \brief Enable bit for PORT6 Clause22 frame format selection */
    uint32 Port7CL22 : 1;        /**< \brief Enable bit for PORT7 Clause22 frame format selection */
    uint32 Port8CL22 : 1;        /**< \brief Enable bit for PORT8 Clause22 frame format selection */
    uint32 Port9CL22 : 1;        /**< \brief Enable bit for PORT9 Clause22 frame format selection */
    uint32 Port10CL22 : 1;       /**< \brief Enable bit for PORT10 Clause22 frame format selection */
    uint32 Port11CL22 : 1;       /**< \brief Enable bit for PORT11 Clause22 frame format selection */
    uint32 Port12CL22 : 1;       /**< \brief Enable bit for PORT12 Clause22 frame format selection */
    uint32 Port13CL22 : 1;       /**< \brief Enable bit for PORT13 Clause22 frame format selection */
    uint32 Port14CL22 : 1;       /**< \brief Enable bit for PORT14 Clause22 frame format selection */
    uint32 Port15CL22 : 1;       /**< \brief Enable bit for PORT15 Clause22 frame format selection */
    uint32 Port16CL22 : 1;       /**< \brief Enable bit for PORT16 Clause22 frame format selection */
    uint32 Port17CL22 : 1;       /**< \brief Enable bit for PORT17 Clause22 frame format selection */
    uint32 Port18CL22 : 1;       /**< \brief Enable bit for PORT18 Clause22 frame format selection */
    uint32 Port19CL22 : 1;       /**< \brief Enable bit for PORT19 Clause22 frame format selection */
    uint32 Port20CL22 : 1;       /**< \brief Enable bit for PORT20 Clause22 frame format selection */
    uint32 Port21CL22 : 1;       /**< \brief Enable bit for PORT21 Clause22 frame format selection */
    uint32 Port22CL22 : 1;       /**< \brief Enable bit for PORT22 Clause22 frame format selection */
    uint32 Port23CL22 : 1;       /**< \brief Enable bit for PORT23 Clause22 frame format selection */
    uint32 Port24CL22 : 1;       /**< \brief Enable bit for PORT24 Clause22 frame format selection */
    uint32 Port25CL22 : 1;       /**< \brief Enable bit for PORT25 Clause22 frame format selection */
    uint32 Port26CL22 : 1;       /**< \brief Enable bit for PORT26 Clause22 frame format selection */
    uint32 Port27CL22 : 1;       /**< \brief Enable bit for PORT27 Clause22 frame format selection */
    uint32 Port28CL22 : 1;       /**< \brief Enable bit for PORT28 Clause22 frame format selection */
    uint32 Port29CL22 : 1;       /**< \brief Enable bit for PORT29 Clause22 frame format selection */
    uint32 Port30CL22 : 1;       /**< \brief Enable bit for PORT30 Clause22 frame format selection */
    uint32 Port31CL22 : 1;       /**< \brief Enable bit for PORT31 Clause22 frame format selection */
} IfxGeth_MdioClause22;

/** \brief MDIO Interrupt Enable Config
 */
typedef struct
{
    uint32 mdioPortNX4P0ConDisIE : 1;            /**< \brief Connect/Disconnect Event Interrupt (Port Nx4 Plus0) Enable */
    uint32 mdioPortNX4P1ConDisIE : 1;            /**< \brief Connect/Disconnect Event Interrupt (Port Nx4 Plus1) Enable */
    uint32 mdioPortNX4P2ConDisIE : 1;            /**< \brief Connect/Disconnect Event Interrupt (Port Nx4 Plus2) Enable */
    uint32 mdioPortNX4P3ConDisIE : 1;            /**< \brief Connect/Disconnect Event Interrupt (Port Nx4 Plus3) Enable */
    uint32 mdioPortNX4P0LnkStatusIE : 1;         /**< \brief Link Status Change Interrupt (Port Nx4 Plus0) Enable */
    uint32 mdioPortNX4P1LnkStatusIE : 1;         /**< \brief Link Status Change Interrupt (Port Nx4 Plus1) Enable */
    uint32 mdioPortNX4P2LnkStatusIE : 1;         /**< \brief Link Status Change Interrupt (Port Nx4 Plus2) Enable */
    uint32 mdioPortNX4P3LnkStatusIE : 1;         /**< \brief Link Status Change Interrupt (Port Nx4 Plus3) Enable */
    uint32 mdioPortNX4P0DeviceAliveIE : 1;       /**< \brief Device Present Status Change Interrupt (Port Nx4 Plus0) Enable */
    uint32 mdioPortNX4P1DeviceAliveIE : 1;       /**< \brief Device Present Status Change Interrupt (Port Nx4 Plus1) Enable */
    uint32 mdioPortNX4P2DeviceAliveIE : 1;       /**< \brief Device Present Status Change Interrupt (Port Nx4 Plus2) Enable */
    uint32 mdioPortNX4P3DeviceAliveIE : 1;       /**< \brief Device Present Status Change Interrupt (Port Nx4 Plus3) Enable */
    uint32 : 1;                                  /**< \brief Non configurable */
    uint32 mdioContinuousCompleteIE : 1;         /**< \brief Continuous Write Completion Interrupt Enable */
    uint32 : 18;                                 /**< \brief Non configurable */
} IfxGeth_MdioContinuousInterruptEnable;

/** \brief MDIO Continuous Scan Port Enable
 */
typedef struct
{
    uint32 mdioPort0ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port0 Enable */
    uint32 mdioPort1ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port1 Enable */
    uint32 mdioPort2ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port2 Enable */
    uint32 mdioPort3ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port3 Enable */
    uint32 mdioPort4ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port4 Enable */
    uint32 mdioPort5ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port5 Enable */
    uint32 mdioPort6ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port6 Enable */
    uint32 mdioPort7ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port7 Enable */
    uint32 mdioPort8ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port8 Enable */
    uint32 mdioPort9ScanEnable : 1;        /**< \brief MDIO Continuous Scan Port9 Enable */
    uint32 mdioPort10ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port10 Enable */
    uint32 mdioPort11ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port11 Enable */
    uint32 mdioPort12ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port12 Enable */
    uint32 mdioPort13ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port13 Enable */
    uint32 mdioPort14ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port14 Enable */
    uint32 mdioPort15ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port15 Enable */
    uint32 mdioPort16ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port16 Enable */
    uint32 mdioPort17ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port17 Enable */
    uint32 mdioPort18ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port18 Enable */
    uint32 mdioPort19ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port19 Enable */
    uint32 mdioPort20ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port20 Enable */
    uint32 mdioPort21ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port21 Enable */
    uint32 mdioPort22ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port22 Enable */
    uint32 mdioPort23ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port23 Enable */
    uint32 mdioPort24ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port24 Enable */
    uint32 mdioPort25ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port25 Enable */
    uint32 mdioPort26ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port26 Enable */
    uint32 mdioPort27ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port27 Enable */
    uint32 mdioPort28ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port28 Enable */
    uint32 mdioPort29ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port29 Enable */
    uint32 mdioPort30ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port 30 Enable */
    uint32 mdioPort31ScanEnable : 1;       /**< \brief MDIO Continuous Scan Port31 Enable */
} IfxGeth_MdioContinuousScanPortEnable;

typedef struct
{
    __IO Ifx_UReg_32Bit TSA : 2;                /**< \brief [1:0] Transmission Selection Algorithm (rw) */
    __I Ifx_UReg_32Bit  CBSEN : 1;              /**< \brief [2:2] Credit Based Shaper Enable (r) */
    __IO Ifx_UReg_32Bit CC : 1;                 /**< \brief [3:3] Credit Control (rw) */
    __IO Ifx_UReg_32Bit SLC : 3;                /**< \brief [6:4] Slot Count (rw) */
    __I Ifx_UReg_32Bit  RESERVED_31_7 : 25;     /**< \brief [31:7] Reserved (r) */
} IfxGeth_PortMtlTcEtsControl_Bits;

typedef struct
{
    __IO Ifx_UReg_32Bit HC : 29;                /**< \brief [28:0] hiCredit Value (rw) */
    __I Ifx_UReg_32Bit  RESERVED_31_29 : 3;     /**< \brief [31:29] Reserved (r) */
} IfxGeth_PortMtlTcHiCredit_Bits;

typedef struct
{
    __IO Ifx_UReg_32Bit LC : 29;                /**< \brief [28:0] loCredit Value (rw) */
    __I Ifx_UReg_32Bit  RESERVED_31_29 : 3;     /**< \brief [31:29] Reserved (r) */
} IfxGeth_PortMtlTcLoCredit_Bits;

typedef struct
{
    __IO Ifx_UReg_32Bit QW : 21;                 /**< \brief [20:0] idleSlopeCredit, Quantum or Weights (rw) */
    __I Ifx_UReg_32Bit  RESERVED_31_21 : 11;     /**< \brief [31:21] Reserved (r) */
} IfxGeth_PortMtlTcQuantumWeight_Bits;

typedef struct
{
    __IO Ifx_UReg_32Bit SSC : 16;                /**< \brief [15:0] sendSlopeCredit Value (rw) */
    __I Ifx_UReg_32Bit  RESERVED_31_16 : 16;     /**< \brief [31:16] Reserved (r) */
} IfxGeth_PortMtlTcSendSlopeCredit_Bits;

/** \brief Rx Descriptor
 */
typedef struct
{
    IfxGeth_RxDescr0 RDES0;       /**< \brief Rx Descriptor DWORD 0 */
    IfxGeth_RxDescr1 RDES1;       /**< \brief Rx Descriptor DWORD 1 */
    IfxGeth_RxDescr2 RDES2;       /**< \brief Rx Descriptor DWORD 2 */
    IfxGeth_RxDescr3 RDES3;       /**< \brief Rx Descriptor DWORD 3 */
} IfxGeth_RxDescr;

/** \brief Tx Descriptor
 */
typedef struct
{
    IfxGeth_TxDescr0 TDES0;       /**< \brief Tx Descriptor DWORD 0 */
    IfxGeth_TxDescr1 TDES1;       /**< \brief Tx Descriptor DWORD 1 */
    IfxGeth_TxDescr2 TDES2;       /**< \brief Tx Descriptor DWORD 2 */
    IfxGeth_TxDescr3 TDES3;       /**< \brief Tx Descriptor DWORD 3 */
} IfxGeth_TxDescr;

/** \brief All TXQs, RXCs and Tx forward path Enable config
 *  Refer to BRIDGE.PORT_0_CONTROL Register
 */
typedef struct
{
    uint8 txQueues;                /**< \brief enable all TxQs */
    uint8 rxChannels;              /**< \brief enable all RxCs */
    uint8 txForwardingPaths;       /**< \brief enable the TxQs for forwarding TRUE: Port-Port Forwarding path, FALSE: Normal Path to Host DMA */
} IfxGeth_TxQRxCEnableAllConfig;

/** \brief Individual TXQ, RXC and Tx Forward Path Enable config
 *  Refer to BRIDGE.PORT_0_CONTROL Register
 */
typedef struct
{
    uint8 txQueue0 : 1;                 /**< \brief enable TxQ0 */
    uint8 txQueue1 : 1;                 /**< \brief enable TxQ1 */
    uint8 txQueue2 : 1;                 /**< \brief enable TxQ2 */
    uint8 txQueue3 : 1;                 /**< \brief enable TxQ3 */
    uint8 txQueue4 : 1;                 /**< \brief enable TxQ4 */
    uint8 txQueue5 : 1;                 /**< \brief enable TxQ5 */
    uint8 txQueue6 : 1;                 /**< \brief enable TxQ6 */
    uint8 txQueue7 : 1;                 /**< \brief enable TxQ7 */
    uint8 rxChannel0 : 1;               /**< \brief enable RxC0 */
    uint8 rxChannel1 : 1;               /**< \brief enable RxC1 */
    uint8 rxChannel2 : 1;               /**< \brief enable RxC2 */
    uint8 rxChannel3 : 1;               /**< \brief enable RxC3 */
    uint8 rxChannel4 : 1;               /**< \brief enable RxC4 */
    uint8 rxChannel5 : 1;               /**< \brief enable RxC5 */
    uint8 rxChannel6 : 1;               /**< \brief enable RxC6 */
    uint8 rxChannel7 : 1;               /**< \brief enable RxC7 */
    uint8 txForwardingQueue0 : 1;       /**< \brief enable TxQ0 as forwarding path */
    uint8 txForwardingQueue1 : 1;       /**< \brief enable TxQ1 as forwarding path */
    uint8 txForwardingQueue2 : 1;       /**< \brief enable TxQ2 as forwarding path */
    uint8 txForwardingQueue3 : 1;       /**< \brief enable TxQ3 as forwarding path */
    uint8 txForwardingQueue4 : 1;       /**< \brief enable TxQ4 as forwarding path */
    uint8 txForwardingQueue5 : 1;       /**< \brief enable TxQ5 as forwarding path */
    uint8 txForwardingQueue6 : 1;       /**< \brief enable TxQ6 as forwarding path */
    uint8 txForwardingQueue7 : 1;       /**< \brief enable TxQ7 as forwarding path */
} IfxGeth_TxQRxCEnableConfig;

/** \brief Configuration Structure for assignment of Rx Vlan packet with given priorities to an Rx Queue.
 * Multiple bits (packets with different priorities) can be enabled for a particular queue. Must be mutually exclusive among different queues.
 * Refer to Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL2 and Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL3 SFRs for more info.
 */
typedef struct
{
    uint8 priorityTag0 : 1;     /**< \brief TRUE: Vlan Packet with USP = 0, is allocated to this Rx Queue. */
    uint8 priorityTag1 : 1;     /**< \brief TRUE: Vlan Packet with USP = 1, is allocated to this Rx Queue. */
    uint8 priorityTag2 : 1;     /**< \brief TRUE: Vlan Packet with USP = 2, is allocated to this Rx Queue. */
    uint8 priorityTag3 : 1;     /**< \brief TRUE: Vlan Packet with USP = 3, is allocated to this Rx Queue. */
    uint8 priorityTag4 : 1;     /**< \brief TRUE: Vlan Packet with USP = 4, is allocated to this Rx Queue. */
    uint8 priorityTag5 : 1;     /**< \brief TRUE: Vlan Packet with USP = 5, is allocated to this Rx Queue. */
    uint8 priorityTag6 : 1;     /**< \brief TRUE: Vlan Packet with USP = 6, is allocated to this Rx Queue. */
    uint8 priorityTag7 : 1;     /**< \brief TRUE: Vlan Packet with USP = 7, is allocated to this Rx Queue. */
} IfxGeth_VlanPsrqConfig;

/** \} */

/** \addtogroup IfxLld_Geth_Std_DataStructures
 * \{ */
/** \brief PROT and APU configuration
 */
typedef struct
{
    IfxApProt_ProtConfig protseConfig;          /**< \brief PROTSE configurations */
    IfxApApu_ApuConfig   apuGlobalConfig;       /**< \brief GLOBAL APU Configurations */
    IfxApApu_ApuConfig   apuMac0Config;         /**< \brief MAC0 APU Configurations */
    IfxApApu_ApuConfig   apuMac1Config;         /**< \brief MAC1 APU Configurations */
    IfxApApu_ApuConfig   apuCh0Config;          /**< \brief Channel 0 APU Configurations */
    IfxApApu_ApuConfig   apuCh1Config;          /**< \brief Channel 1 APU Configurations */
    IfxApApu_ApuConfig   apuCh2Config;          /**< \brief Channel 2 APU Configurations */
    IfxApApu_ApuConfig   apuCh3Config;          /**< \brief Channel 3 APU Configurations */
    IfxApApu_ApuConfig   apuCh4Config;          /**< \brief Channel 4 APU Configurations */
    IfxApApu_ApuConfig   apuCh5Config;          /**< \brief Channel 5 APU Configurations */
    IfxApApu_ApuConfig   apuCh6Config;          /**< \brief Channel 6 APU Configurations */
    IfxApApu_ApuConfig   apuCh7Config;          /**< \brief Channel 7 APU Configurations */
} IfxGeth_ApConfig;

/** \brief Structure for Bridge Interrupt Flags
 */
typedef struct
{
    uint8 dma : 1;            /**< \brief DMA Interrupt Status */
    uint8 port1MTL : 1;       /**< \brief Port 1 MTL Interrupt Status */
    uint8 port1MAC : 1;       /**< \brief Port 1 MAC Interrupt Status */
    uint8 port0MTL : 1;       /**< \brief Port 0 MTL Interrupt Status */
    uint8 port0MAC : 1;       /**< \brief Port 1 MAC Interrupt Status */
} IfxGeth_Bridge_InterruptStatusFlags;

/** \brief DMA channel interrupt flag
 * Definition in DMA.CH(i).INTERRUPT_ENABLE register
 */
typedef struct
{
    boolean transmitInterrupt;              /**< \brief Transmit interrupt */
    boolean transmitStop;                   /**< \brief Transmit stopped */
    boolean txBufferUnavailable;            /**< \brief Transmit buffer unavailable */
    boolean receiveInterrupt;               /**< \brief Receive interrupt */
    boolean rxBufferUnavailable;            /**< \brief Receive buffer unavailable */
    boolean receiveStop;                    /**< \brief Receive stopped */
    boolean descrDefinitionError;           /**< \brief Descriptor Definition Error */
    boolean fatalBusError;                  /**< \brief Fatal Bus Error */
    boolean contextDescrError;              /**< \brief Context descriptor Error */
    boolean abnormalInterruptSummary;       /**< \brief Abnormal Interrupt Summary */
    boolean normalInterruptSummary;         /**< \brief Normal Interrupt Summary */
} IfxGeth_Eth_DmaChannelInterruptFlags;

/** \brief EEE LPI Mode TX config
 *  Definition in MAC_LPI_CONTROL_STATUS, MAC_LPI_TIMERS_CONTROL, MAC_LPI_AUTO_ENTRY_TIMER Register's
 */
typedef struct
{
    boolean lpiModeEnable;                 /**< \brief TRUE: To enter the EEE LPI TX Mode FALSE: To exit the EEE LPI TX Mode */
    boolean lpiInterruptEnable;            /**< \brief TRUE: Enable, FALSE: Disable the interrupt for LPI entry/exit */
    boolean lpiTxClkGateEnable;            /**< \brief TRUE: Enable, FALSE: Disable the TX clock gating when in LPI mode */
    boolean lpiPhyStatusDisable;           /**< \brief True: TX MAC ignores the PHY status received to XGMII/GMII an uses the PLS (to be configured by the application) bit as status  FALSE : Uses the PHY status received through XGMII/GMII */
    boolean lpiAutoTxEnable;               /**< \brief TRUE: Enable, FALSE: Disables Auto entry/exit to EEE LPI TX Mode */
    boolean lpiAutoReEntryEnable;          /**< \brief TRUE: Enable, FALSE: Disable Auto Re-entry/exit to EEE LPI TX Mode Note: Config of this param is valid only if lpiAutoTxEnable = TRUE */
    boolean lpiAxiEnable;                  /**< \brief TRUE: Enable, FALSE: Disable AXI LPI, Note: This parameter should be TRUE for other AXI LPI related param to be valid */
    boolean lpiAxiAutoEnable;              /**< \brief TRUE: Enable, FALSE: Disable AXI Auto Enable, Note: This parameter is valid only if lpiAxiEnable = TRUE */
    boolean lpiAxiExitPacketSelect;        /**< \brief TRUE: Exit's the AXI LPI mode only when remote/magic packet is received, FALSE: Exit's the AXI LPI mode when any packet is received */
    uint8   lpiAxiEntryNumClkCycles;       /**< \brief Number of system clock cycles for AXI LPI Entry wait (Max configurable value: 0x0F), Note: Entry Wait time = Number of clock cycles programmed X 256 */
    uint16  lpiModeExitWaitTime;           /**< \brief wait time to Exit the LPI mode  Note : MAC_LPI_TIMERS_CONTROL.B.TWT is 16-bit(microseconds) timer */
    uint32  lpiModeEntryWaitTime;          /**< \brief wait time to Enter the LPI mode If lpiAutoReEntryEnable is FALSE : MAC_LPI_TIMERS_CONTROL.B.LST a 10-bit(in milliseconds) timer; TRUE : MAC_LPI_TIMERS_CONTROL.B.LPIET a 17-bit(microseconds) timer are used resp */
} IfxGeth_Eth_LpiConfig;

/** \brief Read EEE LPI Mode entry/exit status bit fields
 *  Definition in MAC_LPI_CONTROL_STATUS Register
 */
typedef struct
{
    boolean lpiTxEntry;         /**< \brief TRUE: MAC TX has entered the LPI mode FALSE: MAC TX is in Normal mode */
    boolean lpiTxExit;          /**< \brief TRUE: MAC TX has exited the LPI mode  FALSE: MAC TX still in LPI mode */
    boolean lpiRxEntry;         /**< \brief TRUE: MAC RX has entered the LPI mode FALSE: MAC RX is in Normal mode */
    boolean lpiRxExit;          /**< \brief TRUE: MAC RX has exited the LPI mode  FALSE: MAC RX still in LPI mode */
    boolean lpiTxPattern;       /**< \brief TRUE: MAC TX is transmitting the LPI patterns FALSE: Normal patterns */
    boolean lpiRxPattern;       /**< \brief TRUE: MAC RX is receiving the LPI patterns FALSE: Normal patterns */
    boolean lpiInterrupt;       /**< \brief TRUE: Interrupt for EEE LPI is asserted FALSE: Interrupt for the EEE LPI is de-asserted */
} IfxGeth_Eth_LpiStatus;

/** \brief Power management Mode status bit fields
 *  Definition in MAC_PMT_CONTROL_STATUS Register
 */
typedef struct
{
    boolean                  pmtMagicPacketRx;         /**< \brief TRUE: Magic packet received by the MAC FALSE: MAC in power-down mode */
    boolean                  pmtRwkPacketRx;           /**< \brief TRUE: Remote wake-up packet received by the MAC FALSE: MAC in power-down mode */
    boolean                  pmtInterruptStatus;       /**< \brief TRUE: Interrupt status when magic/remote wake-up packet is received by the MAC FALSE: No interrupt */
    IfxGeth_RwkFilterRegType pmtRwkRegPtr;             /**< \brief FIFO Pointer reference for PMT remote wake-up register's */
} IfxGeth_Eth_PmtStatus;

/** \brief MAC interrupt flags
 *  Definition in MAC_INTERRUPT_ENABLE register
 */
typedef struct
{
    boolean linkStatusChange;       /**< \brief Link status change */
    boolean powerMgmt;              /**< \brief Power management */
    boolean lowPowerIdle;           /**< \brief low power idle mode */
    boolean timeStamp;              /**< \brief time stamp */
    boolean txErrorStatus;          /**< \brief transmit Error */
    boolean rxErrorStatus;          /**< \brief Receive Error */
    boolean framePreEmption;        /**< \brief Frame Preemption */
} IfxGeth_MacInterruptFlag;

/** \brief MDIO Device in use config
 */
typedef struct
{
    uint32 : 1;                         /**< \brief Non configurable bit field */
    uint32 PmdPmaDeviceInUse : 1;       /**< \brief PMA Device is in Use */
    uint32 WisDeviceInUse : 1;          /**< \brief WIS Device is in Use */
    uint32 PcsDeviceInUse : 1;          /**< \brief PCS Device is in Use */
    uint32 PhyxsDeviceInUse : 1;        /**< \brief PHYXS Device is in Use */
    uint32 DtexsDeviceInUse : 1;        /**< \brief DTEXS Device is in Use */
    uint32 TcDeviceInUse : 1;           /**< \brief TC Device is in Use */
    uint32 : 23;                        /**< \brief Non configurable bit field */
    uint32 Vsd1DeviceInUse : 1;         /**< \brief VSD1 Device is in Use */
    uint32 Vsd2DeviceInUse : 1;         /**< \brief VSD2 Device is in Use */
} IfxGeth_MdioDeviceInUse;

/** \brief configuration for indirect Read/write transfer to L3/L4 register's
 * Refer to MAC_L3_L4_CONTROL#(i) and  MAC_L3_L4_ADDRESS_CONTROL register's for more info
 */
typedef struct
{
    IfxGeth_L3L4FilterCtrlTransferType transferType;           /**< \brief configure the indirect Register read/write transfer */
    uint32                             regReadWriteData;       /**< \brief configure the data to be read/write from the indirect access register's */
    IfxGeth_L3L4FilterNum              filterNum;              /**< \brief configure the L3/L4 filter number to be used */
    IfxGeth_L3L4FilterRegType          filterRegType;          /**< \brief configure the L3/L4 indirect register type to be accessed */
} IfxGeth_ReadWriteL3L4RegConfig;

/** \brief Rx Descriptor List
 */
typedef struct
{
    volatile IfxGeth_RxDescr descr[IFXGETH_MAX_RX_DESCRIPTORS];       /**< \brief list of RX descriptors */
} IfxGeth_RxDescrList;

/** \brief Tx Context Descriptor Configurations
 */
typedef struct
{
    uint64                          timeStamp64;                    /**< \brief 64 bit time stamp value for configuring TTSL and TTSH */
    boolean                         oneStepTimeStampEnable;         /**< \brief True: Configure bits related to one step timestamp (TTSL, TTSH, OSTC, TCMSSV), False: Bits related to one step Timestamp are not configured */
    boolean                         twoStepTimeStampEnable;         /**< \brief True: Configure bits related to two step timestamp (TTSL[0:9] as Packet ID, PIDV), False: Bits related to two step Timestamp are not configured */
    uint16                          twoStepTimeStampPacketID;       /**< \brief 10 bit packet ID for configuring TTSL[0:9] for two step timestamp */
    uint16                          vlanTag;                        /**< \brief 16 bit vlan Tag for configuring VT of TDES3. Note: VLTI bit of the MAC_VLAN_Incl register must be set. When configured using API IfxGeth_Eth_txVlanTagInclusionControl, the tag source must be Tx Descriptor (tagSource = 1) */
    boolean                         vlanTagEnable;                  /**< \brief TRUE: vlanTag is valid and must be configured, FALSE: vlanTag is not valid */
    IfxGeth_VlanTagInclusionControl innerVlanTagControl;            /**< \brief Option for inner vlan inclusion control */
    uint16                          innerVlanTag;                   /**< \brief 16 bit inner vlan Tag for configuring IVT of TDES2. Note: VLTI bit of the MAC_INNER_VLAN_Incl register must be set. When configured using API IfxGeth_Eth_txVlanTagInclusionControl, the tag source must be Tx Descriptor (tagSource = 1) */
    boolean                         innerVlanTagEnable;             /**< \brief TRUE: innerVlanTag is valid and must be configured, FALSE: innerVlanTag is not valid */
} IfxGeth_TxContextDescriptorConfig;

/** \brief Tx Descriptor List
 */
typedef struct
{
    volatile IfxGeth_TxDescr descr[IFXGETH_MAX_TX_DESCRIPTORS];       /**< \brief list of TX descriptors */
} IfxGeth_TxDescrList;

/** \} */

/** \addtogroup IfxLld_Geth_Std_Unions
 * \{ */
/** \brief This union contains dma channel to port map. In addition it allows to write and read to/from all dma port selection bits at once via the dmaPortMapAll member.
 */
typedef union
{
    uint8                     dmaPortMapAll;       /**< \brief 8 bit port map member for all dma channels together */
    IfxGeth_Bridge_DmaPortMap channelmap;          /**< \brief port map for individual dma channels 0-7 */
} IfxGeth_Bridge_DmaPortMapUnion;

/** \brief Access Union for mdioClause22 datatype
 */
typedef union
{
    uint32               mdioClause22All;       /**< \brief 32-bit access to mdioClause22 type variable */
    IfxGeth_MdioClause22 mdioClause22;          /**< \brief Bit wise access to mdioClauss22 type variable */
} IfxGeth_MdioClause22Union;

/** \brief Access Union for MdioContinuousInterruptEnable datatype
 */
typedef union
{
    uint32                                mdioContinuousInterruptEnableAll;       /**< \brief 32-bit access to MdioContinuousInterruptEnable type variable */
    IfxGeth_MdioContinuousInterruptEnable mdioContinuousInterruptEnable;          /**< \brief Bit wise access to MdioContinuousInterruptEnable type variable */
} IfxGeth_MdioContinuousInterruptEnableUnion;

/** \brief Access Union for MdioContinuousScanPortEnable datatype
 */
typedef union
{
    uint32                               mdioContinuousScanPortEnableAll;       /**< \brief 32-bit access to mdioContinuousScanPortEnable type variable */
    IfxGeth_MdioContinuousScanPortEnable mdioContinuousScanPortEnable;          /**< \brief Bit wise access to MdioDeviceInUse type variable */
} IfxGeth_MdioContinuousScanPortEnableUnion;

/** \brief Access Union for MdioDeviceInUse datatype
 */
typedef union
{
    uint32                                          mdioDeviceInUseAll;       /**< \brief 32-bit access to MdioDeviceInUse type variable */
    Ifx_GETH_PORT_CORE_MDIO_PORTNX4P2_DEVICE_IN_USE mdioDeviceInUse;          /**< \brief Bit wise access to MdioDeviceInUse type variable */
} IfxGeth_MdioDeviceInUseUnion;

typedef union
{
    Ifx_UReg_32Bit                   U;       /**< \brief Unsigned access */
    IfxGeth_PortMtlTcEtsControl_Bits B;       /**< \brief Bitfield access */
} IfxGeth_PortMtlTcEtsControl;

typedef union
{
    Ifx_UReg_32Bit                 U;       /**< \brief Unsigned access */
    IfxGeth_PortMtlTcHiCredit_Bits B;       /**< \brief Bitfield access */
} IfxGeth_PortMtlTcHiCredit;

typedef union
{
    Ifx_UReg_32Bit                 U;       /**< \brief Unsigned access */
    IfxGeth_PortMtlTcLoCredit_Bits B;       /**< \brief Bitfield access */
} IfxGeth_PortMtlTcLoCredit;

typedef union
{
    Ifx_UReg_32Bit                      U;       /**< \brief Unsigned access */
    IfxGeth_PortMtlTcQuantumWeight_Bits B;       /**< \brief Bitfield access */
} IfxGeth_PortMtlTcQuantumWeight;

typedef union
{
    Ifx_UReg_32Bit                        U;       /**< \brief Unsigned access */
    IfxGeth_PortMtlTcSendSlopeCredit_Bits B;       /**< \brief Bitfield access */
} IfxGeth_PortMtlTcSendSlopeCredit;

/** \brief Union of IfxGeth_TxQRxCEnableConfig and IfxGeth_TxQRxCEnableAllConfig
 */
typedef union
{
    IfxGeth_TxQRxCEnableConfig    enable;          /**< \brief access individual tx queues and rx channels */
    IfxGeth_TxQRxCEnableAllConfig enableAll;       /**< \brief access all tx queues together and all rx channels together */
} IfxGeth_TxQRxCEnableConfigUnion;

typedef union
{
    IfxGeth_VlanPsrqConfig I;       /**< \brief Individual Priority map */
    uint8                  F;       /**< \brief Full priority map */
} IfxGeth_VlanPsrqConfigUnion;

/** \} */

/** \addtogroup IfxLld_Geth_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the status of whether clock for GETH module is enabled or disabled
 * \param gethSFR Pointer to GETH register base address
 * \return Status:\n
 * TRUE : if module is enabled\n
 * FALSE : if module is disabled
 */
IFX_INLINE boolean IfxGeth_isModuleEnabled(Ifx_GETH *gethSFR);

/** \brief Applies a software reset of MAC and DMA controller
 * \param gethSFR Pointer to GETH register base address
 * \return None
 */
IFX_INLINE void IfxGeth_Dma_applySoftwareReset(Ifx_GETH *gethSFR);

/** \brief sets the register clear logic for Bridge Forward Overflow Status and Bridge DPP FSM Interrupt Status Registers
 * \param gethSFR Pointer to GETH register base address
 * \param enable TRUE: corresponding status bit will be cleared on write of 1, FALSE : status bitfield will be cleared on read
 * \return None
 */
IFX_INLINE void IfxGeth_Bridge_setStatusRegisterClearLogic(Ifx_GETH *gethSFR, boolean enable);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disables the clock for GETH module
 * \param gethSFR Pointer to GETH register base address
 * \return None
 */
IFX_EXTERN void IfxGeth_disableModule(Ifx_GETH *gethSFR);

/** \brief Enables the clock for GETH module
 * \param gethSFR Pointer to GETH register base address
 * \return None
 */
IFX_EXTERN void IfxGeth_enableModule(Ifx_GETH *gethSFR);

/** \brief resets Ethernet kernel
 * \param gethSFR Pointer to GETH register base address
 * \return None
 */
IFX_EXTERN void IfxGeth_resetModule(Ifx_GETH *gethSFR);

/** \brief Returns the Src Pointer of the selected GETH service request node
 * \param serviceRequest Service Request number
 * \return pointer to Src register
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxGeth_getSrcPointer(IfxGeth_ServiceRequest serviceRequest);

/** \brief Initialize the PROTs and APUs with default configuration
 * \param config Configuration pointer for the Access Protection
 * \return None
 */
IFX_EXTERN void IfxGeth_initApConfig(IfxGeth_ApConfig *config);

/** \brief Initialize the PORTs and APU
 * \param gethSFR GETH module pointer
 * \param config Configuration pointer to the AP
 * \return None
 */
IFX_EXTERN void IfxGeth_initAp(Ifx_GETH *gethSFR, IfxGeth_ApConfig *config);

/** \brief Configures access to all masters to all ACCENs in GETH in the device
 * \param apConfig pointer to configuration structure.
 * \return None
 */
IFX_EXTERN void IfxGeth_configureAccessToGeth(IfxApApu_ApuConfig *apConfig);

/** \brief Initialize the GETH Port Mode in the bridge
 * \param gethSFR GETH module pointer
 * \param mode Mode Configuration options
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_setPortMode(Ifx_GETH *gethSFR, IfxGeth_BridgePortMode mode);

/** \brief Initialize the same port loopback mode in the bridge
 * \param gethSFR GETH module pointer
 * \param loopbackEnableValue loopback configuration value
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_setLoopbackMode(Ifx_GETH *gethSFR, IfxGeth_BridgeLoopbackMode loopbackEnableValue);

/** \brief Flushes all the RX Queues of required port
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_flushAllPortRxQueues(Ifx_GETH *gethSFR, IfxGeth_Port portNumber);

/** \brief Flushes a particular RX Queue of required port
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \param queueNumber rx queue number
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_flushRxQueue(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_RxMtlQueue queueNumber);

/** \brief enables the tx queues and rx channels of corresponding port, must be called once per each port
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \param config union for tx queue's and rx channel's enable configuration
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_enablePortTxQueuesAndRxChannels(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_TxQRxCEnableConfigUnion config);

/** \brief maps the given tx queue of corresponding port to tx dma or rx forward path, must be called once per tx queue for each port
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \param queueNumber tx queue number
 * \param mapValue mapping value
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_mapTxQueue(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_TxMtlQueue queueNumber, IfxGeth_BridgeTxQueueMap mapValue);

/** \brief maps the given RXC of corresponding port to rx dma or tx forward path, must be called once per RXC for each port
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \param queueNumber rx queue/channel number
 * \param mapValue mapping value
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_mapRxChannel(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_RxMtlQueue queueNumber, IfxGeth_BridgeRxCMap mapValue);

/** \brief returns the status of interrupts in the top most level from the bridge
 * \param gethSFR GETH module pointer
 * \param flags pointer to structure containing status of various interrupt sources
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_getInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_Bridge_InterruptStatusFlags *flags);

/** \brief sets the DMA Port Selection register for all the dma channels in the bridge
 * \param gethSFR GETH module pointer
 * \param mapCfg mapping configuration union for all dma channels
 * \return None
 */
IFX_EXTERN void IfxGeth_Bridge_setDmaPortSelection(Ifx_GETH *gethSFR, IfxGeth_Bridge_DmaPortMapUnion mapCfg);

/** \brief Enables GETH interrupt service request for corresponding GETH service node
 * \param serviceRequestNode GETH service node index
 * \param typeOfService Type of Service
 * \param priority Priority of the interrupt
 * \param vmId Virtual machine identifier
 * \return None
 */
IFX_EXTERN void IfxGeth_enableInterrupt(IfxGeth_ServiceRequest serviceRequestNode, IfxSrc_Tos typeOfService, Ifx_Priority priority, IfxSrc_VmId vmId);

/** \brief Enable/Disable the MAC Register Clear On Write Logic. When set the specified register bits are cleared on write of 1 and when reset the bitfield is cleared on read.
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \param enable TRUE: Enabled, FALSE: Disabled
 * \return None
 */
IFX_EXTERN void IfxGeth_enableMacRegisterClearOnWrite(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, boolean enable);

/** \brief Disable the TimeStamp features.
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \return None
 */
IFX_EXTERN void IfxGeth_disableTimeStamp(Ifx_GETH *gethSFR, IfxGeth_Port portNumber);

/** \brief Select the MAC Timestamp Update Method.
 * \param gethSFR GETH module pointer
 * \param portNumber port number
 * \param updateMethod TRUE: Fine Update, FALSE: Coarse Update
 * \return None
 */
IFX_EXTERN void IfxGeth_setTimeStampUpdateMethod(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, boolean updateMethod);

/** \brief Enable/Disable the MMC Counter Register freeze. When set the MMC Counter register's are freezed and when reset the MMC Counter register's work normal
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param enable TRUE: Enabled, FALSE: Disabled
 * \return None
 */
IFX_EXTERN void IfxGeth_enableMmcCounterFreeze(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean enable);

/** \brief When invoked all the MMC counter register's are cleared
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \return None
 */
IFX_EXTERN void IfxGeth_resetMmcCounter(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex);

/** \brief API to Read/Write the L3/L4  filtering Indirect Access Register's
 * \param gethSFR GETH driver Handle
 * \param portIndex Index of Port
 * \param config configuration to Read/Write the L3/L4 filtering register's
 * \return status TRUE : Register Read/Write Transfer failed due to timeoutError FALSE : Register Read/Write Transfer Successful
 */
IFX_EXTERN boolean IfxGeth_indirectReadWriteL3L4FilterReg(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_ReadWriteL3L4RegConfig *config);

/** \brief API to configure the MAC TX to enter/exit the EEE LPI mode
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param config Configuration to enter/exit LPI mode
 * \return the status as EntrySuccess/ ExitSuccess/ timeOutError /invalidConfigError
 */
IFX_EXTERN IfxGeth_LpiConfigStatus IfxGeth_lowPowerIdleModeTx(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_Eth_LpiConfig *config);

/** \brief API to read/clear EEE LPI mode status bit field's
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param lpiStatus to read the status bit's of EEE LPI mode register
 * \return None
 */
IFX_EXTERN void IfxGeth_getLowPowerInterfaceStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_Eth_LpiStatus *lpiStatus);

/** \brief API to Enable/Disable the EEE LPI mode
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param lpiEnable TRUE: Enable, FALSE: Disable the LPI mode
 * \return None
 */
IFX_EXTERN void IfxGeth_setLowPowerInterface(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean lpiEnable);

/** \brief API to Enable/Disable the Remote Wake-Up mode
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param rwkEnable TRUE: MAC power down mode is enabled (Note: Before enabling this bit either of Magic Packet Enable, Global Unicast, or Remote Wake-Up Packet Enable bit should be set high)
 *                  FALSE: MAC is reverted back to default behavior
 * \return None
 */
IFX_EXTERN void IfxGeth_setRwkMode(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean rwkEnable);

/** \brief API to Enable/Disable the Remote Wake-Up packet forwarding
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param rwkUpFwdEnable TRUE: MAC forwards the Remote wakeup packet along with the other packets after wake-up (Note: Before enabling this bit power down bit = Low and Remote Wake-Up Packet Enable bit = high)
 *                       FALSE: MAC is reverted back to default behavior
 * \return None
 */
IFX_EXTERN void IfxGeth_setRwkPacketForward(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean rwkUpFwdEnable);

/** \brief API to Reset the RWK filter pointer i.e RWKPTR
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \return None
 */
IFX_EXTERN void IfxGeth_resetRwkFilterPtr(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex);

/** \brief API to sequentially write the MAC_RWK_PACKET_FILTER register
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param rwkRegType remote wake up filter register type
 * \param regWriteData configure the data to be written in MAC_RWK_PACKET_FILTER
 * \return the status as TRUE: Timeout error register data write failed FALSE: Register data write successful
 */
IFX_EXTERN boolean IfxGeth_macRwkFilterWrite(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_RwkFilterRegType rwkRegType, uint32 regWriteData);

/** \brief API to read/clear PMT mode status bit field's
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param pmtStatus to read/write the status bit's of Power management mode register
 * \return None
 */
IFX_EXTERN void IfxGeth_getPowerMngmtInterfaceStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_Eth_PmtStatus *pmtStatus);

/** \brief returns the interrupt status for MTL Queue's which have the interrupt events triggered
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \return the interrupt status for MTL Queues
 */
IFX_EXTERN uint32 IfxGeth_getMtlInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex);

/** \brief returns the interrupt status of the MTL Queue interrupt flag parsed
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param queueId MTL queue index
 * \param flag MTL Queue interrupt flag
 * \return the interrupt status of the MTL Queue interrupt flag parsed
 */
IFX_EXTERN boolean IfxGeth_getMtlQueueInterruptFlag(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag);

/** \brief returns the interrupt status for the MTL Queue index parsed
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param queueId MTL queue index
 * \return the interrupt status of the MTL Queue index parsed
 */
IFX_EXTERN uint32 IfxGeth_getMtlQueueInterruptFlags(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId);

/** \brief clear's the interrupt status for the MTL Queue index parsed
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param queueId MTL queue index
 * \return None
 */
IFX_EXTERN void IfxGeth_mtlClearAllInterruptFlags(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId);

/** \brief Clear's the interrupt flag of the MTL Queue
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param queueId MTL queue index
 * \param flag MTL Queue interrupt flag
 * \return None
 */
IFX_EXTERN void IfxGeth_mtlClearInterruptFlag(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag);

/** \brief enables the interrupt flag for the MTL Queue
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param queueId MTL queue index
 * \param flag MTL Queue interrupt flag
 * \param interruptEnable TRUE: Enables, FALSE: Disables the interrupt event for the parsed flag
 * \return None
 */
IFX_EXTERN void IfxGeth_setMtlInterruptEnableFlag(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag, boolean interruptEnable);

/** \brief enables the interrupt flag for the MTL Queue
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \param flag pointer to structure containing various interrupt sources
 * \return None
 */
IFX_EXTERN void IfxGeth_setMacInterruptEnableFlags(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MacInterruptFlag *flag);

/** \brief return's the interrupt status for the MAC interrupt sources
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \return the interrupt status for the MAC interrupt sources
 */
IFX_EXTERN uint32 IfxGeth_getMacInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex);

/** \brief return's the interrupt status for the DMA interrupt sources
 * \param gethSFR GETH module pointer
 * \param portIndex port index
 * \return the interrupt status for the DMA interrupt sources
 */
IFX_EXTERN uint32 IfxGeth_getDmaInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex);

/** \brief enables the interrupt flag for the DMA channel
 * \param gethSFR GETH module pointer
 * \param channelIndex Dma Channel index
 * \param enable pointer to structure containing various interrupt sources
 * \return None
 */
IFX_EXTERN void IfxGeth_setDmaChannelInterruptEnable(Ifx_GETH *gethSFR, uint8 channelIndex, IfxGeth_Eth_DmaChannelInterruptFlags *enable);

/** \brief return's the interrupt status for the DMA channel
 * \param gethSFR GETH module pointer
 * \param channelIndex Dma Channel index
 * \return the interrupt status for the MAC interrupt sources
 */
IFX_EXTERN uint32 IfxGeth_getDmaChannelInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_DmaChannel channelIndex);

/** \brief clear's the interrupt status for the DMA channel index parsed
 * \param gethSFR GETH module pointer
 * \param channelIndex Dma channel index
 * \return None
 */
IFX_EXTERN void IfxGeth_dmaChannelInterruptClearAll(Ifx_GETH *gethSFR, IfxGeth_DmaChannel channelIndex);

/** \brief clear's the interrupt status for the DMA channel index parsed
 * \param gethSFR GETH module pointer
 * \param channelIndex Dma channel index
 * \param flag pointer to structure containing various interrupt sources for DMA channel
 * \return None
 */
IFX_EXTERN void IfxGeth_dmaChannelInterruptClear(Ifx_GETH *gethSFR, IfxGeth_DmaChannel channelIndex, IfxGeth_Eth_DmaChannelInterruptFlags *flag);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE boolean IfxGeth_isModuleEnabled(Ifx_GETH *gethSFR)
{
    return (gethSFR->CLC.B.DISS == 0) ? 1 : 0;
}


IFX_INLINE void IfxGeth_Dma_applySoftwareReset(Ifx_GETH *gethSFR)
{
    gethSFR->DMA.MODE.B.SWR = 1;
}


IFX_INLINE void IfxGeth_Bridge_setStatusRegisterClearLogic(Ifx_GETH *gethSFR, boolean enable)
{
    gethSFR->BRIDGE.CSR_SW_CONTROL.B.RCWE = enable;
}


#endif /* IFXGET_H */
