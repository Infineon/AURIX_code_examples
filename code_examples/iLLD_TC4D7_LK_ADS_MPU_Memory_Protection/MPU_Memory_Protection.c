/**********************************************************************************************************************
 * \file MPU_Memory_Protection.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MPU_Memory_Protection.h"

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function that enables the memory protection
 * Make sure to define code and data protection ranges before calling this function.
 *
 * In this function two intrinsic functions, __mfcr() and __mtcr() are called, to access control registers.
 * The intrinsic function __mfcr(int cfsr) moves contents of the addressed Core Special Function Register (CSFR)
 * into a data register.
 * The intrinsic function __mtcr(int csfr, int val) moves contents of a data register (second int) to the addressed
 * CSFR (first int).
 * The ISYNC instruction ensures that the effects of the CSFR update are correctly seen by all following instructions.
 *
 * The Tasking intrinsic function for MTCR automatically includes an ISYNC instruction.
 * ISYNC for other compiler vendors is ensured by use of a preprocessor macro.
 */

void enable_memory_protection()
{
    Ifx_CPU_CORECON coreconValue;
    coreconValue.U = __mfcr(CPU_CORECON);                 /* Get the Core Configuration Register (CORECON) value     */
    coreconValue.B.PROTEN = 1;                            /* Set the PROTEN bitfield to enable the Memory Protection */
    __mtcr(CPU_CORECON, coreconValue.U);                  /* Set the Core Configuration Register (CORECON)           */

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function that defines a data protection range in the corresponding CPU Data Protection Range Register (DPR).
 * Data protection ranges have 8-byte granularity.
 * As a result, the lower 3 bits of any address passed to the define_data_protection_range function will be discarded.
 * After enabling the Memory Protection, access to an address 'x' will be allowed only if:
 * lowerBoundAddress <= x < upperBoundAddress
 */
void define_data_protection_range(uint32 lowerBoundAddress, uint32 upperBoundAddress, uint8 range)
{
    switch(range)
    {
        case 0: /* Data Protection Range 0 */
            __mtcr(CPU_DPR0_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 0       */
            __mtcr(CPU_DPR0_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 0       */
            break;
        case 1: /* Data Protection Range 1 */
            __mtcr(CPU_DPR1_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 1       */
            __mtcr(CPU_DPR1_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 1       */
            break;
        case 2: /* Data Protection Range 2 */
            __mtcr(CPU_DPR2_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 2       */
            __mtcr(CPU_DPR2_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 2       */
            break;
        case 3: /* Data Protection Range 3 */
            __mtcr(CPU_DPR3_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 3       */
            __mtcr(CPU_DPR3_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 3       */
            break;
        case 4: /* Data Protection Range 4 */
            __mtcr(CPU_DPR4_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 4       */
            __mtcr(CPU_DPR4_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 4       */
            break;
        case 5: /* Data Protection Range 5 */
            __mtcr(CPU_DPR5_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 5       */
            __mtcr(CPU_DPR5_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 5       */
            break;
        case 6: /* Data Protection Range 6 */
            __mtcr(CPU_DPR6_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 6       */
            __mtcr(CPU_DPR6_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 6       */
            break;
        case 7: /* Data Protection Range 7 */
            __mtcr(CPU_DPR7_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 7       */
            __mtcr(CPU_DPR7_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 7       */
            break;
        case 8: /* Data Protection Range 8 */
            __mtcr(CPU_DPR8_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 8       */
            __mtcr(CPU_DPR8_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 8       */
            break;
        case 9: /* Data Protection Range 9 */
            __mtcr(CPU_DPR9_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 9       */
            __mtcr(CPU_DPR9_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 9       */
            break;
        case 10: /* Data Protection Range 10 */
            __mtcr(CPU_DPR10_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 10      */
            __mtcr(CPU_DPR10_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 10      */
            break;
        case 11: /* Data Protection Range 11 */
            __mtcr(CPU_DPR11_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 11      */
            __mtcr(CPU_DPR11_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 11      */
            break;
        case 12: /* Data Protection Range 12 */
            __mtcr(CPU_DPR12_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 12      */
            __mtcr(CPU_DPR12_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 12      */
            break;
        case 13: /* Data Protection Range 13 */
            __mtcr(CPU_DPR13_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 13      */
            __mtcr(CPU_DPR13_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 13      */
            break;
        case 14: /* Data Protection Range 14 */
            __mtcr(CPU_DPR14_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 14      */
            __mtcr(CPU_DPR14_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 14      */
            break;
        case 15: /* Data Protection Range 15 */
            __mtcr(CPU_DPR15_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 15      */
            __mtcr(CPU_DPR15_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 15      */
            break;
        case 16: /* Data Protection Range 16 */
            __mtcr(CPU_DPR16_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 16      */
            __mtcr(CPU_DPR16_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 16      */
            break;
        case 17: /* Data Protection Range 17 */
            __mtcr(CPU_DPR17_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 17      */
            __mtcr(CPU_DPR17_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 17      */
            break;
        case 18: /* Data Protection Range 18 */
            __mtcr(CPU_DPR18_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 18      */
            __mtcr(CPU_DPR18_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 18      */
            break;
        case 19: /* Data Protection Range 19 */
            __mtcr(CPU_DPR19_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 19      */
            __mtcr(CPU_DPR19_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 19      */
            break;
        case 20: /* Data Protection Range 20 */
            __mtcr(CPU_DPR20_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 20      */
            __mtcr(CPU_DPR20_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 20      */
            break;
        case 21: /* Data Protection Range 21 */
            __mtcr(CPU_DPR21_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 21      */
            __mtcr(CPU_DPR21_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 21      */
            break;
        case 22: /* Data Protection Range 22 */
            __mtcr(CPU_DPR22_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 22      */
            __mtcr(CPU_DPR22_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 22      */
            break;
        case 23: /* Data Protection Range 23 */
            __mtcr(CPU_DPR23_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 23      */
            __mtcr(CPU_DPR23_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 23      */
            break;
        default:
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function that defines a code protection range in the corresponding CPU Code Protection Range Register (CPR).
 * Code protection ranges have 32-byte granularity.
 * As a result, the lower 5 bits of any address passed to the define_code_protection_range function will be discarded.
 * After enabling the Memory Protection, access to an address 'x' will be allowed only if:
 * lowerBoundAddress <= x < upperBoundAddress
 */
void define_code_protection_range(uint32 lowerBoundAddress, uint32 upperBoundAddress, uint8 range)
{
    switch(range)
    {
        case 0: /* Code Protection Range 0 */
            __mtcr(CPU_CPR0_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 0       */
            __mtcr(CPU_CPR0_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 0       */
            break;
        case 1: /* Code Protection Range 1 */
            __mtcr(CPU_CPR1_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 1       */
            __mtcr(CPU_CPR1_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 1       */

            break;
        case 2: /* Code Protection Range 2 */
            __mtcr(CPU_CPR2_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 2       */
            __mtcr(CPU_CPR2_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 2       */

            break;
        case 3: /* Code Protection Range 3 */
            __mtcr(CPU_CPR3_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 3       */
            __mtcr(CPU_CPR3_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 3       */
            break;
        case 4: /* Code Protection Range 4 */
            __mtcr(CPU_CPR4_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 4       */
            __mtcr(CPU_CPR4_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 4       */
            break;
        case 5: /* Code Protection Range 5 */
            __mtcr(CPU_CPR5_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 5       */
            __mtcr(CPU_CPR5_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 5       */
            break;
        case 6: /* Code Protection Range 6 */
            __mtcr(CPU_CPR6_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 6       */
            __mtcr(CPU_CPR6_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 6       */
            break;
        case 7: /* Code Protection Range 7 */
            __mtcr(CPU_CPR7_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 7       */
            __mtcr(CPU_CPR7_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 7       */
            break;
        case 8: /* Code Protection Range 8 */
            __mtcr(CPU_CPR8_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 8       */
            __mtcr(CPU_CPR8_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 8       */
            break;
        case 9: /* Code Protection Range 9 */
            __mtcr(CPU_CPR9_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 9       */
            __mtcr(CPU_CPR9_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 9       */
            break;
        case 10: /* Code Protection Range 10 */
            __mtcr(CPU_CPR10_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 10     */
            __mtcr(CPU_CPR10_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 10     */
            break;
        case 11: /* Code Protection Range 11 */
            __mtcr(CPU_CPR11_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 11     */
            __mtcr(CPU_CPR11_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 11     */
            break;
        case 12: /* Code Protection Range 12 */
            __mtcr(CPU_CPR12_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 12     */
            __mtcr(CPU_CPR12_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 12     */
            break;
        case 13: /* Code Protection Range 13 */
            __mtcr(CPU_CPR13_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 13     */
            __mtcr(CPU_CPR13_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 13     */
            break;
        case 14: /* Code Protection Range 14 */
            __mtcr(CPU_CPR14_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 14     */
            __mtcr(CPU_CPR14_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 14     */
            break;
        case 15: /* Code Protection Range 15 */
            __mtcr(CPU_CPR15_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 15     */
            __mtcr(CPU_CPR15_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 15     */
            break;
        default:
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to enable the data read access to a predefined Range in a Protection Set */
void enable_data_read(uint8 protectionSet, uint8 range)
{
    Ifx_CPU_DPRE DPRERegisterValue;

    /* Get the CPU Data Protection Read Enable Register value */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_0);
            break;
        case 1: /* Protection Set 1 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_1);
            break;
        case 2: /* Protection Set 2 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_2);
            break;
        case 3: /* Protection Set 3 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_3);
            break;
        case 4: /* Protection Set 4 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_4);
            break;
        case 5: /* Protection Set 5 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_5);
            break;
        case 6: /* Protection Set 6 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_6);
            break;
        case 7: /* Protection Set 7 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE_7);
            break;
        default:
            break;
    }

    /* Set the bit corresponding to the given Data Protection Range */
    DPRERegisterValue.U |= (0x01 << range);

    /* Set the CPU Data Protection Read Enable Register value to enable data read access */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            __mtcr(CPU_DPRE_0, DPRERegisterValue.U);
            break;
        case 1: /* Protection Set 1 */
            __mtcr(CPU_DPRE_1, DPRERegisterValue.U);
            break;
        case 2: /* Protection Set 2 */
            __mtcr(CPU_DPRE_2, DPRERegisterValue.U);
            break;
        case 3: /* Protection Set 3 */
            __mtcr(CPU_DPRE_3, DPRERegisterValue.U);
            break;
        case 4: /* Protection Set 4 */
            __mtcr(CPU_DPRE_4, DPRERegisterValue.U);
            break;
        case 5: /* Protection Set 5 */
            __mtcr(CPU_DPRE_5, DPRERegisterValue.U);
            break;
        case 6: /* Protection Set 6 */
            __mtcr(CPU_DPRE_6, DPRERegisterValue.U);
            break;
        case 7: /* Protection Set 7 */
            __mtcr(CPU_DPRE_7, DPRERegisterValue.U);
            break;
        default:
            break;
    }


#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to enable the data write access to a predefined Range in a Protection Set */
void enable_data_write(uint8 protectionSet, uint8 range)
{
    Ifx_CPU_DPWE DPWERegisterValue;

    /* Get the CPU Data Protection Write Enable Register value */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_0);
            break;
        case 1: /* Protection Set 1 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_1);
            break;
        case 2: /* Protection Set 2 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_2);
            break;
        case 3: /* Protection Set 3 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_3);
            break;
        case 4: /* Protection Set 4 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_4);
            break;
        case 5: /* Protection Set 5 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_5);
            break;
        case 6: /* Protection Set 6 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_6);
            break;
        case 7: /* Protection Set 7 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE_7);
            break;
        default:
            break;
    }

    /* Set the bit corresponding to the given Data Protection Range */
    DPWERegisterValue.U  |= (0x01 << range);

    /* Set the CPU Data Protection Write Enable Register value to enable data write access */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            __mtcr(CPU_DPWE_0, DPWERegisterValue.U);
            break;
        case 1: /* Protection Set 1 */
            __mtcr(CPU_DPWE_1, DPWERegisterValue.U);
            break;
        case 2: /* Protection Set 2 */
            __mtcr(CPU_DPWE_2, DPWERegisterValue.U);
            break;
        case 3: /* Protection Set 3 */
            __mtcr(CPU_DPWE_3, DPWERegisterValue.U);
            break;
        case 4: /* Protection Set 4 */
            __mtcr(CPU_DPWE_4, DPWERegisterValue.U);
            break;
        case 5: /* Protection Set 5 */
            __mtcr(CPU_DPWE_5, DPWERegisterValue.U);
            break;
        case 6: /* Protection Set 6 */
            __mtcr(CPU_DPWE_6, DPWERegisterValue.U);
            break;
        case 7: /* Protection Set 7 */
            __mtcr(CPU_DPWE_7, DPWERegisterValue.U);
            break;
        default:
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to enable code execution access to a predefined Range in a Protection Set */
void enable_code_execution(uint8 protectionSet, uint8 range)
{
    Ifx_CPU_CPXE CPXERegisterValue;

    /* Get the CPU Code Protection Execute Enable Register value */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_0);
            break;
        case 1: /* Protection Set 1 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_1);
            break;
        case 2: /* Protection Set 2 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_2);
            break;
        case 3: /* Protection Set 3 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_3);
            break;
        case 4: /* Protection Set 4 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_4);
            break;
        case 5: /* Protection Set 5 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_5);
            break;
        case 6: /* Protection Set 6 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_6);
            break;
        case 7: /* Protection Set 7 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE_7);
            break;
        default:
            break;
    }

    /* Set the bit corresponding to the given Code Protection Range */
    CPXERegisterValue.U |= (0x1 << range);

    /* Set the CPU Code Protection Execute Enable Register value to enable code execution */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            __mtcr(CPU_CPXE_0, CPXERegisterValue.U);
            break;
        case 1: /* Protection Set 1 */
            __mtcr(CPU_CPXE_1, CPXERegisterValue.U);
            break;
        case 2: /* Protection Set 2 */
            __mtcr(CPU_CPXE_2, CPXERegisterValue.U);
            break;
        case 3: /* Protection Set 3 */
            __mtcr(CPU_CPXE_3, CPXERegisterValue.U);
            break;
        case 4: /* Protection Set 4 */
            __mtcr(CPU_CPXE_4, CPXERegisterValue.U);
            break;
        case 5: /* Protection Set 5 */
            __mtcr(CPU_CPXE_5, CPXERegisterValue.U);
            break;
        case 6: /* Protection Set 6 */
            __mtcr(CPU_CPXE_6, CPXERegisterValue.U);
            break;
        case 7: /* Protection Set 7 */
            __mtcr(CPU_CPXE_7, CPXERegisterValue.U);
            break;
        default:
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to initialize the port pins that drive the LEDs */
void init_LEDs()
{
    /* Initialize of the LED port pins */
    IfxPort_setPinModeOutput(LED_FIRST_HALF, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LED_SECOND_HALF, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Switch OFF the LEDs (low-level active) */
    IfxPort_setPinHigh(LED_FIRST_HALF);
    IfxPort_setPinHigh(LED_SECOND_HALF);
}

/* Function to turn ON an LED (low-level active) */
void switch_LED_ON(Ifx_P *ledPort, uint8 ledPinIndex)
{
    IfxPort_setPinLow(ledPort, ledPinIndex);
}
