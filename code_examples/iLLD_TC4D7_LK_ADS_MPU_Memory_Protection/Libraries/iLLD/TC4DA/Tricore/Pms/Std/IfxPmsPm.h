/**
 * \file IfxPmsPm.h
 * \brief PMS  basic functionality
 * \ingroup IfxLld_Pms
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 *
 * \defgroup IfxLld_Pms_Std_Pm PM
 * \ingroup IfxLld_Pms_Std
 * \defgroup IfxLld_Pms_Std_Pm_Enumerations Enumerations
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_DataStructures Data Structures
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_SystemModes System Modes
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_CpuModes Cpu Modes
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_WakeupModes WakeupModes
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_Digitalfilter Digitalfilter
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_DTS DTS
 * \ingroup IfxLld_Pms_Std_Pm
 * \defgroup IfxLld_Pms_Std_Pm_SCRFunctions SCR functions
 * \ingroup IfxLld_Pms_Std_Pm
 */

#ifndef IFXPMSPM_H
#define IFXPMSPM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxPms_cfg.h"
#include "Pms/Std/IfxPmsEvr.h"
#include "Wtu/Std/IfxWtu.h"
#include "Smm/Std/IfxSmmSysMode.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Mask for Wakeup and overrun flags WAKEUP_CLR0
 */
#define IFXPMSPM_WAKEUP_OVRUN_FLAGS_CLR0                                                   \
    (uint32)(                                                                              \
        (IFX_PMS_WAKEUP_CLR0_ESR2WKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_ESR2WKPCLR_OFF) |       \
        (IFX_PMS_WAKEUP_CLR0_PINBWKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_PINBWKPCLR_OFF) |       \
        (IFX_PMS_WAKEUP_CLR0_PINCWKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_PINCWKPCLR_OFF) |       \
        (IFX_PMS_WAKEUP_CLR0_PINSEXTWKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_PINSEXTWKPCLR_OFF) | \
        (IFX_PMS_WAKEUP_CLR0_PINSSBWKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_PINSSBWKPCLR_OFF) |   \
        (IFX_PMS_WAKEUP_CLR0_RTCWKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_RTCWKPCLR_OFF) |         \
        (IFX_PMS_WAKEUP_CLR0_WUTWKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_WUTWKPCLR_OFF) |         \
        (IFX_PMS_WAKEUP_CLR0_PWRWKPCLR_MSK << IFX_PMS_WAKEUP_CLR0_PWRWKPCLR_OFF) |         \
        (IFX_PMS_WAKEUP_CLR0_ESR2OVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR0_ESR2OVRUNCLR_OFF) |   \
        (IFX_PMS_WAKEUP_CLR0_PINBOVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR0_PINBOVRUNCLR_OFF) |   \
        (IFX_PMS_WAKEUP_CLR0_PINCOVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR0_PINCOVRUNCLR_OFF) |   \
        (IFX_PMS_WAKEUP_CLR0_RTCOVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR0_RTCOVRUNCLR_OFF) |     \
        (IFX_PMS_WAKEUP_CLR0_WUTOVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR0_WUTOVRUNCLR_OFF))

/** \brief Mask for wakeup and overrun flags WAKEUP_CLR1
 */
#define IFXPMSPM_WAKEUP_OVRUN_FLAGS_CLR1                                                 \
    (uint32)(                                                                            \
        (IFX_PMS_WAKEUP_CLR1_ESR0WKPCLR_MSK << IFX_PMS_WAKEUP_CLR1_ESR0WKPCLR_OFF) |     \
        (IFX_PMS_WAKEUP_CLR1_ESR1WKPCLR_MSK << IFX_PMS_WAKEUP_CLR1_ESR1WKPCLR_OFF) |     \
        (IFX_PMS_WAKEUP_CLR1_PINAWKPCLR_MSK << IFX_PMS_WAKEUP_CLR1_PINAWKPCLR_OFF) |     \
        (IFX_PMS_WAKEUP_CLR1_SCRWKPCLR_MSK << IFX_PMS_WAKEUP_CLR1_SCRWKPCLR_OFF) |       \
        (IFX_PMS_WAKEUP_CLR1_PORSTWKPCLR_MSK << IFX_PMS_WAKEUP_CLR1_PORSTWKPCLR_OFF) |   \
        (IFX_PMS_WAKEUP_CLR1_ESR0OVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR1_ESR0OVRUNCLR_OFF) | \
        (IFX_PMS_WAKEUP_CLR1_ESR1OVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR1_ESR1OVRUNCLR_OFF) | \
        (IFX_PMS_WAKEUP_CLR1_PINAOVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR1_PINAOVRUNCLR_OFF) | \
        (IFX_PMS_WAKEUP_CLR1_SCROVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR1_SCROVRUNCLR_OFF) |   \
        (IFX_PMS_WAKEUP_CLR1_PORSTOVRUNCLR_MSK << IFX_PMS_WAKEUP_CLR1_PORSTOVRUNCLR_OFF))

#define IFXPMSPM_STANDBY_MODE               (0x3U)

/** \brief Macro for DTS temperature conversion to Kelvin
 */
#define IFXPMSPM_DTS_TEMP_KELVIN_CONVERSION (4.781f)

/** \brief Macro for Host Pflash and Dflash mask
 */
#define IFXPMSPM_HOST_PFLASH_DFLASH_MASK    (0x10FFFU)

/** \brief Mask for Interrupt flags INT_CLR
 */
#define IFXPMSPM_INTERRUPT_FLAGS_CLR        (uint32)(0x7FFU)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pms_Std_Pm_Enumerations
 * \{ */
/** \brief Exposes the optons for minimum duration between standby entry and Wakeup.If any wakeup request comes up before this time is elapsed after standby entry, then it's ignored.
 */
typedef enum
{
    IfxPmsPm_BlankingFilterDelay_0us    = 0,   /**< \brief No blanking filter delay */
    IfxPmsPm_BlankingFilterDelay_156us  = 1,   /**< \brief Blanking filter delay of 156us */
    IfxPmsPm_BlankingFilterDelay_1_25ms = 2,   /**< \brief Blanking filter delay of 1_25ms */
    IfxPmsPm_BlankingFilterDelay_2_5ms  = 3,   /**< \brief Blanking delay on 2.5ms */
    IfxPmsPm_BlankingFilterDelay_5ms    = 4,   /**< \brief Blanking delay on 5ms */
    IfxPmsPm_BlankingFilterDelay_10ms   = 5,   /**< \brief Blanking delay on 10ms */
    IfxPmsPm_BlankingFilterDelay_20ms   = 6,   /**< \brief Blanking delay on 20ms */
    IfxPmsPm_BlankingFilterDelay_40ms   = 7,   /**< \brief Blanking delay on 40ms */
    IfxPmsPm_BlankingFilterDelay_80ms   = 8,   /**< \brief Blanking delay on 80ms */
    IfxPmsPm_BlankingFilterDelay_160ms  = 9,   /**< \brief Blanking delay on 160ms */
    IfxPmsPm_BlankingFilterDelay_320ms  = 10,  /**< \brief Blanking delay on 320ms */
    IfxPmsPm_BlankingFilterDelay_640ms  = 11,  /**< \brief Blanking delay on 640ms */
    IfxPmsPm_BlankingFilterDelay_1280ms = 12,  /**< \brief Blanking delay on 1280ms */
    IfxPmsPm_BlankingFilterDelay_2560ms = 13   /**< \brief Blanking delay on 2560ms */
} IfxPmsPm_BlankingFilterDelay;

/** \brief Enumeration for Core power domain
 */
typedef enum
{
    IfxPmsPm_CorePowerDomain_ppu  = 3,  /**< \brief PPU power domain */
    IfxPmsPm_CorePowerDomain_lmu0 = 8,  /**< \brief LMU power domain */
    IfxPmsPm_CorePowerDomain_lmu1 = 9   /**< \brief LMU1 power domain */
} IfxPmsPm_CorePowerDomain;

/** \brief The Digital filter enable/disabled
 * As defined in Ifx_PMS.PMSW.CR0.B.ESRxDFEN and Ifx_PMS.PMSW.CR0.B.PINxDFEN
 */
typedef enum
{
    IfxPmsPm_DigitalFilter_esr2 = 0,  /**< \brief Th digital filter enable/disable for ESR2 event. */
    IfxPmsPm_DigitalFilter_pinC = 1,  /**< \brief The digital filter enable/disable for PINC event. */
    IfxPmsPm_DigitalFilter_esr0 = 2,  /**< \brief The digital filter enable/disable for ESR0 event. */
    IfxPmsPm_DigitalFilter_esr1 = 3,  /**< \brief The digital filter enable/disable for ESR1 event. */
    IfxPmsPm_DigitalFilter_pinA = 4,  /**< \brief The digital filter enable/disable for PINA event. */
    IfxPmsPm_DigitalFilter_pinB = 5   /**< \brief The digital filter enable/disable for PINB event. */
} IfxPmsPm_DigitalFilter;

/** \brief Options for whether to use digital filtering while reading wake-up pulse on PinA,PinB,ESR0 and ESR1 pins.
 */
typedef enum
{
    IfxPmsPm_DigitalFilterConfiguration_bypassed = 0,  /**< \brief The pulse from pin in interpreted directly(without filtering) */
    IfxPmsPm_DigitalFilterConfiguration_used     = 1   /**< \brief The pulse from the pin is filtered with a majority of 3 digital filter before being interpreted */
} IfxPmsPm_DigitalFilterConfiguration;

/** \brief Enumeration for DTS analog enable/Disable
 * As defined in DTS_CON.B.EN
 */
typedef enum
{
    IfxPmsPm_Dts_disable = 0,  /**< \brief Disable DTS analog circuitry */
    IfxPmsPm_Dts_enable  = 1   /**< \brief Enable DTS analog circuitry */
} IfxPmsPm_Dts;

/** \brief Enumeration for DTS ADC conversion start/stop
 */
typedef enum
{
    IfxPmsPm_DtsAdcConversion_stop  = 0, /**< \brief Stop DTS ADC conversion */
    IfxPmsPm_DtsAdcConversion_start = 1  /**< \brief Start DTS ADC conversion */
} IfxPmsPm_DtsAdcConversion;

/** \brief Enumeration for DTS Peak Temperature detector reset
 */
typedef enum
{
    IfxPmsPm_DtsPeakTemp_noreset = 0,  /**< \brief Peak temperature detector is not reset */
    IfxPmsPm_DtsPeakTemp_reset   = 1   /**< \brief Peak temperature detector is reset */
} IfxPmsPm_DtsPeakTemp;

/** \brief Enumeratin for DTS warning enable/disbale
 * As defined in DTS_CON.B.WRNEN
 */
typedef enum
{
    IfxPmsPm_DtsWarning_disable = 0,  /**< \brief Disable DTS warning */
    IfxPmsPm_DtsWarning_enable  = 1   /**< \brief Enable DTS warning */
} IfxPmsPm_DtsWarning;

/** \brief Enumeration for interrupt
 */
typedef enum
{
    IfxPmsPm_Interrupt_rtcCmp0,  /**< \brief RTC CMP0 interrupt */
    IfxPmsPm_Interrupt_rtcCmp1,  /**< \brief RTC CMP1 interrupt */
    IfxPmsPm_Interrupt_wut,      /**< \brief WUT interrupt */
    IfxPmsPm_Interrupt_esr0,     /**< \brief ESR0 interrupt */
    IfxPmsPm_Interrupt_esr1,     /**< \brief ESR1 interrupt */
    IfxPmsPm_Interrupt_esr2,     /**< \brief ESR2 interrupt */
    IfxPmsPm_Interrupt_pina,     /**< \brief PINA interrupt */
    IfxPmsPm_Interrupt_pinb,     /**< \brief PINB interrupt */
    IfxPmsPm_Interrupt_pinc,     /**< \brief PINC interrupt */
    IfxPmsPm_Interrupt_pinssb,   /**< \brief PINSSB interrupt */
    IfxPmsPm_Interrupt_pinsext   /**< \brief PINSEXT interrupt */
} IfxPmsPm_Interrupt;

/** \brief Request to set pads to either input with weak pullup or tristate.
 */
typedef enum
{
    IfxPmsPm_PadStateRequest_inputWithWeakPullUp = 0,  /**< \brief Set pads to input with weak pullup */
    IfxPmsPm_PadStateRequest_tristate            = 1   /**< \brief Set pads to tristate */
} IfxPmsPm_PadStateRequest;

/** \brief Enumeration for trigger event
 */
typedef enum
{
    IfxPmsPm_PinEdgeTriggerEvent_none                     = 0, /**< \brief None of the edges will trigger anything */
    IfxPmsPm_PinEdgeTriggerEvent_risingEdge               = 1, /**< \brief Trigger is generated upon a rising edge */
    IfxPmsPm_PinEdgeTriggerEvent_fallingEdge              = 2, /**< \brief Trigger is generated upon a falling edge */
    IfxPmsPm_PinEdgeTriggerEvent_bothRisingAndFallingEdge = 3  /**< \brief A trigger is generated upon a rising OR falling edge */
} IfxPmsPm_PinEdgeTriggerEvent;

/** \brief Request to set ESR0 pin pads(PAD_CON.ESR0PD) to either input with weak pullup or tristate.
 */
typedef enum
{
    IfxPmsPm_PinStateRequest_tristate    = 0, /**< \brief Set the ESR0 pin pad to tristate */
    IfxPmsPm_PinStateRequest_resetOutput = 1  /**< \brief Set the ESR0 pin pad to Pull down */
} IfxPmsPm_PinStateRequest;

/** \brief Enumeration for PORST digital filter enable
 */
typedef enum
{
    IfxPmsPm_PorstDigitalFilter_analogfilter       = 0,  /**< \brief Analog PORST pad filter delay */
    IfxPmsPm_PorstDigitalFilter_digitalfilter500ns = 1,  /**< \brief Analog PORST pad filter delay + digital filter delay. Digital filter delay is ~500ns */
    IfxPmsPm_PorstDigitalFilter_digitalfilter5us   = 2   /**< \brief Analog PORST pad filter delay + digital filter delay. Digital filter delay is ~5us */
} IfxPmsPm_PorstDigitalFilter;

/** \brief Enumeration for Power Domain Switch-Off Request
 */
typedef enum
{
    IfxPmsPm_PowerDomainSwitchOff_notrequested = 0,  /**< \brief Power domain switch off not requested */
    IfxPmsPm_PowerDomainSwitchOff_requested    = 1   /**< \brief Power domain switch off requested */
} IfxPmsPm_PowerDomainSwitchOff;

/** \brief Enumeration for Power Down Enable/Disable
 */
typedef enum
{
    IfxPmsPm_PowerDown_disable = 0,  /**< \brief Disable Power down of the power domain */
    IfxPmsPm_PowerDown_enable  = 1   /**< \brief Enable Power down of the power domain */
} IfxPmsPm_PowerDown;

/** \brief Enumeration for Power Switch Clock divider
 */
typedef enum
{
    IfxPmsPm_PowerSwitchCLockDivider_0 = 0,  /**< \brief Switch rate clock divider CLK / 1 */
    IfxPmsPm_PowerSwitchCLockDivider_1 = 1,  /**< \brief Switch rate clock divider CLK / 2 */
    IfxPmsPm_PowerSwitchCLockDivider_2 = 2,  /**< \brief Switch rate clock divider CLK / 4 */
    IfxPmsPm_PowerSwitchCLockDivider_3 = 3,  /**< \brief Switch rate clock divider CLK / 8 */
    IfxPmsPm_PowerSwitchCLockDivider_4 = 4,  /**< \brief Switch rate clock divider CLK / 16 */
    IfxPmsPm_PowerSwitchCLockDivider_5 = 5,  /**< \brief Switch rate clock divider CLK / 32 */
    IfxPmsPm_PowerSwitchCLockDivider_6 = 6,  /**< \brief Switch rate clock divider CLK / 64 */
    IfxPmsPm_PowerSwitchCLockDivider_7 = 7   /**< \brief Switch rate clock divider CLK / 128 */
} IfxPmsPm_PowerSwitchCLockDivider;

/** \brief Enumeration for Enable/Disable RTC
 */
typedef enum
{
    IfxPmsPm_Rtc_disable = 0,  /**< \brief Disable RTC */
    IfxPmsPm_Rtc_enable  = 1   /**< \brief Enable RTC */
} IfxPmsPm_Rtc;

/** \brief Enumeration for Rtc clock source
 */
typedef enum
{
    IfxPmsPm_RtcClk_70Khz = 0,  /**< \brief Rtc clock source to be 70Khz */
    IfxPmsPm_RtcClk_32Khz = 1   /**< \brief Rtc clock source to be 32Khz */
} IfxPmsPm_RtcClk;

/** \brief RTC Comparator
 */
typedef enum
{
    IfxPmsPm_RtcCmp_0 = 0,  /**< \brief RTC comparator 0 */
    IfxPmsPm_RtcCmp_1 = 1   /**< \brief RTC comparator 1 */
} IfxPmsPm_RtcCmp;

/** \brief Gain control for RTC.
 */
typedef enum
{
    IfxPmsPm_RtcGain_2x = 0,  /**< \brief Gain to be 2x */
    IfxPmsPm_RtcGain_4x = 1,  /**< \brief Gain to be 4x */
    IfxPmsPm_RtcGain_6x = 2,  /**< \brief Gain to be 6x */
    IfxPmsPm_RtcGain_8x = 3   /**< \brief Gain to be 8x */
} IfxPmsPm_RtcGain;

/** \brief Enumeration for number of bits used for compare operation
 */
typedef enum
{
    IfxPmsPm_RtcMsize_0 = 0,      /**< \brief CMP[0:0] used for compare operation  */
    IfxPmsPm_RtcMsize_1,          /**< \brief CMP[0:1] used for compare operation  */
    IfxPmsPm_RtcMsize_2,          /**< \brief CMP[0:2] used for compare operation  */
    IfxPmsPm_RtcMsize_3,          /**< \brief CMP[0:3] used for compare operation  */
    IfxPmsPm_RtcMsize_4,          /**< \brief CMP[0:4] used for compare operation  */
    IfxPmsPm_RtcMsize_5,          /**< \brief CMP[0:5] used for compare operation  */
    IfxPmsPm_RtcMsize_6,          /**< \brief CMP[0:6] used for compare operation  */
    IfxPmsPm_RtcMsize_7,          /**< \brief CMP[0:7] used for compare operation  */
    IfxPmsPm_RtcMsize_8,          /**< \brief CMP[0:8] used for compare operation  */
    IfxPmsPm_RtcMsize_9,          /**< \brief CMP[0:9] used for compare operation  */
    IfxPmsPm_RtcMsize_10,         /**< \brief CMP[0:10] used for compare operation  */
    IfxPmsPm_RtcMsize_11,         /**< \brief CMP[0:11] used for compare operation  */
    IfxPmsPm_RtcMsize_12,         /**< \brief CMP[0:12] used for compare operation  */
    IfxPmsPm_RtcMsize_13,         /**< \brief CMP[0:13] used for compare operation  */
    IfxPmsPm_RtcMsize_14,         /**< \brief CMP[0:14] used for compare operation  */
    IfxPmsPm_RtcMsize_15,         /**< \brief CMP[0:15] used for compare operation  */
    IfxPmsPm_RtcMsize_16,         /**< \brief CMP[0:16] used for compare operation  */
    IfxPmsPm_RtcMsize_17,         /**< \brief CMP[0:17] used for compare operation  */
    IfxPmsPm_RtcMsize_18,         /**< \brief CMP[0:18] used for compare operation  */
    IfxPmsPm_RtcMsize_19,         /**< \brief CMP[0:19] used for compare operation  */
    IfxPmsPm_RtcMsize_20,         /**< \brief CMP[0:20] used for compare operation  */
    IfxPmsPm_RtcMsize_21,         /**< \brief CMP[0:21] used for compare operation  */
    IfxPmsPm_RtcMsize_22,         /**< \brief CMP[0:22] used for compare operation  */
    IfxPmsPm_RtcMsize_23,         /**< \brief CMP[0:23] used for compare operation  */
    IfxPmsPm_RtcMsize_24,         /**< \brief CMP[0:24] used for compare operation  */
    IfxPmsPm_RtcMsize_25,         /**< \brief CMP[0:25] used for compare operation  */
    IfxPmsPm_RtcMsize_26,         /**< \brief CMP[0:26] used for compare operation  */
    IfxPmsPm_RtcMsize_27,         /**< \brief CMP[0:27] used for compare operation  */
    IfxPmsPm_RtcMsize_28,         /**< \brief CMP[0:28] used for compare operation  */
    IfxPmsPm_RtcMsize_29,         /**< \brief CMP[0:29] used for compare operation  */
    IfxPmsPm_RtcMsize_30,         /**< \brief CMP[0:30] used for compare operation  */
    IfxPmsPm_RtcMsize_31          /**< \brief CMP[0:31] used for compare operation  */
} IfxPmsPm_RtcMsize;

/** \brief Enumeration for lowest number of 64 bit RTC that is used for compare operation
 */
typedef enum
{
    IfxPmsPm_RtcMstart_0 = 0,      /**< \brief STM[0] is the lowest bit number  */
    IfxPmsPm_RtcMstart_1,          /**< \brief STM[1] is the lowest bit number  */
    IfxPmsPm_RtcMstart_2,          /**< \brief STM[2] is the lowest bit number  */
    IfxPmsPm_RtcMstart_3,          /**< \brief STM[3] is the lowest bit number  */
    IfxPmsPm_RtcMstart_4,          /**< \brief STM[4] is the lowest bit number  */
    IfxPmsPm_RtcMstart_5,          /**< \brief STM[5] is the lowest bit number  */
    IfxPmsPm_RtcMstart_6,          /**< \brief STM[6] is the lowest bit number  */
    IfxPmsPm_RtcMstart_7,          /**< \brief STM[7] is the lowest bit number  */
    IfxPmsPm_RtcMstart_8,          /**< \brief STM[8] is the lowest bit number  */
    IfxPmsPm_RtcMstart_9,          /**< \brief STM[9] is the lowest bit number  */
    IfxPmsPm_RtcMstart_10,         /**< \brief STM[10] is the lowest bit number  */
    IfxPmsPm_RtcMstart_11,         /**< \brief STM[11] is the lowest bit number  */
    IfxPmsPm_RtcMstart_12,         /**< \brief STM[12] is the lowest bit number  */
    IfxPmsPm_RtcMstart_13,         /**< \brief STM[13] is the lowest bit number  */
    IfxPmsPm_RtcMstart_14,         /**< \brief STM[14] is the lowest bit number  */
    IfxPmsPm_RtcMstart_15,         /**< \brief STM[15] is the lowest bit number  */
    IfxPmsPm_RtcMstart_16,         /**< \brief STM[16] is the lowest bit number  */
    IfxPmsPm_RtcMstart_17,         /**< \brief STM[17] is the lowest bit number  */
    IfxPmsPm_RtcMstart_18,         /**< \brief STM[18] is the lowest bit number  */
    IfxPmsPm_RtcMstart_19,         /**< \brief STM[19] is the lowest bit number  */
    IfxPmsPm_RtcMstart_20,         /**< \brief STM[20] is the lowest bit number  */
    IfxPmsPm_RtcMstart_21,         /**< \brief STM[21] is the lowest bit number  */
    IfxPmsPm_RtcMstart_22,         /**< \brief STM[22] is the lowest bit number  */
    IfxPmsPm_RtcMstart_23,         /**< \brief STM[23] is the lowest bit number  */
    IfxPmsPm_RtcMstart_24,         /**< \brief STM[24] is the lowest bit number  */
    IfxPmsPm_RtcMstart_25,         /**< \brief STM[25] is the lowest bit number  */
    IfxPmsPm_RtcMstart_26,         /**< \brief STM[26] is the lowest bit number  */
    IfxPmsPm_RtcMstart_27,         /**< \brief STM[27] is the lowest bit number  */
    IfxPmsPm_RtcMstart_28,         /**< \brief STM[28] is the lowest bit number  */
    IfxPmsPm_RtcMstart_29,         /**< \brief STM[29] is the lowest bit number  */
    IfxPmsPm_RtcMstart_30,         /**< \brief STM[30] is the lowest bit number  */
    IfxPmsPm_RtcMstart_31          /**< \brief STM[31] is the lowest bit number  */
} IfxPmsPm_RtcMstart;

/** \brief RTC output to pins and timers selections
 */
typedef enum
{
    IfxPmsPm_RtcOutput_noOutput = 0,  /**< \brief No output */
    IfxPmsPm_RtcOutput_fRTC     = 1,  /**< \brief Clock of the rtc. */
    IfxPmsPm_RtcOutput_cmp0     = 2,  /**< \brief CMP0 compare output */
    IfxPmsPm_RtcOutput_cmp1     = 3   /**< \brief CMP1 compare output */
} IfxPmsPm_RtcOutput;

/** \brief Enumeration describing SCR boot mode.
 * As defined in SCR_CON0.SCRCFG
 */
typedef enum
{
    IfxPmsPm_ScrBootMode_userMode,           /**< \brief User Mode is selected */
    IfxPmsPm_ScrBootMode_socDapOrSpd,        /**< \brief Ocds mode with debug from SOC(DAP/SPD) selected */
    IfxPmsPm_ScrBootMode_pinDap0_0OrDap1_0,  /**< \brief Ocds mode with SCR pins DAP0_0 or SCR DAP1_0 selected */
    IfxPmsPm_ScrBootMode_pinDap0_1OrDap1_1,  /**< \brief Ocds mode with SCR pins DAP0_1 or SCR DAP1_1 selected */
    IfxPmsPm_ScrBootMode_pinSpd0,            /**< \brief Ocds mode with SCR pin SPD_0 selected */
    IfxPmsPm_ScrBootMode_pinSpd1             /**< \brief Ocds mode with SCR pin SPD_1 selected */
} IfxPmsPm_ScrBootMode;

/** \brief Defines Clocking options for SCR in SCR_CON0.
 */
typedef enum
{
    IfxPmsPm_ScrClocking_startswith70kHz = 0,  /**< \brief SCR starts with 70 kHz clock. SCR can override and
                                                * request 100 MHz clock activation through SCU_CLK.DIV_REQ
                                                * settings. If SCU_CLK.DIV_REQ = 0xF, then SCR boots with
                                                * 70 kHz clock. */
    IfxPmsPm_ScrClocking_startswith20MHz = 1   /**< \brief SCR starts with 20MHz clock. SCR can override the
                                                * SCU_CLK.DIV_REQ setting. If SCU_CLK.DIV_REQ = 0xF,
                                                * then based on the SCR request, the 100 MHz clock is switched off. */
} IfxPmsPm_ScrClocking;

/** \brief Enumeration of SCR FLags
 */
typedef enum
{
    IfxPmsPm_ScrFlag_ecc      = 0,  /**< \brief Ecc error flag */
    IfxPmsPm_ScrFlag_wdt      = 1,  /**< \brief watchdog timer error flag */
    IfxPmsPm_ScrFlag_pinReset = 2,  /**< \brief Pin reset flag */
    IfxPmsPm_ScrFlag_swReset  = 3,  /**< \brief Software reset flag */
    IfxPmsPm_ScrFlag_reset    = 4   /**< \brief Reset indication flag. Flag is set on every scr reset caused by an Scr reset source */
} IfxPmsPm_ScrFlag;

/** \brief SCR trigger transition from STDBY1 to STDBY0
 */
typedef enum
{
    IfxPmsPm_ScrTriggerTransition_disable = 0,  /**< \brief Transition from STBY1 to STBY0 is disabled */
    IfxPmsPm_ScrTriggerTransition_enable  = 1   /**< \brief Transition from STBY1 to STBY0 is enabled */
} IfxPmsPm_ScrTriggerTransition;

/** \brief Standby Mode selection STANDBY0 or STANDBY1
 */
typedef enum
{
    IfxPmsPm_StandbyModeSelection_stdby0 = 0,  /**< \brief STBY0 state is selected in standby mode */
    IfxPmsPm_StandbyModeSelection_stdby1 = 1   /**< \brief STBY1 state is selected in standby mode */
} IfxPmsPm_StandbyModeSelection;

/** \brief The RAM being used in Standby mode
 * As defined in STANDBY_CON0.B.SBRAMSEL
 */
typedef enum
{
    IfxPmsPm_StandbyRamSupply_never                 = 0,  /**< \brief Standby RAM is not supplied */
    IfxPmsPm_StandbyRamSupply_cpu0_64Kb             = 1,  /**< \brief Standby RAM CPU0 dLMU 64kB is supplied */
    IfxPmsPm_StandbyRamSupply_cpu0_128Kb            = 3,  /**< \brief Standby RAM (CPU0 dLMU 128kB are supplied) is supplied */
    IfxPmsPm_StandbyRamSupply_cpu1_64Kb             = 16, /**< \brief Standby RAM CPU1 dLMU 64kB supplied */
    IfxPmsPm_StandbyRamSupply_cpu0_64Kb_cpu1_64Kb   = 17, /**< \brief Standby RAM CPU0 dLMU 64kB and CPU1 dLMU 64kB is supplied */
    IfxPmsPm_StandbyRamSupply_cpu0_128Kb_cpu1_64Kb  = 19, /**< \brief Standby RAM CPU0 dLMU 128kB and CPU1 dLMU 64kB supplied */
    IfxPmsPm_StandbyRamSupply_cpu1_128Kb            = 48, /**< \brief Standby RAM (CPU1 dLMU 128kB are supplied) is supplied */
    IfxPmsPm_StandbyRamSupply_cpu0_64Kb_cpu1_128Kb  = 49, /**< \brief Standby RAM CPU0 dLMU 64kB and CPU1 dLMU 128kB supplied */
    IfxPmsPm_StandbyRamSupply_cpu0_128Kb_cpu1_128Kb = 51  /**< \brief Standby RAM (CPU0 dLMU 128kB and CPU1 dLMU 128kB are supplied) is supplied */
} IfxPmsPm_StandbyRamSupply;

/** \brief Enumeration for SCR RAM Supply
 */
typedef enum
{
    IfxPmsPm_StandbySCRRamSupply_nosupply = 0,  /**< \brief No SCR RAM supply in STANDBY0 mode */
    IfxPmsPm_StandbySCRRamSupply_supply   = 1   /**< \brief SCR ram supply in STDBY0 mode */
} IfxPmsPm_StandbySCRRamSupply;

/** \brief Defines events to trigger entry to Standby mode.
 */
typedef enum
{
    IfxPmsPm_StandbyTriggerMode_software                     = 0,  /**< \brief Standby request using SMM_PMCSR0.B.REQSLP */
    IfxPmsPm_StandbyTriggerMode_hardware_undervoltage_vddext = 1,  /**< \brief Standby trigger arising from VDDEXT undervoltage */
    IfxPmsPm_StandbyTriggerMode_hardware_undervoltage_vdd    = 2,  /**< \brief Standby trigger arising from VDD undervoltage */
    IfxPmsPm_StandbyTriggerMode_hardware_esr1                = 4,  /**< \brief Standby request arising from any ESR1 pin assertion */
    IfxPmsPm_StandbyTriggerMode_hardware_esr2                = 3   /**< \brief Standby request arising from any ESR2 pin assertion */
} IfxPmsPm_StandbyTriggerMode;

/** \brief Enumeration describing the status of an operation
 */
typedef enum
{
    IfxPmsPm_Status_success = 0,  /**< \brief operation successful */
    IfxPmsPm_Status_failure = 1   /**< \brief operation failed */
} IfxPmsPm_Status;

/** \brief Enumeration for wakeup event
 */
typedef enum
{
    IfxPmsPm_WakeupEvent_esr2       = 0,  /**< \brief ESR2 wakeup event */
    IfxPmsPm_WakeupEvent_pinb       = 1,  /**< \brief PinB wakeup event */
    IfxPmsPm_WakeupEvent_pinc       = 2,  /**< \brief PinC wakeup event */
    IfxPmsPm_WakeupEvent_pinsext    = 3,  /**< \brief VDDEXT pins wakeup event */
    IfxPmsPm_WakeupEvent_pinssb     = 4,  /**< \brief VDDEVRSB pins wakeup event */
    IfxPmsPm_WakeupEvent_rtc        = 5,  /**< \brief RTC wakeup event */
    IfxPmsPm_WakeupEvent_wut        = 6,  /**< \brief WUT wakeup event */
    IfxPmsPm_WakeupEvent_pwr        = 7,  /**< \brief wakeup event on VDDEXT supply ramp up */
    IfxPmsPm_WakeupEvent_esr2Ovrun  = 16, /**< \brief ESR2 overrun event */
    IfxPmsPm_WakeupEvent_pinbOvrun  = 17, /**< \brief PinB overrun event */
    IfxPmsPm_WakeupEvent_pincOvrun  = 18, /**< \brief PinC overrun event */
    IfxPmsPm_WakeupEvent_rtcOvrun   = 19, /**< \brief RTC overrun event */
    IfxPmsPm_WakeupEvent_wutOvrun   = 20, /**< \brief WUT overrun event */
    IfxPmsPm_WakeupEvent_esr0       = 32, /**< \brief ESR0 wakeup event */
    IfxPmsPm_WakeupEvent_esr1       = 33, /**< \brief ESR1 wakeup event */
    IfxPmsPm_WakeupEvent_pina       = 34, /**< \brief PINA wakeup event */
    IfxPmsPm_WakeupEvent_scr        = 35, /**< \brief SCR wakeup event */
    IfxPmsPm_WakeupEvent_porst      = 36, /**< \brief PORST wakeup event */
    IfxPmsPm_WakeupEvent_esr0Ovrun  = 48, /**< \brief ESR0 overrun event */
    IfxPmsPm_WakeupEvent_esr1Ovrun  = 49, /**< \brief ESR1 overrun event */
    IfxPmsPm_WakeupEvent_pinaOvrun  = 50, /**< \brief PINA overrun event */
    IfxPmsPm_WakeupEvent_scrOvrun   = 51, /**< \brief SCR overrun event */
    IfxPmsPm_WakeupEvent_porstOvrun = 52  /**< \brief PORST overrun event */
} IfxPmsPm_WakeupEvent;

/** \brief Enumeration for wakeup register
 */
typedef enum
{
    IfxPmsPm_WakeupReg_0 = 0,  /**< \brief Selection of wakeup register 0. (WAKEUP_CON0, WAKEUP_STAT0, WAKEUP_CLR0) */
    IfxPmsPm_WakeupReg_1 = 1   /**< \brief Selection of wakeup register 1. (WAKEUP_CON1, WAKEUP_STAT1, WAKEUP_CLR1) */
} IfxPmsPm_WakeupReg;

/** \brief Wakeup enable configuration from STANDBY mode.
 */
typedef enum
{
    IfxPmsPm_WakeupStandbyModeSel_disable        = 0,  /**< \brief Wakeup is disabled */
    IfxPmsPm_WakeupStandbyModeSel_stdbyTorun     = 1,  /**< \brief Wake-up from any STANDBY to RUN mode */
    IfxPmsPm_WakeupStandbyModeSel_stdby0Tostdby1 = 2,  /**< \brief Wake-up from STANDBY0 to STANDBY1 */
    IfxPmsPm_WakeupStandbyModeSel_sequentialwkp  = 3   /**< \brief Sequential wakeup from STANDBY0 to STANDBY1 and  STANDBY1 to Run */
} IfxPmsPm_WakeupStandbyModeSel;

/** \brief Enumeration for Enable/Disable Wakeup timer
 */
typedef enum
{
    IfxPmsPm_Wut_disable = 0,  /**< \brief Disable WUT */
    IfxPmsPm_Wut_enable  = 1   /**< \brief Enabel WUT */
} IfxPmsPm_Wut;

/** \brief Wakeup timer clock configuration.
 */
typedef enum
{
    IfxPmsPm_WutClock_70kHz       = 0, /**< \brief WUT has a 70 kHz clock input */
    IfxPmsPm_WutClock_70khzdiv210 = 1  /**< \brief WUT has a 70khz/210 */
} IfxPmsPm_WutClock;

/** \brief Select wakup timer operation mode
 * As defined in WUT_CON.B.MODE
 */
typedef enum
{
    IfxPmsPm_WutMode_autoReload       = 0,  /**< \brief WUT auto reload mode selected */
    IfxPmsPm_WutMode_standby0autoStop = 1,  /**< \brief WUT start on STANDBY0 entry */
    IfxPmsPm_WutMode_standby1autoStop = 2   /**< \brief WUT start on STANDBY1 entry */
} IfxPmsPm_WutMode;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pms_Std_Pm_DataStructures
 * \{ */
/** \brief Wakeup events digital filter configuration
 */
typedef struct
{
    IfxPmsPm_DigitalFilterConfiguration esr2DigitalFilterUsage;       /**< \brief Whether to use digital filer with interpreting the pulse on ESR2 pin */
    IfxPmsPm_DigitalFilterConfiguration esr1DigitalFilterUsage;       /**< \brief Whether to use didital filer withe interpreting the pulse on ESR1 pin */
    IfxPmsPm_DigitalFilterConfiguration esr0DigitalFilterUsage;       /**< \brief Whether to use didital filer withe interpreting the pulse on ESR0 pin */
    IfxPmsPm_DigitalFilterConfiguration pinCDigitalFilterUsage;       /**< \brief Whether to use digiital filter with interpreting the pulse on ESR0 pin */
    IfxPmsPm_DigitalFilterConfiguration pinADigitalFilterUsage;       /**< \brief Whether to use didital filer withe interpreting the pulse on PINA pin */
    IfxPmsPm_DigitalFilterConfiguration pinBDigitalFilterUsage;       /**< \brief Whether to use didital filer withe interpreting the pulse on PINB pin */
} IfxPmsPm_WakeupEventsDigitlaFilterConfig;

/** \brief Wakeup Event mode Configuration
 */
typedef struct
{
    IfxPmsPm_WakeupStandbyModeSel stdbyModeWut;           /**< \brief Standby Waken up enable for Wut */
    IfxPmsPm_WakeupStandbyModeSel stdbyModeRtc;           /**< \brief Standby Waken up enable for Rtc */
    IfxPmsPm_WakeupStandbyModeSel stdbyModePinC;          /**< \brief Standby Waken up enable for PINC */
    IfxPmsPm_WakeupStandbyModeSel stdbyModePinB;          /**< \brief Standby Waken up enable for PINB */
    IfxPmsPm_WakeupStandbyModeSel stdbyModeEsr2;          /**< \brief Standby Waken up enable for ESR2 */
    IfxPmsPm_WakeupStandbyModeSel stdbyModePower;         /**< \brief Standby Waken up enable for Power */
    IfxPmsPm_WakeupStandbyModeSel stdbyModePinSSB;        /**< \brief Standby Waken up enable for VDDEVRSB pins */
    IfxPmsPm_WakeupStandbyModeSel stdbyModePinSEXT;       /**< \brief Standby Waken up enable for VDDEXT pins */
} IfxPmsPm_WakeupEventsModeConfig;

/** \brief Wakeup Events Trigger Configuration
 */
typedef struct
{
    IfxPmsPm_PinEdgeTriggerEvent esr2TriggerEvent;       /**< \brief Trigger will be generated on which pulse edge of a pulse on ESR2 pin. */
    IfxPmsPm_PinEdgeTriggerEvent esr0TriggerEvent;       /**< \brief Trigger will be generated on which pulse edge of a pulse on ESR0 pin. */
    IfxPmsPm_PinEdgeTriggerEvent esr1TriggerEvent;       /**< \brief Trigger will be generated on which pulse edge of a pulse on ESR1 pin. */
    IfxPmsPm_PinEdgeTriggerEvent pinATriggerEvent;       /**< \brief Trigger will be generated on which pulse edge of a pulse on PINA pin. */
    IfxPmsPm_PinEdgeTriggerEvent pinBTriggerEvent;       /**< \brief Trigger will be generated on which pulse edge of a pulse on PINB pin. */
    IfxPmsPm_PinEdgeTriggerEvent pinCTriggerEvent;       /**< \brief Trigger will be generated on which pulse edge of a pulse on Pin C. */
} IfxPmsPm_WakeupEventsTriggerConfig;

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_DataStructures
 * \{ */
/** \brief DTS limit configuration for UPPER, LOWER and TSD
 */
typedef struct
{
    uint16 threshold;        /**< \brief Temperature-sensing mode warning threshold */
    uint8  hysteresis;       /**< \brief Temperature-sensing mode warning hysteresis */
    uint8  filter;           /**< \brief Temperature-sensing mode warning filter */
} IfxPmsPm_DtsLimitConfig;

/** \brief PAD configuration
 */
typedef struct
{
    IfxPmsPm_PadStateRequest allPads;                   /**< \brief Request to remain in input with weak pull-up or get into tristate.Tristate Enable for all Pads */
    IfxPmsPm_PadStateRequest standbyPads;               /**< \brief Request to remain in input with weak pull-up or get into tristate. Tristate Enable for Standby Pads */
    IfxPmsPm_PinStateRequest esr0PinStateRequest;       /**< \brief Request to remain in input with weak pull-up or get into tristate. */
} IfxPmsPm_PadConfig;

/** \brief Core power domain enable/disable configuration
 */
typedef struct
{
    IfxPmsPm_PowerDown ppu;        /**< \brief Enable/Disable power down of PPU power domain */
    IfxPmsPm_PowerDown lmu0;       /**< \brief Enable/Disable power down of LMU0 power domain */
    IfxPmsPm_PowerDown lmu1;       /**< \brief Enable/Disable power down of LMU1 power domain */
} IfxPmsPm_PowerDownEnableConfig;

/** \brief SCR configuration
 */
typedef struct
{
    boolean                       enableScr;                  /**< \brief Whether to enable SCR or not. */
    IfxPmsPm_ScrTriggerTransition scrTriggerTransition;       /**< \brief Options for SCR trigger transition from STDBY1 to STDBY0 */
    IfxPmsPm_ScrClocking          scrClockSupply;             /**< \brief Options for SCR clock supply */
} IfxPmsPm_ScrConfig;

/** \brief Standby configuration
 */
typedef struct
{
    boolean                             enableVddextdcPowerDown;       /**< \brief Enable power down of Vddextdc during standby mode */
    IfxPmsPm_StandbyRamSupply           standbyRamBlock;               /**< \brief Options for which part of the DLMU can be provided supply during standby. */
    IfxPmsPm_StandbyModeSelection       standbyModeSel;                /**< \brief Options for Standby mode selection */
    IfxPmsPm_StandbySCRRamSupply        standbySCRRamSupply;           /**< \brief Options for SCR RAM supply in STANDBY0 Mode */
    IfxPmsPm_DigitalFilterConfiguration esr2DigitalFilterUsage;        /**< \brief Esr2 digital filter enable for standby entry trigger */
} IfxPmsPm_StandbyEntryConfig;

/** \brief Voltage configuration
 */
typedef struct
{
    float32                          vextUnderVoltageThreshold;         /**< \brief Undervoltage threshold for VddEXT */
    float32                          vddUnderVoltageThreshold;          /**< \brief Undervoltage threshold for VDD */
    uint8                            vextFilter;                        /**< \brief VMONS_VxxCON.FILTER+1 consecutive threshold violations to trigger OV?UV event */
    uint8                            vddFilter;                         /**< \brief VMONS_VxxCON.FILTER+1 consecutive threshold violations to trigger OV?UV event */
    IfxPmsEvr_UnderVoltageMonitoring vextUnderVoltageMode;              /**< \brief Vddext Under-Voltage Monitoring Mode */
    IfxPmsEvr_UnderVoltageMonitoring vddUnderVoltageMode;               /**< \brief Vdd Under-Voltage Monitoring Mode */
    boolean                          enableStandbyOnVextRampDown;       /**< \brief Enable Standby On VddEXT Ramp Down */
    boolean                          enableStandbyOnVddRampDown;        /**< \brief Enable Standby On VDD Ramp Down */
} IfxPmsPm_VoltageConfig;

/** \brief Wakeup configuration
 */
typedef struct
{
    boolean                                  enableWakeupOnScr;         /**< \brief Enable wake-up on request from SCR */
    boolean                                  enableWakeupOnPorst;       /**< \brief Enable wake-up on PORST pin assertion */
    boolean                                  enableWakeupOnPinA;        /**< \brief Enable wake-up on PINA */
    boolean                                  enableWakeupOnEsr0;        /**< \brief Enable wake-up on ESR0 */
    boolean                                  enableWakeupOnEsr1;        /**< \brief Enable wake-up on ESR1 */
    IfxPmsPm_WakeupEventsModeConfig          wakeupEvent;               /**< \brief Wakeup event mode configuration */
    IfxPmsPm_WakeupEventsDigitlaFilterConfig eventFilterConfig;         /**< \brief Wakeup pins digital filter configuration */
    IfxPmsPm_WakeupEventsTriggerConfig       edgeTrigger;               /**< \brief Wakeup pins edge trigger configuration */
} IfxPmsPm_WakeupConfig;

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_DataStructures
 * \{ */
/** \brief DTS Configuration
 */
typedef struct
{
    IfxPmsPm_Dts              dtsenable;           /**< \brief Enable/Disable DTS circuitry */
    IfxPmsPm_DtsAdcConversion adcConversion;       /**< \brief Start/Stop DTS Adc conversion */
    IfxPmsPm_DtsWarning       warning;             /**< \brief Enable/Disable DTS Warning */
    IfxPmsPm_DtsPeakTemp      peakTemp;            /**< \brief Reset peak temperature detector */
    IfxPmsPm_DtsLimitConfig  *lower;               /**< \brief Falling configuration */
    IfxPmsPm_DtsLimitConfig  *upper;               /**< \brief Rising configuration */
    IfxPmsPm_DtsLimitConfig  *tsd;                 /**< \brief TSD configuration */
} IfxPmsPm_DtsConfig;

/** \brief Memory Configuration structure
 */
typedef struct
{
    void  *src;        /**< \brief Source Address pointer. */
    void  *dest;       /**< \brief Destination Address pointer */
    uint32 size;       /**< \brief Size of data to copy */
} IfxPmsPm_MemoryConfig;

/** \brief Power Gating Configuration
 */
typedef struct
{
    IfxPmsPm_PowerDownEnableConfig   powerDown;           /**< \brief Enable/Disable power down of core power domain */
    IfxPmsPm_PowerSwitchCLockDivider ppuClkDivider;       /**< \brief PPU power switch rate clock divider */
    IfxPmsPm_PowerSwitchCLockDivider lmuClkDivider;       /**< \brief LMU power switch rate clock divider. */
} IfxPmsPm_PowerGatingConfig;

/** \brief Clock configuration for RTC
 */
typedef struct
{
    boolean            oscEnable;          /**< \brief RTC Oscillator Enable/Disable.Set TRUE for 32Khz clock */
    boolean            ampRegEnable;       /**< \brief Amplitude Regulation for RTC */
    IfxPmsPm_RtcGain   gainSel;            /**< \brief RTC gain selection */
    boolean            hystEnable;         /**< \brief Hysteresis Enable/Disable */
    IfxPmsPm_RtcOutput rtcOutSel;          /**< \brief RTC Output to Pins and Timers */
    boolean            enableRtc;          /**< \brief RTC enable/disable */
    uint16             clockDivider;       /**< \brief RTC clock divider */
} IfxPmsPm_RtcClockConfig;

/** \brief RTC compare configuration
 */
typedef struct
{
    IfxPmsPm_RtcMsize  mSize0;        /**< \brief Compare Size for CMP0 */
    IfxPmsPm_RtcMsize  mSize1;        /**< \brief Compare Size for CMP1 */
    IfxPmsPm_RtcMstart mStart0;       /**< \brief Start Bit Location for CMP0 */
    IfxPmsPm_RtcMstart mStart1;       /**< \brief Start Bit Location for CMP1 */
    uint32             cmpVal0;       /**< \brief Compare vlaue for CMP0 */
    uint32             cmpVal1;       /**< \brief Compare vlaue for CMP1 */
} IfxPmsPm_RtcCmpConfig;

/** \brief RTC 64 bit timer capture
 */
typedef struct
{
    uint32 lowerPart;       /**< \brief Lower 32 bit timer capture value */
    uint32 upperPart;       /**< \brief Upper 32 bit timer capture value */
} IfxPmsPm_RtcTimerCaptureType;

/** \brief Configurable Standby options
 */
typedef struct
{
    IfxPmsPm_StandbyTriggerMode  trigger;                    /**< \brief Events which'll trigger Standby mode */
    IfxPmsPm_BlankingFilterDelay minDelayBeforeWakeUp;       /**< \brief Selecting the duration, starting from Standby entry, after which wake-up triggers are effective. */
    IfxPmsPm_ScrConfig           scrCfg;                     /**< \brief SCR configuration */
    IfxPmsPm_StandbyEntryConfig  standbyCfg;                 /**< \brief Standby configuration */
    IfxPmsPm_VoltageConfig       voltageCfg;                 /**< \brief Vdd/Vddext under voltage threshold and mode configuration */
    IfxPmsPm_PadConfig           padCfg;                     /**< \brief Pad configuration */
    IfxPmsPm_WakeupConfig        wakeupCfg;                  /**< \brief Wakeup configuration */
    IfxCpu_ResourceCpu           masterCpu;                  /**< \brief CPU which can call powerdown modes.In IfxPmsPm_startStandbySequenceInFlash(),this value is being filled to reflect the core in which standby sequence is running as we're explicitly making it as the master CPU. */
} IfxPmsPm_StandbyConfig;

/** \brief Wake up timer configuration
 */
typedef struct
{
    uint32            reloadValue;       /**< \brief Reload value for Wut. */
    IfxPmsPm_WutClock clockDiv;          /**< \brief Wut Clock */
    IfxPmsPm_WutMode  mode;              /**< \brief Wut mode */
    boolean           enableWut;         /**< \brief Enable/Disable WUT timer */
} IfxPmsPm_WutConfig;

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_SystemModes
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function will initialize the configuration structure with default values.
 * NOTE:
 *
 * 1. Default values of vextUnderVoltageThreshold and vddUnderVoltageThreshold in the StandbyConfig structure are set to 0.
 * Set it to appropriate levels(depending on application) before calling IfxPmsPm_startStandbySequenceInFlash().
 * 2. Common API is implemented for entering standby with only Vddevrsb supplied and both supplied.
 * 3. Configuring values as per the standby entry should be taken care by the user.
 * \param standbyConfig Configurable options for Standby Mode
 * \return None
 *
 * Coding example:
 * \code
 * //Create a global variable
 * IfxPmsPm_StandbyConfig stdbyconfig;
 * IfxPmsPm_initStandbyConfig(&stdbyconfig);
 *
 * //Change the values as per the application need
 * stdbyconfig.vextUnderVoltageThreshold value;
 * stdbyconfig.vddUnderVoltageThreshold = value;
 *
 * //If the standby entry is through hardware no need to configure the application hooks
 * //If the standby entry is through software follow the sequence. Configure the application hooks in Ifx_Cfg.h
 * //Refer IfxPms_cfg.h for hooks configuration
 * IFXPMS_DISABLE_ALL_MODULES_STANDBY
 * IFXPMS_CLOCK_REDUCTION
 * IFXPMS_DISABLE_INTERRUPT_WATCDHDOG_DCADCHE_WRITEBACK
 * IfxPmsPm_startStandbySequenceInFlash(&MODULE_PMS,&stdbyconfig);
 *
 * //Locate IfxPmsPm_continueStandbySequenceInRAM in RAM section if FLASH is disabled.
 * //Configure the application hooks in Ifx_Cfg.h. Refer IfxPms_cfg.h for hooks configuration
 * IFXPMS_DISABLE_FLASH
 * IfxPmsPm_continueStandbySequenceInRAM((&MODULE_PMS,&stdbyconfig);
 *
 * //Enter standby mode through software trigger
 * IfxPmsPm_standbyModeEntry();
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_initStandbyConfig(IfxPmsPm_StandbyConfig *standbyConfig);

/** \brief The function will perform the following things of standby sequence.
 *  - Standby entry is enabled for events. Overrun and wakeup flags are cleared.
 *  - Disable standby SMU. Set IRADIS bit
 *  - UVVAL and UVMOD values are set for Vddext and Vdd
 *
 * Note
 * - If the entry is software triggered then only the application hooks should be configured.
 * - Common Application Hook is provided for disabling of interrupts,placing other CPU to idle and disabling of other CPU watchdog
 * -  Application hook is provided to disable the peripheral module clocks. IFXPMS_DISABLE_ALL_MODULES_STANDBY
 * - Application hook is provided to set the clock dividers and switching the clock to 100Mhz. IFXPMS_CLOCK_REDUCTION
 * \param pms Pointer to pms module
 * \param standbyConfig Configuration structure with initialized Standby configuration options
 * \return None
 *
 * \see IfxPmsPm_initStandbyConfig()
 *
 */
IFX_EXTERN void IfxPmsPm_startStandbySequenceInFlash(Ifx_PMS *pms, IfxPmsPm_StandbyConfig *standbyConfig);

/** \brief The function will perform the following things of standby sequence
 *  - Disabling reset possibilities.
 *  - Writeback to the DCache of master cpu.
 *  - Standby mode, SCR, blanking filter and PAD related configurations
 *  - Wakeup configurations
 *
 * Note:
 *  - If the entry is software triggered then only the application hooks should be configured.
 *  - Writeback of the other CPU DCache should be taken care by the user.
 *  - Application hook for disabling the Flash.IFXPMS_DISABLE_FLASH
 * \param pms Pointer to PMS module.
 * \param standbyConfig Configuration structure with initialized Standby configuration options
 * \return None
 *
 * \see IfxPmsPm_initStandbyConfig()
 *
 */
IFX_EXTERN void IfxPmsPm_continueStandbySequenceInRAM(Ifx_PMS *pms, IfxPmsPm_StandbyConfig *standbyConfig);

/** \brief Standby mode entry trigger on Software request.
 * \return None
 */
IFX_EXTERN void IfxPmsPm_standbyModeEntry(void);

/** \brief Copy data from source address to destination address.
 * \param srcAddr Pointer to source address
 * \param destAddr Pointer to destination address
 * \param dataSize Size of Data
 * \return None
 */
IFX_EXTERN void IfxPmsPm_copyData(void *srcAddr, void *destAddr, uint32 dataSize);

/** \brief API to configure standby mode entries
 * \param pms Pointer to PMS module.
 * \param trigger Selection for standby entries..
 * \return None
 */
IFX_EXTERN void IfxPmsPm_configureStandbyEntries(Ifx_PMS *pms, IfxPmsPm_StandbyTriggerMode trigger);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_WakeupModes
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to Enable/Disable RTC
 * \param pms Pointer to PMS module SFR
 * \param enable Enable/DIsable RTC
 *  0 --> Disable RTC
 *  1 --> Enable RTC
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_enableRtc(&MODULE_PMS, IfxPmsPm_Rtc_disable);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_enableRtc(Ifx_PMS *pms, IfxPmsPm_Rtc enable);

/** \brief Returns 64 bit read timer value
 * \param pms Pointer to PMS module SFR
 * \return RTC 64 bit timer value
 *
 * Coding example:
 * \code
 * IfxPmsPm_RtcTimerCaptureType rtcTim_value;
 * rtcTim_value = IfxPmsPm_readRtcTotalTimerValue(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE IfxPmsPm_RtcTimerCaptureType IfxPmsPm_readRtcTotalTimerValue(Ifx_PMS *pms);

/** \brief Function to Enable/Disable Wakeup timer.
 * \param pms Pointer to PMS module Sfr
 * \param enable Enable/Disable WUT
 * 0 --> Disable WUT
 * 1 --> Enable WUT
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_enableWut(&MODULE_PMS, IfxPmsPm_Wut_disable);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_enableWut(Ifx_PMS *pms, IfxPmsPm_Wut enable);

/** \brief Returns WUT 24bit counter value
 * \param pms Pointer to PMS module sfr
 * \return WUT counter value
 *
 * Coding example:
 * \code
 *  uint32 value;
 *  value =  IfxPmsPm_getWutCounterValue(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE uint32 IfxPmsPm_getWutCounterValue(Ifx_PMS *pms);

/** \brief Returns WUT operating mode
 * \param pms Pointer to PMS module sfr
 * \return WUT mode
 *
 * \code
 *   if(IfxPmsPm_getWutMode(&MODULE_PMS) == IfxPmsPm_WutMode_autoReload)
 *   {
 *     \\
 *   }
 * \endcode
 *
 */
IFX_INLINE IfxPmsPm_WutMode IfxPmsPm_getWutMode(Ifx_PMS *pms);

/** \brief Returns WUT run status
 * \param pms Pointer to PMS module sfr
 * \return WUT Run status
 *  0 --> Wake-up timer (WUT) is inactive
 *  1 --> Wake-up timer (WUT) is active.
 *
 * \code
 *    if(IfxPmsPm_getWutRunStatus(&MODULE_PMS))
 *    {
 *      \\
 *    }
 * \endcode
 *
 */
IFX_INLINE boolean IfxPmsPm_getWutRunStatus(Ifx_PMS *pms);

/** \brief Function to set trim value for RTC
 * \param pms Pointer to PMS module sfr
 * \param offset signed offset to be added to RTC_CMP1
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_setRtcOffset(&MODULE_PMS, usr_value);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_setRtcOffset(Ifx_PMS *pms, uint16 offset);

/** \brief Function to get wakeup event status
 * \param pms Pointer to PMS module SFR
 * \param event Wakeup event selection
 * \return FALSE - No wakeup event
 * TRUE - Wakeup event detected
 *
 * Coding example:
 * \code
 *   if(IfxPmsPm_getWakeupEventStatus(&MODULE_PMS, IfxPmsPm_Wakeup_esr2))
 *  { //code }
 * \endcode
 *
 */
IFX_INLINE boolean IfxPmsPm_getWakeupEventStatus(Ifx_PMS *pms, IfxPmsPm_WakeupEvent event);

/** \brief Function to clear given wakeup evnt status.
 * \param pms Pointer to PMS module SFR
 * \param event selection of event which is to be cleared
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_clearWakeupEventStatus(&MODULE_PMS, IfxPmsPm_Wakeup_esr2);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_clearWakeupEventStatus(Ifx_PMS *pms, IfxPmsPm_WakeupEvent event);

/** \brief Function to clear all wakeup event status of given register.
 * \param pms Pointer to PMS module SFR
 * \param reg selection of event status register
 * \return None
 *
 * Coding example:
 * \code
 *   // Clear all wakeup event flags present in WAKEUP_STAT0.
 *   IfxPmsPm_clearWakeupEventStatusReg(&MODULE_PMS,IfxPmsPm_WakeupReg_0);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_clearWakeupEventStatusReg(Ifx_PMS *pms, IfxPmsPm_WakeupReg reg);

/** \brief Function to Enable/Disable 32khz oscillator as RTC input.
 * NOTE : Oscillator need max 5s to start up as per DS.
 * \param pms Pointer to PMS module SFR
 * \param enable Enable/DIsable oscillator
 *  IfxPmsPm_Rtc_disable --> Disable oscillator
 *  IfxPmsPm_Rtc_enable --> Enable oscillator
 * \return None
 *
 * Coding example:
 *  \code
 *     IfxPmsPm_enableRtcOscillator(&MODULE_PMS, IfxPmsPm_Rtc_enable);
 *  \endcode
 *
 */
IFX_INLINE void IfxPmsPm_enableRtcOscillator(Ifx_PMS *pms, IfxPmsPm_Rtc enable);

/** \brief Function to select RTC clock source.
 * \param pms Pointer to PMS module SFR
 * \param clkSrc clock source
 * \return None
 *
 * Coding example:
 * \code
 *   //For 32 Khz
 *   IfxPmsPm_enableRtcOscillator(&MODULE_PMS, IfxPmsPm_Rtc_enable);
 *   // Delay of max 5s for oscillator to start up
 *   IfxPmsPm_selectRtcClockSource(&MODULE_PMS, IfxPmsPm_RtcClk_32Khz);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_selectRtcClockSource(Ifx_PMS *pms, IfxPmsPm_RtcClk clkSrc);

/** \brief API to check if WUT enabled or not
 * \param pms Pointer to PMS module sfr
 * \return WUT Enable status
 *  0 --> Wake-up timer (WUT) is disabled
 *  1 --> Wake-up timer (WUT) is enabled.
 */
IFX_INLINE boolean IfxPmsPm_isWutEnabled(Ifx_PMS *pms);

/** \brief Function to select RTC wakeup
 * \param pms Pointer to PMS module sfr
 * \param rtcWkp selection for RTC wakeup on CMP0/CMP1
 * \return None
 */
IFX_INLINE void IfxPmsPm_selectRtcWakeup(Ifx_PMS *pms, IfxPmsPm_RtcCmp rtcWkp);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Wakeup Configuration for Standby sequence.
 * \param pms Pointer to PMS module
 * \param wakeupConfig Pointer to Wakeup Configuration Structure
 * \return None
 */
IFX_EXTERN void IfxPmsPm_configureWakeup(Ifx_PMS *pms, IfxPmsPm_WakeupConfig *wakeupConfig);

/** \brief API will configure Wakeup timer with given configuration
 * \param pms Pointer to PMS module
 * \param wutConfig Configuration for Wut.
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_WutConfig config;
 *   config.reloadValue  =  value;
 *   config.clockDiv     =  IfxPmsPm_WutClock_70kHz;
 *   config.mode         =  IfxPmsPm_WutMode_autoReload;
 *   config.enable       =  FALSE;
 *   IfxPmsPm_wutConfiguration(&MODULE_PMS,&config);
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_wutConfiguration(Ifx_PMS *pms, IfxPmsPm_WutConfig *wutConfig);

/** \brief API will configure RTC clock with given configuration
 * \param pms Pointer to PMS module
 * \param rtcClkConfig Clock related configuration for RTC
 * \return None
 *
 * Coding example:
 * \code
 * IfxPmsPm_RtcClockConfig config;
 * config.oscEnable       =  TRUE;
 * config.ampRegEnable    =  FALSE;
 * config.gainSel         =  IfxPmsPm_RtcGain_2x;
 * config.hystEnable      =  FALSE;
 * config.rtcOutSel       =  IfxPmsPm_RtcOutput_noOutput;
 * config.enableRtc       =  FALSE;
 * config.clockDivider    =  div_value;
 *
 * //32Khz clock
 * {
 *  IfxPmsPm_rtcClockConfiguration(&MODULE_PMS,&config);
 *  // Delay of max 5s for oscillator to start as per DS
 *  uint32 waitTicks = IfxStm_getTicksFromMilliseconds(5000);
 *  IfxStm_wait(waitTicks);
 *  IfxPmsPm_selectRtcClockSource(&MODULE_PMS, IfxPmsPm_RtcClk_32Khz);
 *  //Do RTC comparator configuration Refer \ref IfxPmsPm_rtcCmpConfiguration
 *  //Enable Rtc
 *  IfxPmsPm_enableRtc(&MODULE_PMS, IfxPmsPm_Rtc_enable);
 * }
 *
 * //70Khz clock
 * {
 *  IfxPmsPm_rtcClockConfiguration(&MODULE_PMS,&config);
 *  IfxPmsPm_selectRtcClockSource(&MODULE_PMS, IfxPmsPm_RtcClk_70Khz);
 *  //Do RTC comparator configuration Refer \ref IfxPmsPm_rtcCmpConfiguration
 *  IfxPmsPm_enableRtc(&MODULE_PMS, IfxPmsPm_Rtc_enable);
 * }
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_rtcClockConfiguration(Ifx_PMS *pms, IfxPmsPm_RtcClockConfig *rtcClkConfig);

/** \brief API will configure RTC compare registers with given configuration.
 * \param pms Pointer to PMS module
 * \param rtcCmpConfig RTC compare operation configuration
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_RtcCmpConfig  cmpConfig;
 *   cmpConfig.mSize0       =  IfxPmsPm_RtcMsize_0;
 *   cmpConfig.mSize1       =  IfxPmsPm_RtcMsize_0;
 *   cmpConfig.mStart0      =  IfxPmsPm_RtcMstart_0;
 *   cmpConfig.mStart1      =  IfxPmsPm_RtcMstart_0;
 *   cmpConfig.cmpVal0      =  cmp_value;
 *   cmpConfig.cmpVal1      =  cmp_value;
 *   IfxPmsPm_rtcCmpConfiguration(&MODULE_PMS,&cmpConfig);
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_rtcCmpConfiguration(Ifx_PMS *pms, IfxPmsPm_RtcCmpConfig *rtcCmpConfig);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_Digitalfilter
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configuration of PORST digital filter.
 * \param pms Pointer to PMS module.
 * \param filterConfig PORST digital filter enable value.
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_porstdigitalfilter(&MODULE_PMS, IfxPmsPm_PorstDigitalFilter_analogfilter);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_porstdigitalfilter(Ifx_PMS *pms, IfxPmsPm_PorstDigitalFilter filterConfig);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Digital filter enable/disable for ESR0,ESR1,ESR2,PINA,PINB and PINC
 * \param pms Pointer to PMS module
 * \param event Digital filter enable/disable for ESR2,PINC,ESR0,ESR1,PINA and PINB event
 * \param config Configuration to enable digital filter or bypass.
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_digitalFilterEnableDisable(&MODULE_PMS, IfxPmsPm_DigitalFilter_esr2, IfxPmsPm_DigitalFilterConfiguration_bypassed);
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_digitalFilterEnableDisable(Ifx_PMS *pms, IfxPmsPm_DigitalFilter event, IfxPmsPm_DigitalFilterConfiguration config);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_DTS
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable DTS analog circuitry
 * \param pms Pointer to PMS module
 * \param enable Enable/Disable DTS
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_dtsEnable(&MODULE_PMS, IfxPmsPm_Dts_enable);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_dtsEnable(Ifx_PMS *pms, IfxPmsPm_Dts enable);

/** \brief Start DTS conversion
 * \param pms Pointer to PMS module
 * \param enable START/STOP DTS conversion
 * \return None
 *
 * \code
 *   IfxPmsPm_dtsStartAdcConversion(&MODULE_PMS, IfxPmsPm_DtsAdcConversion_start);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_dtsStartAdcConversion(Ifx_PMS *pms, IfxPmsPm_DtsAdcConversion enable);

/** \brief Enable DTS warning
 * \param pms Pointer to PMS module
 * \param enable Enable/Disable DTS warning
 * \return None
 *
 * \code
 *   IfxPmsPm_dtsWarningEnable(&MODULE_PMS, IfxPmsPm_DtsWarning_enable);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_dtsWarningEnable(Ifx_PMS *pms, IfxPmsPm_DtsWarning enable);

/** \brief Reset Peak temperature detector
 * \param pms Pointer to PMS module
 * \return None
 *
 * \code
 *   IfxPmsPm_dtsResetPeakTmpDetector(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_dtsResetPeakTmpDetector(Ifx_PMS *pms);

/** \brief Returns last measured DTS temperature
 * \param pms Pointer to PMS module
 * \return Last measured temperature result.
 *
 * \code
 * uint16 result;
 *   result = IfxPmsPm_getDtsTemperatureResult(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE uint16 IfxPmsPm_getDtsTemperatureResult(Ifx_PMS *pms);

/** \brief Returns last measured DTS temperature in kelvin
 * \param pms Pointer to PMS module
 * \return Last measured temperature result in Kelvin
 *
 * \code
 * float32 result;
 * result = IfxPmsPm_getDtsTemperatureResultKv(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE float32 IfxPmsPm_getDtsTemperatureResultKv(Ifx_PMS *pms);

/** \brief Returns PEAK temperature
 * \param pms Pointer to PMS module
 * \return Peak temperature
 *
 * \code
 * uint16 result;
 * result = IfxPmsPm_getDtsPeakTemperature(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE uint16 IfxPmsPm_getDtsPeakTemperature(Ifx_PMS *pms);

/** \brief Returns DTS Peak temperature in kelvin
 * \param pms Pointer to PMS module sfr.
 * \return Peak temperature result in Kelvin
 *
 * \code
 * float32 result;
 * result = IfxPmsPm_getDtsPeakTemperatureKv(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE float32 IfxPmsPm_getDtsPeakTemperatureKv(Ifx_PMS *pms);

/** \brief Returns DTS analog circuitry is Ready or Busy
 * \param pms Pointer to PMS module sfr
 * \return DTS status
 * 0 --> DTS is busy (Disabled or starting up)
 * 1 --> DTS is ready (completed startup)
 *
 * \code
 * if(IfxPmsPm_getDtsStatus(&MODULE_PMS))
 *   {
 *     \\
 *   }
 * \endcode
 *
 */
IFX_INLINE boolean IfxPmsPm_getDtsStatus(Ifx_PMS *pms);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure DTS limit for Upper,lower and TDS
 * \param pms Pointer to PMS module
 * \param dtsConfig Pointer to DTS configuration
 * \return None
 *
 * \code
 * IfxPmsPm_DtsLimitConfig lowerConfig;
 * lowerConfig.threshold   = thres_value;
 * lowerConfig.hysteresis  = hyst_value;
 * lowerConfig.filter      = filt_value;
 * IfxPmsPm_DtsConfig dtsConfig;
 * dtsConfig.dtsenable        = IfxPmsPm_Dts_disable;
 * dtsConfig.adcConversion    = IfxPmsPm_DtsAdcConversion_stop;
 * dtsConfig.warning          = IfxPmsPm_DtsWarning_disable;
 * dtsConfig.peakTemp         = IfxPmsPm_DtsPeakTemp_noreset;
 * dtsConfig.lower            = &lowerConfig; -->If not required give NULL_PTR
 * dtsConfig.upper            = NULL_PTR;  --> If required configure similar to lower configuration
 * dtsConfig.tsd              = NULL_PTR;
 * IfxPmsPm_configureDts(&MODULE_PMS, &dtsConfig);
 * \endcode
 *
 * \see IfxPmsPm_dtsEnable(), IfxPmsPm_dtsStartAdcConversion(), IfxPmsPm_dtsWarningEnable()
 *      IfxPmsPm_dtsResetPeakTmpDetector(),
 *
 */
IFX_EXTERN void IfxPmsPm_configureDts(Ifx_PMS *pms, IfxPmsPm_DtsConfig *dtsConfig);

/** \} */

/** \addtogroup IfxLld_Pms_Std_Pm_SCRFunctions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to request SCR reset.
 * \param pms Pointer to PMS module SFR
 * \return None
 */
IFX_INLINE void IfxPmsPm_resetScr(Ifx_PMS *pms);

/** \brief Function to enable/disable SCR reset when warm PORST is asserted.
 * \param pms Pointer to PMS module SFR
 * \param enable TRUE --> Enable SCR reset on warm PORST
 * FALSE --> Disable SCR reset on warm PORST
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_enableScrResetOnPorst(&MODULE_PMS, TRUE);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_enableScrResetOnPorst(Ifx_PMS *pms, boolean enable);

/** \brief Function to enable SCR.
 * \param pms Pointer to PMS module SFR
 * \return None
 */
IFX_INLINE void IfxPmsPm_enableScr(Ifx_PMS *pms);

/** \brief Function to disable SCR.
 * \param pms Pointer to PMS module Sfr
 * \return None
 */
IFX_INLINE void IfxPmsPm_disableScr(Ifx_PMS *pms);

/** \brief Function to change SCR bootmode.
 * User should call IfxPmsPm_resetScr function to start off SCR in the chosen mode.
 * \param pms Pointer to PMS module sfr.
 * \param bootMode SCR boot mode selection
 * \return None
 */
IFX_INLINE void IfxPmsPm_changeScrBootMode(Ifx_PMS *pms, IfxPmsPm_ScrBootMode bootMode);

/** \brief Function to configure SCR clock.(SCR_CON0.SCRCLKSEL)
 * \param pms Pointer to PMS module sfr.
 * \param scrClk Scr clock selection.
 * \return None
 */
IFX_INLINE void IfxPmsPm_configureScrClock(Ifx_PMS *pms, IfxPmsPm_ScrClocking scrClk);

/** \brief Function to check if SCR enabled.
 * \param pms Pointer to PMS module SFR
 * \return Return
 * TRUE --> SCR enabled
 * FALSE --> SCR disabled
 */
IFX_INLINE boolean IfxPmsPm_isScrEnabled(Ifx_PMS *pms);

/** \brief Function to trigger interrupt to SCR from PMS/CPUx.
 * Note : Scr should be enabled to do the trigger interrupt to SCR. if not write access is blocked.
 * \param pms Pointer to PMS module SFR
 * \return Return
 * IfxPmsPm_Status_success --> Operation successful
 * IfxPmsPm_Status_failed  --> Operation failed. (SCR not enabled)
 */
IFX_INLINE IfxPmsPm_Status IfxPmsPm_triggerInterruptToScr(Ifx_PMS *pms);

/** \brief Function to send message to SCR from PMS.
 * Note : Scr should be enabled to do the data exchange (SCR_CON0.SCREN = 1), if not write access is blocked.
 * \param pms Pointer to PMS module sfr.
 * \param messageToScr Message to SCR.
 * \return Returns
 * IfxPmsPm_Status_success --> Operation successful
 * IfxPmsPm_Status_failed  --> Operation failed. (SCR not enabled)
 */
IFX_INLINE IfxPmsPm_Status IfxPmsPm_sendMessageToScr(Ifx_PMS *pms, uint8 messageToScr);

/** \brief Function to read message sent from SCR to tricore (SCR_STAT.SCRINT).
 * \param pms Pointer to PMS module sfr.
 * \return Return read message from SCR. (SCR_STAT.SCRINT)
 */
IFX_INLINE uint8 IfxPmsPm_readMessageFromScr(Ifx_PMS *pms);

/** \brief Function to clear SCR status flags.
 * Note : Scr should be enabled to clear Scr status, if not write access is blocked.
 * \param pms Pointer to PMS module sfr.
 * \param scrFlag Scr flag selection
 * \return Returns
 * IfxPmsPm_Status_success --> Operation successful
 * IfxPmsPm_Status_failed  --> Operation failed. (SCR not enabled)
 */
IFX_INLINE IfxPmsPm_Status IfxPmsPm_clearScrStatusFlag(Ifx_PMS *pms, IfxPmsPm_ScrFlag scrFlag);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize the SCR.
 * \param bootMode SCR boot mode selection
 * \param enableReset TRUE --> Enable reset on warm PORST.
 * FALSE --> Disable reset on warm PORST.
 * \param xram Memory configuration to copy the data to XRAM.
 * \return FALSE --> SCR initialization successful
 * TRUE --> SCRT initialization failed.
 *
 * Coding example:
 * \code
 *   IfxPmsPm_MemoryConfig memCfg = {&scrProgram, PMS_XRAM, scrProgramSize};
 *   IfxPmsPm_initScr(IfxPmsPm_ScrBootMode_userMode, FALSE, &memCfg);
 * \endcode
 *
 */
IFX_EXTERN boolean IfxPmsPm_initScr(IfxPmsPm_ScrBootMode bootMode, boolean enableReset, IfxPmsPm_MemoryConfig *xram);

/** \brief Function to copy SCR source code to Xram memory
 * \param srcAddress Source Address of memory
 * \param size Size of data in bytes
 * \return None
 *
 * Coding example:
 * \code
 * IfxPmsPm_copyScrProgram(&scrProgram, scrProgramSize);
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_copyScrProgram(void *srcAddress, uint16 size);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to clear given interrupt status flag.
 * \param pms Pointer to PMS module SFR
 * \param interrupt Select interrupt
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_clearInterruptStatusFlags(&MODULE_PMS,IfxPmsPm_Interrupt_rtcCmp0);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_clearInterruptStatusFlags(Ifx_PMS *pms, IfxPmsPm_Interrupt interrupt);

/** \brief Function to clear all interrupt status flag of INT0_STAT.
 * \param pms Pointer to PMS module SFR
 * \return None
 *
 * Coding example:
 * \code
 *   IfxPmsPm_clearInterruptStatusReg(&MODULE_PMS);
 * \endcode
 *
 */
IFX_INLINE void IfxPmsPm_clearInterruptStatusReg(Ifx_PMS *pms);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function will initialize the power gating configuration structure with default values
 * \param config Pointer to configuration structure
 * \return None
 *
 * \code
 * IfxPmsPm_PowerGatingConfig config;
 * IfxPmsPm_initPowerDownConfig(&config); //Initialize the structure member
 * \endcode
 *
 * \see IfxPmsPm_initandEnablePowerDown(), IfxPmsPm_powerDownTrigger()
 *
 */
IFX_EXTERN void IfxPmsPm_initPowerDownConfig(IfxPmsPm_PowerGatingConfig *config);

/** \brief Function will configure the power domain switch and enable the power down for core power domain
 * \param pms Pointer to PMS module sfr.
 * \param config Pointer to the configuration structure
 * \return None
 *
 * \code
 * IfxPmsPm_PowerGatingConfig config;
 * IfxPmsPm_initPowerDownConfig(&config); //Initialize the structure member
 *  //Modify the configuration as per need
 *  config.powerDown.ppu = IfxPmsPm_PowerDown_enable; // For illustration purpose
 * IfxPmsPm_initandEnablePowerDown(&MODULE_PMS, &config);
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_initandEnablePowerDown(Ifx_PMS *pms, IfxPmsPm_PowerGatingConfig *config);

/** \brief Function will trigger the power down for requested power domain
 * \param pms Pointer to PMS module sfr
 * \param powerDomain Power down will be requested for given core power domain.
 * \return Returns power down trigger status
 * 0 --> Power down was requested
 * 1 --> Power down was not requested.Power down enable should be enabled before power down request.
 *
 * \code
 * IfxPmsPm_PowerGatingConfig config;
 * IfxPmsPm_initPowerDownConfig(&config); //Initialize the structure member
 *  //Modify the configuration as per need
 *  config.powerDown.ppu = IfxPmsPm_PowerDown_enable; // For illustration purpose
 * //Below function will only enable power down
 * IfxPmsPm_initandEnablePowerDown(&MODULE_PMS, &config);
 * //Below function will trigger power down only for requested power domain
 * IfxPmsPm_powerDownTrigger(&MODULE_PMS, IfxPmsPm_CorePowerDomain_ppu);
 * \endcode
 *
 */
IFX_EXTERN boolean IfxPmsPm_powerDownTrigger(Ifx_PMS *pms, IfxPmsPm_CorePowerDomain powerDomain);

/** \brief Function will initialize and  trigger power down for multiple power domains.
 * \param pms Pointer to PMS module sfr.
 * \param config Pointer to power gating configuration structure
 * \return None
 *
 * \code
 *   IfxPmsPm_PowerGatingConfig config;
 *   IfxPmsPm_initPowerDownConfig(&config); //Initialize the structure member
 *   //Modify the configuration as per need
 *   config.powerDown.ppu = IfxPmsPm_PowerDown_enable; // For illustration purpose
 *   //Below function will trigger power down for Ppu
 *   IfxPmsPm_initandTriggerPowerDown(&MODULE_PMS, &config);
 * \endcode
 *
 */
IFX_EXTERN void IfxPmsPm_initandTriggerPowerDown(Ifx_PMS *pms, IfxPmsPm_PowerGatingConfig *config);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxPmsPm_porstdigitalfilter(Ifx_PMS *pms, IfxPmsPm_PorstDigitalFilter filterConfig)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->PAD.CON.B.PORSTDFEN = filterConfig;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_dtsEnable(Ifx_PMS *pms, IfxPmsPm_Dts enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->DTS.CON.B.EN = enable;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_dtsStartAdcConversion(Ifx_PMS *pms, IfxPmsPm_DtsAdcConversion enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->DTS.CON.B.START = enable;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_dtsWarningEnable(Ifx_PMS *pms, IfxPmsPm_DtsWarning enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->DTS.CON.B.WRNEN = enable;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_dtsResetPeakTmpDetector(Ifx_PMS *pms)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->DTS.CON.B.PEAKDETRST = 1;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE uint16 IfxPmsPm_getDtsTemperatureResult(Ifx_PMS *pms)
{
    return (uint16)(pms->DTS.STAT.B.RESULT);
}


IFX_INLINE float32 IfxPmsPm_getDtsTemperatureResultKv(Ifx_PMS *pms)
{
    float32 result;
    result = ((pms->DTS.STAT.B.RESULT) / IFXPMSPM_DTS_TEMP_KELVIN_CONVERSION);
    return result;
}


IFX_INLINE uint16 IfxPmsPm_getDtsPeakTemperature(Ifx_PMS *pms)
{
    return (uint16)(pms->DTS.STAT.B.PEAK);
}


IFX_INLINE float32 IfxPmsPm_getDtsPeakTemperatureKv(Ifx_PMS *pms)
{
    float32 result;
    result = ((pms->DTS.STAT.B.PEAK) / IFXPMSPM_DTS_TEMP_KELVIN_CONVERSION);
    return result;
}


IFX_INLINE boolean IfxPmsPm_getDtsStatus(Ifx_PMS *pms)
{
    return (boolean)(pms->DTS.STAT.B.DTSREADY);
}


IFX_INLINE void IfxPmsPm_enableRtc(Ifx_PMS *pms, IfxPmsPm_Rtc enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->RTC.CON0.B.RTCEN = enable;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE IfxPmsPm_RtcTimerCaptureType IfxPmsPm_readRtcTotalTimerValue(Ifx_PMS *pms)
{
    IfxPmsPm_RtcTimerCaptureType timerValue;
    timerValue.lowerPart = pms->RTC.TIM0.U;
    timerValue.upperPart = pms->RTC.TIM1CAP.U;
    return timerValue;
}


IFX_INLINE void IfxPmsPm_enableWut(Ifx_PMS *pms, IfxPmsPm_Wut enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->WUT.CON.B.ENABLE = enable;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE uint32 IfxPmsPm_getWutCounterValue(Ifx_PMS *pms)
{
    return (uint32)(pms->WUT.STAT.B.COUNTER);
}


IFX_INLINE IfxPmsPm_WutMode IfxPmsPm_getWutMode(Ifx_PMS *pms)
{
    return (IfxPmsPm_WutMode)(pms->WUT.STAT.B.MODE);
}


IFX_INLINE boolean IfxPmsPm_getWutRunStatus(Ifx_PMS *pms)
{
    return (boolean)(pms->WUT.STAT.B.RUN);
}


IFX_INLINE void IfxPmsPm_setRtcOffset(Ifx_PMS *pms, uint16 offset)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->RTC.CON1.B.OFFSET = offset;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_resetScr(Ifx_PMS *pms)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->SCR.CON1.U |= (1U << IFX_PMS_SCR_CON1_SCRSTREQ_OFF) | (1U << IFX_PMS_SCR_CON1_SCRSTREQ_P_OFF);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    /* Waiting for SCR to reset*/
    while (!pms->SCR.STAT.B.SCRST)
    {}
}


IFX_INLINE void IfxPmsPm_enableScrResetOnPorst(Ifx_PMS *pms, boolean enable)
{
    Ifx_PMS_SCR_CON0 scr_con0;
    scr_con0.U            = pms->SCR.CON0.U;
    scr_con0.B.PORSTREQ_P = 1u;
    scr_con0.B.PORSTREQ   = enable;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->SCR.CON0.U = scr_con0.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxPmsPm_getWakeupEventStatus(Ifx_PMS *pms, IfxPmsPm_WakeupEvent event)
{
    boolean status;

    if (event < IfxPmsPm_WakeupEvent_esr0)
    {
        status = (boolean)((pms->WAKEUP.STAT0.U & (1u << event)) >> event);
    }
    else
    {
        event  = (IfxPmsPm_WakeupEvent)(event - IfxPmsPm_WakeupEvent_esr0);
        status = (boolean)((pms->WAKEUP.STAT1.U & (1u << event)) >> event);
    }

    return status;
}


IFX_INLINE void IfxPmsPm_clearWakeupEventStatus(Ifx_PMS *pms, IfxPmsPm_WakeupEvent event)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    if (event < IfxPmsPm_WakeupEvent_esr0)
    {
        pms->WAKEUP.CLR0.U = (1u << event);
    }
    else
    {
        event              = (IfxPmsPm_WakeupEvent)(event - IfxPmsPm_WakeupEvent_esr0);
        pms->WAKEUP.CLR1.U = (1u << event);
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_clearWakeupEventStatusReg(Ifx_PMS *pms, IfxPmsPm_WakeupReg reg)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    if (reg == IfxPmsPm_WakeupReg_0)
    {
        pms->WAKEUP.CLR0.U = IFXPMSPM_WAKEUP_OVRUN_FLAGS_CLR0;
    }
    else
    {
        pms->WAKEUP.CLR1.U = IFXPMSPM_WAKEUP_OVRUN_FLAGS_CLR1;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_clearInterruptStatusFlags(Ifx_PMS *pms, IfxPmsPm_Interrupt interrupt)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->INT.CLR.U = (1U << interrupt);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_clearInterruptStatusReg(Ifx_PMS *pms)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->INT.CLR.U = IFXPMSPM_INTERRUPT_FLAGS_CLR;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_enableScr(Ifx_PMS *pms)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->SCR.CON0.U |= ((1u << IFX_PMS_SCR_CON0_SCREN_P_OFF) | (1u << IFX_PMS_SCR_CON0_SCREN_OFF));
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_disableScr(Ifx_PMS *pms)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->SCR.CON0.U = ((pms->SCR.CON0.U & ~(1u << IFX_PMS_SCR_CON0_SCREN_OFF)) | (1u << IFX_PMS_SCR_CON0_SCREN_P_OFF));
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_changeScrBootMode(Ifx_PMS *pms, IfxPmsPm_ScrBootMode bootMode)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->SCR.CON0.B.SCRCFG = bootMode;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_configureScrClock(Ifx_PMS *pms, IfxPmsPm_ScrClocking scrClk)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->SCR.CON0.B.SCRCLKSEL = scrClk;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxPmsPm_isScrEnabled(Ifx_PMS *pms)
{
    return pms->SCR.CON0.B.SCREN;
}


IFX_INLINE IfxPmsPm_Status IfxPmsPm_triggerInterruptToScr(Ifx_PMS *pms)
{
    IfxPmsPm_Status status = IfxPmsPm_Status_failure;

    if (IfxPmsPm_isScrEnabled(pms))
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
        pms->SCR.CON1.B.TCINTREQ = 1U;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
        status = IfxPmsPm_Status_success;
    }

    return status;
}


IFX_INLINE IfxPmsPm_Status IfxPmsPm_sendMessageToScr(Ifx_PMS *pms, uint8 messageToScr)
{
    IfxPmsPm_Status status = IfxPmsPm_Status_failure;

    if (IfxPmsPm_isScrEnabled(pms))
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
        pms->SCR.CON1.B.TCINT = messageToScr;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
        status = IfxPmsPm_Status_success;
    }

    return status;
}


IFX_INLINE uint8 IfxPmsPm_readMessageFromScr(Ifx_PMS *pms)
{
    return pms->SCR.STAT.B.SCRINT;
}


IFX_INLINE IfxPmsPm_Status IfxPmsPm_clearScrStatusFlag(Ifx_PMS *pms, IfxPmsPm_ScrFlag scrFlag)
{
    IfxPmsPm_Status status = IfxPmsPm_Status_failure;

    if (IfxPmsPm_isScrEnabled(pms))
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
        pms->SCR.STAT.U &= ~(1u << (scrFlag + IFX_PMS_SCR_STAT_SCRECC_OFF));
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
        status = IfxPmsPm_Status_success;
    }

    return status;
}


IFX_INLINE void IfxPmsPm_enableRtcOscillator(Ifx_PMS *pms, IfxPmsPm_Rtc enable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->RTC.CON0.B.RTCOSCEN = (enable == IfxPmsPm_Rtc_enable) ? 1u : 0u;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxPmsPm_selectRtcClockSource(Ifx_PMS *pms, IfxPmsPm_RtcClk clkSrc)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->RTC.CON0.B.RTCCLKSEL = clkSrc;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxPmsPm_isWutEnabled(Ifx_PMS *pms)
{
    return (boolean)(pms->WUT.STAT.B.ENABLE);
}


IFX_INLINE void IfxPmsPm_selectRtcWakeup(Ifx_PMS *pms, IfxPmsPm_RtcCmp rtcWkp)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->RTC.CON0.B.RTCWKPSEL = rtcWkp;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


#endif /* IFXPMSPM_H */
