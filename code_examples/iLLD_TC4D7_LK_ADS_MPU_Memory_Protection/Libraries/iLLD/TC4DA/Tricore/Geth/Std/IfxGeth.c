/**
 * \file IfxGeth.c
 * \brief GETH  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxGeth.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxGeth_disableModule(Ifx_GETH *gethSFR)
{
    gethSFR->CLC.B.DISR = 1;        /* set the disable request */
}


void IfxGeth_enableModule(Ifx_GETH *gethSFR)
{
    if (IfxGeth_isModuleEnabled(gethSFR) != 1)        /* if module is not enabled already */
    {
        gethSFR->CLC.B.DISR = 0;                      /* set the enable request */
    }

    while (IfxGeth_isModuleEnabled(gethSFR) == FALSE) /* wait till enabled */
    {}
}


void IfxGeth_resetModule(Ifx_GETH *gethSFR)
{
    gethSFR->RST.CTRLA.B.KRST = 1;          /* Only if both Kernel reset bits are set a reset is executed */
    gethSFR->RST.CTRLB.B.KRST = 1;

    while (gethSFR->RST.STAT.B.KRST == 0)   /* Wait until reset is executed */
    {}

    gethSFR->RST.CTRLB.B.STATCLR = 1;       /* Clear Kernel reset status bit */

    while (gethSFR->RST.STAT.B.KRST == 1)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}
}


volatile Ifx_SRC_SRCR *IfxGeth_getSrcPointer(IfxGeth_ServiceRequest serviceRequest)
{
    Ifx_SRC_SRCR *src = (Ifx_SRC_SRCR *)(&MODULE_SRC.GETH[0]);
    return &src[serviceRequest];
}


void IfxGeth_initApConfig(IfxGeth_ApConfig *config)
{
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuGlobalConfig);
    IfxApApu_initConfig(&config->apuMac0Config);
    IfxApApu_initConfig(&config->apuMac1Config);
    IfxApApu_initConfig(&config->apuCh0Config);
    IfxApApu_initConfig(&config->apuCh1Config);
    IfxApApu_initConfig(&config->apuCh2Config);
    IfxApApu_initConfig(&config->apuCh3Config);
    IfxApApu_initConfig(&config->apuCh4Config);
    IfxApApu_initConfig(&config->apuCh5Config);
    IfxApApu_initConfig(&config->apuCh6Config);
    IfxApApu_initConfig(&config->apuCh7Config);
}


void IfxGeth_initAp(Ifx_GETH *gethSFR, IfxGeth_ApConfig *config)
{
    /* Initialize the PROTs */
    IfxApProt_init((Ifx_PROT_PROT *)&gethSFR->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&gethSFR->PROTSE, IfxApProt_State_config);

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENGLOBAL, &config->apuGlobalConfig);

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENMAC[0], &config->apuMac0Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENMAC[1], &config->apuMac1Config);

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[0], &config->apuCh0Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[1], &config->apuCh1Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[2], &config->apuCh2Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[3], &config->apuCh3Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[4], &config->apuCh4Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[5], &config->apuCh5Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[6], &config->apuCh6Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&gethSFR->ACCENCH[7], &config->apuCh7Config);

    IfxApProt_setState((Ifx_PROT_PROT *)&gethSFR->PROTSE, IfxApProt_State_run);
}


void IfxGeth_configureAccessToGeth(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GETH0.ACCENGLOBAL, apConfig);

    for (index = 0; index < IFXGETH_NUM_PORTS; index++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GETH0.ACCENMAC[index], apConfig);
    }

    for (index = 0; index < IFXGETH_NUM_DMA_CHANNELS; index++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_GETH0.ACCENCH[index], apConfig);
    }
}


void IfxGeth_Bridge_setPortMode(Ifx_GETH *gethSFR, IfxGeth_BridgePortMode mode)
{
    if (mode < 2)                                                 /*IfxGeth_BridgePortMode_singlePort0 or IfxGeth_BridgePortMode_singlePort1*/
    {
        gethSFR->BRIDGE.FORWARD_CONTROL.B.Q_CH_MAPPING_EN = 0;    /*Single Port Mode*/
        gethSFR->BRIDGE.FORWARD_CONTROL.B.PORT_SEL        = mode; /*Port 0 or Port 1 only to be used*/
    }
    else /*IfxGeth_BridgePortMode_multiPort*/
    {
        gethSFR->BRIDGE.FORWARD_CONTROL.B.Q_CH_MAPPING_EN = 1; /*Multi Port Mode*/
        gethSFR->BRIDGE.FORWARD_CONTROL.B.PORT_SEL        = 0; /*No specific instructions, keeping default reset value*/
    }
}


void IfxGeth_Bridge_setLoopbackMode(Ifx_GETH *gethSFR, IfxGeth_BridgeLoopbackMode loopbackEnableValue)
{
    gethSFR->BRIDGE.PORT_FLUSH_AND_LOOPBACK_CONTROL.B.PORT_LPBK_EN = loopbackEnableValue;
}


void IfxGeth_Bridge_flushAllPortRxQueues(Ifx_GETH *gethSFR, IfxGeth_Port portNumber)
{
    if (portNumber == IfxGeth_Port_1)
    {
        gethSFR->BRIDGE.PORT_FLUSH_AND_LOOPBACK_CONTROL.B.RXQ_FLUSH_PORT1 = 0;
    }

    else
    {
        gethSFR->BRIDGE.PORT_FLUSH_AND_LOOPBACK_CONTROL.B.RXQ_FLUSH_PORT0 = 0;
    }
}


void IfxGeth_Bridge_flushRxQueue(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_RxMtlQueue queueNumber)
{
    if (portNumber == IfxGeth_Port_1)
    {
        gethSFR->BRIDGE.PORT_FLUSH_AND_LOOPBACK_CONTROL.B.RXQ_FLUSH_PORT1 = (1 << queueNumber);
    }
    else
    {
        gethSFR->BRIDGE.PORT_FLUSH_AND_LOOPBACK_CONTROL.B.RXQ_FLUSH_PORT0 = (1 << queueNumber);
    }
}


void IfxGeth_Bridge_enablePortTxQueuesAndRxChannels(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_TxQRxCEnableConfigUnion config)
{
    if (portNumber == IfxGeth_Port_0)
    {
        gethSFR->BRIDGE.PORT_0_CONTROL.B.TXQ_EN = config.enableAll.txQueues;
        gethSFR->BRIDGE.PORT_0_CONTROL.B.RXC_EN = config.enableAll.rxChannels;
        gethSFR->BRIDGE.PORT_0_CONTROL.B.FWD_EN = config.enableAll.txForwardingPaths;
    }
    else
    {
        gethSFR->BRIDGE.PORT_1_CONTROL.B.TXQ_EN = config.enableAll.txQueues;
        gethSFR->BRIDGE.PORT_1_CONTROL.B.RXC_EN = config.enableAll.rxChannels;
        gethSFR->BRIDGE.PORT_1_CONTROL.B.FWD_EN = config.enableAll.txForwardingPaths;
    }
}


void IfxGeth_Bridge_mapTxQueue(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_TxMtlQueue queueNumber, IfxGeth_BridgeTxQueueMap mapValue)
{
    if (portNumber == IfxGeth_Port_0)
    {
        switch (queueNumber)
        {
        case IfxGeth_TxMtlQueue_0:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ0 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_1:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ1 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_2:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ2 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_3:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ3 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_4:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ4 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_5:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ5 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_6:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ6 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_7:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.B.TXQ7 = mapValue;
            break;
        }
        default:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_0.U = 0;
        }
        }
    }
    else
    {
        switch (queueNumber)
        {
        case IfxGeth_TxMtlQueue_0:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ0 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_1:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ1 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_2:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ2 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_3:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ3 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_4:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ4 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_5:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ5 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_6:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ6 = mapValue;
            break;
        }
        case IfxGeth_TxMtlQueue_7:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.B.TXQ7 = mapValue;
            break;
        }
        default:
        {
            gethSFR->BRIDGE.TXQ_MAP_PORT_1.U = 0;
        }
        }
    }
}


void IfxGeth_Bridge_mapRxChannel(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, IfxGeth_RxMtlQueue queueNumber, IfxGeth_BridgeRxCMap mapValue)
{
    if (portNumber == IfxGeth_Port_0)
    {
        switch (queueNumber)
        {
        case IfxGeth_RxMtlQueue_0:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC0 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_1:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC1 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_2:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC2 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_3:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC3 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_4:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC4 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_5:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC5 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_6:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC6 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_7:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.B.RXC7 = mapValue;
            break;
        }
        default:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_0.U = 0;
        }
        }
    }
    else
    {
        switch (queueNumber)
        {
        case IfxGeth_RxMtlQueue_0:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC0 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_1:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC1 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_2:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC2 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_3:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC3 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_4:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC4 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_5:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC5 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_6:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC6 = mapValue;
            break;
        }
        case IfxGeth_RxMtlQueue_7:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.B.RXC7 = mapValue;
            break;
        }
        default:
        {
            gethSFR->BRIDGE.RXC_MAP_PORT_1.U = 0;
        }
        }
    }
}


void IfxGeth_Bridge_getInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_Bridge_InterruptStatusFlags *flags)
{
    flags->dma      = gethSFR->BRIDGE.INTERRUPT_STATUS.B.DMAIS;
    flags->port1MTL = gethSFR->BRIDGE.INTERRUPT_STATUS.B.PORT_1_MTLIS;
    flags->port1MAC = gethSFR->BRIDGE.INTERRUPT_STATUS.B.PORT_1_MACIS;
    flags->port0MTL = gethSFR->BRIDGE.INTERRUPT_STATUS.B.PORT_0_MTLIS;
    flags->port0MAC = gethSFR->BRIDGE.INTERRUPT_STATUS.B.PORT_0_MACIS;
}


void IfxGeth_Bridge_setDmaPortSelection(Ifx_GETH *gethSFR, IfxGeth_Bridge_DmaPortMapUnion mapCfg)
{
    gethSFR->BRIDGE.DMA_PORT_SELECTION.B.DMAPORTSEL = mapCfg.dmaPortMapAll;
}


void IfxGeth_enableInterrupt(IfxGeth_ServiceRequest serviceRequestNode, IfxSrc_Tos typeOfService, Ifx_Priority priority, IfxSrc_VmId vmId)
{
    volatile Ifx_SRC_SRCR *src;
    src = IfxGeth_getSrcPointer(serviceRequestNode);
    IfxSrc_init(src, typeOfService, priority, vmId);
    IfxSrc_enable(src);
}


void IfxGeth_enableMacRegisterClearOnWrite(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, boolean enable)
{
    gethSFR->PORT[portNumber].CORE.MAC_CSR_SW_CTRL.B.RCWE = enable;
}


void IfxGeth_disableTimeStamp(Ifx_GETH *gethSFR, IfxGeth_Port portNumber)
{
    gethSFR->PORT[portNumber].CORE.MAC_TIMESTAMP_CONTROL.B.TSENA = 0;
}


void IfxGeth_setTimeStampUpdateMethod(Ifx_GETH *gethSFR, IfxGeth_Port portNumber, boolean updateMethod)
{
    gethSFR->PORT[portNumber].CORE.MAC_TIMESTAMP_CONTROL.B.TSCFUPDT = updateMethod;
}


void IfxGeth_enableMmcCounterFreeze(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean enable)
{
    gethSFR->PORT[portIndex].CORE.MMC_CONTROL.B.MCF = enable;
}


void IfxGeth_resetMmcCounter(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex)
{
    gethSFR->PORT[portIndex].CORE.MMC_CONTROL.B.CNTRST = 1;
}


boolean IfxGeth_indirectReadWriteL3L4FilterReg(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_ReadWriteL3L4RegConfig *config)
{
    if (config->transferType == IfxGeth_L3L4FilterCtrlTransferType_write)
    {
        Ifx_GETH_PORT_CORE_MAC_L3_L4_DATA regDataL3L4;
        regDataL3L4.U                                  = 0;
        regDataL3L4.U                                  = config->regReadWriteData;
        gethSFR->PORT[portIndex].CORE.MAC_L3_L4_DATA.U = regDataL3L4.U;
    }

    Ifx_GETH_PORT_CORE_MAC_L3_L4_ADDRESS_CONTROL addrCtrlReg;
    addrCtrlReg.U                                             = 0;
    addrCtrlReg.B.TT                                          = config->transferType;
    addrCtrlReg.B.IDDR                                        = (((config->filterNum) << 4) + (config->filterRegType));
    gethSFR->PORT[portIndex].CORE.MAC_L3_L4_ADDRESS_CONTROL.U = addrCtrlReg.U;

    uint32  timeoutCycleCount = IFXGETH_L3L4FILTER_MAX_TIMEOUT;
    boolean timeOutError      = FALSE;

    /* To ensure no register transfer is in progress*/
    while (gethSFR->PORT[portIndex].CORE.MAC_L3_L4_ADDRESS_CONTROL.B.XB == 1)
    {
        IFXGETH_L3L4FILTER_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return timeOutError;
    }

    gethSFR->PORT[portIndex].CORE.MAC_L3_L4_ADDRESS_CONTROL.B.XB = 1;       //To trigger the indirect register Read/write transfer

    timeoutCycleCount                                            = IFXGETH_L3L4FILTER_MAX_TIMEOUT;

    /*Monitor the XB bit for register read/write transfer to complete*/
    while (gethSFR->PORT[portIndex].CORE.MAC_L3_L4_ADDRESS_CONTROL.B.XB == 1)
    {
        IFXGETH_L3L4FILTER_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if ((config->transferType == IfxGeth_L3L4FilterCtrlTransferType_read) && (timeOutError == FALSE))
    {
        config->regReadWriteData = gethSFR->PORT[portIndex].CORE.MAC_L3_L4_DATA.U;
    }

    return timeOutError;
}


IfxGeth_LpiConfigStatus IfxGeth_lowPowerIdleModeTx(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_Eth_LpiConfig *config)
{
    uint32                                    timeoutCycleCount = IFXGETH_LPI_MAX_TIMEOUT;
    boolean                                   timeOutError      = FALSE;
    IfxGeth_LpiConfigStatus                   status;
    Ifx_GETH_PORT_CORE_MAC_LPI_CONTROL_STATUS regLpiCtrl;
    Ifx_GETH_PORT_CORE_MAC_LPI_TIMERS_CONTROL regLpiTimer;
    regLpiCtrl.U         = 0;
    regLpiTimer.U        = 0;

    regLpiCtrl.B.PLSDIS  = config->lpiPhyStatusDisable;
    regLpiCtrl.B.LPITCSE = config->lpiTxClkGateEnable;
    regLpiCtrl.B.LPITXEN = config->lpiModeEnable;

    /*To clear the LPIIS status bit*/
    if (gethSFR->PORT[portIndex].CORE.MAC_CSR_SW_CTRL.B.RCWE == 1)
    {
        gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.U = IFXGETH_LPI_STATUS_CLEAR;
    }
    else
    {
        regLpiCtrl.U = gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.U;
        regLpiCtrl.U = 0;
    }

    gethSFR->PORT[portIndex].CORE.MAC_INTERRUPT_ENABLE.B.LPIIE = config->lpiInterruptEnable;

    if (config->lpiAutoTxEnable == 0)
    {
        /*Config for EEE LPI Mode*/
        if (config->lpiModeEnable == 1)
        {
            /*Wait time for MAC to assert the LPI pattern */
            regLpiTimer.B.LST                                      = (config->lpiModeEntryWaitTime) & (IFX_GETH_PORT_CORE_MAC_LPI_TIMERS_CONTROL_LST_MSK);

            gethSFR->PORT[portIndex].CORE.MAC_LPI_TIMERS_CONTROL.U = regLpiTimer.U;
            gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.U = regLpiCtrl.U;

            /* Check for the EEE LPI mode entry */
            while (gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.B.TLPIEN == 0)
            {
                IFXGETH_LPIMODE_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
            }

            status = (timeOutError) ? IfxGeth_LpiConfigStatus_timeoutError : IfxGeth_LpiConfigStatus_entry;
        }
        else
        {
            regLpiTimer.B.TWT                                      = (config->lpiModeExitWaitTime);

            gethSFR->PORT[portIndex].CORE.MAC_LPI_TIMERS_CONTROL.U = regLpiTimer.U;
            gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.U = regLpiCtrl.U;

            /*Wait time for MAC to assert the Normal pattern*/
            while (gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.B.TLPIEX == 0)
            {
                IFXGETH_LPIMODE_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
            }

            status = (timeOutError) ? IfxGeth_LpiConfigStatus_timeoutError : IfxGeth_LpiConfigStatus_exit;
        }
    }
    else if (config->lpiModeEnable == 1)
    {
        /*Config for EEE Auto LPI Mode*/
        regLpiTimer.B.TWT = (config->lpiModeExitWaitTime);          /*Wait time to exit the LPI Auto mode and for MAC to assert the Normal pattern*/

        if (config->lpiAutoReEntryEnable == FALSE)
        {
            regLpiTimer.B.LST = (config->lpiModeEntryWaitTime) & (IFX_GETH_PORT_CORE_MAC_LPI_TIMERS_CONTROL_LST_MSK);
        }
        else
        {
            /*Wait time to enter the LPI Auto mode and for MAC to assert the LPI pattern*/
            Ifx_GETH_PORT_CORE_MAC_LPI_AUTO_ENTRY_TIMER regLpiAutoModetimer;
            regLpiAutoModetimer.U                                    = 0;
            regLpiAutoModetimer.B.LPIET                              = (config->lpiModeEntryWaitTime) & (IFX_GETH_PORT_CORE_MAC_LPI_AUTO_ENTRY_TIMER_LPIET_MSK);
            gethSFR->PORT[portIndex].CORE.MAC_LPI_AUTO_ENTRY_TIMER.U = regLpiAutoModetimer.U;
        }

        gethSFR->PORT[portIndex].CORE.MAC_LPI_TIMERS_CONTROL.U = regLpiTimer.U;

        regLpiCtrl.B.LPITXA                                    = config->lpiAutoTxEnable;
        regLpiCtrl.B.LPIATE                                    = config->lpiAutoReEntryEnable;
        gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.U = regLpiCtrl.U;

        /* Check for the EEE Auto LPI mode entry*/
        while (gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.B.TLPIEN == 0)
        {
            IFXGETH_LPIMODE_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        status = (timeOutError) ? IfxGeth_LpiConfigStatus_timeoutError : IfxGeth_LpiConfigStatus_entry;
    }
    else
    {
        status = IfxGeth_LpiConfigStatus_invalidConfigError;
    }

    /*AXI LPI mode configuration*/
    if (config->lpiAxiEnable == TRUE)
    {
        Ifx_GETH_DMA_SYSBUS_MODE regDmaSysBusMode;
        regDmaSysBusMode.U             = gethSFR->DMA.SYSBUS_MODE.U;
        regDmaSysBusMode.B.EN_LPI      = config->lpiAxiEnable;
        regDmaSysBusMode.B.AALE        = config->lpiAxiAutoEnable;
        regDmaSysBusMode.B.LPI_XIT_PKT = config->lpiAxiExitPacketSelect;
        gethSFR->DMA.SYSBUS_MODE.U     = regDmaSysBusMode.U;

        Ifx_GETH_DMA_AXI_LPI_ENTRY_INTERVAL regAxiLpiEntry;
        regAxiLpiEntry.U                      = 0;
        regAxiLpiEntry.B.LPIEI                = (config->lpiAxiEntryNumClkCycles) & (IFX_GETH_DMA_AXI_LPI_ENTRY_INTERVAL_LPIEI_MSK);
        gethSFR->DMA.AXI_LPI_ENTRY_INTERVAL.U = regAxiLpiEntry.U;
    }
    else
    {
        gethSFR->DMA.SYSBUS_MODE.B.EN_LPI = 0;
    }

    return status;
}


void IfxGeth_getLowPowerInterfaceStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_Eth_LpiStatus *lpiStatus)
{
    Ifx_GETH_PORT_CORE_MAC_LPI_CONTROL_STATUS regLpiStatus;
    regLpiStatus.U          = 0;
    lpiStatus->lpiInterrupt = gethSFR->PORT[portIndex].CORE.MAC_INTERRUPT_STATUS.B.LPIIS;
    regLpiStatus.U          = gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.U;

    lpiStatus->lpiTxEntry   = regLpiStatus.B.TLPIEN;
    lpiStatus->lpiTxExit    = regLpiStatus.B.TLPIEX;
    lpiStatus->lpiRxEntry   = regLpiStatus.B.RLPIEN;
    lpiStatus->lpiRxExit    = regLpiStatus.B.RLPIEX;
    lpiStatus->lpiTxPattern = regLpiStatus.B.TLPIST;
    lpiStatus->lpiRxPattern = regLpiStatus.B.RLPIST;

    if (gethSFR->PORT[portIndex].CORE.MAC_CSR_SW_CTRL.B.RCWE == 1)
    {
        gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.U = IFXGETH_LPI_STATUS_CLEAR;
    }
}


void IfxGeth_setLowPowerInterface(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean lpiEnable)
{
    gethSFR->PORT[portIndex].CORE.MAC_LPI_CONTROL_STATUS.B.LPITXEN = lpiEnable;
}


void IfxGeth_setRwkMode(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean rwkEnable)
{
    gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.PWRDWN = rwkEnable;
}


void IfxGeth_setRwkPacketForward(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, boolean rwkUpFwdEnable)
{
    gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPFE = rwkUpFwdEnable;
}


void IfxGeth_resetRwkFilterPtr(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex)
{
    gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKFILTRST = 1;
}


boolean IfxGeth_macRwkFilterWrite(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_RwkFilterRegType rwkRegType, uint32 regWriteData)
{
    uint32  timeoutCycleCount = IFXGETH_RWKFLTRPTR_MAX_TIMEOUT;
    boolean timeOutError      = FALSE;

    while (gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR != rwkRegType)
    {
        IFXGETH_RWKFILTPTR_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == FALSE)
    {
        gethSFR->PORT[portIndex].CORE.MAC_RWK_PACKET_FILTER.U = regWriteData;
    }

    return timeOutError;
}


void IfxGeth_getPowerMngmtInterfaceStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_Eth_PmtStatus *pmtStatus)
{
    Ifx_GETH_PORT_CORE_MAC_PMT_CONTROL_STATUS regPmtStatus;
    regPmtStatus.U                = 0;
    pmtStatus->pmtInterruptStatus = gethSFR->PORT[portIndex].CORE.MAC_INTERRUPT_STATUS.B.PMTIS;

    regPmtStatus.U                = gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.U;
    pmtStatus->pmtMagicPacketRx   = regPmtStatus.B.MGKPRCVD;
    pmtStatus->pmtRwkPacketRx     = regPmtStatus.B.RWKPRCVD;
    pmtStatus->pmtRwkRegPtr       = (IfxGeth_RwkFilterRegType)regPmtStatus.B.RWKPTR;

    if (gethSFR->PORT[portIndex].CORE.MAC_CSR_SW_CTRL.B.RCWE == 1)
    {
        gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.U = IFXGETH_PMT_STATUS_CLEAR;
    }
}


uint32 IfxGeth_getMtlInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex)
{
    uint32 status;
    status = (uint32)gethSFR->PORT[portIndex].MTL.INTERRUPT_STATUS.U;

    return status;
}


boolean IfxGeth_getMtlQueueInterruptFlag(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag)
{
    uint32  value  = (1 << flag);
    boolean status = 0;

    switch (queueId)
    {
    case IfxGeth_MtlQueue_0:
        status = (gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    case IfxGeth_MtlQueue_1:
        status = (gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    case IfxGeth_MtlQueue_2:
        status = (gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    case IfxGeth_MtlQueue_3:
        status = (gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    case IfxGeth_MtlQueue_4:
        status = (gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    case IfxGeth_MtlQueue_5:
        status = (gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    case IfxGeth_MtlQueue_6:
        status = (gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    case IfxGeth_MtlQueue_7:
        status = (gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_STATUS.U & (Ifx_UReg_32Bit)value);
        break;
    }

    return status ? 1 : 0;
}


uint32 IfxGeth_getMtlQueueInterruptFlags(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId)
{
    uint32 status = 0;

    switch (queueId)
    {
    case IfxGeth_MtlQueue_0:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_STATUS.U;
        break;
    case IfxGeth_MtlQueue_1:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_STATUS.U;
        break;
    case IfxGeth_MtlQueue_2:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_STATUS.U;
        break;
    case IfxGeth_MtlQueue_3:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_STATUS.U;
        break;
    case IfxGeth_MtlQueue_4:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_STATUS.U;
        break;
    case IfxGeth_MtlQueue_5:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_STATUS.U;
        break;
    case IfxGeth_MtlQueue_6:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_STATUS.U;
        break;
    case IfxGeth_MtlQueue_7:
        status = (uint32)gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_STATUS.U;
        break;
    }

    return status;
}


void IfxGeth_mtlClearAllInterruptFlags(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId)
{
    uint32 value = (1 << IfxGeth_MtlInterruptFlag_txQueueUnderflow) | (1 << IfxGeth_MtlInterruptFlag_averageBitsPerSlot) | (1 << IfxGeth_MtlInterruptFlag_rxQueueOverflow);

    switch (queueId)
    {
    case IfxGeth_MtlQueue_0:
        gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_1:
        gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_2:
        gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_3:
        gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_4:
        gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_5:
        gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_6:
        gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_7:
        gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_STATUS.U |= value;
        break;
    }
}


void IfxGeth_mtlClearInterruptFlag(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag)
{
    uint32 value = (1 << flag);

    switch (queueId)
    {
    case IfxGeth_MtlQueue_0:
        gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_1:
        gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_2:
        gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_3:
        gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_4:
        gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_5:
        gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_6:
        gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_STATUS.U |= value;
        break;
    case IfxGeth_MtlQueue_7:
        gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_STATUS.U |= value;
        break;
    }
}


void IfxGeth_setMtlInterruptEnableFlag(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MtlQueue queueId, IfxGeth_MtlInterruptFlag flag, boolean interruptEnable)
{
    switch (queueId)
    {
    case IfxGeth_MtlQueue_0:
        gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    case IfxGeth_MtlQueue_1:
        gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    case IfxGeth_MtlQueue_2:
        gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    case IfxGeth_MtlQueue_3:
        gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    case IfxGeth_MtlQueue_4:
        gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    case IfxGeth_MtlQueue_5:
        gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    case IfxGeth_MtlQueue_6:
        gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    case IfxGeth_MtlQueue_7:
        gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_ENABLE.U = (uint32)(interruptEnable << flag);
        break;
    }
}


void IfxGeth_setMacInterruptEnableFlags(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, IfxGeth_MacInterruptFlag *flag)
{
    Ifx_GETH_PORT_CORE_MAC_INTERRUPT_ENABLE macInterruptReg;
    macInterruptReg.U                                    = 0;
    macInterruptReg.B.LSIE                               = flag->linkStatusChange;
    macInterruptReg.B.PMTIE                              = flag->powerMgmt;
    macInterruptReg.B.LPIIE                              = flag->lowPowerIdle;
    macInterruptReg.B.TSIE                               = flag->timeStamp;
    macInterruptReg.B.TXESIE                             = flag->txErrorStatus;
    macInterruptReg.B.RXESIE                             = flag->rxErrorStatus;
    macInterruptReg.B.FPEIE                              = flag->framePreEmption;

    gethSFR->PORT[portIndex].CORE.MAC_INTERRUPT_ENABLE.U = macInterruptReg.U;
}


uint32 IfxGeth_getMacInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex)
{
    return (uint32)gethSFR->PORT[portIndex].CORE.MAC_INTERRUPT_STATUS.U;
}


uint32 IfxGeth_getDmaInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex)
{
    return (uint32)gethSFR->DMA.INTERRUPT_STATUS.U;
}


void IfxGeth_setDmaChannelInterruptEnable(Ifx_GETH *gethSFR, uint8 channelIndex, IfxGeth_Eth_DmaChannelInterruptFlags *enable)
{
    Ifx_GETH_DMA_CH_INTERRUPT_ENABLE dmaInterruptReg;
    dmaInterruptReg.U                                = 0;
    dmaInterruptReg.B.TIE                            = enable->transmitInterrupt;
    dmaInterruptReg.B.TXSE                           = enable->transmitStop;
    dmaInterruptReg.B.TBUE                           = enable->txBufferUnavailable;
    dmaInterruptReg.B.RIE                            = enable->receiveInterrupt;
    dmaInterruptReg.B.RBUE                           = enable->rxBufferUnavailable;
    dmaInterruptReg.B.RSE                            = enable->receiveStop;
    dmaInterruptReg.B.DDEE                           = enable->descrDefinitionError;
    dmaInterruptReg.B.FBEE                           = enable->fatalBusError;
    dmaInterruptReg.B.CDEE                           = enable->contextDescrError;
    dmaInterruptReg.B.AIE                            = enable->abnormalInterruptSummary;
    dmaInterruptReg.B.NIE                            = enable->normalInterruptSummary;
    gethSFR->DMA.CH[channelIndex].INTERRUPT_ENABLE.U = dmaInterruptReg.U;
}


uint32 IfxGeth_getDmaChannelInterruptStatus(Ifx_GETH *gethSFR, IfxGeth_DmaChannel channelIndex)
{
    return (uint32)gethSFR->DMA.CH[channelIndex].STATUS.U;
}


void IfxGeth_dmaChannelInterruptClearAll(Ifx_GETH *gethSFR, IfxGeth_DmaChannel channelIndex)
{
    gethSFR->DMA.CH[channelIndex].STATUS.U = IFXGETH_DMA_INTERRUPT_STATUS_CLEAR;
}


void IfxGeth_dmaChannelInterruptClear(Ifx_GETH *gethSFR, IfxGeth_DmaChannel channelIndex, IfxGeth_Eth_DmaChannelInterruptFlags *flag)
{
    Ifx_GETH_DMA_CH_STATUS dmaInterruptStatus;
    dmaInterruptStatus.U                   = 0;
    dmaInterruptStatus.B.TI                = flag->transmitInterrupt;
    dmaInterruptStatus.B.TPS               = flag->transmitStop;
    dmaInterruptStatus.B.TBU               = flag->txBufferUnavailable;
    dmaInterruptStatus.B.RI                = flag->receiveInterrupt;
    dmaInterruptStatus.B.RBU               = flag->rxBufferUnavailable;
    dmaInterruptStatus.B.RPS               = flag->receiveStop;
    dmaInterruptStatus.B.DDE               = flag->descrDefinitionError;
    dmaInterruptStatus.B.FBE               = flag->fatalBusError;
    dmaInterruptStatus.B.CDE               = flag->contextDescrError;
    dmaInterruptStatus.B.AIS               = flag->abnormalInterruptSummary;
    dmaInterruptStatus.B.NIS               = flag->normalInterruptSummary;

    gethSFR->DMA.CH[channelIndex].STATUS.U = dmaInterruptStatus.U;
}
