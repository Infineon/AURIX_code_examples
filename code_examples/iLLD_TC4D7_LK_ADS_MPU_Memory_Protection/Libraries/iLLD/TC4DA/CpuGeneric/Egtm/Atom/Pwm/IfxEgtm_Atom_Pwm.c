/**
 * \file IfxEgtm_Atom_Pwm.c
 * \brief EGTM PWM details
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxEgtm_Atom_Pwm.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxEgtm_Atom_Pwm_init(IfxEgtm_Atom_Pwm_Driver *driver, const IfxEgtm_Atom_Pwm_Config *config)
{
    boolean result = FALSE;

    /* Only PWM mode is supported */
    if (config->mode == IfxEgtm_Atom_Mode_outputPwm)
    {
        result = TRUE;

        Ifx_EGTM_CLS_ATOM    *atomSFR = &config->egtm->CLS[config->cluster].ATOM;
        Ifx_EGTM_CLS_ATOM_CH *channel = &atomSFR->CH[config->atomChannel];
        /* Copy config data into handle */
        driver->egtm                     = config->egtm;
        driver->clsIndex                 = config->cluster;
        driver->atom                     = atomSFR;
        driver->atomChannel              = config->atomChannel;
        driver->agc                      = &atomSFR->AGC;
        driver->synchronousUpdateEnabled = config->synchronousUpdateEnabled;

        /* Enable update of CM0/1 from shadow registers */
        if (config->synchronousUpdateEnabled == TRUE)
        {
            IfxEgtm_Atom_Agc_enableChannelUpdate(driver->agc, driver->atomChannel, TRUE);
        }
        /* Do clock update from shadow once */
        else
        {
            /* After (channel) reset the channel operation will run with CLS[j]_CLK . In order to change the clock source
             * resolution, it is necessary to perform a synchronous update (via CLSi_ATOM_CHx_CTRL_SR.CLK_SRC_SR) before
             * enabling the channel. This can be done by performing the following configuration sequence before enabling
             * the channel: CLSi_ATOM_CHx_CTRL_SR.CLK_SRC_SR=<selected CCM clock source>; CLSi_ATOM_CHx_SR0 = 0H;
             * CLSi_ATOM_CHx_CM0 = 0H; CLSi_ATOM_AGC_GLB_CTRL.UPEN_CTRLk(k=x) = 10H. With this configuration sequence,
             * CLSi_ATOM_CHx_CTRL.CLK_SRC will be immediately updated with the clock source value stored in the shadow
             * register. Afterwards once the channel is enabled, the channel will operate on the selected clock source. Since then,
             * the value read from the register CLSi_ATOM_CHx_CTRL.CLK_SRC reflects the actual selected clock source of operation.
             */
            channel->CTRL_SR.B.CLK_SRC_SR = (uint8)config->clock;
            channel->SR0.U                = 0x0u;
            channel->CM0.U                = 0x0u;
            IfxEgtm_Atom_Agc_enableChannelUpdate(driver->agc, driver->atomChannel, TRUE);
            IfxEgtm_Atom_Agc_enableChannelUpdate(driver->agc, driver->atomChannel, FALSE);
        }

        /* Set channel to start counter when trigger is received */
        IfxEgtm_Atom_Agc_enableChannel(driver->agc, config->atomChannel, TRUE, FALSE);

        /* Set channel to start PWM output when trigger is received */
        IfxEgtm_Atom_Agc_enableChannelOutput(driver->agc, config->atomChannel, TRUE, FALSE);

        /* Set Signal Polarity value here */
        IfxEgtm_Atom_Ch_setSignalLevel(atomSFR, driver->atomChannel, config->signalLevel);

        /* Set ATOM signal output mode as PWM */
        IfxEgtm_Atom_Ch_setMode(atomSFR, driver->atomChannel, config->mode);

        /* Set ATOM channel clock source */
        IfxEgtm_Atom_Ch_setClockSource(atomSFR, driver->atomChannel, config->clock);

        /* Reset counter to 0 */
        IfxEgtm_Atom_Ch_setCounterValue(atomSFR, driver->atomChannel, 0);

        /* Enable and initialize interrupts if chosen */
        if ((config->interrupt.ccu0Enabled == TRUE) || (config->interrupt.ccu1Enabled == TRUE))
        {
            volatile Ifx_SRC_SRCR *src;
            IfxEgtm_Atom_Ch_setNotification(atomSFR, config->atomChannel, config->interrupt.mode, config->interrupt.ccu0Enabled, config->interrupt.ccu1Enabled);

            src = IfxEgtm_Atom_Ch_getSrcPointer(config->egtm, config->cluster, config->atomChannel);
            IfxSrc_init(src, config->interrupt.isrProvider, config->interrupt.isrPriority, config->interrupt.vmId);
            IfxSrc_enable(src);
        }
        /* Disable interrupt */
        else
        {
            channel->IRQ_EN.U = 0u;
        }

        uint32 period    = config->period;
        uint32 dutyCycle = config->dutyCycle;

        /* Set CM0, CM1, SR0, SR1 registers */
        if (config->synchronousUpdateEnabled == TRUE)
        {
            IfxEgtm_Atom_Ch_setCompareZeroShadow(atomSFR, driver->atomChannel, period);
            IfxEgtm_Atom_Ch_setCompareOneShadow(atomSFR, driver->atomChannel, dutyCycle);
        }
        else
        {
            IfxEgtm_Atom_Ch_setCompareZero(atomSFR, driver->atomChannel, period);
            IfxEgtm_Atom_Ch_setCompareOne(atomSFR, driver->atomChannel, dutyCycle);
        }

        /* Connect output pin to Atom channel */
        if (config->pin.outputPin != NULL_PTR)
        {
            IfxEgtm_PinMap_setAtomTout(config->pin.outputPin, config->pin.outputMode, config->pin.padDriver);
        }

        /* Connect Msc to Atom channel */
        if (config->mscOut != NULL_PTR)
        {
            (void)IfxEgtm_ConnectToMsc(config->cluster, IfxEgtm_TrigSource_atom, (IfxEgtm_TrigChannel)config->atomChannel, config->mscOut);
        }

        /* Start channel by giving a trigger */
        if (config->immediateStartEnabled == TRUE)
        {
            IfxEgtm_Atom_Agc_trigger(driver->agc);
        }
    }

    return result;
}


void IfxEgtm_Atom_Pwm_initConfig(IfxEgtm_Atom_Pwm_Config *config, Ifx_EGTM *egtm)
{
    const IfxEgtm_Atom_Pwm_Config defaultConfig = {
        .egtm        = NULL_PTR,
        .cluster     = IfxEgtm_Cluster_0,
        .atomChannel = IfxEgtm_Atom_Ch_0,
        .clock       = IfxEgtm_Atom_Ch_ClkSrc_cmuclk0,
        .mode        = IfxEgtm_Atom_Mode_outputPwm,
        .period      = 20,
        .dutyCycle   = 10,
        .signalLevel = Ifx_ActiveState_high,
        .interrupt   = {
            .ccu0Enabled = FALSE,
            .ccu1Enabled = FALSE,
            .mode        = IfxEgtm_IrqMode_pulseNotify,
            .isrProvider = IfxSrc_Tos_cpu0,
            .isrPriority = 0,
            .vmId        = IfxSrc_VmId_0,
        },
        .pin                      = {
            .outputPin  = NULL_PTR,
            .outputMode = IfxPort_OutputMode_pushPull,
            .padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1,
        },
        .mscOut                   = NULL_PTR,
        .dtmClockSource           = IfxEgtm_Dtm_ClockSource_cmuClock0,
        .oneShotModeEnabled       = FALSE,
        .synchronousUpdateEnabled = FALSE,
        .immediateStartEnabled    = TRUE,
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* Copy SFR */
    config->egtm = egtm;
}


void IfxEgtm_Atom_Pwm_start(IfxEgtm_Atom_Pwm_Driver *driver, boolean immediate)
{
    /* Enable channel if not enabled already */
    IfxEgtm_Atom_Agc_enableChannel(driver->agc, driver->atomChannel, TRUE, immediate);
    IfxEgtm_Atom_Agc_enableChannelOutput(driver->agc, driver->atomChannel, TRUE, immediate);

    /* Trigger the start now */
    IfxEgtm_Atom_Agc_trigger(driver->agc);
}


void IfxEgtm_Atom_Pwm_stop(IfxEgtm_Atom_Pwm_Driver *driver, boolean immediate)
{
    /* Disable channels */
    IfxEgtm_Atom_Agc_enableChannel(driver->agc, driver->atomChannel, FALSE, immediate);
    IfxEgtm_Atom_Agc_enableChannelOutput(driver->agc, driver->atomChannel, FALSE, immediate);

    /* Trigger the stop now */
    IfxEgtm_Atom_Agc_trigger(driver->agc);
}
