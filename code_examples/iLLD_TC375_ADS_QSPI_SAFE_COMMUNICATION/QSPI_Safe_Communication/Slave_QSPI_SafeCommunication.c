/**********************************************************************************************************************
 * \file Slave_QSPI_SafeCommunication.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxStm.h"
#include "Slave_QSPI_SafeCommunication.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/*QSPI Slave */
#define MASTER_DATA_ID            0x01
#define MASTER_SENT_CYCLE         100.0f            /* 100.0 ms is master frame sending cycle    */
#define CHANNEL_BAUDRATE          1000000           /* Master channel baud rate (bit/sec)                            */
#define DATA_WIDTH                32                /* 32 bits                                                       */
#define FRAME_SIZE_BIT            ((float64)(DATA_WIDTH * FRAME_SIZE))
#define FRAME_TRANSFER_TIME       ((float64)(1/CHANNEL_BAUDRATE * FRAME_SIZE_BIT))        /* 0.224ms one frame time  */
#define EXPECTED_CYCLE_TIME       (float64)(MASTER_SENT_CYCLE + FRAME_TRANSFER_TIME)
#define THRESHOLD                 0.5f              /* 0.5ms                                                         */
#define EARLY_CYCLE_TIME          EXPECTED_CYCLE_TIME - THRESHOLD
#define LATE_CYCLE_TIME           EXPECTED_CYCLE_TIME + THRESHOLD
#define FRAME_TIMEOUT             (EXPECTED_CYCLE_TIME + EXPECTED_CYCLE_TIME)
#define SEC_TO_MILLISEC           1000                               /* 1sec = 1000ms                                */
#define LED2                      &MODULE_P00, 6                     /* LED: Port, Pin definition                    */

#define ISR_PRIORITY_SLAVE_TX_QSPI_SAFE           5
#define ISR_PRIORITY_SLAVE_RX_QSPI_SAFE           6
#define ISR_PRIORITY_SLAVE_ER_QSPI_SAFE           7

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
qspiSlaveSafeComm g_qspiSlaveSafe;
volatile boolean g_frameReceived = FALSE;           /* flag once complete frame is received */
float64 g_FrameTime [FRAME_SIZE];
QspiSafeCommDiagnose g_qspiSafeCommDiagnose;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initQSPI2Slave(void);
void validateFrameCylceTime(float64 cycleTime);
void validateSlavedata(uint32 frameCounter);
void validateSlaveDataAndCycleTime(uint32 frameCounterSlaveQSPI, float64 cycleTime);

IFX_INTERRUPT(slaveQSPI2TxISR, 1, ISR_PRIORITY_SLAVE_TX_QSPI_SAFE);
IFX_INTERRUPT(slaveQSPI2RxISR, 1, ISR_PRIORITY_SLAVE_RX_QSPI_SAFE);
IFX_INTERRUPT(slaveQSPI2ErISR, 1, ISR_PRIORITY_SLAVE_ER_QSPI_SAFE);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * get time in millisecond
 * */
float64 getMilliSecondTime()
{
    return ((IfxStm_get(&MODULE_STM1) / IfxStm_getFrequency(&MODULE_STM1)) * SEC_TO_MILLISEC);
}

/* SPI Slave ISR for transmit data */
void slaveQSPI2TxISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrTransmit(&g_qspiSlaveSafe.spiSafeComSlave);
}

/*
 * SPI Slave ISR for receive data
 * This Interrupt occur for each data of 32 bits received (9 times for one frame)
 * */
void slaveQSPI2RxISR()
{
    static uint8 messageCounter = 0;
    static uint32 frameCounterSlaveQSPI = 0;      /* Frame counter for receiving */

    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrReceive(&g_qspiSlaveSafe.spiSafeComSlave);
    g_FrameTime[messageCounter] = getMilliSecondTime();
    messageCounter++;

    /* check if the complete frame of FRAME_SIZE is received */
    if(messageCounter == FRAME_SIZE)
    {
        messageCounter = 0;
        g_frameReceived = TRUE;

        /* data and cycle time validation */
        validateSlaveDataAndCycleTime(frameCounterSlaveQSPI++, getMilliSecondTime());

        /* Instruct the SPI Slave to receive a next data stream of defined length */
        IfxQspi_SpiSlave_exchange(&g_qspiSlaveSafe.spiSafeComSlave, NULL_PTR,
                &g_qspiSlaveSafe.qspiSlaveRx.data[0], FRAME_SIZE);
    }
}

/* SPI Slave ISR for error */
void slaveQSPI2ErISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrError(&g_qspiSlaveSafe.spiSafeComSlave);
}

/*
 * QSPI Slave initialization
 * This function initializes the QSPI2 module in Slave mode.
 */
void initQSPI2Slave(void)
{
    /* Define the Slave configuration */
    IfxQspi_SpiSlave_Config spiSlaveConfig;

    /* Initialize it with default values */
    IfxQspi_SpiSlave_initModuleConfig(&spiSlaveConfig, &MODULE_QSPI2);
    spiSlaveConfig.protocol.dataWidth = DATA_WIDTH;
    /* Select the port pins for communication */
    const IfxQspi_SpiSlave_Pins qspi2SlavePins = {
        &IfxQspi2_SCLKB_P15_8_IN, IfxPort_InputMode_pullDown,           /* SCLK Pin                       (CLK)     */
        &IfxQspi2_MTSRB_P15_6_IN, IfxPort_InputMode_pullDown,           /* MasterTransmitSlaveReceive pin (MOSI)    */
        &IfxQspi2_MRST_P15_7_OUT, IfxPort_OutputMode_pushPull,          /* MasterReceiveSlaveTransmit pin (MISO)    */
        &IfxQspi2_SLSIB_P15_1_IN, IfxPort_InputMode_pullDown,           /* SlaveSelect Pin                (CS)      */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                          /* Pad driver mode                          */
    };
    spiSlaveConfig.pins = &qspi2SlavePins;                              /* Assign Slave port pins                   */

    /* Set the ISR priorities and the service provider */
    spiSlaveConfig.base.txPriority = ISR_PRIORITY_SLAVE_TX_QSPI_SAFE;
    spiSlaveConfig.base.rxPriority = ISR_PRIORITY_SLAVE_RX_QSPI_SAFE;
    spiSlaveConfig.base.erPriority = ISR_PRIORITY_SLAVE_ER_QSPI_SAFE;
    spiSlaveConfig.base.isrProvider = IfxSrc_Tos_cpu1;

    /* Initialize QSPI Slave module */
    IfxQspi_SpiSlave_initModule(&g_qspiSlaveSafe.spiSafeComSlave, &spiSlaveConfig);
}

/*
 * This function to validate the timeout timing of QSPI
 * */
void timeoutSlaveQspiSafeCommunication(void)
{
    static float64 endOfFrameTime, startTime;
    startTime = getMilliSecondTime();
    do
    {
        /* time when the frame transfer is finished */
        endOfFrameTime = (getMilliSecondTime() - startTime);
        if (endOfFrameTime > FRAME_TIMEOUT)
        {
            /* turn on the OneEye GUI LED */
            g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.frameTimeOutError = TRUE;
            return;
        }
        else
        {
            /* turn off the OneEye GUI LED */
            g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.frameTimeOutError = FALSE;
        }
    }while (g_frameReceived == FALSE);

    g_frameReceived = FALSE;
}

/*
 * This function to validate the cycle timing of QSPI frame
 * */
void validateFrameCylceTime(float64 cycleTime)
{
    static uint32 calibrationCounter = 0;
    static float64 previousCycleTime = 0;

    /* validate the cycle time only after 2nd frame received */
    if (calibrationCounter == 0)
    {
        calibrationCounter++;
    }
    else
    {
        /* early frame error */
        if((cycleTime - previousCycleTime) < EARLY_CYCLE_TIME)
        {
            /* turn on the OneEye GUI LED */
            g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.earlyFrameArriveError = TRUE;
        }
        else
        {
            /* turn off the OneEye GUI LED */
            g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.earlyFrameArriveError = FALSE;
        }

        /* late frame error */
        if((cycleTime - previousCycleTime) > LATE_CYCLE_TIME)
        {
            /* turn on the OneEye GUI LED */
            g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.lateFrameArriveError = TRUE;
        }
        else
        {
            /* turn off the OneEye GUI LED */
            g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.lateFrameArriveError = FALSE;
        }
    }
    previousCycleTime = cycleTime;
}

/*
 * This function to validate the data of QSPI frame
 * */
void validateSlavedata(uint32 frameCounter)
{
    uint32 calculatedCrcResultSlaveRx = 0;

    /* calculate CRC on Slave received data */
    for (uint8 i=0; i < BUFFER_SIZE ; i++)
    {
        calculatedCrcResultSlaveRx = __crc32(calculatedCrcResultSlaveRx,
                g_qspiSlaveSafe.qspiSlaveRx.dataS.spi3SlaveRxBuffer[i]);
    }

    /* Check if the slave received data matches the master sent data i.e. ID, Frame counter, CRC  */
    if ((MASTER_DATA_ID != g_qspiSlaveSafe.qspiSlaveRx.dataS.data_id )     ||
        (frameCounter != g_qspiSlaveSafe.qspiSlaveRx.dataS.frame_counter ) ||
        (calculatedCrcResultSlaveRx != g_qspiSlaveSafe.qspiSlaveRx.dataS.crc))
    {
        /* turn on the OneEye GUI LED */
        g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.dataMisMatchError = TRUE;
    }
    else
    {
        /* turn off the OneEye GUI LED */
        g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.dataMisMatchError = FALSE;
    }
}
/*
 * This function checks if the received data is correct
 * */
void validateSlaveDataAndCycleTime(uint32 frameCounterSlaveQSPI, float64 cycleTime)
{
    uint32 waitTimeout = 0xffff;

    /* Wait until the Slave has received all the data or or if the timeout comes */
    while((IfxQspi_SpiSlave_getStatus(&g_qspiSlaveSafe.spiSafeComSlave) == SpiIf_Status_busy) &&
            (waitTimeout > 0))
    {
        waitTimeout--;
    }
    /* status led of slave received data */
    IfxPort_togglePin(LED2);

    /* validate the data of QSPI frame */
    validateSlavedata(frameCounterSlaveQSPI);

    /* validate the cycle time */
    validateFrameCylceTime(cycleTime);
}

/*
 * This function initialize the QSPI modules as slave
 * */
void initQspiSlaveSafeCommunication()
{
    IfxPort_setPinModeOutput(LED2, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(LED2);

    /* init the error flags */
    g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.dataMisMatchError = FALSE;
    g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.earlyFrameArriveError = FALSE;
    g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.frameTimeOutError = FALSE;
    g_qspiSafeCommDiagnose.g_ErrorTypeQspiSafe.lateFrameArriveError = FALSE;

    /* Initialize the Slave */
    initQSPI2Slave();

    /* Instruct the SPI Slave to receive a data stream of defined length */
    IfxQspi_SpiSlave_exchange(&g_qspiSlaveSafe.spiSafeComSlave, NULL_PTR,
            &g_qspiSlaveSafe.qspiSlaveRx.data[0], FRAME_SIZE);
}
