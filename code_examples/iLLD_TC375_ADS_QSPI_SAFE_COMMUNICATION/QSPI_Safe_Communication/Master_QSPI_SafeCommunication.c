/**********************************************************************************************************************
 * \file Master_QSPI_SafeCommunication.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Master_QSPI_SafeCommunication.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* QSPI Master */
#define MASTER_DATA_ID            0x01
#define MASTER_DATA_WIDTH         32              /* 32 bits                                                         */
#define MASTER_CHANNEL_BAUDRATE   1000000         /* Master channel baud rate (bit/sec)                              */
#define DATA_ARRAY_LENGTH         MASTER_BUFFER_SIZE * MASTER_BUFFER_SIZE

#define EXPECTED_CYCLE_TIME       100                          /* 100ms                                              */
#define EARLY_CYCLE_TIME          EXPECTED_CYCLE_TIME - 10     /* 90ms                                               */
#define LATE_CYCLE_TIME           EXPECTED_CYCLE_TIME + 10     /* 110ms                                              */

#define LED1                      &MODULE_P00, 5   /* LED: Port, Pin definition                                      */

/* Priorities used in QSPI Safe communication */
#define ISR_PRIORITY_MASTER_TX_QSPI_SAFE          2
#define ISR_PRIORITY_MASTER_RX_QSPI_SAFE          3
#define ISR_PRIORITY_MASTER_ER_QSPI_SAFE          4


/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
qspiMasterSafeComm g_qspiMasterSafe;
uint32 g_cyclTimeQSPI = EXPECTED_CYCLE_TIME;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
uint32 payloadData[DATA_ARRAY_LENGTH] =     /* Payload Data */
{
    0xaaaaaaaa, 0x55555555, 0xaaaaaaaa, 0x55555555,
    0xb0d9d5a7, 0x768093e0, 0x88b206a0, 0xc51299e4,
    0x00000011, 0x00000022, 0x00000033, 0x00000044,
    0xaabbccdd, 0x11223344, 0xdeff0022, 0x88df5ef9
};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initQSPI1Master(void);
void initQSPI1MasterChannel(void);
void updateMasterBuffer(void);
IFX_INTERRUPT(masterQSPI1TxISR, 0, ISR_PRIORITY_MASTER_TX_QSPI_SAFE);
IFX_INTERRUPT(masterQSPI1RxISR, 0, ISR_PRIORITY_MASTER_RX_QSPI_SAFE);
IFX_INTERRUPT(masterQSPI1ErISR, 0, ISR_PRIORITY_MASTER_ER_QSPI_SAFE);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* SPI Master ISR for transmit data */
void masterQSPI1TxISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrTransmit(&g_qspiMasterSafe.spiSafeComMaster);
}

/* SPI Master ISR for receive data */
void masterQSPI1RxISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrReceive(&g_qspiMasterSafe.spiSafeComMaster);
}

/* SPI Master ISR for error */
void masterQSPI1ErISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrError(&g_qspiMasterSafe.spiSafeComMaster);
}

/*
 * This function is to change the QSPI Cycle time either with correct timing or with error timing to inject fault
 * */
void updateQspiCycleTime(void)
{
    switch (g_qspiMasterSafe.qpsiSafeTimingErrorInjection)
    {
        case ExpectedFrame :
            g_cyclTimeQSPI = EXPECTED_CYCLE_TIME;
            break;
        case EarlyFrame :
            g_cyclTimeQSPI = EARLY_CYCLE_TIME;
            break;
        case LateFrame :
            g_cyclTimeQSPI = LATE_CYCLE_TIME;
            break;
        default:
            g_cyclTimeQSPI = EXPECTED_CYCLE_TIME;
            break;
    }
}

/* QSPI Master initialization
 * This function initializes the QSPI1 module in Master mode.
 */
void initQSPI1Master(void)
{
    IfxQspi_SpiMaster_Config spiMasterConfig;                           /* Define a Master configuration            */

    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, &MODULE_QSPI1); /* Initialize it with default values        */

    spiMasterConfig.base.mode = SpiIf_Mode_master;                      /* Configure the mode                       */

    /* Select the port pins for communication */
    const IfxQspi_SpiMaster_Pins qspi1MasterPins = {
        &IfxQspi1_SCLK_P10_2_OUT, IfxPort_OutputMode_pushPull,          /* SCLK Pin                       (CLK)     */
        &IfxQspi1_MTSR_P10_3_OUT, IfxPort_OutputMode_pushPull,          /* MasterTransmitSlaveReceive pin (MOSI)    */
        &IfxQspi1_MRSTA_P10_1_IN, IfxPort_InputMode_pullDown,           /* MasterReceiveSlaveTransmit pin (MISO)    */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                          /* Pad driver mode                          */
    };
    spiMasterConfig.pins = &qspi1MasterPins;                            /* Assign the Master's port pins            */

    /* Set the ISR priorities and the service provider */
    spiMasterConfig.base.txPriority = ISR_PRIORITY_MASTER_TX_QSPI_SAFE;
    spiMasterConfig.base.rxPriority = ISR_PRIORITY_MASTER_RX_QSPI_SAFE;
    spiMasterConfig.base.erPriority = ISR_PRIORITY_MASTER_ER_QSPI_SAFE;
    spiMasterConfig.base.isrProvider = IfxSrc_Tos_cpu0;

    /* Initialize the QSPI Master module */
    IfxQspi_SpiMaster_initModule(&g_qspiMasterSafe.spiSafeComMaster, &spiMasterConfig);
}

/* QSPI Master channel initialization
 * This function initializes the QSPI1 Master channel.
 */
void initQSPI1MasterChannel(void)
{
    /* Define a Master Channel configuration */
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    /* Initialize the configuration with default values */
    IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &g_qspiMasterSafe.spiSafeComMaster);

    /* Set SCLK frequency to 1 MHz */
    spiMasterChannelConfig.base.baudrate = MASTER_CHANNEL_BAUDRATE;
    spiMasterChannelConfig.base.mode.dataWidth = MASTER_DATA_WIDTH;

    /* Select the port pin for the Chip Select signal */
    const IfxQspi_SpiMaster_Output qspi1SlaveSelect = {                 /* QSPI1 Master selects the QSPI1 Slave     */
        &IfxQspi1_SLSO9_P10_5_OUT, IfxPort_OutputMode_pushPull,         /* Slave Select port pin (CS)               */
        IfxPort_PadDriver_cmosAutomotiveSpeed1                          /* Pad driver mode                          */
    };
    spiMasterChannelConfig.sls.output = qspi1SlaveSelect;

    /* Initialize the QSPI Master channel */
    IfxQspi_SpiMaster_initChannel(&g_qspiMasterSafe.spiSafeComMasterChannel, &spiMasterChannelConfig);
}

/* QSPI Master SW buffer initialization
 * This function update SW buffers the Master uses.
 */
void updateMasterBuffer(void)
{
    static uint32 frameCounter = 0;
    static uint32 payloadIncrement = 0;
    uint32 crcResult = 0;
    g_qspiMasterSafe.qspiMasterTx.dataM.data_id = MASTER_DATA_ID;

    /* circle through payload array data */
    if (payloadIncrement == DATA_ARRAY_LENGTH)
    {
        payloadIncrement = 0;
    }

    /* Fill the data to be sent and calculate CRC on this data */
    for (uint32 i = 0; i < MASTER_BUFFER_SIZE; i++)
    {
        /* Fill TX Master Buffer with pattern */
        g_qspiMasterSafe.qspiMasterTx.dataM.spi4MasterTxBuffer[i] = payloadData[i + payloadIncrement];

        /* calculate CRC on data */
        crcResult = __crc32(crcResult, g_qspiMasterSafe.qspiMasterTx.dataM.spi4MasterTxBuffer[i]);
    }
    g_qspiMasterSafe.qspiMasterTx.dataM.crc = crcResult;
    g_qspiMasterSafe.qspiMasterTx.dataM.frame_counter = frameCounter;
    frameCounter++;
    payloadIncrement = payloadIncrement + MASTER_BUFFER_SIZE;
}

/*
 * This function starts the data transfer from Master to Slave
 * SM:QSPI:SAFE_COMMUNICATION
 * */
void masterTransmitDataSafeCommQSPI()
{
    uint8 loopTimeout = 0xff;

    /* QSPI data buffers update */
    updateMasterBuffer();

    /* Wait until the previous communication has finished, if any or if the loop timeout comes */
    while ((IfxQspi_SpiMaster_getStatus(&g_qspiMasterSafe.spiSafeComMasterChannel) == SpiIf_Status_busy)
            && (loopTimeout > 0))
    {
        loopTimeout--;
    }

    /* Send a data stream through the SPI Master */
    IfxQspi_SpiMaster_exchange(&g_qspiMasterSafe.spiSafeComMasterChannel,
            &g_qspiMasterSafe.qspiMasterTx.data[0], NULL_PTR, MASTER_FRAME_SIZE);

    /* toggling the LEDs for status update */
    IfxPort_togglePin(LED1);
}

/*
 * This function initialize the QSPI modules as master
 * */
void initQspiMasterSafeComm(void)
{
    /* Initialization of the LED used in this example */
    IfxPort_setPinModeOutput(LED1, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(LED1);

    /* Initialize the Master */
    initQSPI1Master();
    initQSPI1MasterChannel();
}
