/**********************************************************************************************************************
 * \file MPU_Memory_Protection.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "MPU_Memory_Protection.h"

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function that enables the memory protection
 * Make sure to define code and data protection ranges before calling this function.
 *
 * In this function two intrinsic functions, __mfcr() and __mtcr() are called, to access control registers.
 * The intrinsic function __mfcr(int cfsr) moves contents of the addressed Core Special Function Register (CSFR)
 * into a data register.
 * The intrinsic function __mtcr(int csfr, int val) moves contents of a data register (second int) to the addressed
 * CSFR (first int).
 * The ISYNC instruction ensures that the effects of the CSFR update are correctly seen by all following instructions.
 *
 * The Tasking intrinsic function for MTCR automatically includes an ISYNC instruction.
 * ISYNC for other compiler vendors is ensured by use of a preprocessor macro.
 */

void MPU_enable_protection()
{
    Ifx_CPU_SYSCON sysconValue;
    sysconValue.U = __mfcr(CPU_SYSCON);                 /* Get the System Configuration Register (SYSCON) value     */
    sysconValue.B.PROTEN = 1;                           /* Set the PROTEN bitfield to enable the Memory Protection  */
    __mtcr(CPU_SYSCON, sysconValue.U);                  /* Set the System Configuration Register (SYSCON)           */

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function that defines a data protection range in the corresponding CPU Data Protection Range Register (DPR).
 * Data protection ranges have 8-byte granularity.
 * As a result, the lower 3 bits of any address passed to the define_data_protection_range function will be discarded.
 * After enabling the Memory Protection, access to an address 'x' will be allowed only if:
 * lowerBoundAddress <= x < upperBoundAddress
 */
void define_data_protection_range(uint32 lowerBoundAddress, uint32 upperBoundAddress, uint8 range)
{
    switch(range)
    {
        case 0: /* Data Protection Range 0 */
            __mtcr(CPU_DPR0_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 0       */
            __mtcr(CPU_DPR0_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 0       */
            break;
        case 1: /* Data Protection Range 1 */
            __mtcr(CPU_DPR1_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 1       */
            __mtcr(CPU_DPR1_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 1       */
            break;
        case 2: /* Data Protection Range 2 */
            __mtcr(CPU_DPR2_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 2       */
            __mtcr(CPU_DPR2_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 2       */
            break;
        case 3: /* Data Protection Range 3 */
            __mtcr(CPU_DPR3_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 3       */
            __mtcr(CPU_DPR3_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 3       */
            break;
        case 4: /* Data Protection Range 4 */
            __mtcr(CPU_DPR4_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 4       */
            __mtcr(CPU_DPR4_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 4       */
            break;
        case 5: /* Data Protection Range 5 */
            __mtcr(CPU_DPR5_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 5       */
            __mtcr(CPU_DPR5_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 5       */
            break;
        case 6: /* Data Protection Range 6 */
            __mtcr(CPU_DPR6_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 6       */
            __mtcr(CPU_DPR6_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 6       */
            break;
        case 7: /* Data Protection Range 7 */
            __mtcr(CPU_DPR7_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 7       */
            __mtcr(CPU_DPR7_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 7       */
            break;
        case 8: /* Data Protection Range 8 */
            __mtcr(CPU_DPR8_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 8       */
            __mtcr(CPU_DPR8_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 8       */
            break;
        case 9: /* Data Protection Range 9 */
            __mtcr(CPU_DPR9_L, lowerBoundAddress);      /* Set the lower bound of CPU Data Protection Range 9       */
            __mtcr(CPU_DPR9_U, upperBoundAddress);      /* Set the upper bound of CPU Data Protection Range 9       */
            break;
        case 10: /* Data Protection Range 10 */
            __mtcr(CPU_DPR10_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 10      */
            __mtcr(CPU_DPR10_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 10      */
            break;
        case 11: /* Data Protection Range 11 */
            __mtcr(CPU_DPR11_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 11      */
            __mtcr(CPU_DPR11_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 11      */
            break;
        case 12: /* Data Protection Range 12 */
            __mtcr(CPU_DPR12_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 12      */
            __mtcr(CPU_DPR12_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 12      */
            break;
        case 13: /* Data Protection Range 13 */
            __mtcr(CPU_DPR13_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 13      */
            __mtcr(CPU_DPR13_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 13      */
            break;
        case 14: /* Data Protection Range 14 */
            __mtcr(CPU_DPR14_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 14      */
            __mtcr(CPU_DPR14_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 14      */
            break;
        case 15: /* Data Protection Range 15 */
            __mtcr(CPU_DPR15_L, lowerBoundAddress);     /* Set the lower bound of CPU Data Protection Range 15      */
            __mtcr(CPU_DPR15_U, upperBoundAddress);     /* Set the upper bound of CPU Data Protection Range 15      */
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function that defines a code protection range in the corresponding CPU Code Protection Range Register (CPR).
 * Code protection ranges have 8-byte granularity.
 * As a result, the lower 3 bits of any address passed to the define_code_protection_range function will be discarded.
 * After enabling the Memory Protection, access to an address 'x' will be allowed only if:
 * lowerBoundAddress <= x < upperBoundAddress
 */
void define_code_protection_range(uint32 lowerBoundAddress, uint32 upperBoundAddress, uint8 range)
{
    switch(range)
    {
        case 0: /* Code Protection Range 0 */
            __mtcr(CPU_CPR0_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 0       */
            __mtcr(CPU_CPR0_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 0       */
            break;
        case 1: /* Code Protection Range 1 */
            __mtcr(CPU_CPR1_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 1       */
            __mtcr(CPU_CPR1_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 1       */
            break;
        case 2: /* Code Protection Range 2 */
            __mtcr(CPU_CPR2_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 2       */
            __mtcr(CPU_CPR2_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 2       */
            break;
        case 3: /* Code Protection Range 3 */
            __mtcr(CPU_CPR3_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 3       */
            __mtcr(CPU_CPR3_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 3       */
            break;
        case 4: /* Code Protection Range 4 */
            __mtcr(CPU_CPR4_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 4       */
            __mtcr(CPU_CPR4_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 4       */
            break;
        case 5: /* Code Protection Range 5 */
            __mtcr(CPU_CPR5_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 5       */
            __mtcr(CPU_CPR5_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 5       */
            break;
        case 6: /* Code Protection Range 6 */
            __mtcr(CPU_CPR6_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 6       */
            __mtcr(CPU_CPR6_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 6       */
            break;
        case 7: /* Code Protection Range 7 */
            __mtcr(CPU_CPR7_L, lowerBoundAddress);      /* Set the lower bound of CPU Code Protection Range 7       */
            __mtcr(CPU_CPR7_U, upperBoundAddress);      /* Set the upper bound of CPU Code Protection Range 7       */
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to enable the data read access to a predefined Range in a Protection Set */
void enable_data_read(uint8 protectionSet, uint8 range)
{
    Ifx_CPU_DPRE DPRERegisterValue;

    /* Get the CPU Data Protection Read Enable Register value */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE0);
            break;
        case 1: /* Protection Set 1 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE1);
            break;
        case 2: /* Protection Set 2 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE2);
            break;
        case 3: /* Protection Set 3 */
            DPRERegisterValue.U = __mfcr(CPU_DPRE3);
            break;
    }

    DPRERegisterValue.B.RE |= (1 << range); /* Set the bit corresponding to the given Data Protection Range */

    /* Set the CPU Data Protection Read Enable Register value to enable data read access */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            __mtcr(CPU_DPRE0, DPRERegisterValue.U);
            break;
        case 1: /* Protection Set 1 */
            __mtcr(CPU_DPRE1, DPRERegisterValue.U);
            break;
        case 2: /* Protection Set 2 */
            __mtcr(CPU_DPRE2, DPRERegisterValue.U);
            break;
        case 3: /* Protection Set 3 */
            __mtcr(CPU_DPRE3, DPRERegisterValue.U);
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to enable the data write access to a predefined Range in a Protection Set */
void enable_data_write(uint8 protectionSet, uint8 range)
{
    Ifx_CPU_DPWE DPWERegisterValue;

    /* Get the CPU Data Protection Write Enable Register value */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE0);
            break;
        case 1: /* Protection Set 1 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE1);
            break;
        case 2: /* Protection Set 2 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE2);
            break;
        case 3: /* Protection Set 3 */
            DPWERegisterValue.U = __mfcr(CPU_DPWE3);
            break;
    }

    /* Set the bit corresponding to the given Data Protection Range */
    DPWERegisterValue.B.WE |= (0x1 << range);

    /* Set the CPU Data Protection Write Enable Register value to enable data write access */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            __mtcr(CPU_DPWE0, DPWERegisterValue.U);
            break;
        case 1: /* Protection Set 1 */
            __mtcr(CPU_DPWE1, DPWERegisterValue.U);
            break;
        case 2: /* Protection Set 2 */
            __mtcr(CPU_DPWE2, DPWERegisterValue.U);
            break;
        case 3: /* Protection Set 3 */
            __mtcr(CPU_DPWE3, DPWERegisterValue.U);
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to enable code execution access to a predefined Range in a Protection Set */
void enable_code_execution(uint8 protectionSet, uint8 range)
{
    Ifx_CPU_CPXE CPXERegisterValue;

    /* Get the CPU Code Protection Execute Enable Register value */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE0);
            break;
        case 1: /* Protection Set 1 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE1);
            break;
        case 2: /* Protection Set 2 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE2);
            break;
        case 3: /* Protection Set 3 */
            CPXERegisterValue.U = __mfcr(CPU_CPXE3);
            break;
    }

    /* Set the bit corresponding to the given Code Protection Range */
    CPXERegisterValue.B.XE |= (0x1 << range);

    /* Set the CPU Code Protection Execute Enable Register value to enable coded execution */
    switch(protectionSet)
    {
        case 0: /* Protection Set 0 */
            __mtcr(CPU_CPXE0, CPXERegisterValue.U);
            break;
        case 1: /* Protection Set 1 */
            __mtcr(CPU_CPXE1, CPXERegisterValue.U);
            break;
        case 2: /* Protection Set 2 */
            __mtcr(CPU_CPXE2, CPXERegisterValue.U);
            break;
        case 3: /* Protection Set 3 */
            __mtcr(CPU_CPXE3, CPXERegisterValue.U);
            break;
    }

#if !defined(__TASKING__)
    __isync();
#endif
}

/* Function to initialize the port pins that drive the LEDs */
void init_LEDs()
{
    /* Initialize of the LED port pins */
    IfxPort_setPinModeOutput(LED_FIRST_HALF, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LED_SECOND_HALF, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Switch OFF the LEDs (low-level active) */
    IfxPort_setPinHigh(LED_FIRST_HALF);
    IfxPort_setPinHigh(LED_SECOND_HALF);
}

/* Function to turn ON an LED (low-level active) */
void switch_LED_ON(Ifx_P *ledPort, uint8 ledPinIndex)
{
    IfxPort_setPinLow(ledPort, ledPinIndex);
}
