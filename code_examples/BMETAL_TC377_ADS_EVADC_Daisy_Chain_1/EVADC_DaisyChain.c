/**********************************************************************************************************************
 * \file EVADC_DaisyChain.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxConverter_reg.h"
#include "IfxEvadc_Adc.h"
#include "IfxStm_reg.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
volatile unsigned int timestamp_trigger;
volatile unsigned int timestamp_G2CH0; /* Store the timestamps for the 6 conversion results in the daisy chain */
volatile unsigned int timestamp_G2CH3;
volatile unsigned int timestamp_G3CH1;
volatile unsigned int timestamp_G0CH6;
volatile unsigned int timestamp_G0CH2;
volatile unsigned int timestamp_G0CH4;

volatile unsigned int trigger_to_G2CH0;
volatile unsigned int G2CH0_to_G2CH3;
volatile unsigned int G2CH3_to_G3CH1;
volatile unsigned int G3CH1_to_G0CH6;
volatile unsigned int G0CH6_to_G0CH2;
volatile unsigned int G0CH2_to_G0CH4;
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* This function initializes Convert Control module:
 * - Enable the CONVCTRL module
 * - Set up 40MHz clock
 */
static void init_CONVCTRL( void )
{
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword ());
    CONVCTRL_CLC.U = 0x00000000;        /* Enable module CONVCTRL */

    while(CONVCTRL_CLC.B.DISS == 0x1)   /* Wait until module clock is enabled   */
    {;}

    CONVCTRL_CCCTRL.U = 0xB0000000;     /* Unlock converter control registers   */
    CONVCTRL_PHSCFG.U = 0x00008003;     /* fADC=160MHz, fPHSYNC=160MHz/4=40MHz  */
    CONVCTRL_CCCTRL.U = 0x00000000;     /* Lock converter control registers     */

    IfxScuWdt_setCpuEndinit (IfxScuWdt_getCpuWatchdogPassword ());
}

/* Function to wait until specified us has elapsed */
static void wait_micro_second(unsigned int ticks_in_us)
{
    /* fSTM = 100MHz by default */
    unsigned int stmCount = 100 * ticks_in_us;

    unsigned int   stmCountBegin = STM0_TIM0.U;

    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

}

/* This function initializes the EVADC Group 0, 2 and 3:
 * - Enable the module
 * - Set up internal clock to 40MHz
 * - Enable Normal operation mode
 * - Request calibration
 * - Set up Queue 1
 * - Set up channel settings
 */
void enable_EVADC( void )
{
    init_CONVCTRL();        /* Enable CONVCTRL module*/

    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    EVADC_CLC.U = 0x0;      /* Enable clock for the EVADC module*/

    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Wait until Module clock is enabled (DISS == 0) */
    while( EVADC_CLC.B.DISS == 0x1 );

    /* Setup Module clock
     * ANCFG - Analog Fct. Config. Register,
         * IPE[0]       - 0x0   --> Idle Precharge
         * BE[1]        - 0x0   --> Input Buffer
         * RPE[2]       - 0x1   --> Reference Precharge
         * RPC[3]       - 0x0   --> Reference Precharge Control
         * CALSTC[4:5]  - 0x0   --> Calibration Sample Time Control
         * DPCAL[6]     - 0x1   --> Disable Post-Calibration
         * ACSD[16:18]  - 0x00  --> Analog Clock Synchronization Delay
         * SSE[19]      - 0x0   --> Sample Synchronization
         * DIVA[20:24]  - 0x03  --> Divider Factor for the Analog Internal Clock (F_adci), 0x03 = 40MHz
         * DCMSB[25]    - 0x0   --> Double Clock for the MSB Conversion
     * */

    EVADC_G0ANCFG.U = ( 0x1 << 2 ) | ( 0x1 << 6 ) | ( 0x1 << 19) | ( 0x3 << 20 );
    EVADC_G2ANCFG.U = ( 0x1 << 2 ) | ( 0x1 << 6 ) | ( 0x1 << 19) | ( 0x3 << 20 );
    EVADC_G3ANCFG.U = ( 0x1 << 2 ) | ( 0x1 << 6 ) | ( 0x1 << 19) | ( 0x3 << 20 );

    /* Enable Module Operation
    * GxARBCFG - Arbitration Config. Register
       * ANONC[0:1]     - 0x03 --> Analog Converter Control, 0x03 = Normal Operation
       * ANONs[16:17]   - rh --> Analog Converter Control Status
       * CHNR[20:24]    - rh --> Channel Number
       * SYNRUN[25]     - rh --> Synchronous Conversion Running
       * CAL[28]        - rh --> Start-Up Calibration Active Indication
       * BUSY[30]       - rh --> Converter Busy Flag
       * SAMPLE[31]     - rh --> Sample Phase Flag
    * */
    EVADC_G0ARBCFG.B.ANONC = 0x3;               /* Setup Normal Operation  */
    EVADC_G2ARBCFG.B.ANONC = 0x3;
    EVADC_G3ARBCFG.B.ANONC = 0x3;

    /* Wait at least 3us to settle analog part */
    wait_micro_second(3);

    /* Request startup calibration
    * EVADC_GLOBCFG - Global Configuration Register
        * USC[12]       - 0x0   --> Unsynchronized Clock Generation
        * SUPLEV[13:14] - 0x00  --> Supply Voltage Level, Automatic control
        * CPWC[15]      - 0x1   --> Write Control
        * SUCAL[31]     - 0x1   --> Start-Up Calibration
    * */
    EVADC_GLOBCFG.U = (1 << 31 ); /* Enable startup calibration */

    /* Wait until calibration is done */
    while((EVADC_G0ARBCFG.B.CAL == 0x1) || (EVADC_G2ARBCFG.B.CAL == 0x1) || (EVADC_G2ARBCFG.B.CAL == 0x1));

    /* Add Channels 0 and 3 to Group 2 Queue Source 0 and enable External Trigger */
    /* GxQINRi (i=0-2) - Queue i Input Register, Group x
        * REQCHNR[0:4]  - 0x00  --> Request Channel Number
        * RF[5]         - 0x00  --> Refill
        * ENSI[6]       - 0x0x  --> Enable Source Interrupt
        * EXTR[7]       - 0x0x  --> External Trigger
        * PDD[9]        - 0x00  --> Pull-Down Diagnostics Enable
        * MDPD[10]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable
        * MDPU[11]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable - MDPD,MDPU
        * CDEN[12]      - 0x00  --> Converter Diagnostics Enable
        * CDSEL[13:14]  - 0x00  --> Converter Diagnostics Pull-Devices Select
    * */

    /* Expected conversion sequence:
     * G2CH0->G2CH3->G3CH1->G0CH6->G0CH2->G0CH4
     * Note: the queue number must be the same for all groups in the daisy chain
     * In this example, QINR1 is used
     */
    EVADC_G2QINR1.U = ( 0x0 << 0 ) | ( 0x0 << 6 ) | ( 0x1 << 7 );
    EVADC_G2QINR1.U = ( 0x3 << 0 ) | ( 0x1 << 6 ) | ( 0x0 << 7 );

    EVADC_G3QINR1.U = ( 0x1 << 0 ) | ( 0x1 << 6 ) | ( 0x1 << 7 );

    EVADC_G0QINR1.U = ( 0x6 << 0 ) | ( 0x0 << 6 ) | ( 0x1 << 7 );
    EVADC_G0QINR1.U = ( 0x2 << 0 ) | ( 0x0 << 6 ) | ( 0x0 << 7 );
    EVADC_G0QINR1.U = ( 0x4 << 0 ) | ( 0x1 << 6 ) | ( 0x0 << 7 );

    /* Configure Source Control Trigger & Gate
    * GxQCTRLi (i=0-2;x=0-11) - Queue i Source Contr. Register, Group x
        * SRCRESREG[0:3]    - 0x00  --> Source-specific Result Register
        * TRSEL[7:6]        - 0xXX  --> Trigger Source Selection
        * XTSEL[8:11]       - 0x00  --> External Trigger Input Selection
        * XTLVL[12]         - 0x00  --> External Trigger Level
        * XTMODE[13:14]     - 0xXX  --> Trigger Operating Mode
        * XTWC[15]          - 0x00  --> Control for Trigger Configuration
        * GTSEL[16:19]      - 0x00  --> Gate Input Selection
        * GTLVL[20]         - 0x00  --> Gate Input Level
        * GTWC[23]          - 0x00  --> Write Control for Gate Configuration
        * TMEN[28]          - 0x00  --> Timer Mode Enable
        * TMWC[31]          - 0x00  --> Write Control for Timer Mode
    * */

    EVADC_G2QCTRL1.U = 0;

    EVADC_G3QCTRL1.U = ( 0x0 )      |    /* Use GxCHCTRy.RESREG to select result register for channels in group*/
                      ( 0x1 << 6 )  |    /* Trigger from the lower adjacent group */
                      ( 0x1 << 13 ) |    /* Trigger on rising edge*/
                      ( 0x1 << 15 );     /* Bitfields XTMODE, XTSEL, TRSEL can be written */

    EVADC_G0QCTRL1.U = ( 0x0 )      |    /* Use GxCHCTRy.RESREG to select result register for channels in group*/
                      ( 0x2 << 6 )  |    /* Trigger wrap around */
                      ( 0x1 << 13 ) |    /* Trigger on rising edge*/
                      ( 0x1 << 15 );     /* Bitfields XTMODE, XTSEL, TRSEL can be written */


    /* Enable Trigger & Gate for Request Source 0
    * GxQMRi (i=0-2;x=0-11) - Queue i Mode Register, Group x
        * ENGT[0:1]    - 0x01  --> Enable Gate
        * ENTR[2]      - 0x1   --> Enable External Trigger
        * CLRV[8]      - 0x0   --> Clear Valid Bit
        * TREV[9]      - 0x0   --> Trigger Event
        * FLUSH[10]    - 0x0   --> Flush Queue
        * CEV[11]      - 0x0   --> Clear Event Flag
        * PTDIS[16]    - 0x0   --> Repeat Disable
    * */
    EVADC_G2QMR1.B.ENGT = 0x1;  /* Enable Gate */
    EVADC_G2QMR1.B.ENTR = 0x1;  /* Enable External Trigger */

    EVADC_G3QMR1.B.ENGT = 0x1;  /* Enable Gate */
    EVADC_G3QMR1.B.ENTR = 0x1;  /* Enable External Trigger */

    EVADC_G0QMR1.B.ENGT = 0x1;  /* Enable Gate */
    EVADC_G0QMR1.B.ENTR = 0x1;  /* Enable External Trigger */

    /* Configure Channel Settings */

    /* Configure sample time of 425ns = 16 x F_adci(40MHz), 2 + (STCS - 15) × 16
    * GxICLASSi - Input Class Register i, (i=0-1)
        * STCS[0:4]     - 0x0F  --> Sample Time Control for Standard Conversions
        * AIPS[6:7]     - 0x00  --> Analog Input Precharge Control for Standard Conversions
        * CMS[8:9]      - 0x00  --> Conversion Mode for Standard Conversions
        * SESPS[10]     - 0x00  --> Spread Early Sample Point for Standard Conversions
        * STCE[16:20]   - 0x00  --> Sample Time Control for EMUX Conversions
        * AIPE[22:23]   - 0x00  --> Analog Input Precharge Control for EMUX Conversions
        * CME[24:25]    - 0x00  --> Conversion Mode for EMUX Conversions
        * SESPE[26]     - 0x00  --> Spread Early Sample Point for EMUX Conversions
    * */
    /* Use the maximum sampling time to make the interval measurement more accurate */
    EVADC_G0ICLASS0.B.STCS  = 0x1F;
    EVADC_G2ICLASS0.B.STCS  = 0x1F;
    EVADC_G3ICLASS0.B.STCS  = 0x1F;

    /*
     * GxCHCTRy - Channel Control Register
        * ICLSEL [0:1]  - 0x00  --> Input Class Select
        * BNDSELL[4:5]  - 0x00  --> Lower Boundary Select
        * BNDSELU[6:7]  - 0x00  --> Upper Boundary Select
        * CHEVMODE[8:9] - 0x00  --> Channel Event Mode
        * SYNC[10]      - 0x00  --> Synchronization Request
        * REFSEL[11]    - 0x00  --> Reference Input Selection
        * BNDSELX[12:15]- 0x00  --> BoundaryExtensions
        * RESREG[16:19] - 0x00  --> Result Register
        * RESTGT[20]    - 0x00  --> Result Target
        * RESPOS[21]    - 0x00  --> Result Position
        * BWDCH[28:29]  - 0x00  --> Broken Wire Detection Channel
        * BWDEN[30]     - 0x00  --> Broken Wire Detection Enable
    * */
    EVADC_G2CHCTR0.B.RESREG = 0x0;  /* Store result from group 2 channel 0 to result register 0 */
    EVADC_G2CHCTR3.B.RESREG = 0x3;  /* Store result from group 2 channel 3 to result register 3 */

    EVADC_G3CHCTR1.B.RESREG = 0x1;  /* Store result from group 3 channel 1 to result register 1 */

    EVADC_G0CHCTR6.B.RESREG = 0x6;  /* Store result from group 0 channel 6 to result register 6 */
    EVADC_G0CHCTR2.B.RESREG = 0x2;  /* Store result from group 0 channel 2 to result register 2 */
    EVADC_G0CHCTR4.B.RESREG = 0x4;  /* Store result from group 0 channel 4 to result register 4 */

    /* Enable arbitration slot x accordingly
    * GxARBPR - Arbitration Priority Register i, i=0-2
        * PRIOi[4*i+1:4*i]  - 0x0  --> Priority of Request Source i
        * CSMi[4*i+3]       - 0x0   --> Conversion Start Mode of Request Source i
        * ASENi[i+24]       - 0x1   --> Arbitration Source Input i Enable
    * */
    EVADC_G2ARBPR.B.ASEN1 = 0x1;    /* Enable Group 2 Arbitration Slot  1 */
    EVADC_G3ARBPR.B.ASEN1 = 0x1;    /* Enable Group 3 Arbitration Slot  1 */
    EVADC_G0ARBPR.B.ASEN1 = 0x1;    /* Enable Group 0 Arbitration Slot  1 */


    EVADC_G2QMR1.B.TREV = 1; /* Trigger the first conversion in the daisy chain */

    timestamp_trigger = STM0_TIM0.U;


    return;

}

void capture_result_time( void )
{

    while(EVADC_G2RES0.B.VF != 1);
    timestamp_G2CH0 = STM0_TIM0.U;

    while(EVADC_G2RES3.B.VF != 1);
    timestamp_G2CH3 = STM0_TIM0.U;

    while(EVADC_G3RES1.B.VF != 1);
    timestamp_G3CH1 = STM0_TIM0.U;

    while(EVADC_G0RES6.B.VF != 1);
    timestamp_G0CH6 = STM0_TIM0.U;

    while(EVADC_G0RES2.B.VF != 1);
    timestamp_G0CH2 = STM0_TIM0.U;

    while(EVADC_G0RES4.B.VF != 1);
    timestamp_G0CH4 = STM0_TIM0.U;

    trigger_to_G2CH0 = timestamp_G2CH0 - timestamp_trigger;
    G2CH0_to_G2CH3 = timestamp_G2CH3 - timestamp_G2CH0;
    G2CH3_to_G3CH1 = timestamp_G3CH1 - timestamp_G2CH3;
    G3CH1_to_G0CH6 = timestamp_G0CH6 - timestamp_G3CH1;
    G0CH6_to_G0CH2 = timestamp_G0CH2 - timestamp_G0CH6;
    G0CH2_to_G0CH4 = timestamp_G0CH4 - timestamp_G0CH2;

    return;
}
