/**********************************************************************************************************************
 * \file DMA_Linked_List_Mode.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "DMA_Linked_List_Mode.h"
#include "IfxDma_Dma.h"
#include "Ifx_Assert.h"
#include "IfxPort.h"
#include "Bsp.h"
#include "pin.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define NUM_LINKED_LIST_ITEMS   4       /* Number of DMA Transactions in the linked list                            */
#define NUM_TRANSFERED_WORDS    16      /* Number of words (32 bits) to be transfered                               */
#define ISR_PRIORITY_DMA_CH0    50      /* Priority of DMA CH0 interrupt                                            */
#define CYCLE_DELAY_MS          1000    /* Delay introduced between each DMA linked list operation, in milliseconds */

#define PASS_LED1               LED_1   /* Pass LED */
#define FAIL_LED2               LED_2   /* Fail LED */

/* Numbers for generating content to be sent by DMA, they have no particular meaning */
#define CONTENT_GENERATOR_NUM1  0x10000000
#define CONTENT_GENERATOR_NUM2  0x00010000

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
uint32 g_source[NUM_LINKED_LIST_ITEMS][NUM_TRANSFERED_WORDS];       /* Source buffers       */
uint32 g_destination[NUM_LINKED_LIST_ITEMS][NUM_TRANSFERED_WORDS];  /* Destination buffers  */

/* Linked List TCSs storage.
 * IMPORTANT: it has to be aligned to a 256-bit address, otherwise the DMA cannot read it
 */
Ifx_DMA_CH IFX_ALIGN(256) g_linkedList[NUM_LINKED_LIST_ITEMS];

IfxDma_Dma g_dma;                   /* DMA handle                */
IfxDma_Dma_Channel g_chn;           /* DMA channel handle        */

volatile Ifx_SRC_SRCR *g_dmaCh0Src; /* DMA Channel0 SRC register */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void checkDmaTransferExecution(void);
static void delay(uint32 ms);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(dmaCh0ISR, 0, ISR_PRIORITY_DMA_CH0);

/* Handle DMA CHANNEL0 interrupt. */
void dmaCh0ISR(void)
{
    /* Enable global Interrupts   */
    IfxCpu_enableInterrupts();
    /* Check DMA transferred data */
    checkDmaTransferExecution();
}

/* Initialization function
 * This function is called from main during initialization phase
 */
void initDmaLinkedList(void)
{
    uint32 i;

    /* Create module configuration */
    IfxDma_Dma_Config dmaConfig;
    IfxDma_Dma_initModuleConfig(&dmaConfig, &MODULE_DMA0);

    /* Initialize module */
    IfxDma_Dma_initModule(&g_dma, &dmaConfig);

    /* Initial channel configuration */
    IfxDma_Dma_ChannelConfig cfg;
    IfxDma_Dma_initChannelConfig(&cfg, &g_dma);

    /* Following settings are used by all transactions of the linked list */
    cfg.channelId = IfxDma_ChannelId_0;
    cfg.transferCount = NUM_TRANSFERED_WORDS;
    cfg.requestMode = IfxDma_ChannelRequestMode_completeTransactionPerRequest;
    cfg.moveSize = IfxDma_ChannelMoveSize_32bit;
    cfg.shadowControl = IfxDma_ChannelShadow_linkedList;

    /* Generate linked list items */
    for(i = 0; i < NUM_LINKED_LIST_ITEMS; ++i)
    {
        cfg.sourceAddress = (uint32)g_source[i];
        cfg.destinationAddress = (uint32)g_destination[i];

        /* Address to next TCS */
        cfg.shadowAddress = (uint32)&g_linkedList[(i + 1) % NUM_LINKED_LIST_ITEMS];

        if(i == NUM_LINKED_LIST_ITEMS - 1)
        {
            /* Enable interrupt on completion of the last DMA transaction of the linked list */
            cfg.channelInterruptEnabled = TRUE;
        }

        /* Copy TCS configuration into linked list storage */
        IfxDma_Dma_initLinkedListEntry((void *)&g_linkedList[i], &cfg);

        /* Copy first transaction set configuration into DMA Channel TCS SFRs  */
        if(i == 0)
        {
            IfxDma_Dma_initChannel(&g_chn, &cfg);
        }
        else
        {
            /* Enable auto-start for the next DMA transactions in the linked list */
            g_linkedList[i].CHCSR.B.SCH = 1;
        }
    }

    /* Configure & enable DMA Channel0 interrupt */
    g_dmaCh0Src = IfxDma_Dma_getSrcPointer(&g_chn);
    IfxSrc_init(g_dmaCh0Src, IfxSrc_Tos_cpu0, ISR_PRIORITY_DMA_CH0, IfxSrc_VmId_0);
    IfxSrc_enable(g_dmaCh0Src);

    /* Setup the port pin connected to the LED to push-pull output mode. */
    IfxPort_setPinMode(PASS_LED1.port, PASS_LED1.pinIndex, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(FAIL_LED2.port, FAIL_LED2.pinIndex, IfxPort_Mode_outputPushPullGeneral);
    /* Turn off LEDs */
    IfxPort_setPinHigh(PASS_LED1.port, PASS_LED1.pinIndex);
    IfxPort_setPinHigh(FAIL_LED2.port, FAIL_LED2.pinIndex);
}

/* Triggers DMA request to start data transfer
 * This function is called once initialization is done
 */
void startDmaLinkedListTransfer(void)
{
    uint32 i, j;

    /* Fill source buffers of DMA transactions */
    for(i = 0; i < NUM_LINKED_LIST_ITEMS; ++i)
    {
        uint32 *src = (uint32 *)g_source[i];

        for(j = 0; j < NUM_TRANSFERED_WORDS; ++j)
        {
            *src++ = CONTENT_GENERATOR_NUM1 + i * CONTENT_GENERATOR_NUM2 + j + 1;
        }
    }

    /* Start first transaction of the DMA linked list */
    IfxDma_Dma_startChannelTransaction(&g_chn);
}

/* This function is called from ISR to:
 * check destination buffers after Linked list execution
 * restart DMA transfer if data is correct
 */
static void checkDmaTransferExecution(void)
{
    uint32 errors = 0;
    uint32 i, j;
    uint32 *src;
    uint32 *dst;

    /* Check destination buffers */
    for(i = 0; i < NUM_LINKED_LIST_ITEMS; ++i)
    {
        src = (uint32 *)g_source[i];
        dst = (uint32 *)g_destination[i];

        for(j = 0; j < NUM_TRANSFERED_WORDS; ++j)
        {
            if(*dst++ != *src++)
            {
                ++errors;
            }
        }
    }

    if(errors != 0)
    {
        /* Stop execution    */
        /* Turn on FAIL LED  */
        IfxPort_setPinLow(FAIL_LED2.port, FAIL_LED2.pinIndex);
        /* Turn off PASS LED */
        IfxPort_setPinHigh(PASS_LED1.port, PASS_LED1.pinIndex);
    }
    else /* No errors */
    {
        /* Toggle Pass LED */
        IfxPort_togglePin(PASS_LED1.port, PASS_LED1.pinIndex);

        /* Add a delay to ensure visibility of LED Toggle */
        delay(CYCLE_DELAY_MS);

        /* Clear Destination buffers */
        for(i = 0; i < NUM_LINKED_LIST_ITEMS; ++i)
        {
            dst = (uint32 *)g_destination[i];

            for(j = 0; j < NUM_TRANSFERED_WORDS; ++j)
            {
                *dst++ = 0x0;
            }
        }
        /* Start again first transaction of the DMA linked list */
        startDmaLinkedListTransfer();
    }
}

/* Waits until a timeout in milliseconds */
static void delay(uint32 ms)
{
    sint32 fSys = IfxStm_getFrequency();
    Ifx_TickTime wait_ms = (fSys / (1000 / ms));

    wait(wait_ms);
}
