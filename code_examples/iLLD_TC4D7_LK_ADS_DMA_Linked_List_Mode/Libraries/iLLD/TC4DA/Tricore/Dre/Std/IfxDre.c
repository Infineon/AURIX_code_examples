/**
 * \file IfxDre.c
 * \brief DRE  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxDre.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxDre_resetModule(Ifx_DRE *dre)
{
    dre->RST.CTRLA.B.KRST = 1;          /* Only if both Kernel reset bits are set a reset is executed */
    dre->RST.CTRLB.B.KRST = 1;

    while (0 == dre->RST.STAT.B.KRST)   /* Wait until reset is executed */
    {}

    dre->RST.CTRLB.B.STATCLR = 1;       /* Clear Kernel reset status bit */

    while (dre->RST.STAT.B.KRST == 1)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}
}


void IfxDre_disableModule(Ifx_DRE *dre)
{
    /*Disable module */
    dre->CLC.B.DISR = 1U;

    /*Wait until module is disabled*/
    while (IfxDre_isModuleEnabled(dre) == TRUE)
    {}
}


void IfxDre_enableModule(Ifx_DRE *dre)
{
    /*Enable module, disregard Sleep Mode request */
    dre->CLC.B.DISR = 0U;

    /*Wait until module is enabled*/
    while (IfxDre_isModuleEnabled(dre) == FALSE)
    {}
}


void IfxDre_getEibufStatusFlags(Ifx_DRE *dre, uint8 bufferIndex, IfxDre_EthernetInputBufStatus *status)
{
    if (bufferIndex < 6)
    {
        Ifx_DRE_EIBUF *eibuf = &(dre->EIBUF[bufferIndex]);

        status->bufferPendingRequest    = eibuf->STATUS.B.BPR;
        status->ethernetFrameError      = eibuf->STATUS.B.FE;
        status->invalidFrameType        = eibuf->STATUS.B.IFT;
        status->invalidDestinationId    = eibuf->STATUS.B.IDID;
        status->avtpLengthMismatchError = eibuf->STATUS.B.LME;
        status->canFormatError          = eibuf->STATUS.B.CFE;
        status->remoteFrameError        = eibuf->STATUS.B.RFE;
        status->ethernetFrameComplete   = eibuf->STATUS.B.FC;
        status->ethernetReceiveRequest  = eibuf->STATUS.B.RXREQ;
    }
}


void IfxDre_setEibufNewEthernetFrameRequest(Ifx_DRE *dre, uint8 bufferIndex)
{
    if (bufferIndex < 6)
    {
        dre->EIBUF[bufferIndex].STATUS.B.RXREQ = 1;
    }
}


void IfxDre_clearBufferPendingRequest(Ifx_DRE *dre, uint8 bufferIndex)
{
    if (bufferIndex < 6)
    {
        dre->EIBUF[bufferIndex].STATUS.B.BPRC = 1;
    }
}


boolean IfxDre_getEibufPendingRequest(Ifx_DRE *dre, uint8 bufferIndex)
{
    return (boolean)(dre->EIBUF[bufferIndex].STATUS.B.BPR);
}


void IfxDre_initApConfig(IfxDre_ApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuConfig);

    uint8 i = 0;

    for (i = 0; i < IFXDRE_NUM_EIBUF_BUFFERS; i++)
    {
        IfxApApu_initConfig(&config->ethApuConfig[i]);
    }
}


void IfxDre_initAp(Ifx_DRE *dre, IfxDre_ApConfig *config)
{
    /* Initialize the PROTs */
    IfxApProt_init((Ifx_PROT_PROT *)&dre->PROTE, &config->proteConfig);
    IfxApProt_init((Ifx_PROT_PROT *)&dre->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&dre->PROTSE, IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&dre->ACCEN, &config->apuConfig);

    uint8 i = 0;

    for (i = 0; i < IFXDRE_NUM_EIBUF_BUFFERS; i++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&dre->ETH[i].ACCEN, &config->ethApuConfig[i]);
    }

    IfxApProt_setState((Ifx_PROT_PROT *)&dre->PROTSE, IfxApProt_State_run);
}


void IfxDre_setInterruptEnable(Ifx_DRE *dre, boolean enable, IfxDre_InterruptLine index)
{
    if (enable)
    {
        dre->IE.U = (dre->IE.U | (1 << index));
    }
    else
    {
        uint32 fixedMaskUpper16 = 0x0000FFFF; /*Only 16 lines*/
        uint32 maskvalue        = ~(1 << index);
        dre->IE.U = (dre->IE.U & (fixedMaskUpper16 & maskvalue));
    }
}


boolean IfxDre_getInterruptLineStatusFlag(Ifx_DRE *dre, IfxDre_InterruptLine index)
{
    if (dre->INTSIG.U & (1 << index))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


boolean IfxDre_getDMemWaterMarkFlag(Ifx_DRE *dre, uint8 index)
{
    return dre->DMEM[index].STATUS.B.WMF;
}


boolean IfxDre_getDMemWrapAroundFlag(Ifx_DRE *dre, uint8 index)
{
    return dre->DMEM[index].STATUS.B.WAF;
}


void IfxDre_clearDMemWaterMarkFlag(Ifx_DRE *dre, uint8 index)
{
    dre->DMEM[index].STATUS.U = 1 << IFX_DRE_DMEM_STATUS_WMF_OFF;
}


void IfxDre_clearDMemWrapAroundFlag(Ifx_DRE *dre, uint8 index)
{
    dre->DMEM[index].STATUS.U = 1 << IFX_DRE_DMEM_STATUS_WAF_OFF;
}


boolean IfxDre_get_CIBL_Status_BufferFullFlag(Ifx_DRE *dre)
{
    return dre->CIBL.STATUS.B.BF;
}


boolean IfxDre_get_COBL_Status_BufferFullFlag(Ifx_DRE *dre)
{
    return dre->COBL.STATUS.B.BF;
}


boolean IfxDre_get_EIBUF_Status_EthernetFrameErrorFlag(Ifx_DRE *dre, uint8 index)
{
    return dre->EIBUF[index].STATUS.B.FE;
}


void IfxDre_clear_EIBUF_Status_EthernetFrameErrorFlag(Ifx_DRE *dre, uint8 index)
{
    dre->EIBUF[index].STATUS.B.FE = 1;
}


boolean IfxDre_get_EOBUF_Status_TxRequestFlag(Ifx_DRE *dre, uint8 index)
{
    return dre->EOBUF[index].STATUS.B.TXREQ;
}


void IfxDre_clear_EOBUF_Status_TxRequestFlag(Ifx_DRE *dre, uint8 index)
{
    dre->EOBUF[index].STATUS.B.TXREQ = 1;
}


boolean IfxDre_get_EIBUF_Status_EthernetFrameCompleteFlag(Ifx_DRE *dre, uint8 index)
{
    return dre->EIBUF[index].STATUS.B.FC;
}


void IfxDre_clear_EIBUF_Status_EthernetFrameCompleteFlag(Ifx_DRE *dre, uint8 index)
{
    dre->EIBUF[index].STATUS.B.FC = 1;
}


void IfxDre_getAndClearInterruptLine8Status(Ifx_DRE *dre, IfxDre_Interrupt_Line8_Status *status)
{
    Ifx_DRE_CIBL_STATUS ciblStatus;
    ciblStatus.U       = dre->CIBL.STATUS.U;

    dre->CIBL.STATUS.U = 0xC0000; /* Write 1 to clear CRCE and WDTE, BF is read only and updated by H/w */

    status->CIBL_BF    = ciblStatus.B.BF;
    status->CIBL_CRCE  = ciblStatus.B.CRCE;
    status->CIBL_WDTE  = ciblStatus.B.WDTE;
}


void IfxDre_getAndClearInterruptLine9Status(Ifx_DRE *dre, IfxDre_Interrupt_Line9_Status *status)
{
    Ifx_DRE_COBL_STATUS coblStatus;
    coblStatus.U            = dre->COBL.STATUS.U;

    dre->COBL.STATUS.B.WDTE = 1; /* Write 1 to clear WDTE, BF is read only and updated by H/w */

    status->COBL_BF         = coblStatus.B.BF;
    status->COBL_WDTE       = coblStatus.B.WDTE;
}


void IfxDre_getAndClearInterruptLine10Status(Ifx_DRE *dre, IfxDre_Interrupt_Line10_Status *status)
{
    Ifx_DRE_EIBUF_STATUS lvStatus[IFXDRE_NUM_EIBUF_BUFFERS];
    Ifx_DRE_EIBUF_ERROR  error[IFXDRE_NUM_EIBUF_BUFFERS];

    uint8                i = 0;

    for (i = 0; i < IFXDRE_NUM_EIBUF_BUFFERS; i++)
    {
        lvStatus[i].U           = dre->EIBUF[i].STATUS.U;
        error[i].U              = dre->EIBUF[i].ERROR.U;

        dre->EIBUF[i].STATUS.U |= 0x6A00; /* Write 1 to clear */
        dre->EIBUF[i].ERROR.U   = 7;      /*Clear Logic: BF = 1, RDESE = 1, WDTE = 1 */
    }

    status->EIBUF0_CFE     = lvStatus[0].B.CFE;
    status->EIBUF0_RFE     = lvStatus[0].B.RFE;
    status->EIBUF0_FE      = lvStatus[0].B.FE;
    status->EIBUF0_IDID    = lvStatus[0].B.IDID;
    status->EIBUF0_WDTE    = error[0].B.WDTE;
    status->EIBUF0_RDESE   = error[0].B.RDESE;
    status->EIBUF0_BF      = error[0].B.BF;
    status->EIBUF0_DERRTYP = error[0].B.DERRTYP;

    status->EIBUF1_CFE     = lvStatus[1].B.CFE;
    status->EIBUF1_RFE     = lvStatus[1].B.RFE;
    status->EIBUF1_FE      = lvStatus[1].B.FE;
    status->EIBUF1_IDID    = lvStatus[1].B.IDID;
    status->EIBUF1_WDTE    = error[1].B.WDTE;
    status->EIBUF1_RDESE   = error[1].B.RDESE;
    status->EIBUF1_BF      = error[1].B.BF;
    status->EIBUF1_DERRTYP = error[1].B.DERRTYP;

    status->EIBUF2_CFE     = lvStatus[2].B.CFE;
    status->EIBUF2_RFE     = lvStatus[2].B.RFE;
    status->EIBUF2_FE      = lvStatus[2].B.FE;
    status->EIBUF2_IDID    = lvStatus[2].B.IDID;
    status->EIBUF2_WDTE    = error[2].B.WDTE;
    status->EIBUF2_RDESE   = error[2].B.RDESE;
    status->EIBUF2_BF      = error[2].B.BF;
    status->EIBUF2_DERRTYP = error[2].B.DERRTYP;

    status->EIBUF3_CFE     = lvStatus[3].B.CFE;
    status->EIBUF3_RFE     = lvStatus[3].B.RFE;
    status->EIBUF3_FE      = lvStatus[3].B.FE;
    status->EIBUF3_IDID    = lvStatus[3].B.IDID;
    status->EIBUF3_WDTE    = error[3].B.WDTE;
    status->EIBUF3_RDESE   = error[3].B.RDESE;
    status->EIBUF3_BF      = error[3].B.BF;
    status->EIBUF3_DERRTYP = error[3].B.DERRTYP;

    status->EIBUF4_CFE     = lvStatus[4].B.CFE;
    status->EIBUF4_RFE     = lvStatus[4].B.RFE;
    status->EIBUF4_FE      = lvStatus[4].B.FE;
    status->EIBUF4_IDID    = lvStatus[4].B.IDID;
    status->EIBUF4_WDTE    = error[4].B.WDTE;
    status->EIBUF4_RDESE   = error[4].B.RDESE;
    status->EIBUF4_BF      = error[4].B.BF;
    status->EIBUF4_DERRTYP = error[4].B.DERRTYP;

    status->EIBUF5_CFE     = lvStatus[5].B.CFE;
    status->EIBUF5_RFE     = lvStatus[5].B.RFE;
    status->EIBUF5_FE      = lvStatus[5].B.FE;
    status->EIBUF5_IDID    = lvStatus[5].B.IDID;
    status->EIBUF5_WDTE    = error[5].B.WDTE;
    status->EIBUF5_RDESE   = error[5].B.RDESE;
    status->EIBUF5_BF      = error[5].B.BF;
    status->EIBUF5_DERRTYP = error[5].B.DERRTYP;
}


void IfxDre_getAndClearInterruptLine11Status(Ifx_DRE *dre, IfxDre_Interrupt_Line11_Status *status)
{
    status->EIBUF0_RXREQ    = dre->EIBUF[0].STATUS.B.RXREQ;
    status->EIBUF1_RXREQ    = dre->EIBUF[1].STATUS.B.RXREQ;
    status->EIBUF2_RXREQ    = dre->EIBUF[2].STATUS.B.RXREQ;
    status->EIBUF3_RXREQ    = dre->EIBUF[3].STATUS.B.RXREQ;
    status->EIBUF4_RXREQ    = dre->EIBUF[4].STATUS.B.RXREQ;
    status->EIBUF5_RXREQ    = dre->EIBUF[5].STATUS.B.RXREQ;

    dre->EIBUF[0].STATUS.U |= 0x2000;
    dre->EIBUF[1].STATUS.U |= 0x2000;
    dre->EIBUF[2].STATUS.U |= 0x2000;
    dre->EIBUF[3].STATUS.U |= 0x2000;
    dre->EIBUF[4].STATUS.U |= 0x2000;
    dre->EIBUF[5].STATUS.U |= 0x2000;
}


void IfxDre_getAndClearInterruptLine12Status(Ifx_DRE *dre, IfxDre_Interrupt_Line12_Status *status)
{
    Ifx_DRE_RS lRoutingStatus;
    lRoutingStatus.U = dre->RS.U;

    status->RS_IRT   = lRoutingStatus.B.IRT;
    status->RS_NMFE  = lRoutingStatus.B.NMFE;

    /*Write 1 to clear bits*/
    dre->RS.U |= 0x00030000;
}


void IfxDre_getAndClearInterruptLine13Status(Ifx_DRE *dre, IfxDre_Interrupt_Line13_Status *status)
{
    Ifx_DRE_ME_ERR lMoveEngineErrorStatus;
    lMoveEngineErrorStatus.U = dre->ME.ERR.U;

    status->SPBBE            = lMoveEngineErrorStatus.B.SPBBE;
    status->SRIBE            = lMoveEngineErrorStatus.B.SRIBE;
    status->DBOE             = lMoveEngineErrorStatus.B.DBOE;
    status->IRDE             = lMoveEngineErrorStatus.B.IRDE;

    status->FEC              = lMoveEngineErrorStatus.B.FEC;
    status->FESID            = lMoveEngineErrorStatus.B.FESID;
    status->FEDID            = lMoveEngineErrorStatus.B.FEDID;
    status->FEDIR            = lMoveEngineErrorStatus.B.FEDIR;

    /*Write 1 to clear bits*/
    dre->ME.ERR.U = 0x0000001E;
}


void IfxDre_getAndClearInterruptLine14Status(Ifx_DRE *dre, IfxDre_Interrupt_Line14_Status *status)
{
    Ifx_DRE_EOBUF_STATUS lvStatus[IFXDRE_NUM_EIBUF_BUFFERS];
    Ifx_DRE_EOBUF_ERROR  error[IFXDRE_NUM_EIBUF_BUFFERS];

    uint8                i = 0;

    for (i = 0; i < IFXDRE_NUM_EOBUF_BUFFERS; i++)
    {
        lvStatus[i].U = dre->EOBUF[i].STATUS.U;
        error[i].U    = dre->EOBUF[i].ERROR.U;

        /* Write 1 to clear */
        //dre->EOBUF[i].STATUS.B.BF = 1; //No longer writable by S/w. Application to clear using TXREQ = 1. This is also part of IfxDre_getAndClearInterruptLine15Status.
        dre->EOBUF[i].ERROR.U = 3;
    }

    status->EOBUF0_BF      = lvStatus[0].B.BF;
    status->EOBUF0_WDTE    = error[0].B.WDTE;
    status->EOBUF0_TDESE   = error[0].B.TDESE;
    status->EOBUF0_DERRTYP = error[0].B.DERRTYP;

    status->EOBUF1_BF      = lvStatus[1].B.BF;
    status->EOBUF1_WDTE    = error[1].B.WDTE;
    status->EOBUF1_TDESE   = error[1].B.TDESE;
    status->EOBUF1_DERRTYP = error[1].B.DERRTYP;

    status->EOBUF2_BF      = lvStatus[2].B.BF;
    status->EOBUF2_WDTE    = error[2].B.WDTE;
    status->EOBUF2_TDESE   = error[2].B.TDESE;
    status->EOBUF2_DERRTYP = error[2].B.DERRTYP;

    status->EOBUF3_BF      = lvStatus[3].B.BF;
    status->EOBUF3_WDTE    = error[3].B.WDTE;
    status->EOBUF3_TDESE   = error[3].B.TDESE;
    status->EOBUF3_DERRTYP = error[3].B.DERRTYP;

    status->EOBUF4_BF      = lvStatus[4].B.BF;
    status->EOBUF4_WDTE    = error[4].B.WDTE;
    status->EOBUF4_TDESE   = error[4].B.TDESE;
    status->EOBUF4_DERRTYP = error[4].B.DERRTYP;

    status->EOBUF5_BF      = lvStatus[5].B.BF;
    status->EOBUF5_WDTE    = error[5].B.WDTE;
    status->EOBUF5_TDESE   = error[5].B.TDESE;
    status->EOBUF5_DERRTYP = error[5].B.DERRTYP;
}


void IfxDre_getAndClearInterruptLine15Status(Ifx_DRE *dre, IfxDre_Interrupt_Line15_Status *status)
{
    status->EOBUF0_TXREQ         = dre->EOBUF[0].STATUS.B.TXREQ;
    status->EOBUF1_TXREQ         = dre->EOBUF[1].STATUS.B.TXREQ;
    status->EOBUF2_TXREQ         = dre->EOBUF[2].STATUS.B.TXREQ;
    status->EOBUF3_TXREQ         = dre->EOBUF[3].STATUS.B.TXREQ;
    status->EOBUF4_TXREQ         = dre->EOBUF[4].STATUS.B.TXREQ;
    status->EOBUF5_TXREQ         = dre->EOBUF[5].STATUS.B.TXREQ;

    dre->EOBUF[0].STATUS.B.TXREQ = 1;
    dre->EOBUF[1].STATUS.B.TXREQ = 1;
    dre->EOBUF[2].STATUS.B.TXREQ = 1;
    dre->EOBUF[3].STATUS.B.TXREQ = 1;
    dre->EOBUF[4].STATUS.B.TXREQ = 1;
    dre->EOBUF[5].STATUS.B.TXREQ = 1;
}


volatile Ifx_SRC_SRCR *IfxDre_getSrcAddress(IfxDre_InterruptLine index)
{
    return (volatile Ifx_SRC_SRCR *)(&MODULE_SRC.DRE[index]);
}


void IfxDre_resetEthTxCount(Ifx_DRE *dre)
{
    dre->EDLSTAT.B.TXCNT = 1;  /*Write of non-zero to clear bit*/
}


void IfxDre_resetEthRxCount(Ifx_DRE *dre)
{
    dre->EDLSTAT.B.RXCNT = 1;  /*Write of non-zero to clear bit*/
}


void IfxDre_getEthDescListStatus(Ifx_DRE *dre, IfxDre_EdlStatus *status)
{
    Ifx_DRE_EDLSTAT edlStatus;
    edlStatus.U     = dre->EDLSTAT.U;

    status->rxCount = edlStatus.B.RXCNT;
    status->txCount = edlStatus.B.TXCNT;
}


void IfxDre_clearEthTxSummary(Ifx_DRE *dre, uint8 value)
{
    dre->EREQ.U = (uint32)value;   /*Write of non-zero to clear bit*/
}


void IfxDre_clearEthFwdSummary(Ifx_DRE *dre, uint8 value)
{
    dre->EREQ.U = (uint32)value << 16;  /*Write of non-zero to clear bit*/
}


void IfxDre_getEthReqSummary(Ifx_DRE *dre, IfxDre_ErsStatus *status)
{
    Ifx_DRE_EREQ ereqStatus;
    ereqStatus.U                = dre->EREQ.U;

    status->tx0                 = ereqStatus.B.TX0_REQ;
    status->tx1                 = ereqStatus.B.TX1_REQ;
    status->tx2                 = ereqStatus.B.TX2_REQ;
    status->tx3                 = ereqStatus.B.TX3_REQ;
    status->tx4                 = ereqStatus.B.TX4_REQ;
    status->tx5                 = ereqStatus.B.TX5_REQ;

    status->fwd0                = ereqStatus.B.FWD0_REQ;
    status->fwd1                = ereqStatus.B.FWD1_REQ;
    status->fwd2                = ereqStatus.B.FWD2_REQ;
    status->fwd3                = ereqStatus.B.FWD3_REQ;
    status->fwd4                = ereqStatus.B.FWD4_REQ;
    status->fwd5                = ereqStatus.B.FWD5_REQ;

    status->currentBufferIndex0 = ereqStatus.B.CBI0;
    status->currentBufferIndex1 = ereqStatus.B.CBI1;
    status->currentBufferIndex2 = ereqStatus.B.CBI2;
    status->currentBufferIndex3 = ereqStatus.B.CBI3;
    status->currentBufferIndex4 = ereqStatus.B.CBI4;
    status->currentBufferIndex5 = ereqStatus.B.CBI5;
}


void IfxDre_configureAccessToDre(IfxApApu_ApuConfig *apConfig)
{
    /* Loop through all the Resource Partitions */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_DRE.ACCEN, apConfig);
}
