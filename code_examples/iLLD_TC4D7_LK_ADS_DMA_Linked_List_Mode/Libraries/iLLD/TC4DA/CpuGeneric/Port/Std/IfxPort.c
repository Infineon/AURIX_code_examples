/**
 * \file IfxPort.c
 * \brief PORT  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxPort.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxPort_disableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
            {
                IfxPort_resetESR(port, pinIndex);
                result = TRUE;
            }

            break;
        }
    }

    return result;
}


boolean IfxPort_enableEmergencyStop(Ifx_P *port, uint8 pinIndex)
{
    sint32  portIndex;
    boolean result = FALSE;

    for (portIndex = 0; portIndex < IFXPORT_NUM_MODULES; portIndex++)
    {
        if (port == IfxPort_cfg_esrMasks[portIndex].port)
        {
            if ((1U << pinIndex) & IfxPort_cfg_esrMasks[portIndex].masks)
            {
                IfxPort_setESR(port, pinIndex);
                result = TRUE;
            }
        }
    }

    return result;
}


Ifx_P *IfxPort_getAddress(IfxPort_Index port)
{
    Ifx_P *module = NULL_PTR;
    uint8  i      = 0;

    while ((i < IFXPORT_NUM_MODULES) && (module == NULL_PTR))
    {
        if (IfxPort_cfg_indexMap[i].index == port)
        {
            module = IfxPort_cfg_indexMap[i].module;
        }

        i++;
    }

    return module;
}


IfxPort_Index IfxPort_getIndex(Ifx_P *port)
{
    uint32        index;
    IfxPort_Index result;

    result = IfxPort_Index_none;

    for (index = 0; index < IFXPORT_NUM_MODULES; index++)
    {
        if (IfxPort_cfg_indexMap[index].module == port)
        {
            result = (IfxPort_Index)IfxPort_cfg_indexMap[index].index;
            break;
        }
    }

    return result;
}


void IfxPort_resetESR(Ifx_P *port, uint8 pinIndex)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif
    Ifx__ldmst(&(port->PADCFG[pinIndex].SAFSEC.U), (IFX_P_PADCFG_SAFSEC_ESR_EN_MSK << IFX_P_PADCFG_SAFSEC_ESR_EN_OFF), 0U);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_setESR(Ifx_P *port, uint8 pinIndex)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif
    Ifx__ldmst(&(port->PADCFG[pinIndex].SAFSEC.U), (IFX_P_PADCFG_SAFSEC_ESR_EN_MSK << IFX_P_PADCFG_SAFSEC_ESR_EN_OFF), 1U << IFX_P_PADCFG_SAFSEC_ESR_EN_OFF);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_setGroupModeInput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_InputMode mode)
{
    uint16 tempMask = mask;
    uint8  pin      = pinIndex;

    while (tempMask != 0U)
    {
        if ((tempMask & 1U) == TRUE)
        {
            IfxPort_setPinMode(port, pin, (IfxPort_Mode)mode);
        }

        ++pin;
        tempMask >>= 1;
    }
}


void IfxPort_setGroupModeOutput(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_OutputMode mode, IfxPort_OutputIdx index)
{
    uint16 tempMask = mask;
    uint8  pin      = pinIndex;

    while (tempMask != 0U)
    {
        if ((tempMask & 1U) == TRUE)
        {
            IfxPort_setPinMode(port, pin, (IfxPort_Mode)(mode | index));
        }

        ++pin;
        tempMask >>= 1;
    }
}


void IfxPort_setGroupPadDriver(Ifx_P *port, uint8 pinIndex, uint16 mask, IfxPort_PadDriver padDriver)
{
    uint16 tempMask = mask;
    uint8  pin      = pinIndex;

    while (tempMask != 0U)
    {
        if ((tempMask & 1U) == 1)
        {
            IfxPort_setPinPadDriver(port, pin, padDriver);
        }

        ++pin;
        tempMask >>= 1;
    }
}


void IfxPort_setPinMode(Ifx_P *port, uint8 pinIndex, IfxPort_Mode mode)
{
    /* For A2G, P40( and P41 for some derivatives) pins have both analog and digital drivers. Through PDISC we select digital functionality below
     * FIXME: P40 and P41 have to be replaced by appropriate ports for A3G
     */
    uint32 mask = ((IFX_P_PADCFG_DRVCFG_MODE_MSK << IFX_P_PADCFG_DRVCFG_MODE_OFF) | (IFX_P_PADCFG_DRVCFG_OD_MSK << IFX_P_PADCFG_DRVCFG_OD_OFF) | (IFX_P_PADCFG_DRVCFG_DIR_MSK << IFX_P_PADCFG_DRVCFG_DIR_OFF));
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif

    if (port == &MODULE_P40)
    {
        port->PDISC.U &= ~(1 << pinIndex);
    }

    Ifx__ldmst(&(port->PADCFG[pinIndex].DRVCFG.U), mask, mode);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_setPinModeLVDS(Ifx_P *port, uint8 pinIndex, IfxPort_Mode pinMode, IfxPort_LvdsConfig *lvds)
{
    uint32               lpcrOffset = (pinIndex / 2);

    volatile Ifx_P_LPCR *lpcr       = &(port->LPCR[0]);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif
    lpcr[lpcrOffset].LPCR.B.LVDSM = lvds->lvdsMode;
    lpcr[lpcrOffset].LPCR.B.PS    = lvds->padSupply;

    if (pinMode < IfxPort_Mode_outputPushPullGeneral)
    {
        lpcr[lpcrOffset].LPCR.B.REN_CTRL = lvds->enablePortControlled;
        lpcr[lpcrOffset].LPCR.B.RX_EN    = 1;
        lpcr[lpcrOffset].LPCR.B.TERM     = lvds->lvdsTerm;
    }
    else
    {
        lpcr[lpcrOffset].LPCR.B.TEN_CTRL = lvds->enablePortControlled;
        lpcr[lpcrOffset].LPCR.B.TX_EN    = 1;
        lpcr[lpcrOffset].LPCR.B.TX_PD    = 0;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_setPinPadDriver(Ifx_P *port, uint8 pinIndex, IfxPort_PadDriver padDriver)
{
    uint32 mask = ((IFX_P_PADCFG_DRVCFG_PD_MSK << IFX_P_PADCFG_DRVCFG_PD_OFF) | (IFX_P_PADCFG_DRVCFG_PL_MSK << IFX_P_PADCFG_DRVCFG_PL_OFF));

    /*
     *
     * Note on the forming the variable value:
     *
     * padDriver consists of 4 bit value where:
     *
     *  padDriver[2:0] is PD
     *  padDriver[5:3] is PL
     *
     * The SFR structure is as follows:
     *
     * DRVCFG[10:8] PD
     * DRVCFG[11:11] Reserved
     * DRVCFG[14:12] PL
     *
     * Due to the gap of 1 bit in between, the below bit manipulation circus is being done.
     *
     */
    uint32 value = ((((padDriver & 0x38U) << 1U) | (padDriver & 0x7U)) << IFX_P_PADCFG_DRVCFG_PD_OFF);

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif
    Ifx__ldmst(&(port->PADCFG[pinIndex].DRVCFG.U), mask, value);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_setPinControllerSelection(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_modifyPinControllerSelection(port, pinIndex, TRUE);
}


void IfxPort_resetPinControllerSelection(Ifx_P *port, uint8 pinIndex)
{
    IfxPort_modifyPinControllerSelection(port, pinIndex, FALSE);
}


void IfxPort_modifyPinControllerSelection(Ifx_P *port, uint8 pinIndex, boolean mode)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif
    /* FIXME: Discuss having an global variable csrMask like esrMask. But then that would lead to extra memory consumption for a configuration which shall not very frequently in application. It would be a one time setting of who controls the pin(SCR/GETH/EVADC or Tricore) */

    Ifx__ldmst(&(port->PCSRSEL.U), 1U << pinIndex, mode << pinIndex);

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_initApuConfig(IfxPort_ApuConfig *config)
{
    IfxApApu_initConfig(&config->apuConfig);
    config->grpNum = 0U;
}


void IfxPort_initApu(Ifx_P *port, IfxPort_ApuConfig *config)
{
    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&port->ACCGRP[config->grpNum], &config->apuConfig);
    IfxApProt_setState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
}


void IfxPort_initApuGroups(Ifx_P *port, IfxPort_ApuGroupConfig *config)
{
    uint8 i = 0U;

    for (i = 0; i < IFXPORT_NUM_PINS; i++)
    {
        IfxPort_setApuGroupSelection(port, config->pinConfig[i].pinIndex, config->pinConfig[i].grpNum);
    }

    for (i = 0; i < IFXPORT_NUM_APU; i++)
    {
        IfxApProt_setState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&port->ACCGRP[config->pinConfig[i].grpNum], &config->apuConfig[i]);
        IfxApProt_setState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
    }
}


void IfxPort_configureESR(Ifx_P *port, uint8 pinIndex, IfxPort_EsrLevel esrLevel, IfxPort_EsrPadCfg esrPadCfg)
{
    uint32 value = 0U;
    uint32 mask  = 0U;

    value = ((esrLevel << IFX_P_PADCFG_SAFSEC_ESR_PPL_OFF) | (esrPadCfg << IFX_P_PADCFG_SAFSEC_ESR_PD_OFF));

    mask  = ((IFX_P_PADCFG_SAFSEC_ESR_PPL_MSK << IFX_P_PADCFG_SAFSEC_ESR_PPL_OFF) | (IFX_P_PADCFG_SAFSEC_ESR_PD_MSK << IFX_P_PADCFG_SAFSEC_ESR_PD_OFF));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif
    Ifx__ldmst(&(port->PADCFG[pinIndex].SAFSEC.U), mask, value);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_configureAccessToPorts(IfxApApu_ApuConfig *apConfig)
{
    /* By default the access protection group selected is 0 (PADCFG.ACCEN.B.GRP= 0) for all ports*/
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P00.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P01.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P02.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P03.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P10.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P13.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P14.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P15.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P16.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P20.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P21.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P22.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P23.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P25.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P30.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P31.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P32.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P33.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P34.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_P40.ACCGRP[0], apConfig);  /*Configure the APU group 0 */
}


void IfxPort_resetModule(Ifx_P *port)
{
    volatile Ifx_P_RST *rst = &(port->RST);

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif

    rst->CTRLA.B.KRST = 1;        /* Only if both Kernel reset bits are set a reset is executed */
    rst->CTRLB.B.KRST = 1;

    while (0 == rst->STAT.B.KRST) /* Wait until reset is executed */
    {}

    rst->CTRLB.B.STATCLR = 1;     /* Clear Kernel reset status bit */

    while (rst->STAT.B.KRST == 1) /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_setPinModex(Ifx_P *port, uint8 pinIndex, IfxPort_Modex modex)
{
    uint32 mask = (IFX_P_PADCFG_DRVCFG_MODEX_MSK << IFX_P_PADCFG_DRVCFG_MODEX_OFF);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_config);
#endif

    Ifx__ldmst(&(port->PADCFG[pinIndex].DRVCFG.U), mask, modex);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_transitionState((Ifx_PROT_PROT *)&port->PROTSE, IfxApProt_State_run);
#endif
}


void IfxPort_configureAccessToPort(Ifx_P *port, IfxPort_PadAccessGroup group, void *apConfig)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&port->ACCGRP[group], apConfig);  /*Configure the APU group */
}
