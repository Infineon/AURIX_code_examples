/**********************************************************************************************************************
 * \file Slk_AA_Global.h
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#ifndef SAFETYLITEKIT_ANALOG_ACQUISITION_SLK_AA_GLOBAL_H_
#define SAFETYLITEKIT_ANALOG_ACQUISITION_SLK_AA_GLOBAL_H_

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Slk_Cfg.h"
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxConvctrl.h"
#include "IfxEvadc_Adc.h"
#include "IfxEdsadc_Edsadc.h"
#include "IfxSmu_cfg.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* General macros for EVADC */
#define IFXEVADC_QUEUE_REFILL_DISABLED  (0 << 5u)

/* Target frequency macros for EVADC, EDSADC and CONVTRL module */
#define EVADC_20MHZ_FREQ    (20.0e6) /* Analog frequency in Hz */
#define EDSADC_20MHZ_FREQ   (20.0e6) /* Modulator frequency in Hz */
#define CONVTRL_20MHZ_FREQ  IfxConvctrl_PhaseSynchronizerDivider_8 /* Divider of 8 as fPER is 160Mhz */

/* Macro to determine voltage measured by 12-bit EVADC */
#define ANALOG_FULL_SCALE     3.3                  /* Analog full-scale voltage i.e. VAREF = 3.3                           */
#define RAW_FULL_SCALE_EVADC  4095.0 /* EDSADC full-scale value(AFS), representing the analog full-scale(V_IN=V_AREF=3.3V) */
#define EVADC_RESULT_TO_V(convRes)      ((float32)(ANALOG_FULL_SCALE * convRes) / 4095.0)
/* Macros for the offset calibration */
#define CALIBRATION_SAMPLE_AMOUNT       100

#define RAW_FULL_SCALE        30000.0 /* EDSADC full-scale value(AFS), representing the analog full-scale(V_IN=V_AREF=3.3V) */
#define EDSADC_RESULT_TO_V(convRes)     ((float32) (convRes * ANALOG_FULL_SCALE) / RAW_FULL_SCALE )
/* Macros for VAREF verification */
#define VAREF_TOLERANCE         0.3     /* 10% */
#define VAREF_EXPECTED_RESULT   3.3    /* V V_UC = 3.3V */

#define MAX_DIFF            0.3                     /* Plausibility check max difference in V */
#define UPPER_LIMIT         3.3                       /* Plausibility check upper limit in V */
#define LOWER_LIMIT         0                       /* Plausibility check lower limit in V */

#define VOLT_TO_10BIT_ADC(voltage) (uint32)((float32)voltage * (float32)(4095/ANALOG_FULL_SCALE))

/* Macros for the FUCs */
/* FUC0: */
#define EVADC_GROUPS_NUM_AA_FUC0      3  /* Number of used EVADC groups  used for Analog Acquisition FUC0 */
#define EVADC_CHANNELS_NUM_AA_FUC0    3  /* Number of used EVADC channels used for Analog Acquisition FUC0 */
/* FUC1 */
#define EDSADC_CHANNELS_NUM_AA_FUC1   3
/* FUC2: */
#define EVADC_GROUPS_NUM_AA_FUC2      2  /* Number of used EVADC groups used for Analog Acquisition FUC2 */
#define EVADC_CHANNELS_NUM_AA_FUC2    2  /* Number of used EVADC channels used for Analog Acquisition FUC2 */
#define EDSADC_CHANNELS_NUM_AA_FUC2   2  /* Number of used EDSADC channels used for Analog Acquisition FUC2 */
/* FUC3: */
#define EVADC_GROUPS_NUM_AA_FUC3      3  /* Number of used EVADC groups used for Analog Acquisition  FUC3 */
#define EVADC_CHANNELS_NUM_AA_FUC3    3  /* Number of used EVADC channels used for Analog Acquisition FUC3 */
/* FUC4: */
#define EVADC_GROUPS_NUM_AA_FUC4      2  /* Number of used EVADC groups used for Analog Acquisition FUC4 */
#define EVADC_CHANNELS_NUM_AA_FUC4    2  /* Number of used EVADC channels used for Analog Acquisition FUC4 */
#define EDSADC_CHANNELS_NUM_AA_FUC4   2  /* Number of used EDSADC channels used for Analog Acquisition FUC4 */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
/* Structure for the EVADC channel configuration */
typedef struct
{
    IfxEvadc_Vadcg_In *analogInput;   /* Ptr to the analog input pin structure which is defined in IfxEvadc_PinMap.c */
    IfxEvadc_Adc_Group *groupHandle;        /* Pointer to the group configuration handle of the specific adc channel */
    IfxEvadc_ChannelResult resultRegister; /* Ch Result in MODULE_EVADC.G[x].CHCTR[y].B. RESREG(x=0,.,11;y=0,.,16)   */
    IfxEvadc_InputClasses  inputClass;     /* inputClass in MODULE_EVADC.G[x].CHCTR[y].B.ICLSEL(x=0,..,11;y=0,1..16) */
    IfxEvadc_RequestSource queueRequestSourceId; /* For EVADC in Queue mode three queues can be selected */
    boolean  initISR;                            /* TRUE if an ISR should be enabled and configured for this channel */
    IfxEvadc_SrcNr resultSrcNr;    /* Service Node in MODULE_EVADC.G[x].SRACT.U(x= 0,.,11)"not used if initISR=FALSE"*/
    IfxSrc_Tos resultServProvider; /* Identifier of ISR,  which handles the interrupt service request */
    Ifx_Priority resultPriority;   /* Interrupt service priority */
} SlkEvadcChannelCfgType;

/* Structure for EVADC configuration */
typedef struct
{
    uint8                      amountOfGroups;        /* Amount of different EVADC groups used for the application   */
    uint8                      amountOfChannels;      /* Amount of different EVADC channels used for the application */
    IfxEvadc_Adc               evadc;                  /* EVADC module handle variable */
    IfxEvadc_Adc_Group         *evadcGroup;            /* Pointer to global array for configuring the EVADC groups   */
    IfxEvadc_Adc_Channel       *evadcChannel;          /* Pointer to global array for configuring the EVADC channels */
    SlkEvadcChannelCfgType     *evadcChannelConfig;    /* Pointer to the EVADC channel configuration structure */
} SlkEvadcCfgType;

/* Structure for the EDSADC channel configuration */
typedef struct
{
    IfxEdsadc_Dsp_In            *posInput;        /* Pointer to EDSADC positive pin mapping structure */
    IfxEdsadc_Dsn_In            *negInput;        /* Pointer to EDSADC negative pin mapping structure */
} SlkEdsadcChannelCfgType;

/* Structure for EDSADC configuration */
typedef struct
{
    uint8                         amountOfChannels;/* Amount of different EDSADC channels used for the application */
    IfxEdsadc_Edsadc              edsadc;          /* EDSADC module handle variable */
    IfxEdsadc_Edsadc_Channel      *edsadcChannel;  /* Pointer to global array for configuring the EDSADC channels*/
    SlkEdsadcChannelCfgType *edsadcChannelConfig; /* Pointer to EDSADC channel configuration structure */
} SlkEdsadcCfgType;

 /* Structure for the status data type of Analog Acquisition */
typedef struct
{
    sint32  evadcConversionResult[EVADC_CHANNELS_NUM_AA_FUC0]; /* Var to store the result of the ADC conversions */
    float32 evadcVoltageResults[EVADC_CHANNELS_NUM_AA_FUC0];   /* Variable to store the calculated voltages [V]  */
    float32 evadcInput1Calibration; /* Used to store the static error between ADC */
    float32 evadcInput2Calibration; /* Used to store the static error between ADC */

    boolean evadcInput1MeasDoneFlag;       /* Flag to signal that a EVADC input1 measurement is done */
    boolean evadcInput2MeasDoneFlag;       /* Flag to signal that a EVADC input2 measurement is done */
    boolean evadcSig1DoneFlag;     /* Flag to signal that a EVADC signal 1 measurement is done */
    boolean evadcSig2DoneFlag;     /* Flag to signal that a EVADC signal 2 measurement is done */
    boolean evadcBrokenWireMeasDoneFlag;/* Flag to signal that a EVADC broken wire measurement is done */

    sint32  edsadcConversionResult[EDSADC_CHANNELS_NUM_AA_FUC1]; /* Var to store the result of ADC conversions */
    float32 edsadcVoltageResults[EDSADC_CHANNELS_NUM_AA_FUC1]; /* Variable to store the calculated voltages [V] */
    float32 edsadcInput1Calibration;/* Used to store the static error between ADC [V] */
    float32 edsadcInput2Calibration;/* Used to store the static error between ADC [V] */

    uint8   initCnt;
} AnalogAcquisitionStatusDatatype;

typedef enum
{
    noAnalogAcquisitionMode = 0,
    initAAcqFuc0Mode,
    initAAcqFuc1Mode,
    initAAcqFuc2Mode,
    initAAcqFuc3Mode,
    initAAcqFuc4BrokenWRMode
} SlkAnalogAcquisitionMode;

typedef enum
{
    noAAcqFuc0Mode = 0,
    runAAcqFuc0Mode,
    runAAcqFuc1Mode,
    runAAcqFuc2Mode,
    runAAcqFuc3Mode,
    runAAcqFuc4BrokenWRMode
} SlkAnalogAcquisitionRunFlag;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initCONVCTRL(void);                                     /* Function to initialize and verify the CONVCTRL */
void initEVADCModule(SlkEvadcCfgType *evadcCfg);             /* Function to initialize the EVADC module        */
void initEVADCGroups(SlkEvadcCfgType *evadcCfg, uint8 varefGrId);  /* Function to initialize the EVADC group   */
void initEVADCChannels(SlkEvadcCfgType *evadcCfg);           /* Function to initialize the EVADC channels      */
sint32 getEvadcChannelResult(IfxEvadc_Adc_Channel *channel);

boolean plausibilityCheck (float32 missionChannel, float32 monitorChannel, float32 maximumDifference,
        float32 upperLimit, float32 lowerLimit, IfxSmu_Alarm smuSoftwareAlarm);
float32 evadcVarefPlausibilityCheck (SlkEvadcCfgType *evadcCfg, const uint8 varefChId,
        const IfxEvadc_RequestSource sourceType);
void getCalibrationOffset(float32 *accumulationResult, const uint16 amountOfSamples, float32 *calibrationResult);

void initEDSADCModule(SlkEdsadcCfgType *edsadcCfg);
void initEDSADCChannels(SlkEdsadcCfgType *edsadcCfg);
float32 edsadcVarefPlausibilityCheck (SlkEdsadcCfgType *edsadcCfg, const uint8 varefChId,
        const float32 varefExpectedResult, const float32 varefTolerance);
void resetAnalogAcqStatus(void);
void initEVADCBrokenWireDetection (IfxEvadc_Vadcg_In *evadcInput, const uint32 lowerBoundary,
        const uint32 upperBoundary, const IfxEvadc_SrcNr channelSrcNr, const IfxCpu_ResourceCpu tosCpuId,
        const Ifx_Priority priority);

#endif /* SAFETYLITEKIT_ANALOG_ACQUISITION_SLK_AA_GLOBAL_H_ */
