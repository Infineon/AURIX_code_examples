/**********************************************************************************************************************
 * \file Slk_AA_Global.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Analog_Acquisition/Slk_AA_Global.h"
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxConvctrl.h"
#include "IfxEvadc_Adc.h"
#include "IfxEdsadc_Edsadc.h"
#include "math.h"
#include "IfxDts_Dts.h"
#include "IfxSrc.h"
#include "IfxStm.h"
#include "IfxCpu_Irq.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* UCB segment with EVADC Vddk records */
#define UCB_BASE_ADDRES             0xAF400000u
#define UCB_G0_OFFSET               0x0A20u
#define UCB_G0_VDDK_RECORD          (*(volatile uint32*)( UCB_BASE_ADDRES + UCB_G0_OFFSET ) )

/* General macros for EDSADC */
#define DECIMATION_FACTOR   32                      /* Configure the CIC decimation factor (N)                      */
#define START_VALUE         32                      /* Configure start value of the decimation counter              */
#define CICSHIFT            15                      /* CIC shift calculated using the selected decimation factor    */
#define GAINFACTOR          5399                    /* Gain factor calculated using the CIC shift                   */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
AnalogAcquisitionStatusDatatype g_analogAcquisitionStatus;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void verifyG0Vddk(float32 vddkResult);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void initCONVCTRL(void)
{
    /* Only initialize CONVCTRL if it is not yet enabled */
    if(MODULE_CONVCTRL.CLC.B.DISS == 0)
    {
        return;
    }
    /*---------------------------------------------------------------------------------------------*/
    /*                       Part 1: Initialize CONVCTRL module                                    */
    /*---------------------------------------------------------------------------------------------*/
    /* Analog frequency of EVADC module is configured to the default value of 20MHz (IFXEVADC_DEFAULT_ANALOG_FREQ)
     * Therefore the CONVCTRL Synchronizer frequency is also configured to 20MHz -> Synchronizer frequency =
     * 160 MHz / IfxConvctrl_PhaseSynchronizerDivider_8 = 20 MHz
     * Refer to User Manual section 31.3.2 and 31.3.3 */
    IfxConvctrl_initializeModule(&MODULE_CONVCTRL, CONVTRL_20MHZ_FREQ);

    /*---------------------------------------------------------------------------------------------*/
    /*                       Part 2: Execute configuration check SM:CONVCTRL:CONFIG_CHECK          */
    /*---------------------------------------------------------------------------------------------*/
    Ifx_CONVERTER_PHSCFG expectedPHSCFG;
    expectedPHSCFG.B.PHSDIV = CONVTRL_20MHZ_FREQ;
    if(MODULE_CONVCTRL.PHSCFG.U != expectedPHSCFG.U)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_ADC);
    }
    /*---------------------------------------------------------------------------------------------*/
    /*              Part 3: Down counter fault injection (SM:CONVCTRL:ALARM_CHECK)            */
    /*---------------------------------------------------------------------------------------------*/
    IfxConvctrl_enableConfigurationAccess(&MODULE_CONVCTRL);

    /* Inject fault in the Down Counter */
    IfxConvctrl_injectCounterFault(&MODULE_CONVCTRL);
    uint16 timeout = 0xFFFF;
    boolean errorDetected = FALSE;
    boolean alarmIsRaised = FALSE;
    do
    {
        /* Wait for alarm flag to be set */
        errorDetected = IfxConvctrl_isErrorDetected(&MODULE_CONVCTRL);
        /* Wait for IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError alarm (ALM11[12]) */
        alarmIsRaised = IfxSmu_getAlarmStatus(IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError);
    } while(timeout-- && (!errorDetected || !alarmIsRaised));

    if(alarmIsRaised && errorDetected)
    {
        IfxConvctrl_clearAlarmFlag(&MODULE_CONVCTRL);
        /* Clear IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError alarm (ALM11[12]) */
        IfxSmu_clearAlarmStatus(IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError);

        /* Wait for alarmCounter to be incremented in ISR afterwards it will get decremented and the alarm informations
         * are cleared */
        volatile uint16 TIMEOUT = 0xFFFF;/* Note STHE: added "volatile" as it didn't work always without */
        do
        {
            __nop();
        } while(TIMEOUT-- && !g_SlkStatus.smuAlarmPending.alarmCounter);

        if(g_SlkStatus.smuAlarmPending.alarmCounter > 0)
        {
            /* Set alarmState to "notPending", decrement alarmCounter and close TFT POP UP window */
            g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1]->alarmState =
                    notPending;
            g_SlkStatus.smuAlarmPending.alarmCounter--;
        }
    }
    else
    {
        while(1)
        {
            __debug();
            __nop();
        }
    }
    IfxConvctrl_lockConfigurationAccess(&MODULE_CONVCTRL);
    /*---------------------------------------------------------------------------------------------*/
    /*        Part 4: Phase synchronizer fault injection (SM:CONVCTRL:ALARM_CHECK)            */
    /*---------------------------------------------------------------------------------------------*/
    IfxConvctrl_enableConfigurationAccess(&MODULE_CONVCTRL);

    /* Inject fault in the Phase Synchronizer Divider(PHSDIV) */
    IfxConvctrl_injectPhaseSyncDividerFault(&MODULE_CONVCTRL);
    timeout = 0xFFFF;
    errorDetected = FALSE;
    alarmIsRaised = FALSE;
    do
    {
        /* Wait for alarm flag to be set */
        errorDetected = IfxConvctrl_isErrorDetected(&MODULE_CONVCTRL);
        /* Wait for IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError alarm (ALM11[12]) */
        alarmIsRaised = IfxSmu_getAlarmStatus(IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError);
    } while(timeout-- && (!errorDetected || !alarmIsRaised));

    if(alarmIsRaised && errorDetected)
    {
        IfxConvctrl_clearAlarmFlag(&MODULE_CONVCTRL);
        /* Clear IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError alarm (ALM11[12]) */
        IfxSmu_clearAlarmStatus(IfxSmu_Alarm_CONVERTER_Phase_SyncronizerError);

        /* Wait for alarmCounter to be incremented in ISR afterwards it will get decremented and the
         * alarm informations are cleared */
        volatile uint16 timeout = 0xFFFF;/* Note STHE: added "volatile" as it didn't work always without */
        do
        {
            __nop();
        } while(timeout-- && !g_SlkStatus.smuAlarmPending.alarmCounter);

        if(g_SlkStatus.smuAlarmPending.alarmCounter > 0)
        {
            /* Set alarmState to "notPending", decrement alarmCounter and close TFT POP UP window */
            g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1]->alarmState =
                    notPending;
            g_SlkStatus.smuAlarmPending.alarmCounter--;
        }
    }
    else
    {
        while(1)
        {
            __debug();
            __nop();
        }
    }

    IfxConvctrl_lockConfigurationAccess(&MODULE_CONVCTRL);
}

/*---------------------------------------------------------------------------------------------*/
/*                                    EVADC Functions                                          */
/*---------------------------------------------------------------------------------------------*/
/*
 * Function to initialize the EVADC module with default parameters
 * */
void initEVADCModule(SlkEvadcCfgType *evadcCfg)
{
    /* If EVADC module is already enabled reset the module and reinitialize it. */
    if(MODULE_EVADC.CLC.B.DISS == 0)
    {
        /* Reset module */
        IfxEvadc_resetModule(&MODULE_EVADC);

        /* Enable access to EVADC module as it gets locked  in IfxEvadc_resetModule() */
        IfxEvadc_enableAccess(&MODULE_EVADC, IfxEvadc_Protection_globalConfig);
    }

    /* Create configuration */
    IfxEvadc_Adc_Config adcConfig;
    IfxEvadc_Adc_initModuleConfig(&adcConfig, &MODULE_EVADC);

    /* Initialize module */
    IfxEvadc_Adc_initModule(&evadcCfg->evadc, &adcConfig);
}

/*
 * Function to initialize the EVADC groups with default parameters
 * */
void initEVADCGroups(SlkEvadcCfgType *evadcCfg, uint8 varefGrId)
{
    /* Create group configuration */
    IfxEvadc_Adc_GroupConfig adcGroupConfig[evadcCfg->amountOfGroups];

    for(uint16 idx = 0; idx < evadcCfg->amountOfGroups; idx++)
    {
        /* Initialize group configuration with default values */
        IfxEvadc_Adc_initGroupConfig(&adcGroupConfig[idx], &evadcCfg->evadc);

        /* Setting user configuration for each group */
        adcGroupConfig[idx].groupId = evadcCfg->evadcChannelConfig[idx].analogInput->groupId;
        adcGroupConfig[idx].master  = evadcCfg->evadcChannelConfig[idx].analogInput->groupId;

        /* Set default analog clock frequency fADCI to 20MHz */
        adcGroupConfig[idx].analogFrequency = EVADC_20MHZ_FREQ;

        /* Enable queued source */
        if(evadcCfg->evadcChannelConfig[idx].queueRequestSourceId == 0)
        {
            adcGroupConfig[idx].arbiter.requestSlotQueue0Enabled = TRUE;
        }
        else if(evadcCfg->evadcChannelConfig[idx].queueRequestSourceId == 1)
        {
            adcGroupConfig[idx].arbiter.requestSlotQueue1Enabled = TRUE;
        }
        else if(evadcCfg->evadcChannelConfig[idx].queueRequestSourceId == 2)
        {
            adcGroupConfig[idx].arbiter.requestSlotQueue2Enabled = TRUE;
        }

        /* Enable all gates in "always" mode (no edge detection) */
        adcGroupConfig[idx].queueRequest[evadcCfg->evadcChannelConfig[idx].queueRequestSourceId].triggerConfig.gatingMode =
                IfxEvadc_GatingMode_always;
        adcGroupConfig[idx].queueRequest[evadcCfg->evadcChannelConfig[idx].queueRequestSourceId].triggerConfig.gatingSource =
                IfxEvadc_GatingSource_0;

        /*
        * The VDDK signal is an internal voltage source that can be measured by any
        * EVADC Group on Channel 29 (Alias feature Channel 0 and Channel 1).
        * ALIAS feature for Channel 0 - VDDK i.e, for EVADC plausibility on VAREF pin
        */
        if (idx == varefGrId)
        {
            adcGroupConfig[idx].module->evadc->G[adcGroupConfig[idx].groupId].ALIAS.B.ALIAS0 = 29;
        }

        /* Enable startup calibration */
        adcGroupConfig[idx].startupCalibration = TRUE;

        /* Initialize the group */
        IfxEvadc_Adc_initGroup(&evadcCfg->evadcGroup[idx], &adcGroupConfig[idx]);

        /* SM:EVADC:CONFIG_CHECK */
        /* Verify the write access to safety relevant registers GxANCFG and GxSYNCTR (x=0..11) by reading the respective
         * register and check the returned value. */
        Ifx_EVADC_G_ANCFG expectedANCFG;
        expectedANCFG.U = 0x00700010;       /* this is just example value, user can have other value */

        Ifx_EVADC_G_SYNCTR SYNCTR_expected;
        SYNCTR_expected.U = 0x00000000;      /* this is just example value, user can have other value */

        if((evadcCfg->evadcGroup[idx].group->ANCFG.U != expectedANCFG.U)   ||
           (evadcCfg->evadcGroup[idx].group->SYNCTR.U != SYNCTR_expected.U))
        {
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_ADC);
        }
    }
}

/* Function to initialize the EVADC channels */
void initEVADCChannels(SlkEvadcCfgType *evadcCfg)
{
    /* Create channel configuration */
    IfxEvadc_Adc_ChannelConfig adcChannelConfig[evadcCfg->amountOfChannels];

    for(uint16 idx = 0; idx < evadcCfg->amountOfChannels; idx++)
    {
        /* Initialize the configuration with default values */
        IfxEvadc_Adc_initChannelConfig(&adcChannelConfig[idx], evadcCfg->evadcChannelConfig[idx].groupHandle);

        /* Select the channel ID and the respective result register */
        adcChannelConfig[idx].channelId = evadcCfg->evadcChannelConfig[idx].analogInput->channelId;
        adcChannelConfig[idx].resultRegister = evadcCfg->evadcChannelConfig[idx].resultRegister;

        adcChannelConfig[idx].inputClass = evadcCfg->evadcChannelConfig[idx].inputClass;
        if(evadcCfg->evadcChannelConfig[idx].initISR)
        {
            adcChannelConfig[idx].resultSrcNr        = evadcCfg->evadcChannelConfig[idx].resultSrcNr;
            adcChannelConfig[idx].resultPriority     = evadcCfg->evadcChannelConfig[idx].resultPriority;
            adcChannelConfig[idx].resultServProvider = evadcCfg->evadcChannelConfig[idx].resultServProvider;
        }

        /* Initialize the channel */
        IfxEvadc_Adc_initChannel(&evadcCfg->evadcChannel[idx], &adcChannelConfig[idx]);
    }

    /* Diversity of result value can be enhanced by using different accumulation levels on the two channels, resulting
     * in different values for the same result. (as stated in Recommendations in SM:EVADC:DIVERSE_REDUNDANCY)
     * */
}

/*
 * Function to initialize Broken wire detection and boundary configuration
 * */
void initEVADCBrokenWireDetection (IfxEvadc_Vadcg_In *evadcInput, const uint32 lowerBoundary,
        const uint32 upperBoundary, const IfxEvadc_SrcNr channelSrcNr, const IfxCpu_ResourceCpu tosCpuId,
        const Ifx_Priority priority)
{
    Ifx_EVADC_G *evadcG = &evadcInput->module->G[evadcInput->groupId];

    IfxEvadc_enableAccess(&MODULE_EVADC, (IfxEvadc_Protection)(IfxEvadc_Protection_channelControl0 + evadcInput->groupId));

    evadcG->CHCTR[evadcInput->channelId].B.BWDEN = 1; /* Enable Additional Preparation Phase */
    evadcG->CHCTR[evadcInput->channelId].B.BWDCH = 1; /* Select VAGND for precharging */
    evadcG->CHCTR[evadcInput->channelId].B.BNDSELL = IfxEvadc_BoundarySelection_group0;
    evadcG->CHCTR[evadcInput->channelId].B.BNDSELU = IfxEvadc_BoundarySelection_group1;
    evadcG->CHCTR[evadcInput->channelId].B.CHEVMODE = IfxEvadc_LimitCheck_eventIfOutsideArea;

    evadcG->BOUND.B.BOUNDARY0 = lowerBoundary;
    evadcG->BOUND.B.BOUNDARY1 = upperBoundary;

    /* Enable channel interrupt (code snippet is based on iLLD function IfxEvadc_Adc_initChannel) */
    volatile Ifx_SRC_SRCR *src = IfxEvadc_getSrcAddress(evadcInput->groupId, channelSrcNr);

    if (evadcInput->channelId < IfxEvadc_ChannelId_8)
    {
        IfxEvadc_setChannelEventNodePointer0(evadcG, channelSrcNr, evadcInput->channelId);
    }
    else
    {
        IfxEvadc_setChannelEventNodePointer1(evadcG, channelSrcNr, evadcInput->channelId);
    }

    IfxEvadc_clearChannelRequest(evadcG, evadcInput->channelId);
    IfxSrc_init(src, IfxCpu_Irq_getTos(tosCpuId), priority);
    IfxSrc_enable(src);

    IfxEvadc_disableAccess(&MODULE_EVADC,
            (IfxEvadc_Protection) (IfxEvadc_Protection_channelControl0 + evadcInput->groupId));
}

/*
 * Function initial EVADC to trigger GTM
 * */
void initEVADCGtmTrigger (SlkEvadcCfgType *evadcCfg, uint8 groupIdx, IfxEvadc_TriggerMode triggerMode,
        IfxEvadc_TriggerSource triggerSource)
{
    /* Get group configuration */
    IfxEvadc_Adc_GroupConfig adcGroupConfig;
    IfxEvadc_Adc_getGroupConfig(&evadcCfg->evadcGroup[groupIdx], &adcGroupConfig);

    /* Configure triggerMode and triggerSource */
    adcGroupConfig.queueRequest[evadcCfg->evadcChannelConfig[groupIdx].queueRequestSourceId].triggerConfig.triggerMode =
            triggerMode;
    adcGroupConfig.queueRequest[evadcCfg->evadcChannelConfig[groupIdx].queueRequestSourceId].triggerConfig.triggerSource =
            triggerSource;

    /* Initialize the group */
    IfxEvadc_Adc_initGroup(&evadcCfg->evadcGroup[groupIdx], &adcGroupConfig);
}

/*
 * This function implements verification of the VDDK supervision signal:
 * - Obtain current temperature using DTS PMS
 * - Read UCB FLASH Group0 record
 * - Compute current expected VDDK value and its min/max boundary
 * - Compare conversion result with the expected values
 */
void verifyG0Vddk(float32 vddkResult)
{
    /* Obtain current die temperature using DTS PMS */
    /* T (°C) = [RESULT / Gnom] - 273.1, where Gnom = 7.505 */
    float32 dtsTemp = IfxDts_Dts_getTemperatureCelsius();

    /* Read UCB FLASH VDDK record */
    uint32 vddkUCB = (UCB_G0_VDDK_RECORD);
    /* Variable to hold base VDDK record - VDDKC */
    uint32 vddkc = (vddkUCB >> 0 ) & 0xFFFF;
    /* Variable to hold temperature compensation VDDK record - dVDDK */
    uint32 dvddk = (vddkUCB >> 0x10) & 0xFFFF;

    /* Compute nominal VDDK value based VDDKC, dVDDK and current temperature */
    /* VDDK(V) = VDDKC + (DVDDK × (Tj + 40)/1000) */
    float32 vddkNom = vddkc + ( dvddk * ( (float32)dtsTemp + 40 ) / 1000 );

    /* Compute min-max boundary of the nominal VDDK */
    float32 vddkMin = vddkNom / 1000 * 0.97;
    float32 vddkMax = vddkNom / 1000 * 1.03;

    /* Check if the conversion result is within expected min/max boundary */
    if( ( vddkResult  > vddkMin ) && ( vddkResult < vddkMax ) )
    {
        /* VDDK test passed */
    }
    else
    {
        /* VDDK test failed */
        /* Trigger SMU alarm if deviation is higher than VAREF_TOLERANCE */
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_ADC);
    }
}

/*
 * Function to run the VAREF plausibility check: SM:EVADC:VAREF_PLAUSIBILITY
 * tolerance is in percent [0..1]
 * */
float32 evadcVarefPlausibilityCheck (SlkEvadcCfgType *evadcCfg, const uint8 varefChId,
        const IfxEvadc_RequestSource sourceType)
{
    /* Add channel to queue with refill option enabled */
    IfxEvadc_Adc_addToQueue(&evadcCfg->evadcChannel[varefChId], sourceType, IFXEVADC_QUEUE_REFILL);

    /* Start the queue */
    IfxEvadc_Adc_startQueue(evadcCfg->evadcChannelConfig[varefChId].groupHandle, sourceType);

    /* Wait 1ms before reading the measurement */
    uint32 milliSeconds = 1;
    IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, milliSeconds));

    g_analogAcquisitionStatus.evadcConversionResult[varefChId] = getEvadcChannelResult(
            &evadcCfg->evadcChannel[varefChId]);
    /* Flush the queue as of VAREF (Vddk) check is only done once per driving cycle. */
    IfxEvadc_Adc_clearQueue(evadcCfg->evadcChannelConfig[varefChId].groupHandle, sourceType);

    /* measured corresponding voltage */
    float32 measuredVddk = EVADC_RESULT_TO_V(g_analogAcquisitionStatus.evadcConversionResult[varefChId]);

    /* Verify obtained results against expected values */
    verifyG0Vddk(measuredVddk);

    return measuredVddk;
}

/*
 * Function get the EVADC channel result
 * */
sint32 getEvadcChannelResult(IfxEvadc_Adc_Channel *channel)
{
    /* Get the EVADC conversion result */
    Ifx_EVADC_G_RES conversionResult;
    uint32 timeout = 0xFF;
    do
    {
        /* Read the result of the selected channel */
        conversionResult = IfxEvadc_Adc_getResult(channel);
    } while(!conversionResult.B.VF && timeout--);

    /* If we did not get any valid conversion before TIMEOUT something is wrong */
    if(!timeout)
    {
        __debug();
        return 0;
    }

    return conversionResult.B.RESULT;
}
/* End of EVADC functions */

/*---------------------------------------------------------------------------------------------*/
/*                                    EDSADC Functions                                         */
/*---------------------------------------------------------------------------------------------*/
/*
 * Function to initialize the EDSADC module with default parameters
 * */
void initEDSADCModule(SlkEdsadcCfgType *edsadcCfg)
{
    /* If EDSADC module is already enabled reset the module and reinitialize it. */
    if(MODULE_EDSADC.CLC.B.DISS == 0)
    {
        IfxEdsadc_resetModule(&MODULE_EDSADC);
    }

    IfxEdsadc_Edsadc_Config edsadcConfig; /* Module configuration structure */

    /* Initialize the configuration with default values */
    IfxEdsadc_Edsadc_initModuleConfig(&edsadcConfig, &MODULE_EDSADC);

    /* Generate the modulator clock independently of the phase synchronizer signal */
    edsadcConfig.modulatorClockMode = IfxEdsadc_ModulatorClockGeneration_unsyncMode;

    /* Initialize the EDSADC module */
    IfxEdsadc_Edsadc_initModule(&edsadcCfg->edsadc, &edsadcConfig);
}

/*
 * Function to initialize the EDSADC channels
 * */
void initEDSADCChannels(SlkEdsadcCfgType *edsadcCfg)
{
    uint32 modulatorMask = 0;
    uint32 channelMask = 0;

    IfxEdsadc_Edsadc_ChannelConfig edsadcChannelConfig[edsadcCfg->amountOfChannels]; /* Channel configuration structure */

    for(uint16 idx = 0; idx < edsadcCfg->amountOfChannels; idx++)
    {
        /* Initialize the configuration with default values */
        IfxEdsadc_Edsadc_initChannelConfig(&edsadcChannelConfig[idx], &edsadcCfg->edsadc);

        /* Configure the comb filter */
        edsadcChannelConfig[idx].combFilter.decimationFactor = DECIMATION_FACTOR; /* Set the decimation factor */
        /* Set the starting value of the decimation counter */
        edsadcChannelConfig[idx].combFilter.startValue = START_VALUE;

        /* Configure the FIR filters in the filter chain */
        edsadcChannelConfig[idx].firFilter.prefilterEnabled = TRUE; /* Enable the Pre-Filter in the filter chain */
        edsadcChannelConfig[idx].firFilter.fir0Enabled = TRUE;      /* Enable the FIR0 Filter in the filter chain */
        edsadcChannelConfig[idx].firFilter.fir1Enabled = TRUE;      /* Enable the FIR1 Filter in the filter chain */
        /* Start the calibration initializing the channel */
        edsadcChannelConfig[idx].firFilter.calibrationTrigger = TRUE;

        /* Configure the modulator */
        edsadcChannelConfig[idx].modulator.modulatorClockFreq = EDSADC_20MHZ_FREQ; /* Set the modulator frequency */

        if(edsadcCfg->edsadcChannelConfig[idx].posInput != NULL_PTR)
        {
            edsadcChannelConfig[idx].modulator.positiveInput = IfxEdsadc_InputConfig_inputPin;
            edsadcChannelConfig[idx].modulator.inputPin =
                    (IfxEdsadc_InputPin) edsadcCfg->edsadcChannelConfig[idx].posInput->select;
            /* Select the channel */
            edsadcChannelConfig[idx].channelId = edsadcCfg->edsadcChannelConfig[idx].posInput->channel;
        }
        else
        {
            edsadcChannelConfig[idx].modulator.positiveInput = IfxEdsadc_InputConfig_referenceGround;
        }

        if(edsadcCfg->edsadcChannelConfig[idx].negInput != NULL_PTR)
        {
            edsadcChannelConfig[idx].modulator.negativeInput = IfxEdsadc_InputConfig_inputPin;
            edsadcChannelConfig[idx].modulator.inputPin =
                    (IfxEdsadc_InputPin) edsadcCfg->edsadcChannelConfig[idx].negInput->select;
            /* Select the channel */
            edsadcChannelConfig[idx].channelId = edsadcCfg->edsadcChannelConfig[idx].negInput->channel;
        }
        else
        {
            edsadcChannelConfig[idx].modulator.negativeInput = IfxEdsadc_InputConfig_referenceGround;
        }
        edsadcChannelConfig[idx].modulator.inputGain     = IfxEdsadc_InputGain_factor1;

        /* Set the CIC shift */
        edsadcChannelConfig[idx].cicShift = CICSHIFT;

        /* Set the gain factor */
        edsadcChannelConfig[idx].gainFactor = GAINFACTOR;

        /* Set the intended full-scale value */
        edsadcChannelConfig[idx].gainCalibrationConfig.calTarget = RAW_FULL_SCALE;

        /* Initialize the channel */
        IfxEdsadc_Edsadc_initChannel(&edsadcCfg->edsadcChannel[idx], &edsadcChannelConfig[idx]);

        /* Add channel id to modulator and channel mask */
        modulatorMask   |= (0x1 << edsadcChannelConfig[idx].channelId);
        channelMask     |= (0x1 << edsadcChannelConfig[idx].channelId);
    }

    /* Start scan of all channels */
    IfxEdsadc_Edsadc_startScan(&edsadcCfg->edsadc, modulatorMask, channelMask);

    /* Diversity of result value can be enhanced by using different integration levels on the two channels,
     * resulting in different values for the same result. (as stated in Recommendations in
     * SM:EDSADC:DIVERSE_REDUNDANCY) */
}

/* Function to run the EDSADC plausibility check: SM:EDSADC:VAREF_PLAUSIBILITY
 * tolerance is in percent [0..1]
 * */
float32 edsadcVarefPlausibilityCheck (SlkEdsadcCfgType *edsadcCfg, const uint8 varefChId,
        const float32 varefExpectedResult, const float32 varefTolerance)
{
    uint32 modulatorMask  = (0x1 << edsadcCfg->edsadcChannel[varefChId].channelId);
    uint32 channelMask    = (0x1 << edsadcCfg->edsadcChannel[varefChId].channelId);

    /* Start scan of VAREF channel as it is only verified once per driving cycle */
    IfxEdsadc_Edsadc_startScan(&edsadcCfg->edsadc, modulatorMask, channelMask);

    /* Wait 1ms before reading the measurement */
    uint32 milliSeconds = 1;
    IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, milliSeconds));
    sint16 conversionResult = IfxEdsadc_Edsadc_getMainResult(&edsadcCfg->edsadcChannel[varefChId]);

    /* Calculate the corresponding voltage and check whether it is within expected Range */
    boolean withinExpectedRange = FALSE;
    float32 VAREF = EDSADC_RESULT_TO_V(conversionResult);
    withinExpectedRange =   VAREF > ((1 - varefTolerance) * varefExpectedResult) &&
                            VAREF < ((1 + varefTolerance) * varefExpectedResult);

    /* Stop scan of VAREF channel as it is only verified once per driving cycle */
    IfxEdsadc_Edsadc_stopScan(&edsadcCfg->edsadc, modulatorMask);

    /* Trigger SMU alarm if deviation is higher than VAREF_TOLERANCE or TIMEOUT has reached */
    if(!withinExpectedRange)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_ADC);
    }

    return VAREF;
}

/* End of EDSADC functions */

/*
 * function to get the calibration offset
 * */
void getCalibrationOffset (float32 *accumulationResult, const uint16 amountOfSamples, float32 *calibrationResult)
{
    float32 calibrationOffset[2] = {0};
    calibrationOffset[0] = accumulationResult[0] / (float32)amountOfSamples;
    calibrationOffset[1] = accumulationResult[1] / (float32)amountOfSamples;

    if(calibrationOffset[0] <= calibrationOffset[1])
    {
        calibrationResult[0] = 0;
        calibrationResult[1] = calibrationOffset[1] - calibrationOffset[0];
    }
    else if(calibrationOffset[1] <= calibrationOffset[0])
    {
        calibrationResult[0] = calibrationOffset[0] - calibrationOffset[1];
        calibrationResult[1] = 0;
    }
    else
    {
        calibrationResult[0] = 0;
        calibrationResult[1] = 0;
    }
}

/*
 * This function can be used for SM:EVADC:PLAUSIBILITY or SM:EDSADC:PLAUSIBILITY
 * This function is independent of the unit, just pass the difference and limit variables in the same unit
 * */
boolean plausibilityCheck (float32 missionChannel, float32 monitorChannel, float32 maximumDifference,
        float32 upperLimit, float32 lowerLimit, IfxSmu_Alarm smuSoftwareAlarm)
{
    boolean checkPass = TRUE;
    /* Limit validation */
    if( (missionChannel > upperLimit) || (monitorChannel > upperLimit) ||
        (missionChannel < lowerLimit) || (monitorChannel < lowerLimit))
    {
        /* Appropriate reaction if values are lower or higher as the specific limits */
        /* Trigger SMU software alarm */
        softwareCoreAlarmTriggerSMU(smuSoftwareAlarm);
        checkPass = FALSE;
    }

    /* Difference validation */
    float32 difference;
    difference =
            (missionChannel < monitorChannel) ? (monitorChannel - missionChannel) : (missionChannel - monitorChannel);

    /* Appropriate reaction if difference is higher than the limit */
    if(difference > maximumDifference)
    {
        /* Trigger SMU software alarm */
        softwareCoreAlarmTriggerSMU(smuSoftwareAlarm);
        checkPass = FALSE;
    }

    return checkPass;
}

/*
 * this function reset the status of analog acquisition status
 * */
void resetAnalogAcqStatus(void)
{
    /* Reset initCnt to ignore first measurements during change of active FUC mode */
    g_analogAcquisitionStatus.initCnt                = 0;
    g_analogAcquisitionStatus.evadcInput1MeasDoneFlag   = FALSE;        /* Reset flag */
    g_analogAcquisitionStatus.evadcInput2MeasDoneFlag   = FALSE;        /* Reset flag */
    g_analogAcquisitionStatus.evadcInput1Calibration    = 0;            /* Reset calibration values */
    g_analogAcquisitionStatus.evadcInput2Calibration    = 0;            /* Reset calibration values */
    g_analogAcquisitionStatus.edsadcInput1Calibration   = 0;            /* Reset calibration values */
    g_analogAcquisitionStatus.edsadcInput1Calibration   = 0;            /* Reset calibration values */
    for (uint8 idx = 0; idx < EVADC_CHANNELS_NUM_AA_FUC0; idx++)
    {
        g_analogAcquisitionStatus.edsadcConversionResult[idx] = 0;
        g_analogAcquisitionStatus.edsadcVoltageResults[idx] = 0;
        g_analogAcquisitionStatus.evadcConversionResult[idx] = 0;
        g_analogAcquisitionStatus.evadcVoltageResults[idx] = 0;
    }

}
