/**********************************************************************************************************************
 * \file Slk_Clock_Plausibility.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Avoid_Detect_CCF/Slk_Clock_Plausibility.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxQspi_SpiMaster.h"
#include "IfxStm.h"


/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define MASTER_CHANNEL_BAUDRATE     10000000             /* Master channel baud rate 10MHz                           */
#define EXPECTED_TIME               100.01               /* microsecond                                              */
#define TRANSFER_TIME_MAX_LIMIT     (EXPECTED_TIME + (EXPECTED_TIME * 0.05))        /* 5% of expected time           */
#define TRANSFER_TIME_MIN_LIMIT     (EXPECTED_TIME - (EXPECTED_TIME * 0.05))        /* 5% of expected time           */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
QspiDma g_qspiDma;
/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void initQspi3Master(void);
static void initQspi3MasterChannel(void);
static void initQspi3MasterBuffers(void);
static void enableInterruptPT(void);
void checkClockPlausibility(void);

IFX_INTERRUPT(isrDMAChn2Tx, CPU_WHICH_RUN_QSPI, ISR_PRIORITY_QSPI3_TX_DMA_CH2_CLK_PlAUS);
IFX_INTERRUPT(isrDMAChn3Rx, CPU_WHICH_RUN_QSPI, ISR_PRIORITY_QSPI3_RX_DMA_CH3_CLK_PlAUS);
IFX_INTERRUPT(isrQSPI3Error, CPU_WHICH_RUN_QSPI, ISR_PRIORITY_QSPI3_ER_CLK_PlAUS);
IFX_INTERRUPT(isrQSPI3Pt, CPU_WHICH_RUN_QSPI, ISR_PRIORITY_QSPI3_PT_CLK_PlAUS);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Handle QSPI3 Error interrupt */
void isrQSPI3Error(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrError(&g_qspiDma.spiMaster);
}

/* Handle DMA Channel 2 interrupt */
void isrDMAChn2Tx(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrDmaTransmit(&g_qspiDma.spiMaster);
}

/* Handle DMA Channel 3 interrupt */
void isrDMAChn3Rx(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrDmaReceive(&g_qspiDma.spiMaster);
}

/*
 * Function to check clock Plausibility on every EOF event
 * SM:CLOCK:PLAUSIBILITY
 * */
void checkClockPlausibility(void)
{
    /* check clock plausibility range */
    if ((g_SlkStatus.timeDiffQspiClockPlaus > TRANSFER_TIME_MAX_LIMIT) ||
        (g_SlkStatus.timeDiffQspiClockPlaus < TRANSFER_TIME_MIN_LIMIT))
    {
        /* check plausibility test failed, Trigger SMU software alarm */
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_CLOCK_PLAUS);
    }
    else
    {
        /* check plausibility test passed */
    }
}
/* Handle QSPI3 Phase Transition interrupt */
void isrQSPI3Pt(void)
{
    static uint64 stmStartOfFrame, stmEndOfFrame;
    uint64 eventTime;
    IfxQspi_PhaseTransitionEvent event;

    /* time when event occurs */
    eventTime = IfxStm_get(&MODULE_STM1);

    IfxCpu_enableInterrupts();

    event = IfxQspi_SpiMaster_isrPhaseTransition(&g_qspiDma.spiMaster);
    /* Process phase transition event */
    switch (event)
    {
        /* Start Of Frame (SOF) event */
        case IfxQspi_PhaseTransitionEvent_startOfFrame:
            stmStartOfFrame = eventTime;
            break;

        /* End Of Frame (EOF) event */
        case IfxQspi_PhaseTransitionEvent_endOfFrame:
            stmEndOfFrame = eventTime;

            /* from where 100 below comes
             * Time in second = Ticks / Fstm; Fstm = 100MHz
             *  1 sec = 1000000  microsecond
             * Time in Microsecond = Ticks /100M *  1000000;
             * Time in Microsecond = Ticks/100
             */
            g_SlkStatus.timeDiffQspiClockPlaus = (float32)(stmEndOfFrame - stmStartOfFrame) / 100;
            checkClockPlausibility();
            break;

          /* add other events if needed */
        case IfxQspi_PhaseTransitionEvent_endOfWait:
        case IfxQspi_PhaseTransitionEvent_serialClockPolarityChange:
        case IfxQspi_PhaseTransitionEvent_transmitBufferEmptied:
        case IfxQspi_PhaseTransitionEvent_receiveBufferFilled:
        case IfxQspi_PhaseTransitionEvent_dataNotAvailable:
        case IfxQspi_PhaseTransitionEvent_endOfExpect:
            break;
        default:
            break;
    }
 }

/*
 * enable the Phase Transition interrupt for QSPI5
 * */
static void enableInterruptPT()
{
    volatile Ifx_SRC_SRCR *src = &MODULE_SRC.QSPI.QSPI[3].PT;
    if(CPU_WHICH_RUN_QSPI)
    {
        IfxSrc_init(src, (IfxSrc_Tos)(CPU_WHICH_RUN_QSPI +1), ISR_PRIORITY_QSPI3_PT_CLK_PlAUS);
    }
    else
    {
        IfxSrc_init(src, (IfxSrc_Tos)CPU_WHICH_RUN_QSPI, ISR_PRIORITY_QSPI3_PT_CLK_PlAUS);
    }

    IfxSrc_enable(src);

    /* Configured for PT1 Start Of Frame event */
    IfxQspi_configPT1Event(&MODULE_QSPI3, IfxQspi_PhaseTransitionEvent_startOfFrame);
    IfxQspi_enablePT1Event(&MODULE_QSPI3, TRUE);

    /* Configured for PT1 End Of Frame event */
    IfxQspi_configPT2Event(&MODULE_QSPI3, IfxQspi_PhaseTransitionEvent_endOfFrame);
    IfxQspi_enablePT2Event(&MODULE_QSPI3, TRUE);
}
/*
 * This function initializes QSPI3 in master mode
 * */
static void initQspi3Master(void)
{
    /* Define the Master Configuration */
    IfxQspi_SpiMaster_Config spiMasterConfig;

    /* Initialize it with default values */
    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, &MODULE_QSPI3);

    /* Set baud rate to 10 MHz */
    spiMasterConfig.base.maximumBaudrate = MASTER_CHANNEL_BAUDRATE;
    /* Select the port pins for communication */
    const IfxQspi_SpiMaster_Pins qspi5Masterpins = {
        &IfxQspi3_SCLK_P02_7_OUT, IfxPort_OutputMode_pushPull,     /* SCLK Pin                          (CLK)  */
        &IfxQspi3_MTSR_P10_6_OUT, IfxPort_OutputMode_pushPull,      /* Master Transmit Slave Receive Pin (MOSI) */
        &IfxQspi3_MRSTA_P02_5_IN, IfxPort_InputMode_pullDown,       /* Master Receive Slave Transmit Pin (MISO) */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                      /* Pad driver mode                          */
    };
    /* Assign Master Pins */
    spiMasterConfig.pins = &qspi5Masterpins;

    /* use DMA for transfer */
    spiMasterConfig.dma.useDma = TRUE;
    spiMasterConfig.dma.txDmaChannelId = IfxDma_ChannelId_2;
    spiMasterConfig.dma.rxDmaChannelId = IfxDma_ChannelId_3;

    /* Set the ISR priorities and the service provider */
    spiMasterConfig.base.txPriority = ISR_PRIORITY_QSPI3_TX_DMA_CH2_CLK_PlAUS;
    spiMasterConfig.base.rxPriority = ISR_PRIORITY_QSPI3_RX_DMA_CH3_CLK_PlAUS;
    spiMasterConfig.base.erPriority = ISR_PRIORITY_QSPI3_ER_CLK_PlAUS;

    if(CPU_WHICH_RUN_QSPI)
    {
        spiMasterConfig.base.isrProvider = (IfxSrc_Tos)(CPU_WHICH_RUN_QSPI + 1);
    }
    else
    {
        spiMasterConfig.base.isrProvider = (IfxSrc_Tos)CPU_WHICH_RUN_QSPI;
    }

    /* Initialize the QSPI Master module using the user configuration */
    IfxQspi_SpiMaster_initModule(&g_qspiDma.spiMaster, &spiMasterConfig);

    /* enable Phase Transition interrupt for QPSI3 only */
    enableInterruptPT();
}

/*
 * This function initializes QSPI3 channel.
 * */
static void initQspi3MasterChannel(void)
{
    /* Define the Master Channel Configuration  */
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    /* Initialize it with default values */
    IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &g_qspiDma.spiMaster);

    /* Set SCLK frequency to 10 MHz */
    spiMasterChannelConfig.base.baudrate = MASTER_CHANNEL_BAUDRATE;

    /* Set spi master in XXL mode */
    spiMasterChannelConfig.mode = IfxQspi_SpiMaster_Mode_xxl;

    const IfxQspi_SpiMaster_Output qspi5SlaveSelect = {
        &IfxQspi3_SLSO5_P02_8_OUT, IfxPort_OutputMode_pushPull,  /* Slave Select Pin (CS) */
        IfxPort_PadDriver_cmosAutomotiveSpeed1                    /* Pad driver mode       */
    };
    /* Assign Slave port pins */
    spiMasterChannelConfig.sls.output = qspi5SlaveSelect;

    /* Initialize the QSPI Master channel using the user configuration */
    IfxQspi_SpiMaster_initChannel(&g_qspiDma.spiMasterChannel, &spiMasterChannelConfig);

}

/*
 * This function initializes Master SW buffers
 * */
static void initQspi3MasterBuffers(void)
{
    for (uint32 i = 0; i < SPI_BUFFER_SIZE_XXL; i++)
    {
        /* Fill the SPI Master TX Buffer  */
        g_qspiDma.qspiBuffer.spi3MasterTxBuffer[i] = (uint8)(i + 1);
        /* Clear the SPI Master RX Buffer */
        g_qspiDma.qspiBuffer.spi3MasterRxBuffer[i] = 0;
    }
}

/*
 * This function ensures the QSPI data transfer by Master i.e. don't need
 * slave for this particular example
 */
void transferDataClockPlausibility(void)
{
    SpiIf_Status status;
    while (IfxQspi_SpiMaster_getStatus(&g_qspiDma.spiMasterChannel)
           == SpiIf_Status_busy)
    {
        /* Wait until the previous transfer has finished, if any */
    }
    /* send a data stream through the SPI Master */
    status = IfxQspi_SpiMaster_exchange(&g_qspiDma.spiMasterChannel, &g_qspiDma.qspiBuffer.spi3MasterTxBuffer[0],
                               NULL_PTR, SPI_BUFFER_SIZE_XXL);

    /* Wait until the slave received all data */
    while (IfxQspi_SpiSlave_getStatus(&g_qspiDma.spiSlave) == SpiIf_Status_busy)
    {
    }

    /* indicate transfer is done */
    if (status != SpiIf_Status_ok)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_CLOCK_PLAUS);
    }
    else
    {
        /* transfer is done */
    }
}
/*
 * This function initializes the QSPI5 module
 * */
void initQspi3ClockPlausibility(void)
{
    /* Initialize the Master */
    initQspi3Master();
    initQspi3MasterChannel();
    initQspi3MasterBuffers();
}
