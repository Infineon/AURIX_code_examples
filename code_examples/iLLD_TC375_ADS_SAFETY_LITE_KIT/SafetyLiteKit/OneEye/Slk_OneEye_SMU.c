/**********************************************************************************************************************
 * \file Slk_OneEye_SMU.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/OneEye/Slk_OneEye_SMU.h"
#include "SafetyLiteKit/Slk_Cfg.h"

#if CPU_WHICH_RUN_SMU == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 1) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 2) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set CPU_WHICH_RUN_SMU to a valid value!"
#endif

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
uint32 g_triggerSMU = 255; /* alarm number set at a upper value than all software alarm to not trigger them */
uint32 g_returnSMU;  /* global variable to store the SMU output number */
uint8 g_clearSMU = 0;      /* global variable only set on the OneEye GUI to clear the SMU. */
uint8 g_resetSys = 0;      /* global variable only set on the OneEye GUI to reset the system. */
uint8 g_resetAlm = 0;      /* global variable only set on the OneEye GUI to clear the alarm. */
boolean g_injectLockstepError = FALSE;
boolean g_alarmDetectLed = FALSE;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
uint8 noAlarmDetected = 0;     /* value compare with the SMU alarm counter */
uint32 noAlarmSmu = 366; /* Normal it should be 'XBAR_SOTA_Swap ", but this alarm is made the default alarm
                                * for user */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

void injectLockstepError(void);
void triggerSwAlarmOneEye();
SmuStatusType clearSmuOneEye(void);
void resetSystemOneEye(void);
void resetAlarmSmuOneEye(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * This function inject lockstep error.
 * */
void injectLockstepError()
{
    if(TRUE == g_injectLockstepError)
    {
        g_injectLockstepError = FALSE;
        /* Step 1: Check if lockstep is enabled */
        if(SCU_LCLCON1.B.LS1 == 1)
        {
            /* Step 2: Inject lockstep error */
            SCU_LCLTEST.B.LCLT1 = 1;
        }
    }
}

/*
 * This function activates a software alarm on the user-defined alarm input number,
 * which should be under 15, within the OneEye graphical user interface (GUI).
 * */
void triggerSwAlarmOneEye()
{
    static uint32 g_triggerSMUPrevious = 255;
    if(g_triggerSMU != g_triggerSMUPrevious)
    {
        softwareCoreAlarmTriggerSMU(IfxSmu_Alarm_Software_Alarm0 + g_triggerSMU);
        g_triggerSMUPrevious = g_triggerSMU;
    }
}

/*
 * This function clear the SMU, via the OneEye graphical user interface (GUI).
 * */
SmuStatusType clearSmuOneEye()
{
    SmuStatusType ack = fail;
    uint16 nbrAlarmToClear = g_SlkStatus.smuAlarmPending.alarmCounter;

    for (uint16 i = 0; i < nbrAlarmToClear; i++)
    {
        if (IfxSmu_getAlarmStatus(g_SlkStatus.smuAlarmPending.lastAlarmRaised[i]->alarmConfig->alarm)
                && (g_SlkStatus.smuAlarmPending.lastAlarmRaised[i]->alarmState == pending))
        {
            ack = coreAlarmReactionClearSMU(g_SlkStatus.smuAlarmPending.lastAlarmRaised[i]);
            if (ack == fail)
            {
                return fail;
            }
        }
        else
        {
            g_SlkStatus.smuAlarmPending.alarmCounter--;
        }
    }
    return pass;
}

/*
 * This function call a system reset, within the OneEye graphical user interface (GUI).
 * */
void resetSystemOneEye()
{
    slkTriggerSwReset(IfxScuRcu_ResetType_system);
}

/*
 * This function clear the alarm, within the OneEye graphical user interface (GUI).
 * */
void resetAlarmSmuOneEye()
{
    if (g_SlkStatus.smuAlarmPending.alarmCounter != 0)
    {
        coreAlarmReactionClearSMU(
                g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1]);
    }
}

/*
 * This function serves as the runtime System Management Unit (SMU),
 * providing all SMU updates based on the user's actions within the OneEye GUI."
 * */
void runtimeSmuOneEye()
{
    triggerSwAlarmOneEye();

    /* inject lockstep error */
    injectLockstepError();

    if(g_clearSMU)
    {
        clearSmuOneEye();
        slkClearAllSmuAlarms();
        g_clearSMU = 0;
    }

    if(g_resetSys)
    {
        resetSystemOneEye();
    }
    if(g_resetAlm)
    {
        resetAlarmSmuOneEye();
        g_resetAlm = 0;
    }

    /* if an alarm is detected update the SMU global variable status */
    if(g_SlkStatus.smuAlarmPending.alarmCounter > noAlarmDetected)
    {
        g_returnSMU =
                (uint32)g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1]->alarmConfig->alarm;

        /* The LED 2 is activated to report that an alarm is detected by the SMU */
        IfxPort_setPinLow(LED2_ALM_DETECTED);
        if (g_alarmDetectLed == TRUE)
        {
            g_alarmDetectLed = FALSE;
        }
        else
        {
            g_alarmDetectLed = TRUE;
        }
    }
    else
    {
        /* The LED 2 is disable to report that an alarm is detected by the SMU */
        IfxPort_setPinHigh(LED2_ALM_DETECTED);
        g_alarmDetectLed = FALSE;
        g_returnSMU = noAlarmSmu;
    }
}
