/**********************************************************************************************************************
 * \file Slk_TrapHandler.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Safe_Computation/Cpu/Slk_TrapHandle.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxScuRcu.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
#if defined(__TASKING__)
#pragma noclear
/* These variables should be placed in a NOINIT section so they are
** not initialized after a reset.  The application could then store the
** data in NVM or make it available via diagnostics.
*/

volatile Ifx_CSA CSA_capture[IFXCPU_NUM_MODULES][CSA_CAPTURE_LIMIT];
volatile uint32 STACK_capture[IFXCPU_NUM_MODULES][STACK_CAPTURE_LIMIT][STACK_CAPTURE_SIZE];

volatile Ifx_CPU_PIETR PIETR_capture[IFXCPU_NUM_MODULES];
volatile Ifx_CPU_PIEAR PIEAR_capture[IFXCPU_NUM_MODULES];

volatile Ifx_CPU_DIETR DIETR_capture[IFXCPU_NUM_MODULES];
volatile Ifx_CPU_DIEAR DIEAR_capture[IFXCPU_NUM_MODULES];

volatile Ifx_CPU_DATR DATR_capture[IFXCPU_NUM_MODULES];
volatile Ifx_CPU_DEADD DEADD_capture[IFXCPU_NUM_MODULES];

volatile Ifx_SMU_AG AG_capture[IFXCPU_NUM_MODULES][12];

#pragma clear
#elif defined(__GNUC__)

volatile Ifx_CSA csaCapture[IFXCPU_NUM_MODULES][csaCapture_LIMIT] __attribute__ ((section (".noinit")));
volatile uint32 STACK_capture[IFXCPU_NUM_MODULES][STACK_CAPTURE_LIMIT][STACK_CAPTURE_SIZE] __attribute__ ((section (".noinit")));

volatile Ifx_CPU_PIETR PIETR_capture[IFXCPU_NUM_MODULES] __attribute__ ((section (".noinit")));
volatile Ifx_CPU_PIEAR PIEAR_capture[IFXCPU_NUM_MODULES] __attribute__ ((section (".noinit")));

volatile Ifx_CPU_DIETR DIETR_capture[IFXCPU_NUM_MODULES] __attribute__ ((section (".noinit")));
volatile Ifx_CPU_DIEAR DIEAR_capture[IFXCPU_NUM_MODULES] __attribute__ ((section (".noinit")));

volatile Ifx_CPU_DATR DATR_capture[IFXCPU_NUM_MODULES] __attribute__ ((section (".noinit")));
volatile Ifx_CPU_DEADD DEADD_capture[IFXCPU_NUM_MODULES] __attribute__ ((section (".noinit")));

volatile Ifx_SMU_AG agCapture[IFXCPU_NUM_MODULES][12] __attribute__ ((section (".noinit")));

#endif

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * This function will trace back as many as csaCapture_LIMIT context save areas and dump each into csaCapture
 * For upper context calls, this function will also dump STACK_CAPTURE_SIZE words from the stack of each context
 * */
void csaCapture(void)
{
    /*Fetch the ID of the current CPU*/
    int cpu = __mfcr(CPU_CUS_ID);

    Ifx_CSA *context_ptr;
    Ifx_CPU_PCXI pcxi;
    uint8 csa_count = 0;
    uint8 stack_count = 0;

    /*Fetch the previous context information*/
    pcxi.U = __mfcr(CPU_PCXI);

    /*Run as long as we have space to dump another CSA*/
    while (csa_count < CSA_CAPTURE_LIMIT)
    {
        /*Recover pointer to CSA block*/
        context_ptr = (Ifx_CSA*) ((pcxi.B.PCXS << 28) | ((pcxi.B.PCXO) * (sizeof(Ifx_CSA))));

        /*Once we've reached the end of the context trace, we are done*/
        if (context_ptr == NULL)
        {
            break;
        }

        if (pcxi.B.UL == CSA_UPPER_CONTEXT)
        {
            /* UPPER contexts are from function calls
             * Reference:
             * - TriCore_TC162P_core_architecture_volume_1_of_2.pdf
             * - 4.5 Context Switching for Function Callsc
             */
            CSA_capture[cpu][csa_count].UPPER.CSA_PCXI = context_ptr->UPPER.CSA_PCXI;
            CSA_capture[cpu][csa_count].UPPER.CSA_PSW = context_ptr->UPPER.CSA_PSW;
            CSA_capture[cpu][csa_count].UPPER.CSA_A10 = context_ptr->UPPER.CSA_A10;
            CSA_capture[cpu][csa_count].UPPER.CSA_A11 = context_ptr->UPPER.CSA_A11;
            CSA_capture[cpu][csa_count].UPPER.CSA_D8 = context_ptr->UPPER.CSA_D8;
            CSA_capture[cpu][csa_count].UPPER.CSA_D9 = context_ptr->UPPER.CSA_D9;
            CSA_capture[cpu][csa_count].UPPER.CSA_D10 = context_ptr->UPPER.CSA_D10;
            CSA_capture[cpu][csa_count].UPPER.CSA_D11 = context_ptr->UPPER.CSA_D11;
            CSA_capture[cpu][csa_count].UPPER.CSA_A12 = context_ptr->UPPER.CSA_A12;
            CSA_capture[cpu][csa_count].UPPER.CSA_A13 = context_ptr->UPPER.CSA_A13;
            CSA_capture[cpu][csa_count].UPPER.CSA_A14 = context_ptr->UPPER.CSA_A14;
            CSA_capture[cpu][csa_count].UPPER.CSA_A15 = context_ptr->UPPER.CSA_A15;
            CSA_capture[cpu][csa_count].UPPER.CSA_D12 = context_ptr->UPPER.CSA_D12;
            CSA_capture[cpu][csa_count].UPPER.CSA_D13 = context_ptr->UPPER.CSA_D13;
            CSA_capture[cpu][csa_count].UPPER.CSA_D14 = context_ptr->UPPER.CSA_D14;
            CSA_capture[cpu][csa_count].UPPER.CSA_D15 = context_ptr->UPPER.CSA_D15;

            /*For upper context calls, we also store the stack if there is room left in STACK_capture*/
            if (stack_count < STACK_CAPTURE_LIMIT)
            {
                /*Fetch the stack pointer stored in register A10*/
                uint32 *stack_ptr = (uint32*) context_ptr->UPPER.CSA_A10.U;

                /*store STACK_CAPTURE_SIZE words*/
                for (uint8 i = 0; i < STACK_CAPTURE_SIZE; ++i)
                {
                    STACK_capture[cpu][stack_count][i] = stack_ptr[i];
                }

                ++stack_count;
            }

            /*Set pcxi to the next previous context*/
            pcxi = context_ptr->UPPER.CSA_PCXI;
        }
        else
        {
            /* LOWER contexts are from interrupts or traps
             * Reference:
             * - TriCore_TC162P_core_architecture_volume_1_of_2.pdf
             * - 4.4 Context Switching with Interrupts and Traps
             */
            CSA_capture[cpu][csa_count].LOWER.CSA_PCXI = context_ptr->LOWER.CSA_PCXI;
            CSA_capture[cpu][csa_count].LOWER.CSA_A11 = context_ptr->LOWER.CSA_A11;
            CSA_capture[cpu][csa_count].LOWER.CSA_A2 = context_ptr->LOWER.CSA_A2;
            CSA_capture[cpu][csa_count].LOWER.CSA_A3 = context_ptr->LOWER.CSA_A3;
            CSA_capture[cpu][csa_count].LOWER.CSA_D0 = context_ptr->LOWER.CSA_D0;
            CSA_capture[cpu][csa_count].LOWER.CSA_D1 = context_ptr->LOWER.CSA_D1;
            CSA_capture[cpu][csa_count].LOWER.CSA_D2 = context_ptr->LOWER.CSA_D2;
            CSA_capture[cpu][csa_count].LOWER.CSA_D3 = context_ptr->LOWER.CSA_D3;
            CSA_capture[cpu][csa_count].LOWER.CSA_A4 = context_ptr->LOWER.CSA_A4;
            CSA_capture[cpu][csa_count].LOWER.CSA_A5 = context_ptr->LOWER.CSA_A5;
            CSA_capture[cpu][csa_count].LOWER.CSA_A6 = context_ptr->LOWER.CSA_A6;
            CSA_capture[cpu][csa_count].LOWER.CSA_A7 = context_ptr->LOWER.CSA_A7;
            CSA_capture[cpu][csa_count].LOWER.CSA_D4 = context_ptr->LOWER.CSA_D4;
            CSA_capture[cpu][csa_count].LOWER.CSA_D5 = context_ptr->LOWER.CSA_D5;
            CSA_capture[cpu][csa_count].LOWER.CSA_D6 = context_ptr->LOWER.CSA_D6;
            CSA_capture[cpu][csa_count].LOWER.CSA_D7 = context_ptr->LOWER.CSA_D7;

            /*Set pcxi to the next previous context*/
            pcxi = context_ptr->LOWER.CSA_PCXI;
        }
        csa_count++;
    }
}

/*
 * This function will capture the PIEAR & PIETR registers
 * */
void piearPietrCapture(void)
{
    /*Fetch the ID of the current CPU*/
    int cpu = __mfcr(CPU_CUS_ID);
    PIEAR_capture[cpu].U = __mfcr(CPU_PIEAR);
    PIETR_capture[cpu].U = __mfcr(CPU_PIETR);
}

/*
 * This function will capture the DIEAR & DIETR registers
 * */
void diearDietrCapture(void)
{
    /*Fetch the ID of the current CPU*/
    int cpu = __mfcr(CPU_CUS_ID);
    DIEAR_capture[cpu].U = __mfcr(CPU_DIEAR);
    DIETR_capture[cpu].U = __mfcr(CPU_DIETR);
}

/*
 * This function will capture the DATR & DEADD registers
 * */
void datrDeaddCapture(void)
{
    /*Fetch the ID of the current CPU*/
    int cpu = __mfcr(CPU_CUS_ID);
    DATR_capture[cpu].U = __mfcr(CPU_DATR);
    DEADD_capture[cpu].U = __mfcr(CPU_DEADD);
}

/*
 * This function will capture the SMU AG registers
 * */
void agCapture(void)
{
    /*Fetch the ID of the current CPU*/
    int cpu = __mfcr(CPU_CUS_ID);
    for (uint8 i=0; i<12; ++i)
    {
        AG_capture[cpu][i] = MODULE_SMU.AG[i];
    }
}

/*
 * This function handle the internal protection trap
 * */
void internalProtectionHook(IfxCpu_Trap trapInfo)

{
    /*execute the context save area capture*/
    csaCapture();
    switch (trapInfo.tId)
    {
        case IfxCpu_Trap_InternalProtection_Id_memoryProtectionRead :
        case IfxCpu_Trap_InternalProtection_Id_memoryProtectionWrite :
        case IfxCpu_Trap_InternalProtection_Id_memoryProtectionPeripheralAccess :
        case IfxCpu_Trap_InternalProtection_Id_memoryProtectionNullAddress :
            /*Capture CPUx_DATR and CPUx_DEADD*/
            datrDeaddCapture();
            break;
        default:
            break;
    }

    /* Trigger a software alarm as a safe reaction */
    softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_TRAP);
}

/*
 * This function handle the instruction errors trap
 * */
void instructionErrorsHook (IfxCpu_Trap trapInfo)
{
    /*execute the context save area capture*/
    csaCapture();
    switch (trapInfo.tId)
    {
        case IfxCpu_Trap_InstructionErrors_Id_dataAddressAlignment :
        case IfxCpu_Trap_InstructionErrors_Id_invalidMemoryAddress :
            /*Capture CPUx_DATR and CPUx_DEADD*/
            datrDeaddCapture();
            break;
        default:
            break;
    }

    /* Trigger a software alarm as a safe reaction */
    softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_TRAP);
}

/*
 * This function handle the bus trap
 * */
void busHook (IfxCpu_Trap trapInfo)
{
    /*execute the context save area capture*/
    csaCapture();
    switch (trapInfo.tId)
    {
        case IfxCpu_Trap_Bus_Id_programMemoryIntegrityError :
            /*Capture CPUx_PIEAR and CPUx_PIETR*/
            piearPietrCapture();
            break;
        case IfxCpu_Trap_Bus_Id_dataMemoryIntegrityError :
            /*Capture CPUx_DIEAR and CPUx_DIETR*/
            diearDietrCapture();
            break;
        case IfxCpu_Trap_Bus_Id_dataAccessAsynchronousError :

            break;
        default:
            break;
    }

    /* Trigger a software alarm as a safe reaction */
    softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_TRAP);
}

/*
 * This function handle the NMI trap
 * */
void nonMaskableInterruptHook (IfxCpu_Trap trapInfo)
{
    /*execute the context save area capture*/
    csaCapture();

    /*capture SMU_AGx*/
    agCapture();

    /* Trigger a software alarm as a safe reaction */
    softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_TRAP);
}

/*
 * This function handle the assert trap
 * */
void assertHook (IfxCpu_Trap trapInfo)
{
    /*execute the context save area capture*/
    csaCapture();

    /*capture SMU_AGx*/
    agCapture();

    /* Trigger a software alarm as a safe reaction */
    softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_TRAP);
}
