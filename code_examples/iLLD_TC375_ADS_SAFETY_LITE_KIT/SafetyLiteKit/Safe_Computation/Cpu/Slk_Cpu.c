/**********************************************************************************************************************
 * \file Slk_Cpu.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Dummy_CPU_SBST/CPU_SBST.h"
#include "SafetyLiteKit/Dummy_CPU_SBST/CPU_SBST_Infra/CPU_SBST_Ifx_Ssw_Infra.h"
#include "SafetyLiteKit/Safe_Computation/Cpu/Slk_Cpu.h"
#include "SafetyLiteKit/Slk_Main.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ERROR_INJECTION    1

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
CpuStatusFlag g_CpuStatus; /* This global variable is used to store all of the status flag and for the GUI */
char versionCpuDummySbst[16];

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void runNonLSCpuInternalBusTest(void);
void runSbstFullTest(void);
void runSbstSlicesTest(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Readback function to compare the value inside a CPU register with the expected value and trigger a reaction
 * */
boolean slkReadbackCpuRegister(uint32 registerValue, uint32 expectedValue)
{
    if(registerValue == expectedValue)
    {
        return TRUE;
    }
    else
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_CPU_MON);
        return FALSE;
    }
}

/*
 * SM:CPU:AP_CHECK
 * The configuration is set to block access to CPU2 SFR & LPB from GETH.
 * */
void slkCpuAccessProtection()
{
    /* CPU access protection configuration */
    uint16  password = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(password);

    /* CPU2 SFR registers */
    if (apCheck == g_CpuStatus.selectCpuTest)
    {
        /* ERROR_INJECTION is set to zero but can be changed within the GUI */
        CPU2_SFR_SPROT_ACCENB_W.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE + ERROR_INJECTION;
    }
    else
    {
        CPU2_SFR_SPROT_ACCENB_W.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;
    }

    /* CPU2 LPB registers */
    CPU2_LPB_SPROT_ACCENB_R.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;

    IfxScuWdt_setSafetyEndinit(password);

    /* readback functions called to set the status flag and trigger a reaction if not matching */
    if(slkReadbackCpuRegister(CPU2_SFR_SPROT_ACCENB_W.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE) &&
       slkReadbackCpuRegister(CPU2_LPB_SPROT_ACCENB_R.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE))
    {
        g_CpuStatus.AP_CHECK_FLAG = TRUE;
    }
    else
    {
        g_CpuStatus.AP_CHECK_FLAG = FALSE;
    }
}

/*
 * SM:CPU:BUS_MPU_INITCHECK
 * The configuration is set to block access to CPU2 Data cache RAM, DLMU RAM
 * and DAM0 from GETH.
 * */
void slkCpuBusMpuInitCheck()
{
    /* BUS MPU init config */
    uint16  password = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(password);

    /* SPR registers */
    /* g_CpuStatus.ERROR_INJECTION is set to zero but can be changed within the GUI */
    if (mpuInitCheck == g_CpuStatus.selectCpuTest)
    {
        /* To flip a bit it required to flip an upper bit than 0xFF value in an editable range of the register */
        CPU2_SPR_SPROT_RGNLA0.U = SLK_CPU2_SPR_ADDR_L_CONFIG_VALUE + (ERROR_INJECTION << SLK_CPU2_FLIP_AN_EDITABLE_BIT);
    }
    else
    {
        CPU2_SPR_SPROT_RGNLA0.U = SLK_CPU2_SPR_ADDR_L_CONFIG_VALUE;
    }
    CPU2_SPR_SPROT_RGNUA0.U = SLK_CPU2_SPR_ADDR_H_CONFIG_VALUE; /* Data cache RAM (CPU2) */

    /* Set access protection for read and write */
    CPU2_SPR_SPROT_RGNACCENB0_W.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;
    CPU2_SPR_SPROT_RGNACCENB0_R.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;

    /* DLMU registers */
    CPU2_DLMU_SPROT_RGNLA0.U = SLK_CPU2_DLMU_ADDR_L_CONFIG_VALUE; /* DLMU RAM (CPU2) */
    CPU2_DLMU_SPROT_RGNUA0.U = SLK_CPU2_DLMU_ADDR_H_CONFIG_VALUE;

    /* Set access protection for read and write */
    CPU2_DLMU_SPROT_RGNACCENB0_W.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;
    CPU2_DLMU_SPROT_RGNACCENB0_R.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;

    /* No LMU */

    /* DAM0 available */
    DAM0_RGNLA0.U = SLK_CPU2_DAMRAM_L_CONFIG_VALUE; /* Access to DAM RAM (DAM0) */
    DAM0_RGNUA0.U = SLK_CPU2_DAMRAM_H_CONFIG_VALUE;
    DAM0_RGNACCENRB0.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;
    DAM0_RGNACCENWB0.U = SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE;

    IfxScuWdt_setSafetyEndinit(password);

    /* No EMEM */

    /* Readback functions called to set the status flag and trigger a reaction if not matching */
    if(slkReadbackCpuRegister(CPU2_SPR_SPROT_RGNLA0.U, SLK_CPU2_SPR_ADDR_L_CONFIG_VALUE) &&
       slkReadbackCpuRegister(CPU2_SPR_SPROT_RGNUA0.U, SLK_CPU2_SPR_ADDR_H_CONFIG_VALUE) &&
       slkReadbackCpuRegister(CPU2_SPR_SPROT_RGNACCENB0_W.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE) &&
       slkReadbackCpuRegister(CPU2_SPR_SPROT_RGNACCENB0_R.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE) &&

       slkReadbackCpuRegister(CPU2_DLMU_SPROT_RGNLA0.U, SLK_CPU2_DLMU_ADDR_L_CONFIG_VALUE) &&
       slkReadbackCpuRegister(CPU2_DLMU_SPROT_RGNUA0.U, SLK_CPU2_DLMU_ADDR_H_CONFIG_VALUE) &&
       slkReadbackCpuRegister(CPU2_DLMU_SPROT_RGNACCENB0_W.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE) &&
       slkReadbackCpuRegister(CPU2_DLMU_SPROT_RGNACCENB0_R.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE) &&

       slkReadbackCpuRegister(DAM0_RGNLA0.U, SLK_CPU2_DAMRAM_L_CONFIG_VALUE) &&
       slkReadbackCpuRegister(DAM0_RGNUA0.U, SLK_CPU2_DAMRAM_H_CONFIG_VALUE) &&
       slkReadbackCpuRegister(DAM0_RGNACCENRB0.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE) &&
       slkReadbackCpuRegister(DAM0_RGNACCENWB0.U, SLK_CPU2_ACCESS_PROTECTION_CONFIG_VALUE))
    {
        g_CpuStatus.MPU_INIT_FLAG = TRUE;
    }
    else
    {
        g_CpuStatus.MPU_INIT_FLAG = FALSE;
    }
}

/*
 * SM:CPU:CODE_MPU_CHECK
 * The configuration is set to enable the access from CPU2 to GETH code protection range 0.
 * Note: The SM required to check CPUx_* registers but it is not possible to read local CSFR registers
 * with the SRI bus. These registers will be updated by calling intrinsic function.
 * CPU2_CP* registers can be checked inside the debug.
 * */
void slkCpuCodeMpuCheck()
{
    /* Code Mpu config */
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(password);

    /* g_CpuStatus.ERROR_INJECTION is set to zero but can be changed within the GUI */
    if (codeMpuCheck == g_CpuStatus.selectCpuTest)
    {
    /* To flip a bit it required to flip an upper bit than 0xFF value in an editable range of the register */
    __mtcr(CPU_CPR0_L, SLK_CPU2_GETH_L_CONFIG_VALUE + (ERROR_INJECTION << SLK_CPU2_FLIP_AN_EDITABLE_BIT));
    }
    else
    {
        __mtcr(CPU_CPR0_L, SLK_CPU2_GETH_L_CONFIG_VALUE);
    }
    __mtcr(CPU_CPR0_U, SLK_CPU2_GETH_H_CONFIG_VALUE);
    __mtcr(CPU_CPXE_0, SLK_CPXE_ENABLE_RANGE_CONFIG_VALUE);

    IfxScuWdt_setSafetyEndinit(password);

    /* readback functions called to set the status flag and trigger a reaction if not matching */
    if(slkReadbackCpuRegister(__mfcr(CPU_CPR0_L), SLK_CPU2_GETH_L_CONFIG_VALUE) &&
       slkReadbackCpuRegister(__mfcr(CPU_CPR0_U), SLK_CPU2_GETH_H_CONFIG_VALUE) &&
       slkReadbackCpuRegister(__mfcr(CPU_CPXE_0), SLK_CPXE_ENABLE_RANGE_CONFIG_VALUE))
    {
        g_CpuStatus.CODE_MPU_FLAG = TRUE;
    }
    else
    {
        g_CpuStatus.CODE_MPU_FLAG = FALSE;
    }
}

/*
 * SM:CPU:DATA_MPU_CHECK
 * The configuration is set to enable the access from CPU2 to GETH data protection range 0.
 * Note: The SM required to check CPUx_* registers but it is not possible to read local CSFR registers
 * with the SRI bus. These registers will be updated by calling intrinsic function.
 * CPU2_CP* registers can be checked inside the debug.
 * */
void slkCpuDataMpuCheck()
{
    /* Data Mpu config */
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(password);

    if (dataMpuCheck == g_CpuStatus.selectCpuTest)
    {
    /* g_CpuStatus.ERROR_INJECTION is set to zero but can be changed within the GUI */
    __mtcr(CPU_DPR0_L, SLK_CPU2_GETH_L_CONFIG_VALUE + (ERROR_INJECTION << SLK_CPU2_FLIP_AN_EDITABLE_BIT));
    }
    else
    {
        __mtcr(CPU_DPR0_L, SLK_CPU2_GETH_L_CONFIG_VALUE);
    }
    __mtcr(CPU_DPR0_U, SLK_CPU2_GETH_H_CONFIG_VALUE);
    __mtcr(CPU_DPRE_0, SLK_CPXE_ENABLE_RANGE_CONFIG_VALUE);
    __mtcr(CPU_DPWE_0, SLK_CPXE_ENABLE_RANGE_CONFIG_VALUE);

    IfxScuWdt_setSafetyEndinit(password);

    /* readback functions called to set the status flag and trigger a reaction if not matching */
    if(slkReadbackCpuRegister(__mfcr(CPU_DPR0_L), SLK_CPU2_GETH_L_CONFIG_VALUE) &&
       slkReadbackCpuRegister(__mfcr(CPU_DPR0_U), SLK_CPU2_GETH_H_CONFIG_VALUE) &&
       slkReadbackCpuRegister(__mfcr(CPU_DPRE_0), SLK_CPXE_ENABLE_RANGE_CONFIG_VALUE) &&
       slkReadbackCpuRegister(__mfcr(CPU_DPWE_0), SLK_CPXE_ENABLE_RANGE_CONFIG_VALUE))
    {
        g_CpuStatus.DATA_MPU_FLAG = TRUE;
    }
    else
    {
        g_CpuStatus.DATA_MPU_FLAG = FALSE;
    }
}

/*
 * SM:CPU:SFR_TEST
 * Note: Every code line commented shows how registers should be changed.
 * There are also commented to show there are no changes from the reset value or after
 * startup value.
 * */
void slkCpuSfrTest()
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(password);

    __mtcr(CPU_BTV, 0xA0000100);

    __mtcr(CPU_BIV, 0x00000000);

    __mtcr(CPU_ISP, 0x00000100);

    /* PMA0 (data access)  reset value : 0x300 -> Segment 8-9, so the LMU, PFLASH and BROM are cached */
    /* if we want to uncached LMU, put the value : 0x100 */
    /* note that for PMAx, dsync and isync mechanism should be activated */
    /* PMA1 : DATA */
    /* PMA2 : Peripheral */

    __dsync();
    __mtcr(CPU_PMA0, 0x100);
    __isync();

    __dsync();
    __mtcr(CPU_PMA1, 0x100);
    __isync();

    /*PMA2 is a read-only register */

    /* By default DCACHE is disabled but activate in __StartUpSoftware to allow program cache access */
    __mtcr(CPU_PCON0, 0x00000000);

    /* By default DCACHE is disabled but activate in __StartUpSoftware to allow Dcache / DRB access */
    __mtcr(CPU_DCON0, 0x00000000);

    /* SEGEN is an error injection register so it will not be modified here */
/*   __mtcr(CPU_SEGEN, 0x00000000); */

/* ----------------------------------------------SAFETY ENDINIT -------------------------------------*/

    /* SMACON.IODT refers to the CPU Store Buffer:
     * Note: Enable this bit, disable the store buffer so this configuration should be not done in normal case
     * The store buffer increase the speed of CPU it don't care of cache misses
     */
   __mtcr(CPU_SMACON, 0x00000000);

    /* SYSCON.BHALT is different than reset because it is coming after boot, refers to Boot Halt in the User Manual. */

    if(sfrTest == g_CpuStatus.selectCpuTest )
    {
        /* Set the COMPAT register to endinit protected */
        __mtcr(CPU_COMPAT, 0xFFFFFFEF + (ERROR_INJECTION << SLK_FLIP_THE_SYSCON_REGISTER_TO_ENDINIT));
    }
    else
    {
        __mtcr(CPU_COMPAT, 0xFFFFFFEF); /* Set the COMPAT register to not safety endinit protected */
    }

    IfxScuWdt_setSafetyEndinit(password);

    /* If the SYSCON register is set to not safety endinit protected, the register can be modify outside safety endinit.*/
    __mtcr(CPU_SYSCON, 0x0);

    /* Readback function */
    /* CPU base trap vector, CPU base interrupt vector and CPU interrupt stack pointer are
     * redefined in file with a different value from the reset
     */
    if(slkReadbackCpuRegister(__mfcr(CPU_BTV), SLK_CPU2_BTV_CONFIG_VALUE) &&
       slkReadbackCpuRegister(__mfcr(CPU_BIV), SLK_CPU2_BIV_CONFIG_VALUE) &&
      slkReadbackCpuRegister(__mfcr(CPU_ISP), SLK_CPU2_ISP_CONFIG_VALUE) &&
      /* PMA0 (data access)  reset value : 0x300 -> Segment 8-9, so the LMU, PFLASH and BROM are cached */
      slkReadbackCpuRegister(__mfcr(CPU_PMA0), SLK_CPU2_PMA0_CONFIG_VALUE) &&
      /* PMA0 (code access)  reset value : 0x300 -> Segment 8-9, so the LMU, PFLASH and BROM are cached */
      slkReadbackCpuRegister(__mfcr(CPU_PMA1), SLK_CPU2_PMA1_CONFIG_VALUE) &&
      /*PMA2 is a read-only register */
      slkReadbackCpuRegister(__mfcr(CPU_PMA2), SLK_CPU2_PMA2_CONFIG_VALUE) &&
      /* By default PCACHE is disabled but activate in __StartUpSoftware to allow program cache access */
      slkReadbackCpuRegister(__mfcr(CPU_PCON0), SLK_CPU2_PCON0_CONFIG_VALUE) &&
      /* By default DCACHE is disabled but activate in __StartUpSoftware to allow program cache access */
      slkReadbackCpuRegister(__mfcr(CPU_DCON0), SLK_CPU2_DCON0_CONFIG_VALUE) &&
      /* SEGEN is an error injection register so it will not be modified here */
      /* slkReadbackCpuRegister(__mfcr(CPU_SEGEN), SLK_CPU2_SEGEN_CONFIG_VALUE) && */

      /* Activate the CPU store buffer with SMACON.IODT */
      slkReadbackCpuRegister(__mfcr(CPU_SMACON), SLK_CPU2_SMACON_CONFIG_VALUE) &&
      /* Set the SYSCON register to endinit protected */
      slkReadbackCpuRegister(__mfcr(CPU_COMPAT), SLK_CPU2_COMPAT_CONFIG_VALUE) &&
      /* Memory protection will be not activated because there are data transfer between CPUs */
      slkReadbackCpuRegister(__mfcr(CPU_SYSCON), SLK_CPU2_SYSCON_CONFIG_VALUE) &&
      /* Entry and exit time are set to 0, as disable to not add time after the CPU is receiving
       * a trap request and before the exit of the trap handler with an RFE instruction
       */
      slkReadbackCpuRegister(__mfcr(CPU_TPS_EXTIM_ENTRY_LVAL), SLK_CPU2_TPS_EXTIM_ENTRY_LVAL_CONFIG_VALUE) &&
      slkReadbackCpuRegister(__mfcr(CPU_TPS_EXTIM_EXIT_LVAL), SLK_CPU2_TPS_EXTIM_EXIT_LVAL_CONFIG_VALUE))
    {
        g_CpuStatus.SFR_FLAG = TRUE;
    }
    else
    {
        g_CpuStatus.SFR_FLAG = FALSE;
    }
}

/*
 * This function run all Cpu safe computation safety measures
 * */
void runCpuSafeComputation (void)
{
    static uint8 lastSlkSelectCpuError = noneSelected; /* This flag is used to store the CPU error selected in the GUI */

    /* run SM:CPU:SFR_TEST each DTI */
    slkCpuSfrTest();

    /* Run again one CPU SM if selected in the GUI */
    if (lastSlkSelectCpuError != g_CpuStatus.selectCpuTest)
    {
        /* check which SM is selected inside the GUI to inject an error */
        switch (g_CpuStatus.selectCpuTest)
        {
            case noneSelected :
                break;
            case apCheck :
                slkCpuAccessProtection();
                break;
            case mpuInitCheck :
                slkCpuBusMpuInitCheck();
                break;
            case codeMpuCheck :
                slkCpuCodeMpuCheck();
                break;
            case dataMpuCheck :
                slkCpuDataMpuCheck();
                break;
            case sfrTest :
                /* sfr test called each DTi already */
                break;
        }
        lastSlkSelectCpuError = g_CpuStatus.selectCpuTest;
    }
}

/*
 * This is the pseudo code of SM:CPU:INTERNAL_BUS_MONITOR
 * from the appendix B in the safety manual.
 * Note: This code was adapted to fit to a Tasking compilation and not a GCC one.
 */
boolean nonLSCpuInternalBusTest (uint32 * csa_area, uint32 pattern)
{
   boolean result; /* fail = 0, success = 1 */
   uint32 ie_prev; /* previous ICR.IE state */
   uint64 tmp64;
   uint32 tmp_pcxi;
   uint32 tmp_psw;
   void *  tmp_a11;

   /* Disable Interrupts; ie_prev contains previous interrupt enable state */
   __asm ( "disable %0" : "=d"(ie_prev) );

   /* Synchronize Data - memory coherency => forces all Cached Data to be written to memory */
   __asm  ("dsync");
   /**
    Global List
    ------------
    0 -> result
    1 -> tmp64
    2 -> tmp_pcxi
    3 -> tmp_psw
    4 -> tmp_a11
    5 -> pattern
    6 -> csa_area
   **/

   __asm  (
             "PSW .equ 0xFE04 \n\t"
             "PCXI .equ 0xFE00 \n\t"
             "mov   d2,   %5  \n\t"      /* move "pattern" to lower 32 bits of "tmp64"*/
             "mov.aa %4, a11 \n\t"       /* move A11 to "tmp_a11" -> copy for future comparison*/
             "mov   d3,   %5  \n\t"      /* move "pattern" to higher 32 bits of "tmp64"*/
             "mfcr %2, #PCXI   \n\t"     /* move PCXI to "tmp_pcxi" -> copy for future comparison*/
             "mov   d8,  %5  \n\t"       /* move "pattern" to D8*/
             "mfcr %3, #PSW    \n\t"     /* move PSW to "tmp_psw" -> copy for future comparison*/
             "mov   D9,  %5  \n\t"       /* move "pattern" to D9*/
             "mov.a A10, %5  \n\t"       /* move "pattern" to A10*/
             "mov   D10, %5  \n\t"       /* move "pattern" to D10*/
             "mov   D11, %5  \n\t"       /* move "pattern" to D11*/
             "mov.a A12, %5  \n\t"       /* move "pattern" to A12*/
             "mov   D12, %5  \n\t"       /* move "pattern" to D12*/
             "mov.a A13, %5  \n\t"       /* move "pattern" to A13*/
             "mov   D13, %5  \n\t"       /* move "pattern" to D13*/
             "mov.a A14, %5  \n\t"       /* move "pattern" to A14*/
             "mov   D14, %5  \n\t"       /* move "pattern" to D14*/
             "mov.a A15, %5  \n\t"       /* move "pattern" to A15*/
             "mov   D15, %5  \n\t"       /* move "pattern" to D15*/

             "st.d  [%6]0x44, e2 \n\t"   /* store "tmp64" to "csa_area"+0x44 => offset 68*/
             "stucx [%6]0x0       \n\t"
             /* store Upper Context (A10-A15, D8-D15, PSW, PCXI) to  "csa_area"+0x00 => 64 bytes*/

             "mov   D2,   #0 \n\t"       /* zero lower 32 bits of "tmp64"*/
             "mov   D3,   #0 \n\t"       /* zero higher 32 bits of "tmp64"*/
             "mov   d8,  #0 \n\t"        /* zero contents of D8"*/
             "mov   d9,  #0 \n\t"        /* zero contents of D9*/
             "mov.a a10, #0 \n\t"        /* zero contents of A10*/
             "mov   d10, #0 \n\t"        /* zero contents of D10*/
             "mov   d11, #0 \n\t"        /* zero contents of D11*/
             "mov.a a12, #0 \n\t"        /* zero contents of A12*/
             "mov   d12, #0 \n\t"        /* zero contents of D12*/
             "mov.a a13, #0 \n\t"        /* zero contents of A13*/
             "mov   d13, #0 \n\t"        /* zero contents of D13*/
             "mov.a a14, #0 \n\t"        /* zero contents of A14*/
             "mov   d14, #0 \n\t"        /* zero contents of D14*/
             "mov.a a15, #0 \n\t"        /* zero contents of A15*/
             "mov   d15, #0 \n\t"        /* zero contents of D15*/

             "dsync \n\t"
             /* Synchronize Data - memory coherency => forces all Cached Data to be written to memory */
             "ld.d e2, [%6]0x44 \n\t"    /* load DOUBLE-WORD "tmp64" from "csa_area"+0x44 => offset 68*/
             "lducx     [%6]0x0  \n\t"   /* load Upper Context (A10-A15, D8-D15, PSW, PCXI) from  "csa_area"+0x00*/

             "eq.a   %0, %4, a11 \n\t"   /* "result" = (A11 == "tmp_a11") */
             "and.eq %0, %5, d2   \n\t"  /* "result" &= (lower 32 bits of "tmp64" == "pattern") */
             "and.eq %0, %5, d3   \n\t"  /* "result" &= (higher 32 bits of "tmp64" == "pattern") */
             "and.eq %0, %5, d8  \n\t"   /* "result" &= (D8 == "pattern") */
             "and.eq %0, %5, d9  \n\t"   /* "result" &= (D9 == "pattern") */
             "and.eq %0, %5, d10 \n\t"   /* "result" &= (D10 == "pattern") */
             "mov.d  d10, a10 \n\t"      /* move A10 to D10 for comparison" */
             "and.eq %0, %5, d11 \n\t"   /* "result" &= (D11 == "pattern" */
             "and.eq %0, %5, d12 \n\t"   /* "result" &= (D12 == "pattern") */
             "mov.d  d12, a12 \n\t"      /* move A12 to D12 for comparison" */
             "and.eq %0, %5, d13 \n\t"   /* "result" &= (D13 == "pattern") */
             "mov.d  d13, a13 \n\t"      /* move A13 to D13 for comparison" */
             "and.eq %0, %5, d14 \n\t"   /* "result" &= (D14 == "pattern") */
             "mov.d  d14, a14 \n\t"      /* move A14 to D14 for comparison" */
             "and.eq %0, %5, d15 \n\t"   /* "result" &= (D15 == "pattern") */
             "mov.d  d15, a15 \n\t"      /* move A15 to D15 for comparison" */
             "and.eq %0, %5, d10 \n\t"   /* "result" &= (D10(actually A10) == "pattern") */
             "and.eq %0, %5, d12 \n\t"   /* "result" &= (D12(actually A12) == "pattern") */
             "and.eq %0, %5, d13 \n\t"   /* "result" &= (D13(actually A13) == "pattern") */
             "and.eq %0, %5, d14 \n\t"   /* "result" &= (D14(actually A14) == "pattern") */
             "and.eq %0, %5, d15 \n\t"   /* "result" &= (D15(actually A15) == "pattern") */

             "ld.d e2, [%6]0x0 \n\t"     /* load DOUBLE-WORD "tmp64" from "csa_area"+0x0 => offset 0 (PCXI, PSW)*/
             "and.eq %0, D2, %2 \n\t"    /* "result" &= (lower 32 bits of "tmp64" == "tmp_pcxi") */
             "and.eq %0, D3, %3 \n\t"    /* "result" &= (higher 32 bits of "tmp64" == "tmp_psw") */

             /* Global List */
             : "=&d"(result), "=&e"(tmp64), "=&d"(tmp_pcxi), "=&d"(tmp_psw), "=&a"(tmp_a11) /* output */
             : "d"(pattern), "a"(csa_area)                                                  /* input  */
             : "d8", "d9", "d10", "d11", "d12", "d13", "d14", "d15", "a12", "a13", "a14", "a15"
             /* registers not used to store inputs or output */
             );


   __asm ( "restore %0" : : "d"(ie_prev) ); /* Restore interrupt state */

   return result;
}

/*
 * run internal bus test for non lockstep CPU
 * The SBST required to implement SM:CPU:INTERNAL_BUS_MONITOR after each FTTI test execution
 * */
void runNonLSCpuInternalBusTest()
{
    boolean testResult;

    /* The SBST required to implement SM:CPU:INTERNAL_BUS_MONITOR after each FTTI test execution */
    testResult = nonLSCpuInternalBusTest((uint32 *)CPU2_PSPR_BASE_ADDR, SLK_PATTERN_A);

    testResult = nonLSCpuInternalBusTest((uint32 *)CPU2_PSPR_BASE_ADDR, SLK_PATTERN_5);

    testResult = nonLSCpuInternalBusTest((uint32 *)CPU2_DLMU_BASE_ADDR, SLK_PATTERN_A);

    testResult = nonLSCpuInternalBusTest((uint32 *)CPU2_DLMU_BASE_ADDR, SLK_PATTERN_5);

   if(FALSE == testResult)
   {
       softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_SBST);
   }
}

/* This function run the SBST SLICES test
 * */
void runSbstSlicesTest(void)
{
    static uint32 sbst_cpu_state = 0;     /* initialize SBST run state variable */

    switch (sbst_cpu_state)
    {
        case 0 :
            if (g_CpuStatus.sbstStatus.SBST_ERROR == FALSE)
            {
                SBST_CPU_Seeding_CRC_Value();
            }
            else
            {
                SBST_CPU_Seeding_CRC_Value_Fault_Inj();
                g_CpuStatus.sbstStatus.SBST_ERROR = FALSE;
            }
            SBST_CPU_Slice0();
            break;

        case 1 :
            SBST_CPU_Slice1();
            break;

        case 2 :
            SBST_CPU_Slice2();
            break;

        case 3 :
            SBST_CPU_Slice3();
            break;

        case 4 :
            SBST_CPU_Slice4();
            break;

        case 5 :
            SBST_CPU_Slice5();
            break;

        case 6 :
            SBST_CPU_Slice6();
            break;

        case 7 :
            SBST_CPU_Slice7();
            break;

        case 8 :
            SBST_CPU_Slice8();
            /* check the crc result */
            if (SBST_CPU_RESULT != SBST_CPU_OK)
            {
                softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_SBST);
            }

            /* The SBST required to implement SM:CPU:INTERNAL_BUS_MONITOR after each FTTI test execution */
            runNonLSCpuInternalBusTest();
            break;

        default:
            break;
    }
    sbst_cpu_state = (sbst_cpu_state + 1) % 9;
}

/*
 * This function run the SBST Full test
 * */
void runSbstFullTest(void)
{
    if(g_CpuStatus.sbstStatus.SBST_ERROR == FALSE)
    {
        SBST_CPU_Seeding_CRC_Value();
    }
    else
    {
        SBST_CPU_Seeding_CRC_Value_Fault_Inj();
        g_CpuStatus.sbstStatus.SBST_ERROR = FALSE;
    }

    SBST_CPU_runtest();

    /* check the crc result */
    if (SBST_CPU_RESULT != SBST_CPU_OK)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_SBST);
    }

    /* The SBST required to implement SM:CPU:INTERNAL_BUS_MONITOR after each FTTI test execution */
    runNonLSCpuInternalBusTest();
}

/*
 * This function is used to run SBST within the DTI
 * base on SBST test selection, the select test will be run.
 * */
void runSBST(void)
{
   switch (g_CpuStatus.sbstStatus.sbstTestSelection)
   {
       case defaultTest:
           runSbstFullTest();
           break;

       case SbstFullTest:
           runSbstFullTest();
           break;

       case SbstSlicesTest:
           runSbstSlicesTest();
           break;

       default:
           break;
   }
}

/*
 * This function is to initialize SBST
 * */
void initSBST()
{
    /* get the dummy SBST version */
    const char* p_version = SBST_CPU_version();

    g_CpuStatus.sbstStatus.sbstTestSelection = defaultTest;

    for (uint8 i = 0; i<16; i++)
    {
        versionCpuDummySbst[i] = p_version[i];
    }
    /* Initiate the seeding value for CRC */
    SBST_CPU_Seeding_CRC_Value();

    /* Execute the SBST test */
    SBST_CPU_runtest();

    /* Check the CRC result */
    if(SBST_CPU_RESULT != SBST_CPU_OK)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_SBST);
    }
}
