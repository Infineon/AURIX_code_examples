/**********************************************************************************************************************
 * \file Slk_Dma.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Safe_Computation/Slk_Dma.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxDma.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* DMA different error types */
#define DMA_ADDRESS_CRC_ERROR           0x00000001U
#define DMA_DATA_CRC_ERROR              0x00000002U
#define DMA_TIMING_ERROR                0x00000004U
#define DMA_ME0_ERROR                   0x00000008U
#define DMA_ME1_ERROR                   0x00000010U
#define DMA_TRL_ERROR                   0x00000020U
#define DMA_DATA_WRONG_ERROR            0x00000040U
#define DMA_ME_ERRORS_MASK              0x07330000U

#define THRESHOLD_MIN_TIMESTAMP_COUNT   10             /* Minimum threshold time stamp count */
#define THRESHOLD_MAX_TIMESTAMP_COUNT   20             /* Maximum threshold time stamp count */

#define BUFFER_SIZE                     16             /* Dma source & destination buffer size */

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxDma_Dma_Channel chn;                 /* dma channel variable */

uint32 source[BUFFER_SIZE];             /* Source buffer */
uint32 destination[BUFFER_SIZE + 1];    /* Destination buffer, plus 1 is for time stamp value. */
uint32 wrongDestination = (uint32)&MODULE_CAN0; /* The address of the memory location of an uninitialized
                                                                          module is used as wrongDestination address */
static volatile uint32 sdcrc, rdcrc;         /* Read-data and Source-Destination CRC32 results */
static uint32  transactionStartTimeStamp;    /*start time of dma transaction                                      */
SafeComputationDma g_DmaErrorInjection;
uint32 g_dmaErrorStatus = 0;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(isrRP0DMA, 0, ISR_PRIORITY_DMARP0ISR);
IFX_INTERRUPT(isrCH0DMA, 0, ISR_PRIORITY_DMACH0ISR);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * DMA Error Service Request
 * */
void isrRP0DMA(void)
{
    /* ISR implementing SM:DMA:ERROR_HANDLING for RP0 */

    uint32 ME0ErrorStatus = MODULE_DMA.ME0.ERRSR.U;
    uint32 ME1ErrorStatus = MODULE_DMA.ME1.ERRSR.U;

    /* Collect errors */
    if(ME0ErrorStatus != 0x0)
    {
        supervisionSMDMA(&chn, DMA_ME0_ERROR);
        IfxDma_clearErrorFlags(chn.dma, IfxDma_MoveEngine_0, DMA_ME_ERRORS_MASK);
    }

    if(ME1ErrorStatus != 0x0)
    {
        supervisionSMDMA(&chn, DMA_ME1_ERROR);
        IfxDma_clearErrorFlags(chn.dma, IfxDma_MoveEngine_1, DMA_ME_ERRORS_MASK);
    }

    if(MODULE_DMA.TSR[3].B.TRL != 0x0)
    {
        supervisionSMDMA(&chn, DMA_TRL_ERROR);
        IfxDma_clearChannelTransactionRequestLost(chn.dma, chn.channelId);
    }
}

/*
 * DMA Channel Service Request
 * */
void isrCH0DMA(void)
{
    uint32 dmaTotalTimestampCount;

    /* clear error */
    g_dmaErrorStatus = 0;
    dmaTotalTimestampCount = destination[BUFFER_SIZE] - transactionStartTimeStamp;

    /* Implement SM:DMA:ADDRESS_CRC */
    if (chn.dma->CH[IfxDma_ChannelId_10].SDCRCR.U != sdcrc)
    {
        g_dmaErrorStatus |= DMA_ADDRESS_CRC_ERROR;
    }

    /* Implement SM:DMA:DATA_CRC */
    else if (chn.dma->CH[IfxDma_ChannelId_10].RDCRCR.U != rdcrc)
    {
        g_dmaErrorStatus |= DMA_DATA_CRC_ERROR;
    }

    /* Implement SM:DMA:TIMESTAMP
     * Time taken of data move source to destination
     * last value of destination buffer is time stamp
     * */
    else if ((dmaTotalTimestampCount >= THRESHOLD_MAX_TIMESTAMP_COUNT) ||
             (dmaTotalTimestampCount <= THRESHOLD_MIN_TIMESTAMP_COUNT))
    {
        g_dmaErrorStatus |= DMA_TIMING_ERROR;
    }
    else
    {
        /*check if the source and destination data match*/
        for (int i = 0; i < BUFFER_SIZE; i++)
        {
            if (source[i] != destination[i])
            {
                g_dmaErrorStatus |= DMA_DATA_WRONG_ERROR;
            }
        }
    }

    /* Call SM:DMA:SUPERVISION */
    if (g_dmaErrorStatus != 0)
    {
        supervisionSMDMA(&chn, g_dmaErrorStatus);
    }
}

/*
 * SM:DMA:SUPERVISION
 * */
void supervisionSMDMA(IfxDma_Dma_Channel *chn, uint32 error)
{
    /* User function, must take the right action depending on application requirements:
     *      - alarms
     *      - DMA CH reset
     *      - System reset
     *      - ...
     *  */
    softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DMA);
}

IFX_INLINE uint32 __crc32b_SafetyLiteKitDMA(uint32 b, uint32 a)
{
    uint32 returnvalue = 0;

    __asm__ volatile ("CRC32.B %0,%1,%2" : "=d" (returnvalue) : "d"(b), "d"(a));

    return returnvalue;
}

/* sadr: Source address start (assumes incrementing)
 * dadr: Destination address start (assumes incrementing)
 * transfers: No:of transfers in the transaction as defined by TREL
 * moves: No:of moves in each transfer as defined by BLKM.
 * chdw_bytes: Channel data width in bytes, as defined by CHDW.
 * accumulate: 0:continue accumulating from previously computed value; 1: start anew
 */
void accumulateCRC(uint8* sadr, uint8* dadr, uint32 transfers, uint32 moves, uint32 chdw_bytes, uint32 accumulate)
{
    int i;
    static uint32 a, bsd = 0, brd = 0;

    if(!accumulate)
    {
        a = 0;
        bsd = 0;
        brd = 0;
        sdcrc = 0;
        rdcrc = 0;
    }

    for (i = 0; i < transfers*moves; i++)
    {
        /* The CRC of SDCRC (Source Destination CRC) is calculated by (1st Source Address, 1st Destination Address,
         * 2nd Source,... Last Destination Address) */
        a = (uint32)(sadr + i*chdw_bytes);
        bsd = __crc32(bsd, a);

        a = (uint32)(dadr + i*chdw_bytes);
        bsd = __crc32(bsd, a);

        /* DMA_TC.039: RDCRC not supported for 8-bit & 16-bit transfers
           Available only from TC38A & TC39B onwards */
        if(chdw_bytes >= 4)
        {
            /*The CRC for read data is calculated by (1st read data, 2nd ,... last read data)*/
            a = *(uint32*)(sadr + i*chdw_bytes);
            brd = __crc32(brd, a);
        }
        else if (chdw_bytes == 2)
        {
            a = *(uint8*)(sadr + i*chdw_bytes + 1);
            brd = __crc32b_SafetyLiteKitDMA(brd, a);
            a = *(uint8*)(sadr + i*chdw_bytes);
            brd = __crc32b_SafetyLiteKitDMA(brd, a);
        }
        else if (chdw_bytes == 1)
        {
            a = *(uint8*)(sadr + i*chdw_bytes);
            brd = __crc32b_SafetyLiteKitDMA(brd, a);
        }
    }

    sdcrc = bsd;
    rdcrc = brd;
}

/*
 * This function initialize and transfer DMA data and is called periodically
 */
void initAndRunDmaTransaction(void)
{
    uint32 i;

    /* Create module config */
    IfxDma_Dma_Config dmaConfig;
    IfxDma_Dma_initModuleConfig(&dmaConfig, &MODULE_DMA);

    /* Initialize module */
    IfxDma_Dma dma;
    IfxDma_Dma_initModule(&dma, &dmaConfig);

    /* Initial configuration for all channels */
    IfxDma_Dma_ChannelConfig cfg;
    IfxDma_Dma_initChannelConfig(&cfg, &dma);

    /* Following configuration is used by all channels */
    cfg.transferCount   = BUFFER_SIZE;
    cfg.requestMode     = IfxDma_ChannelRequestMode_completeTransactionPerRequest;
    cfg.moveSize        = IfxDma_ChannelMoveSize_32bit;
    /* Enable appending the DMA time stamp */
    cfg.timestampEnabled =  TRUE;
    cfg.channelId       = IfxDma_ChannelId_10;
    cfg.sourceAddress   = (uint32)source;

    /* SM:DMA:ADDRESS_CRC : compute the expected address CRC stored sdcrc */
    if(TRUE == g_DmaErrorInjection.injectDestinationError)
    {
        /* Destination is an uninitialized module */
        cfg.destinationAddress = (uint32)wrongDestination;
        g_DmaErrorInjection.injectDestinationError = FALSE;
    }
    else
    {
        cfg.destinationAddress = (uint32)destination;
    }

    IfxDma_Dma_initChannel(&chn, &cfg);
    IfxDma_enableChannelInterrupt(chn.dma, chn.channelId);

    IfxDma_enableMoveEngineSourceError(&MODULE_DMA, IfxDma_MoveEngine_0);
    IfxDma_enableMoveEngineSourceError(&MODULE_DMA, IfxDma_MoveEngine_1);

    IfxDma_enableMoveEngineDestinationError(&MODULE_DMA, IfxDma_MoveEngine_0);
    IfxDma_enableMoveEngineDestinationError(&MODULE_DMA, IfxDma_MoveEngine_1);

    /* Prepare buffers */
    for (i = 0; i < BUFFER_SIZE; i++)
    {
        source[i] = i*0x10000000 + (i+1);
        destination[i] = 0xdeadbeef;
    }

    /* Enable error interrupts */
    MODULE_DMA.ME0.EER.B.EDER = 1U;
    MODULE_DMA.ME0.EER.B.ESER = 1U;
    MODULE_DMA.ME0.EER.B.ELER = 1U;

    MODULE_DMA.ME1.EER.B.EDER = 1U;
    MODULE_DMA.ME1.EER.B.ESER = 1U;
    MODULE_DMA.ME1.EER.B.ELER = 1U;

    MODULE_DMA.TSR[cfg.channelId].B.ETRL = 1U;

    volatile Ifx_SRC_SRCR *SRC_DMA_ER0;
    SRC_DMA_ER0 = &MODULE_SRC.DMA.DMA[0].ERR[3];
    IfxSrc_init(SRC_DMA_ER0, IfxSrc_Tos_cpu0, ISR_PRIORITY_DMARP0ISR);
    IfxSrc_enable(SRC_DMA_ER0);

    volatile Ifx_SRC_SRCR *SRC_DMA_CH0;
    SRC_DMA_CH0 = &MODULE_SRC.DMA.DMA[0].CH[cfg.channelId];
    IfxSrc_init(SRC_DMA_CH0, IfxSrc_Tos_cpu0, ISR_PRIORITY_DMACH0ISR);
    IfxSrc_enable(SRC_DMA_CH0);

    /* SM:DMA:ADDRESS_CRC : compute the expected address CRC stored sdcrc
     * SM:DMA:DATA_CRC    : compute the expected data CRC stored rdcrc */
    accumulateCRC((uint8 *)source, (uint8 *)destination, BUFFER_SIZE, 1, 4, 0);

    /* CRC error injection
     * SM:DMA:DATA_CRC    : compute the expected data CRC stored rdcrc */
    if(TRUE == g_DmaErrorInjection.injectCrcError )
    {
        /* Corrupt CRC */
        rdcrc = rdcrc -1;
        g_DmaErrorInjection.injectCrcError = FALSE;
    }

    /* SM:DMA:TIMESTAMP */
    transactionStartTimeStamp = IfxDma_getTimestamp(chn.dma);
    /* check if time stamp error flag is on */
    if (TRUE == g_DmaErrorInjection.injectTimestampError)
    {
        transactionStartTimeStamp = transactionStartTimeStamp - 5; /* corrupt time stamp current value i.e -5 or +5 */
        g_DmaErrorInjection.injectTimestampError = FALSE;
    }

    /* Start DMA transaction */
    IfxDma_Dma_startChannelTransaction(&chn);
}
