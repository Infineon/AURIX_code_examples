/**********************************************************************************************************************
 * \file Slk_Ssw_Smu_Reg_Monitor_Test.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU/FSP/SMU_stdby_FSP.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Smu_Reg_Monitor_Test.h"
#include "IfxSmu.h"
#include "IfxSmu_cfg.h"
#include "IfxMtu.h"
#include "IfxIom.h"
#include "IfxIom_reg.h"
#include "IfxDma_reg.h"
#include "IfxStm.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define SMU_REG_MONITOR_TEST_MAX_TIME_SEC 2e-6 /* Safety Manual recommends 2Âµs, assuming default clock configurations*/
#define TYPE_SMU_CORE   0
#define TYPE_SMU_STDBY  1

#ifdef IFXEMEM_REG_H
#define NUM_UNCORRECTABLE_ERRORS     14
#else
#define NUM_UNCORRECTABLE_ERRORS     13
#endif

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/
typedef enum
{
    /* Following alarms were triggered during the execution of the REG_MONITOR_TEST of the specific module:
     * (The safety mechanisms listed in the brackets are the mechanisms which are related to the
     * SM:SMU:REG_MONITOR_TEST of the specific module)
     */
    smuRegMonitorModuleMTU = 0,             /* ALM6[0] (SM[HW]:VMT:FPI_WRITE_MONITOR, (SM[HW]:VMT:REG_MONITOR)),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleIOM = 1,             /* ALM6[1] (SM[HW]:GTM:FPI_WRITE_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleIR = 2,              /* ALM6[2] (SM[HW]:IR:FPI_WRITE_MONITOR, SM[HW]:IR:REG_MONITOR),
                                                * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleEMEM = 3,            /* ALM6[3] (SM[HW]:EMEM:FPI_WRITE_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleSCUSRU = 4,          /* ALM6[4] (SM[HW]:RESET:FF_MONITORING, SM[HW]:RESET:FPI_WRITE_MONITOR,
                                                 * SM[HW]:SCU:FPI_WRITE_MONITOR, SM[HW]:SCU:REG_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModulePMS = 5,             /* ALM6[5] (SM[HW]:PMS:REG_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleDMA = 6,             /* ALM6[6] (SM[HW]:DMA:REQUEST_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleSMUcore = 7,         /* ALM6[7] (SM[HW]:SMU:FPI_WRITE_MONITOR, SM[HW]:SMU:REG_MONITOR_TEST),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleCERBERUS = 8,        /* ALM6[23] (SM[HW]:DEBUG:CFG_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleSYSPllPERPll = 9,   /* ALM6[8] (SM[HW]:CLOCK:CFG_MONITOR, SM[HW]:CLOCK:FPI_WRITE_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    smuRegMonitorModuleCCU = 10,           /* ALM6[24] & ALM6[25] & ALM10[20] (SM[HW]:CLOCK:CFG_MONITOR),
                                                 * (ALM10[21], alarm triggered during test of every module) */
    numSmuRegMonitorModule = 11
} SmuRegMonitorModule;

typedef struct
{
    uint8   smuType;
    uint16  alarmName;
} SafetyFfUncorrectableErrorsType;

SafetyFfUncorrectableErrorsType safetyFfUncorrectableErrors[NUM_UNCORRECTABLE_ERRORS] =
{
    {TYPE_SMU_CORE,     IfxSmu_Alarm_MTU_Safety_FfUncorrectableErrorDetected                },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_IOM_Safety_FfUncorrectableErrorDetected                },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_IR_Safety_FfUncorrectableErrorDetected                 },
#ifdef IFXEMEM_REG_H
    {TYPE_SMU_CORE,     IfxSmu_Alarm_EMEM_Safety_FfUncorrectableErrorDetected               },
#endif
    {TYPE_SMU_CORE,     IfxSmu_Alarm_SCU_Safety_FfUncorrectableErrorDetected                },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_PMS_Safety_FfUncorrectableErrorDetected                },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_DMA_Safety_FfUncorrectableErrorDetected                },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_SMU_core_Safety_FfUncorrectableErrorDetected           },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_SMU_Safety_FfUncorrectableErrorDetected                },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_CERBERUS_Safety_FfUncorrectableErrorDetected           },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_SYS_PLL_PER_PLL_Safety_FfUncorrectableErrorDetected    },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_CCU_Safety_FfUncorrectableErrorDetected                },
    {TYPE_SMU_CORE,     IfxSmu_Alarm_CCU_Safety_FfCorrectableErrorDetected                  },
    {TYPE_SMU_STDBY,    smuStdbyAlarmSafetyFlipFlopUncorrectableError                }
};

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Register monitor test of SMU module
 * SM:SMU:REG_MONITOR_TEST
 * */
void slkSswSmuRegMonitorTest(void)
{
    g_SlkStatus.smuStatus.smuSafetyFlipFlopTriggerTestSts         = NA;
    g_SlkStatus.smuStatus.smuSafetyFlipFlopTestResultCheckSts     = NA;
    g_SlkStatus.smuStatus.smuSafetyFlipFlopTestAlarmFlagClearSts  = NA;
    g_SlkStatus.smuStatus.regMonitorTestSmu  = NA;
    g_SlkStatus.unlockConfig = TRUE;
    g_SlkStatus.smuStatus.unlockConfigRegisterSMU = NA;

    /* Enable all clocks */
    boolean mtuWasEnabled = IfxMtu_isModuleEnabled();
    if (mtuWasEnabled == FALSE)
    {
        IfxMtu_enableModule();
    }
    boolean iomWasEnabled = TRUE;
    if(MODULE_IOM.CLC.B.DISS != 0)
    {
        iomWasEnabled = FALSE;
        IfxIom_enableModule(&MODULE_IOM, 0x1);
    }
#ifdef IFXEMEM_REG_H
    boolean ememWasEnabled = IfxEmem_isModuleEnabled();
    if(ememWasEnabled == FALSE)
    {
        IfxEmem_enableModule(&MODULE_EMEM);
        IfxEmem_setUnlockMode(&MODULE_EMEM);
    }
#endif
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    boolean dmaWasEnabled = TRUE;
    if(MODULE_DMA.CLC.B.DISS != 0)
    {
        dmaWasEnabled = FALSE;
        DMA_CLC.B.DISS = 0;
    }
    boolean smuWasEnabled = TRUE;
    if(MODULE_SMU.CLC.B.DISS != 0)
    {
        smuWasEnabled = FALSE;
        SMU_CLC.B.DISS = 0;
    }
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Unlock SMU registers for configuration */
    g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SlkStatus.unlockConfig == TRUE)
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    uint64 tStart, tExecution;
    float64 tExecutionInSec;

    boolean smuRegMonitorTestPassed = TRUE;

    /* Iterate through all modules listed in the SmuRegMonitorModule enumeration */
    for (SmuRegMonitorModule testModeEnable = smuRegMonitorModuleMTU; testModeEnable < numSmuRegMonitorModule;
            testModeEnable++)
    {
#ifndef IFXEMEM_REG_H
        /* If EMEM is not available skip the loop iteration for testModeEnable == EMEM */
        if(testModeEnable == smuRegMonitorModuleEMEM)
        {
            continue;
        }
#endif

        /* Enable the test */
        IfxSmu_setRegMonTestModeEnable(testModeEnable);

        tStart = IfxStm_get(&MODULE_STM0);

        /* Wait until test is done, as long test is not finished measure the execution time */
        uint32 timeout = 0xfff;
        do{
            tExecution = IfxStm_get(&MODULE_STM0) - tStart;
            timeout--;
        }
        while(!(IfxSmu_getRegisterMonitorStatus() & (1U << testModeEnable)) && (timeout > 0));

        /* Disable the test */
        IfxSmu_clearRegMonTestModeEnable(testModeEnable);

        /* Convert the time to seconds */
        tExecutionInSec = tExecution / IfxStm_getFrequency(&MODULE_STM0);

        /* Validation */
        if(IfxSmu_getRegisterMonitorErrorFlag() && (1U << testModeEnable))
        {
            smuRegMonitorTestPassed = FALSE;
        }

        if(tExecutionInSec > SMU_REG_MONITOR_TEST_MAX_TIME_SEC)
        {
            smuRegMonitorTestPassed = FALSE;
        }
    }

    /* Set g_SlkStatus.smuStatus variable */
    if(smuRegMonitorTestPassed == TRUE)
    {
        g_SlkStatus.smuStatus.smuSafetyFlipFlopTriggerTestSts       = pass;
        g_SlkStatus.smuStatus.smuSafetyFlipFlopTestResultCheckSts  = pass;
    }

    /* CLear all Safety Flip-Flop uncorrectable errors which are raised during the test */
    /* Required for g_SlkStatus.smuStatus variable */
    boolean alarmClearedSuccessful = FALSE;
    SmuStatusType result = pass;

    for(uint8 errorId = 0; errorId < NUM_UNCORRECTABLE_ERRORS; errorId++)
    {
        if(safetyFfUncorrectableErrors[errorId].smuType == TYPE_SMU_CORE)
        {
            IfxSmu_clearAlarmStatus(safetyFfUncorrectableErrors[errorId].alarmName);
            if(IfxSmu_getAlarmStatus(safetyFfUncorrectableErrors[errorId].alarmName) == FALSE)
            {
                alarmClearedSuccessful = TRUE;
            }
        }
        else if (safetyFfUncorrectableErrors[errorId].smuType == TYPE_SMU_STDBY)
        {
            if (clearBitSMUstdby(safetyFfUncorrectableErrors[errorId].alarmName) == fail)
            {
                result = fail;
            }
        }
    }

    /* Set g_SlkStatus.smuStatus variable */
    if((alarmClearedSuccessful == TRUE) && (result == pass))
    {
        g_SlkStatus.smuStatus.smuSafetyFlipFlopTestAlarmFlagClearSts = pass;
    }

    /* Lock SMU registers again*/
    IfxSmu_temporaryLockConfigRegisters();

    /* Disable all clocks */
    if (mtuWasEnabled == FALSE)
    {
        /* Clear EndInit */
        IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

        /* MTU clock disable */
        MTU_CLC.B.DISR = 0x1U;
        /*Set EndInit */
        IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    }

    if(iomWasEnabled == FALSE)
    {
        IfxIom_resetModule(&MODULE_IOM);
    }
#ifdef IFXEMEM_REG_H
    if(ememWasEnabled == FALSE)
    {
        IfxEmem_disableModule(&MODULE_EMEM);
    }
#endif
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    if(dmaWasEnabled == FALSE)
    {
        MODULE_DMA.CLC.B.DISR = 0x1U;
    }
    if(smuWasEnabled == FALSE)
    {
        MODULE_SMU.CLC.B.DISR = 0x1U;
    }
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());


    if(smuRegMonitorTestPassed == TRUE)
    {
        g_SlkStatus.smuStatus.regMonitorTestSmu = pass;
    }
    else
    {
        g_SlkStatus.smuStatus.regMonitorTestSmu = fail;
    }
}
