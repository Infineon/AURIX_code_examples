/**********************************************************************************************************************
 * \file Slk_Ssw.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Alive_Alarm_Test.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Lbist.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Mbist.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Mcu_Fw_Check.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Mcu_Startup.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Monbist.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Smu_Reg_Monitor_Test.h"
#include "Ifx_Cfg_Ssw.h"
#include "IfxMtu.h"
#include "IfxPort.h"
#include "IfxScuLbist.h"
#include "IfxPmsPm.h"
#include "IfxSmuStdby.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* This global variable stores the number of Ssw, Lbist and MCU runs */
volatile SswRunCount *g_SswRunCount = &SSW_STATUS_DATA_ADDRESS;  /* This variable is located in SCR XRAM memory. */
MonbistStatus g_MonbistStatus; /* This global variable is used to store the status of the Monbist */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
SlkResetCode slkEvaluateReset(void);
boolean slkEvaluateStandby(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Execute the sequence of safety mechanisms when coming from an un-powered state.
 * Refer to Figure 7 in AURIX TC3xx Safety Manual
 * */
void runAppSwStartup()
{
    /* Execute LBIST routine if LBIST execution by either Firmware or application software are enabled. */
#if SLK_CFG_SSW_ENABLE_LBIST_BOOT || SLK_CFG_SSW_ENABLE_LBIST_APPSW
    slkSswLbist();
#endif /* SLK_CFG_SSW_ENABLE_LBIST_BOOT || SLK_CFG_SSW_ENABLE_LBIST_APPSW */

    /* Evaluate reset after LBIST execution.
     * This global variable is used in the project to store the reset status */
    g_SlkStatus.resetCode = slkEvaluateReset();

    /* This global variable is used in the MCU FW check to evaluate if it is coming from a standby mode*/
    g_SlkStatus.wakeupFromStandby = slkEvaluateStandby();

#if SLK_CFG_SSW_ENABLE_MONBIST
    /* MONBIST Tests and evaluation
     * SMC:PMS:MONBIST_CFG
     * SM:PMS:MONBIST_RESULT
     * */
    slkMonbist();
#endif /* SLK_CFG_SSW_ENABLE_MONBIST */

#if SLK_CFG_SSW_ENABLE_MCU_FW_CHECK
    slkSswMcuFwCheck();
#endif /* SLK_CFG_SSW_ENABLE_MCU_FW_CHECK */

#if SLK_CFG_SSW_ENABLE_MCU_STARTUP
    slkSswMcuStartup();
#endif /* SLK_CFG_SSW_ENABLE_MCU_STARTUP */

#if SLK_CFG_SSW_ENABLE_ALIVE_ALARM_TEST
    slkSswAliveAlarmTest();
#endif /* SLK_CFG_SSW_ENABLE_ALIVE_ALARM_TEST */

#if SLK_CFG_SSW_ENABLE_REG_MONITOR_TEST
    /* SM:SMU:REG_MONITOR_TEST */
    slkSswSmuRegMonitorTest();
#endif /* SLK_CFG_SSW_ENABLE_REG_MONITOR_TEST */

#if SLK_CFG_SSW_ENABLE_MBIST
    /* SMC:VMT:MBIST
     * SM:VMT:MBIST
     * */
    slkSswMbist();
#endif /* SLK_CFG_SSW_ENABLE_MBIST */

    /* Configure the alarm action for all SMU alarms with default configuration.
     * Some configuration might get overwritten with specific configuration later in the function initSMUModule() */
    slkEnableAllSMUAlarms();
}

/*
 * Triggering a Warm PORST via the LBIST.
 * Note: "In AURIX(TM) TC3xx devices, LBIST execution terminates [..] with a warm reset." but
 * "The Startup Software executed afterwards follows the flow as after cold power-on [..]"
 * */
void slkTriggerWarmPorst(void)
{
    slkTriggerSwReset(SlkResetType_warmpoweron);
}

/*
 * This function triggers either a SW Application Reset or a SW System Reset, based on the parameter resetType
 * */
void slkTriggerSwReset(SlkResetType resetType)
{
    /* Get the CPU EndInit password */
    uint16 password = IfxScuWdt_getCpuWatchdogPassword();

    /* Configure the request trigger in the Reset Configuration Register */
    IfxScuRcu_configureResetRequestTrigger(IfxScuRcu_Trigger_sw, (IfxScuRcu_ResetType) resetType);

    /* Clear CPU EndInit protection to write in the SWRSTCON register of SCU */
    IfxScuWdt_clearCpuEndinit(password);

    /* Trigger a software reset based on the configuration of RSTCON register */
    IfxCpu_triggerSwReset();

    /* The following instructions are not executed if a SW reset occurs */
    /* Set CPU EndInit protection */
    IfxScuWdt_setCpuEndinit(password);
}

/*
 * Reimplementation of the illd function IfxScuRcu_ResetCode IfxScuRcu_evaluateReset(void)
 * according to safety lite kit
 */
SlkResetCode slkEvaluateReset(void)
{
    static boolean resetEvaluated = FALSE;
    static SlkResetCode resetCode;

    /* This function guarantees that reset type will be evaluated only once
     * and that its value will not change during runtime.
     * The first time this function is called, it evaluate the reset type and
     *  clears RSTSTAT register.
     */
    if (resetEvaluated == FALSE)
    {
        Ifx_SCU_RSTCON rstCon;
        Ifx_SCU_RSTSTAT rstStat;

        resetCode.cpuSafeState = (((MODULE_SCU.RSTCON2.U >> IFX_SCU_RSTCON2_CSSX_OFF) & IFX_SCU_RSTCON2_CSSX_MSK)
                == IFX_SCU_RSTCON2_CSSX_MSK);
        resetCode.resetType = SlkResetType_undefined;
        resetCode.resetTrigger = IfxScuRcu_Trigger_undefined;
        resetCode.resetReason = 0;

        /* When coming from cold PORST and if the LBIST is trigger by application software, to store LBIST execution counter
         * at SCR XRAM, it is required to clear cold power on reset otherwise it will clear SRC XRAM. Before clearing cold POSRT status,
         * the MODULE_SCU.RSTSTAT.U status is also stored to  g_SswRunCount->RSTSTAT.U which also store SCR XRAM. Therefore,
         * g_SswRunCount->RSTSTAT.U here to get the real status of cold PORST (which is real status)
         * */
        if ((FALSE == Ifx_Ssw_isColdPoweronReset()) &&
             TRUE == MODULE_SCU.RSTSTAT.B.LBTERM )
        {
            rstStat.U = g_SswRunCount->RSTSTAT.U;
        }
        else
        {
            /* This variable is located in SCR XRAM memory */
            g_SswRunCount->RSTSTAT.U = MODULE_SCU.RSTSTAT.U;
            rstStat.U = MODULE_SCU.RSTSTAT.U;
        }

        rstCon.U = MODULE_SCU.RSTCON.U;

        /* Evaluate the warm reset conditions first */
        if (rstStat.B.ESR0)
        {
            resetCode.resetType = (SlkResetType) rstCon.B.ESR0;
            resetCode.resetTrigger = IfxScuRcu_Trigger_esr0;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.ESR1)
        {
            resetCode.resetType = (SlkResetType) rstCon.B.ESR1;
            resetCode.resetTrigger = IfxScuRcu_Trigger_esr1;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.SMU)
        {
            resetCode.resetType = (SlkResetType) rstCon.B.SMU;
            resetCode.resetTrigger = IfxScuRcu_Trigger_smu;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.SW)
        {
            resetCode.resetType = (SlkResetType) rstCon.B.SW;
            resetCode.resetTrigger = IfxScuRcu_Trigger_sw;
            resetCode.resetReason = MODULE_SCU.RSTCON2.B.USRINFO;
        }
        else if (rstStat.B.STM0)
        {
            resetCode.resetType = (SlkResetType) rstCon.B.STM0;
            resetCode.resetTrigger = IfxScuRcu_Trigger_stm0;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.STM1)
        {
            resetCode.resetType = (SlkResetType) rstCon.B.STM1;
            resetCode.resetTrigger = IfxScuRcu_Trigger_stm1;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.STM2)
        {
            resetCode.resetType = (SlkResetType) rstCon.B.STM2;
            resetCode.resetTrigger = IfxScuRcu_Trigger_stm2;
            resetCode.resetReason = 0;
        }

        else if (rstStat.B.CB0)
        {
            resetCode.resetType = SlkResetType_system;
            resetCode.resetTrigger = IfxScuRcu_Trigger_cb0;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.CB1)
        {
            resetCode.resetType = SlkResetType_debug;
            resetCode.resetTrigger = IfxScuRcu_Trigger_cb1;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.CB3)
        {
            resetCode.resetType = SlkResetType_application;
            resetCode.resetTrigger = IfxScuRcu_Trigger_cb3;
            resetCode.resetReason = 0;
        }
        else if (rstStat.B.LBTERM)
        {
            resetCode.resetType = SlkResetType_lbist;
            resetCode.resetTrigger = IfxScuRcu_Trigger_swd;
            resetCode.resetReason = 0;
        }
        else
        {
            /* Now evaluate for Cold reset conditions */
            if (rstStat.B.EVRC)
            {
                resetCode.resetType = SlkResetType_coldpoweron;
                resetCode.resetTrigger = IfxScuRcu_Trigger_evrc;
                resetCode.resetReason = 0;
            }
            else if (rstStat.B.EVR33)
            {
                resetCode.resetType = SlkResetType_coldpoweron;
                resetCode.resetTrigger = IfxScuRcu_Trigger_evr33;
                resetCode.resetReason = 0;
            }
            else if (rstStat.B.SWD)
            {
                resetCode.resetType = SlkResetType_coldpoweron;
                resetCode.resetTrigger = IfxScuRcu_Trigger_swd;
                resetCode.resetReason = 0;
            }
            else if (rstStat.B.STBYR)
            {
                resetCode.resetType = SlkResetType_coldpoweron;
                resetCode.resetTrigger = IfxScuRcu_Trigger_stbyr;
                resetCode.resetReason = 0;
            }
        }
        /* Finally - Evaluate selectively for PORST */
        if (rstStat.B.PORST)
        {
            if (resetCode.resetType != SlkResetType_coldpoweron
                    && resetCode.resetType != SlkResetType_lbist)
            {
                resetCode.resetType = SlkResetType_warmpoweron;
                resetCode.resetTrigger = IfxScuRcu_Trigger_portst;
            }
            resetCode.resetReason = 0;
        }
        resetEvaluated = TRUE;

        /* Clear COLD PORST reason to have new status after any type of reset*/
        IfxScuRcu_clearColdResetStatus();
    }
    else
    {
    }
    return resetCode;
}

/*
 * This function evaluates if software execution is continuing after being in Standby mode
 * */
boolean slkEvaluateStandby(void)
{
    static boolean standbyEvaluated = FALSE;
    static boolean comingFromStandby = FALSE;

    if (standbyEvaluated == FALSE)
    {
        if ((PMS_PMSWSTAT2.U & PMSWSTAT2_WAKE_UP_FLAGS_MASK) > 0)
        {
            /* Clear standby flag */
            uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
            PMS_PMSWSTATCLR.U |= (PMS_PMSWSTAT2.U & PMSWSTAT2_WAKE_UP_FLAGS_MASK);
            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

            comingFromStandby = TRUE;
        }
        else
        {
            comingFromStandby = FALSE;
        }
    }
    return comingFromStandby;
}
