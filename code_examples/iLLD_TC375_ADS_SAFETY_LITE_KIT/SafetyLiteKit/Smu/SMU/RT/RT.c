/**********************************************************************************************************************
 * \file RT.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*----------------------------------Includes-------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU/RT/RT.h"

/*********************************************************************************************************************/
/*------------------------------Global variables---------------------------------------------------------------------*/
/*********************************************************************************************************************/
ConfigStructRecoveryTimerSMU configRecoveryTimerSMU;
boolean recoveryTimerUp = FALSE;
extern uint16 nbrAlarmsThatTriggerRT;
extern RuntimeAlarmHandle alarmsThatTriggerRT[];

/*********************************************************************************************************************/
/*-------------------------Function Implementations------------------------------------------------------------------*/
/*********************************************************************************************************************/
SmuStatusType configRTSMU(ConfigStructRecoveryTimerSMU configRecoveryTimerSMU);
uint32 getCF0ConfigRTSMU(IfxSmu_Alarm alarm);
uint32 getCF1ConfigRTSMU(IfxSmu_Alarm alarm);
uint32 getCF2ConfigRTSMU(IfxSmu_Alarm alarm);
IfxSmu_InternalAlarmAction getBehaviorRTSMU(IfxSmu_Alarm alarm);

/*********************************************************************************************************************/
/*-------------------------Function Implementations------------------------------------------------------------------*/
/*********************************************************************************************************************/
/*
* configures the recovery timer chosen with RT_enabled (RT0 or RT1) to react to the alarms
* (alarm0 to alarm3), checks if the reaction set for these alarms is either an interrupt or
* an NMI if not the alarm is not set configures the RTC register to enable the right Recovery timer with
* the RTD value present in the ConfigStructRecoveryTimerSMU structure and checks if configuration has been applied
* Note: The use of the recovery timer only makes sense if the internal action is an interrupt or NMI. However no
* hardware check is done, it is up to software to configure the SMU_core in the appropriate way.
* */
SmuStatusType configRTSMU(ConfigStructRecoveryTimerSMU configRecoveryTimerSMU)
{
    Ifx_SMU_RTAC00 RTAC00;
    Ifx_SMU_RTAC01 RTAC01;
    Ifx_SMU_RTAC10 RTAC10;
    Ifx_SMU_RTAC11 RTAC11;

    Ifx_SMU_RTC RTC;

    boolean bool = TRUE;

    boolean alarm0ToBeSetup = FALSE;
    boolean alarm1ToBeSetup = FALSE;
    boolean alarm2ToBeSetup = FALSE;
    boolean alarm3ToBeSetup = FALSE;

    IfxSmu_Alarm alarm0;
    IfxSmu_Alarm alarm1;
    IfxSmu_Alarm alarm2;
    IfxSmu_Alarm alarm3;

    unsigned char fourBitsCode = 0x0;

    RTAC00.U = MODULE_SMU.RTAC00.U;
    RTAC01.U = MODULE_SMU.RTAC01.U;
    RTAC10.U = MODULE_SMU.RTAC10.U;
    RTAC11.U = MODULE_SMU.RTAC11.U;

    RTC.U = MODULE_SMU.RTC.U;

    if(nbrAlarmsThatTriggerRT == 1)
    {
        alarm0 = alarmsThatTriggerRT[0].alarmConfig->alarm;
        alarm1 = alarm2 = alarm3 = alarm0;
    }
    else if(nbrAlarmsThatTriggerRT == 2)
    {
        alarm0 = alarmsThatTriggerRT[0].alarmConfig->alarm;
        alarm1 = alarmsThatTriggerRT[1].alarmConfig->alarm;
        alarm2 = alarm3 = alarm0;
    }
    else if(nbrAlarmsThatTriggerRT == 3)
    {
        alarm0 = alarmsThatTriggerRT[0].alarmConfig->alarm;
        alarm1 = alarmsThatTriggerRT[1].alarmConfig->alarm;
        alarm2 = alarmsThatTriggerRT[2].alarmConfig->alarm;
        alarm3 = alarm0;
    }
    else if(nbrAlarmsThatTriggerRT == 4)
    {
        alarm0 = alarmsThatTriggerRT[0].alarmConfig->alarm;
        alarm1 = alarmsThatTriggerRT[1].alarmConfig->alarm;
        alarm2 = alarmsThatTriggerRT[2].alarmConfig->alarm;
        alarm3 = alarmsThatTriggerRT[3].alarmConfig->alarm;
    }
    else if ((nbrAlarmsThatTriggerRT == 0) &&
            ((configRecoveryTimerSMU.RT0 == Recovery_timer_disabled)  ||
             (configRecoveryTimerSMU.RT1 == Recovery_timer_disabled)))
    {
        if(configRecoveryTimerSMU.RT0 == Recovery_timer_disabled)
        {
            RTC.B.RT0E = 0;
        }
        if(configRecoveryTimerSMU.RT1 == Recovery_timer_disabled)
        {
            RTC.B.RT1E = 0;
        }
        /* Unlocks the SMU configuration registers for modification */
        g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
        if (g_SlkStatus.unlockConfig == TRUE)
        {
            g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
        }
        else
        {
            g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
        }
        IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
            SMU_RTC.U = RTC.U;
        IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
        IfxSmu_temporaryLockConfigRegisters();
        return NA;
    }
    else
    {
        __debug();
    }

    /*
     * The use of the recovery timer only makes sense if the internal action is an interrupt or NMI. However no
     * hardware check is done, it is up to software to configure the SMU_core in the appropriate way.
     */

    if((getBehaviorRTSMU(alarm0)>=IfxSmu_InternalAlarmAction_igcs0) &
       (getBehaviorRTSMU(alarm0)<=IfxSmu_InternalAlarmAction_nmi))
    {
        alarm0ToBeSetup = TRUE;
    }
    if((getBehaviorRTSMU(alarm1)>=IfxSmu_InternalAlarmAction_igcs0) &
       (getBehaviorRTSMU(alarm1)<=IfxSmu_InternalAlarmAction_nmi))
    {
        alarm1ToBeSetup = TRUE;
    }
    if((getBehaviorRTSMU(alarm2)>=IfxSmu_InternalAlarmAction_igcs0) &
       (getBehaviorRTSMU(alarm2)<=IfxSmu_InternalAlarmAction_nmi))
    {
        alarm2ToBeSetup = TRUE;
    }
    if((getBehaviorRTSMU(alarm3)>=IfxSmu_InternalAlarmAction_igcs0) &
       (getBehaviorRTSMU(alarm3)<=IfxSmu_InternalAlarmAction_nmi))
    {
        alarm3ToBeSetup = TRUE;
    }

    fourBitsCode = (alarm3ToBeSetup<<0x3)|(alarm2ToBeSetup<<0x2)|(alarm1ToBeSetup<<0x1)|(alarm0ToBeSetup<<0x0);

    switch (fourBitsCode)
    {
        case 0x1 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm0 / 32;
                RTAC00.B.ALID1 = alarm0 % 32;
                RTAC01.B.GID2 = alarm0 / 32;
                RTAC01.B.ALID2 = alarm0 % 32;
                RTAC01.B.GID3 = alarm0 / 32;
                RTAC01.B.ALID3 = alarm0 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm0 / 32;
                RTAC10.B.ALID1 = alarm0 % 32;
                RTAC11.B.GID2 = alarm0 / 32;
                RTAC11.B.ALID2 = alarm0 % 32;
                RTAC11.B.GID3 = alarm0 / 32;
                RTAC11.B.ALID3 = alarm0 % 32;
            }
            break;

        case 0x2 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm1 / 32;
                RTAC00.B.ALID0 = alarm1 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm1 / 32;
                RTAC01.B.ALID2 = alarm1 % 32;
                RTAC01.B.GID3 = alarm1 / 32;
                RTAC01.B.ALID3 = alarm1 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm1 / 32;
                RTAC10.B.ALID0 = alarm1 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm1 / 32;
                RTAC11.B.ALID2 = alarm1 % 32;
                RTAC11.B.GID3 = alarm1 / 32;
                RTAC11.B.ALID3 = alarm1 % 32;
            }
            break;

        case 0x3 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm0 / 32;
                RTAC01.B.ALID2 = alarm0 % 32;
                RTAC01.B.GID3 = alarm0 / 32;
                RTAC01.B.ALID3 = alarm0 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm0 / 32;
                RTAC11.B.ALID2 = alarm0 % 32;
                RTAC11.B.GID3 = alarm0 / 32;
                RTAC11.B.ALID3 = alarm0 % 32;
            }
            break;

        case 0x4 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm2 / 32;
                RTAC00.B.ALID0 = alarm2 % 32;
                RTAC00.B.GID1 = alarm2 / 32;
                RTAC00.B.ALID1 = alarm2 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm2 / 32;
                RTAC01.B.ALID3 = alarm2 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm2 / 32;
                RTAC10.B.ALID0 = alarm2 % 32;
                RTAC10.B.GID1 = alarm2 / 32;
                RTAC10.B.ALID1 = alarm2 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm2 / 32;
                RTAC11.B.ALID3 = alarm2 % 32;
            }
            break;

        case 0x5 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm0 / 32;
                RTAC00.B.ALID1 = alarm0 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm0 / 32;
                RTAC01.B.ALID3 = alarm0 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm0 / 32;
                RTAC10.B.ALID1 = alarm0 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm0 / 32;
                RTAC11.B.ALID3 = alarm0 % 32;
            }
            break;

        case 0x6 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm1 / 32;
                RTAC00.B.ALID0 = alarm1 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm1 / 32;
                RTAC01.B.ALID3 = alarm1 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm1 / 32;
                RTAC10.B.ALID0 = alarm1 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm1 / 32;
                RTAC11.B.ALID3 = alarm1 % 32;
            }
            break;

        case 0x7 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm0 / 32;
                RTAC01.B.ALID3 = alarm0 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm0 / 32;
                RTAC11.B.ALID3 = alarm0 % 32;
            }
            break;

        case 0x8 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm3 / 32;
                RTAC00.B.ALID0 = alarm3 % 32;
                RTAC00.B.GID1 = alarm3 / 32;
                RTAC00.B.ALID1 = alarm3 % 32;
                RTAC01.B.GID2 = alarm3 / 32;
                RTAC01.B.ALID2 = alarm3 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm3 / 32;
                RTAC10.B.ALID0 = alarm3 % 32;
                RTAC10.B.GID1 = alarm3 / 32;
                RTAC10.B.ALID1 = alarm3 % 32;
                RTAC11.B.GID2 = alarm3 / 32;
                RTAC11.B.ALID2 = alarm3 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        case 0x9 :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm0 / 32;
                RTAC00.B.ALID1 = alarm0 % 32;
                RTAC01.B.GID2 = alarm0 / 32;
                RTAC01.B.ALID2 = alarm0 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm0 / 32;
                RTAC10.B.ALID1 = alarm0 % 32;
                RTAC11.B.GID2 = alarm0 / 32;
                RTAC11.B.ALID2 = alarm0 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        case 0xA :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm1 / 32;
                RTAC00.B.ALID0 = alarm1 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm1 / 32;
                RTAC01.B.ALID2 = alarm1 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm1 / 32;
                RTAC10.B.ALID0 = alarm1 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm1 / 32;
                RTAC11.B.ALID2 = alarm1 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        case 0xB :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm0 / 32;
                RTAC01.B.ALID2 = alarm0 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm0 / 32;
                RTAC11.B.ALID2 = alarm0 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        case 0xC :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm2 / 32;
                RTAC00.B.ALID0 = alarm2 % 32;
                RTAC00.B.GID1 = alarm2 / 32;
                RTAC00.B.ALID1 = alarm2 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm2 / 32;
                RTAC10.B.ALID0 = alarm2 % 32;
                RTAC10.B.GID1 = alarm2 / 32;
                RTAC10.B.ALID1 = alarm2 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        case 0xD :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm0 / 32;
                RTAC00.B.ALID1 = alarm0 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm0 / 32;
                RTAC10.B.ALID1 = alarm0 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        case 0xE :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm1 / 32;
                RTAC00.B.ALID0 = alarm1 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm1 / 32;
                RTAC10.B.ALID0 = alarm1 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        case 0xF :
            if (configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
            {
                RTAC00.B.GID0 = alarm0 / 32;
                RTAC00.B.ALID0 = alarm0 % 32;
                RTAC00.B.GID1 = alarm1 / 32;
                RTAC00.B.ALID1 = alarm1 % 32;
                RTAC01.B.GID2 = alarm2 / 32;
                RTAC01.B.ALID2 = alarm2 % 32;
                RTAC01.B.GID3 = alarm3 / 32;
                RTAC01.B.ALID3 = alarm3 % 32;
            }
            if (configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
            {
                RTAC10.B.GID0 = alarm0 / 32;
                RTAC10.B.ALID0 = alarm0 % 32;
                RTAC10.B.GID1 = alarm1 / 32;
                RTAC10.B.ALID1 = alarm1 % 32;
                RTAC11.B.GID2 = alarm2 / 32;
                RTAC11.B.ALID2 = alarm2 % 32;
                RTAC11.B.GID3 = alarm3 / 32;
                RTAC11.B.ALID3 = alarm3 % 32;
            }
            break;

        default:
            break;
    }

    /* If at least one alarm has the right internal reaction */
    if(fourBitsCode != 0x0)
    {
        if(configRecoveryTimerSMU.RT0 == Recovery_timer_enabled)
        {
            /* Unlock KEYS register because RTAC are KEYS protected */
            g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
            if (g_SlkStatus.unlockConfig == TRUE)
            {
                g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
            }
            else
            {
                g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
            }

            IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
                MODULE_SMU.RTAC00.U = RTAC00.U;
                MODULE_SMU.RTAC01.U = RTAC01.U;
            IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
        }

        if(configRecoveryTimerSMU.RT1 == Recovery_timer_enabled)
        {
            /* Unlock KEYS register because RTAC are KEYS protected */
            g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
            if (g_SlkStatus.unlockConfig == TRUE)
            {
                g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
            }
            else
            {
                g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
            }

            IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
                MODULE_SMU.RTAC10.U = RTAC10.U;
                MODULE_SMU.RTAC11.U = RTAC11.U;
            IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
        }

        /* The limit in size of the RTD bitfield is 24 bit, thus the test */
        if(configRecoveryTimerSMU.RTD_value>0xFFFFFF)
        {
            configRecoveryTimerSMU.RTD_value = 0x3FFF;
        }
        RTC.B.RTD = configRecoveryTimerSMU.RTD_value;

        if(configRecoveryTimerSMU.RT0 == Recovery_timer_disabled)
        {
            RTC.B.RT0E = 0;
        }

        if(configRecoveryTimerSMU.RT1== Recovery_timer_disabled)
        {
            RTC.B.RT1E = 0;
        }

        /* Unlocks the SMU configuration registers for modification */
        g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
        if (g_SlkStatus.unlockConfig == TRUE)
        {
            g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
        }
        else
        {
            g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
        }
        IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
        SMU_RTC.U = RTC.U;
        IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
    }

    /* Check that the configurations wanted have really been applied */
    bool = (SMU_RTC.U == RTC.U);
    bool &= (MODULE_SMU.RTAC10.U == RTAC10.U)|(MODULE_SMU.RTAC11.U == RTAC11.U);
    bool &= (MODULE_SMU.RTAC01.U == RTAC01.U)|(MODULE_SMU.RTAC00.U == RTAC00.U);

    if((fourBitsCode != 0x0) & bool)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * This function allow to enable the recovery Timer with different or not alarms
 * Note:The use of the recovery timer only makes sense if the internal action is an interrupt or NMI. However no
 * hardware check is done, it is up to software to configure the SMU_core in the appropriate way.
 * */
void enableRecoveryTimerSMU(uint32 duration)
{
    if (nbrAlarmsThatTriggerRT == 0)
    {
        recoveryTimerUp = FALSE;
        configRecoveryTimerSMU.RT0 = Recovery_timer_disabled;  /* enable the first recovery timer */
        configRecoveryTimerSMU.RT1 = Recovery_timer_disabled;  /* enable the second recovery timer */
        configRecoveryTimerSMU.RTD_value = duration;           /* recovery timer duration, 24 bits so max = 0xFFFFFF */

        SmuStatusType result = fail;
        result = configRTSMU(configRecoveryTimerSMU);
        g_SlkStatus.smuStatus.smuRecoveryTimerConfigSts = result;
    }
    else
    {
        recoveryTimerUp = TRUE;
        configRecoveryTimerSMU.RT0 = Recovery_timer_enabled;  /* enable the first recovery timer */
        configRecoveryTimerSMU.RT1 = Recovery_timer_enabled;  /* enable the second recovery timer */
        configRecoveryTimerSMU.RTD_value = duration;          /* recovery timer duration, 24 bits so max = 0xFFFFFF */

        SmuStatusType result = fail;
        result = configRTSMU(configRecoveryTimerSMU);
        g_SlkStatus.smuStatus.smuRecoveryTimerConfigSts = result;
    }
}

/*
 * return the value of the AG_CF0 register corresponding to the alarm given in parameter
 * */
uint32 getCF0ConfigRTSMU(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup =(int) alarm / 32;
    uint32 alarmGroupCF0 = 0x0;

    switch (alarmGroup)
        {
            case 0:
                alarmGroupCF0 = (uint32)(SMU_AG0CF0.U);
                break;
            case 1:
                alarmGroupCF0 = (uint32)(SMU_AG1CF0.U);
                break;
            case 2:
                alarmGroupCF0 = (uint32)(SMU_AG2CF0.U);
                break;
            case 3:
                alarmGroupCF0 = (uint32)(SMU_AG3CF0.U);
                break;
            case 4:
                alarmGroupCF0 = (uint32)(SMU_AG4CF0.U);
                break;
            case 5:
                alarmGroupCF0 = (uint32)(SMU_AG5CF0.U);
                break;
            case 6:
                alarmGroupCF0 = (uint32)(SMU_AG6CF0.U);
                break;
            case 7:
                alarmGroupCF0 = (uint32)(SMU_AG7CF0.U);
                break;
            case 8:
                alarmGroupCF0 = (uint32)(SMU_AG8CF0.U);
                break;
            case 9:
                alarmGroupCF0 = (uint32)(SMU_AG9CF0.U);
                break;
            case 10:
                alarmGroupCF0 = (uint32)(SMU_AG10CF0.U);
                break;
            case 11:
                alarmGroupCF0 = (uint32)(SMU_AG11CF0.U);
                break;
            default:
                break;
        }
    return alarmGroupCF0;
}

/*
 * return the value of the AG_CF1 register corresponding to the alarm given in parameter
 * */
uint32 getCF1ConfigRTSMU(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup =(int) alarm / 32;
    uint32 alarmGroupCF1 = 0x0;

    switch (alarmGroup)
        {
            case 0:
                alarmGroupCF1 = (uint32)(SMU_AG0CF1.U);
                break;
            case 1:
                alarmGroupCF1 = (uint32)(SMU_AG1CF1.U);
                break;
            case 2:
                alarmGroupCF1 = (uint32)(SMU_AG2CF1.U);
                break;
            case 3:
                alarmGroupCF1 = (uint32)(SMU_AG3CF1.U);
                break;
            case 4:
                alarmGroupCF1 = (uint32)(SMU_AG4CF1.U);
                break;
            case 5:
                alarmGroupCF1 = (uint32)(SMU_AG5CF1.U);
                break;
            case 6:
                alarmGroupCF1 = (uint32)(SMU_AG6CF1.U);
                break;
            case 7:
                alarmGroupCF1 = (uint32)(SMU_AG7CF1.U);
                break;
            case 8:
                alarmGroupCF1 = (uint32)(SMU_AG8CF1.U);
                break;
            case 9:
                alarmGroupCF1 = (uint32)(SMU_AG9CF1.U);
                break;
            case 10:
                alarmGroupCF1 = (uint32)(SMU_AG10CF1.U);
                break;
            case 11:
                alarmGroupCF1 = (uint32)(SMU_AG11CF1.U);
                break;
            default:
                break;
        }
    return alarmGroupCF1;
}

/*
 * return the value of the AG_CF2 register corresponding to the alarm given in parameter
 * */
uint32 getCF2ConfigRTSMU(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup =(int) alarm / 32;
    uint32 alarmGroupCF2 = 0x0;

    switch (alarmGroup)
        {
            case 0:
                alarmGroupCF2 = (uint32)(SMU_AG0CF2.U);
                break;
            case 1:
                alarmGroupCF2 = (uint32)(SMU_AG1CF2.U);
                break;
            case 2:
                alarmGroupCF2 = (uint32)(SMU_AG2CF2.U);
                break;
            case 3:
                alarmGroupCF2 = (uint32)(SMU_AG3CF2.U);
                break;
            case 4:
                alarmGroupCF2 = (uint32)(SMU_AG4CF2.U);
                break;
            case 5:
                alarmGroupCF2 = (uint32)(SMU_AG5CF2.U);
                break;
            case 6:
                alarmGroupCF2 = (uint32)(SMU_AG6CF2.U);
                break;
            case 7:
                alarmGroupCF2 = (uint32)(SMU_AG7CF2.U);
                break;
            case 8:
                alarmGroupCF2 = (uint32)(SMU_AG8CF2.U);
                break;
            case 9:
                alarmGroupCF2 = (uint32)(SMU_AG9CF2.U);
                break;
            case 10:
                alarmGroupCF2 = (uint32)(SMU_AG10CF2.U);
                break;
            case 11:
                alarmGroupCF2 = (uint32)(SMU_AG11CF2.U);
                break;
            default:
                break;
        }
    return alarmGroupCF2;
}

/*
 * return the internal_alarm_action that is currently being used for alarm, if the alarm given in
 * parameter is not correct or not part of the IfxSmu_Alarm enum the output of the function is 0x8
 */
IfxSmu_InternalAlarmAction getBehaviorRTSMU(IfxSmu_Alarm alarm)
{
    uint32 alarmGroupCF2 = 0x0;
    uint32 alarmGroupCF1 = 0x0;
    uint32 alarmGroupCF0 = 0x0;

    uint16 alarmPos = (int)(alarm % 32);

    alarmGroupCF0 =  getCF0ConfigRTSMU(alarm);
    alarmGroupCF0 = alarmGroupCF0 >> alarmPos;
    alarmGroupCF0 &= 0x1;

    alarmGroupCF1 =  getCF1ConfigRTSMU(alarm);
    alarmGroupCF1 = alarmGroupCF1 >> alarmPos;
    alarmGroupCF1 &= 0x1;

    alarmGroupCF2 =  getCF2ConfigRTSMU(alarm);
    alarmGroupCF2 = alarmGroupCF2 >> alarmPos;
    alarmGroupCF2 &= 0x1;

    return (alarmGroupCF2<<0x2)|(alarmGroupCF1<<0x1)|(alarmGroupCF0<<0x0);
}

/*
 * checks if the internal action associated with an alarm is the one desired for it
 * */
boolean checkBehaviorRTSMU(IfxSmu_Alarm alarm, IfxSmu_InternalAlarmAction internalAction)
{
    boolean result = FALSE;

    result = (getBehaviorRTSMU(alarm) == internalAction);
    return result;
}
