/**********************************************************************************************************************
 * \file SMU.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*----------------------------------Includes-------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Safe_Computation/Slk_NvmPflash.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU/FSP/SMU_core_FSP.h"
#include "SafetyLiteKit/Smu/SMU/FSP/SMU_stdby_FSP.h"
#include "SafetyLiteKit/Smu/SMU/RT/RT.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "SafetyLiteKit/Smu/SMU_Test/Keys.h"
#include "SafetyLiteKit/Sw_StartUp/Slk_Ssw_Mcu_Fw_Check.h"
#include "Cpu/Irq/IfxCpu_Irq.h"

#if CPU_WHICH_RUN_SMU == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 1) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 2) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set CPU_WHICH_RUN_SMU to a valid value!"
#endif

/*********************************************************************************************************************/
/*------------------------------Global variables---------------------------------------------------------------------*/
/*********************************************************************************************************************/
IFX_EXTERN ConfigStructRecoveryTimerSMU configRecoveryTimerSMU;

/*-------------------------------------------------------------------------------------------------------------------*/
/*                           CONFIGURABLE BY USER                                                                    */
/*-------------------------------------------------------------------------------------------------------------------*/
/*
 * The array globalAlarmConfig[] holds the configuration of every alarm configured by the user
 * For each alarm, you can:
 *  - configure the internal reaction (trigger interrupts, issue NMI, individual CPU reset or MCU reset)
 *  - enable the external reaction (FSP or PES depending of the PES config: see IfxSmu_configAlarmActionPES function)
 *  - enable the use of recovery timer (currently can only be triggered by alarms max)
 *  - configure a callback function that will be called when alarm is detected
 *
 * Notes:
 *  During program execution, alarms are stored in different arrays according to their internal reaction.
 *  Alarms that needs to be detected as fast as possible should be placed at the first position
 *  of their reaction group section in the globalAlarmConfig[] array.
 *
 *  The use of the recovery timer only makes sense if the internal action is an interrupt or NMI. However no
 *  hardware check is done, it is up to software to configure the SMU_core in the appropriate way.
 *  */
const AlarmConfigStruct globalAlarmConfig[USER_ALARM_NUMBER] =
{
    /*
     * Attention
     * Alarm message names are created in /outputPrintedSMU.js to show alarm message names in OneEye GUI.
     * */
    /*---------------------------------------------------------------------------------------------------------------*/
    /* IfxSmu_Alarm alarm                       IfxSmu_InternalAlarmAction         Enable      Trigger  Function to
                                                                                   external    Recovery call when alarm
                                                                                   reaction    Timer    is detected  */
    /*------------------------------------------------------------- IGCS0 -------------------------------------------*/
    {DEFAULT_ALARM,                              DEFAULT_ALARM_ACTION,               FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_ADC_BWD,                       IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_ADC,                           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_GTM_ISR_MON,                   IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_SBST,                          IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_QSPI_SAFE,                     IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_DIGITAL_ACQ_ACT,               IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_DTS,                           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_DMA,                           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_CPU_MON,                       IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_STM,                           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_PFLASH,                        IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_TRAP,                          IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_PORT_SMs,                      IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_CLOCK_PLAUS,                   IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_DMA_DMASRI_EccError,           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_IOM_Pin_MismatchIndication,    IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_EVR_Undervoltage_Alarm,        IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_XBAR_EDC_WritePhaseError,      IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_LMU_EDC_WritePhaseError,       IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_CPU2_Buslevel_MpuViolation,     IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_CPU0_PFI0_PFLASH0_ReadPathError, IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,    NULL_PTR},

    /*------------------------------------------------------------- IGCS1 -------------------------------------------*/
    {IfxSmu_Alarm_CPU0_Lockstep_ComparatorError, IfxSmu_InternalAlarmAction_igcs1,   TRUE,       FALSE,      NULL_PTR},
    {IfxSmu_Alarm_CPU1_Lockstep_ComparatorError, IfxSmu_InternalAlarmAction_igcs1,   TRUE,       FALSE,      NULL_PTR},
    {IfxSmu_Alarm_CPU2_Lockstep_ComparatorError, IfxSmu_InternalAlarmAction_igcs1,   TRUE,       FALSE,      NULL_PTR},

    /*------------------------------------------------------------- IGCS2 -------------------------------------------*/
    {IfxSmu_Alarm_SMU_Error_PinFaultStateActivation, IfxSmu_InternalAlarmAction_igcs2,  FALSE,    FALSE,     NULL_PTR},
    {IfxSmu_Alarm_SCU_External_EmergencyStopSignalEvent, IfxSmu_InternalAlarmAction_igcs2, FALSE, FALSE,     NULL_PTR},
    {SOFT_SMU_ALM_GTM_ECKL,                       IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_HSM_Undervoltage_Alarm,         IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_FSI_PFlash_SingleBitError,      IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_FSI_PFlash_DoubleBitError, IfxSmu_InternalAlarmAction_igcs2, FALSE, FALSE, &enableWlFailDetectPFLASH},
    {IfxSmu_Alarm_FSI_Multiple_BitErrorDetectionTrackingBufferFull, IfxSmu_InternalAlarmAction_igcs2,
                                                                                      FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_SMU_Access_EnableErrorDetected, IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    /*-------------------------------------------------------------- NMI --------------------------------------------*/
    /* Note: STHE: Watchdog alarm and Recovery timer is not exactly configured as stated in UM section 15.3.1.5.8
     * Watchdog Alarms -> Changes in Recovery Timer configuration needs to be done */
    {SMU_ALARM_WHICH_TRIGGERS_NMI,       IfxSmu_InternalAlarmAction_nmi, FALSE, TRUE,       &slkWatchdogAlarmHandling},

    /*------------------------------------------------------------- RESET --------------------------------------------*/
    {IfxSmu_Alarm_SMU_Timer0_TimeOut,             IfxSmu_InternalAlarmAction_reset,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_SMU_Timer1_TimeOut,             IfxSmu_InternalAlarmAction_reset,   FALSE,      FALSE,      NULL_PTR},

    /*------------------------- CPU RESET (SMU AGC register defines which CPUs are affected by the CPU reset) --------*/
    {IfxSmu_Alarm_SCU_CPU2_WatchdogTimeOut,         IfxSmu_InternalAlarmAction_igcs2, FALSE,      FALSE,      NULL_PTR},

    /*-------------------------------------------------------- Disabled alarms ---------------------------------------*/
    /* Used for SMU ISR test */
    {SOFT_SMU_ALM_CFG_CHECK,                     IfxSmu_InternalAlarmAction_disabled, FALSE,      FALSE,      NULL_PTR},

    {IfxSmu_Alarm_SCU_External_RequestUnitAlarm1, IfxSmu_InternalAlarmAction_disabled, FALSE,     FALSE,      NULL_PTR},
    {IfxSmu_Alarm_SPB_BusErrorEvent,              IfxSmu_InternalAlarmAction_igcs2, FALSE,     FALSE,      NULL_PTR}
    /*---------------------------------------------------------------------------------------------------------------*/
};

/* The array configArrayIGCS[3] holds the configuration of each Interrupt Generation Configuration Set (IGCS)
 * Each IGCS can be configured to trigger up to 3 ISR.
 */
IGCSisrBindingStruct configArrayIGCS[3] = {
    {IfxSmu_InternalAlarmAction_igcs0, SmuSR0},
    {IfxSmu_InternalAlarmAction_igcs1, SmuSR1},
    {IfxSmu_InternalAlarmAction_igcs2, SmuSR2}
};

/* Add in this array STDBY_SMU alarms that should trigger FSP
 * The complete list of these alarms can be found in SMU_stdby_FSP.h file
 * and in TC37x user manual(STDBY alarms are located in alarm group 20 and 21)
 */
AlarmStdbySMU alarmStdbySMUReactionEnabledFSP[]={
        smuStdbyAlarmEVRVDDOverVoltage,
        smuStdbyAlarmEVRVDDPDOverVoltage
};  /* SMU standby alarms array */
uint8 sizeAlarmStdbySMUReactionEnabledFSP = sizeof(alarmStdbySMUReactionEnabledFSP) / sizeof(AlarmStdbySMU);

/*------------------------------------------------------------------------------------------------------------------*/
/*               USED BY SOFTWARE - NO USER CONFIG NEEDED HERE                                                      */
/*------------------------------------------------------------------------------------------------------------------*/

/* Alarms list for fault source detection -  will be filled by SW */
RuntimeAlarmHandle alarmsThatTriggerIsr0 [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerIsr1 [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerIsr2 [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerNMI  [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatAreDisabled [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerFSP  [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerRT   [4]; /* With the current implementation you can configure 4 alarms
                                                                              to trigger a recovery timer */
uint16 nbrAlarmsThatTriggerIsr0 = 0;
uint16 nbrAlarmsThatTriggerIsr1 = 0;
uint16 nbrAlarmsThatTriggerIsr2 = 0;
uint16 nbrAlarmsThatTriggerNMI  = 0;
uint16 nbrAlarmsThatAreDisabled = 0;
uint16 nbrAlarmsThatTriggerFSP  = 0;
uint16 nbrAlarmsThatTriggerRT   = 0;

/* Used to check SMU ISR groups config */
volatile boolean isrConfigTestRunningSMU = FALSE;

/* Used to visualize alarms in OneEye */
RuntimeAlarmHandle runtimeAlarmHandleNotConfiguredAlarm;

/*********************************************************************************************************************/
/*-------------------------Function Prototypes-----------------------------------------------------------------------*/
/*********************************************************************************************************************/
void initFunctionExecutionStatusSMU(SmuExecutionStatusType *SmuExecutionStatusType);
SmuStatusType initSMUAlarmsSMU(void);
SmuStatusType activateSMU(void);
SmuStatusType checkIsrConfigSMU(void);

IFX_INTERRUPT(isr0SMU, CPU_WHICH_RUN_SMU, ISR_PRORITY_SMU_ISR_0);
IFX_INTERRUPT(isr1SMU, CPU_WHICH_RUN_SMU, ISR_PRORITY_SMU_ISR_1);
IFX_INTERRUPT(isr2SMU, CPU_WHICH_RUN_SMU, ISR_PRORITY_SMU_ISR_2);

/*********************************************************************************************************************/
/*-------------------------Function Implementations------------------------------------------------------------------*/
/*********************************************************************************************************************/
/*
 * alarm interrupt routine 0, insert here the routine wanted when the interrupt is called
 * */
void isr0SMU(void)
{
    uint16 nbrRaisedAlarm;
    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* nbr_raised_alarm > 0  : An alarm was triggered which is listed in alarmsThatTriggerIsr1 and which was not
     * yet pending
     * nbr_raised_alarm == 0 : An alarm was triggered which is not listed in alarmsThatTriggerIsr1, therefore it
     * is probably
     * one of the alarms configured with default configuration during Application SSW
     * */
    nbrRaisedAlarm = detectAlarmSourceSMU(&alarmsThatTriggerIsr0[0], nbrAlarmsThatTriggerIsr0);

    /* Probably one of the alarms configured with default configuration during Application SSW */
    if(nbrRaisedAlarm == 0 && DEFAULT_ALARM_ACTION == IfxSmu_InternalAlarmAction_igcs0)
    {
        IfxCpu_disableInterrupts();
        runtimeAlarmHandleNotConfiguredAlarm = (RuntimeAlarmHandle){&globalAlarmConfig[0], pending};
        g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter] =
                &runtimeAlarmHandleNotConfiguredAlarm;
        g_SlkStatus.smuAlarmPending.alarmCounter++;
        IfxCpu_enableInterrupts();
    }

    if (!isrConfigTestRunningSMU){
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq0);
    }
}

/*
 * alarm interrupt routine 1, insert here the routine wanted when the interrupt is called
 * */
void isr1SMU(void)
{
    uint16 nbrRaisedAlarm;

    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* nbr_raised_alarm > 0  : An alarm was triggered which is listed in alarmsThatTriggerIsr1 and which was not yet
     * pending
     * nbr_raised_alarm == 0 : An alarm was triggered which is not listed in alarmsThatTriggerIsr1, therefore it is
     * probably
     * one of the alarms configured with default configuration during Application SSW
     * */
    nbrRaisedAlarm = detectAlarmSourceSMU(&alarmsThatTriggerIsr1[0], nbrAlarmsThatTriggerIsr1);

    /* Probably one of the alarms configured with default configuration during Application SSW */
    if(nbrRaisedAlarm == 0 && DEFAULT_ALARM_ACTION == IfxSmu_InternalAlarmAction_igcs1)
    {
        IfxCpu_disableInterrupts();

        runtimeAlarmHandleNotConfiguredAlarm = (RuntimeAlarmHandle){&globalAlarmConfig[0], pending};
        g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter] =
                &runtimeAlarmHandleNotConfiguredAlarm;
        g_SlkStatus.smuAlarmPending.alarmCounter++;
        IfxCpu_enableInterrupts();
    }
    /* nbr_raised_alarm < 0 : do nothing */

    if (!isrConfigTestRunningSMU)
    {
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq1);
    }
}

/*
 * alarm interrupt routine 2, insert here the routine wanted when the interrupt is called
 * */
void isr2SMU(void)
{
    uint16 nbrRaisedAlarm;

    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* nbr_raised_alarm > 0  : An alarm was triggered which is listed in alarmsThatTriggerIsr1 and which was not yet
     * pending
     * nbr_raised_alarm == 0 : An alarm was triggered which is not listed in alarmsThatTriggerIsr1, therefore it is
     * probably
     * one of the alarms configured with default configuration during Application SSW
     * */
    nbrRaisedAlarm = detectAlarmSourceSMU(&alarmsThatTriggerIsr2[0], nbrAlarmsThatTriggerIsr2);

    /* Probably one of the alarms configured with default configuration during Application SSW */
    if(nbrRaisedAlarm == 0 && DEFAULT_ALARM_ACTION == IfxSmu_InternalAlarmAction_igcs2)
    {
        IfxCpu_disableInterrupts();

        runtimeAlarmHandleNotConfiguredAlarm = (RuntimeAlarmHandle){&globalAlarmConfig[0], pending};
        g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter] =
                &runtimeAlarmHandleNotConfiguredAlarm;
        g_SlkStatus.smuAlarmPending.alarmCounter++;
        IfxCpu_enableInterrupts();
    }

    if (!isrConfigTestRunningSMU)
    {
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq2);
    }
}

/*
 * check the configuration of SMU ISRs
 * */
SmuStatusType checkIsrConfigSMU(void)
{
    uint8 smuIsrSts;
    uint32 isrTestTimeout = 0xfff;
    TargetPES configPES;


    /* Check if SMU interrupts are setup correctly by triggering SOFT_SMU_ALM_CFG_CHECK (sw_alm0)
     * This alarm is initially configured to trigger IGCS0 reaction, but we will change its config
     * on purpose to also check IGCS1 and IGCS2
     * Also disable PES during test to avoid triggering it
     */

    configPES = SMU_AGC.B.PES;

    /* Unlocks the SMU configuration registers for modification */
    g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SlkStatus.unlockConfig == TRUE)
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    IfxSmu_configAlarmActionPES(disablePES);
    IfxSmu_temporaryLockConfigRegisters();

    for (uint8 k=0; k<3; k++)
    {
        IfxSmu_setAlarmAction(SOFT_SMU_ALM_CFG_CHECK, IfxSmu_InternalAlarmAction_igcs0 + k);

        isrConfigTestRunningSMU = TRUE;
        g_SlkStatus.smuStatus.smuCoreSWAlarmTriggerSts = softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_CFG_CHECK);

        /* Wait for configured interrupts to be reached and processed */
        do{
            isrTestTimeout--;
            smuIsrSts = SMU_AEX.B.IRQ2STS << 2 | SMU_AEX.B.IRQ1STS << 1 | SMU_AEX.B.IRQ0STS;

        }while ((smuIsrSts != configArrayIGCS[k].igcs_config) && (isrTestTimeout > 0));

        isrConfigTestRunningSMU = FALSE;
        IfxSmu_clearAlarmStatus(SOFT_SMU_ALM_CFG_CHECK);
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq0);
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq1);
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq2);

        /* Wait until alarmCounter is incremented to decrement it afterwards again and to clear alarm in
         * g_SlkStatus.smuAlarmPending structure */
        volatile uint16 timeout = 0xFFFF;/* Note STHE: added "volatile" as it didn't work always without */
        do
        {
            __nop();
        }
        while(timeout-- && !g_SlkStatus.smuAlarmPending.alarmCounter);

        if(g_SlkStatus.smuAlarmPending.alarmCounter > 0)
        {
            /* Set alarmState to "notPending", decrement alarmCounter */
            g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1]->alarmState =
                    notPending;
            g_SlkStatus.smuAlarmPending.alarmCounter--;
        }

        if (isrTestTimeout == 0)
        {
            IfxSmu_setAlarmAction(SOFT_SMU_ALM_CFG_CHECK, IfxSmu_InternalAlarmAction_disabled);

            /* Unlocks the SMU configuration registers for modification */
            g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
            if (g_SlkStatus.unlockConfig == TRUE)
            {
                g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
            }
            else
            {
                g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
            }
            IfxSmu_configAlarmActionPES(configPES);
            IfxSmu_temporaryLockConfigRegisters();

            return fail;
        }
    }
    IfxSmu_setAlarmAction(SOFT_SMU_ALM_CFG_CHECK, IfxSmu_InternalAlarmAction_disabled);

    /* Unlocks the SMU configuration registers for modification */
    g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SlkStatus.unlockConfig == TRUE)
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    IfxSmu_configAlarmActionPES(configPES);
    IfxSmu_temporaryLockConfigRegisters();

    return pass;

}

/*
 * activate the  SMU, enable transition from run to fault state and enable configuration of KEYS locked
 * registers and checks if the SMU has really been started
 * */
SmuStatusType activateSMU(void)
{
    boolean configApplied = FALSE;

    IfxSmu_unlockConfigRegisters();

    /* Mandatory check! currently not done by the iLLD function IfxSmu_activateRunState */
    if(MODULE_SMU.DBG.B.SSM == IfxSmu_SmuState_run)
    {
        return pass;
    }
    else if(MODULE_SMU.DBG.B.SSM == IfxSmu_SmuState_start)
    {
        IfxSmu_activateRunState();
        configApplied = (SMU_STS.B.CMD == IfxSmu_Command_start);
        configApplied &= (!SMU_STS.B.RES)&(IfxSmu_getSmuState() == IfxSmu_SmuState_run);
    }
    else if(MODULE_SMU.DBG.B.SSM == IfxSmu_SmuState_fault)
    {
        IfxSmu_releaseFSP();
        uint32 timeoutSmu = 0x0FFFFFFF;
        do
        {
            __nop();
        }while(IfxSmu_getSmuState() != IfxSmu_SmuState_run && timeoutSmu--);
        configApplied = TRUE;
    }
    else
    {
        __debug();
    }

    IfxSmu_temporaryLockConfigRegisters();

    if(configApplied)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * configure the SMU and registers related to alarm setup according to the globalAlarmConfig array
 * */
SmuStatusType initSMUAlarmsSMU(void)
{
    uint8 smuInterruptsToEnable = configArrayIGCS[0].igcs_config | configArrayIGCS[1].igcs_config
            | configArrayIGCS[2].igcs_config;
    boolean configApplied = FALSE;

    /* Configure alarm internal reaction according to globalAlarmConfig set by user */
    for(int i=0; i<USER_ALARM_NUMBER; i++)
    {
        IfxSmu_setAlarmAction(globalAlarmConfig[i].alarm, globalAlarmConfig[i].alarmReaction);

        /* Each IGCS group can trigger up to 3 isr simultaneously, so each alarm that can trigger a specific
         * isr (according to its IGCS group) is put in the corresponding array to speed-up the alarm source
         * detection process */
        for (uint8 k=0; k<3; k++)
        {
            if (globalAlarmConfig[i].alarmReaction == configArrayIGCS[k].igcs_id)
            {
                if (configArrayIGCS[k].igcs_config & 0x1)
                {
                    alarmsThatTriggerIsr0[nbrAlarmsThatTriggerIsr0] = (RuntimeAlarmHandle){&globalAlarmConfig[i],
                                    notPending};
                    nbrAlarmsThatTriggerIsr0++;
                }
                if (configArrayIGCS[k].igcs_config & 0x2)
                {
                    alarmsThatTriggerIsr1[nbrAlarmsThatTriggerIsr1] = (RuntimeAlarmHandle){&globalAlarmConfig[i],
                                    notPending};
                    nbrAlarmsThatTriggerIsr1++;
                }
                if (configArrayIGCS[k].igcs_config & 0x4)
                {
                    alarmsThatTriggerIsr2[nbrAlarmsThatTriggerIsr2] = (RuntimeAlarmHandle){&globalAlarmConfig[i],
                                    notPending};
                    nbrAlarmsThatTriggerIsr2++;
                }
            }
        }

        /* Check if alarm external reaction is enabled */
        if (globalAlarmConfig[i].externalReactionEnabled)
        {
            alarmsThatTriggerFSP[nbrAlarmsThatTriggerFSP] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatTriggerFSP ++;
        }

        /* Check if alarm should trigger Recovery Timer */
        if (globalAlarmConfig[i].triggerRecoveryTimer)
        {
            alarmsThatTriggerRT[nbrAlarmsThatTriggerRT] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatTriggerRT ++;
        }

        if(globalAlarmConfig[i].alarmReaction == IfxSmu_InternalAlarmAction_nmi)
        {
            alarmsThatTriggerNMI[nbrAlarmsThatTriggerNMI] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatTriggerNMI ++;
        }

        if(globalAlarmConfig[i].alarmReaction == IfxSmu_InternalAlarmAction_disabled)
        {
            alarmsThatAreDisabled[nbrAlarmsThatAreDisabled] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatAreDisabled ++;
        }
    }
    /* Unlocks the SMU configuration registers for modification */
    g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SlkStatus.unlockConfig == TRUE)
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }
    /* Configure each Interrupt Generation Configuration Set according to user config */
    IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

        SMU_AGC.B.IGCS0 = configArrayIGCS[0].igcs_config;
        configApplied = (SMU_AGC.B.IGCS0 == configArrayIGCS[0].igcs_config);

        SMU_AGC.B.IGCS1 = configArrayIGCS[1].igcs_config;
        configApplied &= (SMU_AGC.B.IGCS1 == configArrayIGCS[1].igcs_config);

        SMU_AGC.B.IGCS2 = configArrayIGCS[2].igcs_config;
        configApplied &= (SMU_AGC.B.IGCS2 == configArrayIGCS[2].igcs_config);

    IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

    /* Enable required interrupts */
    if (smuInterruptsToEnable & 0x1)
    {
        IfxSrc_init(&SRC_SMU_SMU0_SR0, IfxCpu_Irq_getTos(CPU_WHICH_RUN_SMU), ISR_PRORITY_SMU_ISR_0);
        IfxSrc_enable(&SRC_SMU_SMU0_SR0);
    }

    if (smuInterruptsToEnable & 0x2)
    {
        IfxSrc_init(&SRC_SMU_SMU0_SR1, IfxCpu_Irq_getTos(CPU_WHICH_RUN_SMU), ISR_PRORITY_SMU_ISR_1);
        IfxSrc_enable(&SRC_SMU_SMU0_SR1);
    }

    if (smuInterruptsToEnable & 0x4)
    {
        IfxSrc_init(&SRC_SMU_SMU0_SR2, IfxCpu_Irq_getTos(CPU_WHICH_RUN_SMU), ISR_PRORITY_SMU_ISR_2);
        IfxSrc_enable(&SRC_SMU_SMU0_SR2);
    }

    /* Non Maskable Interrupt config/enabling on CPUs */
    /* Comment and/or uncomment depending on the CPU targeted */
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Enable trap requests for the CPU, which takes care of the SMU software */
#if  CPU_WHICH_RUN_SMU == 0
    SCU_TRAPDIS0.B.CPU0SMUT = 0;
#elif CPU_WHICH_RUN_SMU == 1
    SCU_TRAPDIS0.B.CPU1SMUT = 0;
#elif CPU_WHICH_RUN_SMU == 2
    SCU_TRAPDIS0.B.CPU2SMUT = 0;
#endif

    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    if(configApplied)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * This function enable the structure where we save the config
 * */
void initFunctionExecutionStatusSMU(SmuExecutionStatusType *functionExecutionStatus)
{
    functionExecutionStatus->structInitSts                      = NA;
    functionExecutionStatus->smuCoreAlarmConfigSts              = NA;
    functionExecutionStatus->smuCoreKeysTestSts                 = NA;
    functionExecutionStatus->smuCoreKeysTestClearSts            = NA;
    functionExecutionStatus->stdbySmuFspReactionEnableSts       = NA;
    functionExecutionStatus->smuStdbyFSP0DrivingEnableSts       = NA;
    functionExecutionStatus->smuStdbyFSP1DrivingEnableSts       = NA;
    functionExecutionStatus->smuCoreInitSts                     = NA;
    functionExecutionStatus->smuCoreAlarmPESSetSts              = NA;
    functionExecutionStatus->smuCoreFSPConfigSts                = NA;
    functionExecutionStatus->smuCoreFSPReactionToAlarmConfigSts = NA;
    functionExecutionStatus->smuRecoveryTimerConfigSts          = NA;
    functionExecutionStatus->smuCoreSWAlarmTriggerSts           = NA;
}

/*
 * Initial SMU module
 * */
void initSMUModule(void)
{
    /* Prevention of double SMU reset */
    IfxScuWdt_clearSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());
    SCU_WDTSCON1.B.CLRIRF = 1;
    IfxScuWdt_setSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());

    /* Initialize the structure containing the execution state of SMU sensitive functions */
    initFunctionExecutionStatusSMU(&g_SlkStatus.smuStatus);

    /* Test if SM:SMU:LOCK is working */
    enableKeysTestSMU();

    /* Reset alarmCounter */
    g_SlkStatus.smuAlarmPending.alarmCounter = 0;

    /* Set result to fail */
    SmuStatusType result = fail;

    /* Fill the RuntimeAlarmHandle structures and configure alarms */
    result = initSMUAlarmsSMU();
    g_SlkStatus.smuStatus.smuCoreAlarmConfigSts = result;

    /* Enable and configure the PES */
    uint8 pesAction = onPESIGCS1;

    g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SlkStatus.unlockConfig == TRUE)
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    IfxSmu_configAlarmActionPES(pesAction);
    IfxSmu_temporaryLockConfigRegisters();

    /* Validation if PES configuration was successful */
    IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());
    if(MODULE_SMU.AGC.B.PES != pesAction)
    {
        result = fail;
    }
    IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());
    g_SlkStatus.smuStatus.smuCoreAlarmPESSetSts = result;

    /* Enable and configure the recovery Timer (maximum value for the duration is 0xffffff) */
    enableRecoveryTimerSMU(0xffffff);

    /* Enable and configure the FSP */
    enableFSPcoreSMU(IfxSmu_FspMode_BiStableProtocol, IfxSmu_FspPrescalar1_referenceClockDiv2,
            IfxSmu_FspPrescalar2_referenceClockDiv4096);

    enableFSPstdbySMU();

    /* Enable the SMU */
    result = activateSMU();
    g_SlkStatus.smuStatus.smuCoreInitSts = result;

    /* Check if IGCSx group config is valid and if SMU ISRs are reachable */
    result = checkIsrConfigSMU();
    g_SlkStatus.smuStatus.smuCoreAlarmConfigSts &= result;
}

/*
 * This function configures the alarm action for every alarm which has no default alarm configuration set
 * Note: This function is only configuring every alarm with with default alarm group configuration but
 * SMU configuration and interrupt handling is still required and implemented in the function initMMU_Module.
 * Every alarm which is not explicitly reconfigured in the function initSMUModule will keep the default
 * configuration as configured in this function.
 * */
void slkEnableAllSMUAlarms(void)
{
    /* Enable SMU Module */
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    MODULE_SMU.CLC.B.DISS = 0;
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* First determine the target configuration */
    uint32 alarmGroupCF0[IFXSMU_NUM_ALARM_GROUPS] = {0};
    uint32 alarmGroupCF1[IFXSMU_NUM_ALARM_GROUPS] = {0};
    uint32 alarmGroupCF2[IFXSMU_NUM_ALARM_GROUPS] = {0};

    /* Iterate through all groups */
    for(uint8 alarmGroup = 0; alarmGroup < IFXSMU_NUM_ALARM_GROUPS ; alarmGroup++)
    {
        /* Iterate through all alarms of every group */
        for(uint8 alarmPos = 0 ; alarmPos < 32 ; alarmPos++)
        {
            /* Determine if there is already an alarm action configured for the alarm at position alarmPos
             * of group alarmGroup */
            IfxSmu_InternalAlarmAction alarmAction =
                    (IfxSmu_InternalAlarmAction)(((MODULE_SMU.AGCF[alarmGroup][0].U >> alarmPos) & 0x1)      |
                                                 ((MODULE_SMU.AGCF[alarmGroup][1].U >> alarmPos) & 0x1) << 1 |
                                                 ((MODULE_SMU.AGCF[alarmGroup][2].U >> alarmPos) & 0x1) << 2 );

            /* If the alarm is still disabled enable it with the alarm action defined by the macro
             * DEFAULT_ALARM_ACTION */
            if(alarmAction == IfxSmu_InternalAlarmAction_disabled)
            {
                alarmGroupCF0[alarmGroup] |= ( DEFAULT_ALARM_ACTION         & 0x01) << alarmPos;
                alarmGroupCF1[alarmGroup] |= ((DEFAULT_ALARM_ACTION >> 1)   & 0x01) << alarmPos;
                alarmGroupCF2[alarmGroup] |= ((DEFAULT_ALARM_ACTION >> 2)   & 0x01) << alarmPos;
            }
            /* Else don't modify the alarm action. (Write the previously determined alarmAction to the
             * registers alarmGroupCF0,
             * alarmGroupCF1 and alarmGroupCF2 */
            else
            {
                alarmGroupCF0[alarmGroup] |= ( alarmAction         & 0x01) << alarmPos;
                alarmGroupCF1[alarmGroup] |= ((alarmAction >> 1)   & 0x01) << alarmPos;
                alarmGroupCF2[alarmGroup] |= ((alarmAction >> 2)   & 0x01) << alarmPos;
            }
        }
    }

    /* Unlocks the SMU configuration registers for modification */
    g_SlkStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SlkStatus.unlockConfig == TRUE)
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SlkStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    for(uint8 alarmGroup = 0; alarmGroup < IFXSMU_NUM_ALARM_GROUPS ; alarmGroup++)
    {
        /* Disable the write-protection for registers */
        IfxScuWdt_clearSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());

        MODULE_SMU.AGCF[alarmGroup][0].U = alarmGroupCF0[alarmGroup];
        MODULE_SMU.AGCF[alarmGroup][1].U = alarmGroupCF1[alarmGroup];
        MODULE_SMU.AGCF[alarmGroup][2].U = alarmGroupCF2[alarmGroup];

        /* Restore back the write-protection for registers */
        IfxScuWdt_setSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());
    }

    /* After configuration set temporary lock of SMU configuration */
    IfxSmu_temporaryLockConfigRegisters();
}

/*
 * test if the alarm is really a software alarm, then if so triggers it
 * SM:SMU:APPLICATION_SW_ALARM
 * */
SmuStatusType softwareCoreAlarmTriggerSMU(IfxSmu_Alarm alarm)
{
    boolean configApplied = FALSE;

    /* Check that the alarm is of the good group (10) and that the index is strictly lower
     * than 16 to be sure that the alarm given in parameter is a software alarm
     */
    if (((alarm / 32) == 10) & ((alarm % 32) < 16))
    {
        IfxSmu_setAlarmStatus(alarm);
    }

    configApplied = ~IfxSmu_getAlarmStatus(alarm);
    configApplied &= ~(SMU_STS.B.RES);

    if (configApplied)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * clear the alarm status flag in the AG registers and disable all the reaction
 * configured for this alarm.
 * */
SmuStatusType coreAlarmReactionClearSMU(RuntimeAlarmHandle *activeAlarm)
{
    boolean ack = FALSE;
    SmuSR configIGCSGroup = SmuNAN;

    IfxSmu_clearAlarmStatus(activeAlarm->alarmConfig->alarm);
    ack = (IfxSmu_getAlarmStatus(activeAlarm->alarmConfig->alarm) == 0);

    /* Also clear FSP alarm if FSP was configured to be triggered */
    if (activeAlarm->alarmConfig->alarm == IfxSmu_Alarm_SMU_Error_PinFaultStateActivation)
    {
        /* Alarm has triggered the FSP */
        IfxSmu_releaseFSP();
    }

    /* Check if alarm group triggers a Port Emergency Stop */
    if (MODULE_SMU.AGC.B.PES == (0x1 << (activeAlarm->alarmConfig->alarmReaction - 0x2)))
    {
        /* EMS has been triggered by SMU */
        if (SMU_AEX.B.EMSSTS && MODULE_SCU.EMSR.B.SEMSF)
        {
            /* Clear SMU EMS status flags */
            IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

                SMU_AEXCLR.B.EMSCLR     = 1;
                SMU_AEXCLR.B.EMSAEMCLR     = 1;

            IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
        }
    }

    /* Get the config of the used IGCS group */
    for (uint8 i=0; i<3; i++)
    {
        if (activeAlarm->alarmConfig->alarmReaction == configArrayIGCS[i].igcs_id)
        {
            configIGCSGroup = configArrayIGCS[i].igcs_config;
            break;
        }
    }

    /* Reset necessary Action EXecuted IRQx flags */
    if (configIGCSGroup & 0x1)
    {
        IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
            SMU_AEXCLR.B.IRQ0CLR = 1;
        IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

        ack &= ~SMU_AEX.B.IRQ0STS;
    }

    if (configIGCSGroup & 0x2)
    {
        IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
            SMU_AEXCLR.B.IRQ1CLR = 1;
        IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

        ack &= ~SMU_AEX.B.IRQ1STS;
    }

    if (configIGCSGroup & 0x4)
    {
        IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
            SMU_AEXCLR.B.IRQ2CLR = 1;
        IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

        ack &= ~SMU_AEX.B.IRQ2STS;
    }

    /* SMU STDBY exception for undervoltage alarms */
    /* If IfxSmu_Alarm_EVR_Undervoltage_Alarm or IfxSmu_Alarm_HSM_Undervoltage_Alarm is active the
     * corresponding alarm is SMU_stdby is also active, therefore also reset the standby alarms*/
    if(activeAlarm->alarmConfig->alarm == IfxSmu_Alarm_EVR_Undervoltage_Alarm)
    {
        /* Clear the EVR VEXT under voltage alarm in SMU STDBY */
        ack &= clearBitSMUstdby(smuStdbyAlarmEVRVEXTUnderVoltage);
    }

    if(activeAlarm->alarmConfig->alarm == IfxSmu_Alarm_HSM_Undervoltage_Alarm)
    {
        /* Clear the HSM VEXT under voltage alarm in SMU STDBY */
        ack &= clearBitSMUstdby(smuStdbyAlarmHSMVEXTUnderVoltage);
    }

    if(ack)
    {

        /* If the alarm cleared is not the last of the pending alarm list, we need to replace its
         * value in the list by the last alarm of the list to avoid holes in the list
         */
        if (!(g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1]
                == activeAlarm))
        {
            for (uint16 i=0; i<USER_ALARM_NUMBER; i++)
            {
                if (g_SlkStatus.smuAlarmPending.lastAlarmRaised[i] == activeAlarm)
                {
                    g_SlkStatus.smuAlarmPending.lastAlarmRaised[i] =
                    g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1];
                }
            }
        }
        g_SlkStatus.smuAlarmPending.alarmCounter--;
        activeAlarm->alarmState = notPending;
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * Detect and report every active alarm not already reported in a specific reaction group
 * */
uint16 detectAlarmSourceSMU(RuntimeAlarmHandle *alarmArray, uint16 nbrAlarms)
{
    uint16 nbrAlarmReported = 0;
    for (uint16 i=0; i<nbrAlarms; i++)
    {
        if (alarmArray[i].alarmState == notPending)
        {
            if (IfxSmu_getAlarmStatus(alarmArray[i].alarmConfig->alarm))
            {
                alarmArray[i].alarmState = pending;
                __disable();
                g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter] =&
                        alarmArray[i];
                g_SlkStatus.smuAlarmPending.alarmCounter++;
                __enable();
                nbrAlarmReported++;

                /* Perform callback function if non void */
                if (alarmArray[i].alarmConfig->functionToCallOnDetection != NULL_PTR)
                {
                    (alarmArray[i].alarmConfig->functionToCallOnDetection)();
                }

                /* Stop recovery timer after alarm handling is done. */
                if (alarmArray[i].alarmConfig->triggerRecoveryTimer)
                {
                    if(configRecoveryTimerSMU.RT0)
                    {
                        IfxSmu_stopRT(0);
                    }

                    if(configRecoveryTimerSMU.RT1)
                    {
                        IfxSmu_stopRT(1);
                    }
                }
            }
        }
        else /* alarmArray[i].alarmState == pending */
        {
            if (IfxSmu_getAlarmStatus(alarmArray[i].alarmConfig->alarm))
            {
                /* Same alarm which is still pending is triggered again.
                 * Therefore only increment counter variable and do nothing else*/
                nbrAlarmReported++;
            }
        }
    }
    return nbrAlarmReported;
}

/*
 * Reset all previously active alarms
 * */
SmuStatusType resetAllAlarmsSMU(void)
{
    SmuStatusType ack = fail;
    uint16 nbrAlarmToClear = g_SlkStatus.smuAlarmPending.alarmCounter;

    for (uint16 i=0; i<nbrAlarmToClear; i++)
    {
        if ( IfxSmu_getAlarmStatus(g_SlkStatus.smuAlarmPending.lastAlarmRaised[i]->alarmConfig->alarm) && \
                                  (g_SlkStatus.smuAlarmPending.lastAlarmRaised[i]->alarmState == pending))
        {
            ack = coreAlarmReactionClearSMU(g_SlkStatus.smuAlarmPending.lastAlarmRaised[i]);
            if (ack == fail)
            {
                return fail;
            }
        }
        else
        {
            g_SlkStatus.smuAlarmPending.alarmCounter--;
        }
    }

    return pass;
}

/*
 * Call out function for NMI
 * */
void slkNmiCallout(IfxCpu_Trap trapWatch)
{
    /* Check if NMI was called due to an SMU alarm */
    if ((IfxSmu_getAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_nmi)) &&
        (IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest_smu)))
    {
        /* Implement appropriate reaction */
        /* Check if an alarm, which is intended to trigger an NMI has been triggered, if yes stop recovery timer */
        /* Note: if the alarm is triggered a second time before it got reset via OneEye, the function
         * detectAlarmSourceSMU() will not stop the recovery timer */
        detectAlarmSourceSMU(&alarmsThatTriggerNMI[0], nbrAlarmsThatTriggerNMI);

        /* Clear alarm executed status bit*/
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_nmi);

        /* Clear SMU Alarm Trap Request Flag */
        IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest_smu);
    }
}

/*
 * Alarm handling functions
 * */
void slkWatchdogAlarmHandling(void)
{
    g_SlkStatus.slkRunTask.stopCpuWatchdogService = FALSE;
    g_SlkStatus.slkRunTask.stopSafetyWatchdogService = FALSE;
}
