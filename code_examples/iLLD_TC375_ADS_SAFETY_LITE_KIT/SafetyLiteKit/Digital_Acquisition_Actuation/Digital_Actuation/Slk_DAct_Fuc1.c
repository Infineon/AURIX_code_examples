/**********************************************************************************************************************
 * \file Slk_DAct_Fuc1.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Digital_Acquisition_Actuation/Digital_Actuation/Slk_DAct_Fuc1.h"
#include "Digital_Acquisition_Actuation/Slk_DA_Global.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxCcu6_Timer.h"
#include "IfxGtm_Tom_Pwm.h"
#include "IfxCcu6_TPwm.h"
#include "IfxIom.h"
#include "IfxIom_Driver.h"
#include "IfxSmu.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IFX_EXTERN IfxGtm_Tom_Pwm_Driver    g_tomPwmMissionHandler;    /* Handler for TOM PWM mission signal configuration   */
IFX_EXTERN IfxCcu6_TPwm             g_ccu61PwmReferenceHandler;

IfxIom_Driver                       g_iomDriverDActFuc1;          /* IOM driver handle */
IfxIom_Driver_Lam                   g_iomLamDActFuc1;             /* IOM LAM driver handle */
IfxIom_Driver_Config                g_iomConfigDriverDActFuc1;    /* IOM driver configuration */
IfxIom_Driver_LamConfig             g_iomConfigLamDActFuc1;       /* IOM LAM configuration */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initMissionGtmTomFuc1(void);
void initMonitorCcu6(void);
void configIomFuc1(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * initialized TOM as mission signal
 * */
void initMissionGtmTomFuc1(void)
{
    IfxGtm_Tom_Pwm_Config pwmOutputMissionSignalConfig;
    IfxGtm_Tom_Pwm_initConfig(&pwmOutputMissionSignalConfig, &MODULE_GTM); /* Initialize default parameters */

    pwmOutputMissionSignalConfig.tom = GTM_TOM_SAFE_PIN.tom;            /* Select the TOM */
    pwmOutputMissionSignalConfig.tomChannel = GTM_TOM_SAFE_PIN.channel; /*Select the channel */
    pwmOutputMissionSignalConfig.pin.outputPin = &GTM_TOM_SAFE_PIN;     /* Set the port pin as output */
    pwmOutputMissionSignalConfig.clock = DA_TOM_CLOCK_SOURCE;           /* Select the clock source*/
    pwmOutputMissionSignalConfig.synchronousUpdateEnabled = TRUE;       /* Enable synchronous update */
    pwmOutputMissionSignalConfig.period = TOM_PWM_PERIOD;               /* Set the timer period */
    pwmOutputMissionSignalConfig.dutyCycle = (uint32) (TOM_DUTY_CYCLE * 0.01 * pwmOutputMissionSignalConfig.period);
    pwmOutputMissionSignalConfig.immediateStartEnabled = FALSE;         /* Disable immediate start */

    /* Initialize the GTM TOM */
    boolean success = IfxGtm_Tom_Pwm_init(&g_tomPwmMissionHandler, &pwmOutputMissionSignalConfig);
    if(!success)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
        return;
    }

    /* Validate if configuration was written successfully to the registers */
    slkTomPwmConfigReadBack(&pwmOutputMissionSignalConfig, SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
}

/*
 * initialized TOM as monitor signal
 * */
void initMonitorCcu6(void)
{
    IfxCcu6_TPwm_Config pwmOutputReferenceSignalConfig;

    /* Initialize default parameters */
    IfxCcu6_TPwm_initModuleConfig(&pwmOutputReferenceSignalConfig, CCU6_REF_PIN.module);

    /* Set same frequency as configured for CMU CLK0 which is used by TOM */
    pwmOutputReferenceSignalConfig.base.frequency = IfxGtm_Cmu_getClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, TRUE);
    pwmOutputReferenceSignalConfig.base.period = TOM_PWM_PERIOD;
    pwmOutputReferenceSignalConfig.base.waitingTime = 0;
    /*select the active state of the output */
    pwmOutputReferenceSignalConfig.base.activeState = Ifx_ActiveState_high;

    /* select the timer through which PWM is to be generated */
    pwmOutputReferenceSignalConfig.timer = IfxCcu6_TimerId_t12;

    /* Configure the clock for internal mode */
    pwmOutputReferenceSignalConfig.clock.t12ExtClockEnabled   = FALSE;
    pwmOutputReferenceSignalConfig.clock.t12countingInputMode = IfxCcu6_CountingInputMode_internal;

    /* Configure the selected timer block */
    pwmOutputReferenceSignalConfig.timer12.channelId        = IfxCcu6_T12Channel_2;
    pwmOutputReferenceSignalConfig.timer12.clockInput       = IfxCcu6_TimerInputClock_fcc6;
    pwmOutputReferenceSignalConfig.timer12.counterValue     = 0;
    pwmOutputReferenceSignalConfig.timer12.compareValue = (uint16) (TOM_DUTY_CYCLE * 0.01
                                                            * pwmOutputReferenceSignalConfig.base.period);

    /* Select the channel out for modulation */
    pwmOutputReferenceSignalConfig.channelOut = IfxCcu6_ChannelOut_cc2;

    /* Pin configuration */
    IfxCcu6_TPwm_Pins pins = {
        NULL_PTR,                               /* CC60Out pin not used */
        NULL_PTR,                               /* CC61Out pin */
        &CCU6_REF_PIN,                          /* CC62Out pin not used */
        NULL_PTR,                               /* COUT60 pin not used */
        NULL_PTR,                               /* COUT61 pin not used */
        NULL_PTR,                               /* COUT62 pin not used */
        NULL_PTR,                               /* COUT63 pin not used */
        IfxPort_OutputMode_pushPull,
        IfxPort_PadDriver_cmosAutomotiveSpeed1,
        NULL_PTR,
        NULL_PTR,
        IfxPort_InputMode_pullUp
    };
    pwmOutputReferenceSignalConfig.pins = &pins;

    /* Configure input and output triggers */
    pwmOutputReferenceSignalConfig.trigger.t12ExtInputTrigger   = NULL_PTR;
    pwmOutputReferenceSignalConfig.trigger.t13ExtInputTrigger   = NULL_PTR;
    pwmOutputReferenceSignalConfig.trigger.t13InSyncWithT12     = FALSE;
    pwmOutputReferenceSignalConfig.trigger.outputTriggerEnabled = FALSE;

    /* Initialize the CCU6 */
    IfxCcu6_TPwm_initModule(&g_ccu61PwmReferenceHandler, &pwmOutputReferenceSignalConfig);
}

/*
 * initialized IOM for monitoring
 * */
void configIomFuc1(void)
{
    /* Disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    /* IOM monitor input */
    IfxPort_setPinMode(IOM_MONITOR_PIN, IfxPort_Mode_inputPullDown);

    /* Initialization of the IOM module */
    IfxIom_enableModule(&MODULE_IOM, CLOCK_DIVIDER);
    /* Creation of the IOM default configuration */
    IfxIom_Driver_initConfig(&g_iomConfigDriverDActFuc1, &MODULE_IOM);
    IfxIom_Driver_init(&g_iomDriverDActFuc1, &g_iomConfigDriverDActFuc1);       /* Apply the configuration */

    /* Creation of a default LAM configuration */
    IfxIom_Driver_initLamConfig(&g_iomConfigLamDActFuc1, &g_iomDriverDActFuc1);

    g_iomConfigLamDActFuc1.channel = IfxIom_LamId_0; /* Selection of LAM ID 0 */

    /* Configuration of the Monitor signal */
    g_iomConfigLamDActFuc1.mon.input = IOM_MONITOR_INPUT;                     /* IOM - Monitor signal input */
    g_iomConfigLamDActFuc1.mon.filter.mode = IfxIom_LamFilterMode_noFilter;   /* No filter applied on the signal */
    g_iomConfigLamDActFuc1.mon.inverted = FALSE;                              /* Input signal NOT inverted */

    /* Configuration of the Reference signal */
    g_iomConfigLamDActFuc1.ref.input = IOM_CCU6_REFERENCE_INPUT;             /* IOM - Reference signal input */
    g_iomConfigLamDActFuc1.ref.filter.mode = IfxIom_LamFilterMode_noFilter;  /* No filter applied on the signal */
    g_iomConfigLamDActFuc1.ref.inverted = FALSE;                             /* Input signal NOT inverted */

    /* Configuration of the Event Window */
    /* Event window generation determined from the source signal */
    g_iomConfigLamDActFuc1.eventWindow.controlSource = IfxIom_LamEventWindowControlSource_mon;
    /* Event generation window is not gated */
    g_iomConfigLamDActFuc1.eventWindow.run = IfxIom_LamEventWindowRunControl_freeRunning;
    /* Window clears at any edge */
    g_iomConfigLamDActFuc1.eventWindow.clearEvent = IfxIom_LamEventWindowClearEvent_anyEdge;
    g_iomConfigLamDActFuc1.eventWindow.threshold = IOM_DUTY_THRESHOLD;        /* Set the threshold */
    g_iomConfigLamDActFuc1.eventWindow.inverted = FALSE;                      /* Window: NOT INVERTED */

    /* Configuration of the IOM event. IfxSmu_Alarm_IOM_Pin_MismatchIndication will be triggered if event
    * is detected. */
    /* Signal comparison: Reference XOR Monitor */
    g_iomConfigLamDActFuc1.event.source = IfxIom_LamEventSource_monXorRef;
    /* Falling edge is used for event generation */
    g_iomConfigLamDActFuc1.event.trigger = IfxIom_LamEventTrigger_fallingEdge;
    /* Alarm generated after 1 event*/
    g_iomConfigLamDActFuc1.systemEventTriggerThreshold = NUM_OF_LAM_EVENTS;

    /* Apply the custom configuration */
    IfxIom_Driver_initLam(&g_iomLamDActFuc1, &g_iomConfigLamDActFuc1);

    /* Accumulated counter used */
    if(g_iomConfigLamDActFuc1.systemEventTriggerThreshold >= 2)
    {
        g_iomLamDActFuc1.accumulatedCounterIndex = 1;
    }
    IfxIom_Driver_enableLamEvent(&g_iomLamDActFuc1); /* Enable LAM events */

    /* Restore interrupt state */
    IfxCpu_restoreInterrupts(interruptState);

    /* Run SM:IOM_ALARM_CHECK */
    alarmCheckGTMIOM(NULL_PTR, g_ccu61PwmReferenceHandler.ccu6);
}

/*
 * initial Digital Actuation FUC 1
 * */
void initDActFuc1(void)
{
    resetDAconfiguration();

    /* Part 1: Configure GTM TOM for the output PWM mission signal */
    initMissionGtmTomFuc1();

    /* Part 2: Configure a CCU6 channel for the output PWM reference signal */
    initMonitorCcu6();

    /* Part 3: Start all PWM generation synchronously */
    IfxGtm_Tom_Pwm_start(&g_tomPwmMissionHandler, TRUE);
    IfxCcu6_TPwm_start(&g_ccu61PwmReferenceHandler);

    /* Part 4: Configure the IOM */
    configIomFuc1();
}
