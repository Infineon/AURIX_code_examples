/**********************************************************************************************************************
 * \file Slk_DA_Global.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Digital_Acquisition_Actuation/Slk_DA_Global.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxPort.h"
#include "IfxGtm_Cmu.h"
#include "IfxGtm_PinMap.h"
#include "IfxGtm.h"
#include "IfxGtm_Tim.h"
#include "IfxGtm_Tim_In.h"
#include "IfxGtm_Tom.h"
#include "IfxGtm_Atom_Pwm.h"
#include "IfxCcu6_TPwm.h"
#include "IfxIom.h"
#include "IfxGpt12.h"
#include "IfxCpu_Irq.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define REF_MODIFY_VALUE   100
/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Tom_Pwm_Driver           g_tomPwmMissionHandler;        /* Handler for TOM PWM mission signal configuration   */
IfxGtm_Tom_Pwm_Driver           g_tomPwmMonitorHandler;        /* Handler for TOM PWM mission signal configuration   */
IfxGtm_Tom_Pwm_Driver           g_tomPwmReferenceHandler;      /* Handler for TOM PWM reference signal configuration */
IfxGtm_Tim_In                   g_timPwmMissionHandler;         /* Handler for TIM PWM mission configuration         */
IfxGtm_Tim_In                   g_timPwmMonitorHandler;         /* Handler for TIM PWM monitor configuration         */

IfxGtm_Atom_Pwm_Driver          g_atomPwmMissionHandler;        /* Handler for ATOM PWM mission signal configuration */
IfxCcu6_TPwm                    g_ccu61PwmReferenceHandler;     /* Handler for CCU6 PWM reference signal config      */

DigitalAcqActStatusDatatype     g_digitalAcqActStatus;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
uint32 slkConfigCheckTomTgcBuildFeatureForChannel(IfxGtm_Tom_Ch channel, boolean enabled, uint8 bitfieldOffset);
boolean slkConfigCheckTomTgcEnableChannelUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled);
boolean slkConfigCheckTomTgcSetChannelForceUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean resetEnabled);
boolean slkConfigCheckPinMapSetTomTout(IfxGtm_Tom_ToutMap *config, IfxPort_OutputMode outputMode,
        IfxPort_PadDriver padDriver);
boolean slkConfigCheckTomTgcEnableChannel(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate);
boolean slkConfigCheckTomTgcEnableChannelOutput(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate);
boolean slkConfigCheckTomChSetNotification(Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_IrqMode mode,
        boolean interruptOnCompareZero, boolean interruptOnCompareOne);

boolean slkConfigCheckTimChSetChannelNotification(Ifx_GTM_TIM_CH *channel, boolean irqOnNewVal,
        boolean irqOnCntOverflow, boolean irqOnEcntOverflow, boolean irqOnDatalost);
boolean slkConfigCheckPinMapSetTimIn(IfxGtm_Tim_TinMap *config, IfxPort_InputMode inputMode);

boolean slkConfigCheckSrcInitAndEnable(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* SM:GTM:IOM_ALARM_CHECK
 * This function can be used to either modify the duty cycle of the reference tom or of the reference CCU6 channel.
 * After modification an SMU alarm should get triggered, if so, error injection will be stopped and the duty cycle
 * will be set to its initial value. */
void alarmCheckGTMIOM (IfxGtm_Tom_Pwm_Driver *tomReference, Ifx_CCU6 *ccu61Reference)
{
    /* Verify that only one pointer is passed and that the other one is NULL_PTR otherwise raise alarm */
    if( (tomReference == NULL_PTR && ccu61Reference == NULL_PTR) ||
        (tomReference != NULL_PTR && ccu61Reference != NULL_PTR) )
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
    }

    /* Start error injection by modifying the duty cycle of the reference pwm signal */
    uint32 tomPwmRefPulseLengthTicks = 0;
    uint32 updatedPwmRefPulseLengthTicks = 0;
    if(tomReference != NULL_PTR)
    {
        tomPwmRefPulseLengthTicks = IfxGtm_Tom_Ch_getCompareOne(tomReference->tom, tomReference->tomChannel);
    }
    else if(ccu61Reference != NULL_PTR)
    {
        tomPwmRefPulseLengthTicks = IfxCcu6_getCaptureShadowRegisterValue(ccu61Reference, IfxCcu6_T12Channel_2);
    }

    if(tomPwmRefPulseLengthTicks > REF_MODIFY_VALUE)
    {
        if(tomReference != NULL_PTR)
        {
            updatedPwmRefPulseLengthTicks = tomPwmRefPulseLengthTicks - REF_MODIFY_VALUE;
            IfxGtm_Tom_Ch_setCompareOneShadow(tomReference->tom, tomReference->tomChannel, (uint16)updatedPwmRefPulseLengthTicks);
        }
        else if(ccu61Reference != NULL_PTR)
        {
            updatedPwmRefPulseLengthTicks = tomPwmRefPulseLengthTicks - REF_MODIFY_VALUE;
            IfxCcu6_setT12CompareValue(ccu61Reference, IfxCcu6_T12Channel_2, (uint16)updatedPwmRefPulseLengthTicks);
            IfxCcu6_enableShadowTransfer(ccu61Reference, TRUE, FALSE);

        }
    }
    else
    {
        if(tomReference != NULL_PTR)
        {
            updatedPwmRefPulseLengthTicks = tomPwmRefPulseLengthTicks + REF_MODIFY_VALUE;
            IfxGtm_Tom_Ch_setCompareOneShadow(tomReference->tom, tomReference->tomChannel, (uint16)updatedPwmRefPulseLengthTicks);
        }
        else if(ccu61Reference != NULL_PTR)
        {
            updatedPwmRefPulseLengthTicks = tomPwmRefPulseLengthTicks + REF_MODIFY_VALUE;
            IfxCcu6_setT12CompareValue(ccu61Reference, IfxCcu6_T12Channel_2, (uint16)updatedPwmRefPulseLengthTicks);
            IfxCcu6_enableShadowTransfer(ccu61Reference, TRUE, FALSE);
        }
    }

    /* Wait for the SMU alarm */
    uint32 timeout = 0xFFFF;
    boolean alarmIsRaised = FALSE;
    do
    {
        /* Wait for IfxSmu_Alarm_IOM_Pin_MismatchIndication alarm (ALM8[25]) */
        alarmIsRaised = IfxSmu_getAlarmStatus(IfxSmu_Alarm_IOM_Pin_MismatchIndication);
    } while(!alarmIsRaised && timeout--);

    if(alarmIsRaised)
    {
        /* Stop error injection */
        if(tomReference != NULL_PTR)
        {
            IfxGtm_Tom_Ch_setCompareOneShadow(tomReference->tom, tomReference->tomChannel, (uint16)tomPwmRefPulseLengthTicks);
        }
        else if(ccu61Reference != NULL_PTR)
        {
            IfxCcu6_setT12CompareValue(ccu61Reference, IfxCcu6_T12Channel_2, (uint16)tomPwmRefPulseLengthTicks);
            IfxCcu6_enableShadowTransfer(ccu61Reference, TRUE, FALSE);
        }

        /* Clear IfxSmu_Alarm_IOM_Pin_MismatchIndication alarm (ALM8[25]) */
        IfxSmu_clearAlarmStatus(IfxSmu_Alarm_IOM_Pin_MismatchIndication);

        /* Wait for alarmCounter to be incremented in ISR afterwards it will get decremented and
         * the alarm informations are cleared */
        {
            volatile uint16 timeout = 0xFFFF;/* Note STHE: added "volatile" as it didn't work always without */
            do
            {
                __nop();
            } while(timeout-- && !g_SlkStatus.smuAlarmPending.alarmCounter);

            if(g_SlkStatus.smuAlarmPending.alarmCounter > 0)
            {
                /* Set alarmState to "notPending", decrement alarmCounter and close TFT POP UP window */
                g_SlkStatus.smuAlarmPending.lastAlarmRaised[g_SlkStatus.smuAlarmPending.alarmCounter - 1]->alarmState =
                        notPending;
                g_SlkStatus.smuAlarmPending.alarmCounter--;

            }
        }
    }
    else
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
    }
}

/*
 * Reset every module and channel used for Digital Actuation and Digital Acquisition
 * */
void resetDAconfiguration(void)
{
    /*reset the flags*/
    for (uint8 i = 0; i < DACQ_MISSION_MONITOR_SIG; i++)
    {
        /* Reset measurement monitor frequency, duty cycle and done flag */
        g_digitalAcqActStatus.pwmFrequency[i] = 0;
        g_digitalAcqActStatus.pwmDutyCylce[i] = 0;
        g_digitalAcqActStatus.doneFlag[i] = FALSE;
    }

    /* Reset IOM module */
    if(MODULE_IOM.CLC.B.DISS == 0)
    {
        IfxIom_resetModule(&MODULE_IOM);
    }

    /* Reset all TIM channels which are used for digital acquisition */
    IfxGtm_Tim_Ch_resetChannel(&MODULE_GTM.TIM[GTM_TIM_MISSION.tim], GTM_TIM_MISSION.channel);
    IfxGtm_Tim_Ch_resetChannel(&MODULE_GTM.TIM[GTM_TIM_MONITOR.tim], GTM_TIM_MONITOR.channel);
    IfxGtm_Tim_Ch_resetChannel(&MODULE_GTM.TIM[GTM_TIM_ECKL_INPUT.tim], GTM_TIM_ECKL_INPUT.channel);
    IfxGtm_Tim_Ch_resetChannel(&MODULE_GTM.TIM[GTM_TIM_MISSION_FUC2.tim], GTM_TIM_MISSION_FUC2.channel);

    /* Reset all TOM channels which are used for digital acquisition and digital actuation */
    if(g_tomPwmMissionHandler.tgc[0] != NULL)
    {
        if(g_tomPwmMissionHandler.tomChannel < IfxGtm_Tom_Ch_8)
        {
            IfxGtm_Tom_Tgc_resetChannels(g_tomPwmMissionHandler.tgc[0], (1 << g_tomPwmMissionHandler.tomChannel));
        }
        else
        {
            IfxGtm_Tom_Tgc_resetChannels(g_tomPwmMissionHandler.tgc[0],
                    (1 << g_tomPwmMissionHandler.tomChannel - IfxGtm_Tom_Ch_8));
        }
    }
    if(g_tomPwmMonitorHandler.tgc[0] != NULL)
    {
        if(g_tomPwmMonitorHandler.tomChannel < IfxGtm_Tom_Ch_8)
        {
            IfxGtm_Tom_Tgc_resetChannels(g_tomPwmMonitorHandler.tgc[0], (1 << g_tomPwmMonitorHandler.tomChannel));
        }
        else
        {
            IfxGtm_Tom_Tgc_resetChannels(g_tomPwmMonitorHandler.tgc[0],
                    (1 << g_tomPwmMonitorHandler.tomChannel - IfxGtm_Tom_Ch_8));
        }
    }
    if(g_tomPwmReferenceHandler.tgc[0] != NULL)
    {
        if(g_tomPwmReferenceHandler.tomChannel < IfxGtm_Tom_Ch_8)
        {
            IfxGtm_Tom_Tgc_resetChannels(g_tomPwmReferenceHandler.tgc[0], (1 << g_tomPwmReferenceHandler.tomChannel));
        }
        else
        {
            IfxGtm_Tom_Tgc_resetChannels(g_tomPwmReferenceHandler.tgc[0],
                    (1 << (g_tomPwmReferenceHandler.tomChannel - IfxGtm_Tom_Ch_8)));
        }
    }

    /* Reset CCU6 module */
    if(CCU6_INPUT_MONITOR_PIN.module->CLC.B.DISS == 0)
    {
        IfxCcu6_resetModule(CCU6_INPUT_MONITOR_PIN.module);
    }
    if(CCU6_REF_PIN.module->CLC.B.DISS == 0)
    {
        IfxCcu6_resetModule(CCU6_REF_PIN.module);
    }
    if(CCU6_OUTPUT_MISSION_PIN.module->CLC.B.DISS == 0)
    {
        IfxCcu6_resetModule(CCU6_OUTPUT_MISSION_PIN.module);
    }
    if(CCU6_INPUT_MISSION_PIN_FUC4.module->CLC.B.DISS == 0)
    {
        IfxCcu6_resetModule(CCU6_INPUT_MISSION_PIN_FUC4.module);
    }
    if(GPT12_INPUT_MONITOR_PIN_FUC4.module->CLC.B.DISS == 0)
    {
        IfxGpt12_resetModule(GPT12_INPUT_MONITOR_PIN_FUC4.module);
    }

}

/*
 * This function, validate if configuration of TOM TGC was written successfully to the registers
 * */
uint32 slkConfigCheckTomTgcBuildFeatureForChannel(IfxGtm_Tom_Ch channel, boolean enabled, uint8 bitfieldOffset)
{
    uint32 reg = 0;

    /* Bitfield length is 2 bits */
    uint8  shift = ((channel % 8) * 2) + bitfieldOffset;

    if (enabled == 1)
    {
        reg = (IfxGtm_FeatureControl_enable + 1)<< shift;
    }
    else
    {
        reg = (IfxGtm_FeatureControl_disable - 1) << shift;
    }

    return reg;
}

/*
 * This function, validate if configuration of TOM TGC enable channel update was written successfully
 * */
boolean slkConfigCheckTomTgcEnableChannelUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled)
{
    uint32 expectedRegVal = slkConfigCheckTomTgcBuildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
    /* Bitfield length is 2 bits */
    uint32 mask = 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF;
    return (tgc->GLB_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
}

/*
 * This function, validate if configuration of TOM TGC force update was written successfully
 * */
boolean slkConfigCheckTomTgcSetChannelForceUpdate (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean resetEnabled)
{
    uint32 regEnable, regReset;

    regEnable = slkConfigCheckTomTgcBuildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_FUPD_CTRL_FUPD_CTRL0_OFF);
    regReset = slkConfigCheckTomTgcBuildFeatureForChannel(channel, resetEnabled,
            IFX_GTM_TOM_TGC_FUPD_CTRL_RSTCN0_CH0_OFF);

    /* Bitfield length is 2 bits */
    uint32 mask = 0;
    mask |= 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_FUPD_CTRL_FUPD_CTRL0_OFF;
    mask |= 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_FUPD_CTRL_RSTCN0_CH0_OFF;

    uint32 expectedRegVal = regEnable | (regReset);

    return (tgc->FUPD_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
}

/*
 * This function, validate if configuration of pin map set to TOM TOUT was written successfully
 * */
boolean slkConfigCheckPinMapSetTomTout (IfxGtm_Tom_ToutMap *config, IfxPort_OutputMode outputMode,
        IfxPort_PadDriver padDriver)
{
    /* based on IfxGtm_PinMap_setTomTout */
    uint32 outselReg = (config->toutn >> 3);
    uint32 shift = (config->toutn & 0x7U) * 4;
    uint32 outsel = (uint32)config->toutSel << shift;
    uint32 mask = 0xFU << shift;

    return (MODULE_GTM.TOUTSEL[outselReg].U & mask) == outsel ? TRUE : FALSE;
}

/*
 * This function, validate if configuration of TOM TGC enable channel was written successfully
 * */
boolean slkConfigCheckTomTgcEnableChannel (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate)
{
    boolean retVal = TRUE;
    uint32 expectedRegVal = IfxGtm_Tom_Tgc_buildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_ENDIS_CTRL_ENDIS_CTRL0_OFF);

    /* Bitfield length is 2 bits */
    uint32 mask = 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_ENDIS_CTRL_ENDIS_CTRL0_OFF;

    if (immediate)
    {
        retVal &= (tgc->ENDIS_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
        retVal &= (tgc->ENDIS_STAT.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    else
    {
        retVal &= (tgc->ENDIS_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    return retVal;
}

/*
 * This function, validate if configuration of TIM channel notification set was written successfully
 * */
boolean slkConfigCheckTimChSetChannelNotification (Ifx_GTM_TIM_CH *channel, boolean irqOnNewVal,
        boolean irqOnCntOverflow, boolean irqOnEcntOverflow, boolean irqOnDatalost)
{
    boolean retVal = TRUE;

    Ifx_GTM_TIM_CH_IRQ_EN IRQ_EN_expectedRegVal;
    IRQ_EN_expectedRegVal.B.NEWVAL_IRQ_EN  = irqOnNewVal ? 1 : 0;
    IRQ_EN_expectedRegVal.B.CNTOFL_IRQ_EN  = irqOnCntOverflow ? 1 : 0;
    IRQ_EN_expectedRegVal.B.ECNTOFL_IRQ_EN = irqOnEcntOverflow ? 1 : 0;
    IRQ_EN_expectedRegVal.B.GPROFL_IRQ_EN  = irqOnDatalost ? 1 : 0;

    retVal &= channel->IRQ.EN.U == IRQ_EN_expectedRegVal.U ? TRUE : FALSE;

    return retVal;
}

/*
 * This function, validate if configuration of pin map set to TIM IN was written successfully
 * */
boolean slkConfigCheckPinMapSetTimIn(IfxGtm_Tim_TinMap *config, IfxPort_InputMode inputMode)
{
    /* based on IfxGtm_PinMap_setTimTin */
    boolean retVal = TRUE;

    uint32 shift = config->channel * 4;
    uint32 mask = (0xFU << shift);
    uint32 expected = ((uint32)config->select) << shift;

    retVal &= ( MODULE_GTM.TIMINSEL[config->tim].U & mask ) == expected ? TRUE : FALSE;
    if (inputMode != IfxPort_InputMode_undefined)
    {
        volatile Ifx_P_IOCR0    *iocr      = &(config->pin.port->IOCR0);
        uint8                   iocrIndex = (config->pin.pinIndex / 4);
        uint8                   shift     = (config->pin.pinIndex & 0x3U) * 8;
                                mask      = (0xFFUL << shift);
                                expected  = (inputMode << shift);

        retVal &= ( iocr[iocrIndex].U & mask ) == expected ? TRUE : FALSE;
    }

    return retVal;
}

/*
 * This function, validate if configuration of TIM was written successfully to the registers
 * */
void slkTimInConfigReadback(const IfxGtm_Tim_In_Config *config, IfxSmu_Alarm alarm)
{
    boolean configValidated = TRUE;

    /* This check is based on the iLLD function IfxGtm_Tim_In_init */
    Ifx_GTM_TIM_CH     *channel;

    IfxGtm_Tim_Ch       channelIndex;
    IfxGtm_Tim          timIndex;
    IfxGtm_Tim_In_Input input;

    if (config->filter.inputPin != NULL_PTR)
    {
        channelIndex = config->filter.inputPin->channel;
        timIndex     = config->filter.inputPin->tim;
        input        = IfxGtm_Tim_In_Input_currentChannel;
    }
    else
    {
        channelIndex = config->channelIndex;
        timIndex     = config->timIndex;
        input        = config->filter.input;
    }

    channel = IfxGtm_Tim_getChannel(&config->gtm->TIM[timIndex], channelIndex);

    configValidated &= (IfxGtm_Tim_Mode_pwmMeasurement == channel->CTRL.B.TIM_MODE);

    configValidated &= (config->capture.clock == IfxGtm_Tim_Ch_getCaptureClockSource(channel));

    if(config->capture.mode == Ifx_Pwm_Mode_leftAligned)
    {
        configValidated &= ( channel->CTRL.B.DSL == 1 );
    }
    else if(config->capture.mode == Ifx_Pwm_Mode_rightAligned)
    {
        configValidated &= ( channel->CTRL.B.DSL == 0 );
    }

    configValidated &= (IfxGtm_Tim_CntsSel_cntReg == channel->CTRL.B.CNTS_SEL);
    configValidated &= (IfxGtm_Tim_GprSel_cnts == channel->CTRL.B.GPR0_SEL);
    configValidated &= (IfxGtm_Tim_GprSel_cnts == channel->CTRL.B.GPR1_SEL);

    /* Validate interrupt configuration */
    if (config->isrPriority)
    {
        volatile Ifx_SRC_SRCR *src;
        configValidated &= ( channel->IRQ.MODE.B.IRQ_MODE == config->irqMode );
        configValidated &= slkConfigCheckTimChSetChannelNotification(channel, config->capture.irqOnNewVal,
                config->capture.irqOnCntOverflow, config->capture.irqOnEcntOverflow, config->capture.irqOnDatalost);

        src = IfxGtm_Tim_Ch_getSrcPointer(config->gtm, timIndex, channelIndex);
        slkConfigCheckSrcInitAndEnable(src, config->isrProvider, config->isrPriority);
    }

    /* Validate input configuration */

    uint32 mask;
    mask = 0x3 << channelIndex * (IFX_GTM_TIM_IN_SRC_MODE_1_OFF - IFX_GTM_TIM_IN_SRC_MODE_0_OFF);
    configValidated     &= ((config->gtm->TIM[timIndex].IN_SRC.U & mask) == 0 << (IFX_GTM_TIM_IN_SRC_MODE_0_OFF +
                             channelIndex * (IFX_GTM_TIM_IN_SRC_MODE_1_OFF - IFX_GTM_TIM_IN_SRC_MODE_0_OFF))); /*MODE0*/

    mask = 0x3 << channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF);
    switch (input)
    {
        case IfxGtm_Tim_In_Input_currentChannel:
            configValidated &= ( (config->gtm->TIM[timIndex].IN_SRC.U & mask) == 0 << (IFX_GTM_TIM_IN_SRC_VAL_0_OFF + \
                                  channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF)) );/*VAL0*/
            configValidated &= ( channel->CTRL.B.CICTRL == IfxGtm_Tim_Input_currentChannel );
            break;
        case IfxGtm_Tim_In_Input_adjacentChannel:
            configValidated &= ( (config->gtm->TIM[timIndex].IN_SRC.U & mask) == 0 << (IFX_GTM_TIM_IN_SRC_VAL_0_OFF + \
                                  channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF)) );/*VAL0*/
            configValidated &= ( channel->CTRL.B.CICTRL == IfxGtm_Tim_Input_adjacentChannel );
            break;
        case IfxGtm_Tim_In_Input_aux:
            configValidated &= ( (config->gtm->TIM[timIndex].IN_SRC.U & mask) == 3 << (IFX_GTM_TIM_IN_SRC_VAL_0_OFF + \
                                  channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF)) );/*VAL1*/
            break;
        default:
            __debug();
            break;
    }

    if (config->filter.inputPin != NULL_PTR)
    {
        configValidated &= slkConfigCheckPinMapSetTimIn(config->filter.inputPin, config->filter.inputPinMode);
    }


    /* Validate filter configuration */
    if ((config->filter.fallingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none) ||
        (config->filter.risingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none))
    {
        float32 clockFrequency;
        sint32  fallingfilterTime;
        sint32  risingfilterTime;

        configValidated &= ( channel->CTRL.B.FLT_EN == 1 );
        configValidated &= ( channel->CTRL.B.FLT_CNT_FRQ == config->filter.clock );

        clockFrequency = IfxGtm_Tim_Ch_getFilterClockFrequency(config->gtm, channel);

        fallingfilterTime = (uint32) (config->filter.fallingEdgeFilterTime * clockFrequency) - 1;

        if (fallingfilterTime < 0)
        {
            fallingfilterTime = 0;
        }
        else if (fallingfilterTime > (sint32)IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK)
        {
            fallingfilterTime = IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK;
            configValidated &= FALSE;
        }

        configValidated &= (channel->FLT_FE.B.FLT_FE == fallingfilterTime);

        risingfilterTime = (uint32) (config->filter.risingEdgeFilterTime * clockFrequency) - 1;

        if (risingfilterTime < 0)
        {
            risingfilterTime = 0;
        }
        else if (risingfilterTime > (sint32)IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK)
        {
            risingfilterTime = IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK;
            configValidated &= FALSE;
        }

        configValidated &= ( channel->FLT_RE.B.FLT_RE == risingfilterTime );

        if (config->filter.fallingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none)
        {
            if (config->filter.fallingEdgeMode == IfxGtm_Tim_In_ConfigFilterMode_immediateEdgePropagation)
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_FE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            }
            else
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_FE == IfxGtm_Tim_FilterMode_individualDeglitchTime );
                configValidated &= (
                        channel->CTRL.B.FLT_CTR_FE == config->filter.fallingEdgeMode
                                == IfxGtm_Tim_In_ConfigFilterMode_individualDeglitchTimeUpDown ?
                                IfxGtm_Tim_FilterCounter_upDown : IfxGtm_Tim_FilterCounter_hold);
            }
        }
        else
        {
            configValidated &= ( channel->CTRL.B.FLT_MODE_FE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            configValidated &= ( channel->FLT_FE.B.FLT_FE == 0 );
        }

        if (config->filter.risingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none)
        {
            if (config->filter.risingEdgeMode == IfxGtm_Tim_In_ConfigFilterMode_immediateEdgePropagation)
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_RE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            }
            else
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_RE == IfxGtm_Tim_FilterMode_individualDeglitchTime );
                configValidated &= (
                        channel->CTRL.B.FLT_CTR_RE == IfxGtm_Tim_In_ConfigFilterMode_individualDeglitchTimeUpDown ?
                                IfxGtm_Tim_FilterCounter_upDown : IfxGtm_Tim_FilterCounter_hold);
            }
        }
        else
        {
            configValidated &= ( channel->CTRL.B.FLT_MODE_RE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            configValidated &= ( channel->FLT_RE.B.FLT_RE == 0 );
        }

        configValidated &= ( channel->IRQ.EN.B.GLITCHDET_IRQ_EN == config->filter.irqOnGlitch ? 1 : 0 );
    }

    /* Validate if TIM channel is enabled */
    configValidated &= ( channel->CTRL.B.TIM_EN == 1 );

    if(configValidated == FALSE)
    {
        softwareCoreAlarmTriggerSMU(alarm);
    }
}

/*
 * This function, validate if configuration of TOM channel notification set was written successfully
 * */
boolean slkConfigCheckTomChSetNotification (Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_IrqMode mode,
        boolean interruptOnCompareZero, boolean interruptOnCompareOne)
{
    boolean retVal = TRUE;
    Ifx_GTM_TOM_CH       *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    Ifx_GTM_TOM_CH_IRQ_EN IRQ_EN_expectedRegVal;
    IRQ_EN_expectedRegVal.B.CCU0TC_IRQ_EN = interruptOnCompareZero ? 1 : 0;
    IRQ_EN_expectedRegVal.B.CCU1TC_IRQ_EN = interruptOnCompareOne  ? 1 : 0;

    Ifx_GTM_TOM_CH_IRQ_MODE IRQ_MODE_expectedVal;
    IRQ_MODE_expectedVal.B.IRQ_MODE    = mode;

    retVal &= tomCh->IRQ.MODE.B.IRQ_MODE == IRQ_MODE_expectedVal.B.IRQ_MODE ? TRUE : FALSE;
    retVal &= tomCh->IRQ.EN.U == IRQ_EN_expectedRegVal.U ? TRUE : FALSE;

    return retVal;
}

/*
 * This function, validate if configuration of SRC init and enable was written successfully
 * */
boolean slkConfigCheckSrcInitAndEnable (volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService,
        Ifx_Priority priority)
{
    boolean retVal = TRUE;
    retVal &= src->B.SRPN   == priority;
    retVal &= src->B.TOS    == typOfService;
    retVal &= src->B.SRE    == 1;
    return retVal;
}

/*
 * This function, validate if configuration of TOM TGC enable channel output was written successfully
 * */
boolean slkConfigCheckTomTgcEnableChannelOutput (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate)
{
    boolean retVal = TRUE;
    uint32 expectedRegVal = IfxGtm_Tom_Tgc_buildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_OUTEN_CTRL_OUTEN_CTRL0_OFF);
    /* Bitfield length is 2 bits */
    uint32 mask = 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_OUTEN_CTRL_OUTEN_CTRL0_OFF;

    if (immediate)
    {
        retVal &= (tgc->OUTEN_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
        retVal &= (tgc->OUTEN_STAT.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    else
    {
        retVal &= (tgc->OUTEN_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    return retVal;
}

/*
 * This function, validate if configuration of TOM was written successfully to the registers
 * */
void slkTomPwmConfigReadBack(const IfxGtm_Tom_Pwm_Config *config, IfxSmu_Alarm alarm)
{
    boolean configValidated = TRUE;

    /* This check is based on IfxGtm_Tom_Pwm_init */
    Ifx_GTM_TOM     *tomSFR = &config->gtm->TOM[config->tom];
    Ifx_GTM_TOM_CH  *tomCh  = IfxGtm_Tom_Ch_getChannelPointer(tomSFR, config->tomChannel);
    Ifx_GTM_TOM_TGC *tgc[2];

#if defined(IFXGTM_DTM_AVAILABLE)
#error "DTM Config Read back is not implemented"
#endif

    if (config->tomChannel <= 7)
    {
        tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(tomSFR, 0);
        tgc[1] = IfxGtm_Tom_Ch_getTgcPointer(tomSFR, 1);
    }
    else
    {
        tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(tomSFR, 1);
        tgc[1] = NULL_PTR; /* NOTE currently no concatenation between TOMs */
    }

    /* Check the timer part */
    if (config->synchronousUpdateEnabled == 1)
    {
        configValidated &= slkConfigCheckTomTgcEnableChannelUpdate(tgc[0], config->tomChannel, TRUE);
    }

    configValidated &= (config->clock == IfxGtm_Tom_Ch_getClockSource(tomSFR, config->tomChannel));

    configValidated &= slkConfigCheckTomTgcSetChannelForceUpdate(tgc[0], config->tomChannel, TRUE, TRUE);

    configValidated &= (config->signalLevel == (tomCh->CTRL.B.SL == 1 ? Ifx_ActiveState_high : Ifx_ActiveState_low));

    if (config->pin.outputPin != NULL_PTR)
    {
        configValidated &= slkConfigCheckPinMapSetTomTout(config->pin.outputPin, config->pin.outputMode,
                config->pin.padDriver);
    }

    /* Check interrupt configuration if enabled */
    if ((config->interrupt.ccu0Enabled == 1) || (config->interrupt.ccu1Enabled == 1))
    {
        configValidated &= slkConfigCheckTomChSetNotification(tomSFR, config->tomChannel, config->interrupt.mode,
                config->interrupt.ccu0Enabled, config->interrupt.ccu1Enabled);
        volatile Ifx_SRC_SRCR *src;
        src = IfxGtm_Tom_Ch_getSrcPointer(config->gtm, config->tom, config->tomChannel);
        slkConfigCheckSrcInitAndEnable(src, config->interrupt.isrProvider, config->interrupt.isrPriority);
    }

    if (config->synchronousUpdateEnabled == 1)
    {
        configValidated &= (config->period == tomCh->SR0.U);
        configValidated &= (config->dutyCycle == tomCh->SR1.U);
    }
    else
    {
        configValidated &= (config->period == tomCh->CM0.U);
        configValidated &= (config->dutyCycle == tomCh->CM1.U);
    }

    configValidated &= slkConfigCheckTomTgcEnableChannel(tgc[0], config->tomChannel, TRUE, FALSE);
    configValidated &= slkConfigCheckTomTgcEnableChannelOutput(tgc[0], config->tomChannel, TRUE, FALSE);


#if defined(IFXGTM_DTM_AVAILABLE)
#error "DTM Config Read back is not implemented"
#endif

    if(configValidated == FALSE)
    {
        softwareCoreAlarmTriggerSMU(alarm);
    }
}

/*
 * This function compare the frequency of mission and monitor pwm signals
 * */
void comparePwmFrequency(float32 missionPwmFreq, float32 monitorPwmFreq)
{
    float32 pwmFreqDifference = 0;

    /* Difference validation */
    pwmFreqDifference =
            (missionPwmFreq < monitorPwmFreq) ? (monitorPwmFreq - missionPwmFreq) : (missionPwmFreq - monitorPwmFreq);

    /* Appropriate reaction if difference is higher than the limit */
    if(pwmFreqDifference > TIM_REDUNDANCY_MAX_DIFF)
    {
        /* Trigger SMU software alarm */
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
    }
}

/*
 * This function compare the duty cycle of mission and monitor pwm signals
 * */
void comparePwmDutyCycle(float32 missionPwmDutyCycle, float32 monitorPwmDutyCycle)
{
    float32 pwmDutyCycleDifference = 0;

    /* Difference validation */
    pwmDutyCycleDifference =
            (missionPwmDutyCycle < monitorPwmDutyCycle) ?
                    (monitorPwmDutyCycle - missionPwmDutyCycle) : (missionPwmDutyCycle - monitorPwmDutyCycle);

    /* Appropriate reaction if difference is higher than the limit */
    if(pwmDutyCycleDifference > TIM_REDUNDANCY_MAX_DIFF)
    {
        /* Trigger SMU software alarm */
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
    }
}
