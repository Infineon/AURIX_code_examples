/**********************************************************************************************************************
 * \file Slk_Tim_Clock_Monitor.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Digital_Acquisition_Actuation/Slk_DA_Global.h"
#include "Digital_Acquisition_Actuation/Slk_Tim_Clock_Monitor.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Slk_Main.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxPort.h"
#include "IfxGtm_Cmu.h"
#include "IfxGtm_PinMap.h"
#include "IfxGtm.h"
#include "IfxGtm_Tim.h"
#include "IfxGtm_Tim_In.h"
#include "IfxCpu_Irq.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define EXT_CLK0_FREQ               ((float32)10000) /* [Hz] */
#define EXT_CLK_MULTIPLIER          (2) /* Multiply frequency by two as there is a divider by two in hardware */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Tim_In                   g_eclkTimHandler;              /* Handler for TIM ECLK configuration                 */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void configTIM(void);
void configECLK(void);
/* Declarations of the ISR functions */
IFX_INTERRUPT(gtmTimEclkMonitoringISR, CPU1_RUNNING_TASK, ISR_PRIORITY_GTM_TIM_ECLK_MON_DA);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* ECLK monitor ISR */
void gtmTimEclkMonitoringISR(void)
{
    IfxCpu_enableInterrupts();
    IfxGtm_Tim_In_onIsr(&g_eclkTimHandler);

    /* Corner case not covered by IfxGtm_Tim_In_update(driver); --> overflow without NEWVAL notification */
    if(!g_eclkTimHandler.newData)
    {
        g_eclkTimHandler.overflowCnt = IfxGtm_Tim_Ch_isCntOverflowEvent(g_eclkTimHandler.channel);
        if (g_eclkTimHandler.overflowCnt )
        {
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_GTM_ECKL);
            g_eclkTimHandler.overflowCnt = FALSE;
        }
    }
    else
    {
        if(g_eclkTimHandler.dataCoherent == FALSE)
        {
            /* Duty and period values were not measured from the same period */
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_GTM_ECKL);
        }

        /* Process data */
        uint32 expectedPeriodTick = (uint32) g_eclkTimHandler.captureClockFrequency / EXT_CLK0_FREQ;
        uint32 periodTickDifference =
                g_eclkTimHandler.periodTick > expectedPeriodTick ?
                        g_eclkTimHandler.periodTick - expectedPeriodTick :
                        expectedPeriodTick - g_eclkTimHandler.periodTick;

        /* Trigger an SMU alarm if the tick difference is higher than the allowed tolerance */
        if(periodTickDifference > TICK_TOLERANCE)
        {
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_GTM_ECKL);
        }
    }
}

/*
 * This function configure ECLK and its output on an external pin
 * */
void configECLK(void)
{
    /* Disable ECLK for configuration */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKDIS_ECLK0);

    /* Setup ECLK0 external pin, configure as alternative output pin 4, GTM_CLK0 or cmu_eclk0,
     * refer to the table "GTM External Clock to Port Mapping" in the User Manual */
    IfxPort_setPinPadDriver(GTM_ECLK_OUTPUT_PIN, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    IfxPort_setPinModeOutput(GTM_ECLK_OUTPUT_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_alt4);

    /* Setup frequency */
    /* Following code is copied from the function IfxGtm_Cmu_setEclkFrequency()
     * As IfxGtm_Cmu_setEclkFrequency() takes very long to acquire the Numerator and Denominator it is hard coded */
    uint16 psw = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(psw);

    /* write ECLK_NUM twice to be sure i.e. recommended by user manual */
    MODULE_GTM.CMU.ECLK[IfxGtm_Cmu_Eclk_0].NUM.B.ECLK_NUM = (uint32) (IfxGtm_Cmu_getGclkFrequency(&MODULE_GTM)
            / EXT_CLK0_FREQ);
    MODULE_GTM.CMU.ECLK[IfxGtm_Cmu_Eclk_0].NUM.B.ECLK_NUM = (uint32) (IfxGtm_Cmu_getGclkFrequency(&MODULE_GTM)
            / EXT_CLK0_FREQ);
    MODULE_GTM.CMU.ECLK[IfxGtm_Cmu_Eclk_0].DEN.B.ECLK_DEN = 0x1;
    IfxScuWdt_setCpuEndinit(psw);

    /* Enable ECLK again */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_ECLK0);

    /* Verify ECLK configuration by reading it back */
    float32 configuredFreq = EXT_CLK_MULTIPLIER * IfxGtm_Cmu_getEclkFrequency(&MODULE_GTM, IfxGtm_Cmu_Eclk_0, FALSE);
    if(configuredFreq != EXT_CLK0_FREQ)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_GTM_ECKL);
    }
}

/*
 * This function configure a TIM channel for monitoring the externally looped back ECKL signal
 * */
void configTIM()
{
    IfxGtm_Tim_In_Config timEclkConfig;
    IfxGtm_Tim_In_initConfig(&timEclkConfig, &MODULE_GTM); /* Initialize default parameters */

    /* Configure input pin */
    timEclkConfig.filter.inputPin               = &GTM_TIM_ECKL_INPUT;

    /* Configure clocks */
    timEclkConfig.capture.clock                 = DA_TIM_CLOCK_SOURCE;
    timEclkConfig.timeout.clock                 = DA_TIM_CLOCK_SOURCE;

    /* ISR configuration */
    timEclkConfig.capture.irqOnNewVal           = TRUE; /* Trigger interrupt on new value */
    timEclkConfig.capture.irqOnCntOverflow      = TRUE; /* Trigger interrupt on counter overflow */
    timEclkConfig.isrProvider                   = IfxCpu_Irq_getTos(CPU1_RUNNING_TASK);
    timEclkConfig.isrPriority                   = ISR_PRIORITY_GTM_TIM_ECLK_MON_DA;

    /* Initialize the TIM */
    boolean success = IfxGtm_Tim_In_init(&g_eclkTimHandler, &timEclkConfig);
    if(!success)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_GTM_ECKL);
    }

    slkTimInConfigReadback(&timEclkConfig, SOFT_SMU_ALM_GTM_ECKL);
}

/*
 * SM:TIM_CLOCK_MONITORING
 * */
void initEclkMonitoring(void)
{
    /* Part 1: Configure ECLK and its output on an external pin */
    configECLK();

    /* Part 2: Configure a TIM channel for monitoring the externally looped back ECKL signal */
    configTIM();
}
