/**********************************************************************************************************************
 * \file Slk_DAcq_Fuc0.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Digital_Acquisition_Actuation/Digital_Acquisition/Slk_DAcq_Fuc0.h"
#include "Digital_Acquisition_Actuation/Slk_DA_Global.h"
#include "Digital_Acquisition_Actuation/Slk_Tim_Clock_Monitor.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxGtm_Tom_Pwm.h"
#include "IfxGtm_Tim_In.h"
#include "IfxCpu_Irq.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IFX_EXTERN IfxGtm_Tom_Pwm_Driver            g_tomPwmMissionHandler; /* Handler for TOM PWM configuration */
IFX_EXTERN IfxGtm_Tim_In                    g_timPwmMissionHandler; /* Handler for TIM PWM mission configuration*/
IFX_EXTERN IfxGtm_Tim_In                    g_timPwmMonitorHandler; /* Handler for TIM PWM monitor configuration*/
IFX_EXTERN DigitalAcqActStatusDatatype      g_digitalAcqActStatus;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initMissionTIM(void);
void initMonitorTIM(void);
void generatePwmFuc0(void);

/* Declarations of the ISR functions */
IFX_INTERRUPT(isrGtmTimPwmMissionDAcqFuc0, CPU1_RUNNING_TASK, ISR_PRIORITY_GTM_TIM_MISSION_DACQ_FUC0);
IFX_INTERRUPT(isrGtmTimPwmMonitorDAcqFuc0, CPU1_RUNNING_TASK, ISR_PRIORITY_GTM_TIM_MONITOR_DACQ_FUC0);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Mission TIM ISR handler */
void isrGtmTimPwmMissionDAcqFuc0(void)
{
    IfxCpu_enableInterrupts();

    IfxGtm_Tim_In_onIsr(&g_timPwmMissionHandler);

    /* Corner case not covered by IfxGtm_Tim_In_update(driver); --> overflow without NEWVAL notification */
    if (!g_timPwmMissionHandler.newData)
    {
        g_timPwmMissionHandler.overflowCnt = IfxGtm_Tim_Ch_isCntOverflowEvent(g_timPwmMissionHandler.channel);
        if (g_timPwmMissionHandler.overflowCnt)
        {
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
            g_timPwmMissionHandler.overflowCnt = FALSE;
        }
    }
    else
    {
        if (g_timPwmMissionHandler.dataCoherent == FALSE)
        {
            /* Duty and period values were not measured from the same period */
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
        }

        /* Process data */
        float32 g_measuredPwmPeriod;
        g_measuredPwmPeriod = IfxGtm_Tim_In_getPeriodSecond(&g_timPwmMissionHandler);          /* Get the period of the PWM signal */
        g_digitalAcqActStatus.pwmFrequency[0] = 1 / g_measuredPwmPeriod;                             /* Calculate the frequency          */
        g_digitalAcqActStatus.pwmDutyCylce[0] = IfxGtm_Tim_In_getDutyPercent(&g_timPwmMissionHandler, &g_timPwmMissionHandler.dataCoherent); /* Get the duty cycle     */
        g_digitalAcqActStatus.doneFlag[0] = TRUE;

        /* Execute SM:GTM_TIM_REDUNDANCY by calling checkRedundancyGtmTim only from mission TIM channel */
        checkRedundancyGtmTim();
    }
}

/* Monitor on TIM ISR handler */
void isrGtmTimPwmMonitorDAcqFuc0(void)
{
    IfxCpu_enableInterrupts();

    IfxGtm_Tim_In_onIsr(&g_timPwmMonitorHandler);

    /* Corner case not covered by IfxGtm_Tim_In_update(driver); --> overflow without NEWVAL notification */
    if (!g_timPwmMonitorHandler.newData)
    {
        g_timPwmMonitorHandler.overflowCnt = IfxGtm_Tim_Ch_isCntOverflowEvent(g_timPwmMonitorHandler.channel);
        if (g_timPwmMonitorHandler.overflowCnt)
        {
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
            g_timPwmMonitorHandler.overflowCnt = FALSE;
        }
    }
    else
    {
        if (g_timPwmMonitorHandler.dataCoherent == FALSE)
        {
            /* Duty and period values were not measured from the same period */
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
        }

        /* Process data */
        float32 g_measuredPwmPeriod;
        g_measuredPwmPeriod = IfxGtm_Tim_In_getPeriodSecond(&g_timPwmMonitorHandler);          /* Get the period of the PWM signal */
        g_digitalAcqActStatus.pwmFrequency[1] = 1 / g_measuredPwmPeriod;                             /* Calculate the frequency          */
        g_digitalAcqActStatus.pwmDutyCylce[1] = IfxGtm_Tim_In_getDutyPercent(&g_timPwmMonitorHandler, &g_timPwmMonitorHandler.dataCoherent); /* Get the duty cycle     */
        g_digitalAcqActStatus.doneFlag[1] = TRUE;
    }
}

/*
 * Check redundancy of TIM TIM
 * SM:GTM_TIM_REDUNDANCY
 * */
void checkRedundancyGtmTim(void)
{
    /* Continue only if both measurements are done */
    static uint8 notDoneCnt;

    if(!g_digitalAcqActStatus.doneFlag[0] && !g_digitalAcqActStatus.doneFlag[1])
    {
        /* Increase static not done counter */
        notDoneCnt++;
        /* If notDoneCnt is not reset frequently it means that any TIM is not successfully measured anymore */
        if(notDoneCnt > 10)
        {
            /* Trigger SMU software alarm */
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);

            /* Reset static notDoneCnt counter */
            notDoneCnt = 0;
        }
    }
    else
    {
        /* Reset static notDoneCnt counter */
        notDoneCnt = 0;

        /* Difference validation */
        /* Pwm frequency comparison */
        comparePwmFrequency(g_digitalAcqActStatus.pwmFrequency[0], g_digitalAcqActStatus.pwmFrequency[1]);

        /* Pwm duty cycle comparison */
        comparePwmDutyCycle(g_digitalAcqActStatus.pwmDutyCylce[0], g_digitalAcqActStatus.pwmDutyCylce[1]);

        /* Reset measurement done flags */
        g_digitalAcqActStatus.doneFlag[0] = FALSE;
        g_digitalAcqActStatus.doneFlag[1] = FALSE;
    }
}

/*
 * initialized TIM as mission signal
 * */
void initMissionTIM()
{
    IfxGtm_Tim_In_Config timPwmMeasMissionConfig;
    IfxGtm_Tim_In_initConfig(&timPwmMeasMissionConfig, &MODULE_GTM); /* Initialize default parameters */

    /* Configure input pin */
    timPwmMeasMissionConfig.filter.inputPin = &GTM_TIM_MISSION;

    /* Configure clocks */
    timPwmMeasMissionConfig.capture.clock = DA_TIM_CLOCK_SOURCE;
    timPwmMeasMissionConfig.timeout.clock = DA_TIM_CLOCK_SOURCE;

    /* ISR configuration */
    timPwmMeasMissionConfig.capture.irqOnNewVal = TRUE; /* Trigger interrupt on new value */
    timPwmMeasMissionConfig.capture.irqOnCntOverflow = TRUE; /* Trigger interrupt on counter overflow */
    timPwmMeasMissionConfig.isrProvider = IfxCpu_Irq_getTos(CPU1_RUNNING_TASK);
    timPwmMeasMissionConfig.isrPriority = ISR_PRIORITY_GTM_TIM_MISSION_DACQ_FUC0;

    /* Initialize the TIM */
    boolean success = IfxGtm_Tim_In_init(&g_timPwmMissionHandler, &timPwmMeasMissionConfig);
    if (!success)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
        return;
    }

    /* Validate if configuration was written successfully to the registers */
    slkTimInConfigReadback(&timPwmMeasMissionConfig, SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
}

/*
 * initialized TIM as monitor signal
 * */
void initMonitorTIM()
{
    IfxGtm_Tim_In_Config timPwmMeasMonitorConfig;
    IfxGtm_Tim_In_initConfig(&timPwmMeasMonitorConfig, &MODULE_GTM); /* Initialize default parameters */

    /* Configure input pin */
    timPwmMeasMonitorConfig.filter.inputPin = &GTM_TIM_MONITOR;

    /* Configure clocks */
    timPwmMeasMonitorConfig.capture.clock = DA_TIM_CLOCK_SOURCE;
    timPwmMeasMonitorConfig.timeout.clock = DA_TIM_CLOCK_SOURCE;

    /* ISR configuration */
    timPwmMeasMonitorConfig.capture.irqOnNewVal = TRUE; /* Trigger interrupt on new value */
    timPwmMeasMonitorConfig.capture.irqOnCntOverflow = TRUE; /* Trigger interrupt on counter overflow */
    timPwmMeasMonitorConfig.isrProvider = IfxCpu_Irq_getTos(CPU1_RUNNING_TASK);
    timPwmMeasMonitorConfig.isrPriority = ISR_PRIORITY_GTM_TIM_MONITOR_DACQ_FUC0;

    /* Initialize the TIM */
    boolean success = IfxGtm_Tim_In_init(&g_timPwmMonitorHandler, &timPwmMeasMonitorConfig);
    if (!success)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
        return;
    }

    /* Validate if configuration was written successfully to the registers */
    slkTimInConfigReadback(&timPwmMeasMonitorConfig, SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
}

/*
 * This function generate Dummy PWM
 * */
void generatePwmFuc0(void)
{
    IfxGtm_Tom_Pwm_Config pwmOutputSignalConfig;
    IfxGtm_Tom_Pwm_initConfig(&pwmOutputSignalConfig, &MODULE_GTM); /* Initialize default parameters */

    pwmOutputSignalConfig.tom = GTM_TOM_SAFE_PIN.tom; /* Select the TOM */
    pwmOutputSignalConfig.tomChannel = GTM_TOM_SAFE_PIN.channel; /* select the channel */
    pwmOutputSignalConfig.pin.outputPin = &GTM_TOM_SAFE_PIN; /* Set the port pin as output */
    pwmOutputSignalConfig.clock = DA_TOM_CLOCK_SOURCE; /* Select the clock source*/
    pwmOutputSignalConfig.synchronousUpdateEnabled = TRUE; /* Enable synchronous update */
    pwmOutputSignalConfig.period = TOM_PWM_PERIOD; /* Set the timer period */
    pwmOutputSignalConfig.dutyCycle = (uint32) (TOM_DUTY_CYCLE * 0.01 * pwmOutputSignalConfig.period);

    /* Initialize the GTM TOM */
    boolean success = IfxGtm_Tom_Pwm_init(&g_tomPwmMissionHandler, &pwmOutputSignalConfig);
    if (!success)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_DIGITAL_ACQ_ACT);
        return;
    }

    /* Validate if configuration was written successfully to the registers */
    slkTomPwmConfigReadBack(&pwmOutputSignalConfig, SOFT_SMU_ALM_DIGITAL_ACQ_ACT);

    /* Start the PWM */
    IfxGtm_Tom_Pwm_start(&g_tomPwmMissionHandler, TRUE);
}
/*
 * initial Digital Acquisition FUC0
 * */
void initDAcqFuc0(void)
{
    resetDAconfiguration();

    /* Part 1: Initialize SM:TIM_CLOCK_MONITORING */
    initEclkMonitoring();

    /* Part 2: Configure GTM TIM as mission channel for measuring the generated dummy PWM signal */
    initMissionTIM();

    /* Part 3: Configure GTM TIM as monitor channel for measuring the generated dummy PWM signal */
    initMonitorTIM();

    /* Part 4: Configure GTM TOM for the dummy output PWM signal which is measured by the TOMs */
    generatePwmFuc0();
}
