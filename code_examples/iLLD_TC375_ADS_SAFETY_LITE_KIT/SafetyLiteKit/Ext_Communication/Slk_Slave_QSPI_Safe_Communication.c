/**********************************************************************************************************************
 * \file Slk_Slave_QSPI_Safe_Communication.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyLiteKit/Ext_Communication/Slk_Slave_QSPI_Safe_Communication.h"
#include "SafetyLiteKit/Slk_Cfg.h"
#include "SafetyLiteKit/Smu/SMU.h"
#include "IfxStm.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/*QSPI Slave */
#define MASTER_DATA_ID            0x01
#define CHANNEL_BAUDRATE          1000000           /* Master channel baud rate                                      */
#define DATA_WIDTH                32                /* 32 bits                                                       */
#define FRAME_SIZE_BIT            ((float64)(DATA_WIDTH * FRAME_SIZE))
#define FRAME_TRANSFER_TIME       ((float64)(1/CHANNEL_BAUDRATE * FRAME_SIZE_BIT)) /* 0.224ms one frame time
                                                                                                  (1byte = 0.032ms)  */
#define TOTAL_CYCLY_TIME          (float64)(100.0f + FRAME_TRANSFER_TIME)  /* 100.0 is master frame sending cycle    */
#define THRESHOLD                 0.5f               /* 0.5ms */
#define EARLY_FRAME_TIME          TOTAL_CYCLY_TIME - THRESHOLD
#define LATE_FRAME_TIME           TOTAL_CYCLY_TIME + THRESHOLD
#define FRAME_TIMEOUT             (TOTAL_CYCLY_TIME + TOTAL_CYCLY_TIME)
#define SEC_TO_MILLISEC           1000             /* 1sec = 1000ms */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
qspiSlaveSafeComm g_qspiSlaveSafe;
volatile boolean g_frameReceived = FALSE;           /* flag once complete frame is received */
uint8 g_ErrorTypeQspiSafe = 0;                      /* global variable for the error code */
boolean enableQspiSafeCommunication = FALSE;

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
float32 getMilliSecondTime(void);
void initQSPI2Slave(void);
void validateFrameCylceTime(float64 cycleTime);
void validateSlavedata(uint32 frameCounter);
void validateSlaveDataAndCycleTime(uint32 frameCounterSlaveQSPI, float64 cycleTime);

IFX_INTERRUPT(slaveQSPI2TxISR, CPU1_RUNNING_TASK, ISR_PRIORITY_SLAVE_TX_QSPI_SAFE);
IFX_INTERRUPT(slaveQSPI2RxISR, CPU1_RUNNING_TASK, ISR_PRIORITY_SLAVE_RX_QSPI_SAFE);
IFX_INTERRUPT(slaveQSPI2ErISR, CPU1_RUNNING_TASK, ISR_PRIORITY_SLAVE_ER_QSPI_SAFE);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * get time in millisecond
 * */
float64 getMilliSecondTime()
{
    return ((IfxStm_get(&MODULE_STM2) / IfxStm_getFrequency(&MODULE_STM2)) * SEC_TO_MILLISEC);
}

/* SPI Slave ISR for transmit data */
void slaveQSPI2TxISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrTransmit(&g_qspiSlaveSafe.spiSafeComSlave);
}

/*
 * SPI Slave ISR for receive data
 * This Interrupt occur for each data of 32 bits received (9 times for one frame)
 * */
void slaveQSPI2RxISR()
{
    static uint8 messageCounter = 0;
    static uint32 frameCounterSlaveQSPI = 0;      /* Frame counter for receiving */

    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrReceive(&g_qspiSlaveSafe.spiSafeComSlave);
    messageCounter++;

    /* check if the complete frame of FRAME_SIZE is received */
    if(messageCounter == FRAME_SIZE)
    {
        messageCounter = 0;
        g_frameReceived = TRUE;

        /* data and cycle time validation */
        validateSlaveDataAndCycleTime(frameCounterSlaveQSPI++, getMilliSecondTime());

        /* Instruct the SPI Slave to receive a next data stream of defined length */
        IfxQspi_SpiSlave_exchange(&g_qspiSlaveSafe.spiSafeComSlave, NULL_PTR,
                &g_qspiSlaveSafe.qspiSlaveRx.data[0], FRAME_SIZE);
    }
}

/* SPI Slave ISR for error */
void slaveQSPI2ErISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrError(&g_qspiSlaveSafe.spiSafeComSlave);
}

/*
 * QSPI Slave initialization
 * This function initializes the QSPI2 module in Slave mode.
 */
void initQSPI2Slave(void)
{
    /* Define the Slave configuration */
    IfxQspi_SpiSlave_Config spiSlaveConfig;

    /* Initialize it with default values */
    IfxQspi_SpiSlave_initModuleConfig(&spiSlaveConfig, &MODULE_QSPI2);
    spiSlaveConfig.protocol.dataWidth = DATA_WIDTH;
    /* Select the port pins for communication */
    const IfxQspi_SpiSlave_Pins qspi2SlavePins = {
        &IfxQspi2_SCLKB_P15_8_IN, IfxPort_InputMode_pullDown,           /* SCLK Pin                       (CLK)     */
        &IfxQspi2_MTSRB_P15_6_IN, IfxPort_InputMode_pullDown,           /* MasterTransmitSlaveReceive pin (MOSI)    */
        &IfxQspi2_MRST_P15_7_OUT, IfxPort_OutputMode_pushPull,          /* MasterReceiveSlaveTransmit pin (MISO)    */
        &IfxQspi2_SLSIB_P15_1_IN, IfxPort_InputMode_pullDown,           /* SlaveSelect Pin                (CS)      */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                          /* Pad driver mode                          */
    };
    spiSlaveConfig.pins = &qspi2SlavePins;                              /* Assign Slave port pins                   */

    /* Set the ISR priorities and the service provider */
    spiSlaveConfig.base.txPriority = ISR_PRIORITY_SLAVE_TX_QSPI_SAFE;
    spiSlaveConfig.base.rxPriority = ISR_PRIORITY_SLAVE_RX_QSPI_SAFE;
    spiSlaveConfig.base.erPriority = ISR_PRIORITY_SLAVE_ER_QSPI_SAFE;
    spiSlaveConfig.base.isrProvider = IfxSrc_Tos_cpu1;

    /* Initialize QSPI Slave module */
    IfxQspi_SpiSlave_initModule(&g_qspiSlaveSafe.spiSafeComSlave, &spiSlaveConfig);
}

/*
 * This function to validate the timeout timing of QSPI
 * */
void timeoutSlaveQspiSafeCommunication(void)
{
    if (TRUE == enableQspiSafeCommunication)
    {
        static float64 endOfFrameTime, startTime;
        startTime = getMilliSecondTime();
        do
        {
            /* time when the frame transfer is finished */
            endOfFrameTime = (getMilliSecondTime() - startTime);
            if (endOfFrameTime > FRAME_TIMEOUT)
            {
                g_ErrorTypeQspiSafe = 4;
                softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
                return;
            }
        }while (g_frameReceived == FALSE);

        g_frameReceived = FALSE;
    }
}

/*
 * This function to validate the cycle timing of QSPI frame
 * */
void validateFrameCylceTime(float64 cycleTime)
{
    static uint32 calibrationCounter = 0;
    static float64 previousCycleTime = 0;

    /* validate the cycle time only after 2nd frame received */
    if (calibrationCounter == 0)
    {
        calibrationCounter++;
    }
    else
    {
        if((cycleTime - previousCycleTime) < EARLY_FRAME_TIME)
        {
            g_ErrorTypeQspiSafe = 2;
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
        }
        else if((cycleTime - previousCycleTime) > LATE_FRAME_TIME)
        {
            g_ErrorTypeQspiSafe = 3;
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
        }
    }
    previousCycleTime = cycleTime;
}

/*
 * This function to validate the data of QSPI frame
 * */
void validateSlavedata(uint32 frameCounter)
{
    uint32 calculatedCrcResultSlaveRx = 0;

    /* calculate CRC on Slave received data */
    for (uint8 i=0; i < BUFFER_SIZE ; i++)
    {
        calculatedCrcResultSlaveRx = __crc32(calculatedCrcResultSlaveRx,
                g_qspiSlaveSafe.qspiSlaveRx.dataS.spi3SlaveRxBuffer[i]);
    }

    /* Check if the slave received data matches the master sent data i.e. ID, Frame counter, CRC  */
    if ((MASTER_DATA_ID != g_qspiSlaveSafe.qspiSlaveRx.dataS.data_id ) ||
        (frameCounter != g_qspiSlaveSafe.qspiSlaveRx.dataS.frame_counter ) ||
        (calculatedCrcResultSlaveRx != g_qspiSlaveSafe.qspiSlaveRx.dataS.crc))
    {
        g_ErrorTypeQspiSafe = 1;
        /* software alarm trigger and alarm window pop up on display */
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
    }
}
/*
 * This function checks if the received data is correct
 * */
void validateSlaveDataAndCycleTime(uint32 frameCounterSlaveQSPI, float64 cycleTime)
{
    uint32 waitTimeout = 0xffff;

    /* Wait until the Slave has received all the data or or if the timeout comes */
    while((IfxQspi_SpiSlave_getStatus(&g_qspiSlaveSafe.spiSafeComSlave) == SpiIf_Status_busy) &&
            (waitTimeout > 0))
    {
        waitTimeout--;
    }

    /* validate the data of QSPI frame */
    validateSlavedata(frameCounterSlaveQSPI);

    /* validate the cycle time */
    validateFrameCylceTime(cycleTime);
}

/*
 * This function initialize the QSPI modules as slave
 * */
void initQspiSlaveSafeCommunication()
{
    /* Initialize the Slave */
    initQSPI2Slave();

    /* Instruct the SPI Slave to receive a data stream of defined length */
    IfxQspi_SpiSlave_exchange(&g_qspiSlaveSafe.spiSafeComSlave, NULL_PTR,
            &g_qspiSlaveSafe.qspiSlaveRx.data[0], FRAME_SIZE);
}
