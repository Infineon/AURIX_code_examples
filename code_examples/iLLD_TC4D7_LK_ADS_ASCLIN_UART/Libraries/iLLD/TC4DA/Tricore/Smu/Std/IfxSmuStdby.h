/**
 * \file IfxSmuStdby.h
 * \brief SMU  basic functionality
 * \ingroup IfxLld_Smu
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Smu_Std_Stdby STDBY
 * \ingroup IfxLld_Smu_Std
 * \defgroup IfxLld_Smu_Std_Stdby_Enumerations Enumerations
 * \ingroup IfxLld_Smu_Std_Stdby
 * \defgroup IfxLld_Smu_Std_Stdby_Structures Structures
 * \ingroup IfxLld_Smu_Std_Stdby
 * \defgroup IfxLld_Smu_Std_Stdby_Functions Functions
 * \ingroup IfxLld_Smu_Std_Stdby
 */

#ifndef IFXSMUSTDBY_H
#define IFXSMUSTDBY_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxSmu_cfg.h"
#include "IfxSmu_reg.h"
#include "IfxSmu_stdby_reg.h"
#include "IfxSmu_stdby_bf.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Smu_Std_Stdby_Enumerations
 * \{ */
/** \brief This bit  (CMD_STDBY.B.ASCE) controls if a status flag set in an AGx register upon detection of the alarm event can be cleared by software or not. When ASCE is enabled, software shall write a 1 to bit position in AGx to clear the bit
 * (W1C). When a W1C action takes place the ASCE bit is automatically cleared to 0 by hardware and software shall set the ASCE bit again.
 * 0B SMU_stdby alarm status bits in AGi cannot be cleared.
 * 1B SMU_stdby alarm status bits in AGi can be cleared
 */
typedef enum
{
    IfxSmuStdby_AlarmStatusClear_disable = 0,  /**< \brief SMU_stdby alarm status bits in AGi cannot be cleared */
    IfxSmuStdby_AlarmStatusClear_enable  = 1   /**< \brief SMU_stdby alarm status bits in AGi can be cleared */
} IfxSmuStdby_AlarmStatusClear;

/** \brief Status flag for alarm
 * 0B Status flag  does not report a fault condition
 * 1B Status flag reports a fault condition
 */
typedef enum
{
    IfxSmuStdby_AlarmStatusFlag_noFaultExist = 0,  /**< \brief Status flag does not report a fault condition */
    IfxSmuStdby_AlarmStatusFlag_faultExist   = 1   /**< \brief Status flag does report a fault condition */
} IfxSmuStdby_AlarmStatusFlag;

/** \brief Fault signaling configuration flag
 */
typedef enum
{
    IfxSmuStdby_FaultSignalAlarmConfigFlagEvent_disable = 0,  /**< \brief FSP disabled for this alarm event */
    IfxSmuStdby_FaultSignalAlarmConfigFlagEvent_enable  = 1   /**< \brief FSP enabled for this alarm event */
} IfxSmuStdby_FaultSignalAlarmConfigFlagEvent;

/** \brief Error Pin Fault State Status
 */
typedef enum
{
    IfxSmuStdby_FspErrorPinFaultState_noFault = 0,  /**< \brief Error pin was not set into fault state */
    IfxSmuStdby_FspErrorPinFaultState_fault   = 1   /**< \brief Error pin was set into fault state */
} IfxSmuStdby_FspErrorPinFaultState;

/** \brief SMU_stdby Error pin function to be able set Pin to fault state. (CMD_STDBY.B.FSP0EN or CMD_STDBY.B.FSP1EN)
 */
typedef enum
{
    IfxSmuStdby_FspErrorPinState_inactive = 0,  /**< \brief SMU_stdby Error Pin fault indication function on pin inactive */
    IfxSmuStdby_FspErrorPinState_active   = 1   /**< \brief SMU_stdby Error Pin fault indication function on pin active */
} IfxSmuStdby_FspErrorPinState;

/** \brief FSP Index
 */
typedef enum
{
    IfxSmuStdby_FspIndex_none = -1,  /**< \brief Not Selected */
    IfxSmuStdby_FspIndex_0    = 0,   /**< \brief FSP index0  */
    IfxSmuStdby_FspIndex_1,          /**< \brief FSP index1  */
    IfxSmuStdby_FspIndex_2,          /**< \brief FSP index2  */
    IfxSmuStdby_FspIndex_3           /**< \brief FSP index3  */
} IfxSmuStdby_FspIndex;

/** \brief Pull Down Pin State
 */
typedef enum
{
    IfxSmuStdby_FspPullDownPinState_inactive = 0,  /**< \brief Pull down state inactive */
    IfxSmuStdby_FspPullDownPinState_active   = 1   /**< \brief Pull down state active */
} IfxSmuStdby_FspPullDownPinState;

/** \brief SMU_stdby Module Enable(CMD_STDBY.B.SMUEN)
 */
typedef enum
{
    IfxSmuStdby_SmuStdbyModuleState_disable = 0,  /**< \brief SMU_stdby disabled */
    IfxSmuStdby_SmuStdbyModuleState_enable  = 1   /**< \brief SMU_stdby enabled */
} IfxSmuStdby_SmuStdbyModuleState;

/** \} */

/** \addtogroup IfxLld_Smu_Std_Stdby_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function clears the TSTEN, TSTRUN, TSTDONE, TSTOK, SMUERR and PMSERR flags
 * \return None
 */
IFX_INLINE void IfxSmuStdby_clearSmuStdbyMonBistFlags(void);

/** \brief This function enable / disables he Alarm status clear in the Smu Standby command register .
 * This controls if a status flag set in an AGx register upon detection of the alarm event can be cleared by software or not. When ASCE is enabled, software shall write a 1 to bit position in AGx to clear the bit
 * (W1C). When a W1C action takes place the ASCE bit is automatically cleared to 0 by hardware and software shall set the ASCE bit again.
 * \return None
 */
IFX_INLINE void IfxSmuStdby_enableAlarmStatusClear(void);

/** \brief This function enables the Smu Standby module
 * \param enable SMU standby enable/disable Module
 * \return None
 */
IFX_INLINE void IfxSmuStdby_enableSmuStdby(IfxSmuStdby_SmuStdbyModuleState enable);

/** \brief This function enables the Smu standby Built-in Self test
 * \return None
 */
IFX_INLINE void IfxSmuStdby_enableSmuStdbyMonBist(void);

/** \brief Funtion returns Smu Standby Alarm Group status
 * \param alarm smu alarm group and position
 * \return Smu standby status
 */
IFX_INLINE uint32 IfxSmuStdby_getSmuStdbyAlarmGroupStatus(IfxSmu_Alarm alarm);

/** \brief Funtion returns Smu Standby Alarm status
 * \param alarm smu alarm group and position
 * \return Smu standby status
 */
IFX_INLINE uint32 IfxSmuStdby_getSmuStdbyAlarmStatus(IfxSmu_Alarm alarm);

/** \brief This function returns the SMU standby module status (enabled/disabled).
 * \return Smu standby status
 */
IFX_INLINE IfxSmuStdby_SmuStdbyModuleState IfxSmuStdby_getSmuStdbyModuleStatus(void);

/** \brief This function returns the Smu Stdby BIST PMSERR flag
 * \return Smu Stdby BIST PMSERR flag
 */
IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistPmsErrorFlag(void);

/** \brief This function returns the Smu Stdby BIST SMUERR flag
 * \return Smu Stdby BIST SMUERR flag
 */
IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistSmuErrorFlag(void);

/** \brief This function returns the Smu Stdby BIST TSTDONE flag
 * \return Smu Stdby BIST TSTDONE flag
 */
IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistTestDoneFlag(void);

/** \brief This function returns the Smu Stdby BIST TSTOK flag
 * \return Smu Stdby BIST TSTOK flag
 */
IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistTestOkFlag(void);

/** \brief This function returns the Smu Stdby BIST TSTRUN flag
 * \return Smu Stdby BIST TSTRUN flag
 */
IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistTestRunFlag(void);

/** \brief Function to configure FSP Alarm group functionality
 * \param alarm smu alarm group and position
 * \param flags Fault Signal Alarm Group config event flags
 * \return None
 */
IFX_INLINE void IfxSmuStdby_setFaultSignalAGConfigEventFlags(IfxSmu_Alarm alarm, uint32 flags);

/** \brief This function sets FSPx(x=0-3) Error pin fault indication function .
 * \param index FSP Index
 * \param active Set FSP Error pin fault indication function to active / inactive
 * \return None
 */
IFX_INLINE void IfxSmuStdby_setFspErrorPinActive(IfxSmuStdby_FspIndex index, IfxSmuStdby_FspErrorPinState active);

/** \brief This function sets FSPx(x=0-3) Error pin pull down indication function .
 * \param index FSP index
 * \param active Set FSP pull down indication function to active / inactive
 * \return None
 */
IFX_INLINE void IfxSmuStdby_setFspPullDownActive(IfxSmuStdby_FspIndex index, IfxSmuStdby_FspPullDownPinState active);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to configure FSP functionality , FaultSignalAlarmConfigEventFlag
 * Note: This function has an assumption that the FSP0-3 register bitfields remain the same. In case this changes the API will need an update
 * \param address Pointer to the FSP register to be configured
 * \param alarm smu alarm group and position
 * \param enable enable/disable Fault Signal Alarm config event flag
 * \return None
 *
 * IfxSmuStdby_setFaultSignalAlarmConfigEventFlag((void *)(&MODULE_SMUSTDBY.AGSTDBY[0].FSP0),0,2,IfxSmuStdby_FaultSignalAlarmConfigFlagEvent_enable);
 *
 */
IFX_EXTERN void IfxSmuStdby_setFaultSignalAlarmConfigEventFlag(void *address, IfxSmu_Alarm alarm, IfxSmuStdby_FaultSignalAlarmConfigFlagEvent enable);

/** \brief Function to configure alarm status.
 * \param alarm smu alarm group and position
 * \param status enable/disable Alarm status flag
 * \return None
 */
IFX_EXTERN void IfxSmuStdby_setSmuStdbyAlarmStatusFlag(IfxSmu_Alarm alarm, IfxSmuStdby_AlarmStatusFlag status);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief The API will clear all the FSP config event flags
 * \param agStdby Pointer to agStdby register
 * \return None
 */
IFX_INLINE void IfxSmuStdby_clearFaultSignalAlarmConfigEventFlags(Ifx_SMU_STDBY_AGSTDBY *agStdby);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures access to all masters to the STDBY SMU's in the device
 * \param apConfig config pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxSmuStdby_configureAccessToStandbySmu(IfxApApu_ApuConfig *apConfig);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxSmuStdby_clearSmuStdbyMonBistFlags(void)
{
    Ifx_SMU_STDBY_MONBISTCTRL monBistCtrl;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    monBistCtrl.U          = SMUSTDBY_MONBISTCTRL.U;
    monBistCtrl.B.TSTCLR   = 1;
    monBistCtrl.B.BITPROT  = 1;
    SMUSTDBY_MONBISTCTRL.U = monBistCtrl.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmuStdby_enableAlarmStatusClear(void)
{
    Ifx_SMU_STDBY_CMDSTDBY cmdStdby;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    cmdStdby.U          = SMUSTDBY_CMDSTDBY.U;
    cmdStdby.B.ASCE     = 1;
    cmdStdby.B.BITPROT  = 1;
    SMUSTDBY_CMDSTDBY.U = cmdStdby.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmuStdby_enableSmuStdby(IfxSmuStdby_SmuStdbyModuleState enable)
{
    Ifx_SMU_STDBY_CMDSTDBY cmdStdby;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    cmdStdby.U          = SMUSTDBY_CMDSTDBY.U;
    cmdStdby.B.SMUEN    = enable;
    cmdStdby.B.BITPROT  = 1;
    SMUSTDBY_CMDSTDBY.U = cmdStdby.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmuStdby_enableSmuStdbyMonBist(void)
{
    Ifx_SMU_STDBY_MONBISTCTRL monBistCtrl;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    monBistCtrl.U          = SMUSTDBY_MONBISTCTRL.U;
    monBistCtrl.B.TSTEN    = 1;
    monBistCtrl.B.BITPROT  = 1;
    SMUSTDBY_MONBISTCTRL.U = monBistCtrl.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


IFX_INLINE uint32 IfxSmuStdby_getSmuStdbyAlarmGroupStatus(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup       = (int)alarm >> 5;
    uint32 alarmGroupStatus = 0;

    alarmGroupStatus = MODULE_SMUSTDBY.AGSTDBY[alarmGroup].STS.U;

    return alarmGroupStatus;
}


IFX_INLINE uint32 IfxSmuStdby_getSmuStdbyAlarmStatus(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup  = (int)alarm >> 5;
    uint8  alarmPos    = (int)alarm & 0x1F;
    uint32 alarmStatus = 0;

    alarmStatus = ((MODULE_SMUSTDBY.AGSTDBY[alarmGroup].STS.U) >> alarmPos) & 0x01U;

    return alarmStatus;
}


IFX_INLINE IfxSmuStdby_SmuStdbyModuleState IfxSmuStdby_getSmuStdbyModuleStatus(void)
{
    return (IfxSmuStdby_SmuStdbyModuleState)SMUSTDBY_CMDSTDBY.B.SMUEN;
}


IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistPmsErrorFlag(void)
{
    return SMUSTDBY_MONBISTSTAT.B.PMSERR;
}


IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistSmuErrorFlag(void)
{
    return SMUSTDBY_MONBISTSTAT.B.SMUERR0;
}


IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistTestDoneFlag(void)
{
    return SMUSTDBY_MONBISTSTAT.B.TSTDONE;
}


IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistTestOkFlag(void)
{
    return SMUSTDBY_MONBISTSTAT.B.TSTOK;
}


IFX_INLINE boolean IfxSmuStdby_getSmuStdbyMonBistTestRunFlag(void)
{
    return SMUSTDBY_MONBISTSTAT.B.TSTRUN;
}


IFX_INLINE void IfxSmuStdby_setFaultSignalAGConfigEventFlags(IfxSmu_Alarm alarm, uint32 flags)
{
    uint16 alarmGroup = (int)alarm >> 5;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    MODULE_SMUSTDBY.AGSTDBY[alarmGroup].STS.U = flags;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmuStdby_setFspErrorPinActive(IfxSmuStdby_FspIndex index, IfxSmuStdby_FspErrorPinState active)
{
    Ifx_SMU_STDBY_CMDSTDBY cmdStdby;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    cmdStdby.U = SMUSTDBY_CMDSTDBY.U;

    if (active)
    {
        cmdStdby.U |= (1U << (index + IFX_SMU_STDBY_CMDSTDBY_FSP0EN_OFF));
    }
    else
    {
        cmdStdby.U &= ~(1U << (index + IFX_SMU_STDBY_CMDSTDBY_FSP0EN_OFF));
    }

    cmdStdby.B.BITPROT  = 1;
    SMUSTDBY_CMDSTDBY.U = cmdStdby.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmuStdby_setFspPullDownActive(IfxSmuStdby_FspIndex index, IfxSmuStdby_FspPullDownPinState active)
{
    Ifx_SMU_STDBY_CMDSTDBY cmdStdby;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    cmdStdby.U = SMUSTDBY_CMDSTDBY.U;

    if (active)
    {
        cmdStdby.U |= (1U << (index + IFX_SMU_STDBY_CMDSTDBY_FSP0PD_OFF));
    }
    else
    {
        cmdStdby.U &= ~(1U << (index + IFX_SMU_STDBY_CMDSTDBY_FSP0PD_OFF));
    }

    cmdStdby.B.BITPROT  = 1;
    SMUSTDBY_CMDSTDBY.U = cmdStdby.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmuStdby_clearFaultSignalAlarmConfigEventFlags(Ifx_SMU_STDBY_AGSTDBY *agStdby)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_config);
#endif

    agStdby->FSP0.U = 0x40000000U;
    agStdby->FSP1.U = 0x40000000U;
    agStdby->FSP2.U = 0x40000000U;
    agStdby->FSP3.U = 0x40000000U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMUSTDBY.PROTSTDBYE, IfxApProt_State_run);
#endif
}


#endif /* IFXSMUSTDBY_H */
