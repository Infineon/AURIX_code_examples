/**
 * \file IfxSmu.c
 * \brief SMU  basic functionality 
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 *

*                                 IMPORTANT NOTICE
*
* Use of this file is subject to the terms of use agreed between (i) you or
* the company in which ordinary course of business you are acting and (ii)
* Infineon Technologies AG or its licensees. If and as long as no such terms
* of use are agreed, use of this file is subject to following:
*
* Boost Software License - Version 1.0 - August 17th, 2003
*
* Permission is hereby granted, free of charge, to any person or organization
* obtaining a copy of the software and accompanying documentation covered by
* this license (the "Software") to use, reproduce, display, distribute,
* execute, and transmit the Software, and to prepare derivative works of the
* Software, and to permit third-parties to whom the Software is furnished to
* do so, all subject to the following:
*
* The copyright notices in the Software and this entire statement, including
* the above license grant, this restriction and the following disclaimer, must
* be included in all copies of the Software, in whole or in part, and all
* derivative works of the Software, unless such copies or derivative works are
* solely in the form of machine-executable object code generated by a source
* language processor.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
* SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
* FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
* DEALINGS IN THE SOFTWARE.
 
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxSmu.h"

 

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/


void IfxSmu_setSafetyAlarmAction(IfxSmu_Alarm alarm, IfxSmu_InternalAlarmAction intAlarmAction, boolean smuSafeIndex)
{
    uint32 alarmGroupCF3;
    uint32 alarmGroupCF2;
    uint32 alarmGroupCF1;
    uint32 alarmGroupCF0;
    uint32 alarmGroupCFMask;
    uint16 alarmGroup = (int)alarm >> 5;
    uint8  alarmPos   = (int)alarm & 0x1F;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.SAFE[smuSafeIndex].KEYS.B.PERLCK != 0xFFU));

    /* Get the mask for configuration registers to set the particular
     * bits
     */
    alarmGroupCFMask = ~((uint32)0x1U << alarmPos);

    /* Extract Alarm configuration for 4 CFG registers
     * from input parameter
     */
    alarmGroupCF0 = (intAlarmAction & 0x01) << alarmPos;
    alarmGroupCF1 = ((intAlarmAction >> 1) & 0x01) << alarmPos;
    alarmGroupCF2 = ((intAlarmAction >> 2) & 0x01) << alarmPos;
    alarmGroupCF3 = ((intAlarmAction >> 3) & 0x01) << alarmPos;

    /* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.SAFE[smuSafeIndex].KEYS.U = (uint32)0x000000bc;

    /* Write Alarm configuration into corresponding
     *   SMU alarm CFx (x=0-3) registers
     */
    MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[0].U = (MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[0].U & alarmGroupCFMask) | alarmGroupCF0;
    MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[1].U = (MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[1].U & alarmGroupCFMask) | alarmGroupCF1;
    MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[2].U = (MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[2].U & alarmGroupCFMask) | alarmGroupCF2;
    MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[3].U = (MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].CON[3].U & alarmGroupCFMask) | alarmGroupCF3;

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.SAFE[smuSafeIndex].KEYS.U = 0;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_run);
#endif
}


boolean IfxSmu_setSafetyAlarmStatus(IfxSmu_Alarm alarm, boolean smuSafeIndex, boolean smuSafeStateMachineId)
{
    uint16          alarmGroup = (int)alarm >> 5;
    uint8           alarmPos   = (int)alarm & 0x1F;
    IfxSmu_SmuState smuState;
    boolean         status     = 0U;

    /* Read the SMU state from module DBG register */
    if (smuSafeStateMachineId == 0)
    {
        smuState = (IfxSmu_SmuState)(MODULE_SMU.SAFE[smuSafeIndex].DBG.B.SSM0);
    }
    else
    {
        smuState = (IfxSmu_SmuState)(MODULE_SMU.SAFE[smuSafeIndex].DBG.B.SSM1);
    }

    if (smuState == IfxSmu_SmuState_start)
    {
        /* SMU is in START state */
        /* All SMU Groups are allowed to set alarm status */
	/* Register protected by APU-PSAFEx register set and not PROT */

        /* Write 1 in AG bit to set alarm */
        MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].STS.U = ((uint32)0x1U << alarmPos);

    }
    else   /* Alarm is in RUN state or FAULT state */
    {
        /* SW Alarm Group/s are only allowed to set alarm status */
        /* Write SMU_ALARM(ARG), where ARG:alarmPos in CMD register to set the Alarm  */
        Ifx_SMU_SAFE_CMD cmdSfr;
        cmdSfr.U                                = MODULE_SMU.SAFE[smuSafeIndex].CMD.U;
        cmdSfr.B.CMD                            = IfxSmu_Command_triggerAlarm;
        cmdSfr.B.ARG                            = alarmPos;
        MODULE_SMU.SAFE[smuSafeIndex].CMD.U = cmdSfr.U;
        status                                  = MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES;
    }

    return status;
}


boolean IfxSmu_smuSafeActivateRunState(boolean smuSafeIndex, boolean smuSafeStateMachineId)
{
    Ifx_SMU_SAFE_CMD cmdSfr;

	cmdSfr.U                            = MODULE_SMU.SAFE[smuSafeIndex].CMD.U;
    /* Check if SMU is in START state */
    if (smuSafeStateMachineId == 0)
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.SAFE[smuSafeIndex].DBG.B.SSM0 == IfxSmu_SmuState_start));
    }
    else
    {
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.SAFE[smuSafeIndex].DBG.B.SSM1 == IfxSmu_SmuState_start));
    }

    /* Write CMD for RUN */
    cmdSfr.B.CMD = IfxSmu_Command_start;

    cmdSfr.B.ARG = smuSafeStateMachineId;

    MODULE_SMU.SAFE[smuSafeIndex].CMD.U = cmdSfr.U;

    return MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES;
}


boolean IfxSmu_smuSafeClearAlarmStatus(IfxSmu_Alarm alarm, boolean smuSafeIndex)
{
    uint16 alarmGroup = (int)alarm >> 5;
    uint8  alarmPos   = (int)alarm & 0x1F;

    /* Write SMU_ASCE(0) in CMD register */
    MODULE_SMU.SAFE[smuSafeIndex].CMD.U = IfxSmu_Command_alarmStatusClear;
   
    /* Register protected by APU-PSAFEx register set and not PROT
       Write 1 in AG bit to clear alarm */
    MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].STS.U = (uint32)((uint32)0x1U << alarmPos);
    
    return MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES;
}


boolean IfxSmu_smuSafeGetAlarmStatus(IfxSmu_Alarm alarm, boolean smuSafeIndex)
{
    uint16  alarmGroup = (int)alarm >> 5;
    uint8   alarmPos   = (int)alarm & 0x1F;

    /* Read Alarm status */
    boolean alarmStatus = (boolean)((MODULE_SMU.SAFE[smuSafeIndex].AGSF[alarmGroup].STS.U >> alarmPos) & 0x1);

    return alarmStatus;
}


IfxSmu_SmuState IfxSmu_getSmuSafeState(boolean smuSafeIndex, boolean smuSafeStateMachineId)
{
    /* Return SMU state read from DBG register */
    if (smuSafeStateMachineId == 0)
    {
        return (IfxSmu_SmuState)(MODULE_SMU.SAFE[smuSafeIndex].DBG.B.SSM0);
    }
    else
    {
        return (IfxSmu_SmuState)(MODULE_SMU.SAFE[smuSafeIndex].DBG.B.SSM1);
    }
}


void IfxSmu_smuSafeWaitForAlarm(IfxSmu_Alarm alarm, boolean smuSafeIndex)
{
    while(!IfxSmu_smuSafeGetAlarmStatus(alarm, smuSafeIndex));
	
    IfxSmu_smuSafeClearAlarmStatus(alarm, smuSafeIndex);
}


void IfxSmu_safetyConfigAlarmActionPES(uint32 pesAction, boolean smuSafeIndex)
{
    /* Register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_config);
#endif

    /* Port Emergency Stop: enables control of the Port Emergency Stop (PES) feature
     * independently for each internal action. When an action is triggered and if the
     * corresponding bit (as defined below) is set, the hardware triggers
     * automatically a port emergency stop request. Each bit of PES is allocated to
     * an action as follows:
     * 1H SMU_IGCS0 activates PES
     * 2H SMU_IGCS1 activates PES
     * 4H SMU_IGCS2 activates PES
     * 8H SMU_NMI activates PES
     * 10H SMU_CPU_RESET activates PES */

    MODULE_SMU.SAFE[smuSafeIndex].PES.U = pesAction;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_run);
#endif
}


boolean IfxSmu_smu_SafeActivateFSP(boolean smuSafeIndex, boolean smuSafeStateMachineId)
{
    Ifx_SMU_SAFE_CMD cmdSfr;

	cmdSfr.U                            = MODULE_SMU.SAFE[smuSafeIndex].CMD.U;
    /* Activate FSP by Writing SMU_ActivateFSP(0) in CMD register */
	cmdSfr.B.CMD = IfxSmu_Command_activateFSP;

	cmdSfr.B.ARG = smuSafeStateMachineId;

	MODULE_SMU.SAFE[smuSafeIndex].CMD.U = cmdSfr.U;

    /* Check if Activate FSP command is successfully accepted */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES == 0));

    return MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES;
}


boolean IfxSmu_smuSafeReleaseFSP(boolean smuSafeIndex, boolean smuSafeStateMachineId)
{
    Ifx_SMU_SAFE_CMD cmdSfr;

	cmdSfr.U                            = MODULE_SMU.SAFE[smuSafeIndex].CMD.U;
    /* Check if SMU is in FAULT state and EFRST is enabled*/
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, ((IfxSmu_getSmuSafeState(smuSafeIndex, smuSafeStateMachineId) != IfxSmu_SmuState_fault) || (MODULE_SMU.SAFE[smuSafeIndex].AGC.B.EFRST0 != 0) || (MODULE_SMU.SAFE[smuSafeIndex].AGC.B.EFRST1 != 0)));

    /* SMU is in START state or (FAULT state with EFRST enabled) */
    /* Release FSP to Fault Free state */
    cmdSfr.B.CMD = IfxSmu_Command_releaseFSP;

    cmdSfr.B.ARG = smuSafeStateMachineId;

    MODULE_SMU.SAFE[smuSafeIndex].CMD.U = cmdSfr.U;

    /* Check if Release FSP command is accepted by reading the Status reg
     */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES == 0));

    return MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES;
}


void IfxSmu_smuSafeLockConfigRegisters(boolean smuSafeIndex)
{
    /* Check if SMU cfg registers is not locked */
    if (MODULE_SMU.SAFE[smuSafeIndex].KEYS.B.PERLCK != 0xFFU)
    {
	/* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_config);
#endif

        /* Write the key reg to lock config registers */
        MODULE_SMU.SAFE[smuSafeIndex].KEYS.B.PERLCK = 0xFFU;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_run);
#endif
    }
}


boolean IfxSmu_smuSafeStopRT(uint8 timerNum, boolean smuSafeIndex)
{
    /* Write CMD for Stop Recovery Timer */
    Ifx_SMU_SAFE_CMD cmdSfr;
    cmdSfr.U                                = MODULE_SMU.SAFE[smuSafeIndex].CMD.U;
    cmdSfr.B.CMD                            = IfxSmu_Command_stopRT;
    cmdSfr.B.ARG                            = timerNum;
    MODULE_SMU.SAFE[smuSafeIndex].CMD.U = cmdSfr.U;

    return MODULE_SMU.SAFE[smuSafeIndex].STS.B.RES;
}


boolean IfxSmu_smuSafeUnlockConfigRegisters(boolean smuSafeIndex)
{
    boolean status = 1U;

    /* Check if SMU cfg registers is not locked */
    if (MODULE_SMU.SAFE[smuSafeIndex].KEYS.B.PERLCK != 0xFFU)
    {
	/* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_config);
#endif

        /*Write Config key to configure the SMU registers. */
        MODULE_SMU.SAFE[smuSafeIndex].KEYS.U = (uint32)0x000000bc;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_run);
#endif
    }
    else
    {
        /* If SMU config is permanently locked then return false */
        status = 0U;
    }

    return status;
}


void IfxSmu_smuSafeTemporaryLockConfigRegisters(boolean smuSafeIndex)
{
    /* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_config);
#endif

    /*Write Config key to configure temporary lock of the SMU registers. */
    MODULE_SMU.SAFE[smuSafeIndex].KEYS.U = 0U;

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuSafeIndex].PROTSE, IfxApProt_State_run);
#endif
}


void IfxSmu_setSecurityAlarmAction(IfxSmu_Alarm alarm, IfxSmu_SecurityAlarmAction AlarmAction)
{
    uint32 alarmGroupCF2;
    uint32 alarmGroupCF1;
    uint32 alarmGroupCF0;
    uint32 alarmGroupCFMask;
    uint16 alarmGroup = ((int)alarm >> 5);
    uint8  alarmPos   = (int)alarm & 0x1F;
    /* uint16 passwd = IfxWtu_getSecurityWatchdogPassword(); */

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.CS.KEYS.B.PERLCK != 0xFFU));

    /* Get the mask for configuration registers to set the perticular
     * bits
     */
    alarmGroupCFMask = ~((uint32)0x1U << alarmPos);

    /* Extract Alarm configuration for 3 CFG registers
     * from input parameter
     */
    alarmGroupCF0 = (AlarmAction & 0x01) << alarmPos;
    alarmGroupCF1 = ((AlarmAction >> 1) & 0x01) << alarmPos;
    alarmGroupCF2 = ((AlarmAction >> 2) & 0x01) << alarmPos;

    /* Register protected by CE (CS_PROTCE) and APU-PCS */
    /* disable the write-protection for registers */

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.CS.KEYS.U = (uint32)0x000000bc;

    /* Write Alarm configuration into corresponding
     *   SMU alarm CFx (x=0-3) registers
     */
    MODULE_SMU.CS.AGCS[alarmGroup].CON[0].U = (MODULE_SMU.CS.AGCS[alarmGroup].CON[0].U & alarmGroupCFMask) | alarmGroupCF0;
    MODULE_SMU.CS.AGCS[alarmGroup].CON[1].U = (MODULE_SMU.CS.AGCS[alarmGroup].CON[1].U & alarmGroupCFMask) | alarmGroupCF1;
    MODULE_SMU.CS.AGCS[alarmGroup].CON[2].U = (MODULE_SMU.CS.AGCS[alarmGroup].CON[2].U & alarmGroupCFMask) | alarmGroupCF2;

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.CS.KEYS.U = 0;

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_run);
#endif
}


boolean IfxSmu_setSecurityAlaramStatus(IfxSmu_Alarm alarm)
{
    uint16                  alarmGroup = ((int)alarm >> 5);
    uint8                   alarmPos   = (int)alarm & 0x1F;
    IfxSmu_SmuSecurityState smuState;
    boolean                 status     = 0U;

    /* Read the SMU state from module DBG register */
    smuState = (IfxSmu_SmuSecurityState)(MODULE_SMU.CS.DBG.B.SSM);

    if (smuState == IfxSmu_SmuSecurityState_start)
    {
        /* SMU is in START state */
        /* All SMU Groups are allowed to set alarm status */

        /* disable the write-protection for registers */
	/* register protected by APU-PCS register set and not PROT */
        /* Write 1 in AG bit to set alarm */
        MODULE_SMU.CS.AGCS[alarmGroup].STS.U = ((uint32)0x1U << alarmPos);

        /* Restore back the write-protection for registers */
    }
    else   /* Alarm is in RUN state or FAULT state */
    {
        /* SW Alarm Group/s are only allowed to set alarm status */
        /* Write SMU_ALARM(ARG), where ARG:alarmPos in CMD register to set the Alarm  */
        Ifx_SMU_CS_CMD cmdSfr;
        cmdSfr.U           = MODULE_SMU.CS.CMD.U;
        cmdSfr.B.CMD       = IfxSmu_SecurityCommand_triggerAlarm;
        cmdSfr.B.ARG       = alarmPos;
        MODULE_SMU.CS.CMD.U = cmdSfr.U;
        status             = MODULE_SMU.CS.STS.B.RES;
    }

    return status;
}


boolean IfxSmu_smuSecurityActivateRunState(void)
{
    /* Check if SMU is in START state */
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.CS.DBG.B.SSM == IfxSmu_SmuSecurityState_start));

    /* Write CMD for RUN */
    MODULE_SMU.CS.CMD.U = IfxSmu_SecurityCommand_start;

    return MODULE_SMU.CS.STS.B.RES;
}


boolean IfxSmu_smuSecurityClearAlarmStatus(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup = ((int)alarm >> 5);
    uint8  alarmPos   = (int)alarm & 0x1F;

    /* Write SMU_ASCE(0) in CMD register */
    MODULE_SMU.CS.CMD.U = IfxSmu_SecurityCommand_ASCE;

    /* disable the write-protection for registers */

    /* Write 1 in AG bit to clear alarm */
    MODULE_SMU.CS.AGCS[alarmGroup].STS.U = (uint32)((uint32)0x1U << alarmPos);

    /* Restore back the write-protection for registers */

    return MODULE_SMU.CS.STS.B.RES;
}


boolean IfxSmu_smuSecurityGetAlarmStatus(IfxSmu_Alarm alarm)
{
    uint16  alarmGroup = ((int)alarm >> 5);
    uint8   alarmPos   = (int)alarm & 0x1F;

    /* Read Alarm status */
    boolean alarmStatus = (boolean)((MODULE_SMU.CS.AGCS[alarmGroup].STS.U >> alarmPos) & 0x1);

    return alarmStatus;
}


IfxSmu_SmuSecurityState IfxSmu_getSmuSecurityState(void)
{
    /* Return SMU state read from DBG register */
    return (IfxSmu_SmuSecurityState)(MODULE_SMU.CS.DBG.B.SSM);
}


void IfxSmu_smuSecurityWaitForAlarm(IfxSmu_Alarm alarm)
{
    while (!IfxSmu_smuSecurityGetAlarmStatus(alarm))
    {}

    IfxSmu_smuSecurityClearAlarmStatus(alarm);
}


void IfxSmu_smuSecurityLockConfigRegisters(void)
{
    /* Check if SMU cfg registers is not locked */
    if (MODULE_SMU.CS.KEYS.B.PERLCK != 0xFFU)
    {
        /* passwd = IfxWtu_getSecurityWatchdogPassword(); */
	/* Register protected by CE (CS_PROTCE) and APU-PCS */
        /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_config);
#endif
        /* Write the key reg to lock config registers */
        MODULE_SMU.CS.KEYS.B.PERLCK = 0xFFU;

        /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_run);
#endif
    }
}


boolean IfxSmu_smuSecurityStopRT(uint8 timerNum)
{
    /* Write CMD for Stop Recovery Timer */
    Ifx_SMU_CS_CMD cmdSfr;
    cmdSfr.U           = MODULE_SMU.CS.CMD.U;
    cmdSfr.B.CMD       = IfxSmu_SecurityCommand_RTstop;
    cmdSfr.B.ARG       = timerNum;
    MODULE_SMU.CS.CMD.U = cmdSfr.U;

    return MODULE_SMU.CS.STS.B.RES;
}


boolean IfxSmu_smuSecurityUnlockConfigRegisters(void)
{
    boolean status = 1U;

    /* Check if SMU cfg registers is not locked */
    if (MODULE_SMU.CS.KEYS.B.PERLCK != 0xFFU)
    {
        /* Register protected by CE (CS_PROTCE) and APU-PCS */
	/* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_config);
#endif
        /*Write Config key to configure the SMU registers. */
        MODULE_SMU.CS.KEYS.U = (uint32)0x000000bc;

        /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_run);
#endif
    }
    else
    {
        /* If SMU config is permanently locked then return false */
        status = 0U;
    }

    return status;
}


void IfxSmu_smuSecurityTemporaryLockConfigRegisters(void)
{
    /* Register protected by CE (CS_PROTCE) and APU-PCS */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_config);
#endif

    /*Write Config key to configure temporary lock of the SMU registers. */
    MODULE_SMU.CS.KEYS.U = 0U;

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_run);
#endif
}


void IfxSmu_clearRegMonTestModeEnable(uint8 regMonIndex, uint8 testModeEnable)
{
    /* register protected by GE (GCC_PROTGE) and APU-PGCC */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_config);
#endif

    MODULE_SMU.GCC.RM[regMonIndex].CTL.U &= ~(1U << testModeEnable);

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_run);
#endif
}


void IfxSmu_clearRegisterMonitorErrorFlag(uint8 regMonIndex, uint8 errorFlag)
{
    /* register protected by GE (GCC_PROTGE) and APU-PGCC */
    /* disable the write-protection for registers */
    #if (IFX_PROT_ENABLED == 1U)
 IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_config);
#endif
    MODULE_SMU.GCC.RM[regMonIndex].EF.U &= ~(1U << errorFlag);
    
    
    /* Restore back the write-protection for registers */
    #if (IFX_PROT_ENABLED == 1U)
 IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_run);
#endif
}


void IfxSmu_clearRegisterMonitorStatus(uint8 regMonIndex, uint8 statusFlag)
{
    /* register protected by GE (GCC_PROTGE) and APU-PGCC */
    /* disable the write-protection for registers */
    #if (IFX_PROT_ENABLED == 1U)
 IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_config);
#endif
    MODULE_SMU.GCC.RM[regMonIndex].STS.U &= ~(1U << statusFlag);
    
    
    /* Restore back the write-protection for registers */
    #if (IFX_PROT_ENABLED == 1U)
 IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_run);
#endif
}


void IfxSmu_enableFaultToRunState(boolean smuIndex, boolean stateType)
{
    /* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_config);
#endif

    /*Enable FAULT to RUN State Transition in Alarm Global Configuration . */
    if (stateType == 0)
    {
        MODULE_SMU.SAFE[smuIndex].AGC.B.EFRST0 = 1;
    }
    else
    {
        MODULE_SMU.SAFE[smuIndex].AGC.B.EFRST1 = 1;
    }

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_run);
#endif
}


void IfxSmu_configAlarmActionPES(boolean smuIndex, IfxSmu_portEmergencyStop pesField, boolean Action)
{
    /*register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_config);
#endif
    /*
     * Port Emergency Stop: enables control of the Port Emergency Stop (PES) feature
     * independently for each internal action. When an action is triggered and if the
     * corresponding bit (as defined below) is set, the hardware triggers
     * automatically a port emergency stop request. Each bit of PES is allocated to
     */
    MODULE_SMU.SAFE[smuIndex].PES.U |= (uint32)(Action << pesField);

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_run);
#endif
}


IfxSmu_InternalAlarmAction IfxSmu_getSafetyAlarmAction(IfxSmu_Alarm alarm, IfxSmu_InternalAlarmAction intAlarmAction, boolean smuIndex)
{
    uint16  alarmGroup = (int)alarm >> 5;
    /* Read Alarm configuration from SMU alarm CFx (x=0-3) registers
     * and align them to combine to get 4 bit value
     */
    intAlarmAction = (IfxSmu_InternalAlarmAction)(MODULE_SMU.SAFE[smuIndex].AGSF[alarmGroup].CON[0].U |
                                                  MODULE_SMU.SAFE[smuIndex].AGSF[alarmGroup].CON[1].U << 1 |
                                                  MODULE_SMU.SAFE[smuIndex].AGSF[alarmGroup].CON[2].U << 2 |
                                                  MODULE_SMU.SAFE[smuIndex].AGSF[alarmGroup].CON[3].U << 3);
    return intAlarmAction;
}


boolean IfxSmu_getSafetyAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus alarmEx, boolean smuIndex)
{
    boolean alarmExecuteStatus = (boolean)((MODULE_SMU.SAFE[smuIndex].AEX.U >> alarmEx) & 0x1);
    return alarmExecuteStatus;
}


uint32 IfxSmu_getSafetyAlarmGroupDebugStatus(uint8 alarmGroup, boolean smuIndex)
{
    uint32 alarmStatus;
    /*
     *   Read the alarm status from SMU_ADx (x: 0..6) register
     */
    alarmStatus = MODULE_SMU.SAFE[smuIndex].AGSF[alarmGroup].DBG.U;
    return alarmStatus;
}


boolean IfxSmu_getSafetyAlarmStatus(IfxSmu_Alarm alarm, boolean smuIndex)
{
    uint16  alarmGroup  = (int)alarm >> 5;
    uint8   alarmPos    = (int)alarm & 0x1F;
    /* Read Alarm status */
    boolean alarmStatus = (boolean)((MODULE_SMU.SAFE[smuIndex].AGSF[alarmGroup].STS.U >> alarmPos) & 0x1);

    return alarmStatus;
}


boolean IfxSmu_getPortControlHwDir(boolean smuIndex, boolean fspIndex)
{
    if (fspIndex == 0)
    {
        return (boolean)MODULE_SMU.SAFE[smuIndex].PCTL.B.HWDIR0;
    }
    else
    {
        return (boolean)MODULE_SMU.SAFE[smuIndex].PCTL.B.HWDIR1;
    }
}


boolean IfxSmu_getPortControlHwEnable(boolean smuIndex, boolean fspIndex)
{
    if (fspIndex == 0)
    {
        return (boolean)MODULE_SMU.SAFE[smuIndex].PCTL.B.HWEN0;
    }
    else
    {
        return (boolean)MODULE_SMU.SAFE[smuIndex].PCTL.B.HWEN1;
    }
}


boolean IfxSmu_getSafetyRTMissedEvent(boolean smuIndex, uint8 timerNum)
{
    boolean timerMissEvent = 0;

    switch (timerNum)
    {
    case 0:
        timerMissEvent = MODULE_SMU.SAFE[smuIndex].STS.B.RTME0;
        break;
    case 1:
        timerMissEvent = MODULE_SMU.SAFE[smuIndex].STS.B.RTME1;
        break;
    default:
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
        break;
    }

    return timerMissEvent;
}


uint32 IfxSmu_getRegisterMonitorErrorFlag(uint8 regMonIndex)
{
    uint32 errorFlags = 0;
    errorFlags = MODULE_SMU.GCC.RM[regMonIndex].EF.U;
    return errorFlags;
}


uint32 IfxSmu_getRegisterMonitorStatus(uint8 regMonIndex)
{
    uint32 selfTestStatus = 0;
    selfTestStatus = MODULE_SMU.GCC.RM[regMonIndex].STS.U;
    return selfTestStatus;
}


boolean IfxSmu_isModuleSuspended(Ifx_SMU* smu)
{
    Ifx_SMU_OCS ocs;

    /* read the status */
    ocs.U = smu->OCS.U;
    
    /* return the status */
    return ocs.B.SUSSTA;
}


void IfxSmu_setFspMode(boolean smuIndex, boolean fspIndex, IfxSmu_FspMode mode)
{
    /* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.SAFE[smuIndex].FSP[fspIndex].CON.B.MODE = mode;

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_run);
#endif
}


boolean IfxSmu_stopSafetyRT(boolean smuIndex, uint8 timerNum)
{
    /* Write CMD for Stop Recovery Timer */
    Ifx_SMU_SAFE_CMD cmdSfr;
    cmdSfr.U                            = MODULE_SMU.SAFE[smuIndex].CMD.U;
    cmdSfr.B.CMD                        = IfxSmu_Command_stopRT;
    cmdSfr.B.ARG                        = timerNum;
    MODULE_SMU.SAFE[smuIndex].CMD.U = cmdSfr.U;

    return MODULE_SMU.SAFE[smuIndex].STS.B.RES;
}


void IfxSmu_safetyConfigureInterruptGeneration(IfxSmu_InterruptGenerationConfiguration config, boolean smuIndex, IfxSmu_InterruptRequest intRequest)
{
    uint8                shift = 0, value = 0;
    uint32               mask  = 0;
    Ifx_SMU_SAFE_AGC agc;

    agc.U = MODULE_SMU.SAFE[smuIndex].AGC.U;
    shift = (config << 2);
    value = (1 << intRequest);
    mask  = ~(7 << shift);
    /* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.SAFE[smuIndex].KEYS.U = (uint32)0x000000bc;

    /* Clear the specific bits */
    agc.U &= mask;

    /* Write into the specific bits */
    agc.U                               |= ((value) << (shift));

    MODULE_SMU.SAFE[smuIndex].AGC.U  = agc.U;

    MODULE_SMU.SAFE[smuIndex].KEYS.U = 0x0U;

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[smuIndex].PROTSE, IfxApProt_State_run);
#endif
}


IfxSmu_SecurityAlarmAction IfxSmu_getSecurityAlarmAction(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup     = ((int)alarm >> 5);
    uint8  intAlarmAction = 0;
    /* Read Alarm configuration from SMU alarm CFx (x=0-2) registers
     * and align them to combine to get 3 bit value
     */

    intAlarmAction = (IfxSmu_SecurityAlarmAction)(MODULE_SMU.CS.AGCS[alarmGroup].CON[0].U |
                                                  MODULE_SMU.CS.AGCS[alarmGroup].CON[1].U << 1 |
                                                  MODULE_SMU.CS.AGCS[alarmGroup].CON[2].U << 2);

    return (IfxSmu_SecurityAlarmAction)intAlarmAction;
}


uint32 IfxSmu_getSecurityAlarmGroupDebugStatus(uint8 alarmGroup)
{
    uint32 alarmStatus;
    /* Read the alarm status from SMU_ADx (x: 0..6) register */
    alarmStatus = MODULE_SMU.CS.AGCS[alarmGroup].DBG.U;
    return alarmStatus;
}


boolean IfxSmu_getSecurityAlarmStatus(IfxSmu_Alarm alarm)
{
    uint16  alarmGroup  = ((int)alarm >> 5);
    uint8   alarmPos    = (int)alarm & 0x1F;
    /* Read Alarm status */
    boolean alarmStatus = (boolean)((MODULE_SMU.CS.AGCS[alarmGroup].STS.U >> alarmPos) & 0x1);

    return alarmStatus;
}


boolean IfxSmu_getSecurityRTMissedEvent(void)
{
    boolean timerMissEvent = 0;

    timerMissEvent = MODULE_SMU.CS.STS.B.RTME0;

    return timerMissEvent;
}


IfxSmu_SmuSecurityState IfxSmu_getSecuritySmuState(void)
{
    /* Return SMU state read from DBG register */
    return (IfxSmu_SmuSecurityState)(MODULE_SMU.CS.DBG.B.SSM);
}


boolean IfxSmu_stopSecurityRT(uint8 timerNum)
{
    /* Write CMD for Stop Recovery Timer */
    Ifx_SMU_CS_CMD cmdSfr;
    cmdSfr.U           = MODULE_SMU.CS.CMD.U;
    cmdSfr.B.CMD       = IfxSmu_Command_stopRT;
    cmdSfr.B.ARG       = timerNum;
    MODULE_SMU.CS.CMD.U = cmdSfr.U;

    return MODULE_SMU.CS.STS.B.RES;
}


void IfxSmu_configureSharedSelectionRegister(IfxSmu_SharedType SharedType, IfxSmu_Alarm alarm)
{
    uint16 alarmGroup = ((int)alarm >> 5);
    uint8  alarmPos   = (int)alarm & 0x1F;

    if (SharedType == IfxSmu_SharedType_safety)
    {
         // register protected by GE (GCC_PROTGE) and APU-PGCC
        /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_config);
#endif

        MODULE_SMU.GCC.AGSH[alarmGroup].SEL.U |= (uint32)(1 << alarmPos);
 /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_run);
#endif

    }
    else
    {
        /* Register protected by CE (CS_PROTCE) and APU-PCS */
        /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_config);
#endif
	/* Provide an ASSERT if the specific alarm is already mapped to safety */
    	IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (((MODULE_SMU.GCC.AGSH[alarmGroup].SEL.U & (uint32)(1 << alarmPos)) >> alarmPos) != 1U));
        MODULE_SMU.CS.AGSH[alarmGroup].SEL.U |= (uint32)(1 << alarmPos);
        /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_run);
#endif
    }
}


boolean IfxSmu_getSharedSelectionStatus(IfxSmu_SharedType SharedType, IfxSmu_Alarm alarm)
{
    uint16  alarmGroup = ((int)alarm >> 5);
    uint8   alarmPos   = (int)alarm & 0x1F;
    boolean result     = 1;

    if (SharedType == IfxSmu_SharedType_safety)
    {
        result = (boolean)((MODULE_SMU.GCC.AGSH[alarmGroup].SS.U & (uint32)(1 << alarmPos)) >> alarmPos);
    }
    else
    {
        result = (boolean)((MODULE_SMU.CS.AGSH[alarmGroup].SS.U & (uint32)(1 << alarmPos)) >> alarmPos);
    }

    return result;
}


void IfxSmu_setSharedSafetyAlarmAction(IfxSmu_Alarm alarm, IfxSmu_InternalAlarmAction intAlarmAction)
{
    uint32 alarmGroupCF2;
    uint32 alarmGroupCF1;
    uint32 alarmGroupCF0;
    uint32 alarmGroupCFMask;
    uint16 alarmGroup = (int)alarm >> 5;
    uint8  alarmPos   = (int)alarm & 0x1F;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.SAFE[0].KEYS.B.PERLCK != 0xFFU));

    /* Get the mask for configuration registers to set the particular
     * bits
     */
    alarmGroupCFMask = ~((uint32)0x1U << alarmPos);

    /* Extract Alarm configuration for 4 CFG registers
     * from input parameter
     */
    alarmGroupCF0 = (intAlarmAction & 0x01) << alarmPos;
    alarmGroupCF1 = ((intAlarmAction >> 1) & 0x01) << alarmPos;
    alarmGroupCF2 = ((intAlarmAction >> 2) & 0x01) << alarmPos;

    /* register protected by SxE (SAFEx_PROTE) and APU-PSAFEx */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[0].PROTSE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.SAFE[0].KEYS.U = (uint32)0x000000bc;

    /* Write Alarm configuration into corresponding
     *   SMU alarm CFx (x=0-3) registers
     */
    MODULE_SMU.SAFE[0].AGSH[alarmGroup].CON[0].U = (MODULE_SMU.SAFE[0].AGSH[alarmGroup].CON[0].U & alarmGroupCFMask) | alarmGroupCF0;
    MODULE_SMU.SAFE[0].AGSH[alarmGroup].CON[1].U = (MODULE_SMU.SAFE[0].AGSH[alarmGroup].CON[1].U & alarmGroupCFMask) | alarmGroupCF1;
    MODULE_SMU.SAFE[0].AGSH[alarmGroup].CON[2].U = (MODULE_SMU.SAFE[0].AGSH[alarmGroup].CON[2].U & alarmGroupCFMask) | alarmGroupCF2;

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.SAFE[0].KEYS.U = 0;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.SAFE[0].PROTSE, IfxApProt_State_run);
#endif
}


boolean IfxSmu_setSharedSafetyAlarmStatus(IfxSmu_Alarm alarm, boolean smuSafeStateMachineId)
{
    uint16          alarmGroup = (int)alarm >> 5;
    uint8           alarmPos   = (int)alarm & 0x1F;
    IfxSmu_SmuState smuState;
    boolean         status     = 0U;

    /* Read the SMU state from module DBG register */
    if (smuSafeStateMachineId == 0)
    {
        smuState = (IfxSmu_SmuState)(MODULE_SMU.SAFE[0].DBG.B.SSM0);
    }
    else
    {
        smuState = (IfxSmu_SmuState)(MODULE_SMU.SAFE[0].DBG.B.SSM1);
    }

    if (smuState == IfxSmu_SmuState_start)
    {
        /* SMU is in START state */
        /* All SMU Groups are allowed to set alarm status */
	/* register protected by APU-PSAFEx register set and not PROT */
        /* Write 1 in AG bit to set alarm */
        MODULE_SMU.SAFE[0].AGSH[alarmGroup].STS.U = ((uint32)0x1U << alarmPos);
    }
    else   /* Alarm is in RUN state or FAULT state */
    {
        /* SW Alarm Group/s are only allowed to set alarm status */
        /* Write SMU_ALARM(ARG), where ARG:alarmPos in CMD register to set the Alarm  */
        Ifx_SMU_SAFE_CMD cmdSfr;
        cmdSfr.U                                = MODULE_SMU.SAFE[0].CMD.U;
        cmdSfr.B.CMD                            = IfxSmu_Command_triggerAlarm;
        cmdSfr.B.ARG                            = alarmPos;
        MODULE_SMU.SAFE[0].CMD.U = cmdSfr.U;
        status                                  = MODULE_SMU.SAFE[0].STS.B.RES;
    }

    return status;
}


void IfxSmu_setSharedSecurityAlarmAction(IfxSmu_Alarm alarm, IfxSmu_SecurityAlarmAction AlarmAction)
{
    uint32 alarmGroupCF2;
    uint32 alarmGroupCF1;
    uint32 alarmGroupCF0;
    uint32 alarmGroupCFMask;
    uint16 alarmGroup = ((int)alarm >> 5);
    uint8  alarmPos   = (int)alarm & 0x1F;
    /* uint16 passwd = IfxWtu_getSecurityWatchdogPassword(); */

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (MODULE_SMU.CS.KEYS.B.PERLCK != 0xFFU));

    /* Get the mask for configuration registers to set the perticular
     * bits
     */
    alarmGroupCFMask = ~((uint32)0x1U << alarmPos);

    /* Extract Alarm configuration for 3 CFG registers
     * from input parameter
     */
    alarmGroupCF0 = (AlarmAction & 0x01) << alarmPos;
    alarmGroupCF1 = ((AlarmAction >> 1) & 0x01) << alarmPos;
    alarmGroupCF2 = ((AlarmAction >> 2) & 0x01) << alarmPos;

    /* Register protected by CE (CS_PROTCE) and APU-PCS */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_config);
#endif

    /*Write Config key to configure the SMU registers. */
    MODULE_SMU.CS.KEYS.U = (uint32)0x000000bc;

    /* Write Alarm configuration into corresponding
     *   SMU alarm CFx (x=0-3) registers
     */
    MODULE_SMU.CS.AGSH[alarmGroup].CON[0].U = (MODULE_SMU.CS.AGSH[alarmGroup].CON[0].U & alarmGroupCFMask) | alarmGroupCF0;
    MODULE_SMU.CS.AGSH[alarmGroup].CON[1].U = (MODULE_SMU.CS.AGSH[alarmGroup].CON[1].U & alarmGroupCFMask) | alarmGroupCF1;
    MODULE_SMU.CS.AGSH[alarmGroup].CON[2].U = (MODULE_SMU.CS.AGSH[alarmGroup].CON[2].U & alarmGroupCFMask) | alarmGroupCF2;

    /* After configuration set temporary lock of SMU configuration */
    MODULE_SMU.CS.KEYS.U = 0;

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.CS.PROTCE, IfxApProt_State_run);
#endif
}


boolean IfxSmu_setSharedSecurityAlaramStatus(IfxSmu_Alarm alarm)
{
    uint16                  alarmGroup = ((int)alarm >> 5);
    uint8                   alarmPos   = (int)alarm & 0x1F;
    IfxSmu_SmuSecurityState smuState;
    boolean                 status     = 0U;

    /* Read the SMU state from module DBG register */
    smuState = (IfxSmu_SmuSecurityState)(MODULE_SMU.CS.DBG.B.SSM);

    if (smuState == IfxSmu_SmuSecurityState_start)
    {
        /* SMU is in START state */
        /* All SMU Groups are allowed to set alarm status */

        /* disable the write-protection for registers */

        /* Write 1 in AG bit to set alarm */
        MODULE_SMU.CS.AGSH[alarmGroup].STS.U = ((uint32)0x1U << alarmPos);

        /* Restore back the write-protection for registers */
    }
    else   /* Alarm is in RUN state or FAULT state */
    {
        /* SW Alarm Group/s are only allowed to set alarm status */
        /* Write SMU_ALARM(ARG), where ARG:alarmPos in CMD register to set the Alarm  */
        Ifx_SMU_CS_CMD cmdSfr;
        cmdSfr.U           = MODULE_SMU.CS.CMD.U;
        cmdSfr.B.CMD       = IfxSmu_SecurityCommand_triggerAlarm;
        cmdSfr.B.ARG       = alarmPos;
        MODULE_SMU.CS.CMD.U = cmdSfr.U;
        status             = MODULE_SMU.CS.STS.B.RES;
    }

    return status;
}


IfxSmu_InternalAlarmAction IfxSmu_getSharedSafetyAlarmAction(IfxSmu_Alarm alarm, IfxSmu_InternalAlarmAction intAlarmAction, boolean smuIndex)
{
    uint16  alarmGroup = (int)alarm >> 5;
    /* Read Alarm configuration from SMU alarm CFx (x=0-3) registers
     * and align them to combine to get 4 bit value
     */
    intAlarmAction = (IfxSmu_InternalAlarmAction)(MODULE_SMU.SAFE[smuIndex].AGSH[alarmGroup].CON[0].U |
                                                  MODULE_SMU.SAFE[smuIndex].AGSH[alarmGroup].CON[1].U << 1 |
                                                  MODULE_SMU.SAFE[smuIndex].AGSH[alarmGroup].CON[2].U << 2 );
    return intAlarmAction;
}


IfxSmu_SecurityAlarmAction IfxSmu_getSharedSecurityAlarmAction(IfxSmu_Alarm alarm)
{
    uint16 alarmGroup     = ((int)alarm >> 5);
    uint8  intAlarmAction = 0;
    /* Read Alarm configuration from SMU alarm CFx (x=0-2) registers
     * and align them to combine to get 3 bit value
     */

    intAlarmAction = (IfxSmu_SecurityAlarmAction)(MODULE_SMU.CS.AGSH[alarmGroup].CON[0].U |
                                                  MODULE_SMU.CS.AGSH[alarmGroup].CON[1].U << 1 |
                                                  MODULE_SMU.CS.AGSH[alarmGroup].CON[2].U << 2);

    return (IfxSmu_SecurityAlarmAction)intAlarmAction;
}


boolean IfxSmu_getSharedAlarmStatus(IfxSmu_SharedType SharedType, IfxSmu_Alarm alarm, boolean smuIndex)
{
    uint16  alarmGroup = ((int)alarm >> 5);
    uint8   alarmPos   = (int)alarm & 0x1F;
    boolean result     = 1;

    /* Read Alarm status */

    if (SharedType == IfxSmu_SharedType_safety)
    {
        result = (boolean)((MODULE_SMU.SAFE[smuIndex].AGSH[alarmGroup].STS.U >> alarmPos) & 0x1);
    }
    else
    {
        result = (boolean)((MODULE_SMU.CS.AGSH[alarmGroup].STS.U >> alarmPos) & 0x1);
    }

    return result;
}


void IfxSmu_smuSharedLockConfigRegisters(void)
{
    /* Check if SMU cfg registers is not locked */
    if (MODULE_SMU.GCC.KEYS.B.PERLCK != 0xFFU)
    {
    /* Register protected by GE (GCC_PROTGE) and APU-PGCC */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_config);
#endif

        /* Write the key reg to lock config registers */
        MODULE_SMU.GCC.KEYS.B.PERLCK = 0xFFU;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_run);
#endif
    }
}


boolean IfxSmu_smuSharedUnlockConfigRegisters(void)
{
    boolean status = 1U;

    /* Check if SMU cfg registers is not locked */
    if (MODULE_SMU.GCC.KEYS.B.PERLCK != 0xFFU)
    {
     /* register protected by GE (GCC_PROTGE) and APU-PGCC */
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_config);
#endif

        /*Write Config key to configure the SMU registers. */
        MODULE_SMU.GCC.KEYS.U = (uint32)0x000000bc;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_run);
#endif
    }
    else
    {
        /* If SMU config is permanently locked then return false */
        status = 0U;
    }

    return status;
}


void IfxSmu_smuSharedTemporaryLockConfigRegisters(void)
{
    /*register protected by GE (GCC_PROTGE) and APU-PGCC */
    /* disable the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_config);
#endif

    /*Write Config key to configure temporary lock of the SMU registers. */
    MODULE_SMU.GCC.KEYS.U = 0U;

    /* Restore back the write-protection for registers */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMU.GCC.PROTGE, IfxApProt_State_run);
#endif
}


void IfxSmu_configureAccessToGlobalConfigurationSmu(IfxApApu_ApuConfig* apConfig)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_SMU.GCC.ACCEN, apConfig);
}


void IfxSmu_configureAccessToSecuritySmu(IfxApApu_ApuConfig* apConfig)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_SMU.CS.ACCEN, apConfig);
}


void IfxSmu_configureAccessToSafetySmu(IfxApApu_ApuConfig* apConfig)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_SMU.SAFE[0].ACCEN, apConfig);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_SMU.SAFE[1].ACCEN, apConfig);
}

