/**
 * \file IfxSmmRst.c
 * \brief SMM  basic functionality
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxSmmRst.h"

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to get counter and divider value from time period
 * \param timeInNs Time duration in Nanoseconds
 * \param clockDivider Address to store calculated clock divider value
 * \param counter Address to store calculated counter
 * \return None
 */
IFX_INLINE void IfxSmmRst_calculateDivAndCntValue(uint32 timeInNs, uint8 *clockDivider, uint16 *counter);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxSmmRst_calculateDivAndCntValue(uint32 timeInNs, uint8 *clockDivider, uint16 *counter)
{
    uint32  power = 1U;
    uint8   index, powIndex;
    float32 minCalTime, maxCalTime;

    /* Loop through possible divider to check if required time could be achieved with the divider settings */
    for (index = 0; index < 16U; index++)
    {
        powIndex = index;

        while (powIndex != 0)
        {
            power *= 2U;
            powIndex--;
        }

        minCalTime = ((power / IFXSMMRST_RESET_COUNTER_BASE_CLOCK) * IFXSMMRST_TIME_IN_NS);
        maxCalTime = (minCalTime * IFXSMMRST_RESET_COUNTER_MAX_VALUE);

        /* Break if the requested time could be achieved with the divider settings */
        if ((timeInNs > (uint32)minCalTime) && (timeInNs < (uint32)maxCalTime))
        {
            break;
        }
        else
        {
            power = 1U;
        }
    }

    /* Store calculated value */
    *counter      = (uint16)(timeInNs / minCalTime);
    *clockDivider = index;
}


/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxSmmRst_evaluateReset(IfxSmmRst_Reset *reset)
{
    Ifx_SMM_WRMRSTTRIGH wrmRstTrigH;        /*highest warm reset event*/
    Ifx_SMM_WRMRSTTRIG  wrmRstTrig;         /*Warm reset trigger*/
    Ifx_SMM_RSTSTATH    rstStatH;           /*Highest reset status type*/
    Ifx_SMM_RSTSTAT     rstStat;            /*Accumulated reset status*/
    Ifx_PMS_CLDRSTRIGL  cldRstTrigL;        /*Last cold reset trigger*/
    Ifx_PMS_CLDRSTSTAT  cldRstStat;         /*Cold reset status*/
    Ifx_PMS_CLDRSTRIG   cldRstTrig;         /*cold reset event*/
    uint8               index = 0;
    reset->highestResetType      = IfxSmmRst_ResetType_undefined;
    reset->highestWarmRstTrigger = IfxSmmRst_WarmRstTrigger_undefined;
    reset->lastColdRstTrigger    = IfxSmmRst_ColdResetTrigger_undefined;

    /* Reading register */
    wrmRstTrigH.U = SMM_WRMRSTTRIGH.U;
    wrmRstTrig.U  = SMM_WRMRSTTRIG.U;
    rstStatH.U    = SMM_RSTSTATH.U;
    rstStat.U     = SMM_RSTSTAT.U;
    cldRstTrig.U  = PMS_CLDRSTRIG.U;
    cldRstTrigL.U = PMS_CLDRSTRIGL.U;
    cldRstStat.U  = PMS_CLDRSTSTAT.U;

    /* To check for safe state*/
    reset->cpuSafeState = (((SMM_SHSEQCTRLD.U >> IFX_SMM_SHSEQCTRLD_CSSX_OFF) & IFX_SMM_SHSEQCTRLD_CSSX_MSK) == IFX_SMM_SHSEQCTRLD_CSSX_MSK);

    /*Update accumulated reset type since last clear */
    reset->resetStatus.U = rstStat.U;

    /* Update highest reset type */
    for (index = 0; index < 32; index++)
    {
        if (rstStatH.U & (1 << index))
        {
            reset->highestResetType = (IfxSmmRst_ResetType)index;
            break;
        }
    }

    /* Accumulated trigger for the last reset type*/
    reset->warmRstTrigger.U = wrmRstTrig.U;

    /* Update reset trigger of Highest reset type*/
    for (index = 0; index < 32; index++)
    {
        if (wrmRstTrigH.U & (1 << index))
        {
            reset->highestWarmRstTrigger = (IfxSmmRst_WarmRstTrigger)index;
            break;
        }
    }

    /* Cold Reset status*/
    reset->coldResetStatus.U = cldRstStat.U;

    /* Update accumulated cold reset trigger*/
    reset->coldResetTrigger.U = cldRstTrig.U;

    /*Update last cold reset trigger */
    for (index = 0; index < 32; index++)
    {
        if (cldRstTrigL.U & (1 << index))
        {
            reset->lastColdRstTrigger = (IfxSmmRst_ColdResetTrigger)index;
            break;
        }
    }
}


void IfxSmmRst_performReset(const IfxSmmRst_TriggerRstCfgType rstCfgType, const uint16 userResetInfo)
{
    uint32 index;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

    /* Write the Reset Type - Application or System or Module Reset or Module group Reset */
    SMM_RSTTRIGCTRLA.B.SW = rstCfgType;

    /* Write the user DATA to reset evaluation */
    SMM_USRINFO.B.USRINFO = userResetInfo;

    /* software Reset can be performed by writing to Reset Request register  SWRSTCON */
    SMM_SWRSTCON.B.SWRSTREQ = 1U;

    /* Add some delay for HW to reset */
    for (index = 0U; index < (uint32)IFXSMMRST_PERFORM_RESET_DELAY; index++)
    {}

    /* Setting the PROT state back to RUN is not needed, as the micro would RESET */
}


void IfxSmmRst_getSmuSafeRstTrigger(IfxSmmRst_SmuSafeRstTrigger *safeTrigger, boolean smuSafeIndex)
{
    Ifx_SMM_SMURSTSTATA smuRSTA;
    Ifx_SMM_SMURSTSTATB smuRSTB;

    if (smuSafeIndex)
    {
        /* If SAFE1 read the SAFE1 status register */
        smuRSTB.U                   = SMM_SMURSTSTATB.U;

        safeTrigger->safe1AlmGrp[0] = smuRSTB.B.SMU1ALMGRP0;
        safeTrigger->safe1AlmId[0]  = smuRSTB.B.SMU1ALMID0;
        safeTrigger->safe1AlmGrp[1] = smuRSTB.B.SMU1ALRMGRP1;
        safeTrigger->safe1AlmId[1]  = smuRSTB.B.SMU1ALRMID1;
    }
    else
    {
        /* If SAFE0 read the SAFE0 status register */
        smuRSTA.U                   = SMM_SMURSTSTATA.U;

        safeTrigger->safe0AlmGrp[0] = smuRSTA.B.SMU0ALMGRP0;
        safeTrigger->safe0AlmId[0]  = smuRSTA.B.SMU0ALMID0;
        safeTrigger->safe0AlmGrp[1] = smuRSTA.B.SMU0ALMGRP0;
        safeTrigger->safe0AlmId[1]  = smuRSTA.B.SMU0ALMID0;
    }
}


void IfxSmmRst_getSmuSecureRstTrigger(IfxSmmRst_SmuSecureRstTrigger *secureTrigger)
{
    Ifx_SMM_SMURSTSTATB smuRSTB;

    if (secureTrigger != NULL_PTR)
    {
        /* Read the RSTB status register */
        smuRSTB.U                   = SMM_SMURSTSTATB.U;

        secureTrigger->secureAlmGrp = smuRSTB.B.SMUSECALMGRP;
        secureTrigger->secureAlmId  = smuRSTB.B.SMUSECALMID;
    }
}


void IfxSmmRst_configureEsr0ElongationTime(IfxSmmRst_Esr0RstOutputRelease esrBehaviour, uint32 timeInNs)
{
    uint8               clkDiv;
    uint16              counter;
    Ifx_SMM_ESR0CNTCTRL esr0ctrl;

    /* Reading register */
    esr0ctrl.U = SMM_ESR0CNTCTRL.U;

    /* Non zero value */
    if (timeInNs)
    {
        IfxSmmRst_calculateDivAndCntValue(timeInNs, &clkDiv, &counter);
        esr0ctrl.B.CLKDIV  = clkDiv;
        esr0ctrl.B.RSTECNT = counter;
        esr0ctrl.B.RSTCON  = esrBehaviour;
    }

    /* Writing register back */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
    SMM_ESR0CNTCTRL.U = esr0ctrl.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


void IfxSmmRst_configureEsr2ElongationTime(uint32 timeInNs)
{
    uint8               clkDiv;
    uint16              counter;
    Ifx_PMS_PAD_ESR2CON esr2con;

    /* Reading register */
    esr2con.U = PMS_PAD_ESR2CON.U;

    /* Non zero value */
    if (timeInNs)
    {
        IfxSmmRst_calculateDivAndCntValue(timeInNs, &clkDiv, &counter);
        esr2con.B.CLKDIV  = clkDiv;
        esr2con.B.RSTECNT = counter;
    }

    /* Writing register back */
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_config);
#endif
    PMS_PAD_ESR2CON.U = esr2con.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_run);
#endif
}


void IfxSmmRst_initConfig(IfxSmmRst_Config *resetCfg)
{
    // initialize all to default values
    const IfxSmmRst_Config defaultResetConfig = {
        .esr0Cfg                       = {
            .inputCfg                  = {
                .edge             = IfxSmmRst_EdgeTrigger_fallingEdge,
                .filter           = IfxSmmRst_EsrDigitalFilter_bypassed,
                .clkDiv           = IfxSmmRst_EsrCounterClock_fback,
                .eventSel         = TRUE,
                .rstPulseCmpValue = 0u,
            },
            .rstRelease     = IfxSmmRst_Esr0RstOutputRelease_esr0ElongatedByTime,
            .portMode       = IfxSmm_PortMode_outputOpenDrainAlt8,
            .padDriver      = IfxPort_PadDriver_ttlSpeed1,
            .rstElongTimeNs = 0u
        },
        .esr1Cfg                       = {
            .inputCfg                  = {
                .edge             = IfxSmmRst_EdgeTrigger_fallingEdge,
                .filter           = IfxSmmRst_EsrDigitalFilter_bypassed,
                .clkDiv           = IfxSmmRst_EsrCounterClock_fback,
                .eventSel         = TRUE,
                .rstPulseCmpValue = 0u,
            },
            .portMode  = IfxSmm_PortMode_inputPullUp,
            .padDriver = IfxPort_PadDriver_ttlSpeed1
        },
        .esr2Cfg                       = {
            .inputCfg                  = {
                .edge             = IfxSmmRst_EdgeTrigger_fallingEdge,
                .filter           = IfxSmmRst_EsrDigitalFilter_bypassed,
                .clkDiv           = IfxSmmRst_EsrCounterClock_fback,
                .eventSel         = TRUE,
                .rstPulseCmpValue = 0u,
            },
            .enableRstElongInWarmPorst = FALSE,
            .enableRstElongInAppRst    = FALSE,
            .rstElongTimeNs            = 0u
        },
        .rstTrigCfg                    = {
            .esr0       = IfxSmmRst_TriggerRstCfgType_noReset,
            .esr1       = IfxSmmRst_TriggerRstCfgType_noReset,
            .esr2       = IfxSmmRst_TriggerRstCfgType_noReset,
            .smuSafe0Ar = IfxSmmRst_TriggerRstCfgType_noReset,
            .smuSafe0Sr = IfxSmmRst_TriggerRstCfgType_noReset,
            .smuSafe1Ar = IfxSmmRst_TriggerRstCfgType_noReset,
            .smuSafe1Sr = IfxSmmRst_TriggerRstCfgType_noReset,
            .software   = IfxSmmRst_TriggerRstCfgType_noReset,
            .stm0       = IfxSmmRst_TriggerRstCfgType_noReset,
            .stm1       = IfxSmmRst_TriggerRstCfgType_noReset,
            .stm2       = IfxSmmRst_TriggerRstCfgType_noReset,
            .stm3       = IfxSmmRst_TriggerRstCfgType_noReset,
            .stm4       = IfxSmmRst_TriggerRstCfgType_noReset,
            .stm5       = IfxSmmRst_TriggerRstCfgType_noReset,
            .padRst     = FALSE,
            .phyRst     = FALSE
        },
    };

    *resetCfg = defaultResetConfig;
}


void IfxSmmRst_init(IfxSmmRst_Config *resetCfg)
{
    IfxSmmRst_ResetTrigConfig *rstTrigCfgPtr = &(resetCfg->rstTrigCfg);
    IfxSmmRst_Esr0Config      *esr0CfgPtr    = &(resetCfg->esr0Cfg);
    IfxSmmRst_Esr1Config      *esr1CfgPtr    = &(resetCfg->esr1Cfg);
    IfxSmmRst_Esr2Config      *esr2CfgPtr    = &(resetCfg->esr2Cfg);
    Ifx_SMM_ESRCFG             esrCfg0, esrCfg1, esrCfg2;
    Ifx_SMM_ESR0CNTCTRL        esr0CntCtrl;
    Ifx_PMS_PAD_ESR2CON        esr2con;
    Ifx_SMM_RSTTRIGCTRLA       rstCona;
    Ifx_SMM_RSTTRIGCTRLB       rstConb;
    Ifx_SMM_PDISC              pdisc;
    uint8                      clockDiv   = 0u;
    uint16                     counter    = 0u;
    uint32                     esr0PadCfg = 0u, esr1PadCfg = 0u;

    /* Reading register */
    esrCfg0.U = SMM_ESRCFG0.U;
    esrCfg1.U = SMM_ESRCFG1.U;
    esrCfg2.U = SMM_ESRCFG2.U;

    {
        /* ESR0 input configuration */
        esrCfg0.B.EDCON = esr0CfgPtr->inputCfg.edge;
        esrCfg0.B.DFEN  = esr0CfgPtr->inputCfg.filter;

        IfxSmmRst_calculateDivAndCntValue(esr0CfgPtr->rstElongTimeNs, &clockDiv, &counter);
        /* ESR0 reset elongation configuration */
        esr0CntCtrl.B.CLKDIV  = clockDiv;
        esr0CntCtrl.B.RSTECNT = counter;
        esr0CntCtrl.B.RSTCON  = esr0CfgPtr->rstRelease;

        /* ESR0 pad configuration */
        esr0PadCfg = (((((resetCfg->esr0Cfg.padDriver & 0x38U) << IFXSMMRST_DRVCFG_PL_OFF) | (resetCfg->esr0Cfg.padDriver & 0x7U)) << IFX_P_PADCFG_DRVCFG_PD_OFF) | \
                      (resetCfg->esr0Cfg.portMode));

        pdisc.B.PDIS0 = 0u;
    }

    /*ESR1 configuration */
    {
        /* ESR1 input configuration */
        esrCfg1.B.EDCON = esr1CfgPtr->inputCfg.edge;
        esrCfg1.B.DFEN  = esr1CfgPtr->inputCfg.filter;

        /* ESR1 pad configuration */
        esr1PadCfg = (((((resetCfg->esr1Cfg.padDriver & 0x38U) << IFXSMMRST_DRVCFG_PL_OFF) | (resetCfg->esr1Cfg.padDriver & 0x7U)) << IFX_P_PADCFG_DRVCFG_PD_OFF) | \
                      (resetCfg->esr1Cfg.portMode));

        pdisc.B.PDIS1 = 0u;
    }

    /*ESR2 configuration */
    {
        /* ESR2 input configuration */
        esrCfg2.B.EDCON = esr2CfgPtr->inputCfg.edge;
        esrCfg2.B.DFEN  = esr2CfgPtr->inputCfg.filter;

        IfxSmmRst_calculateDivAndCntValue(esr2CfgPtr->rstElongTimeNs, &clockDiv, &counter);
        esr2con.B.CLKDIV    = clockDiv;
        esr2con.B.RSTECNT   = counter;
        esr2con.B.ESR2ROEN  = resetCfg->esr2Cfg.enableRstElongInWarmPorst;
        esr2con.B.ESR2ROAPP = resetCfg->esr2Cfg.enableRstElongInAppRst;
    }

    /* Reset trigger configuration */
    {
        rstCona.U = (rstTrigCfgPtr->esr0) | (rstTrigCfgPtr->esr1 << IFX_SMM_RSTTRIGCTRLA_ESR1_OFF) | (rstTrigCfgPtr->esr2 << IFX_SMM_RSTTRIGCTRLA_ESR2_OFF) | \
                    (rstTrigCfgPtr->smuSafe0Ar << IFX_SMM_RSTTRIGCTRLA_SMUSAFE0AR_OFF) | (rstTrigCfgPtr->smuSafe0Sr << IFX_SMM_RSTTRIGCTRLA_SMUSAFE0SR_OFF) | \
                    (rstTrigCfgPtr->smuSafe1Ar << IFX_SMM_RSTTRIGCTRLA_SMUSAFE1AR_OFF) | (rstTrigCfgPtr->smuSafe1Sr << IFX_SMM_RSTTRIGCTRLA_SMUSAFE1SR_OFF) | \
                    (rstTrigCfgPtr->software << IFX_SMM_RSTTRIGCTRLA_SW_OFF) |                                                                                \
                    (rstTrigCfgPtr->padRst << IFX_SMM_RSTTRIGCTRLA_PINRST_OFF) | (rstTrigCfgPtr->phyRst << IFX_SMM_RSTTRIGCTRLA_PHYRST_OFF);

        rstConb.U = (rstTrigCfgPtr->stm0) | (rstTrigCfgPtr->stm1 << IFX_SMM_RSTTRIGCTRLB_STM1_OFF) | (rstTrigCfgPtr->stm2 << IFX_SMM_RSTTRIGCTRLB_STM2_OFF) | \
                    (rstTrigCfgPtr->stm3 << IFX_SMM_RSTTRIGCTRLB_STM3_OFF) | (rstTrigCfgPtr->stm4 << IFX_SMM_RSTTRIGCTRLB_STM4_OFF) |                         \
                    (rstTrigCfgPtr->stm5 << IFX_SMM_RSTTRIGCTRLB_STM5_OFF);
    }
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_config);
#endif
    /* Writing register back */
    SMM_RSTTRIGCTRLA.U = rstCona.U;
    SMM_RSTTRIGCTRLB.U = rstConb.U;

    if (SMM_ESRCFG0.B.CNTLCK != 1u)
    {
        esrCfg0.B.CLKDIV   = esr0CfgPtr->inputCfg.clkDiv;
        esrCfg0.B.GL       = esr0CfgPtr->inputCfg.eventSel;
        esrCfg0.B.RSTDELAY = esr0CfgPtr->inputCfg.rstPulseCmpValue;
        esrCfg0.B.CNTLCK   = 1u;
    }

    SMM_ESRCFG0.U     = esrCfg0.U;
    SMM_ESR0CNTCTRL.U = esr0CntCtrl.U;
    SMM_DRVCFGESR0.U  = esr0PadCfg;

    if (SMM_ESRCFG1.B.CNTLCK != 1u)
    {
        esrCfg1.B.CLKDIV   = esr1CfgPtr->inputCfg.clkDiv;
        esrCfg1.B.GL       = esr1CfgPtr->inputCfg.eventSel;
        esrCfg1.B.RSTDELAY = esr1CfgPtr->inputCfg.rstPulseCmpValue;
        esrCfg1.B.CNTLCK   = 1u;
    }

    SMM_ESRCFG1.U    = esrCfg1.U;
    SMM_DRVCFGESR1.U = esr1PadCfg;

    if (SMM_ESRCFG2.B.CNTLCK != 1u)
    {
        esrCfg2.B.CLKDIV   = esr2CfgPtr->inputCfg.clkDiv;
        esrCfg2.B.GL       = esr2CfgPtr->inputCfg.eventSel;
        esrCfg2.B.RSTDELAY = esr2CfgPtr->inputCfg.rstPulseCmpValue;
        esrCfg2.B.CNTLCK   = 1u;
    }

    SMM_ESRCFG2.U     = esrCfg2.U;
    SMM_PDISC.U       = pdisc.U;
    PMS_PAD_ESR2CON.U = esr2con.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_run);
#endif
}
