/**
 * \file IfxSrc.h
 * \brief SRC  basic functionality
 * \ingroup IfxLld_Src
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Src SRC
 * \addtogroup IfxLld_Src
 * \{
 * \defgroup IfxLld_Src_Usage How to use Service Request Mechanism?
 * \addtogroup IfxLld_Src_Usage
 * \{
 *
 * For Aurix controller peripherals that can generate service requests is connected to one
 * or more Service Request Nodes (SRNs) in the central Interrupt Router(IR) module. Refer to Controller User Manual for more details\n
 *
 * IfxSrc driver provides the APIs to configure and control service requests. Refer \ref IfxLld_Src_Usage for
 * details of these APIs.
 *
 *
 * \section Ifx_Src_UsageInit Initialize the Service Request Node
 *
 * Service request node is initialized to configure the following,\n
 * 1) Route the interrupt trigger to service provider, which are:\n
 *  __a. One of the available CPUs or\n
 *  __b. DMA controller\n
 *  __c. CSRM controller\n
 *  __d. PPU\n
 *
 * 2) Priority of CPU Interrupt or DMA Trigger.
 *
 * For Interrupt or DMA to be correctly triggered, following steps are to be done in the user code:
 *
 * \subsection Ifx_Src_UsageInitStep1 Step1: Configure the Node
 *
 * User must configure the service request node in the application / driver files.
 *
 * \subsection Ifx_Src_UsageInitStep2 Step2: Enable the Trigger
 *
 * Enable the service request node to connect the trigger event from the hardware to service provider.
 *
 * Example:
 * Following example show the configuration for STM0 Service request 0 trigger configured to trigger
 * CPU1 with the priority specified by IFX_INTPRIO_STM0 (from the example at IfxCpu_Irq)
 *
 * \code
 * //file: myApplication.c
 *
 * #include "Ifx_IntPrioDef.h" // to get the priority numbers
 *
 * void myDriverInitFunction(void)
 * {
 *    // driver init code
 *
 *    // Step1: Call the function to route the trigger from for SRC_STM0_SR0 to CPU1
 *    // and priority specified at Ifx_IntPrioDef.h globally
 *    IfxSrc_init(&MODULE_SRC.STM[0].SR[0], IfxSrc_Tos_cpu1, IFX_INTPRIO_STM0);
 *
 *    // Step2: Enable the service request node
 *    IfxSrc_enable(&MODULE_SRC.STM.STM[0].SR[0]);
 * }
 * \endcode
 *
 * \}
 * \}
 *
 * \defgroup IfxLld_Src_Std_Service_Request Service Request Functions
 * \ingroup IfxLld_Src_Std
 * \defgroup IfxLld_Src_Std_Module Module Functions
 * \ingroup IfxLld_Src_Std
 */

#ifndef IFXSRC_H
#define IFXSRC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxSrc_cfg.h"
#if !defined(IFX_ILLD_PPU_USAGE)
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#endif
#if defined(IFX_ILLD_PPU_USAGE)
#include "Cpu/Std/IfxPpu_Intrinsics.h"
#endif
#include "IfxSrc_reg.h"
#include "IfxInt_reg.h"
#if !defined(IFX_ILLD_PPU_USAGE)
#include "Cpu/Std/IfxCpu.h"
#endif
#include "Ap/Std/IfxApApu.h"
#include "Ap/Std/IfxApProt.h"

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief OCDS Trigger Bus Interface Selection
 */
typedef enum
{
    IfxSrc_OtgbBusSel_otgb0 = 0,  /**< \brief TriggerSet is output on OTGB0 */
    IfxSrc_OtgbBusSel_otgb1 = 1   /**< \brief TriggerSet is output on OTGB1 */
} IfxSrc_OtgbBusSel;

/** \brief SRN index for interrupt triggers
 */
typedef enum
{
    IfxSrc_OtgbSrnIndex_srnIndex0 = 0,  /**< \brief SRN index for interrupt trigger-0 */
    IfxSrc_OtgbSrnIndex_srnIndex1 = 1,  /**< \brief SRN index for interrupt trigger-1 */
    IfxSrc_OtgbSrnIndex_srnIndex2 = 2,  /**< \brief SRN index for interrupt trigger-2 */
    IfxSrc_OtgbSrnIndex_srnIndex3 = 3   /**< \brief SRN index for interrupt trigger-3 */
} IfxSrc_OtgbSrnIndex;

/** \brief TriggerSet Selection availbale in IR.
 */
typedef enum
{
    IfxSrc_TrigSet_none = 0,  /**< \brief No TriggerSet Selected */
    IfxSrc_TrigSet_is   = 1,  /**< \brief TriggerSet 1 : TS16_IS Interrupt Selection selected */
    IfxSrc_TrigSet_spa  = 2,  /**< \brief TriggerSet 2 : TS16_SPA Service Provider Activity selected */
    IfxSrc_TrigSet_sp   = 3   /**< \brief TriggerSet 3 : TS16_SP Service Provider selected */
} IfxSrc_TrigSet;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief SRN index Values corresponding to each SRN index
 */
typedef struct
{
    uint16 srnIndexVal0;       /**< \brief SRN index value for interrupt trigger-0 */
    uint16 srnIndexVal1;       /**< \brief SRN index Value for interrupt trigger-1 */
    uint16 srnIndexVal2;       /**< \brief SRN index Value for interrupt trigger-2 */
    uint16 srnIndexVal3;       /**< \brief SRN index Value for interrupt trigger-3 */
} IfxSrc_OtgbSrnIndexVal;

/** \brief Configuration for Service Provider trigger Set
 */
typedef struct
{
    boolean    bus0Enable;       /**< \brief OTGB0 enable/disable */
    boolean    bus1Enable;       /**< \brief OTGB1 enable/diable */
    IfxSrc_Tos tos0;             /**< \brief type of  service (TOS)-0 for service provider tiggerSet */
    IfxSrc_Tos tos1;             /**< \brief type of service(TOS)-1 for service provider triggerSet */
} IfxSrc_spConfig;

/** \brief OTGB configuration parameters for all trigger sets
 */
typedef struct
{
    IfxSrc_TrigSet         trigger;           /**< \brief Trigger Set Selection */
    IfxSrc_OtgbBusSel      busSelect;         /**< \brief bus Selction for the selected trigger Set */
    IfxSrc_OtgbSrnIndexVal srnIndexVal;       /**< \brief SRN index value for corressponding SRN index */
    IfxSrc_spConfig        spConfig;          /**< \brief Service Provider triggerSet configuration */
} IfxSrc_OtgbConfig;

/** \addtogroup IfxLld_Src_Std_Service_Request
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Resets the overrun flag of the Service Request.
 * \param src pointer to the Service Request Control register which the overrun flag should be cleared.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_clearOverrun(volatile Ifx_SRC_SRCR *src);

/** \brief Resets a specific interrupt service by software.
 * \param src pointer to the Service Request Control register which the request should be cleared.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src);

/** \brief Gets the current overrun status.
 * \param src pointer to the Service Request Control register for which the overrun status should be returned.
 * \return current service request control overrun status.
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE boolean IfxSrc_isOverrun(volatile Ifx_SRC_SRCR *src);

/** \brief Gets the current request status.
 * \param src pointer to the Service Request Control register for which the request status should be returned.
 * \return current service request control request status.
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE boolean IfxSrc_isRequested(volatile Ifx_SRC_SRCR *src);

/** \brief Requests a specific interrupt service by software
 * \param src pointer to the Service Request Control register which the interrupt has to be requested.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_setRequest(volatile Ifx_SRC_SRCR *src);

/** \brief Get the ECC error status.
 * \param intr pointer to the Interrupt Control Unit register for which the ECC error status should be returned.
 * \param typeOfService type of interrupt service provider.[Interrupt Control Unit mapped to type of service provider]
 * \return current interrupt control unit ECC error status.
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE boolean IfxSrc_getEccError(volatile Ifx_INT *intr, IfxSrc_Tos typeOfService);

/** \brief Clear the ECC error status flag.
 * \param intr pointer to the Interrupt Control Unit register for which the ECC error flag should be cleared.
 * \param typeOfService type of interrupt service provider.[Interrupt Control Unit mapped to type of service provider]
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_clearEccError(volatile Ifx_INT *intr, IfxSrc_Tos typeOfService);

/** \brief Enables a specific interrupt line service request in broadcast interrupt group.
 * \param intr pointer to the Service Request Broadcast register for which the interrupt line has to be enabled.
 * \param groupNum Service request broadcast group in which interrupt line should be enabled.
 * \param interruptLine Specific interrupt line number in service request broadcast group.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_enableBroadcastInterruptLine(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interruptLine);

/** \brief Disables a specific interrupt line service request in broadcast interrupt group.
 * \param intr pointer to the Service Request Broadcast register for which the interrupt line has to be disabled.
 * \param groupNum Service request broadcast group in which interrupt line should be disabled.
 * \param interruptLine Specific interrupt line number in service request broadcast group.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_disableBroadcastInterruptLine(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interruptLine);

/** \brief Trigger a specific interrupt line in service request broadcast group by software
 * \param intr pointer to the Service Request Broadcast register for which the interrupt line has to be triggered.
 * \param groupNum Service request broadcast group in which interrupt line should be triggered.
 * \param interruptLine Specific interrupt line number in service request broadcast group.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_triggerBroadcastinterruptLine(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interruptLine);

/** \brief Trigger interrupts in service request broadcast group by software
 * \param intr pointer to the Service Request Broadcast register for which the interrupts has to be triggered.
 * \param groupNum Service request broadcast group in which interrupts should be triggered.
 * \param interrupts Number of Interrupts in service request broadcast group.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_triggerBroadcastinterrupts(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interrupts);

/** \} */

/** \addtogroup IfxLld_Src_Std_Module
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief DeInitializes the service request control register.
 * Resets the TOS to F.
 * \param src pointer to the Service Request Control register which should be deinitialised.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_deinit(volatile Ifx_SRC_SRCR *src);

/** \brief Disables a specific interrupt service request.
 * \param src pointer to the Service Request Control register for which the interrupt has to be disabled.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_disable(volatile Ifx_SRC_SRCR *src);

/** \brief Enables a specific interrupt service request.
 * \param src pointer to the Service Request Control register for which the interrupt has to be enabled.
 * \return None
 *
 * Usage example: see \ref IfxSrc_init
 *
 */
IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src);

/** \brief Initializes the service request control register.
 * Note: In case Virtualization is disabled VM Number is always written with zero.
 * Note: In case of re-initialization, use IfxSrc_deinit to reset the TOS to F.
 * \param src pointer to the Service Request Control register which should be initialised.
 * \param typOfService type of interrupt service provider.
 * \param priority Interrupt priority.
 * \param vmNumber The Virtual Machine which is going to be the interrupt service provider.
 * \return None
 *
 * Get the peripheral service control register which request need to be serviced and assign this service to any of service providers.
 * \code
 * //define the interrupt priority
 * #define IFXASCLIN0_TX_INTPRIO 2
 * //get the service request
 * volatile Ifx_SRC_SRCR *src = IfxAsclin_getSrcPointerRx( &MODULE_ASCLIN0 );
 * //initlaise the service request
 * IfxSrc_init( src, IfxSrc_Tos_cpu0, IFXASCLIN0_TX_INTPRIO, IfxSrc_Vmc_0);
 * // enable the service
 * IfxSrc_enable( src );
 * //check for service request flags and clear if they occur
 * if ( IfxSrc_isRequested( src ) == TRUE )
 * {
 *    IfxSrc_clearRequest( src );
 * }
 * if ( IfxSrc_isOverrun( src ) == TRUE )
 * {
 *      IfxSrc_clearOverrun( src );
 * }
 * // Atlast deinitialise the service control
 * IfxSrc_deinit( src );
 * \endcode
 *
 */
IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority, IfxSrc_VmId vmNumber);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Used to select the type of OTGB trigger Set
 * \param intr points to the OTGB OCS register
 * \param triggerSelection type of triggerSet chosen
 * \return None
 */
IFX_INLINE void IfxSrc_configOtgbTriggerSet(volatile Ifx_INT *intr, IfxSrc_TrigSet triggerSelection);

/** \brief Used to select the OTGB Bus for the selected triggerSet
 * \param intr points to the OTGB OCS regoster
 * \param busSelection : bus chosen for the trigger selected
 * \return None
 */
IFX_INLINE void IfxSrc_configOtgbBusSelect(volatile Ifx_INT *intr, IfxSrc_OtgbBusSel busSelection);

/** \brief configure GPSR[x].DATA
 * \param src GPSRGxSRy pointer
 * \param data unsigned 16-bit data
 * \return None
 */
IFX_INLINE void IfxSrc_updateGpsrData(volatile Ifx_INT_GPSRG_SWC *src, uint16 data);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Used to select only one SRN index and corressponding SRN index Value
 * \param intr points to OTGB OIX register
 * \param srnIndex SRN index passed by the user
 * \param srnIndexVal value corressponding to the srnIndex
 * \return None
 */
IFX_EXTERN void IfxSrc_setOtgbSrnIndex(volatile Ifx_INT *intr, IfxSrc_OtgbSrnIndex srnIndex, IfxSrc_OtgbSrnIndexVal *srnIndexVal);

/** \brief Used to configure the selected triggerSet.
 * 1. for IS triggerSet  , 4 SRN are configured according to the input provided by the user.
 * 2. for SP triggerSet , sp config provided by the user is configured.
 * 3.for SPA triggerSet , no additional configuration required.
 * \param intr ICU module pointer
 * \param OtgbConfig Configuration for all the triggerSets
 * \return None
 */
IFX_EXTERN void IfxSrc_initOtgb(volatile Ifx_INT *intr, IfxSrc_OtgbConfig *OtgbConfig);

/** \brief default configuration for all the trigger Sets
 * \param OtgbConfig Configuration param passed to congure all three trigger Sets
 * \return None
 */
IFX_EXTERN void IfxSrc_initOtgbConfig(IfxSrc_OtgbConfig *OtgbConfig);

/** \brief Used for configuration of SP trigger Set
 * \param intr points to OTGB OIT register
 * \param spConfig service provider configuration struct object
 * \return None
 */
IFX_EXTERN void IfxSrc_configOtgbServiceProviderTrigger(volatile Ifx_INT *intr, IfxSrc_spConfig *spConfig);

/** \brief Configures access to all masters to all the ICUs in the device
 * \param apConfig config pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxSrc_configureAccessToSrcs(IfxApApu_ApuConfig *apConfig);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxSrc_clearOverrun(volatile Ifx_SRC_SRCR *src)
{
    src->B.IOVCLR = 1;
}


IFX_INLINE void IfxSrc_clearRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.CLRR = 1;
}


IFX_INLINE void IfxSrc_deinit(volatile Ifx_SRC_SRCR *src)
{
    Ifx_SRC_SRCR srcTmp;

    srcTmp.U     = 0U;
    srcTmp.B.TOS = 0xFU;

    src->U       = srcTmp.U;
}


IFX_INLINE void IfxSrc_disable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 0;
}


IFX_INLINE void IfxSrc_enable(volatile Ifx_SRC_SRCR *src)
{
    src->B.SRE = 1;
}


IFX_INLINE void IfxSrc_init(volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService, Ifx_Priority priority, IfxSrc_VmId vmNumber)
{
    Ifx_SRC_SRCR srcTmp;

    srcTmp.U = src->U;

    /* For TOS other than CPU0-5 write VM bitfield with 0 */
    if (typOfService > 5U)
    {
        vmNumber = IfxSrc_VmId_0;
    }

#if !defined(IFX_ILLD_PPU_USAGE)

    if (IfxCpu_getCoreIndex() == IfxCpu_ResourceCpu_6)
    {
        srcTmp.B.CS = 1U;
    }

#endif
#if (IFX_CFG_VIRTUALIZATION_DISABLED == 1)
    /* If Virtualization is disabled then always write VM bitfield with 0 */
    srcTmp.B.SRPN = priority;
    srcTmp.B.TOS  = typOfService;
    srcTmp.B.VM   = 0U;
#else
    srcTmp.B.SRPN = priority;
    srcTmp.B.TOS  = typOfService;
    srcTmp.B.VM   = vmNumber;
#endif

    src->U = srcTmp.U;
    IfxSrc_clearRequest(src);
}


IFX_INLINE boolean IfxSrc_isOverrun(volatile Ifx_SRC_SRCR *src)
{
    return src->B.IOV ? TRUE : FALSE;
}


IFX_INLINE boolean IfxSrc_isRequested(volatile Ifx_SRC_SRCR *src)
{
    return src->B.SRR ? TRUE : FALSE;
}


IFX_INLINE void IfxSrc_setRequest(volatile Ifx_SRC_SRCR *src)
{
    src->B.SETR = 1;
}


IFX_INLINE boolean IfxSrc_getEccError(volatile Ifx_INT *intr, IfxSrc_Tos typeOfService)
{
    return intr->ICU[typeOfService].ECTRL.B.STAT ? TRUE : FALSE;
}


IFX_INLINE void IfxSrc_clearEccError(volatile Ifx_INT *intr, IfxSrc_Tos typeOfService)
{
    intr->ICU[typeOfService].ECTRL.B.STATCLR = 1U;
}


IFX_INLINE void IfxSrc_enableBroadcastInterruptLine(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interruptLine)
{
    intr->GPSRG[groupNum].SWC[interruptLine].B.BRDIS = 0U;
}


IFX_INLINE void IfxSrc_disableBroadcastInterruptLine(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interruptLine)
{
    intr->GPSRG[groupNum].SWC[interruptLine].B.BRDIS = 1U;
}


IFX_INLINE void IfxSrc_triggerBroadcastinterruptLine(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interruptLine)
{
    intr->SRB[groupNum].U |= (1U << interruptLine);
}


IFX_INLINE void IfxSrc_triggerBroadcastinterrupts(volatile Ifx_INT *intr, IfxSrc_Int_group groupNum, uint8 interrupts)
{
    volatile uint16 interruptLines;
    interruptLines         = (1U << interrupts) - (uint8)1U;
    intr->SRB[groupNum].U |= interruptLines;
}


IFX_INLINE void IfxSrc_configOtgbTriggerSet(volatile Ifx_INT *intr, IfxSrc_TrigSet triggerSelection)
{
    intr->OCS.B.TGS = triggerSelection;
}


IFX_INLINE void IfxSrc_configOtgbBusSelect(volatile Ifx_INT *intr, IfxSrc_OtgbBusSel busSelection)
{
    intr->OCS.B.TGB = busSelection;
}


IFX_INLINE void IfxSrc_updateGpsrData(volatile Ifx_INT_GPSRG_SWC *src, uint16 data)
{
    src->B.LOCKCLR = 1;

    while (src->B.LOCKSTAT)
    {}

    {
        Ifx_INT_GPSRG_SWC gprsgSwc;
        gprsgSwc.B.DATA    = data;
        gprsgSwc.B.LOCKSET = 1;
        src->U             = gprsgSwc.U;
    }

    while (!src->B.LOCKSTAT)
    {}
}


#endif /* IFXSRC_H */
