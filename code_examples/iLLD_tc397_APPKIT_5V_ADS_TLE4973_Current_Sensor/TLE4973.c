/**********************************************************************************************************************
 * \file TLE4973.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "TLE4973.h"
#include "EDSADC.h"
#include "IfxPort.h"
#include "IfxCpu_Irq.h"
#include "UART_Config.h"
#include "Main_Config.h"
#include "EEPROM.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
uint8 lookupTableCRC5[256] = {0};
bool lutCreatedCRC5 = false;
COMMANDBYTE Cmdb;
SAFETYBYTE Safeb;
TLE4973Frame TLEFrame;
comFlag comFlags;
uint8 g_staticAddr[CHANNELS_NUM] = {0xA, 0xB, 0xC};
uint8 g_ocdStatus[CHANNELS_NUM];
tle4973_REG TLEDevice;
float g_sensitivity;
int g_off[CHANNELS_NUM] = {0, 0, 0};

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
static float g_senseRange[] = {52.89, 63.47, 84.63, 105.8, 126.95, 148.12, 169.26, 190.44, 253.89};
static uint8 g_MEASRange[] = {0x5, 0x6, 0x8, 0xA, 0xC, 0xE, 0x10, 0x12, 0x18};

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/* This function calculate the CRC3 of a uint8 data buffer. */
uint8 crc3Calculation(uint8 data)
{
    data ^= 0xA0;
    uint8 crcR = data;
    uint8 Poly = 0xB0;

    for (int i = 0; i < 5; i++)
    {
         if (crcR & 0x80)
          {
             crcR ^= Poly;
             crcR = (crcR << 1)& 0xFF;
          }
         else
          {
             crcR = (crcR << 1)& 0xFF;
          }
    }
    crcR = (crcR >> 5) & 0x07;
    return crcR;
}

/* This function verify the CRC3 of a uint8 data buffer if valid. */
uint8 crc3Verification(uint8 data)
{
    data ^= 0xA0;
    uint8 crcR = data;
    uint8 Poly = 0xB0;
    uint8 out = CRC_NOT_VALID;

    for (int i = 0; i < 5; i++)
    {
         if (crcR & 0x80)
        {
             crcR ^= Poly;
             crcR = (crcR << 1)& 0xFF;
        }
         else
        {
             crcR = (crcR << 1)& 0xFF;
        }
    }
    crcR = (crcR >> 5) & 0x07;
    if(crcR == 0x00)
    {
           out = CRC_VALID;                     /* At the end CRC must be equal to 0, which mean the data was well received */
    }
    return out;
}

/* This function create the CRC5 LUT for the CRC5 calculation. */
void createCRC5LUT(void)
{
    uint8 polynomial;
    polynomial = (uint8)(0x5 << 3);
    for (uint16 tableIndex = 0; tableIndex < 256; tableIndex++)
    {
        uint8 byte = (uint8)tableIndex;
        for (uint8 bit = 0; bit < 8; bit++)
        {
            const bool xorWithPolynomial = (byte & 0x80) != 0;
            byte <<= 1;
            if (xorWithPolynomial)
            {
                byte ^= polynomial;
            }
        }
        /* store CRC value in lookup table */
        lookupTableCRC5[tableIndex] = byte;
    }
    lutCreatedCRC5 = true;
}

/* This function calculate a CRC5 of a uint8 array. */
uint8 calculateCRC5(uint8 *data, uint8 numberOfBytes, uint8 initialValue)
{
    if(!lutCreatedCRC5)
    {
        createCRC5LUT();
    }
    uint8 crc;
    crc = initialValue;
    for (uint8 byteIndex = 0; byteIndex < numberOfBytes; byteIndex++)
    {
        const uint8 byte             = data[byteIndex];
        /* XOR-in next input byte */
        const uint8 lookupTableIndex = (uint8)(byte ^ crc);
        /* get current CRC value = remainder */
        crc = lookupTableCRC5[lookupTableIndex];
    }
    crc >>= 3;
    crc ^= 0x00;
    return (uint8)(crc & 0x1F);
}

/* This function receive a buffer of data from the TLE4973. If it is a write reply only 1 safety byte is received, if it is a read
reply 3 bytes are received (2 data and 1 safety byte), the data is store in TLEFrame. */
void dataStreamToFrame(uint8 *stock)
{
    if(getRequestSize() == readRequest)
    {
        /*the received frames are store in global TLEFrame*/
        TLEFrame.U = 0x0000;
        TLEFrame.B.Data |= stock[4] & 0x00FF;               /* Data frame of the received message */
        TLEFrame.B.Data = (TLEFrame.B.Data << 8);
        TLEFrame.B.Data |= stock[3] & 0x00FF;
        TLEFrame.B.Safety = stock[5];                       /* safety frame of the received message */
    }
    else if(getRequestSize() == writeRequest)
    {
        TLEFrame.U = 0x0000;
        TLEFrame.B.Safety = stock[5];                       /* safety frame of the received message */
    }
}

/* This function send a broadcast command to the sensors. Either BROADCAST SET or GET. */
void sendBroadCastCmd(commandBCType cmd)
{
    Cmdb.U = CLEAR_BYTE;
    Cmdb.B.Addr = CLEAR_BYTE;
    Cmdb.B.Cmd = cmd;
    Cmdb.B.CRC = crc3Calculation(Cmdb.U);
    sendTLE4973Byte(Cmdb.U);                    /* send one broadcast byte (command frame) */
}

/* This function send a write command to a sensor. */
void writeHLCommand(tle4973RegAddr addr, commandHLType data, uint8 deviceID)
{
    transferDataTLE4973(writeCommand, addr, data, deviceID);
}

void sendReset(uint8 deviceID)
{
    sendTLE9010Buffer(writeCommand, FAILRegAddr, RESET, WRITE_LENGTH, deviceID);
    Waitms(3);
}

/* This function send a read command to a sensor. */
uint16 readHLCommand(tle4973RegAddr addr, uint8 deviceID)
{
    transferDataTLE4973(readCommand, addr, NO_DATA, deviceID);
    return TLEFrame.B.Data;
}

/* This function create a read (3 frames) or write (5 frames) buffer and send it to the TLE4973. */
void sendTLE9010Buffer(commandType cmd, tle4973RegAddr addr, uint16 data, uint8 size, uint8 deviceAddr)
{
    uint8 dcdiFrame[size];
    uint8 crcFrame[4];
    uint8 dataL = (data & 0xFF);
    uint8 dataH = ((data >> 8) & 0xFF);
    Safeb.U = CLEAR_BYTE;

    /* Command byte */
    Cmdb.U = CLEAR_BYTE;
    Cmdb.B.Addr = deviceAddr;
    Cmdb.B.Cmd = cmd;
    Cmdb.B.CRC = crc3Calculation(Cmdb.U);               /* CRC3 calculation */

    uint8 crc5Seed = ((0x80) | (Cmdb.B.Addr << 3));     /* seed for CRC5 calculation */

    /* CRC calculation */
    crcFrame[0] = addr;
    crcFrame[1] = dataL;
    crcFrame[2] = dataH;
    crcFrame[3] = Safeb.U;

    uint8 crc = calculateCRC5(crcFrame, 4, crc5Seed);   /* CRC5 calculation */

    dcdiFrame[0] = Cmdb.U;
    dcdiFrame[1] = addr;
    if(cmd == writeCommand)                             /* add the data in the buffer for the write command */
    {
        dcdiFrame[2] = dataL;
        dcdiFrame[3] = dataH;
    }

    Safeb.B.CRC = crc;
    dcdiFrame[size-1] = Safeb.U;                       /* add CRC frame */
    sendTLE4973Frame(dcdiFrame, size);
}


void setRequestSize(comFlagType command)
{
    comFlags.B.frameRequest = command;
}

comFlagType getRequestSize(void)
{
    return comFlags.B.frameRequest;
}


/* This function return any content of the DIAG register. */
int getDiag(getDiagBFLD selDiag, uint8 index)
{
    uint16 data = 0x0;
    int res = 0;
    TLEDevice.GETDIAG.U = readHLCommand(DIAGSTATUSRegAddr, g_staticAddr[index]);
    if(selDiag == temperatureIC)
    {
        data = TLEDevice.GETDIAG.B.TEMPERATURE;
        res = (data - 2048)/16 + 65;
    }
    if(selDiag == out_Diag)
    {
        data = TLEDevice.GETDIAG.B.OUTDIAG;
        res = data;
    }
    if(selDiag == OCD_Diag)
    {
        data = TLEDevice.GETDIAG.B.OCDDIAG;
        res = data;
    }
    if(selDiag == sat)
    {
        data = TLEDevice.GETDIAG.B.SAT;
        if( data == 1)
        {
            printf("saturation detected");
        }
        res = data;
    }
    if(selDiag == OCD)
    {
        data = TLEDevice.GETDIAG.B.OCD;
        if( data == 1)
        {
            printf("overcurrent detected");
        }
        res = data;
    }
    return res;
}


/* This function return the voltage measure of a device (EDSADC). */
float measureVoltageSensor(uint8 index)
{
    float VAOUT;
    float Vres = 0.0;

    for(int i = 0; i <1000; i++)
    {
        runEDSADC();                                    /* Start EDSADC measurement */
        VAOUT = readEDSACVoltage(index);                /* read measurement result */
        Vres += VAOUT;
    }
    Vres = Vres/1000;
    return Vres;
}

/* Current measurement for one device (EVADC). */
void measureCurrent(uint8 index)
{
    float current;
    float VAOUT;
    VAOUT = measureVoltageSensor(index);                       /* measure voltage output of the sensor */
    current = ((VAOUT - g_off[index])/(g_sensitivity));        /* current calculation */
    printf("current value: %f A\n\r", current);
}

/* Current measurement for several devices (EVADC). */
void multiMeasureCurrent(void)
{
    uint16 VAOUT;
    double current;
    runEDSADC();
    printf("\n\r\n\rMeasurment result:\n\r");
    for(uint8 i = 0; i < CHANNELS_NUM; i++)
    {
        VAOUT = readEDSACVoltage(i);
        current = ((VAOUT)- g_off[i])/(g_sensitivity);
        printf("current of device %i: %lf\n\r", g_staticAddr[i], current);
    }
}

/* This function configure the output mode of the sensor. */
void configOutPut(OPMode output, MEASRange sense)
{
    initEDSADC(output);
    printf("\n\rTURN OFF THE CURRENT, THEN PRESS ANY KEY ON THE KEY BOARD\n\r\n\r");
    uint8 rec;
    receiveUART0(1, &rec);
    for(uint8 i = 0; i <CHANNELS_NUM; i++)
    {
        setOutputMode(output, g_staticAddr[i]);
        setMeasRange(sense, g_staticAddr[i]);
        g_off[i] = 0;
        g_sensitivity = (g_senseRange[sense]*46.19)/1000;

        /* Offset calibration */
        float Meas_1 = measureVoltageSensor(i);
        Waitms(1);
        float Meas_2 = measureVoltageSensor(i);
        Waitms(1);
        float Meas_3 = measureVoltageSensor(i);
        Waitms(1);
        g_off[i] = round((Meas_1+Meas_2+Meas_3)/3);                                /* offset calculation */
    }
}

/* This function set the EEPROM output mode. */
void setOutputMode(OPMode OPM, uint8 DeviceID)
{
    readEEPROM(DeviceID);
    TLEDevice.EEPROM40.U = getEEPROMValue(EEPROM40h);
    TLEDevice.EEPROM40.B.OUTPUTMODE = OPM;
    addNewEEPROMValue(TLEDevice.EEPROM40.U, EEPROM40h);
    programEEPROM(DeviceID);
}

/* This function set the EEPROM Measurement range. */
void setMeasRange(MEASRange sense, uint8 DeviceID)
{
    readEEPROM(DeviceID);
    TLEDevice.EEPROM40.U = getEEPROMValue(EEPROM40h);
    TLEDevice.EEPROM40.B.MEASRANGE = g_MEASRange[sense];
    addNewEEPROMValue(TLEDevice.EEPROM40.U, EEPROM40h);
    programEEPROM(DeviceID);
}
