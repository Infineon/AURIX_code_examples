/**********************************************************************************************************************
 * \file UART_VCOM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxAsclin_reg.h"
#include "IfxCpu_Irq.h"
#include "UART_Config.h"
#include "Bsp.h"
#include <stdio.h>
#include <stdlib.h>

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define SERIAL_BAUDRATE         57600                                        /* Baud rate in bit/s                   */

#define SERIAL_PIN_RX           IfxAsclin0_RXA_P14_1_IN                      /* RX pin of the board                  */
#define SERIAL_PIN_TX           IfxAsclin0_TX_P14_0_OUT                      /* TX pin of the board                  */
#define SERIAL_PIN2_RX          IfxAsclin3_RXE_P00_1_IN                      /* RX pin of the board                  */
#define SERIAL_PIN2_TX          IfxAsclin3_TX_P00_1_OUT                      /* TX pin of the board                  */

#define INTPRIO_ASCLIN0_TX      19                                           /* Priority of the ISR                  */
#define INTPRIO_ASCLIN0_RX      18
#define INTPRIO_ASCLIN2_TX      21                                           /* Priority of the ISR                  */
#define INTPRIO_ASCLIN2_RX      20

#define ASC_TX_BUFFER_SIZE      64                                           /* Definition of the buffer size        */
#define ASC_RX_BUFFER_SIZE      64

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxAsclin_Asc g_asc;                                                         /* Declaration of the ASC handle        */
IfxAsclin_Asc g_asc2;

uint8 g_ascTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];              /* Declaration of the FIFOs parameters  */
uint8 g_ascRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

uint8 g_ascTxBuffer2[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];             /* Declaration of the FIFOs parameters  */
uint8 g_ascRxBuffer2[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

uint8 g_WriteData[6];
uint8 g_ReadData[6];

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

IFX_INTERRUPT(asclin0_Rx_ISR, 0, INTPRIO_ASCLIN0_RX);
IFX_INTERRUPT(asclin0_Tx_ISR, 0, INTPRIO_ASCLIN0_TX);
IFX_INTERRUPT(asclin2_Rx_ISR, 0, INTPRIO_ASCLIN2_RX);
IFX_INTERRUPT(asclin2_Tx_ISR, 0, INTPRIO_ASCLIN2_TX);

void asclin0_Rx_ISR(void)
{
    IfxAsclin_Asc_isrReceive(&g_asc);
}

void asclin0_Tx_ISR(void)
{
    IfxAsclin_Asc_isrTransmit(&g_asc);
}

void asclin2_Rx_ISR(void)
{
    IfxAsclin_Asc_isrReceive(&g_asc2);
}

void asclin2_Tx_ISR(void)
{
    IfxAsclin_Asc_isrTransmit(&g_asc2);
}


/* ASCLIN0 Module Initialization. */
void init_UART(void)
{
    /* Initialize an instance of IfxAsclin_Asc_Config with default values */
    IfxAsclin_Asc_Config ascConfig;
    IfxAsclin_Asc_initModuleConfig(&ascConfig, &MODULE_ASCLIN0);

    /* Set the desired baud rate */
    ascConfig.baudrate.baudrate = SERIAL_BAUDRATE;

    /* ISR priorities and interrupt target */
    ascConfig.interrupt.rxPriority = INTPRIO_ASCLIN0_RX;
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

    /* FIFO configuration */
    ascConfig.rxBuffer = &g_ascRxBuffer;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;

    /* Port pins configuration */
    const IfxAsclin_Asc_Pins pins =
    {
        NULL_PTR,         IfxPort_InputMode_pullUp,     /* CTS pin not used     */
        &SERIAL_PIN_RX,   IfxPort_InputMode_pullUp,     /* RX pin not used      */
        NULL_PTR,         IfxPort_OutputMode_pushPull,  /* RTS pin not used     */
        &SERIAL_PIN_TX,   IfxPort_OutputMode_pushPull,  /* TX pin               */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;
    IfxAsclin_Asc_initModule(&g_asc, &ascConfig);       /* Initialize module with above parameters  */
    MODULE_ASCLIN0.FLAGSSET.B.TFLS = 1;
}

/* When using printf() command send on UART0 */
#ifdef __TASKING__
void _io_putc (char character)
{
    while (IfxAsclin_getTxFifoFillLevelFlagStatus(&MODULE_ASCLIN0) != TRUE)
    {}

    IfxAsclin_clearTxFifoFillLevelFlag(&MODULE_ASCLIN0);

    /* Send the character */
    IfxAsclin_writeTxData(&MODULE_ASCLIN0, character);
}
#endif /* __TASKING__ */

/* ASCLIN2 Module Initialization. */
void init_UART2(void)
{
    /* Initialize an instance of IfxAsclin_Asc_Config with default values */
    IfxAsclin_Asc_Config ascConfig2;
    IfxAsclin_Asc_initModuleConfig(&ascConfig2, &MODULE_ASCLIN3);
    ascConfig2.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_12;
    ascConfig2.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;
    ascConfig2.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;

    /* Set the desired baud rate */
    ascConfig2.baudrate.baudrate = SERIAL_BAUDRATE;

    /* ISR priorities and interrupt target */
    ascConfig2.interrupt.txPriority = INTPRIO_ASCLIN2_TX;
    ascConfig2.interrupt.rxPriority = INTPRIO_ASCLIN2_RX;
    ascConfig2.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

    /* FIFO configuration */
    ascConfig2.txBuffer = &g_ascTxBuffer2;
    ascConfig2.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConfig2.rxBuffer = &g_ascRxBuffer2;
    ascConfig2.rxBufferSize = ASC_RX_BUFFER_SIZE;

    /* Port pins configuration */
    const IfxAsclin_Asc_Pins pins =
    {
        NULL_PTR,         IfxPort_InputMode_pullUp,      /* CTS pin not used     */
        &SERIAL_PIN2_RX,   IfxPort_InputMode_pullUp,     /* RX pin not used      */
        NULL_PTR,         IfxPort_OutputMode_pushPull,   /* RTS pin not used     */
        &SERIAL_PIN2_TX,   IfxPort_OutputMode_pushPull,  /* TX pin               */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig2.pins = &pins;
    IfxAsclin_Asc_initModule(&g_asc2, &ascConfig2);         /* Initialize module with above parameters  */
}

/* This function send a message with several bytes to the TLE4973. */
void sendTLE4973Frame(uint8 *frame, uint8 size)
{
    Ifx_SizeT countr = size;
    IfxAsclin_Asc_write(&g_asc2, frame, &countr, TIME_INFINITE);
}

/* This function send a one byte message to the TLE4973. */
void sendTLE4973Byte(uint8 mess)
{
    Ifx_SizeT countr = 1;
    IfxAsclin_Asc_write(&g_asc2, &mess, &countr, TIME_INFINITE);
}

/* This function received message from the TLE4973. */
void receiveUART2(Ifx_SizeT sizeM, uint8 *buffer)
{
    IfxAsclin_Asc_clearRx(&g_asc2);
    IfxAsclin_Asc_read(&g_asc2, buffer, &sizeM, TIME_INFINITE);
}

/* This function received message from the computer. */
void receiveUART0(Ifx_SizeT sizeM, uint8 *buffer)
{
    IfxAsclin_Asc_clearRx(&g_asc);
    IfxAsclin_Asc_read(&g_asc, buffer, &sizeM, TIME_INFINITE);
}

/* This function clear the received buffer */
void clearAsc(void)
{
    IfxAsclin_Asc_clearRx(&g_asc2);
}

/* This function send a write or read request to the TLE4973. */
void transferDataTLE4973(commandType cmd, tle4973RegAddr addr, uint16 data, uint8 deviceID)
{
    if(cmd == writeCommand )
    {
        setRequestSize(writeRequest);
        sendTLE9010Buffer(cmd, addr, data, WRITE_LENGTH, deviceID); /* create a buffer and send it to the sensor */
        receiveUART2(UART_FRAME, g_WriteData);
        dataStreamToFrame(g_WriteData);
    }
    else if(cmd == readCommand)
    {
        setRequestSize(readRequest);
        sendTLE9010Buffer(cmd, addr, data, READ_LENGTH, deviceID);  /* create a buffer and send it to the sensor */
        receiveUART2(UART_FRAME, g_ReadData);
        dataStreamToFrame(g_ReadData);
    }
}
