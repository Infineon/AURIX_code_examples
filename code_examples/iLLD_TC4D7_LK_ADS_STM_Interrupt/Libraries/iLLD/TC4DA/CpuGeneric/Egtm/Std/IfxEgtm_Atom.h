/**
 * \file IfxEgtm_Atom.h
 * \brief EGTM  basic functionality
 * \ingroup IfxLld_Egtm
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 *
 * \defgroup IfxLld_Egtm_Std_Atom Atom Basic Functionality
 * \ingroup IfxLld_Egtm_Std
 * \defgroup IfxLld_Egtm_Std_Atom_Enumerations ATOM Enumerations
 * \ingroup IfxLld_Egtm_Std_Atom
 * \defgroup IfxLld_Egtm_Std_Atom_Channel_Functions ATOM Channel Functions
 * \ingroup IfxLld_Egtm_Std_Atom
 * \defgroup IfxLld_Egtm_Std_Atom_AGC_Functions ATOM AGC Functions
 * \ingroup IfxLld_Egtm_Std_Atom
 * \defgroup IfxLld_Egtm_Std_Atom_Module_Functions ATOM Module Functions
 * \ingroup IfxLld_Egtm_Std_Atom
 */

#ifndef IFXEGTM_ATOM_H
#define IFXEGTM_ATOM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxEgtm_cfg.h"
#include "IfxEgtm.h"
#include "IfxEgtm_Tbu.h"
#include "Src/Std/IfxSrc.h"
#include "IfxEgtm_Cmu.h"
#include "stddef.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Number of channels per ATOM AGC
 */
#define IFXEGTM_ATOM_NUM_AGC_CHANNELS (8)

/** \brief Macro to calculate shift for each channel
 * Each channel occupies two bits hence left shift by 1 and then add offset
 */
#define IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, offset) ((((uint32)((uint32)channel & 0x7u)) << 1u) + offset)

/** \brief Macro to mask one channel bitfield in AGC registers
 */
#define IFXEGTM_ATOM_AGC_CHANNEL_MASK (3u)

/** \brief Macro to calculate channel bitfield value in AGC registers depending on whether it is enabled or not
 */
#define IFXEGTM_ATOM_AGC_CHANNEL_VALUE(enabled)         ((enabled == TRUE) ? IfxEgtm_FeatureControl_enable : IfxEgtm_FeatureControl_disable)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Std_Atom_Enumerations
 * \{ */
/** \brief Clock source for the ATOM channels
 */
typedef enum
{
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk0  = 0,   /**< \brief cmu clock0 */
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk1  = 1,   /**< \brief cmu clock1 */
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk2  = 2,   /**< \brief cmu clock2 */
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk3  = 3,   /**< \brief cmu clock3 */
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk4  = 4,   /**< \brief cmu clock4 */
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk5  = 5,   /**< \brief cmu clock5 */
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk6  = 6,   /**< \brief cmu clock6 */
    IfxEgtm_Atom_Ch_ClkSrc_cmuclk7  = 7,   /**< \brief cmu clock7 */
    IfxEgtm_Atom_Ch_ClkSrc_noClock  = 8,   /**< \brief no clock */
    IfxEgtm_Atom_Ch_ClkSrc_prevTrig = 13,  /**< \brief TRIG[x-1] trigger from previous channel */
    IfxEgtm_Atom_Ch_ClkSrc_extTrig  = 14   /**< \brief TIM_EXT_CAPTURE */
} IfxEgtm_Atom_Ch_ClkSrc;

/** \brief Reset source for channel counter CN0
 */
typedef enum
{
    IfxEgtm_Atom_Ch_OutputTrigger_forward  = 0, /**< \brief Forward the trigger from the previous channel */
    IfxEgtm_Atom_Ch_OutputTrigger_generate = 1  /**< \brief Generate the trigger from the current channel */
} IfxEgtm_Atom_Ch_OutputTrigger;

/** \brief Reset event for channel counter CN0
 */
typedef enum
{
    IfxEgtm_Atom_Ch_ResetEvent_onCm0     = 0,
    IfxEgtm_Atom_Ch_ResetEvent_onTrigger = 1
} IfxEgtm_Atom_Ch_ResetEvent;

/** \brief Enum for ATOM mode
 */
typedef enum
{
    IfxEgtm_Atom_Mode_outputImmediate,       /**< \brief ATOM Signal Output Mode Immediate (SOMI) */
    IfxEgtm_Atom_Mode_outputCompare,         /**< \brief ATOM Signal Output Mode Compare (SOMC) */
    IfxEgtm_Atom_Mode_outputPwm,             /**< \brief ATOM Signal Output Mode PWM (SOMP) */
    IfxEgtm_Atom_Mode_outputSerial,          /**< \brief ATOM Signal Output Mode Serial (SOMS) */
    IfxEgtm_Atom_Mode_outputBufferedControl  /**< \brief ATOM Signal Output Mode Buffered Compare (SOMB) */
} IfxEgtm_Atom_Mode;

/** \brief Match Compare control modes
 */
typedef enum
{
    IfxEgtm_Atom_SomcControl_compareBoth     = 0,  /**< \brief compare CCU0 and CCU1 in parallel */
    IfxEgtm_Atom_SomcControl_compareBoth1    = 1,  /**< \brief compare CCU0 and CCU1 in parallel */
    IfxEgtm_Atom_SomcControl_ccu0Ts0         = 2,  /**< \brief compare CCU0 against TS0 */
    IfxEgtm_Atom_SomcControl_ccu1Ts12        = 3,  /**< \brief compare only CCU1 against TS1 or TS2 */
    IfxEgtm_Atom_SomcControl_ccu0ccu1Ts0     = 4,  /**< \brief compare CCU0 then CCU1, use TS0 */
    IfxEgtm_Atom_SomcControl_ccu0ccu1Ts12    = 5,  /**< \brief compare CCU0 then CCU1. Use TS1 or TS2 */
    IfxEgtm_Atom_SomcControl_ccu0Ts0ccu1Ts12 = 6,  /**< \brief compare CCU0 with TS0 then CCU1 with TS1 or TS2 */
    IfxEgtm_Atom_SomcControl_cancelCompare   = 7   /**< \brief Cancel pending compare events */
} IfxEgtm_Atom_SomcControl;

/** \brief SOMC signal level Control
 */
typedef enum
{
    IfxEgtm_Atom_SomcSignalLevelControl_noChange = 0,  /**< \brief no signal level change at output */
    IfxEgtm_Atom_SomcSignalLevelControl_sl0out1  = 1,  /**< \brief SL= 0 -> Out=1; SL=1->Out=0 */
    IfxEgtm_Atom_SomcSignalLevelControl_sl0out0  = 2,  /**< \brief SL=0->Out=0; SL=1->Out=1 */
    IfxEgtm_Atom_SomcSignalLevelControl_toggle   = 3   /**< \brief toggle the output signal level */
} IfxEgtm_Atom_SomcSignalLevelControl;

/** \} */

/** \addtogroup IfxLld_Egtm_Std_Atom_Channel_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Clears IR notification for CCU1 events
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_clearOneNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Clears IR notification for CCU0 events
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_clearZeroNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param clk Clock source
 * \param activeState Active State
 * \param resetEvent Channel reset event
 * \param trigger Channel trigger output mode
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_configurePwmMode(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_ClkSrc clk, Ifx_ActiveState activeState, IfxEgtm_Atom_Ch_ResetEvent resetEvent, IfxEgtm_Atom_Ch_OutputTrigger trigger);

/** \brief Returns the base addredd of selected Atom channel
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return Pointer to channel base address
 */
IFX_INLINE volatile Ifx_EGTM_CLS_ATOM_CH *IfxEgtm_Atom_Ch_getChannelPointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the ATOM channel input clock frequency in Hz
 * \param egtm Pointer to EGTM module
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return ATOM channel input clock frequency in Hz
 */
IFX_INLINE float32 IfxEgtm_Atom_Ch_getClockFrequency(Ifx_EGTM *egtm, Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the channel clock source
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return The clock source
 */
IFX_INLINE IfxEgtm_Atom_Ch_ClkSrc IfxEgtm_Atom_Ch_getClockSource(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the compare one value
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return compare one value
 */
IFX_INLINE uint32 IfxEgtm_Atom_Ch_getCompareOne(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the compare one pointer
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return compare one pointer
 */
IFX_INLINE volatile uint32 *IfxEgtm_Atom_Ch_getCompareOnePointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the compare zero value
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return compare zero value
 */
IFX_INLINE uint32 IfxEgtm_Atom_Ch_getCompareZero(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the compare zero pointer
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return compare zero pointer
 */
IFX_INLINE volatile uint32 *IfxEgtm_Atom_Ch_getCompareZeroPointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Gets the ATOM output level
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return TRUE the output is high, FALSE the output is low
 */
IFX_INLINE boolean IfxEgtm_Atom_Ch_getOutputLevel(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns a pointer to the ATOM channel SRC
 * \param egtm Pointer to EGTM module
 * \param cluster Specifies the cluster
 * \param channel Channel index
 * \return Pointer to the TOM channel SRC
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxEgtm_Atom_Ch_getSrcPointer(Ifx_EGTM *egtm, IfxEgtm_Cluster cluster, IfxEgtm_Atom_Ch channel);

/** \brief Returns the Timer pointer
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return Timer pointer
 */
IFX_INLINE volatile uint32 *IfxEgtm_Atom_Ch_getTimerPointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the status of channel One notification
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return Status of channel One notification
 */
IFX_INLINE boolean IfxEgtm_Atom_Ch_isOneNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Returns the status of channel Zero notification
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return Status of channel Zero notification
 */
IFX_INLINE boolean IfxEgtm_Atom_Ch_isZeroNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Raises the interrupt for Compare 1
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_raiseInterruptOne(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Raises the interrupt for Compare 0
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_raiseInterruptZero(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Sets the channel clock source
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param clk Channel clock source
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setClockSource(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_ClkSrc clk);

/** \brief Sets the compare 0 and 1 values
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param compareZero Compare zero value
 * \param compareOne Compare one value
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setCompare(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 compareZero, uint32 compareOne);

/** \brief Sets the compare 1 value
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param compareOne Compare one value
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setCompareOne(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 compareOne);

/** \brief Sets the compare 1 shadow value
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param shadowOne Compare one shadow value
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setCompareOneShadow(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 shadowOne);

/** \brief Sets the compare 0 and 1 shadow values
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param shadowZero Compare zero shadow value
 * \param shadowOne Compare one shadow value
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setCompareShadow(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 shadowZero, uint32 shadowOne);

/** \brief Sets the compare 0 value
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param compareZero Compare zero value
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setCompareZero(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 compareZero);

/** \brief Sets the compare 0 shadow value
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param shadowZero Compare zero shadow value
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setCompareZeroShadow(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 shadowZero);

/** \brief Sets the counter value
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param value Counter value
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setCounterValue(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 value);

/** \brief set the Atom operating mode
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param mode Atom operating mode
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setMode(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Mode mode);

/** \brief Sets the channel notification
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param mode Interrupt mode
 * \param interruptOnCompareZero If TRUE, an interrupt is generated on compare 0, else no interrupt is generated
 * \param interruptOnCompareOne If TRUE, an interrupt is generated on compare 1, else no interrupt is generated
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_IrqMode mode, boolean interruptOnCompareZero, boolean interruptOnCompareOne);

/** \brief Enable/disable the one shot mode
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param enabled If TRUE, the feature is enabled, else disabled
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setOneShotMode(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, boolean enabled);

/** \brief Sets the channel clock source either from local or from previous channel
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param event Channel reset event
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setResetSource(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_ResetEvent event);

/** \brief Sets the signal level
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param activeState Signal level active state. In case the channel is reset, the output is set to not active. The signal is active between 0 and the leading edge (CM1) and inactive between the leading edge and the trailing edge (CM0).
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setSignalLevel(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, Ifx_ActiveState activeState);

/** \brief Sets the channel trigger output
 * \param atom Pointer to the ATOM object
 * \param channel Channel index
 * \param trigger Channel trigger output mode
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setTriggerOutput(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_OutputTrigger trigger);

/** \brief Get the counter value
 * \param atom pointer to the ATOM instance
 * \param channel channel index of the ATOM
 * \return counter value
 */
IFX_INLINE uint32 IfxEgtm_Atom_Ch_getCounterValue(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief sets the SOMC control bits for the specified ATOM channel
 * \param atom pointer to ATOM instance
 * \param channel ATOM channel index
 * \param control SOMC control mode enum
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setSomcControl(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_SomcControl control);

/** \brief sets the SL control for SOMC mode.
 * \param atom pointer to the ATOM instance
 * \param channel index of ATOM channel
 * \param ctrl SIgnal level control
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setSomcSignalLevelControl(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_SomcSignalLevelControl ctrl);

/** \brief set the High resolution support for ATOM channel
 * \param atom pointer to ATOM instance
 * \param channel ATOM channel index
 * \param enabled enable or disable HRES suport
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Ch_setHresEn(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, boolean enabled);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Get configured frequency of PWM channel
 * Note: This API does not work if channel 0 counter is reset by external trigger. API will cause a trap in such a case.
 * \param atom Pointer to ATOM subcluster SFR
 * \param channel ATOM channel numer
 * \return Channel frequency in Hz
 */
IFX_EXTERN float32 IfxEgtm_Atom_Ch_getFrequency(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \brief Get configured duty of PWM channel
 * Note: This API does not work if channel 0 counter is reset by external trigger. API will cause a trap in such a case.
 * \param atom Pointer to ATOM subcluster SFR
 * \param channel ATOM channel numer
 * \return Channel duty in percentage [0-100%]
 */
IFX_EXTERN float32 IfxEgtm_Atom_Ch_getDuty(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel);

/** \} */

/** \addtogroup IfxLld_Egtm_Std_Atom_AGC_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable/disable one channel (ENDIS)
 * \param agc Pointer to the AGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choice of the feature
 * \param immediate If TRUE, the action is done immediately else, the action is done on AGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableChannel(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled, boolean immediate);

/** \brief Enable/disable one channel output (OUTEN)
 * \param agc Pointer to the AGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choice of the feature
 * \param immediate If TRUE, the action is done immediately else, the action is done on TGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelOutput(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled, boolean immediate);

/** \brief Enable/disable one channel for update (UPEN)
 * \param agc Pointer to the AGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choice of the feature
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled);

/** \brief Enable/disable one or more channels (ENDIS)
 * \param agc Pointer to the AGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param immediate If TRUE, the action is done immediately else, the action is done on TGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableChannels(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, boolean immediate);

/** \brief Enable/disable one or more channels output (OUTEN)
 * \param agc Pointer to the TGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param immediate If TRUE, the action is done immediately else, the action is done on TGC trigger (CTRL_TRIG)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelsOutput(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, boolean immediate);

/** \brief Enable/disable the TGC channels trigger
 * \param agc Pointer to the AGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelsTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask);

/** \brief Enable/disable one or more channels for update (UPEN)
 * \param agc Pointer to the AGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelsUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask);

/** \brief Enable/disable the time base trigger
 * \param agc Pointer to the AGC object
 * \param enabled If TRUE, the trigger is enabled else disabled
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_enableTimeTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, boolean enabled);

/** \brief Reset one or more channels
 * \param agc Pointer to the AGC object
 * \param resetMask Mask for the channel reset (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_resetChannels(Ifx_EGTM_CLS_ATOM_AGC *agc, uint32 resetMask);

/** \brief Enable/disable one channel for update (FUPD)
 * \param agc Pointer to the AGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choice of the feature
 * \param resetEnabled Enable/ Disable reset choice of the feature
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_setChannelForceUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled, boolean resetEnabled);

/** \brief Enable/disable one or more channels for the force update feature (FUPD)
 * \param agc Pointer to the AGC object
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param resetEnableMask Mask for the enabled channels counter reset on force update (bit 0: Channel 0, bit 1: channel 1, ...) Channel 0, bit 1: channel 1, ...)
 * \param resetDisableMask Mask for the disabled channels with no counter reset on force update (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_setChannelsForceUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, uint16 resetEnableMask, uint16 resetDisableMask);

/** \brief Sets the trigger time base and time base value
 * \param agc Pointer to the AGC object
 * \param base Time base used for comparison
 * \param value Compare value that raise the trigger
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_setTimeTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Tbu_Ts base, uint32 value);

/** \brief Raise the trigger for the channel enable/disable settings,  output enable settings, and force update event (CTRL_TRIG)
 * \param agc Pointer to the AGC object
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_trigger(Ifx_EGTM_CLS_ATOM_AGC *agc);

/** \brief Sets the channels for update (UPEN)
 * \param agc Pointer to the AGC object
 * \param value value for the channel enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_setChannelsUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, uint32 value);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Builds the register value for the feature enable/disable
 * \param enableMask Mask for the channel feature enable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param disableMask Mask for the channel feature disable (bit 0: Channel 0, bit 1: channel 1, ...)
 * \param bitfieldOffset Offset of the channel 0 bitfield in the register
 * \return The register value
 */
IFX_EXTERN uint32 IfxEgtm_Atom_Agc_buildFeature(uint16 enableMask, uint16 disableMask, uint8 bitfieldOffset);

/** \brief Builds the register value for the feature enable/disable for a single channel
 * \param channel Channel index
 * \param enabled Enable/ Disable choice of the feature
 * \param bitfieldOffset Offset of the channel 0 bitfield in the register
 * \return The register value
 */
IFX_EXTERN uint32 IfxEgtm_Atom_Agc_buildFeatureForChannel(IfxEgtm_Atom_Ch channel, boolean enabled, uint8 bitfieldOffset);

/** \} */

/** \addtogroup IfxLld_Egtm_Std_Atom_Module_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures the tout selection
 * \param toutNum TOUT number
 * \param toutSel TOUTselection
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_setTout(uint32 toutNum, uint32 toutSel);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable/disable the AGC channel trigger
 * \param agc Pointer to the AGC object
 * \param channel Channel index
 * \param enabled Enable/ Disable choice of the feature
 * \return None
 */
IFX_INLINE void IfxEgtm_Atom_Agc_setInternalTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxEgtm_Atom_Agc_enableChannel(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled, boolean immediate)
{
    uint32 shift = IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, IFX_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_ENDIS_CTRL0_OFF);
    uint32 value = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_VALUE(enabled) << shift;
    uint32 mask  = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_MASK << shift;

    Ifx__ldmst(&(agc->ENDIS_CTRL.U), mask, value);

    if (immediate == TRUE)
    {
        Ifx__ldmst(&(agc->ENDIS_STAT.U), mask, value);
    }
}


IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelOutput(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled, boolean immediate)
{
    uint32 shift = IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, IFX_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_OUTEN_CTRL0_OFF);
    uint32 value = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_VALUE(enabled) << shift;
    uint32 mask  = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_MASK << shift;

    Ifx__ldmst(&(agc->OUTEN_CTRL.U), mask, value);

    if (immediate == TRUE)
    {
        Ifx__ldmst(&(agc->OUTEN_STAT.U), mask, value);
    }
}


IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled)
{
    uint32 shift = IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, IFX_EGTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF);
    uint32 value = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_VALUE(enabled) << shift;
    uint32 mask  = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_MASK << shift;

    Ifx__ldmst(&(agc->GLB_CTRL.U), mask, value);
}


IFX_INLINE void IfxEgtm_Atom_Agc_enableChannels(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, boolean immediate)
{
    uint32 value;

    value             = IfxEgtm_Atom_Agc_buildFeature(enableMask, disableMask, IFX_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_ENDIS_CTRL0_OFF);

    agc->ENDIS_CTRL.U = value;

    if (immediate == TRUE)
    {
        agc->ENDIS_STAT.U = value;
    }
}


IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelsOutput(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, boolean immediate)
{
    uint32 value;

    value             = IfxEgtm_Atom_Agc_buildFeature(enableMask, disableMask, IFX_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_OUTEN_CTRL0_OFF);

    agc->OUTEN_CTRL.U = value;

    if (immediate == TRUE)
    {
        agc->OUTEN_STAT.U = value;
    }
}


IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelsTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask)
{
    agc->INT_TRIG.U = IfxEgtm_Atom_Agc_buildFeature(enableMask, disableMask, IFX_EGTM_CLS_ATOM_AGC_INT_TRIG_INT_TRIG0_OFF);
}


IFX_INLINE void IfxEgtm_Atom_Agc_enableChannelsUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask)
{
    agc->GLB_CTRL.U = IfxEgtm_Atom_Agc_buildFeature(enableMask, disableMask, IFX_EGTM_CLS_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF);
}


IFX_INLINE void IfxEgtm_Atom_Agc_enableTimeTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, boolean enabled)
{
    agc->ACT_TB.B.TB_TRIG = (enabled == TRUE) ? (uint8)1u : (uint8)0u;
}


IFX_INLINE void IfxEgtm_Atom_Agc_resetChannels(Ifx_EGTM_CLS_ATOM_AGC *agc, uint32 resetMask)
{
    uint8  i;
    uint32 reg = 0u;

    for (i = 0u; i < IFXEGTM_ATOM_NUM_AGC_CHANNELS; i++)
    {
        if ((resetMask & 0x1u) == 0x1u)
        {
            reg |= (uint32)((uint32)1u << i);
        }

        resetMask = resetMask >> 1;
    }

    agc->GLB_CTRL.U = reg << IFX_EGTM_CLS_ATOM_AGC_GLB_CTRL_RST_CH0_OFF;
}


IFX_INLINE void IfxEgtm_Atom_Agc_setChannelForceUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled, boolean resetEnabled)
{
    uint32 shift = IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, IFX_EGTM_CLS_ATOM_AGC_FUPD_CTRL_FUPD_CTRL0_OFF);
    uint32 value = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_VALUE(enabled) << shift;
    uint32 mask  = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_MASK << shift;

    shift = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, IFX_EGTM_CLS_ATOM_AGC_FUPD_CTRL_RSTCN0_CH0_OFF);
    value = (uint32)value | (uint32)((uint32)IFXEGTM_ATOM_AGC_CHANNEL_VALUE(resetEnabled) << shift);
    mask  = mask | (uint32)((uint32)IFXEGTM_ATOM_AGC_CHANNEL_MASK << shift);

    Ifx__ldmst(&(agc->FUPD_CTRL.U), mask, value);
}


IFX_INLINE void IfxEgtm_Atom_Agc_setChannelsForceUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, uint16 enableMask, uint16 disableMask, uint16 resetEnableMask, uint16 resetDisableMask)
{
    uint32 regEnable, regReset;

    regEnable        = IfxEgtm_Atom_Agc_buildFeature(enableMask, disableMask, IFX_EGTM_CLS_ATOM_AGC_FUPD_CTRL_FUPD_CTRL0_OFF);
    regReset         = IfxEgtm_Atom_Agc_buildFeature(resetEnableMask, resetDisableMask, IFX_EGTM_CLS_ATOM_AGC_FUPD_CTRL_RSTCN0_CH0_OFF);
    agc->FUPD_CTRL.U = regEnable | regReset;
}


IFX_INLINE void IfxEgtm_Atom_Agc_setTimeTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Tbu_Ts base, uint32 value)
{
    Ifx_EGTM_CLS_ATOM_AGC_ACT_TB act_tb;

    act_tb.U         = agc->ACT_TB.U;
    act_tb.B.TBU_SEL = (uint8)base;
    act_tb.B.ACT_TB  = value;
    agc->ACT_TB.U    = act_tb.U;
}


IFX_INLINE void IfxEgtm_Atom_Agc_trigger(Ifx_EGTM_CLS_ATOM_AGC *agc)
{
    agc->GLB_CTRL.B.HOST_TRIG = 1u;
}


IFX_INLINE void IfxEgtm_Atom_Ch_clearOneNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    atom->CH[channel].IRQ_NOTIFY.B.CCU1TC = 1u;
}


IFX_INLINE void IfxEgtm_Atom_Ch_clearZeroNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    atom->CH[channel].IRQ_NOTIFY.B.CCU0TC = 1u;
}


IFX_INLINE void IfxEgtm_Atom_Ch_configurePwmMode(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_ClkSrc clk, Ifx_ActiveState activeState, IfxEgtm_Atom_Ch_ResetEvent resetEvent, IfxEgtm_Atom_Ch_OutputTrigger trigger)
{
    volatile Ifx_EGTM_CLS_ATOM_CH *atomCh = IfxEgtm_Atom_Ch_getChannelPointer(atom, channel);
    Ifx_EGTM_CLS_ATOM_CH_CTRL      ctrl;

    ctrl.U            = 0u;
    ctrl.B.MODE       = (uint8)IfxEgtm_Atom_Mode_outputPwm;
    ctrl.B.CLK_SRC    = (uint8)clk;
    ctrl.B.RST_CCU0   = (uint8)resetEvent;
    ctrl.B.SL         = (activeState == Ifx_ActiveState_high ? (uint8)1u : (uint8)0u);
    ctrl.B.TRIGOUT    = (uint8)trigger;

    atomCh->CTRL.U    = ctrl.U;
    atomCh->CTRL_SR.U = ctrl.U & (0xF800U);
}


IFX_INLINE volatile Ifx_EGTM_CLS_ATOM_CH *IfxEgtm_Atom_Ch_getChannelPointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return (volatile Ifx_EGTM_CLS_ATOM_CH *)(&atom->CH[channel]);
}


IFX_INLINE float32 IfxEgtm_Atom_Ch_getClockFrequency(Ifx_EGTM *egtm, Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    IfxEgtm_Atom_Ch_ClkSrc clk;
    float32                result = 0.0f;

    clk = IfxEgtm_Atom_Ch_getClockSource(atom, channel);

    if (clk <= IfxEgtm_Atom_Ch_ClkSrc_cmuclk7)
    {
        result = IfxEgtm_Cmu_getClkFrequency(egtm, (IfxEgtm_Cmu_Clk)clk, TRUE);
    }

    return result;
}


IFX_INLINE IfxEgtm_Atom_Ch_ClkSrc IfxEgtm_Atom_Ch_getClockSource(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return (IfxEgtm_Atom_Ch_ClkSrc)(atom->CH[channel].CTRL.B.CLK_SRC);
}


IFX_INLINE uint32 IfxEgtm_Atom_Ch_getCompareOne(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return atom->CH[channel].CM1.U;
}


IFX_INLINE volatile uint32 *IfxEgtm_Atom_Ch_getCompareOnePointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return (volatile uint32 *)(volatile void *)(&atom->CH[channel].CM1);
}


IFX_INLINE uint32 IfxEgtm_Atom_Ch_getCompareZero(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return atom->CH[channel].CM0.U;
}


IFX_INLINE volatile uint32 *IfxEgtm_Atom_Ch_getCompareZeroPointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return (volatile uint32 *)(volatile void *)(&atom->CH[channel].CM0);
}


IFX_INLINE boolean IfxEgtm_Atom_Ch_getOutputLevel(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    boolean result;

    result = (atom->CH[channel].STAT.B.OL == (uint8)1) ? TRUE : FALSE;

    return result;
}


IFX_INLINE volatile Ifx_SRC_SRCR *IfxEgtm_Atom_Ch_getSrcPointer(Ifx_EGTM *egtm, IfxEgtm_Cluster cluster, IfxEgtm_Atom_Ch channel)
{
    IFX_UNUSED_PARAMETER(egtm)
    return &MODULE_SRC.EGTM.ATOM[cluster].SR[channel >> 1u];
}


IFX_INLINE volatile uint32 *IfxEgtm_Atom_Ch_getTimerPointer(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return (volatile uint32 *)(&(atom->CH[channel].CN0.U));
}


IFX_INLINE boolean IfxEgtm_Atom_Ch_isOneNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    boolean result;
    result = (atom->CH[channel].IRQ_NOTIFY.B.CCU1TC != (uint8)0u) ? TRUE : FALSE;
    return result;
}


IFX_INLINE boolean IfxEgtm_Atom_Ch_isZeroNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    boolean result;
    result = (atom->CH[channel].IRQ_NOTIFY.B.CCU0TC != (uint8)0u) ? TRUE : FALSE;
    return result;
}


IFX_INLINE void IfxEgtm_Atom_Ch_raiseInterruptOne(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    atom->CH[channel].IRQ_FORCINT.B.TRG_CCU1TC = 1u;
}


IFX_INLINE void IfxEgtm_Atom_Ch_raiseInterruptZero(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    atom->CH[channel].IRQ_FORCINT.B.TRG_CCU0TC = 1u;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setClockSource(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_ClkSrc clk)
{
    atom->CH[channel].CTRL.B.CLK_SRC       = (uint8)clk;
    atom->CH[channel].CTRL_SR.B.CLK_SRC_SR = (uint8)clk;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setCompare(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 compareZero, uint32 compareOne)
{
    atom->CH[channel].CM0.U = compareZero;
    atom->CH[channel].CM1.U = compareOne;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setCompareOne(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 compareOne)
{
    atom->CH[channel].CM1.U = compareOne;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setCompareOneShadow(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 shadowOne)
{
    atom->CH[channel].SR1.U = shadowOne;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setCompareShadow(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 shadowZero, uint32 shadowOne)
{
    atom->CH[channel].SR0.U = shadowZero;
    atom->CH[channel].SR1.U = shadowOne;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setCompareZero(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 compareZero)
{
    atom->CH[channel].CM0.U = compareZero;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setCompareZeroShadow(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 shadowZero)
{
    atom->CH[channel].SR0.U = shadowZero;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setCounterValue(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, uint32 value)
{
    atom->CH[channel].CN0.U = value;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setMode(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Mode mode)
{
    atom->CH[channel].CTRL.B.MODE = (uint8)mode;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setNotification(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_IrqMode mode, boolean interruptOnCompareZero, boolean interruptOnCompareOne)
{
    Ifx_EGTM_CLS_ATOM_CH       *atomCh = &(atom->CH[channel]);

    /* Prepare new values */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_EN en;
    en.B.CCU0TC_IRQ_EN          = interruptOnCompareZero;
    en.B.CCU1TC_IRQ_EN          = interruptOnCompareOne;

    atomCh->IRQ_EN.U            = 0u;          /* Disable all interrupts of the interrupt set to change mode */
    atomCh->IRQ_MODE.B.IRQ_MODE = (uint8)mode; /* Change mode */
    atomCh->IRQ_EN.U            = en.U;        /* Set the new values */
}


IFX_INLINE void IfxEgtm_Atom_Ch_setOneShotMode(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, boolean enabled)
{
    atom->CH[channel].CTRL.B.OSM = (uint8)enabled;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setResetSource(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_ResetEvent event)
{
    atom->CH[channel].CTRL.B.RST_CCU0 = (uint8)event;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setSignalLevel(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, Ifx_ActiveState activeState)
{
    atom->CH[channel].CTRL.B.SL       = (uint8)(activeState);

    atom->CH[channel].CTRL_SR.B.SL_SR = (uint8)(activeState);
}


IFX_INLINE void IfxEgtm_Atom_Ch_setTriggerOutput(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_Ch_OutputTrigger trigger)
{
    atom->CH[channel].CTRL.B.TRIGOUT = (uint8)trigger;
}


IFX_INLINE void IfxEgtm_Atom_Agc_setChannelsUpdate(Ifx_EGTM_CLS_ATOM_AGC *agc, uint32 value)
{
    agc->GLB_CTRL.U = value;
}


IFX_INLINE uint32 IfxEgtm_Atom_Ch_getCounterValue(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel)
{
    return (uint32)(atom->CH[channel].CN0.U);
}


IFX_INLINE void IfxEgtm_Atom_Ch_setSomcControl(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_SomcControl control)
{
    atom->CH[channel].CTRL_SOMC.B.ACB42 = (uint8)control;
}


IFX_INLINE void IfxEgtm_Atom_Ch_setSomcSignalLevelControl(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, IfxEgtm_Atom_SomcSignalLevelControl ctrl)
{
    atom->CH[channel].CTRL_SOMC.B.ACB10 = (uint8)ctrl;
}


IFX_INLINE void IfxEgtm_Atom_setTout(uint32 toutNum, uint32 toutSel)
{
    uint32 outselReg = (toutNum / 6u);
    uint32 shift     = (toutNum % 6u) * 5u;

    if (shift >= 15u)
    {
        ++shift;
    }

    uint32 outsel = toutSel << shift;
    uint32 mask   = (uint32)0x1FU << shift;

    Ifx__ldmst(&(MODULE_EGTM.TOUTSEL[outselReg].U), mask, outsel);
}


IFX_INLINE void IfxEgtm_Atom_Agc_setInternalTrigger(Ifx_EGTM_CLS_ATOM_AGC *agc, IfxEgtm_Atom_Ch channel, boolean enabled)
{
    uint32 shift = IFXEGTM_ATOM_AGC_CHANNEL_SHIFT(channel, IFX_EGTM_CLS_ATOM_AGC_INT_TRIG_INT_TRIG0_OFF);
    uint32 value = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_VALUE(enabled) << shift;
    uint32 mask  = (uint32)IFXEGTM_ATOM_AGC_CHANNEL_MASK << shift;

    Ifx__ldmst(&(agc->INT_TRIG.U), mask, value);
}


IFX_INLINE void IfxEgtm_Atom_Ch_setHresEn(Ifx_EGTM_CLS_ATOM *atom, IfxEgtm_Atom_Ch channel, boolean enabled)
{
    atom->CH[channel].CTRL2.B.HRES = (uint8)enabled;
}


#endif /* IFXEGTM_ATOM_H */
