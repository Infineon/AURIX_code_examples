/**
 * \file IfxEgtm.h
 * \brief EGTM  basic functionality
 * \ingroup IfxLld_Egtm
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Egtm_Std_Functions Functions
 * \ingroup IfxLld_Egtm_Std
 * \defgroup IfxLld_Egtm_Std_Enumerations Enumerations
 * \ingroup IfxLld_Egtm_Std
 * \defgroup IfxLld_Egtm_Std_Structures Structures
 * \ingroup IfxLld_Egtm_Std
 */

#ifndef IFXEGTM_H
#define IFXEGTM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxEgtm_cfg.h"
#include "IfxEgtm_bf.h"
#include "Clock/Std/IfxClock.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Std_Enumerations
 * \{ */
/** \brief Defines the operation mode for the AEI bridge
 * For CLSi_AEI_BRIDGE_MODE.BRG_MODE
 */
typedef enum
{
    IfxEgtm_AeiBridgeOpMode_sync  = 0u, /**< \brief AEI bridge operates in sync_bridge mode */
    IfxEgtm_AeiBridgeOpMode_async = 1u  /**< \brief AEI bridge operates in async_bridge mode */
} IfxEgtm_AeiBridgeOpMode;

/** \brief Defines the cluster clock divider mode
 * For CLSi_ARCH_CLK_CFG.B.CLSj_CLK_DIV
 */
typedef enum
{
    IfxEgtm_ClusterClockDiv_disable    = 0u, /**< \brief Cluster is disabled */
    IfxEgtm_ClusterClockDiv_enable     = 1u, /**< \brief Cluster is enabled without clock divider */
    IfxEgtm_ClusterClockDiv_enableDiv2 = 2u  /**< \brief Cluster is enabled with clock divider 2 */
} IfxEgtm_ClusterClockDiv;

/** \brief Enum for EGTM interrupt modes
 */
typedef enum
{
    IfxEgtm_IrqMode_level       = 0,
    IfxEgtm_IrqMode_pulse       = 1,
    IfxEgtm_IrqMode_pulseNotify = 2,
    IfxEgtm_IrqMode_singlePulse = 3
} IfxEgtm_IrqMode;

/** \brief Enum for Msc Alt Input
 */
typedef enum
{
    IfxEgtm_MscAltInput_low     = 0,
    IfxEgtm_MscAltInput_lowext  = 1,
    IfxEgtm_MscAltInput_high    = 2,
    IfxEgtm_MscAltInput_highext = 3
} IfxEgtm_MscAltInput;

/** \brief OCDS Suspend Control (OCDS.SUS)
 */
typedef enum
{
    IfxEgtm_SuspendMode_none = 0,  /**< \brief No suspend */
    IfxEgtm_SuspendMode_hard = 1,  /**< \brief Hard Suspend */
    IfxEgtm_SuspendMode_soft = 2   /**< \brief Soft Suspend */
} IfxEgtm_SuspendMode;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Std_Structures
 * \{ */
/** \brief Cluster PROT and APU configuration
 */
typedef struct
{
    IfxApApu_ApuConfig apuConfig;       /**< \brief APU configuration */
} IfxEgtm_ClApConfig;

/** \brief CTRL PROT and APU configuration
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;       /**< \brief PROTE configuration */
    IfxApApu_ApuConfig   apuConfig;         /**< \brief APU configuration */
} IfxEgtm_CtrlApConfig;

/** \brief Wrap PROT and APU configuration
 */
typedef struct
{
    IfxApApu_ApuConfig apuConfig;       /**< \brief APU configuration */
} IfxEgtm_WrapApConfig;

/** \} */

/** \addtogroup IfxLld_Egtm_Std_Structures
 * \{ */
/** \brief PROT and APU configuration for GTM
 */
typedef struct
{
    IfxApProt_ProtConfig protseConfig;                              /**< \brief PROTSE configuration */
    IfxEgtm_ClApConfig   clApConfig[IFXEGTM_NUM_CCM_OBJECTS];       /**< \brief Cluster APU configuration */
    IfxEgtm_CtrlApConfig ctrlApConfig;                              /**< \brief Ctrl PROT and APU configuration */
    IfxEgtm_WrapApConfig wrapApConfig;                              /**< \brief Wrap APU configuration */
} IfxEgtm_ApConfig;

/** \brief MSc configuration Structure
 */
typedef struct
{
    IfxEgtm_Cfg_MscSet       mscSet;             /**< \brief MSC set value */
    IfxEgtm_Cfg_MscSetSignal mscSetSignal;       /**< \brief MSC set signal */
    IfxEgtm_Cfg_MscModule    mscModule;          /**< \brief MSC Module */
    IfxEgtm_Cfg_MscSelect    mscSelect;          /**< \brief MSC Select */
    IfxEgtm_MscAltInput      mscAltIn;           /**< \brief MSC Alt Input selection */
} IfxEgtm_MscOut;

/** \} */

/** \addtogroup IfxLld_Egtm_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disables the module
 * \param egtm Pointer to EGTM module
 * \return None
 */
IFX_INLINE void IfxEgtm_disable(Ifx_EGTM *egtm);

/** \brief Enables the module
 * \param egtm Pointer to EGTM module
 * \return None
 */
IFX_INLINE void IfxEgtm_enable(Ifx_EGTM *egtm);

/** \brief Returns the status of module enabled or disabled
 * \param egtm Pointer to EGTM module
 * \return status: TRUE/FALSE
 */
IFX_INLINE boolean IfxEgtm_isEnabled(Ifx_EGTM *egtm);

/** \brief Returns the module's suspend state.
 * TRUE :if module is suspended.
 * FALSE:if module is not yet suspended.
 * \param egtm Pointer to EGTM module registers
 * \return Suspend status (TRUE / FALSE)
 */
IFX_INLINE boolean IfxEgtm_isModuleSuspended(Ifx_EGTM *egtm);

/** \brief Configure the Module to Hard/Soft suspend mode.
 * Note: The api works only when the OCDS is enabled and in Supervisor Mode. When OCDS is disabled the OCS suspend control is ineffective.
 * \param egtm Pointer to EGTM module registers
 * \param mode Module suspend mode
 * \return None
 */
IFX_INLINE void IfxEgtm_setSuspendMode(Ifx_EGTM *egtm, IfxEgtm_SuspendMode mode);

/** \brief returns the EGTM SYSCLK frequency.
 * Refer to the Clock distribution for details on EGTM SYS CLK.
 * \return sysFreq
 */
IFX_INLINE uint32 IfxEgtm_getSysClkFrequency(void);

/** \brief returns the cluster frequency of the EGTM cluster.
 * If the cluster is disabled, then it will return 0 as frequency.
 * \param egtm pointer to egtm device
 * \param cluster index of cluster
 * \return cluster frequency
 */
IFX_INLINE uint32 IfxEgtm_getClusterFrequency(Ifx_EGTM *egtm, IfxEgtm_Cluster cluster);

/** \brief Convert timer ticks to seconds
 * \param clockFreq clockFreq Timer clock frequency
 * \param ticks ticks time value in ticks to be converted
 * \return Return the converted time in s
 */
IFX_INLINE float32 IfxEgtm_tickToS(float32 clockFreq, uint32 ticks);

/** \brief Convert seconds to timer ticks
 * \param clockFreq clockFreq Timer clock frequency
 * \param seconds seconds time value in seconds to be converted
 * \return Return the converted time in timer ticks
 */
IFX_INLINE uint32 IfxEgtm_sToTick(float32 clockFreq, float32 seconds);

/** \brief Initialize the PORT Safe Endinit
 * \param egtm Pointer to EGTM module
 * \param protseConfig Configuration pointer for the Prot
 * \return None
 */
IFX_INLINE void IfxEgtm_initProtSe(Ifx_EGTM *egtm, IfxApProt_ProtConfig *protseConfig);

/** \brief Initialize the PORTE for Control logic
 * \param egtm Pointer to EGTM module
 * \param ctrlProteConfig Configuration pointer for the Prot
 * \return None
 */
IFX_INLINE void IfxEgtm_initCtrlProt(Ifx_EGTM *egtm, IfxApProt_ProtConfig *ctrlProteConfig);

/** \brief Initialize the APU for the GTM Cluster
 * \param egtm Pointer to EGTM module
 * \param cluster Cluster index of GTM
 * \param clApuConfig Configuration pointer for the Apu
 * \return None
 */
IFX_INLINE void IfxEgtm_initClApu(Ifx_EGTM *egtm, IfxEgtm_Cluster cluster, IfxApApu_ApuConfig *clApuConfig);

/** \brief Initialize the APU for Control logic
 * \param egtm Pointer to EGTM module
 * \param ctrlApuConfig Configuration pointer for the Apu
 * \return None
 */
IFX_INLINE void IfxEgtm_initCtrlApu(Ifx_EGTM *egtm, IfxApApu_ApuConfig *ctrlApuConfig);

/** \brief Initialize the APU for Wrap logic
 * \param egtm Pointer to EGTM module
 * \param wrapApuConfig Configuration pointer for the Apu
 * \return None
 */
IFX_INLINE void IfxEgtm_initWrapApu(Ifx_EGTM *egtm, IfxApApu_ApuConfig *wrapApuConfig);

/** \brief Configure Cluster with clock divider
 * \param cluster Cluster of GTM which need to be set
 * \param clockDivider Choose the cluster clock divider mode
 * \return Operation status (TRUE / FALSE)
 */
IFX_INLINE boolean IfxEgtm_setClusterClockDiv(IfxEgtm_Cluster cluster, IfxEgtm_ClusterClockDiv clockDivider);

/** \brief Disable clock of cluster
 * \param cluster Cluster of GTM which need to be cleared
 * \return Operation status (TRUE / FALSE)
 */
IFX_INLINE boolean IfxEgtm_clearClusterClockDiv(IfxEgtm_Cluster cluster);

/** \brief set or clear Rf Prot bit
 * \param value value to be set for the RF PORT bit
 * \return None
 */
IFX_INLINE void IfxEgtm_setResetProtection(boolean value);

/** \brief get the status of Rf Prot bit
 * \return set status (TRUE / FALSE)
 */
IFX_INLINE boolean IfxEgtm_getResetProtection(void);

/** \brief Activates write buffer of AEI Bridge
 * EGTM_CLS0_AEI_BRIDGE_MODE.B.MSK_WR_RSP = 1
 * \param egtm Pointer to eGTM module
 * \return None
 */
IFX_INLINE void IfxEgtm_enableAeiBridgeWriteBuffer(Ifx_EGTM *egtm);

/** \brief Disables write buffer of AEI Bridge
 * EGTM_CLS0_AEI_BRIDGE_MODE.B.MSK_WR_RSP = 0
 * \param egtm Pointer to eGTM module
 * \return None
 */
IFX_INLINE void IfxEgtm_disableAeiBridgeWriteBuffer(Ifx_EGTM *egtm);

/** \brief Writes the operation mode for the AEI bridge
 * EGTM_CLS0_AEI_BRIDGE_MODE.B.BRG_MODE = mode
 * \param egtm Pointer to GTM module
 * \param mode Choose the operation mode
 * \return None
 */
IFX_INLINE void IfxEgtm_setAeiBridgeOpMode(Ifx_EGTM *egtm, IfxEgtm_AeiBridgeOpMode mode);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief GTM connection to MSC
 * \param egtmCluster Cluster of EGTM which contains the trigger source
 * \param egtmSource Trigger source selected (Atom or Tom)
 * \param Channel channel within the egtmSource
 * \param mscOut msc connection details
 * \return TRUE on success else FALSE
 */
IFX_EXTERN boolean IfxEgtm_ConnectToMsc(IfxEgtm_Cluster egtmCluster, IfxEgtm_TrigSource egtmSource, IfxEgtm_TrigChannel Channel, IfxEgtm_MscOut *mscOut);

/** \brief Initialize the PROTs and APUs with default configuration
 * \param config Configuration pointer for the Access Protection
 * \return None
 */
IFX_EXTERN void IfxEgtm_initApConfig(IfxEgtm_ApConfig *config);

/** \brief Initialize the PORTs and APU
 * \param egtm Pointer to EGTM module
 * \param config Configuration pointer for the Access Protection
 * \return None
 */
IFX_EXTERN void IfxEgtm_initAp(Ifx_EGTM *egtm, IfxEgtm_ApConfig *config);

/** \brief Configures access to all masters to all the eGTMs in the device
 * \param apConfig pointer to configuration structure.
 * \return None
 */
IFX_EXTERN void IfxEgtm_configureAccessToEgtms(IfxApApu_ApuConfig *apConfig);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxEgtm_disable(Ifx_EGTM *egtm)
{
#if defined(IFX_PROT_ENABLED)
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&egtm->CTRL.PROTE, IfxApProt_State_config);
#endif
#endif
    egtm->CLC.B.DISR = 1u;
#if defined(IFX_PROT_ENABLED)
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&egtm->CTRL.PROTE, IfxApProt_State_run);
#endif
#endif
}


IFX_INLINE void IfxEgtm_enable(Ifx_EGTM *egtm)
{
#if defined(IFX_PROT_ENABLED)
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&egtm->CTRL.PROTE, IfxApProt_State_config);
#endif
#endif
    egtm->CLC.B.DISR = 0u;
#if defined(IFX_PROT_ENABLED)
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&egtm->CTRL.PROTE, IfxApProt_State_run);
#endif
#endif
}


IFX_INLINE boolean IfxEgtm_isEnabled(Ifx_EGTM *egtm)
{
    boolean enabled;
    enabled = (egtm->CLC.B.DISS == (uint8)0u) ? TRUE : FALSE;
    return enabled;
}


IFX_INLINE boolean IfxEgtm_isModuleSuspended(Ifx_EGTM *egtm)
{
    Ifx_EGTM_OCS ocs;

    /* Read the status */
    ocs.U = egtm->OCS.U;

    /* Return the status */
    return ocs.B.SUSSTA;
}


IFX_INLINE void IfxEgtm_setSuspendMode(Ifx_EGTM *egtm, IfxEgtm_SuspendMode mode)
{
    Ifx_EGTM_OCS ocs;

    /* Remove protection and configure the suspend mode. */
    ocs.B.SUS_P = 1u;
    ocs.B.SUS   = (uint8)mode;

    egtm->OCS.U = ocs.U;
}


IFX_INLINE uint32 IfxEgtm_getSysClkFrequency(void)
{
    return IfxClock_geteGtmFrequency();
}


IFX_INLINE uint32 IfxEgtm_getClusterFrequency(Ifx_EGTM *egtm, IfxEgtm_Cluster cluster)
{
    uint32 Freq;
    uint8  clsDiv = 0u;
    clsDiv = (uint8)(((egtm->CLS->ARCH.CLK_CFG.U) >> ((uint8)cluster << 1u)) & 0x3U);

    if (clsDiv == 0u)
    {
        Freq = (uint32)0u; /* cluster is disabled - return 0 */
    }
    else
    {
        Freq = IfxEgtm_getSysClkFrequency() / clsDiv;
    }

    return Freq;
}


IFX_INLINE float32 IfxEgtm_tickToS(float32 clockFreq, uint32 ticks)
{
    return (float32)ticks / clockFreq;
}


IFX_INLINE uint32 IfxEgtm_sToTick(float32 clockFreq, float32 seconds)
{
    return (uint32)((float32)(seconds * clockFreq));
}


IFX_INLINE void IfxEgtm_initProtSe(Ifx_EGTM *egtm, IfxApProt_ProtConfig *protseConfig)
{
    (void)IfxApProt_init((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->PROTSE), protseConfig);
}


IFX_INLINE void IfxEgtm_initCtrlProt(Ifx_EGTM *egtm, IfxApProt_ProtConfig *ctrlProteConfig)
{
    (void)IfxApProt_init((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->CTRL.PROTE), ctrlProteConfig);
}


IFX_INLINE void IfxEgtm_initClApu(Ifx_EGTM *egtm, IfxEgtm_Cluster cluster, IfxApApu_ApuConfig *clApuConfig)
{
    (void)IfxApProt_setState((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->PROTSE), IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)(volatile void *)&(egtm->CL[cluster].ACCEN), clApuConfig);
    (void)IfxApProt_setState((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->PROTSE), IfxApProt_State_run);
}


IFX_INLINE void IfxEgtm_initCtrlApu(Ifx_EGTM *egtm, IfxApApu_ApuConfig *ctrlApuConfig)
{
    (void)IfxApProt_setState((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->PROTSE), IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)(volatile void *)&(egtm->CTRL.ACCEN), ctrlApuConfig);
    (void)IfxApProt_setState((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->PROTSE), IfxApProt_State_run);
}


IFX_INLINE void IfxEgtm_initWrapApu(Ifx_EGTM *egtm, IfxApApu_ApuConfig *wrapApuConfig)
{
    (void)IfxApProt_setState((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->PROTSE), IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)(volatile void *)&(egtm->WRAP.ACCEN), wrapApuConfig);
    (void)IfxApProt_setState((volatile Ifx_PROT_PROT *)(volatile void *)&(egtm->PROTSE), IfxApProt_State_run);
}


IFX_INLINE boolean IfxEgtm_setClusterClockDiv(IfxEgtm_Cluster cluster, IfxEgtm_ClusterClockDiv clockDivider)
{
    uint32  shift    = (uint32)cluster << 1u;
    uint32  setValue = (uint32)clockDivider << shift;
    uint32  mask     = (uint32)0x3U << shift;
    boolean result   = FALSE;

    boolean status   = IfxEgtm_getResetProtection();

    if (status == FALSE)
    {
        Ifx__ldmst(&(MODULE_EGTM.CLS[0].ARCH.CLK_CFG.U), mask, setValue);
        result = TRUE;
    }

    return result;
}


IFX_INLINE boolean IfxEgtm_clearClusterClockDiv(IfxEgtm_Cluster cluster)
{
    uint32  shift    = (uint32)cluster << 1u;
    uint32  setValue = 0u;
    uint32  mask     = (uint32)0x3U << shift;
    boolean result   = FALSE;

    boolean status   = IfxEgtm_getResetProtection();

    if (status == FALSE)
    {
        Ifx__ldmst(&(MODULE_EGTM.CLS[0].ARCH.CLK_CFG.U), mask, setValue);
        result = TRUE;
    }

    return result;
}


IFX_INLINE void IfxEgtm_setResetProtection(boolean value)
{
    MODULE_EGTM.CLS[0].ARCH.CTRL.B.RF_PROT = value;
}


IFX_INLINE boolean IfxEgtm_getResetProtection(void)
{
    boolean result;
    result = MODULE_EGTM.CLS[0].ARCH.CTRL.B.RF_PROT;
    return result;
}


IFX_INLINE void IfxEgtm_enableAeiBridgeWriteBuffer(Ifx_EGTM *egtm)
{
    egtm->CLS[0].AEI.BRIDGE_MODE.B.MSK_WR_RSP = (uint8)TRUE;
}


IFX_INLINE void IfxEgtm_disableAeiBridgeWriteBuffer(Ifx_EGTM *egtm)
{
    egtm->CLS[0].AEI.BRIDGE_MODE.B.MSK_WR_RSP = (uint8)FALSE;
}


IFX_INLINE void IfxEgtm_setAeiBridgeOpMode(Ifx_EGTM *egtm, IfxEgtm_AeiBridgeOpMode mode)
{
    egtm->CLS[0].AEI.BRIDGE_MODE.B.BRG_MODE = (uint8)mode;
}


#endif /* IFXEGTM_H */
