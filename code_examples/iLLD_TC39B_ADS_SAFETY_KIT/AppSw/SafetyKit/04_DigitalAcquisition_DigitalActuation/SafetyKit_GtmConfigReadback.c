/**********************************************************************************************************************
 * \file SafetyKit_GtmConfigReadback.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyKit_GtmConfigReadback.h"
#include "SafetyKit_Main.h"
#include "SafetyKit_Cfg.h"
#include "IfxGtm.h"
#include "IfxGtm_Tom_Pwm.h"
#include "IfxGtm_Tim_In.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
uint32 safetyKitConfigCheckTomTgcBuildFeatureForChannel (IfxGtm_Tom_Ch channel, boolean enabled, uint8 bitfieldOffset);
boolean safetyKitConfigCheckTomTgcEnableChannelUpdate (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled);
boolean safetyKitConfigCheckTomTgcSetChannelForceUpdate (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean resetEnabled);
boolean safetyKitConfigCheckPinMapSetTomTout (IfxGtm_Tom_ToutMap *config, IfxPort_OutputMode outputMode,
        IfxPort_PadDriver padDriver);
boolean safetyKitConfigCheckTomTgcEnableChannel (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate);
boolean safetyKitConfigCheckTomTgcEnableChannelOutput (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate);
boolean safetyKitConfigCheckTomChSetNotification (Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_IrqMode mode,
        boolean interruptOnCompareZero, boolean interruptOnCompareOne);

boolean safetyKitConfigCheckTimChSetChannelNotification (Ifx_GTM_TIM_CH *channel, boolean irqOnNewVal,
        boolean irqOnCntOverflow, boolean irqOnEcntOverflow, boolean irqOnDatalost);
boolean safetyKitConfigCheckPinMapSetTimIn (IfxGtm_Tim_TinMap *config, IfxPort_InputMode inputMode);

boolean safetyKitConfigCheckSrcInitAndEnable (volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService,
        Ifx_Priority priority);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * This function, validate if configuration of TOM was written successfully to the registers
 * */
void safetyKitTomPwmConfigReadBack(const IfxGtm_Tom_Pwm_Config *config, IfxSmu_Alarm alarm)
{
    boolean configValidated = TRUE;

    /* This check is based on IfxGtm_Tom_Pwm_init */
    Ifx_GTM_TOM     *tomSFR = &config->gtm->TOM[config->tom];
    Ifx_GTM_TOM_CH  *tomCh  = IfxGtm_Tom_Ch_getChannelPointer(tomSFR, config->tomChannel);
    Ifx_GTM_TOM_TGC *tgc[2];

#if defined(IFXGTM_DTM_AVAILABLE)
#error "DTM Config Read back is not implemented"
#endif

    if (config->tomChannel <= 7)
    {
        tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(tomSFR, 0);
        tgc[1] = IfxGtm_Tom_Ch_getTgcPointer(tomSFR, 1);
    }
    else
    {
        tgc[0] = IfxGtm_Tom_Ch_getTgcPointer(tomSFR, 1);
        tgc[1] = NULL_PTR; /* NOTE currently no concatenation between TOMs */
    }

    /* Check the timer part */
    if (config->synchronousUpdateEnabled == 1)
    {
        configValidated &= safetyKitConfigCheckTomTgcEnableChannelUpdate(tgc[0], config->tomChannel, TRUE);
    }

    configValidated &= (config->clock == IfxGtm_Tom_Ch_getClockSource(tomSFR, config->tomChannel));

    configValidated &= safetyKitConfigCheckTomTgcSetChannelForceUpdate(tgc[0], config->tomChannel, TRUE, TRUE);

    configValidated &= (config->signalLevel == (tomCh->CTRL.B.SL == 1 ? Ifx_ActiveState_high : Ifx_ActiveState_low));

    if (config->pin.outputPin != NULL_PTR)
    {
        configValidated &= safetyKitConfigCheckPinMapSetTomTout(config->pin.outputPin, config->pin.outputMode,
                config->pin.padDriver);
    }

    /* Check interrupt configuration if enabled */
    if ((config->interrupt.ccu0Enabled == 1) || (config->interrupt.ccu1Enabled == 1))
    {
        configValidated &= safetyKitConfigCheckTomChSetNotification(tomSFR, config->tomChannel, config->interrupt.mode,
                config->interrupt.ccu0Enabled, config->interrupt.ccu1Enabled);
        volatile Ifx_SRC_SRCR *src;
        src = IfxGtm_Tom_Ch_getSrcPointer(config->gtm, config->tom, config->tomChannel);
        safetyKitConfigCheckSrcInitAndEnable(src, config->interrupt.isrProvider, config->interrupt.isrPriority);
    }

    if (config->synchronousUpdateEnabled == 1)
    {
        configValidated &= (config->period == tomCh->SR0.U);
        configValidated &= (config->dutyCycle == tomCh->SR1.U);
    }
    else
    {
        configValidated &= (config->period == tomCh->CM0.U);
        configValidated &= (config->dutyCycle == tomCh->CM1.U);
    }

    configValidated &= safetyKitConfigCheckTomTgcEnableChannel(tgc[0], config->tomChannel, TRUE, FALSE);
    configValidated &= safetyKitConfigCheckTomTgcEnableChannelOutput(tgc[0], config->tomChannel, TRUE, FALSE);


#if defined(IFXGTM_DTM_AVAILABLE)
#error "DTM Config Read back is not implemented"
#endif

    if(configValidated == FALSE)
    {
        softwareCoreAlarmTriggerSMU(alarm);
    }
}

/*
 * This function, validate if configuration of TIM was written successfully to the registers
 * */
void safetyKitTimInConfigReadback(const IfxGtm_Tim_In_Config *config, IfxSmu_Alarm alarm)
{
    boolean configValidated = TRUE;

    /* This check is based on the iLLD function IfxGtm_Tim_In_init */
    Ifx_GTM_TIM_CH     *channel;

    IfxGtm_Tim_Ch       channelIndex;
    IfxGtm_Tim          timIndex;
    IfxGtm_Tim_In_Input input;

    if (config->filter.inputPin != NULL_PTR)
    {
        channelIndex = config->filter.inputPin->channel;
        timIndex     = config->filter.inputPin->tim;
        input        = IfxGtm_Tim_In_Input_currentChannel;
    }
    else
    {
        channelIndex = config->channelIndex;
        timIndex     = config->timIndex;
        input        = config->filter.input;
    }

    channel = IfxGtm_Tim_getChannel(&config->gtm->TIM[timIndex], channelIndex);

    configValidated &= (IfxGtm_Tim_Mode_pwmMeasurement == channel->CTRL.B.TIM_MODE);

    configValidated &= (config->capture.clock == IfxGtm_Tim_Ch_getCaptureClockSource(channel));

    if(config->capture.mode == Ifx_Pwm_Mode_leftAligned)
    {
        configValidated &= ( channel->CTRL.B.DSL == 1 );
    }
    else if(config->capture.mode == Ifx_Pwm_Mode_rightAligned)
    {
        configValidated &= ( channel->CTRL.B.DSL == 0 );
    }

    configValidated &= (IfxGtm_Tim_CntsSel_cntReg == channel->CTRL.B.CNTS_SEL);
    configValidated &= (IfxGtm_Tim_GprSel_cnts == channel->CTRL.B.GPR0_SEL);
    configValidated &= (IfxGtm_Tim_GprSel_cnts == channel->CTRL.B.GPR1_SEL);

    /* Validate interrupt configuration */
    if (config->isrPriority)
    {
        volatile Ifx_SRC_SRCR *src;
        configValidated &= ( channel->IRQ.MODE.B.IRQ_MODE == config->irqMode );
        configValidated &= safetyKitConfigCheckTimChSetChannelNotification(channel, config->capture.irqOnNewVal,
                config->capture.irqOnCntOverflow, config->capture.irqOnEcntOverflow, config->capture.irqOnDatalost);

        src = IfxGtm_Tim_Ch_getSrcPointer(config->gtm, timIndex, channelIndex);
        safetyKitConfigCheckSrcInitAndEnable(src, config->isrProvider, config->isrPriority);
    }

    /* Validate input configuration */

    uint32 mask;
    mask = 0x3 << channelIndex * (IFX_GTM_TIM_IN_SRC_MODE_1_OFF - IFX_GTM_TIM_IN_SRC_MODE_0_OFF);
    configValidated     &= ((config->gtm->TIM[timIndex].IN_SRC.U & mask) == 0 << (IFX_GTM_TIM_IN_SRC_MODE_0_OFF +
                             channelIndex * (IFX_GTM_TIM_IN_SRC_MODE_1_OFF - IFX_GTM_TIM_IN_SRC_MODE_0_OFF))); /*MODE0*/

    mask = 0x3 << channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF);
    switch (input)
    {
        case IfxGtm_Tim_In_Input_currentChannel:
            configValidated &= ( (config->gtm->TIM[timIndex].IN_SRC.U & mask) == 0 << (IFX_GTM_TIM_IN_SRC_VAL_0_OFF + \
                                  channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF)) );/*VAL0*/
            configValidated &= ( channel->CTRL.B.CICTRL == IfxGtm_Tim_Input_currentChannel );
            break;
        case IfxGtm_Tim_In_Input_adjacentChannel:
            configValidated &= ( (config->gtm->TIM[timIndex].IN_SRC.U & mask) == 0 << (IFX_GTM_TIM_IN_SRC_VAL_0_OFF + \
                                  channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF)) );/*VAL0*/
            configValidated &= ( channel->CTRL.B.CICTRL == IfxGtm_Tim_Input_adjacentChannel );
            break;
        case IfxGtm_Tim_In_Input_aux:
            configValidated &= ( (config->gtm->TIM[timIndex].IN_SRC.U & mask) == 3 << (IFX_GTM_TIM_IN_SRC_VAL_0_OFF + \
                                  channelIndex * (IFX_GTM_TIM_IN_SRC_VAL_1_OFF - IFX_GTM_TIM_IN_SRC_VAL_0_OFF)) );/*VAL1*/
            break;
        default:
            __debug();
            break;
    }

    if (config->filter.inputPin != NULL_PTR)
    {
        configValidated &= safetyKitConfigCheckPinMapSetTimIn(config->filter.inputPin, config->filter.inputPinMode);
    }


    /* Validate filter configuration */
    if ((config->filter.fallingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none) ||
        (config->filter.risingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none))
    {
        float32 clockFrequency;
        sint32  fallingfilterTime;
        sint32  risingfilterTime;

        configValidated &= ( channel->CTRL.B.FLT_EN == 1 );
        configValidated &= ( channel->CTRL.B.FLT_CNT_FRQ == config->filter.clock );

        clockFrequency = IfxGtm_Tim_Ch_getFilterClockFrequency(config->gtm, channel);

        fallingfilterTime = (uint32) (config->filter.fallingEdgeFilterTime * clockFrequency) - 1;

        if (fallingfilterTime < 0)
        {
            fallingfilterTime = 0;
        }
        else if (fallingfilterTime > (sint32)IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK)
        {
            fallingfilterTime = IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK;
            configValidated &= FALSE;
        }

        configValidated &= (channel->FLT_FE.B.FLT_FE == fallingfilterTime);

        risingfilterTime = (uint32) (config->filter.risingEdgeFilterTime * clockFrequency) - 1;

        if (risingfilterTime < 0)
        {
            risingfilterTime = 0;
        }
        else if (risingfilterTime > (sint32)IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK)
        {
            risingfilterTime = IFX_GTM_TIM_CH_FLT_FE_FLT_FE_MSK;
            configValidated &= FALSE;
        }

        configValidated &= ( channel->FLT_RE.B.FLT_RE == risingfilterTime );

        if (config->filter.fallingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none)
        {
            if (config->filter.fallingEdgeMode == IfxGtm_Tim_In_ConfigFilterMode_immediateEdgePropagation)
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_FE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            }
            else
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_FE == IfxGtm_Tim_FilterMode_individualDeglitchTime );
                configValidated &= (
                        channel->CTRL.B.FLT_CTR_FE == config->filter.fallingEdgeMode
                                == IfxGtm_Tim_In_ConfigFilterMode_individualDeglitchTimeUpDown ?
                                IfxGtm_Tim_FilterCounter_upDown : IfxGtm_Tim_FilterCounter_hold);
            }
        }
        else
        {
            configValidated &= ( channel->CTRL.B.FLT_MODE_FE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            configValidated &= ( channel->FLT_FE.B.FLT_FE == 0 );
        }

        if (config->filter.risingEdgeMode != IfxGtm_Tim_In_ConfigFilterMode_none)
        {
            if (config->filter.risingEdgeMode == IfxGtm_Tim_In_ConfigFilterMode_immediateEdgePropagation)
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_RE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            }
            else
            {
                configValidated &= ( channel->CTRL.B.FLT_MODE_RE == IfxGtm_Tim_FilterMode_individualDeglitchTime );
                configValidated &= (
                        channel->CTRL.B.FLT_CTR_RE == IfxGtm_Tim_In_ConfigFilterMode_individualDeglitchTimeUpDown ?
                                IfxGtm_Tim_FilterCounter_upDown : IfxGtm_Tim_FilterCounter_hold);
            }
        }
        else
        {
            configValidated &= ( channel->CTRL.B.FLT_MODE_RE == IfxGtm_Tim_FilterMode_immediateEdgePropagation );
            configValidated &= ( channel->FLT_RE.B.FLT_RE == 0 );
        }

        configValidated &= ( channel->IRQ.EN.B.GLITCHDET_IRQ_EN == config->filter.irqOnGlitch ? 1 : 0 );
    }

    /* Validate if TIM channel is enabled */
    configValidated &= ( channel->CTRL.B.TIM_EN == 1 );

    if(configValidated == FALSE)
    {
        softwareCoreAlarmTriggerSMU(alarm);
    }
}

/*
 * This function, validate if configuration of TOM TGC was written successfully to the registers
 * */
uint32 safetyKitConfigCheckTomTgcBuildFeatureForChannel(IfxGtm_Tom_Ch channel, boolean enabled, uint8 bitfieldOffset)
{
    uint32 reg = 0;

    /* Bitfield length is 2 bits */
    uint8  shift = ((channel % 8) * 2) + bitfieldOffset;

    if (enabled == 1)
    {
        reg = (IfxGtm_FeatureControl_enable + 1)<< shift;
    }
    else
    {
        reg = (IfxGtm_FeatureControl_disable - 1) << shift;
    }

    return reg;
}

/*
 * This function, validate if configuration of TOM TGC enable channel update was written successfully
 * */
boolean safetyKitConfigCheckTomTgcEnableChannelUpdate(Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled)
{
    uint32 expectedRegVal = safetyKitConfigCheckTomTgcBuildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
    /* Bitfield length is 2 bits */
    uint32 mask = 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF;
    return (tgc->GLB_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
}

/*
 * This function, validate if configuration of TOM TGC force update was written successfully
 * */
boolean safetyKitConfigCheckTomTgcSetChannelForceUpdate (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean resetEnabled)
{
    uint32 regEnable, regReset;

    regEnable = safetyKitConfigCheckTomTgcBuildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_FUPD_CTRL_FUPD_CTRL0_OFF);
    regReset = safetyKitConfigCheckTomTgcBuildFeatureForChannel(channel, resetEnabled,
            IFX_GTM_TOM_TGC_FUPD_CTRL_RSTCN0_CH0_OFF);

    /* Bitfield length is 2 bits */
    uint32 mask = 0;
    mask |= 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_FUPD_CTRL_FUPD_CTRL0_OFF;
    mask |= 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_FUPD_CTRL_RSTCN0_CH0_OFF;

    uint32 expectedRegVal = regEnable | (regReset << 16);

    return (tgc->FUPD_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
}

/*
 * This function, validate if configuration of pin map set to TOM TOUT was written successfully
 * */
boolean safetyKitConfigCheckPinMapSetTomTout (IfxGtm_Tom_ToutMap *config, IfxPort_OutputMode outputMode,
        IfxPort_PadDriver padDriver)
{
    /* based on IfxGtm_PinMap_setTomTout */
    uint32 outselReg = (config->toutn >> 3);
    uint32 shift = (config->toutn & 0x7U) * 4;
    uint32 outsel = (uint32)config->toutSel << shift;
    uint32 mask = 0xFU << shift;

    return (MODULE_GTM.TOUTSEL[outselReg].U & mask) == outsel ? TRUE : FALSE;
}

/*
 * This function, validate if configuration of TOM TGC enable channel was written successfully
 * */
boolean safetyKitConfigCheckTomTgcEnableChannel (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate)
{
    boolean retVal = TRUE;
    uint32 expectedRegVal = IfxGtm_Tom_Tgc_buildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_ENDIS_CTRL_ENDIS_CTRL0_OFF);

    /* Bitfield length is 2 bits */
    uint32 mask = 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_ENDIS_CTRL_ENDIS_CTRL0_OFF;

    if (immediate)
    {
        retVal &= (tgc->ENDIS_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
        retVal &= (tgc->ENDIS_STAT.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    else
    {
        retVal &= (tgc->ENDIS_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    return retVal;
}

/*
 * This function, validate if configuration of TOM TGC enable channel output was written successfully
 * */
boolean safetyKitConfigCheckTomTgcEnableChannelOutput (Ifx_GTM_TOM_TGC *tgc, IfxGtm_Tom_Ch channel, boolean enabled,
        boolean immediate)
{
    boolean retVal = TRUE;
    uint32 expectedRegVal = IfxGtm_Tom_Tgc_buildFeatureForChannel(channel, enabled,
            IFX_GTM_TOM_TGC_OUTEN_CTRL_OUTEN_CTRL0_OFF);
    /* Bitfield length is 2 bits */
    uint32 mask = 0x3 << ((channel % 8) * 2) + IFX_GTM_TOM_TGC_OUTEN_CTRL_OUTEN_CTRL0_OFF;

    if (immediate)
    {
        retVal &= (tgc->OUTEN_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
        retVal &= (tgc->OUTEN_STAT.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    else
    {
        retVal &= (tgc->OUTEN_CTRL.U & mask) == expectedRegVal ? TRUE : FALSE;
    }
    return retVal;
}

/*
 * This function, validate if configuration of TOM channel notification set was written successfully
 * */
boolean safetyKitConfigCheckTomChSetNotification (Ifx_GTM_TOM *tom, IfxGtm_Tom_Ch channel, IfxGtm_IrqMode mode,
        boolean interruptOnCompareZero, boolean interruptOnCompareOne)
{
    boolean retVal = TRUE;
    Ifx_GTM_TOM_CH       *tomCh = IfxGtm_Tom_Ch_getChannelPointer(tom, channel);

    Ifx_GTM_TOM_CH_IRQ_EN IRQ_EN_expectedRegVal;
    IRQ_EN_expectedRegVal.B.CCU0TC_IRQ_EN = interruptOnCompareZero ? 1 : 0;
    IRQ_EN_expectedRegVal.B.CCU1TC_IRQ_EN = interruptOnCompareOne  ? 1 : 0;

    Ifx_GTM_TOM_CH_IRQ_MODE IRQ_MODE_expectedVal;
    IRQ_MODE_expectedVal.B.IRQ_MODE    = mode;

    retVal &= tomCh->IRQ.MODE.B.IRQ_MODE == IRQ_MODE_expectedVal.B.IRQ_MODE ? TRUE : FALSE;
    retVal &= tomCh->IRQ.EN.U == IRQ_EN_expectedRegVal.U ? TRUE : FALSE;

    return retVal;
}

/*
 * This function, validate if configuration of TIM channel notification set was written successfully
 * */
boolean safetyKitConfigCheckTimChSetChannelNotification (Ifx_GTM_TIM_CH *channel, boolean irqOnNewVal,
        boolean irqOnCntOverflow, boolean irqOnEcntOverflow, boolean irqOnDatalost)
{
    boolean retVal = TRUE;

    Ifx_GTM_TIM_CH_IRQ_EN IRQ_EN_expectedRegVal;
    IRQ_EN_expectedRegVal.B.NEWVAL_IRQ_EN  = irqOnNewVal ? 1 : 0;
    IRQ_EN_expectedRegVal.B.CNTOFL_IRQ_EN  = irqOnCntOverflow ? 1 : 0;
    IRQ_EN_expectedRegVal.B.ECNTOFL_IRQ_EN = irqOnEcntOverflow ? 1 : 0;
    IRQ_EN_expectedRegVal.B.GPROFL_IRQ_EN  = irqOnDatalost ? 1 : 0;

    retVal &= channel->IRQ.EN.U == IRQ_EN_expectedRegVal.U ? TRUE : FALSE;

    return retVal;
}

/*
 * This function, validate if configuration of pin map set to TIM IN was written successfully
 * */
boolean safetyKitConfigCheckPinMapSetTimIn(IfxGtm_Tim_TinMap *config, IfxPort_InputMode inputMode)
{
    /* based on IfxGtm_PinMap_setTimTin */
    boolean retVal = TRUE;

    uint32 shift = config->channel * 4;
    uint32 mask = (0xFU << shift);
    uint32 expected = ((uint32)config->select) << shift;

    retVal &= ( MODULE_GTM.TIMINSEL[config->tim].U & mask ) == expected ? TRUE : FALSE;
    if (inputMode != IfxPort_InputMode_undefined)
    {
        volatile Ifx_P_IOCR0    *iocr      = &(config->pin.port->IOCR0);
        uint8                   iocrIndex = (config->pin.pinIndex / 4);
        uint8                   shift     = (config->pin.pinIndex & 0x3U) * 8;
                                mask      = (0xFFUL << shift);
                                expected  = (inputMode << shift);

        retVal &= ( iocr[iocrIndex].U & mask ) == expected ? TRUE : FALSE;
    }

    return retVal;
}

/*
 * This function, validate if configuration of SRC init and enable was written successfully
 * */
boolean safetyKitConfigCheckSrcInitAndEnable (volatile Ifx_SRC_SRCR *src, IfxSrc_Tos typOfService,
        Ifx_Priority priority)
{
    boolean retVal = TRUE;
    retVal &= src->B.SRPN   == priority;
    retVal &= src->B.TOS    == typOfService;
    retVal &= src->B.SRE    == 1;
    return retVal;
}
