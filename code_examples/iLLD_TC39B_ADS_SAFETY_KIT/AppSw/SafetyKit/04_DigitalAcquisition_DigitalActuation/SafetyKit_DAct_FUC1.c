/**********************************************************************************************************************
 * \file SafetyKit_DAct_FUC1.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/* Digital Actuation with redundant TOM/CCU6 channels and IOM comparison
 * The CPU or DMA generates an output digital signal request, e.g. PWM period and duty cycle.
 * The GTM output resource (TOM or ATOM) is used to generate the PWM signal which shall be fed back
 * from the external actuator to an MCU input port.
 * The CCU6 output resource is used to generate the internal reference PWM signal
 * to be compared by the IOM against received PWM signal from the external actuator.
 * Following SM is required:
 * SM:IOM_ALARM_CHECK
 *
 * SM:IOM_CONFIG_FOR_GTM
 * SM:GTM_CONFIG_FOR ATOM (not implemented)
 *
 * GTM ATOM0 Ch0 TOUT9 on pin P00.0 (GTM_ATOM_SAFE_PIN) is used for the generation of the output PWM mission signal which
 * is connected as monitoring input to the IOM
 * CCU6 module1 channel 1 on pin P00.3 (CCU6_REF_PIN) is used for the redundant output PWM signal which is connected as
 * reference input to the IOM
 * Pin P33.1 (IOM_MONITOR_INPUT) which is connected to the PWM output signal is used as the IOM monitoring input
 * CCU6 module1 channel 1 (IOM_CCU6_REFERENCE_INPUT) which is connected to the PWM reference signal is used as the IOM
 * reference input
 *
 * This example is also referred as "CCU6IOM out" example
 * */

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyKit_DA_global.h"
#include "SafetyKit_DAct_FUC1.h"
#include "SafetyKit_Main.h"
#include "SafetyKit_Cfg.h"
#include "IfxCcu6_Timer.h"
#include "IfxGtm_Atom_Pwm.h"
#include "IfxCcu6_TPwm.h"
#include "IfxIom.h"
#include "IfxIom_Driver.h"
#include "IfxSmu.h"
#include "conio_tft.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IFX_EXTERN IfxGtm_Atom_Pwm_Driver   g_atomPwmMissionHandler;
IFX_EXTERN IfxCcu6_TPwm             g_ccu61PwmReferenceHandler;

IfxIom_Driver                       g_iomDriverDActFUC1;          /* IOM driver handle */
IfxIom_Driver_Lam                   g_iomLamDActFUC1;             /* IOM LAM driver handle */
IfxIom_Driver_Config                g_iomConfigDriverDActFUC1;    /* IOM driver configuration */
IfxIom_Driver_LamConfig             g_iomConfigLamDActFUC1;       /* IOM LAM configuration */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * initial Digital Actuation FUC 1
 * */
void initDActFuc1(void)
{
    resetDAconfiguration();

    /* Disable clk0 for configuration and synchronous start of the clocks afterwards */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKDIS_CLK0);

    /*---------------------------------------------------------------------------------------------*/
    /*                  Part 1: Configure GTM ATOM for the output PWM mission signal               */
    /*---------------------------------------------------------------------------------------------*/
    IfxGtm_Atom_Pwm_Config pwmOutputMissionSignalConfig;
    IfxGtm_Atom_Pwm_initConfig(&pwmOutputMissionSignalConfig, &MODULE_GTM);

    pwmOutputMissionSignalConfig.atom                       = GTM_ATOM_SAFE_PIN.atom;
    pwmOutputMissionSignalConfig.atomChannel                = GTM_ATOM_SAFE_PIN.channel;
    pwmOutputMissionSignalConfig.pin.outputPin              = &GTM_ATOM_SAFE_PIN;
    pwmOutputMissionSignalConfig.synchronousUpdateEnabled   = TRUE; /* Enable synchronous update */
    pwmOutputMissionSignalConfig.period                     = ATOM_CCU6_PWM_PERIOD;
    pwmOutputMissionSignalConfig.dutyCycle                  =
            (uint32) (ATOM_CCU6_DUTY_CYCLE * 0.01 * pwmOutputMissionSignalConfig.period);
    pwmOutputMissionSignalConfig.immediateStartEnabled      = FALSE; /* Disable immediate start */

    /* Initialize the GTM ATOM */
    boolean success = IfxGtm_Atom_Pwm_init(&g_atomPwmMissionHandler, &pwmOutputMissionSignalConfig);
    if(!success)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_GTM_TIM_CCU6);
        return;
    }

    /*---------------------------------------------------------------------------------------------*/
    /*            Part 2: Configure a CCU6 channel for the output PWM reference signal             */
    /*---------------------------------------------------------------------------------------------*/
    IfxCcu6_TPwm_Config pwmOutputReferenceSignalConfig;
    /* Initialize default parameters */
    IfxCcu6_TPwm_initModuleConfig(&pwmOutputReferenceSignalConfig, CCU6_REF_PIN.module);

    /* Set same frequency as configured for CMU CLK0 which is used by ATOM */
    pwmOutputReferenceSignalConfig.base.frequency = IfxGtm_Cmu_getClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, TRUE);
    pwmOutputReferenceSignalConfig.base.period = ATOM_CCU6_PWM_PERIOD;
    pwmOutputReferenceSignalConfig.base.waitingTime = 0;
    /*select the active state of the output */
    pwmOutputReferenceSignalConfig.base.activeState = pwmOutputMissionSignalConfig.signalLevel;

    /* select the timer through which PWM is to be generated */
    pwmOutputReferenceSignalConfig.timer = IfxCcu6_TimerId_t12;

    /* Configure the clock for internal mode */
    pwmOutputReferenceSignalConfig.clock.t12ExtClockEnabled = FALSE;
    pwmOutputReferenceSignalConfig.clock.t12countingInputMode = IfxCcu6_CountingInputMode_internal;

    /* Configure the selected timer block */
    pwmOutputReferenceSignalConfig.timer12.channelId        = IfxCcu6_T12Channel_1;
    pwmOutputReferenceSignalConfig.timer12.clockInput       = IfxCcu6_TimerInputClock_fcc6;
    pwmOutputReferenceSignalConfig.timer12.counterValue     = 0;
    pwmOutputReferenceSignalConfig.timer12.compareValue     = (uint16) (ATOM_CCU6_DUTY_CYCLE * 0.01
                                                                 * pwmOutputReferenceSignalConfig.base.period);

    /* Select the channel out for modulation */
    pwmOutputReferenceSignalConfig.channelOut = IfxCcu6_ChannelOut_cc1;

    /* Pin configuration */
    IfxCcu6_TPwm_Pins pins = {
        NULL_PTR,                               /* CC60Out pin not used */
        &CCU6_REF_PIN,                          /* CC61Out pin */
        NULL_PTR,                               /* CC62Out pin not used */
        NULL_PTR,                               /* COUT60 pin not used */
        NULL_PTR,                               /* COUT61 pin not used */
        NULL_PTR,                               /* COUT62 pin not used */
        NULL_PTR,                               /* COUT63 pin not used */
        IfxPort_OutputMode_pushPull,
        IfxPort_PadDriver_cmosAutomotiveSpeed1,
        NULL_PTR,
        NULL_PTR,
        IfxPort_InputMode_pullUp
    };
    pwmOutputReferenceSignalConfig.pins = &pins;

    /* Configure input and output triggers */
    pwmOutputReferenceSignalConfig.trigger.t12ExtInputTrigger   = NULL_PTR;
    pwmOutputReferenceSignalConfig.trigger.t13ExtInputTrigger   = NULL_PTR;

    pwmOutputReferenceSignalConfig.trigger.t13InSyncWithT12     = FALSE;
    pwmOutputReferenceSignalConfig.trigger.outputTriggerEnabled = FALSE;
    /* Initialize the CCU6 */
    IfxCcu6_TPwm_initModule(&g_ccu61PwmReferenceHandler, &pwmOutputReferenceSignalConfig);

    /*---------------------------------------------------------------------------------------------*/
    /*                             Part 3: Start all channels synchronously                        */
    /*---------------------------------------------------------------------------------------------*/
    IfxGtm_Atom_Pwm_start(&g_atomPwmMissionHandler, TRUE);
    IfxCcu6_TPwm_start(&g_ccu61PwmReferenceHandler);

    /* Enable the clocks for synchronous start of reference and monitor (A)TOM */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);

    /*---------------------------------------------------------------------------------------------*/
    /*                                Part 4: Configure the IOM                                    */
    /*---------------------------------------------------------------------------------------------*/
    /* Disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    /* IOM monitor input */
    IfxPort_setPinMode(IOM_MONITOR_PIN.port, IOM_MONITOR_PIN.pinIndex, IfxPort_Mode_inputPullDown);

    /* Initialization of the IOM module */
    IfxIom_enableModule(&MODULE_IOM, 1);
    /* Creation of the IOM default configuration */
    IfxIom_Driver_initConfig(&g_iomConfigDriverDActFUC1, &MODULE_IOM);
    IfxIom_Driver_init(&g_iomDriverDActFUC1, &g_iomConfigDriverDActFUC1);       /* Apply the configuration */
    /* Creation of a default LAM configuration */
    IfxIom_Driver_initLamConfig(&g_iomConfigLamDActFUC1, &g_iomDriverDActFUC1);

    g_iomConfigLamDActFUC1.channel = IfxIom_LamId_0; /* Selection of LAM ID 0 */

    /* Configuration of the Monitor signal */
    g_iomConfigLamDActFUC1.mon.input = IOM_MONITOR_INPUT;                     /* IOM - Monitor signal input */
    g_iomConfigLamDActFUC1.mon.filter.mode = IfxIom_LamFilterMode_noFilter;   /* No filter applied on the signal */
    g_iomConfigLamDActFUC1.mon.inverted = FALSE;                              /* Input signal NOT inverted */

    /* Configuration of the Reference signal */
    g_iomConfigLamDActFUC1.ref.input = IOM_CCU6_REFERENCE_INPUT;             /* IOM - Reference signal input */
    g_iomConfigLamDActFUC1.ref.filter.mode = IfxIom_LamFilterMode_noFilter;  /* No filter applied on the signal */
    g_iomConfigLamDActFUC1.ref.inverted = FALSE;                             /* Input signal NOT inverted */

    /* Configuration of the Event Window */
    /* Event window generation determined from the reference signal */
    g_iomConfigLamDActFUC1.eventWindow.controlSource = IfxIom_LamEventWindowControlSource_ref;
    /* Event generation window is not gated */
    g_iomConfigLamDActFUC1.eventWindow.run = IfxIom_LamEventWindowRunControl_freeRunning;
    /* Window clears at any edge */
    g_iomConfigLamDActFUC1.eventWindow.clearEvent = IfxIom_LamEventWindowClearEvent_anyEdge;
    g_iomConfigLamDActFUC1.eventWindow.threshold = IOM_DUTY_THRESHOLD;        /* Set the threshold */
    g_iomConfigLamDActFUC1.eventWindow.inverted = FALSE;                      /* Window: NOT INVERTED */

    /* Configuration of the IOM event. IfxSmu_Alarm_IOM_Pin_MismatchIndication will be triggered if event
    * is detected. */
    /* Signal comparison: Reference XOR Monitor */
    g_iomConfigLamDActFUC1.event.source = IfxIom_LamEventSource_monXorRef;
    /* Falling edge is used for event generation */
    g_iomConfigLamDActFUC1.event.trigger = IfxIom_LamEventTrigger_fallingEdge;
    /* Alarm generated after 1 event*/
    g_iomConfigLamDActFUC1.systemEventTriggerThreshold = NUM_OF_LAM_EVENTS;

    /* Apply the custom configuration */
    IfxIom_Driver_initLam(&g_iomLamDActFUC1, &g_iomConfigLamDActFUC1);

    /* Accumulated counter used */
    g_iomLamDActFUC1.accumulatedCounterIndex = 1;

    IfxIom_Driver_enableLamEvent(&g_iomLamDActFUC1); /* Enable LAM events */

    /* Restore interrupt state */
    IfxCpu_restoreInterrupts(interruptState);

    /* Run SM:IOM_ALARM_CHECK */
    alarmCheckGTMIOM(NULL_PTR, g_ccu61PwmReferenceHandler.ccu6);
}
