/**********************************************************************************************************************
 * \file TLF35584.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "TLF35584.h"

/* Additional includes for SafetyKit */
#include "SafetyKit_Cfg.h"

#if CPU_WHICH_RUN_TLF == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 1) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 2) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 3) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 4) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 5) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set CPU_WHICH_RUN_TLF to a valid value!"
#endif
/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void unlockRegisterTLF35584(void);
void lockRegisterTLF35584(void);
void disableWindowWatchdogTLF35584(Tlf35584 *tlfDevice);
void enableWindowWatchdogTLF35584(Tlf35584 *tlfDevice);
void disableErrPinMonitorTLF35584(Tlf35584 *tlfDevice);
void enableErrPinMonitorTLF35584(Tlf35584 *tlfDevice);
void enableVoltageSupplyRails(Tlf35584 *tlfDevice);
uint8 getSpiStatusFlagsTLF35584(Tlf35584 *tlfDevice);
void clearSpiStatusFlagsTLF35584(Tlf35584 *tlfDevice);
IFX_EXTERN uint16 transferDataTLF35584(spiCommandType cmd, Tlf35584RegAddr addr, uint8 data);

/*********************************************************************************************************************/
/*----------------------------------------------Function Implementations---------------------------------------------*/
/*********************************************************************************************************************/
/*
 * unlock register of TLF
 * */
void unlockRegisterTLF35584(void)
{
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey1);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey2);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey3);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, UnlockKey4);
}

/*
 * lock register of TLF
 * */
void lockRegisterTLF35584(void)
{
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey1);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey2);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey3);
    transferDataTLF35584(SpiCommand_write, ProtcfgRegAddr, LockKey4);

    /* After the LOCK sequence an internal configuration time of max. 60us has to be considered to ensure that the new
     * configuration is taken over. See datasheet section 13.2 */
    IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMicroseconds(&MODULE_STM0, 60));
}

/*
 * disable Window Watchdog of TLF
 * */
void disableWindowWatchdogTLF35584(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of RWDCFG0 to check the current window watchdog setting */
    spiFrame.U = transferDataTLF35584(SpiCommand_read, Rwdcfg0RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->WDCFG0.U = spiFrame.B.data;

    if(tlfDevice->WDCFG0.B.WWDEN == WindowWatchdog_enabled)
    {
        tlfDevice->WDCFG0.B.WWDEN = WindowWatchdog_disabled;
        transferDataTLF35584(SpiCommand_write, Wdcfg0RegAddr, tlfDevice->WDCFG0.U);
    }
}

/*
 * enable Window Watchdog of TLF
 * */
void enableWindowWatchdogTLF35584(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of RWDCFG0 to check the current window watchdog setting */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Rwdcfg0RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->RWDCFG0.U = spiFrame.B.data;

    if(tlfDevice->RWDCFG0.B.WWDEN == WindowWatchdog_disabled)
    {
        tlfDevice->WDCFG0.B.WWDEN = WindowWatchdog_enabled;
        transferDataTLF35584(SpiCommand_write, Wdcfg0RegAddr, tlfDevice->WDCFG0.U);
    }
}

/*
 * disable Error Pin Monitoring of TLF
 * */
void disableErrPinMonitorTLF35584(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of RSYSPCFG1 to check the current error pin monitoring setting */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Rsyspcfg1RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->SYSPCFG1.U = spiFrame.B.data;

    if(tlfDevice->SYSPCFG1.B.ERREN == ErrPinMonitor_enabled)
    {
        tlfDevice->SYSPCFG1.B.ERREN = ErrPinMonitor_disabled;
        transferDataTLF35584(SpiCommand_write, Syspcfg1RegAddr, tlfDevice->SYSPCFG1.U);
    }
}

/*
 * enable Error Pin Monitoring of TLF
 * */
void enableErrPinMonitorTLF35584(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of RSYSPCFG1 to check the current error pin monitoring setting */
    spiFrame.U = transferDataTLF35584(SpiCommand_read, Rsyspcfg1RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->SYSPCFG1.U = spiFrame.B.data;

    if(tlfDevice->SYSPCFG1.B.ERREN == ErrPinMonitor_disabled)
    {
        tlfDevice->SYSPCFG1.B.ERREN = ErrPinMonitor_enabled;
        transferDataTLF35584(SpiCommand_write, Syspcfg1RegAddr, tlfDevice->SYSPCFG1.U);
    }
}

/*
 * enable voltage supply rail
 * */
void enableVoltageSupplyRails(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, DevctrlRegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->DEVCTRL.U = spiFrame.B.data;

    /* Enable all voltage supply rails */
    tlfDevice->DEVCTRL.B.COMEN = CommunicationLdoVoltage_enabled;
    tlfDevice->DEVCTRL.B.VREFEN = VoltageReferenceQVR_enabled;

    /* Update device register values */
    transferDataTLF35584(SpiCommand_write, DevctrlRegAddr, tlfDevice->DEVCTRL.U);
    transferDataTLF35584(SpiCommand_write, DevctrlnRegAddr, ~tlfDevice->DEVCTRL.U);
}

/*
 * get state transition of TLF
 * */
void setStateTransitionTLF35584(Tlf35584 *tlfDevice, statereqType requestedStateTransition)
{
    Tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, DevctrlRegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    tlfDevice->DEVCTRL.U = spiFrame.B.data;
    /* Set the requested state transition of TLF device locally */
    tlfDevice->DEVCTRL.B.STATEREQ = requestedStateTransition;

    /* Update device register values */
    transferDataTLF35584(SpiCommand_write, DevctrlRegAddr, tlfDevice->DEVCTRL.U);
    transferDataTLF35584(SpiCommand_write, DevctrlnRegAddr, ~tlfDevice->DEVCTRL.U);
}

/*
 * get current state of TLF
 * */
stateStatusType getCurrentStateTLF35584(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, DevstatRegAddr, (uint8)DUMMY_DATA);
    tlfDevice->DEVSTAT.U = spiFrame.B.data;

    return tlfDevice->DEVSTAT.B.STATE;
}

/*
 * get system status flag of TLF
 * */
uint8 getSystemStatusFlagsTLF35584(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, SyssfRegAddr, (uint8)DUMMY_DATA);

    tlfDevice->SYSSF.U = spiFrame.B.data;

    return tlfDevice->SYSSF.U;
}

void clearSystemStatusFlagsTLF35584(Tlf35584 *tlfDevice)
{
    tlfDevice->SYSSF.U = CLEAR_STATUS_FLAGS;
    transferDataTLF35584(SpiCommand_write, SyssfRegAddr, tlfDevice->SYSSF.U);
}

/*
 * get SPI status flag of TLF
 * */
uint8 getSpiStatusFlagsTLF35584(Tlf35584 *tlfDevice)
{
    Tlf35584SpiFrameType spiFrame;

    spiFrame.U = transferDataTLF35584(SpiCommand_read, SpisfRegAddr, (uint8)DUMMY_DATA);

    tlfDevice->SPISF.U = spiFrame.B.data;

    return tlfDevice->SPISF.U;
}

/*
 * clear SPI status flag of TLF
 * */
void clearSpiStatusFlagsTLF35584(Tlf35584 *tlfDevice)
{
    tlfDevice->SPISF.U = CLEAR_STATUS_FLAGS;
    transferDataTLF35584(SpiCommand_write, SpisfRegAddr, tlfDevice->SPISF.U);
}

/*
 * This function initializes the TLF35584 device
 * */
void initTLF35584(Tlf35584 *tlfDevice)
{
    unlockRegisterTLF35584();
    disableWindowWatchdogTLF35584(tlfDevice);
    disableErrPinMonitorTLF35584(tlfDevice);
    lockRegisterTLF35584();

    enableVoltageSupplyRails(tlfDevice);
}

#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#else
    #error "Only TASKING is supported, add pragmas for your compiler"
#endif
