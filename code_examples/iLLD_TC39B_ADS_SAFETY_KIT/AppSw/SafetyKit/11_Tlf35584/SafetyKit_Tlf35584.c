/**********************************************************************************************************************
 * \file SAFETYKIT_TLF35584.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyKit_Tlf35584.h"
#include "SafetyKit_Main.h"
#include "SafetyKit_Cfg.h"
#include "IfxStm.h"


#if CPU_WHICH_RUN_TLF == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 1) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 2) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 3) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 4) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_TLF == 5) && (CPU_WHICH_RUN_TLF < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set CPU_WHICH_RUN_TLF to a valid value!"
#endif
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Maximum functional watchdog questions */
#define IFXTLF35584_MAX_FWD_QUES  (16u)

/* Maximum functional watchdog response for a question */
#define IFXTLF35584_MAX_RESPONSE  (4u)

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
Tlf35584 g_tlfDevice;

IFX_CONST uint32 functionalWatchdogResponseTLF35584[IFXTLF35584_MAX_FWD_QUES][IFXTLF35584_MAX_RESPONSE] = {
    {0xFF, 0x0F, 0xF0, 0x00},
    {0xB0, 0x40, 0xBF, 0x4F},
    {0xE9, 0x19, 0xE6, 0x16},
    {0xA6, 0x56, 0xA9, 0x59},
    {0x75, 0x85, 0x7A, 0x8A},
    {0x3A, 0xCA, 0x35, 0xC5},
    {0x63, 0x93, 0x6C, 0x9C},
    {0x2C, 0xDC, 0x23, 0xD3},
    {0xD2, 0x22, 0xDD, 0x2D},
    {0x9D, 0x6D, 0x92, 0x62},
    {0xC4, 0x34, 0xCB, 0x3B},
    {0x8B, 0x7B, 0x84, 0x74},
    {0x58, 0xA8, 0x57, 0xA7},
    {0x17, 0xE7, 0x18, 0xE8},
    {0x4E, 0xBE, 0x41, 0xB1},
    {0x01, 0xF1, 0x0E, 0xFE}
};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
IFX_EXTERN void unlockRegisterTLF35584(void);
IFX_EXTERN void lockRegisterTLF35584(void);
IFX_EXTERN void enableErrPinMonitorTLF35584(Tlf35584 *tlfDevice);
IFX_EXTERN uint16 transferDataTLF35584(spiCommandType cmd, Tlf35584RegAddr addr, uint8 data);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Following SMs are covered with the usage of TLF together with AURIX:
 * SM[HW]:MCU:LBIST_MONITOR: TLF has the possibility, whenever the TLF is power, with default config, the watchdog is
 * on, if the TLF does not received valid communication within 550ms, the watchdog will be serviced and TFL will reset
 * (soft reset) the AURIX.
 * SM[HW]:SYS:FSP_ERROR_PIN_MONITOR
 * SM[HW]:SYS:WATCHDOG_FUNCTION
 * */
void initSafetyKitTlf35584(void)
{
    /* Initialize the QSPI module */
    initQSPI();

    /* Initialize the TLF35584 device */
    initTLF35584(&g_tlfDevice);

    /* Additionally disable Functional Watchdog as it might have been enabled before last reset of AURIX */
    safetyKitTlf35584DisableFwd();

    /* Disable Wake Up Timer in case it got enabled before TLF moved to Standby State */
    safetyKitTlf35584disableWakeUpTimer();

    /* If any error flag has been raised, clear that flag */
    if (getSystemStatusFlagsTLF35584(&g_tlfDevice) != 0)
    {
        clearSystemStatusFlagsTLF35584(&g_tlfDevice);
    }
}

/*
 * go to normal of TLF
 * */
void safetyKitTlf35584GoToSafeNormalMode(void)
{
    /* Enable TLF error pin monitoring, window watchdog and functional watchdog */
    safetyKitTlf35584EnableErrMon();
    safetyKitTlf35584ConfigAndEnableWwd();
    safetyKitTlf35584ConfigAndEnableFwd();

    /* Initial service of window and functional watchdog */
    safetyKitTlf35584ServiceWwd();
    safetyKitTlf35584ServiceFwd();

    /* Switch TLF to normal mode */
    stateStatusType currentState;
    uint8 timeout = 6;

    do
    {
        /* Set the device state to NORMAL. LED D104 should turn on afterwards. */
        setStateTransitionTLF35584(&g_tlfDevice, DeviceStateTransition_normal);

        /* Verify the current TLF state */
        currentState = getCurrentStateTLF35584(&g_tlfDevice);
        if(currentState != DeviceStateTransition_normal)
        {
            /* Wait 10s before requesting the state change again */
            IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMicroseconds(&MODULE_STM0, 10));

            /* Decrement TIMEOUT counter */
            timeout--;
        }

    /* If the device state does not correspond to the NORMAL state, repeat the state change request */
    } while(currentState != DeviceStateTransition_normal && timeout > 0);

    /* If any error is encountered, the code execution will end up in the infinite loop */
    if (getSystemStatusFlagsTLF35584(&g_tlfDevice) != 0 || timeout == 0)
    {
        while(1);
    }
}

/*
 * service window and functional watchdogs
 * */
void safetyKitTlf35584ServiceWatchdogs(void)
{
    safetyKitTlf35584ServiceWwd(); /* Service Window Watchdog */
    safetyKitTlf35584ServiceFwd(); /* Service Functional Watchdog */
}

/*
 * Enable Error Monitoring
 * */
void safetyKitTlf35584EnableErrMon(void)
{
    /* Enable error pin monitoring */
    unlockRegisterTLF35584();
    enableErrPinMonitorTLF35584(&g_tlfDevice);
    lockRegisterTLF35584();
}

/*
 * configur and Enable Window watchdog
 * */
void safetyKitTlf35584ConfigAndEnableWwd(void)
{
    /* Configure and enable the Window Watchdog */
    Tlf35584SpiFrameType spiFrame;

    /* WDCFG0 configuration */
    /* Get the value of RWDCFG0 to check the current Window Watchdog setting */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Rwdcfg0RegAddr, (uint8)DUMMY_DATA);

    g_tlfDevice.RWDCFG0.U = spiFrame.B.data;
    g_tlfDevice.WDCFG0.U  = g_tlfDevice.RWDCFG0.U;

    g_tlfDevice.WDCFG0.B.WWDETHR    = 9; /* Default value */
    g_tlfDevice.WDCFG0.B.WWDEN      = WindowWatchdog_enabled;
    g_tlfDevice.WDCFG0.B.WWDTSEL    = 1; /* Window watchdog is triggered via SPI */
    g_tlfDevice.WDCFG0.B.WDCYC      = 0; /* 0.1ms tick period */

    /* WWDCFG0 configuration */
    /* 5ms Close window: CW = 0, (0+1)*50*(tick period) = 5ms,  with 0.1ms as tick period */
    g_tlfDevice.WWDCFG0.B.CW = 0x0;

    /* WWDCFG1 configuration */
    /* 10ms Open window: OW = 1, (1+1)*50*(tick period) = 10ms, with 0.1ms as tick period */
    g_tlfDevice.WWDCFG1.B.OW = 0x1;

    /* Write configuration to WDCFG0, WWDCFG0 and WWDCFG1 registers */
    unlockRegisterTLF35584();
    transferDataTLF35584(SpiCommand_write, Wdcfg0RegAddr,  g_tlfDevice.WDCFG0.U);
    transferDataTLF35584(SpiCommand_write, Wwdcfg0RegAddr, g_tlfDevice.WWDCFG0.U);
    transferDataTLF35584(SpiCommand_write, Wwdcfg1RegAddr, g_tlfDevice.WWDCFG1.U);

    /* Write-verify-apply procedure as mentioned in [SM_SPI_02] */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Wdcfg0RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.WDCFG0.U = spiFrame.B.data;
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Wwdcfg0RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.WWDCFG0.U = spiFrame.B.data;
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Wwdcfg1RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.WWDCFG1.U = spiFrame.B.data;
    lockRegisterTLF35584();
}

/*
 * service Window watchdog
 * */
void safetyKitTlf35584ServiceWwd(void)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of WWDSCMD to get TRIG_STATUS */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, WwdscmdRegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.WWDSCMD.U = spiFrame.B.data;

    /* Write the inverted value of TRIG_STATUS bitfield to TRIG bitfield */
    g_tlfDevice.WWDSCMD.B.TRIG = !g_tlfDevice.WWDSCMD.B.TRIG_STATUS;
    transferDataTLF35584(SpiCommand_write, WwdscmdRegAddr, g_tlfDevice.WWDSCMD.U);

    /* Get the value of WWDSTAT to get WWDECNT Window watchdog error counter status */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, WwdstatRegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.WWDSTAT.U = spiFrame.B.data;
}

/*
 * disable Functional watchdog
 * */
void safetyKitTlf35584DisableFwd(void)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of RWDCFG0 to check the current functional watchdog setting */
    spiFrame.U = transferDataTLF35584(SpiCommand_read, Rwdcfg0RegAddr, (uint8)DUMMY_DATA);

    /* Refresh local value of TLF register */
    g_tlfDevice.WDCFG0.U = spiFrame.B.data;

    if(g_tlfDevice.WDCFG0.B.FWDEN == FunctionalWatchdog_enabled)
    {
        g_tlfDevice.WDCFG0.B.FWDEN = FunctionalWatchdog_disabled;
        unlockRegisterTLF35584();
        transferDataTLF35584(SpiCommand_write, Wdcfg0RegAddr, g_tlfDevice.WDCFG0.U);
        lockRegisterTLF35584();
    }
}

/*
 * config and enable Functional watchdog
 * */
void safetyKitTlf35584ConfigAndEnableFwd(void)
{
    /* Configure and enable the functional watchdog */
    Tlf35584SpiFrameType spiFrame;

    /* WDCFG0 configuration */
    /* Get the value of RWDCFG0 to check the current functional watchdog setting */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Rwdcfg0RegAddr, (uint8)DUMMY_DATA);

    g_tlfDevice.RWDCFG0.U = spiFrame.B.data;
    g_tlfDevice.WDCFG0.U  = g_tlfDevice.RWDCFG0.U;

    /* Enable the FWDEN bitfield */
    g_tlfDevice.WDCFG0.B.FWDEN = FunctionalWatchdog_enabled;

    /* WDCFG1 configuration */
    g_tlfDevice.WDCFG1.B.FWDETHR = 9; /* Default value */

    /* FWDCFG configuration */

    g_tlfDevice.FWDCFG.B.WDHBTP = 0x2; /* 15ms Functional watchdog heartbeat timer period: WDHBTP = 0x2,
                                          (2+1)*50*(tick period) = 15ms,  with 0.1ms as tick period */
    /* Write configuration to WDCFG0, WWDCFG0 and WWDCFG1 registers */
    unlockRegisterTLF35584();
    transferDataTLF35584(SpiCommand_write, Wdcfg0RegAddr, g_tlfDevice.WDCFG0.U);
    transferDataTLF35584(SpiCommand_write, Wdcfg1RegAddr, g_tlfDevice.WDCFG1.U);
    transferDataTLF35584(SpiCommand_write, FwdcfgRegAddr, g_tlfDevice.FWDCFG.U);

    /* Write-verify-apply procedure as mentioned in [SM_SPI_02] */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Wdcfg0RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.WDCFG0.U = spiFrame.B.data;

    spiFrame.U  = transferDataTLF35584(SpiCommand_read, FwdcfgRegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.FWDCFG.U = spiFrame.B.data;

    lockRegisterTLF35584();
}

/*
 * service functional watch dog
 * */
void safetyKitTlf35584ServiceFwd(void)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of FWDSTAT0 to get FWDQUEST */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Fwdstat0RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.FWDSTAT0.U = spiFrame.B.data;

    /* Get the value of FWDSTAT1 to get error counter value */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Fwdstat1RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.FWDSTAT1.U = spiFrame.B.data;

    uint8 index = 0u;
    for(index = 0u; index < 3u; index++)
    {
        g_tlfDevice.FWDRSP.B.FWDRSP = functionalWatchdogResponseTLF35584[g_tlfDevice.FWDSTAT0.B.FWDQUEST][index];

        /* Write Response RESP3, RESP2, RESP1 in FWDRSP */
        transferDataTLF35584(SpiCommand_write, FwdrspRegAddr, g_tlfDevice.FWDRSP.U);
    }
    g_tlfDevice.FWDRSPSYNC.B.FWDRSPS = functionalWatchdogResponseTLF35584[g_tlfDevice.FWDSTAT0.B.FWDQUEST][index];

    /* Write Response RESP0 in FWDRSPSYNC */
    transferDataTLF35584(SpiCommand_write, FwdrspsyncRegAddr, g_tlfDevice.FWDRSPSYNC.U);
}

/*
 * goto standby power down state
 * */
void safetyKitTlf35584GotoStandbyPowerdownState(void)
{
    /* Set the device state to STANDBY */
    setStateTransitionTLF35584(&g_tlfDevice, DeviceStateTransition_standby);
}

/*
 * Enable wake up timer
 * */
void safetyKitTlf35584EnableWakeUpTimer(void)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of DEVCFG0 */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Devcfg0RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.DEVCFG0.U = spiFrame.B.data;

    /* Enable the Wake up timer */
    g_tlfDevice.DEVCFG0.B.WKTIMEN = 1;

    /* Write Response to DEVCFG0 */
   transferDataTLF35584(SpiCommand_write, Devcfg0RegAddr, g_tlfDevice.DEVCFG0.U);
}

/*
 * disable wake up timer
 * */
void safetyKitTlf35584disableWakeUpTimer(void)
{
    Tlf35584SpiFrameType spiFrame;

    /* Get the value of DEVCFG0 */
    spiFrame.U  = transferDataTLF35584(SpiCommand_read, Devcfg0RegAddr, (uint8)DUMMY_DATA);
    g_tlfDevice.DEVCFG0.U = spiFrame.B.data;

    /* Disable the Wake up timer */
    g_tlfDevice.DEVCFG0.B.WKTIMEN = 0;

    /* Write Response to DEVCFG0 */
   transferDataTLF35584(SpiCommand_write, Devcfg0RegAddr, g_tlfDevice.DEVCFG0.U);
}

/*
 * config wake up timer of 500ms
 * */
void safetyKitTlf35584ConfigureWakeUpTimer500ms(void)
{
    /* Configure TLF Wake Up Timer to 500ms.
     * 500ms are 50000 times 10 microseconds which is the resolution of the wake up timer of TLF
     * 50000 is in hexadecimal 0xC350, therefore set WKTIMCFG0 to 0x50 and WKTIMCFG1 to 0xC3.
     */

    /* Write to WKTIMCFG0 */
    g_tlfDevice.WKTIMCFG0.U = 0x50;
    transferDataTLF35584(SpiCommand_write, Wktimcfg0RegAddr, g_tlfDevice.WKTIMCFG0.U);

    /* Write to WKTIMCFG1 */
    g_tlfDevice.WKTIMCFG1.U = 0xC3;
    transferDataTLF35584(SpiCommand_write, Wktimcfg1RegAddr, g_tlfDevice.WKTIMCFG1.U);
}


#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#else
    #error "Only TASKING is supported, add pragmas for your compiler"
#endif
