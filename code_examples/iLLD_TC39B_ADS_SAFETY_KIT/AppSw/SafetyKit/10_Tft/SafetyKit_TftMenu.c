/**********************************************************************************************************************
 * \file SafetyKit_TftMenue.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyKit_AA_global.h"
#include "06_Safe_Computation/SafetyKit_Dma.h"
#include "06_Safe_Computation/SafetyKit_Pflash_Programming.h"
#include "06_Safe_Computation/SafetyKit_Pflash_Programming.h"
#include "06_Safe_Computation/SafetyKit_Sri_Error_Handling.h"
#include "09_Fault_Injection/SafetyKit_TriggerSmuAlarm.h"
#include "Ifx_Types.h"
#include "IfxCpu.h"

#include "conio_tft.h"
#include "touch.h"

#include "SafetyKit_Main.h"
#include "SafetyKit_Cfg.h"
#include <stdio.h>
#include <string.h>
#include "SafetyKit_AA_FUC2.h"
#include "SafetyKit_EmergencyStop.h"
#include "IfxPmsEvr.h"

#if CPU_WHICH_SERVICE_TFT == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 1) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 2) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 3) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 4) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 5) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_TFT to a valid value!"
#endif
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IFX_EXTERN char* popMessage;
IFX_EXTERN AnalogAcquisitionStatusDatatype g_analogAcquisitionStatus;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void safetykitMenuDisplay(sint32 ind, TDISPLAYENTRY * pdisplayentry);
void safetykitMenuSelect(sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 safetykitMenuInput (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayDieTemp (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectDieTemp (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplaySentAngle (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectSentAngle (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayLBIST (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayMONBIST (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayFwCheck (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayMBIST (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayVext (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectVext (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayVextUV (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menuInputVextUV (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectVextUV (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayVddp3 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectVddp3 (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayVddp3UV (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menuInputVddp3UV (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectVddp3UV (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayCoreVolt (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectCoreVolt (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayCoreVoltUV (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menuInputCoreVoltUV (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectCoreVoltUV (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayClearES (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectClearES (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayLockstepError (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectLockstepError  (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectResetSmu  (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectStartAAcqFuc4BrokenWire  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayStartAAcqFuc4BrokenWire (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectStopAAcqFuc4BrokenWire  (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectTIMTIM  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayTIMTIM (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectTIMCCU6  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayTIMCCU6 (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectGPT12CCU6  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayGPT12CCU6 (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectTOMTIM  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayTOMTIM (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectTOMIOM  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayTOMIOM (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectCCU6IOM  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayCCU6IOM (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectCCU6GPT12  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayCCU6GPT12 (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayClkPlaus (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectClkPlaus (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectDMAECC  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectDMACRC  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectDMADest  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectDMATimestamp (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectSRIError (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectEvadcEvadc  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menudisplayEvadcEvadc (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectEdsadcEdsadc  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayEdsadcEdsadc (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectEvadcEdsadc  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayEvadcEdsadc (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuSelectEvadcSinglePin  (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuDisplayEvadcSinglePin (sint32 ind, TDISPLAYENTRY * pdisplayentry);

/*********************************************************************************************************************/
/*-------------------------------------------Private Variables/Constants---------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Safety kit menu list
 * */
const TDISPLAYENTRY safetykit_menulist[35] = {
    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 27, 39, 1, &safetykitMenuSelect,
            &menuDisplayLBIST, &safetykitMenuInput, "LBIST: result"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 23, 2, &menuSelectDieTemp,
            &menuDisplayDieTemp, &safetykitMenuInput, "DIE Temperature: "},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 25, 39, 2, &safetykitMenuSelect,
            &menuDisplayMONBIST, &safetykitMenuInput, "MONBIST: result"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 20, 3, &menuSelectSentAngle,
            &menuDisplaySentAngle, &safetykitMenuInput, "Angle: "},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 24, 39, 3, &safetykitMenuSelect,
            &menuDisplayFwCheck, &safetykitMenuInput, "FW CHECK: result"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 27, 39, 4, &safetykitMenuSelect,
            &menuDisplayMBIST, &safetykitMenuInput, "MBIST: result"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 19, 5, &menuSelectVext,
            &menuDisplayVext, &safetykitMenuInput, "VEXT Voltage : "},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 25, 40, 5, &menuSelectVextUV,
            &menuDisplayVextUV, &menuInputVextUV,  "UV Limit: "}, /* UV Limit code line has to be before Voltage status
                                                                     menu line */
    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 19, 6, &menuSelectVddp3,
            &menuDisplayVddp3, &safetykitMenuInput, "VDDP3 Voltage: "},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 25, 40, 6, &menuSelectVddp3UV,
            &menuDisplayVddp3UV, &menuInputVddp3UV, "UV Limit: "}, /* UV Limit code line has to be before Voltage status
                                                                      menu line */
    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 19, 7, &menuSelectCoreVolt,
            &menuDisplayCoreVolt, &safetykitMenuInput, "Core Voltage : "},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 25, 40, 7, &menuSelectCoreVoltUV,
            &menuDisplayCoreVoltUV, &menuInputCoreVoltUV, "UV Limit: "}, /* UV Limit code line has to be before Voltage
                                                                            status menu line */
    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 19, 8, &menuSelectClearES,
            &menuDisplayClearES, &safetykitMenuInput, "Clear Emergency Stop"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 28, 40, 8,  &menuSelectTIMTIM,
            &menuDisplayTIMTIM, &safetykitMenuInput, "TIMTIM  in"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 23, 9, &menuSelectLockstepError,
            &menuDisplayLockstepError, &safetykitMenuInput, "Lockstep error injection"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 30, 40, 9,  &menuSelectTIMCCU6,
            &menuDisplayTIMCCU6, &safetykitMenuInput, "TIMCCU6 in"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 22, 10, &menuSelectStartAAcqFuc4BrokenWire,
            &menuDisplayStartAAcqFuc4BrokenWire, &safetykitMenuInput, "Run safe ADC capturing"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 28, 40, 10,  &menuSelectGPT12CCU6,
            &menuDisplayGPT12CCU6, &safetykitMenuInput, "CCU6GPT12 in"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 23, 11, &menuSelectStopAAcqFuc4BrokenWire,
            &safetykitMenuDisplay, &safetykitMenuInput, "Stop safe ADC capturing"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 30, 40, 11,  &menuSelectTOMIOM,
            &menuDisplayTOMIOM, &safetykitMenuInput, "TOMIOM out"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 21, 12, &menuSelectClkPlaus,
            &menuDisplayClkPlaus, &safetykitMenuInput, "ClkPlaus: "},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 29, 40, 12, &menuSelectCCU6IOM,
            &menuDisplayCCU6IOM, &safetykitMenuInput, "CCU6IOM out"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 21, 13, &menuSelectDMAECC,
            &safetykitMenuDisplay, &safetykitMenuInput, "DMA inject ECC  error"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 30, 40, 13, &menuSelectTOMTIM,
            &menuDisplayTOMTIM, &safetykitMenuInput, "TOMTIM out"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 21, 14, &menuSelectDMACRC,
            &safetykitMenuDisplay, &safetykitMenuInput, "DMA inject CRC  error"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 27, 40, 14, &menuSelectCCU6GPT12,
            &menuDisplayCCU6GPT12, &safetykitMenuInput, "CCU6GPT12 out"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 21, 15, &menuSelectDMADest,
            &safetykitMenuDisplay, &safetykitMenuInput, "DMA inject Dest error"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 28, 38, 15,  &menuSelectEvadcEvadc,
            &menudisplayEvadcEvadc,     &safetykitMenuInput, "EVADC+EVADC"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 21, 16, &menuSelectDMATimestamp,
            &safetykitMenuDisplay, &safetykitMenuInput, "DMA inject TS error"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 27, 40, 16,  &menuSelectEdsadcEdsadc,
            &menuDisplayEdsadcEdsadc,   &safetykitMenuInput, "EDSADC+EDSADC"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 21, 17, &menuSelectSRIError,
            &safetykitMenuDisplay, &safetykitMenuInput, "SRI inject error"},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 28, 40, 17,  &menuSelectEvadcEdsadc,
            &menuDisplayEvadcEdsadc,    &safetykitMenuInput, "EVADC+EDSADC"},

    {(COLOR_MAGENTA << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 21, 18, &menuSelectResetSmu,
            &safetykitMenuDisplay, &safetykitMenuInput, "Reset SMU alarms"},
    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 26, 40, 18,  &menuSelectEvadcSinglePin,
            &menuDisplayEvadcSinglePin, &safetykitMenuInput, "2 EVADC 1 PIN"},

    {0, 0, 0, 0, 0, 0, 0, 0, " "}  /* LAST ENTRY */
};

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * display Menu
 * */
void safetykitMenuDisplay (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, &pdisplayentry->text[0]);
}

/*
 * select Menu
 * */
void safetykitMenuSelect (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, &pdisplayentry->text[0]);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   /* clear */
    }
}

sint32 safetykitMenuInput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    __debug ();
    return (0);
}

/*
 * display Die temperature
 * */
void menuDisplayDieTemp (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    float32 higher_temp =
            g_SafetyKitStatus.dieTempStatus.dieTemperatureCore > g_SafetyKitStatus.dieTempStatus.dieTemperaturePms ?
                    g_SafetyKitStatus.dieTempStatus.dieTemperatureCore :
                    g_SafetyKitStatus.dieTempStatus.dieTemperaturePms;
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Higher DIE Temp.: %.1f%cC", higher_temp, 0xF8);
}

/*
 * select Die temperature from menu
 * */
void menuSelectDieTemp (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y,
            (const uint8*) "min: %.1f %cC max: %.1f %cC", g_SafetyKitStatus.dieTempStatus.dieTempLowest, 0xF8,
            g_SafetyKitStatus.dieTempStatus.dieTempHighest, 0xF8);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   /* clear */
    }
}

/*
 * display SENT angle
 *  */
void menuDisplaySentAngle (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y,
            (const uint8*) "Angle Sens1: %.1f%c\nAngle Sens2: %.1f%c",
            g_SafetyKitStatus.sentRedundancy.angleCover[0], 0xF8, g_SafetyKitStatus.sentRedundancy.angleCover[1], 0xF8);
}

/* select SENT angle
 * */
void menuSelectSentAngle (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "Angle Diff.: %.1f%c",
            g_SafetyKitStatus.sentRedundancy.angleMaximumThreshold, 0xF8);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   /* clear */
    }
}

/* TFT Functions for SSW status */
/*
 * display LBIST
 * */
void menuDisplayLBIST (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    const uint8* result_string;

    switch (g_SafetyKitStatus.sswStatus.lbistStatus)
    {
        case failed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
            result_string = (const uint8*) "LBIST: failed";
            break;
        case passed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_GREEN << 4) | COLOR_BLACK);
            result_string = (const uint8*) "LBIST: passed";
            break;
        case notEvaluated :
            conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
            result_string = (const uint8*) "LBIST: not done";
            break;
        default:
            break;
    }

    conio_ascii_printfxy(DISPLAYMENU, (sint32) (TERMINAL_MAXX - strlen((const char*) result_string)), pdisplayentry->y,
            result_string);
}

/*
 * display MONBIST
 * */
void menuDisplayMONBIST (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    const uint8* result_string;

    switch (g_SafetyKitStatus.sswStatus.monbistStatus)
    {
        case failed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
            result_string = (const uint8*) "MONBIST: failed";
            break;
        case passed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_GREEN << 4) | COLOR_BLACK);
            result_string = (const uint8*) "MONBIST: passed";
            break;
        case notEvaluated :
            conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
            result_string = (const uint8*) "MONBIST: not done";
            break;
        default:
            break;
    }

    conio_ascii_printfxy(DISPLAYMENU, (sint32) (TERMINAL_MAXX - strlen((const char*) result_string)), pdisplayentry->y,
            result_string);
}

/*
 * display FW check
 * */
void menuDisplayFwCheck (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    const uint8* result_string;

    switch (g_SafetyKitStatus.sswStatus.mcuFwcheckStatus)
    {
        case failed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
            result_string = (const uint8*) "FW CHECK: failed";
            break;
        case passed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_GREEN << 4) | COLOR_BLACK);
            result_string = (const uint8*) "FW CHECK: passed";
            break;
        case notEvaluated :
            conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
            result_string = (const uint8*) "FW CHECK: not done";
            break;
        default:
            break;
    }

    conio_ascii_printfxy(DISPLAYMENU, (sint32) (TERMINAL_MAXX - strlen((const char*) result_string)), pdisplayentry->y,
            result_string);
}

/*
 * display MBIST
 * */
void menuDisplayMBIST (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    const uint8* result_string;

    switch (g_SafetyKitStatus.sswStatus.mbistStatus)
    {
        case failed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
            result_string = (const uint8*) "MBIST: failed";
            break;
        case passed :
            conio_ascii_textattr(DISPLAYMENU, (COLOR_GREEN << 4) | COLOR_BLACK);
            result_string = (const uint8*) "MBIST: passed";
            break;
        case notEvaluated :
            conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
            result_string = (const uint8*) "MBIST: not done";
            break;
        default:
            break;
    }

    conio_ascii_printfxy(DISPLAYMENU, (sint32) (TERMINAL_MAXX - strlen((const char*) result_string)), pdisplayentry->y,
            result_string);
}
/* End of TFT Functions for SSW status */

/* TFT Functions for VEXT Voltage status */
/*
 * display Vext
 * */
void menuDisplayVext (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    if (g_SafetyKitStatus.voltStatus.vextVoltage < g_SafetyKitStatus.voltStatus.vextVoltageUvLimit)
    {
        conio_ascii_textattr(DISPLAYMENU, COLOR_RED);
    }
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "VEXT Voltage : %.2fV",
            g_SafetyKitStatus.voltStatus.vextVoltage);
}

/*
 * select Vext
 * */
void menuSelectVext (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y,
            (const uint8*) "VEXT Voltage min: %.2fV max: %.2fV      ", g_SafetyKitStatus.voltStatus.vextVoltageLowest,
            g_SafetyKitStatus.voltStatus.vextVoltageHighest);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
    }
}
/* TFT Functions for VEXT Voltage status */

/*
 * TFT Functions for VEXT Undervoltage limit
 * */
void menuDisplayVextUV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "UV limit: %.2fV",
            (float) g_SafetyKitStatus.voltStatus.vextVoltageUvLimit);
}

sint32 menuInputVextUV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    float32 temp;
    sint32 result;
    result = sscanf((char*) &conio_driver.scanftext[0], "%f", &temp);
    if (result != 1)
    {
        return (-1);
    }
    if (temp < (SWD_UV_VAL_RANGE_MIN_MV / 1000))
    {
        temp = (SWD_UV_VAL_RANGE_MIN_MV / 1000);
    }
    if (temp > (SWD_UV_VAL_RANGE_MAX_MV / 1000))
    {
        temp = (SWD_UV_VAL_RANGE_MAX_MV / 1000);
    }

    /* Update voltage monitoring threshold */
    g_SafetyKitStatus.voltStatus.vextVoltageUvLimit = temp;
    IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(&MODULE_PMS, g_SafetyKitStatus.voltStatus.vextVoltageUvLimit * 1000,
            IfxPmsEvr_SupplyMode_swd);

    return (0);
}

void menuSelectVextUV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "UV limit: %.2fV",
            (float) g_SafetyKitStatus.voltStatus.vextVoltageUvLimit);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        strcpy((char*) &conio_driver.scanfdescr[0], "Undervoltage limit ");
        sprintf((char*) &conio_driver.scanftext[0], "%.4f", g_SafetyKitStatus.voltStatus.vextVoltageUvLimit);
        conio_driver.scanfx = 0; /* actual cursor */
        conio_driver.dialogmode = KEYBOARDON; /* Keyboard input mode */
        conio_driver.input = pdisplayentry->input;
        conio_driver.inputid = ind;
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
    }
}
/* TFT Functions for VEXT Undervoltage limit */

/*
 * TFT Functions for VDDP3 Voltage status
 * */
void menuDisplayVddp3 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    if (g_SafetyKitStatus.voltStatus.vddp3Voltage < g_SafetyKitStatus.voltStatus.vddp3VoltageUvLimit)
    {
        conio_ascii_textattr(DISPLAYMENU, COLOR_RED);
    }
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "VDDP3 Voltage: %.2fV",
            g_SafetyKitStatus.voltStatus.vddp3Voltage);
}

void menuSelectVddp3 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y,
            (const uint8*) "VDDP3 Voltage min: %.2fV max: %.2fV     ", g_SafetyKitStatus.voltStatus.vddp3VoltageLowest,
            g_SafetyKitStatus.voltStatus.vddp3VoltageHighest);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
    }
}
/* TFT Functions for VDDP3 Voltage status */

/*
 * TFT Functions for VDDP3 Undervoltage limit
 * */
void menuDisplayVddp3UV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "UV limit: %.2fV",
            (float) g_SafetyKitStatus.voltStatus.vddp3VoltageUvLimit);
}

sint32 menuInputVddp3UV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    float32 temp;
    sint32 result;
    result = sscanf((char*) &conio_driver.scanftext[0], "%f", &temp);
    if (result != 1)
    {
        return (-1);
    }
    if (temp < (EVR33_UV_VAL_RANGE_MIN_MV / 1000))
    {
        temp = (EVR33_UV_VAL_RANGE_MIN_MV / 1000);
    }
    if (temp > (EVR33_UV_VAL_RANGE_MAX_MV / 1000))
    {
        temp = (EVR33_UV_VAL_RANGE_MAX_MV / 1000);
    }

    /* Update voltage monitoring threshold */
    g_SafetyKitStatus.voltStatus.vddp3VoltageUvLimit = temp;
    IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(&MODULE_PMS, g_SafetyKitStatus.voltStatus.vddp3VoltageUvLimit * 1000,
            IfxPmsEvr_SupplyMode_evr33);

    return (0);
}

void menuSelectVddp3UV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "UV limit: %.2fV",
            (float) g_SafetyKitStatus.voltStatus.vddp3VoltageUvLimit);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        strcpy((char*) &conio_driver.scanfdescr[0], "Undervoltage limit ");
        sprintf((char*) &conio_driver.scanftext[0], "%.4f", g_SafetyKitStatus.voltStatus.vddp3VoltageUvLimit);
        conio_driver.scanfx = 0; /* actual cursor */
        conio_driver.dialogmode = KEYBOARDON; /* Keyboard input mode */
        conio_driver.input = pdisplayentry->input;
        conio_driver.inputid = ind;
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
    }
}
/* TFT Functions for VDDP3 Undervoltage limit */

/*
 * TFT Functions for Core Voltage status
 * */
void menuDisplayCoreVolt (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    if (g_SafetyKitStatus.voltStatus.coreVoltage < g_SafetyKitStatus.voltStatus.coreVoltageUvLimit)
        conio_ascii_textattr(DISPLAYMENU, COLOR_RED);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "CORE Voltage : %.2fV",
            g_SafetyKitStatus.voltStatus.coreVoltage);
}

void menuSelectCoreVolt (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y,
            (const uint8*) "CORE Voltage min: %.2fV max: %.2fV      ", g_SafetyKitStatus.voltStatus.coreVoltageLowest,
            g_SafetyKitStatus.voltStatus.coreVoltageHighest);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
    }
}
/* TFT Functions for Core Voltage status */

/*
 * TFT Functions for Core Undervoltage limit
 * */
void menuDisplayCoreVoltUV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "UV limit: %.2fV",
            (float) g_SafetyKitStatus.voltStatus.coreVoltageUvLimit);
}

sint32 menuInputCoreVoltUV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    float32 temp;
    sint32 result;
    result = sscanf((char*) &conio_driver.scanftext[0], "%f", &temp);
    if (result != 1)
    {
        return (-1);
    }
    if (temp < (EVRC_UV_VAL_RANGE_MIN_MV / 1000))
    {
        temp = (EVRC_UV_VAL_RANGE_MIN_MV / 1000);
    }
    if (temp > (EVRC_UV_VAL_RANGE_MAX_MV / 1000))
    {
        temp = (EVRC_UV_VAL_RANGE_MAX_MV / 1000);
    }

    /* Update voltage monitoring threshold */
    g_SafetyKitStatus.voltStatus.coreVoltageUvLimit = temp;
    IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(&MODULE_PMS, g_SafetyKitStatus.voltStatus.coreVoltageUvLimit * 1000,
            IfxPmsEvr_SupplyMode_evrc);

    return (0);
}

void menuSelectCoreVoltUV (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "UV limit: %.2fV",
            (float) g_SafetyKitStatus.voltStatus.coreVoltageUvLimit);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        strcpy((char*) &conio_driver.scanfdescr[0], "Undervoltage limit ");
        sprintf((char*) &conio_driver.scanftext[0], "%.4f", g_SafetyKitStatus.voltStatus.coreVoltageUvLimit);
        conio_driver.scanfx = 0; /* actual cursor */
        conio_driver.dialogmode = KEYBOARDON; /* Keyboard input mode */
        conio_driver.input = pdisplayentry->input;
        conio_driver.inputid = ind;
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
    }
}
/* TFT Functions for Core Undervoltage limit */

/*
 * TFT functions for clear emergency stop
 * */
void menuDisplayClearES (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (MODULE_SCU.EMSR.B.EMSF || MODULE_SCU.EMSR.B.SEMSF)
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    else
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

void menuSelectClearES (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) "Clearing Emergency Stop");

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        clearEmergencyStopFlags();
    }
}
/* TFT functions for clear emergency stop */

/*
 * TFT functions for lockstep error injection
 * */
void menuDisplayLockstepError (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);
}

void menuSelectLockstepError (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{

    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) "Inject LSL error");

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        safetyKitFaultInjection(IfxSmu_Alarm_CPU1_Lockstep_ComparatorError);
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
    }
}
/* TFT functions for lockstep error injection */

/*
 * TFT functions for reset smu alarm button
 * */
void menuSelectResetSmu (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        popMessage = "Reset alarm";
        conio_driver.dialogmode = SHOWSMUALARM;
    }
}
/* TFT functions for reset smu alarm button */

/*
 * TFT functions for broken wire detection within Analog Acquisition FUC4
 * */
void menuSelectStartAAcqFuc4BrokenWire (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (uint8*) "Capturing safe ADC: %.2fV",
            g_analogAcquisitionStatus.evadcVoltageResults[EVADC_RV1_CH_ID_AA_FUC2]);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        g_SafetyKitStatus.analogAcquisitionMode = initAAcqFuc4BrokenWRMode;
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
    }
}

void menuSelectStopAAcqFuc4BrokenWire (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (uint8*) "Stop safe ADC capturing");

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        g_SafetyKitStatus.analogAcquisitionMode = initAAcqFuc0Mode;
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
    }
}

void menuDisplayStartAAcqFuc4BrokenWire (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.analogAcquisitionMode == runAAcqFuc4BrokenWRMode)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

/* TFT functions for broken wire detection within Analog Acquisition FUC4 */

/*
 * TFT functions for Digital Acquisition FUCs
 * */
void menuSelectTIMTIM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.digitalAcqActMode = initializeDAcqFuc0;
    }
}
void menuDisplayTIMTIM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.digitalAcqActMode == runDAcqFuc0)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

/*
 * TFT functions for Digital Acquisition FUCs
 * */
void menuSelectTIMCCU6 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.digitalAcqActMode = initializeDAcqFuc1;
    }
}
void menuDisplayTIMCCU6 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.digitalAcqActMode == runDAcqFuc1)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

/*
 * TFT functions for Digital Acquisition FUCs
 * */
void menuSelectGPT12CCU6 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.digitalAcqActMode = initializeDAcqFuc2;
    }
}
void menuDisplayGPT12CCU6 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.digitalAcqActMode == runDAcqFuc2)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

/* TFT functions for Digital Acquisition FUCs */

/*
 * TFT functions for Digital Actuation FUCs
 * */
void menuSelectTOMIOM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.digitalAcqActMode = initializeDActFuc0;
    }
}
void menuDisplayTOMIOM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.digitalAcqActMode == runDActFuc0)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

void menuSelectCCU6IOM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.digitalAcqActMode = initializeDActFuc1;
    }
}
void menuDisplayCCU6IOM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.digitalAcqActMode == runDActFuc1)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

void menuSelectTOMTIM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.digitalAcqActMode = initializeDActFuc2;
    }
}
void menuDisplayTOMTIM (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.digitalAcqActMode == runDActFuc2)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

void menuSelectCCU6GPT12 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.digitalAcqActMode = initializeDActFuc3;
    }
}
void menuDisplayCCU6GPT12 (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.digitalAcqActMode == runDActFuc3)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

/* TFT functions for Digital Actuation FUCs */

/*
 * TFT functions for fault injection into an DMA transaction
 * */
void menuSelectDMAECC (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        injectECCErrorDMA();
    }
}

void menuSelectDMACRC (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        injectCrcErrorDMA();
    }
}

void menuSelectDMADest (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        injectDestinationErrorDMA();
    }
}

void menuSelectDMATimestamp (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        injectTimestampErrorDMA();
    }
}

/*
 * TFT functions for fault injection into an DMA transaction
 * */
void menuSelectSRIError (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);

    conio_ascii_cputs(DISPLAYMENU, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        injectSRIError();
    }
}
void menuSelectClkPlaus (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "Min: %.2fV Max: %.2fV",
            g_SafetyKitStatus.qspiEofandSofTimeDifference.timeMinimumThreshold,
            g_SafetyKitStatus.qspiEofandSofTimeDifference.timeMaximumThreshold);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
    }
}

void menuDisplayClkPlaus (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "QSPI ClockPlaus : %.2fus",
            g_SafetyKitStatus.qspiEofandSofTimeDifference.timeDifference);
}

/* TFT functions for fault injection into an DMA transaction */

/*
 * TFT functions for Analog Acquisition FUCs
 * */
void menuSelectEvadcEvadc (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y,
            (const uint8*) "%.1f, %.1f ", g_analogAcquisitionStatus.evadcRv1NtcTemp,
            g_analogAcquisitionStatus.evadcRv2NtcTemp);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.analogAcquisitionMode = initAAcqFuc0Mode;
    }
}
void menudisplayEvadcEvadc (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.analogAcquisitionMode == runAAcqFuc0Mode)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

void menuSelectEdsadcEdsadc (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y,
            (const uint8*) "%.1f, %.1f ", g_analogAcquisitionStatus.edsadcRv1NtcTemp,
            g_analogAcquisitionStatus.edsadcRv2NtcTemp);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.analogAcquisitionMode = initAAcqFuc1Mode;
    }
}
void menuDisplayEdsadcEdsadc (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.analogAcquisitionMode == runAAcqFuc1Mode)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

void menuSelectEvadcEdsadc (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "%.1f, %.1f ",
            g_analogAcquisitionStatus.evadcRv1NtcTemp, g_analogAcquisitionStatus.edsadcRv2NtcTemp);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.analogAcquisitionMode = initAAcqFuc2Mode;
    }
}
void menuDisplayEvadcEdsadc (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.analogAcquisitionMode == runAAcqFuc2Mode)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}

void menuSelectEvadcSinglePin (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8*) "%.2f, %.2f ",
            g_analogAcquisitionStatus.evadcVoltageResults[0], g_analogAcquisitionStatus.evadcVoltageResults[1]);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN; /* clear */
        g_SafetyKitStatus.analogAcquisitionMode = initAAcqFuc3Mode;
    }
}
void menuDisplayEvadcSinglePin (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    if (g_SafetyKitStatus.analogAcquisitionMode == runAAcqFuc3Mode)
    {
        conio_ascii_textattr(DISPLAYMENU, (COLOR_RED << 4) | COLOR_BLACK);
    }
    else
    {
        conio_ascii_textattr(DISPLAYMENU, pdisplayentry->color_display);
    }

    conio_ascii_gotoxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs(DISPLAYMENU, (uint8*) pdisplayentry->text);
}
/* TFT functions for Analog Acquisition FUCs */

/*
 * show menu of safety kit
 * */
void safetykitShowMenu (sint16 x, sint16 y, TDISPLAYENTRY *pmenulist)
{
    sint32 i;
    conio_ascii_textbackground(DISPLAYMENU, MENU_BACKGRND);
    conio_ascii_clrscr(DISPLAYMENU);
    conio_ascii_textcolor(DISPLAYMENU, COLOR_BLACK);
    conio_ascii_textbackground(DISPLAYMENU, COLOR_CYAN);
    conio_ascii_printfxy(DISPLAYMENU, 3, 0, (const uint8*) "%s TC3%d%d %s %s", BOARD_TEXT_TFT,
    SCU_CHIPID.B.CHID, SCU_CHIPID.B.CHPK, SW_VERSION_TEXT, SAFETY_EVA_BOARD);

    for (i = 0; pmenulist[i].select != 0; i += 1)
    {
        if ((x >= pmenulist[i].xmin) && (x <= pmenulist[i].xmax) && (y == pmenulist[i].y))
        {
            if (conio_driver.dialogmode == DIALOGOFF)
            {
                if (pmenulist[i].display == 0)
                {
                    safetykitMenuSelect(i, (struct DISPLAYENTRY*) &pmenulist[i]);
                }
                else
                {
                    pmenulist[i].select(i, (struct DISPLAYENTRY*) &pmenulist[i]);
                }
            }
        }
        else
        {
            if (pmenulist[i].display == 0)
            {
                safetykitMenuDisplay(i, (struct DISPLAYENTRY*) &pmenulist[i]);
            }
            else
            {
                pmenulist[i].display(i, (struct DISPLAYENTRY*) &pmenulist[i]);
            }
        }
    }
}

#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#else
    #error "Only TASKING is supported, add pragmas for your compiler"
#endif
