/**********************************************************************************************************************
 * \file SMU_Test_output.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*----------------------------------Includes-------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#include <stdio.h>
#include <string.h>
#include "10_Tft/SMU_Test_output.h"
#include "touch.h"
#include "conio_tft.h"
#include "Ifx_types.h"
#include "SafetyKit_Main.h"

/*********************************************************************************************************************/
/*-----------------------------------Macros--------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#define TEXT_ENTRY_NB      20
#define DISPLAY_ENTRIES    (TERMINAL_MAXY-2)

/*********************************************************************************************************************/
/*------------------------------Global variables---------------------------------------------------------------------*/
/*********************************************************************************************************************/


void displayResultsSmuTestOutput(void);
char* testResultToChar(SmuStatusType);
void menuDisplaySmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menuInputSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayScrollDownSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menuInputScrollDownSmuTestOutput   (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectScrollDownSmuTestOutput  (sint32 ind, TDISPLAYENTRY * pdisplayentry);

void menuDisplayScrollupSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menuInputScrollupSmuTestOutput   (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menuSelectScrollUpSmuTestOutput  (sint32 ind, TDISPLAYENTRY * pdisplayentry);

/*********************************************************************************************************************/
/*------------------------Private Variables/Constants----------------------------------------------------------------*/
/*********************************************************************************************************************/
int delta_scroll = 0;
TSTDOUT0TEXT smuTestOutputText[TEXT_ENTRY_NB];

/* Up and down buttons */
const TDISPLAYENTRY SMU_Test_output_menulist[3] = {
    {(COLOR_YELLOW << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 35, TERMINAL_MAXX-1, 2,
            &menuSelectScrollUpSmuTestOutput, &menuDisplayScrollupSmuTestOutput,
            &menuInputScrollupSmuTestOutput, " up "},

    {(COLOR_YELLOW << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 35, TERMINAL_MAXX-1, 17,
            &menuSelectScrollDownSmuTestOutput, &menuDisplayScrollDownSmuTestOutput,
            &menuInputScrollDownSmuTestOutput, "down"},

    {0, 0, 0, 0, 0, 0, 0, 0, " "}  /* Last entry */
};

/*********************************************************************************************************************/
/*-------------------------Function Implementations------------------------------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Fill SMU status structure for TFT
 * */
void initSMUTestOutput(void)
{
    uint32 i = 0;

    strcpy((char *)smuTestOutputText[i].text, "SMU_reg_monitor_test: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.regMonitorTestSmu;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_struct_init: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreInitSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_init: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreInitSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_unlock_config_reg: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_alarm_config: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreAlarmConfigSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_alive_test: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreAliveTestSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_alive_test_clear: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreAliveTestClearSts;
    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_Keys_test: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreKeysTestSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_Keys_test: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreKeysTestSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_Keys_test_clear: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreKeysTestClearSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_FSP_config: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreFSPConfigSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_FSP_reaction_to_alm: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreFSPReactionToAlarmConfigSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_SW_alarm_trigger: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreSWAlarmTriggerSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_stdby_FSP_reaction_enable: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.stdbySmuFspReactionEnableSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_stdby_FSP0_driving_enable: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuStdbyFSP0DrivingEnableSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_stdby_FSP1_driving_enable: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuStdbyFSP1DrivingEnableSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_core_alarm_PES_set: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuCoreAlarmPESSetSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_SFF_trigger_test: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuSafetyFlipFlopTriggerTestSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_SFF_test_result_check: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuSafetyFlipFlopTestResultCheckSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_SFF_alm_flag_clear: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuSafetyFlipFlopTestAlarmFlagClearSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "SMU_recovery_timer_conf: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.smuStatus.smuRecoveryTimerConfigSts;

    i++;
    strcpy((char *)smuTestOutputText[i].text, "All_FB_reg_monitor_test: %s");
    smuTestOutputText[i].status = &g_SafetyKitStatus.regMonitorTestAllFB;
}

/*
 * This function will check SMU status results, if any test is fail, then It trigger SW alarm
 * */
void smuExecutionStatusCheck(void)
{
    for (uint8 i= 0; i < TEXT_ENTRY_NB; i++)
    {
        /* check if any of the SMU status flag is failed */
        if (smuTestOutputText[i].status == fail)
        {
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_SMU);
        }
    }
}

/*----------------------------------------------------------------------------*/
/*                          Display setup function                            */
/*----------------------------------------------------------------------------*/
void showMenuSmuTestOutput (sint16 x, sint16 y, TDISPLAYENTRY * pMenuList)
{
    sint32 i;
    conio_ascii_textbackground(DISPLAYSTDOUT0, COLOR_BLACK);
    conio_ascii_clrscr(DISPLAYSTDOUT0);
    conio_ascii_textcolor(DISPLAYSTDOUT0, COLOR_WHITE);
    conio_ascii_textbackground(DISPLAYSTDOUT0, COLOR_BLACK);

    /* Setup the version name string */
    conio_ascii_printfxy(DISPLAYSTDOUT0, 1, 0, (const uint8*) "%s TC3%d%d %s %s", BOARD_TEXT_TFT,
    SCU_CHIPID.B.CHID, SCU_CHIPID.B.CHPK, SW_VERSION_TEXT, SAFETY_EVA_BOARD);

    for (i = 0; pMenuList[i].select != 0; i += 1)
    {
        if ((x >= pMenuList[i].xmin) && (x <= pMenuList[i].xmax) && (y == pMenuList[i].y))
        {
            if (conio_driver.dialogmode == DIALOGOFF)
            {
                if (pMenuList[i].display == 0)
                {
                    menuSelectSmuTestOutput(i, (struct DISPLAYENTRY*) &pMenuList[i]);
                }
                else
                {
                    pMenuList[i].select(i, (struct DISPLAYENTRY*) &pMenuList[i]);
                }
            }
        }
        else
        {
            if (pMenuList[i].display == 0)
            {
                menuDisplaySmuTestOutput(i, (struct DISPLAYENTRY*) &pMenuList[i]);
            }
            else
            {
                pMenuList[i].display(i, (struct DISPLAYENTRY*) &pMenuList[i]);
            }
        }
    }
    displayResultsSmuTestOutput();
}

/*
 * display the result of SMu status
 * */
void displayResultsSmuTestOutput()
{
    int pos = 1;
    int tab_entry = 0;

    for (tab_entry = delta_scroll; (tab_entry - delta_scroll < DISPLAY_ENTRIES) && (tab_entry < TEXT_ENTRY_NB);
            tab_entry++)
    {
        conio_ascii_printfxy(DISPLAYSTDOUT0, 0, pos++, (uint8*) smuTestOutputText[tab_entry].text,
                testResultToChar(*smuTestOutputText[tab_entry].status));
    }
}

/*
 * convert test result to Char
 * */
char* testResultToChar(SmuStatusType status)
{
    switch (status)
    {
        case (fail) :
            conio_ascii_textattr(DISPLAYSTDOUT0, (COLOR_RED << 4) | COLOR_BLACK);
            return "fail";
            break;

        case (pass) :
            conio_ascii_textattr(DISPLAYSTDOUT0, (COLOR_GREEN << 4) | COLOR_BLACK);
            return "pass";
            break;

        default:
            conio_ascii_textattr(DISPLAYSTDOUT0, (COLOR_BLACK << 4) | COLOR_WHITE);
            return "NA";
            break;
    }
    __debug();
    return NULL_PTR;
}


/*----------------------------------------------------------------------------*/
/*                Display entries behavior handle functions                   */
/*----------------------------------------------------------------------------*/
void menuDisplaySmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, &pdisplayentry->text[0]);
}


void menuSelectSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, &pdisplayentry->text[0]);

    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        /* Clear touch event */
        touch_driver.touchmode &= ~MASK_TOUCH_UP;
    }
}


sint32 menuInputSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    __debug ();
    return (0);
}


/*----------------------------------------------------------------------------*/
/*                                Scroll up                                   */
/*----------------------------------------------------------------------------*/
void menuDisplayScrollupSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYSTDOUT0, pdisplayentry->color_display);
    conio_ascii_gotoxy (DISPLAYSTDOUT0, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYSTDOUT0, pdisplayentry->text);
}


void menuSelectScrollUpSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYSTDOUT0, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYSTDOUT0, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYSTDOUT0, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        /* Clear touch event */
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN;

        delta_scroll--;
        if(delta_scroll<0)delta_scroll = 0;
    }
}


sint32 menuInputScrollupSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    __debug ();
    return (0);
}

/*----------------------------------------------------------------------------*/
/*                               Scroll down                                  */
/*----------------------------------------------------------------------------*/
void menuDisplayScrollDownSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYSTDOUT0, pdisplayentry->color_display);
    conio_ascii_gotoxy (DISPLAYSTDOUT0, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYSTDOUT0, pdisplayentry->text);
}


void menuSelectScrollDownSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYSTDOUT0, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYSTDOUT0, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYSTDOUT0, pdisplayentry->text);

    if ((touch_driver.touchmode & MASK_TOUCH_DOWN) != 0)
    {
        /* Clear touch event */
        touch_driver.touchmode &= ~MASK_TOUCH_DOWN;

        if((TEXT_ENTRY_NB - DISPLAY_ENTRIES) > 0)
        {
            delta_scroll++;
            if(delta_scroll > (TEXT_ENTRY_NB - DISPLAY_ENTRIES))delta_scroll = (TEXT_ENTRY_NB - DISPLAY_ENTRIES);
        }
    }
}


sint32 menuInputScrollDownSmuTestOutput (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    __debug ();
    return (0);
}
