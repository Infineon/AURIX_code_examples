/**********************************************************************************************************************
 * \file SafetyKit_TftShowSmuAlarm.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*----------------------------------Includes-------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#include <08_Ext_Communication/SafetyKit_QSPI_Safe_Communication.h>
#include "01_Smu/SMU/SMU.h"
#include "AppKit_Cfg.h"
#include "Cpu/Std/Ifx_Types.h"
#include "SafetyKit_Main.h"
#include "Configuration.h"
#include "conio_tft.h"
#include "touch.h"
#include "SMU.h"
#include "SafetyKit_SSW_02_MCU_FW_CHECK.h"

#if CPU_WHICH_SERVICE_TFT == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 1) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 2) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 3) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 4) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 5) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_TFT to a valid value!"
#endif


#if USE_SAFETYKIT_TFT
/*********************************************************************************************************************/
/*------------------------Inline Function Prototypes-----------------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------Macros--------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#define SHOWSMUALARM_BUTTONS   4
#define SHOW_SMU_ALARM_ROW     13
#define SHOW_SMU_ALARM_COL     30

/*********************************************************************************************************************/
/*-------------------------Function Prototypes-----------------------------------------------------------------------*/
/*********************************************************************************************************************/
void showSmuAlarmDisplay (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 showSmuAlarmInput (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void showSmuAlarmSelectResetAlm (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void showSmuAlarmSelectIgnore (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void showSmuAlarmSelectResetSmu (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void showSmuAlarmSelectResetSystem (sint32 ind, TDISPLAYENTRY * pdisplayentry);

/*********************************************************************************************************************/
/*------------------------Private Variables/Constants----------------------------------------------------------------*/
/*********************************************************************************************************************/
/*  *INDENT-OFF* */
const uint8 showSmuAlarmOutline[SHOW_SMU_ALARM_ROW][SHOW_SMU_ALARM_COL] = {
    {0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF},
    {0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0x00, 0x00, 0x00, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0x00, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0xB3, 'R', 'E', 'S', 'E', 'T', ' ', 'A', 'L', 'M', 0xB3, 0x00, 0x00, 0x00, 0xB3, 0x00, 'I', 'G', 'N', 'O', 'R', 'E', 0x00, 0xB3, 0x00, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0x00, 0x00, 0x00, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0x00, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0x00, 0x00, 0xDA, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xBF, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0xB3, 'R', 'E', 'S', 'E', 'T', ' ', 'S', 'M', 'U', 0xB3, 0x00, 0x00, 0xB3, 'R', 'E', 'S', 'E', 'T', ' ', 'S', 'Y', 'S', ' ', 0xB3, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0x00, 0x00, 0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9, 0x00, 0xB3},
    {0xB3, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB3},
    {0xC0, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xC4, 0xD9}
};

const TDISPLAYENTRY showSmuAlarmList[SHOWSMUALARM_BUTTONS] = {
    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 9, 17, 11, &showSmuAlarmSelectResetAlm,
            &showSmuAlarmDisplay, &showSmuAlarmInput, "", 0x0},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 23, 30, 11, &showSmuAlarmSelectIgnore,
            &showSmuAlarmDisplay, &showSmuAlarmInput, "", 0x0},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 9, 17, 14, &showSmuAlarmSelectResetSmu,
            &showSmuAlarmDisplay, &showSmuAlarmInput, "", 0x0},

    {(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 22, 31, 14, &showSmuAlarmSelectResetSystem,
            &showSmuAlarmDisplay, &showSmuAlarmInput, "", 0x0}
};
/*  *INDENT-ON* */
/*********************************************************************************************************************/
/*------------------------------Global variables---------------------------------------------------------------------*/
/*********************************************************************************************************************/
uint32 periodicCountSmuAlarm = 0;

IFX_EXTERN const char* messagSMUAlarmsName[AMOUNT_OF_SMU_ALARMS];
IFX_EXTERN char* popMessage;

/*********************************************************************************************************************/
/*-------------------------Function Implementations------------------------------------------------------------------*/
/*********************************************************************************************************************/
/*
 * show SMU alarm display
 * */
void showSmuAlarmDisplay (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    sint32 j;
    for (j = showSmuAlarmList[ind].xmin; j <= showSmuAlarmList[ind].xmax; j += 1)
    {
        conio_ascii_gotoxy(conio_driver.displaymode, j, showSmuAlarmList[ind].y);
        conio_ascii_textchangecolor(conio_driver.displaymode, showSmuAlarmList[ind].color_display);
    }
}

/*
 * show SMU alarm input
 * */
sint32 showSmuAlarmInput (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    __debug();
    return (0);
}

/*
 * special call back for reset the SMU alarm
 * */
void showSmuAlarmSelectResetAlm (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    uint32 j;
    for (j = showSmuAlarmList[ind].xmin; j <= showSmuAlarmList[ind].xmax; j += 1)
    {
        conio_ascii_gotoxy(conio_driver.displaymode, j, showSmuAlarmList[ind].y);
        conio_ascii_textchangecolor(conio_driver.displaymode, showSmuAlarmList[ind].color_select);
    }
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        if (g_SafetyKitStatus.smuAlarmPending.alarmCounter != 0)
        {
            coreAlarmReactionClearSMU(
                    g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter - 1]);
        }

        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
        conio_driver.dialogmode = DIALOGOFF;
        display_ascii_clrscr(conio_driver.displaymode);
        touch_event.status = TOUCH_UP; /*  reset touch status to the correct last status */
    }
}

/*
 * special call back for reset all SMU alarms
 * */
void showSmuAlarmSelectResetSmu (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    uint32 j;
    for (j = showSmuAlarmList[ind].xmin; j <= showSmuAlarmList[ind].xmax; j += 1)
    {
        conio_ascii_gotoxy(conio_driver.displaymode, j, showSmuAlarmList[ind].y);
        conio_ascii_textchangecolor(conio_driver.displaymode, showSmuAlarmList[ind].color_select);
    }
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        resetAllAlarmsSMU();/* This function clears all alarms which are in the g_SafetyKitStatus.smuAlarmPending array */
        safetyKitClearAllSmuAlarms(); /* This function clears all alarms which have their alarm status bit set */

        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
        conio_driver.dialogmode = DIALOGOFF;
        display_ascii_clrscr(conio_driver.displaymode);
        touch_event.status = TOUCH_UP; /*  reset touch status to the correct last status */
    }
}

/*
 * special call back for ignore the alarm
 * */
void showSmuAlarmSelectIgnore (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    uint32 j;
    for (j = showSmuAlarmList[ind].xmin; j <= showSmuAlarmList[ind].xmax; j += 1)
    {
        conio_ascii_gotoxy(conio_driver.displaymode, j, showSmuAlarmList[ind].y);
        conio_ascii_textchangecolor(conio_driver.displaymode, showSmuAlarmList[ind].color_select);
    }
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
        conio_driver.dialogmode = DIALOGOFF;
        conio_ascii_clrscr(conio_driver.displaymode);
        touch_event.status = TOUCH_UP; /*  reset touch status to the correct last status */
    }
}

/*
 * special call back for reset system
 * */
void showSmuAlarmSelectResetSystem (sint32 ind, TDISPLAYENTRY *pdisplayentry)
{
    uint32 j;
    for (j = showSmuAlarmList[ind].xmin; j <= showSmuAlarmList[ind].xmax; j += 1)
    {
        conio_ascii_gotoxy(conio_driver.displaymode, j, showSmuAlarmList[ind].y);
        conio_ascii_textchangecolor(conio_driver.displaymode, showSmuAlarmList[ind].color_select);
    }
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        safetyKitTriggerSwReset(safetyKitResetTypeSystem);

        touch_driver.touchmode &= ~MASK_TOUCH_UP; /* clear */
        conio_driver.dialogmode = DIALOGOFF;
        conio_ascii_clrscr(conio_driver.displaymode);
        touch_event.status = TOUCH_UP; /*  reset touch status to the correct last status */
    }
}

/*
 * Show SMu alarm
 * */
void showSmuAlarm (sint16 x, sint16 y)
{
    sint32 i, j;
    periodicCountSmuAlarm++;
    touch_event.status = TOUCH_MOVE; /*  this is needed that our backlight will be switched on */
    conio_ascii_textcolor(DISPLAYMENU, COLOR_BLACK);

    if (conio_driver.dasdisplaymode != DISPLAYMENU)
        return;

    if (g_SafetyKitStatus.smuAlarmPending.alarmCounter == 0)
    {
        conio_ascii_textbackground(DISPLAYMENU, COLOR_GREEN);
    }
    else
    {
        if (periodicCountSmuAlarm & 0x4)
        {
            conio_ascii_textbackground(DISPLAYMENU, COLOR_RED);
        }
        else
        {
            conio_ascii_textbackground(DISPLAYMENU, COLOR_LIGHTRED);
        }
    }
    for (j = 0; j < SHOW_SMU_ALARM_ROW; j += 1)
    {
        conio_ascii_gotoxy(conio_driver.displaymode, 5, 5 + j);
        for (i = 0; i < SHOW_SMU_ALARM_COL; i += 1)
        {
            conio_ascii_putch(conio_driver.displaymode, showSmuAlarmOutline[j][i]);
        }
    }

    if (g_SafetyKitStatus.smuAlarmPending.alarmCounter == 0)
    {
        popMessage = "No Alarm pending!";
    }
    conio_ascii_printfxy(conio_driver.displaymode, 9, 6, (uint8*) popMessage);

    if (g_SafetyKitStatus.smuAlarmPending.alarmCounter > 0)
    {
        if (messagSMUAlarmsName[g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter
                - 1]->alarmConfig->alarm] == "Soft_Alm10:")
        {
            switch (g_ErrorTypeQspiSafe)
            {
                case 1 : /* CRC error output shown on TFT */
                    conio_ascii_printfxy(conio_driver.displaymode, 9, 8, (uint8*) "QSPI Safe: Early Frame");
                    break;
                case 2 :/* Frame counter error output shown on TFT */
                    conio_ascii_printfxy(conio_driver.displaymode, 9, 8, (uint8*) "QSPI Safe: Late Frame");
                    break;
                case 3 :
                    conio_ascii_printfxy(conio_driver.displaymode, 9, 8, (uint8*) "QSPI Safe: Frame Corrupt");
                    break;
                case 4 :
                    conio_ascii_printfxy(conio_driver.displaymode, 9, 8, (uint8*) "QSPI Safe: Timeout");
                    break;
                default:
                    break;
            }
        }
        else
        {
            conio_ascii_printfxy(conio_driver.displaymode, 9, 8,
                    (uint8*) messagSMUAlarmsName[g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter
                            - 1]->alarmConfig->alarm]);
        }
    }

    conio_ascii_printfxy(conio_driver.displaymode, 9, 9, (uint8*) "Total alarms pending: %u",
            g_SafetyKitStatus.smuAlarmPending.alarmCounter);
    conio_ascii_gotoxy(conio_driver.displaymode, 5, 0);
    /* for all buttons */
    for (i = 0; i < SHOWSMUALARM_BUTTONS; i += 1)
    {
        if ((x >= showSmuAlarmList[i].xmin) && (x <= showSmuAlarmList[i].xmax) && (y == showSmuAlarmList[i].y))
        {
            showSmuAlarmList[i].select(i, (struct DISPLAYENTRY*) &showSmuAlarmList[i]);
        }
        else
        {
            showSmuAlarmList[i].display(i, (struct DISPLAYENTRY*) &showSmuAlarmList[i]);
        }
    }
}

#endif /* USE_SAFETYKIT_TFT */


#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#else
    #error "Only TASKING is supported, add pragmas for your compiler"
#endif
