/**********************************************************************************************************************
 * \file SafetyKit_ClockPlausibility.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <stdio.h>
#include "IfxPort.h"
#include "Ifx_Assert.h"
#include "IfxCpu_Irq.h"
#include "IfxStm.h"
#include "SafetyKit_Main.h"
#include "SafetyKit_Cfg.h"
#include "SafetyKit_ClockPlausibility.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define MASTER_CHANNEL_BAUDRATE     10000000             /* Master channel baud rate 10MHz                           */

#define EXPECTED_TIME               100.01               /* microsecond                                              */
#define TRANSFER_TIME_MAX_LIMIT     (EXPECTED_TIME + (EXPECTED_TIME * 0.05))        /* 5% of expected time           */
#define TRANSFER_TIME_MIN_LIMIT     (EXPECTED_TIME - (EXPECTED_TIME * 0.05))        /* 5% of expected time           */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
QspiDma g_qspiDma;                                              /* Global handle for QSPI communication              */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
static void initQSPI5Master(void);
static void initQSPI5MasterChannel(void);
static void initQSPI5MasterBuffers(void);
static void enableInterruptPT(void);
void checkClockPlausibility(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* DMA Channel 2 Interrupt definition */
IFX_INTERRUPT(isrDMAChn2Tx, CPU_WHICH_RUN_CLK_PLAUS_SM, ISR_PRIORITY_QSPI5_TX_DMA_CH2_CLK_PlAUS);
/* DMA Channel 3 Interrupt definition */
IFX_INTERRUPT(isrDMAChn3Rx, CPU_WHICH_RUN_CLK_PLAUS_SM, ISR_PRIORITY_QSPI5_RX_DMA_CH3_CLK_PlAUS);
/* SPI Master Error Interrupt definition */
IFX_INTERRUPT(isrQSPI5Error, CPU_WHICH_RUN_CLK_PLAUS_SM, ISR_PRIORITY_QSPI5_ER_CLK_PlAUS);
/* QSPI5 Phase Transition Interrupt definition */
IFX_INTERRUPT(isrQSPI5Pt, CPU_WHICH_RUN_CLK_PLAUS_SM, ISR_PRIORITY_QSPI5_PT_CLK_PlAUS);

/* Handle QSPI5 Error interrupt */
void isrQSPI5Error(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrError(&g_qspiDma.spiMaster);
}

/* Handle DMA Channel 2 interrupt */
void isrDMAChn2Tx(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrDmaTransmit(&g_qspiDma.spiMaster);
}

/* Handle DMA Channel 3 interrupt */
void isrDMAChn3Rx(void)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrDmaReceive(&g_qspiDma.spiMaster);
}

/* Handle QSPI5 Phase Transition interrupt */
void isrQSPI5Pt(void)
{
    static uint64 stmStartOfFrame, stmEndOfFrame;
    uint64 eventTime;
    IfxQspi_PhaseTransitionEvent event;

    /* time when event occurs */
    eventTime = IfxStm_get(&MODULE_STM0);

    IfxCpu_enableInterrupts();

    event = IfxQspi_SpiMaster_isrPhaseTransition(&g_qspiDma.spiMaster);
    /* Process phase transition event */
    switch (event)
    {
        /* Start Of Frame (SOF) event */
        case IfxQspi_PhaseTransitionEvent_startOfFrame:
            stmStartOfFrame = eventTime;
            break;

        /* End Of Frame (EOF) event */
        case IfxQspi_PhaseTransitionEvent_endOfFrame:
            stmEndOfFrame = eventTime;

            /* from where 100 below comes
             * Time in second = Ticks / Fstm; Fstm = 100MHz
             *  1 sec = 1000000  microsecond
             * Time in Microsecond = Ticks /100M *  1000000;
             * Time in Microsecond = Ticks/100
             */
            g_SafetyKitStatus.qspiEofandSofTimeDifference.timeDifference = (float32)(stmEndOfFrame - stmStartOfFrame)
                    / 100;
             checkClockPlausibility();
            break;

          /* add other events if needed */
        case IfxQspi_PhaseTransitionEvent_endOfWait:
        case IfxQspi_PhaseTransitionEvent_serialClockPolarityChange:
        case IfxQspi_PhaseTransitionEvent_transmitBufferEmptied:
        case IfxQspi_PhaseTransitionEvent_receiveBufferFilled:
        case IfxQspi_PhaseTransitionEvent_dataNotAvailable:
        case IfxQspi_PhaseTransitionEvent_endOfExpect:
            break;
        default:
            break;
    }
 }

/*
 * enable the Phase Transition interrupt for QSPI5
 * */
static void enableInterruptPT()
{
    volatile Ifx_SRC_SRCR *src = &MODULE_SRC.QSPI.QSPI[5].PT;
    if(CPU_WHICH_RUN_CLK_PLAUS_SM)
    {
        IfxSrc_init(src, (IfxSrc_Tos)(CPU_WHICH_RUN_CLK_PLAUS_SM +1), ISR_PRIORITY_QSPI5_PT_CLK_PlAUS);
    }
    else
    {
        IfxSrc_init(src, (IfxSrc_Tos)CPU_WHICH_RUN_CLK_PLAUS_SM, ISR_PRIORITY_QSPI5_PT_CLK_PlAUS);
    }

    IfxSrc_enable(src);

    /* Configured for PT1 Start Of Frame event */
    IfxQspi_configPT1Event(&MODULE_QSPI5, IfxQspi_PhaseTransitionEvent_startOfFrame);
    IfxQspi_enablePT1Event(&MODULE_QSPI5, TRUE);

    /* Configured for PT1 End Of Frame event */
    IfxQspi_configPT2Event(&MODULE_QSPI5, IfxQspi_PhaseTransitionEvent_endOfFrame);
    IfxQspi_enablePT2Event(&MODULE_QSPI5, TRUE);
}

/*
 * This function initializes QSPI5 in master mode
 * */
static void initQSPI5Master(void)
{
    /* Define the Master Configuration */
    IfxQspi_SpiMaster_Config spiMasterConfig;

    /* Initialize it with default values */
    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, &MODULE_QSPI5);

    /* Set baud rate to 10 MHz */
    spiMasterConfig.base.maximumBaudrate = MASTER_CHANNEL_BAUDRATE;
    /* Select the port pins for communication */
    const IfxQspi_SpiMaster_Pins qspi5Masterpins = {
        &IfxQspi5_SCLK_P14_10_OUT, IfxPort_OutputMode_pushPull,     /* SCLK Pin                          (CLK)  */
        &IfxQspi5_MTSR_P14_6_OUT, IfxPort_OutputMode_pushPull,      /* Master Transmit Slave Receive Pin (MOSI) */
        &IfxQspi5_MRSTB_P14_5_IN, IfxPort_InputMode_pullDown,       /* Master Receive Slave Transmit Pin (MISO) */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                      /* Pad driver mode                          */
    };
    /* Assign Master Pins */
    spiMasterConfig.pins = &qspi5Masterpins;

    /* use DMA for transfer */
    spiMasterConfig.dma.useDma = TRUE;
    spiMasterConfig.dma.txDmaChannelId = IfxDma_ChannelId_2;
    spiMasterConfig.dma.rxDmaChannelId = IfxDma_ChannelId_3;

    /* Set the ISR priorities and the service provider */
    spiMasterConfig.base.txPriority = ISR_PRIORITY_QSPI5_TX_DMA_CH2_CLK_PlAUS;
    spiMasterConfig.base.rxPriority = ISR_PRIORITY_QSPI5_RX_DMA_CH3_CLK_PlAUS;
    spiMasterConfig.base.erPriority = ISR_PRIORITY_QSPI5_ER_CLK_PlAUS;

    if(CPU_WHICH_RUN_CLK_PLAUS_SM)
    {
        spiMasterConfig.base.isrProvider = (IfxSrc_Tos)(CPU_WHICH_RUN_CLK_PLAUS_SM + 1);
    }
    else
    {
        spiMasterConfig.base.isrProvider = (IfxSrc_Tos)CPU_WHICH_RUN_CLK_PLAUS_SM;
    }

    /* Initialize the QSPI Master module using the user configuration */
    IfxQspi_SpiMaster_initModule(&g_qspiDma.spiMaster, &spiMasterConfig);

    /* enable Phase Transition interrupt for QPSI5 only */
    enableInterruptPT();
}

/*
 * This function initializes QSPI5 channel.
 * */
static void initQSPI5MasterChannel(void)
{
    /* Define the Master Channel Configuration  */
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    /* Initialize it with default values */
    IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &g_qspiDma.spiMaster);

    /* Set SCLK frequency to 10 MHz */
    spiMasterChannelConfig.base.baudrate = MASTER_CHANNEL_BAUDRATE;

    /* Set spi master in XXL mode */
    spiMasterChannelConfig.mode = IfxQspi_SpiMaster_Mode_xxl;

    const IfxQspi_SpiMaster_Output qspi5SlaveSelect = {
        &IfxQspi5_SLSO8_P14_15_OUT, IfxPort_OutputMode_pushPull,  /* Slave Select Pin (CS) */
        IfxPort_PadDriver_cmosAutomotiveSpeed1                    /* Pad driver mode       */
    };
    /* Assign Slave port pins */
    spiMasterChannelConfig.sls.output = qspi5SlaveSelect;

    /* Initialize the QSPI Master channel using the user configuration */
    IfxQspi_SpiMaster_initChannel(&g_qspiDma.spiMasterChannel, &spiMasterChannelConfig);

}

/*
 * This function initializes Master SW buffers
 * */
static void initQSPI5MasterBuffers(void)
{
    for (uint32 i = 0; i < SPI_BUFFER_SIZE_XXL; i++)
    {
        /* Fill the SPI Master TX Buffer  */
        g_qspiDma.qspiBuffer.spi3MasterTxBuffer[i] = (uint8)(i + 1);
        /* Clear the SPI Master RX Buffer */
        g_qspiDma.qspiBuffer.spi3MasterRxBuffer[i] = 0;
    }
}

/*
 * This function initializes the QSPI5 module
 * */
void initQSPI5ForClockPlausibility(void)
{
    g_SafetyKitStatus.qspiEofandSofTimeDifference.timeMinimumThreshold = TRANSFER_TIME_MIN_LIMIT;
    g_SafetyKitStatus.qspiEofandSofTimeDifference.timeMaximumThreshold = TRANSFER_TIME_MAX_LIMIT;

    /* Initialize the Master */
    initQSPI5Master();
    initQSPI5MasterChannel();
    initQSPI5MasterBuffers();
}

/*
 * This function ensures the QSPI data transfer by Master i.e. don't need
 * slave for this particular example
 */
void transferDataToCheckClockPlausibility(void)
{
    SpiIf_Status status;
    while (IfxQspi_SpiMaster_getStatus(&g_qspiDma.spiMasterChannel)
           == SpiIf_Status_busy)
    {
        /* Wait until the previous transfer has finished, if any */
    }
    /* send a data stream through the SPI Master */
    status = IfxQspi_SpiMaster_exchange(&g_qspiDma.spiMasterChannel, &g_qspiDma.qspiBuffer.spi3MasterTxBuffer[0],
                               NULL_PTR, SPI_BUFFER_SIZE_XXL);

    /* Wait until the slave received all data */
    while (IfxQspi_SpiSlave_getStatus(&g_qspiDma.spiSlave) == SpiIf_Status_busy)
    {
    }

    /* toggle LED to indicate transfer is done */
    if (status != SpiIf_Status_ok)
    {
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_CLOCK_PLAUS);
    }
    else
    {
        /* transfer is done */
    }
}

/*
 * Function to check clock Plausibility on every EOF event
 * SM:CLOCK:PLAUSIBILITY
 * */
void checkClockPlausibility(void)
{
    /* check clock plausibility range */
    if ((g_SafetyKitStatus.qspiEofandSofTimeDifference.timeDifference > TRANSFER_TIME_MAX_LIMIT) ||
        (g_SafetyKitStatus.qspiEofandSofTimeDifference.timeDifference < TRANSFER_TIME_MIN_LIMIT))
    {
        /* check plausibility test failed, Trigger SMU software alarm */
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_CLOCK_PLAUS);
    }
    else
    {
        /* check plausibility test passed */
    }
}
