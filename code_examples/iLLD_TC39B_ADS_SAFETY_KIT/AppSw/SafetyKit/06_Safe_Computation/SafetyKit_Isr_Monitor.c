/**********************************************************************************************************************
 * \file    SafetyKit_Isr_Monitor.c
  * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <stdio.h>
#include "SafetyKit_Isr_Monitor.h"
#include "IfxPort.h"
#include "IfxGtm_Atom_Timer.h"
#include "Ifx_Types.h"
#include "IfxStdIf_DPipe.h"
#include "AsclinShellInterface.h"
#include "SafetyKit_Cfg.h"

#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "IfxInt_reg.h"
#include "IfxSmu_reg.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Atom_Timer           g_timerDriver;     /* ATOM driver                                                        */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
static uint32 currentTicksOnTimMission = 0;
static uint32 previousTicksOnTimMission = 0;

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ATOM_FREQ             4.0f                     /* ATOM frequency */
#define STM_FREQ              100000000                /* STM is running with 100MHz */
#define ISR_OCCURENCE_TICKS   STM_FREQ / ATOM_FREQ

#define MIN_THRESHOLD_TICK    ISR_OCCURENCE_TICKS - 15
#define MAX_THRESHOLD_TICK    ISR_OCCURENCE_TICKS + 15

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/


/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define the Interrupt Service Routine */
IFX_INTERRUPT(interruptHandlerGtmAtom, ISR_PROVIDER_ISR_MONITOR, ISR_PRIORITY_ATOM_ISR_MONITOR);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Interrupt Service Routine of the ATOM
 * */
void interruptHandlerGtmAtom(void)
{
    IfxGtm_Atom_Timer_acknowledgeTimerIrq(&g_timerDriver);     /* Reset the timer event */
    currentTicksOnTimMission = STM0_TIM0.B.STM_31_0;           /* take the STM ticks value */
}

/*
 * SM:IR:ISR_MONITOR
 * Method 2. Plausibility check for periodic interrupts" according to Safety Manual is applied
 * */
void isrMonitor()
{
    uint32 diffTicksOnTimMission;
    if (currentTicksOnTimMission != previousTicksOnTimMission)
    {
        diffTicksOnTimMission = currentTicksOnTimMission - previousTicksOnTimMission;
        if (diffTicksOnTimMission > MAX_THRESHOLD_TICK || diffTicksOnTimMission < MIN_THRESHOLD_TICK)
        {
            IfxPort_togglePin(ISR_MONITOR_LED_D8.port, ISR_MONITOR_LED_D8.pinIndex);
        }

        previousTicksOnTimMission = currentTicksOnTimMission;
    }
}

/*
 * This function initializes the ATOM
 * SM:GTM_CONFIG_FOR_ATOM
 * */
void initGTMATOM(void)
{
    IfxGtm_enable(&MODULE_GTM);                                                 /* Enable GTM                       */

    IfxGtm_Atom_Timer_Config timerConfig;                                       /* Timer configuration structure    */
    IfxGtm_Atom_Timer_initConfig(&timerConfig, &MODULE_GTM);                    /* Initialize default parameters    */

    timerConfig.atom = IfxGtm_Atom_0;                                           /* Select the ATOM_0                */
    timerConfig.timerChannel = IfxGtm_Atom_Ch_0;                                /* Select channel 0                 */
    timerConfig.clock = IfxGtm_Cmu_Clk_0;                                       /* Select the CMU clock 0           */
    timerConfig.base.frequency = ATOM_FREQ;                                     /* Set timer frequency              */
    timerConfig.base.isrPriority = ISR_PRIORITY_ATOM_ISR_MONITOR;               /* Set interrupt priority           */
    timerConfig.base.isrProvider = IRQ_GET_TOS(ISR_PROVIDER_ISR_MONITOR);       /* Set interrupt provider           */

    IfxGtm_Atom_Timer_init(&g_timerDriver, &timerConfig);                        /* Initialize the ATOM              */
    IfxGtm_Atom_Timer_run(&g_timerDriver);                                      /* Start the ATOM                   */
}

/*
* SM:IR:FFI_CONTROL, user can call this function, in safety kit it is not called because,
 * Alarm will be pop up continuously
*/
void initFFIControl(void)
{
    /*---------------------------------------------------------------------------------------------*/
    /*                        BEGIN CONFIGURATION OF ACCESS ENABLE PROTECTION                      */
    /*---------------------------------------------------------------------------------------------*/

    /* For test: Allow all masters EXCEPT CPU0 */
    uint32 accen_select = ~((1 << IfxBus_TagId_cpu1)|(1 << IfxBus_TagId_cpu1s));

    uint16 sei_pwd = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(sei_pwd);

    /* Access protection of SRBx registers (ACCEN_SRBx) */

    INT_ACCEN_SRB00.U = accen_select;
    INT_ACCEN_SRB10.U = accen_select;
    INT_ACCEN_SRB20.U = accen_select;
    INT_ACCEN_SRB30.U = accen_select;
    INT_ACCEN_SRB40.U = accen_select;
    INT_ACCEN_SRB50.U = accen_select;

    /* Configure ACCEN_SRC_TOSx0 Registers */
    /* Access protection of SRC[31:16] */
    /* See User Manual section "Background / Use Case (SRC[31:16] protected by ACCEN_SRC_TOSx)" for more details.*/
    INT_ACCEN_SRC_TOS00.U = accen_select;
    INT_ACCEN_SRC_TOS10.U = accen_select;
    INT_ACCEN_SRC_TOS20.U = accen_select;

    INT_ACCEN_SRC_TOS30.U = accen_select;
    INT_ACCEN_SRC_TOS40.U = accen_select;
    INT_ACCEN_SRC_TOS50.U = accen_select;
    INT_ACCEN_SRC_TOS60.U = accen_select;

    /* Configure ACCEN_SRC_TOSx1 Registers */
    /* Access protection of SRC[31:16] */
    /* See User Manual section "Background / Use Case (SRC[31:16] protected by ACCEN_SRC_TOSx)" for more details */
    INT_ACCEN_SRC_TOS01.U = accen_select;
    INT_ACCEN_SRC_TOS11.U = accen_select;
    INT_ACCEN_SRC_TOS21.U = accen_select;
    INT_ACCEN_SRC_TOS31.U = accen_select;
    INT_ACCEN_SRC_TOS41.U = accen_select;
    INT_ACCEN_SRC_TOS51.U = accen_select;
    INT_ACCEN_SRC_TOS61.U = accen_select;

    /* Access protection of SRC[15:0] */
    /* See User Manual section "Background / Use Case (SRC[15:0] protected by ACCEN_CONFIG)" for more details. */
    INT_ACCEN_CONFIG0.U = accen_select;

    IfxScuWdt_setSafetyEndinit(sei_pwd);

    /*---------------------------------------------------------------------------------------------*/
    /*                           BEGIN TEST OF ACCESS ENABLE PROTECTION                            */
    /*---------------------------------------------------------------------------------------------*/
    /* Test is not necessary according to the TC3xx Safety Manual. Test is performed for demonstration purposes only. */

    /* In the case of an access protection violation the write is silently ignored, an error is signaled to the SMU.
     * Beside this signaling to the SMU, no other error, interrupt or trap is generated. */

    SRC_CAN0INT0.B.SETR = 1;

    /* Test SRC[15:0] protection */
    SRC_CAN0INT0.B.SRE = 1; /* Attempt to write bit 10 to enable service request*/
    while(SMU_AG10.B.SF22 == 0); /* Wait for alarm to set */
    SMU_CMD.U = 0x5; /* Alarm Status Clear Enable (ASCE) */
    while(SMU_STS.B.ASCE == 0); /* Wait for acceptance of command */
    IfxScuWdt_clearSafetyEndinit(sei_pwd);
    SMU_AG10.B.SF22 = 1; /* Clear alarm */
    IfxScuWdt_setSafetyEndinit(sei_pwd);

    /* Test SRB protection */
    INT_SRB0.U = 0xFF; /* Attempt to trigger all 8 service requests in the broadcast group */
    while(SMU_AG10.B.SF22 == 0); /* Wait for alarm to set */
    SMU_CMD.U = 0x5; /* Alarm Status Clear Enable (ASCE) */
    while(SMU_STS.B.ASCE == 0); /* Wait for acceptance of command */
    IfxScuWdt_clearSafetyEndinit(sei_pwd);
    SMU_AG10.B.SF22 = 1; /* Clear alarm */
    IfxScuWdt_setSafetyEndinit(sei_pwd);
}

/*
 * Test SRC protection
 * for SM:IR:FFI_CONTROL, user can call this function, in safety kit it is not called because,
 * Alarm will be pop up continuously
 * */

void attemptToWrite(void)
{
    /* Test SRC[31:16] protection */
    SRC_CAN0INT0.B.SETR = 1; /* Attempt to write bit 26 to trigger service request */
}
