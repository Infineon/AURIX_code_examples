/**********************************************************************************************************************
 * \file SMU.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*----------------------------------Includes-------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#include <06_Safe_Computation/SafetyKit_NvmPflash.h>
#include "01_Smu/SMU/FSP/SMU_core_FSP.h"
#include "01_Smu/SMU/FSP/SMU_stdby_FSP.h"
#include "01_Smu/SMU/RT/RT.h"
#include "01_Smu/SMU/SMU.h"
#include "01_Smu/SMU_Test/Keys.h"
#include "SafetyKit_SSW_02_MCU_FW_CHECK.h"
#include "SafetyKit_Cfg.h"
#include "SafetyKit_Main.h"
#include "conio_tft.h"
#include "Cpu/Irq/IfxCpu_Irq.h"
#include "Keys.h"

#if CPU_WHICH_RUN_SMU == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 1) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 2) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 3) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 4) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((CPU_WHICH_RUN_SMU == 5) && (CPU_WHICH_RUN_SMU < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set CPU_WHICH_RUN_SMU to a valid value!"
#endif

/*********************************************************************************************************************/
/*------------------------------Global variables---------------------------------------------------------------------*/
/*********************************************************************************************************************/
#if USE_SAFETYKIT_TFT
char* popMessage;
#endif /* USE_SAFETYKIT_TFT */
#if USE_ASC_SHELL
#include "SafetyKit_SmuCmds.h"
#endif /* USE_ASC_SHELL */
IFX_EXTERN ConfigStructRecoveryTimerSMU configRecoveryTimerSMU;
/*-------------------------------------------------------------------------------------------------------------------*/
/*                           CONFIGURABLE BY USER                                                                    */
/*-------------------------------------------------------------------------------------------------------------------*/
/*
 * The array globalAlarmConfig[] holds the configuration of every alarm configured by the user
 * For each alarm, you can:
 *  - configure the internal reaction (trigger interrupts, issue NMI, individual CPU reset or MCU reset)
 *  - enable the external reaction (FSP or PES depending of the PES config: see IfxSmu_configAlarmActionPES function)
 *  - enable the use of recovery timer (currently can only be triggered by alarms max)
 *  - configure a callback function that will be called when alarm is detected
 *
 * Notes:
 *  During program execution, alarms are stored in different arrays according to their internal reaction.
 *  Alarms that needs to be detected as fast as possible should be placed at the first position
 *  of their reaction group section in the globalAlarmConfig[] array.
 *
 *  The use of the recovery timer only makes sense if the internal action is an interrupt or NMI. However no
 *  hardware check is done, it is up to software to configure the SMU_core in the appropriate way.
 *  */
const AlarmConfigStruct globalAlarmConfig[USER_ALARM_NUMBER] =
{
    /*---------------------------------------------------------------------------------------------------------------*/
    /* IfxSmu_Alarm alarm                       IfxSmu_InternalAlarmAction         Enable      Trigger  Function to
                                                                                   external    Recovery call when alarm
                                                                                   reaction    Timer    is detected  */
    /*------------------------------------------------------------- IGCS0 -------------------------------------------*/
    {DEFAULT_ALARM,                              DEFAULT_ALARM_ACTION,               FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_SMU,                           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_ADC,                           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_GTM_TOM_TIM,                   IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_GTM_CCU6_GPT12,                IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_GTM_TIM_TIM,                   IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_GTM_TIM_CCU6,                  IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_GTM_ECKL,                      IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_DMA,                           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_QSPI_SAFE,                     IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_PFLASH,                        IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_PORT_SMs,                     IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {SOFT_SMU_ALM_CLOCK_PLAUS,                   IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_DMA_DMASRI_EccError,           IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_IOM_Pin_MismatchIndication,    IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_EVR_Undervoltage_Alarm,        IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_XBAR_EDC_WritePhaseError,      IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_LMU_EDC_WritePhaseError,       IfxSmu_InternalAlarmAction_igcs0,   FALSE,      FALSE,      NULL_PTR},

    /*------------------------------------------------------------- IGCS1 -------------------------------------------*/
    {IfxSmu_Alarm_CPU0_Lockstep_ComparatorError, IfxSmu_InternalAlarmAction_igcs1,   TRUE,       FALSE,      NULL_PTR},
    {IfxSmu_Alarm_CPU1_Lockstep_ComparatorError, IfxSmu_InternalAlarmAction_igcs1,   TRUE,       FALSE,      NULL_PTR},
    {IfxSmu_Alarm_CPU2_Lockstep_ComparatorError, IfxSmu_InternalAlarmAction_igcs1,   TRUE,       FALSE,      NULL_PTR},
    {IfxSmu_Alarm_CPU3_Lockstep_ComparatorError, IfxSmu_InternalAlarmAction_igcs1,   TRUE,       FALSE,      NULL_PTR},

    /*------------------------------------------------------------- IGCS2 -------------------------------------------*/
    {IfxSmu_Alarm_SMU_Error_PinFaultStateActivation, IfxSmu_InternalAlarmAction_igcs2,  FALSE,    FALSE,     NULL_PTR},
    {IfxSmu_Alarm_SCU_External_EmergencyStopSignalEvent, IfxSmu_InternalAlarmAction_igcs2, FALSE, FALSE,     NULL_PTR},
    {SOFT_SMU_ALM_ADC_BND,                        IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_HSM_Undervoltage_Alarm,         IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_FSI_PFlash_SingleBitError,      IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_FSI_PFlash_DoubleBitError, IfxSmu_InternalAlarmAction_igcs2, FALSE, FALSE, &enableWlFailDetectPFLASH},
    {IfxSmu_Alarm_FSI_Multiple_BitErrorDetectionTrackingBufferFull, IfxSmu_InternalAlarmAction_igcs2,
                                                                                      FALSE,      FALSE,     NULL_PTR},
    {IfxSmu_Alarm_SMU_Access_EnableErrorDetected, IfxSmu_InternalAlarmAction_igcs2,   FALSE,      FALSE,     NULL_PTR},
    /*-------------------------------------------------------------- NMI --------------------------------------------*/
    /* Note: STHE: Watchdog alarm and Recovery timer is not exactly configured as stated in UM section 15.3.1.5.8
     * Watchdog Alarms -> Changes in Recovery Timer configuration needs to be done */
    {SMU_ALARM_WHICH_TRIGGERS_NMI, IfxSmu_InternalAlarmAction_nmi, FALSE, TRUE,       &safetyKitWatchdogAlarmHandling},

    /*------------------------------------------------------------- RESET --------------------------------------------*/
    {IfxSmu_Alarm_SMU_Timer0_TimeOut,             IfxSmu_InternalAlarmAction_reset,   FALSE,      FALSE,      NULL_PTR},
    {IfxSmu_Alarm_SMU_Timer1_TimeOut,             IfxSmu_InternalAlarmAction_reset,   FALSE,      FALSE,      NULL_PTR},

    /*------------------------- CPU RESET (SMU AGC register defines which CPUs are affected by the CPU reset) --------*/

    /*-------------------------------------------------------- Disabled alarms ---------------------------------------*/
    /* Used for SMU ISR test */
    {SOFT_SMU_ALM_CFG_CHECK,                     IfxSmu_InternalAlarmAction_disabled, FALSE,      FALSE,      NULL_PTR},
    /* Will be triggered when Stall CPU button is pressed */
    {IfxSmu_Alarm_SCU_External_RequestUnitAlarm1, IfxSmu_InternalAlarmAction_disabled, FALSE,     FALSE,      NULL_PTR},
    /* Note: STHE: Some times this alarm is raised during fault injection and access other modules. Further
     * investigation needed why this is happening even though access is enabled to all masters. */
    {IfxSmu_Alarm_SPB_BusErrorEvent,              IfxSmu_InternalAlarmAction_disabled, FALSE,     FALSE,      NULL_PTR}
    /*---------------------------------------------------------------------------------------------------------------*/
};

/* alarm message names */
const char* messagSMUAlarmsName[AMOUNT_OF_SMU_ALARMS ]= {
    "CPU0_Lockstep_Error ",
    "CPU0_Bus_MpuViolat- ",
    "CPU0_ReadPathError ",
    "Error ",
    "CPU0_PCACHE_ecc_uncor ",
    "CPU0_PCACHE_edc ",
    "CPU0_PSPR_ecc_cor ",
    "CPU0_PSPR_ecc_uncor ",
    "CPU0_PSPR_edc ",
    "CPU0_DSRP_ecc_cor ",
    "CPU0_DSRP_ecc_uncor ",
    "CPU0_DSRP_edc ",
    "CPU0_DTAG_ecc_cor ",
    "CPU0_DTAG_ecc_uncor ",
    "CPU0_DTAG_edc ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU0_Instr.SriEdc ",
    "CPU0_DataSriEdc ",
    "CPU0_CPU_Except.IntTrap ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU1_Lockstep_Error ",
    "CPU1_Bus_MpuViolat- ",
    "CPU1_ReadPathError ",
    "Error ",
    "CPU1_PCACHE_ecc_uncor ",
    "CPU1_PCACHE_edc ",
    "CPU1_PSPR_ecc_cor ",
    "CPU1_PSPR_ecc_uncor ",
    "CPU1_PSPR_edc ",
    "CPU1_DSRP_ecc_cor ",
    "CPU1_DSRP_ecc_uncor ",
    "CPU1_DSRP_edc ",
    "CPU1_DTAG_ecc_cor ",
    "CPU1_DTAG_ecc_uncor ",
    "CPU1_DTAG_edc ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU1_Instr.SriEdc ",
    "CPU1_DataSriEdc ",
    "CPU1_CPU_Except.IntTrap ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU2_Lockstep_Error ",
    "CPU2_Bus_MpuViolat- ",
    "CPU2_ReadPathError ",
    "Error ",
    "CPU2_PCACHE_ecc_uncor ",
    "CPU2_PCACHE_edc ",
    "CPU2_PSPR_ecc_cor ",
    "CPU2_PSPR_ecc_uncor ",
    "CPU2_PSPR_edc ",
    "CPU2_DSRP_ecc_cor ",
    "CPU2_DSRP_ecc_uncor ",
    "CPU2_DSRP_edc ",
    "CPU2_DTAG_ecc_cor ",
    "CPU2_DTAG_ecc_uncor ",
    "CPU2_DTAG_edc ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU2_Instr.SriEdc ",
    "CPU2_DataSriEdc ",
    "CPU2_CPU_Except.IntTrap ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU3_Lockstep_Error ",
    "CPU3_Bus_MpuViolat- ",
    "CPU3_ReadPathError ",
    "Error ",
    "CPU3_PCACHE_ecc_uncor ",
    "CPU3_PCACHE_edc ",
    "CPU3_PSPR_ecc_cor ",
    "CPU3_PSPR_ecc_uncor ",
    "CPU3_PSPR_edc ",
    "CPU3_DSRP_ecc_cor ",
    "CPU3_DSRP_ecc_uncor ",
    "CPU3_DSRP_edc ",
    "CPU3_DTAG_ecc_cor ",
    "CPU3_DTAG_ecc_uncor ",
    "CPU3_DTAG_edc ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU3_Instr.SriEdc ",
    "CPU3_DataSriEdc ",
    "CPU3_CPU_Except.IntTrap ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU4_Bus_MpuViolat- ",
    "CPU4_ReadPathError ",
    "Error ",
    "CPU4_PCACHE_ecc_uncor ",
    "CPU4_PCACHE_edc ",
    "CPU4_PSPR_ecc_cor ",
    "CPU4_PSPR_ecc_uncor ",
    "CPU4_PSPR_edc ",
    "CPU4_DSRP_ecc_cor ",
    "CPU4_DSRP_ecc_uncor ",
    "CPU4_DSRP_edc ",
    "CPU4_DTAG_ecc_cor ",
    "CPU4_DTAG_ecc_uncor ",
    "CPU4_DTAG_edc ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU4_Instr.SriEdc ",
    "CPU4_DataSriEdc ",
    "CPU4_CPU_Except.IntTrap ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU5_Bus_MpuViolat- ",
    "CPU5_ReadPathError ",
    "Error ",
    "CPU5_PCACHE_ecc_uncor ",
    "CPU5_PCACHE_edc ",
    "CPU5_PSPR_ecc_cor ",
    "CPU5_PSPR_ecc_uncor ",
    "CPU5_PSPR_edc ",
    "CPU5_DSRP_ecc_cor ",
    "CPU5_DSRP_ecc_uncor ",
    "CPU5_DSRP_edc ",
    "CPU5_DTAG_ecc_cor ",
    "CPU5_DTAG_ecc_uncor ",
    "CPU5_DTAG_edc ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "CPU5_Instr.SriEdc ",
    "CPU5_DataSriEdc ",
    "CPU5_CPU_Except.IntTrap ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "MTU_Safety_ecc_unc ",
    "IOM_Safety_ecc_unc ",
    "IR_Safety_ecc_unc ",
    "EMEM_Safety_ecc_unc ",
    "SCU_Safety_ecc_unc ",
    "PMS_Safety_ecc_unc ",
    "DMA_Safety_ecc_unc ",
    "SMU_core_Safety_ecc_unc ",
    "SYS_PLL_Safety_ecc_unc ",
    "Error ",
    "GTM_GTM_ecc_cor ",
    "GTM_GTM_ecc_uncor ",
    "GTM_GTM_edc ",
    "ERAY_ERAY_ecc_cor ",
    "ERAY_ERAY_ecc_uncor ",
    "ERAY_ERAY_edc ",
    "CAN_CAN_ecc_cor ",
    "CAN_CAN_ecc_uncor ",
    "CAN_CAN_edc ",
    "Misc_MISC_ecc_cor ",
    "Misc_MISC_ecc_uncor ",
    "Misc_MISC_edc ",
    "Error ",
    "CERBERUS_ecc_unc ",
    "CCU_Safety_ecc_cor ",
    "CCU_Safety_ecc_unc ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "LMU_FSI_RAM_ecc_cor ",
    "LMU_FSI_RAM_ecc_uncor ",
    "LMU_FSI_RAM_edc ",
    "EMEM_EMEM_ecc_cor ",
    "EMEM_EMEM_ecc_uncor ",
    "EMEM_EMEM_edc ",
    "SPU_CIF_ecc_cor ",
    "SPU_CIF_ecc_uncor ",
    "SPU_CIF_edc ",
    "Error ",
    "Error ",
    "Error ",
    "LMU_Lockstep_Error ",
    "LMU_Lockstep_CtrlErr ",
    "LMU_ECC_Error ",
    "LMU_Buslevel_MpuErr ",
    "LMU_EDC_ReadPhaseErr ",
    "XBAR0_SRI_BusError ",
    "XBAR1_SRI_BusError ",
    "XBAR2_SRI_BusError ",
    "SPB_BusError ",
    "BBB_BusError ",
    "FSI_PFlash_1BitErr ",
    "FSI_PFlash_2BitErr ",
    "FSI_Sgl_Bit_BuffFull ",
    "FSI_Dbl_Bit_BuffFull ",
    "FSI_Multiple_Bit_BuffFull ",
    "FSI_Zero_BitErr_BuffFull ",
    "FSI_PFlash_EccError ",
    "FSI_PFlash_EdcError ",
    "FSI_CPUFLASHCON_Conf ",
    "FSI_Flash_StoredConf ",
    "SCU_OS_Clock_Range ",
    "CCU_BckpClk_Range ",
    "CCU_BckpClck_Alive ",
    "SCU_Sys_PllLockLoss ",
    "SCU_Periph_PllLockLoss ",
    "SCU_LBIST_Alarm ",
    "SCU_ERU_Alarm0 ",
    "SCU_ERU_Alarm1 ",
    "SCU_ERU_Alarm2 ",
    "SCU_ERU_Alarm3 ",
    "SCU_CPU0_Wd_TO ",
    "SCU_CPU1_Wd_TO ",
    "SCU_CPU2_Wd_TO ",
    "SCU_CPU3_Wd_TO ",
    "SCU_CPU4_Wd_TO ",
    "SCU_CPU5_Wd_TO ",
    "SCU_Safety_Wd_TO ",
    "SCU_Watchdog_TimeOut ",
    "SCU_LS_DualRail ",
    "SCU_EmergencyStop ",
    "SCU_Pad_HeatingAlarm ",
    "SCU_LBIST_TestMode ",
    "IR_EDC_ConfDataPath ",
    "DMA_DMASRI_EccError ",
    "Error ",
    "IOM_Pin_Mismatch ",
    "SCU_ERU_Alarm4 ",
    "SCU_ERU_Alarm5 ",
    "SCU_ERU_Alarm6 ",
    "SCU_ERU_Alarm7 ",
    "DTS_core_Under_Temp ",
    "DTS_core_Over_Temp ",
    "DTS_Temp_Overflow ",
    "DTS_Temp_Underflow ",
    "Error ",
    "EVR_Overvoltage ",
    "Error ",
    "EVR_Undervoltage ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "EVR_Short_ToLowHight ",
    "HSM_Overvoltage ",
    "HSM_Undervoltage ",
    "Error ",
    "Error ",
    "EMEM_Unexpected_Write ",
    "EMEM_SEP_ControlLogic ",
    "EMEM_LS_CtrlLogicInput ",
    "SPULCKSTP_Comparator ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "SPU_SPU0_SafetyAlarm ",
    "SPU_SPU1_SafetyAlarm ",
    "RIF_RIF0_SafetyAlarm ",
    "RIF_RIF1_SafetyAlarm ",
    "Soft_Alm0: ISR CFG check ",
    "Soft_Alm1: SMU ",
    "Soft_Alm2: ADC ",
    "Soft_Alm3: ADC BROKEN WIRE",
    "Soft_Alm4: TOMTIM monitor",
    "Soft_Alm5: CCU6GPT12 moni",
    "Soft_Alm6: TIMCCU6 moni",
    "Soft_Alm7: TIMTIM monitor",
    "Soft_Alm8: ECKL monitor",
    "Soft_Alm9: DMA ",
    "Soft_Alm10:",
    "Soft_Alm11: STM monitor",
    "Soft_Alm12: Pflash/Emem ",
    "Soft_Alm13: DTS monitor",
    "Soft_Alm14: Port/Sent ",
    "Soft_Alm15: Clock Plaus",
    "SMU_Timer0_TimeOut ",
    "SMU_Timer1_TimeOut ",
    "SMU_Pin_FS_Activation ",
    "Error ",
    "SMU_Safety_ecc_cor ",
    "SMU_Safety_ecc_unc ",
    "SMU_Access_EnableErrDetect ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "Error ",
    "LMU_EDC_AddPhase ",
    "LMU_EDC_WritePhase ",
    "XBAR_EDC_AddPhase ",
    "XBAR_EDC_WritePhase ",
    "DMU_EDC_AddPhase ",
    "DMU_EDC_WritePhase ",
    "SFI_BBB_EDC_AddPhase ",
    "SFI_BBB_EDC_WritePhase ",
    "SRI_EDC_ReadPhase ",
    "SFI_SPB_EDC_ReadPhase ",
    "HSSL_HSSL0EDC_ReadPhase ",
    "HSSL_HSSL1EDC_ReadPhase ",
    "CONVERTER_Phase_Syncro ",
    "See alarm status regs", /* Normal it should be 'XBAR_SOTA_Swap ", but this alarm is made the default alarm for user*/
};

/* The array configArrayIGCS[3] holds the configuration of each Interrupt Generation Configuration Set (IGCS)
 * Each IGCS can be configured to trigger up to 3 ISR.
 */

IGCSisrBindingStruct configArrayIGCS[3] = {
    {IfxSmu_InternalAlarmAction_igcs0, SmuSR0},
    {IfxSmu_InternalAlarmAction_igcs1, SmuSR1},
    {IfxSmu_InternalAlarmAction_igcs2, SmuSR2}
};


/* Add in this array STDBY_SMU alarms that should trigger FSP
 * The complete list of these alarms can be found in SMU_stdby_FSP.h file
 * and in TC39xB user manual (15.4.1) (STDBY alarms are located in alarm group 20 and 21)
 */
AlarmStdbySMU alarmStdbySMUReactionEnabledFSP[]={
        smuStdbyAlarmEVRVDDOverVoltage,
        smuStdbyAlarmEVRVDDPDOverVoltage
};  /* SMU standby alarms array */
uint8 sizeAlarmStdbySMUReactionEnabledFSP = sizeof(alarmStdbySMUReactionEnabledFSP) / sizeof(AlarmStdbySMU);

/*------------------------------------------------------------------------------------------------------------------*/
/*               USED BY SOFTWARE - NO USER CONFIG NEEDED HERE                                                      */
/*------------------------------------------------------------------------------------------------------------------*/

/* Alarms list for fault source detection -  will be filled by SW */
RuntimeAlarmHandle alarmsThatTriggerIsr0 [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerIsr1 [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerIsr2 [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerNMI  [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatAreDisabled [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerFSP  [USER_ALARM_NUMBER];
RuntimeAlarmHandle alarmsThatTriggerRT   [4]; /* With the current implementation you can configure 4 alarms
                                                                              to trigger a recovery timer */
uint16 nbrAlarmsThatTriggerIsr0 = 0;
uint16 nbrAlarmsThatTriggerIsr1 = 0;
uint16 nbrAlarmsThatTriggerIsr2 = 0;
uint16 nbrAlarmsThatTriggerNMI  = 0;
uint16 nbrAlarmsThatAreDisabled = 0;
uint16 nbrAlarmsThatTriggerFSP  = 0;
uint16 nbrAlarmsThatTriggerRT   = 0;

/* Used to check SMU ISR groups config */
volatile boolean isrConfigTestRunningSMU = FALSE;

/* Used to visualize TFT pop up window for alarms which were configured with default configuration during AppSSW */
RuntimeAlarmHandle runtimeAlarmHandleNotConfiguredAlarm;

/*********************************************************************************************************************/
/*-------------------------Function Prototypes-----------------------------------------------------------------------*/
/*********************************************************************************************************************/
void initFunctionExecutionStatusSMU(SmuExecutionStatusType *SmuExecutionStatusType);
SmuStatusType initSMUAlarmsSMU(void);
SmuStatusType activatSMU(void);
SmuStatusType checkIsrConfigSMU(void);

IFX_INTERRUPT(isr0SMU, CPU_WHICH_RUN_SMU, ISR_PRORITY_SMU_ISR_0);
IFX_INTERRUPT(isr1SMU, CPU_WHICH_RUN_SMU, ISR_PRORITY_SMU_ISR_1);
IFX_INTERRUPT(isr2SMU, CPU_WHICH_RUN_SMU, ISR_PRORITY_SMU_ISR_2);

/*********************************************************************************************************************/
/*-------------------------Function Implementations------------------------------------------------------------------*/
/*********************************************************************************************************************/
/* alarm interrupt routine 0, insert here the routine wanted when the interrupt is called */
void isr0SMU(void)
{
    uint16 nbrRaisedAlarm;

    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* nbr_raised_alarm > 0  : An alarm was triggered which is listed in alarmsThatTriggerIsr1 and which was not
     * yet pending
     * nbr_raised_alarm == 0 : An alarm was triggered which is not listed in alarmsThatTriggerIsr1, therefore it
     * is probably
     * one of the alarms configured with default configuration during Application SSW
     * */
    nbrRaisedAlarm = detectAlarmSourcSMU(&alarmsThatTriggerIsr0[0], nbrAlarmsThatTriggerIsr0);

    if (nbrRaisedAlarm > 0) /* An alarm was triggered which was not yet pending*/
    {
#if USE_SAFETYKIT_TFT
        popMessage = "IGCS0 SMU Alarm! ";
        conio_driver.dialogmode = SHOWSMUALARM;
#endif /* USE_SAFETYKIT_TFT */
        /* ASC_SHELL print is executed from endless background task */
    }
    /* Probably one of the alarms configured with default configuration during Application SSW */
    else if(nbrRaisedAlarm == 0 && DEFAULT_ALARM_ACTION == IfxSmu_InternalAlarmAction_igcs0)
    {
        popMessage = "Default IGCS0 SMU Alarm!";
        IfxCpu_disableInterrupts();
        runtimeAlarmHandleNotConfiguredAlarm = (RuntimeAlarmHandle){&globalAlarmConfig[0], pending};
        g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter] =
                &runtimeAlarmHandleNotConfiguredAlarm;
        g_SafetyKitStatus.smuAlarmPending.alarmCounter++;
        IfxCpu_enableInterrupts();
        conio_driver.dialogmode = SHOWSMUALARM;
    }

    if (!isrConfigTestRunningSMU)
    {
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq0);
    }
}

/* alarm interrupt routine 1, insert here the routine wanted when the interrupt is called */
void isr1SMU(void)
{
    uint16 nbrRaisedAlarm;

    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* nbr_raised_alarm > 0  : An alarm was triggered which is listed in alarmsThatTriggerIsr1 and which was not yet
     * pending
     * nbr_raised_alarm == 0 : An alarm was triggered which is not listed in alarmsThatTriggerIsr1, therefore it is
     * probably
     * one of the alarms configured with default configuration during Application SSW
     * */
    nbrRaisedAlarm = detectAlarmSourcSMU(&alarmsThatTriggerIsr1[0], nbrAlarmsThatTriggerIsr1);

    if (nbrRaisedAlarm > 0)
    {
#if USE_SAFETYKIT_TFT
        popMessage = "IGCS1 SMU Alarm! ";
        conio_driver.dialogmode = SHOWSMUALARM;
#endif /* USE_SAFETYKIT_TFT */
        /* ASC_SHELL print is executed from endless background task */
    }
    /* Probably one of the alarms configured with default configuration during Application SSW */
    else if(nbrRaisedAlarm == 0 && DEFAULT_ALARM_ACTION == IfxSmu_InternalAlarmAction_igcs1)
    {
        popMessage = "Default IGCS1 SMU Alarm!";
        IfxCpu_disableInterrupts();

        runtimeAlarmHandleNotConfiguredAlarm = (RuntimeAlarmHandle){&globalAlarmConfig[0], pending};
        g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter] =
                &runtimeAlarmHandleNotConfiguredAlarm;
        g_SafetyKitStatus.smuAlarmPending.alarmCounter++;
        IfxCpu_enableInterrupts();
        conio_driver.dialogmode = SHOWSMUALARM;
    }
    /* nbr_raised_alarm < 0 : do nothing */

    if (!isrConfigTestRunningSMU)
    {
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq1);
    }
}

/* alarm interrupt routine 2, insert here the routine wanted when the interrupt is called */
void isr2SMU(void)
{
    uint16 nbrRaisedAlarm;

    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* nbr_raised_alarm > 0  : An alarm was triggered which is listed in alarmsThatTriggerIsr1 and which was not yet
     * pending
     * nbr_raised_alarm == 0 : An alarm was triggered which is not listed in alarmsThatTriggerIsr1, therefore it is
     * probably
     * one of the alarms configured with default configuration during Application SSW
     * */
    nbrRaisedAlarm = detectAlarmSourcSMU(&alarmsThatTriggerIsr2[0], nbrAlarmsThatTriggerIsr2);

    if (nbrRaisedAlarm > 0)
    {
#if USE_SAFETYKIT_TFT
        popMessage = "IGCS2 SMU Alarm! ";
        conio_driver.dialogmode = SHOWSMUALARM;
#endif /* USE_SAFETYKIT_TFT */
        /* ASC_SHELL print is executed from endless background task */
    }
    /* Probably one of the alarms configured with default configuration during Application SSW */
    else if(nbrRaisedAlarm == 0 && DEFAULT_ALARM_ACTION == IfxSmu_InternalAlarmAction_igcs2)
    {
        popMessage = "Default IGCS2 SMU Alarm!";
        IfxCpu_disableInterrupts();

        runtimeAlarmHandleNotConfiguredAlarm = (RuntimeAlarmHandle){&globalAlarmConfig[0], pending};
        g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter] =
                &runtimeAlarmHandleNotConfiguredAlarm;
        g_SafetyKitStatus.smuAlarmPending.alarmCounter++;
        IfxCpu_enableInterrupts();
        conio_driver.dialogmode = SHOWSMUALARM;
    }

    if (!isrConfigTestRunningSMU)
    {
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq2);
    }
}

/*
 * check the configuration of SMU ISRs
 * */
SmuStatusType checkIsrConfigSMU(void)
{
    uint8 smuIsrSts;
    uint32 isrTestTimeout = 0xfff;
    TargetPES configPES;


    /* Check if SMU interrupts are setup correctly by triggering SOFT_SMU_ALM_CFG_CHECK (sw_alm0)
     * This alarm is initially configured to trigger IGCS0 reaction, but we will change its config
     * on purpose to also check IGCS1 and IGCS2
     * Also disable PES during test to avoid triggering it
     */

    configPES = SMU_AGC.B.PES;

    /* Unlocks the SMU configuration registers for modification */
    g_SafetyKitStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SafetyKitStatus.unlockConfig == TRUE)
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    IfxSmu_configAlarmActionPES(disablePES);
    IfxSmu_temporaryLockConfigRegisters();

    for (uint8 k=0; k<3; k++)
    {
        IfxSmu_setAlarmAction(SOFT_SMU_ALM_CFG_CHECK, IfxSmu_InternalAlarmAction_igcs0 + k);

        isrConfigTestRunningSMU = TRUE;
        g_SafetyKitStatus.smuStatus.smuCoreSWAlarmTriggerSts = softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_CFG_CHECK);

        /* Wait for configured interrupts to be reached and processed */
        do
        {
            isrTestTimeout--;
            smuIsrSts = SMU_AEX.B.IRQ2STS << 2 | SMU_AEX.B.IRQ1STS << 1 | SMU_AEX.B.IRQ0STS;

        } while((smuIsrSts != configArrayIGCS[k].igcs_config) && (isrTestTimeout > 0));

        isrConfigTestRunningSMU = FALSE;
        IfxSmu_clearAlarmStatus(SOFT_SMU_ALM_CFG_CHECK);
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq0);
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq1);
        IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq2);

        /* Wait until alarmCounter is incremented to decrement it afterwards again and to clear alarm in
         * g_SafetyKitStatus.smuAlarmPending structure */
        volatile uint16 timeout = 0xFFFF;/* Note STHE: added "volatile" as it didn't work always without */
        do
        {
            __nop();
        } while(timeout-- && !g_SafetyKitStatus.smuAlarmPending.alarmCounter);

        if(g_SafetyKitStatus.smuAlarmPending.alarmCounter > 0)
        {
            /* Set alarmState to "notPending", decrement alarmCounter and close TFT POP UP window */
            g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter - 1]->alarmState =
                    notPending;
            g_SafetyKitStatus.smuAlarmPending.alarmCounter--;
            conio_driver.dialogmode = DIALOGOFF;
        }

        if (isrTestTimeout == 0)
        {
            IfxSmu_setAlarmAction(SOFT_SMU_ALM_CFG_CHECK, IfxSmu_InternalAlarmAction_disabled);

            /* Unlocks the SMU configuration registers for modification */
            g_SafetyKitStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
            if (g_SafetyKitStatus.unlockConfig == TRUE)
            {
                g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = pass;
            }
            else
            {
                g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = fail;
            }
            IfxSmu_configAlarmActionPES(configPES);
            IfxSmu_temporaryLockConfigRegisters();

            return fail;
        }
    }
    IfxSmu_setAlarmAction(SOFT_SMU_ALM_CFG_CHECK, IfxSmu_InternalAlarmAction_disabled);

    /* Unlocks the SMU configuration registers for modification */
    g_SafetyKitStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SafetyKitStatus.unlockConfig == TRUE)
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    IfxSmu_configAlarmActionPES(configPES);
    IfxSmu_temporaryLockConfigRegisters();

    return pass;

}

/*
 * activate the  SMU, enable transition from run to fault state and enable configuration of KEYS locked
 * registers and checks if the SMU has really been started
 * */
SmuStatusType activatSMU(void)
{
    boolean configApplied = FALSE;

    IfxSmu_unlockConfigRegisters();

    /* Mandatory check! currently not done by the iLLD function IfxSmu_activateRunState */
    if(MODULE_SMU.DBG.B.SSM == IfxSmu_SmuState_run)
    {
        return pass;
    }
    else if(MODULE_SMU.DBG.B.SSM == IfxSmu_SmuState_start)
    {
        IfxSmu_activateRunState();
        configApplied = (SMU_STS.B.CMD == IfxSmu_Command_start);
        configApplied &= (!SMU_STS.B.RES)&(IfxSmu_getSmuState() == IfxSmu_SmuState_run);
    }
    else if(MODULE_SMU.DBG.B.SSM == IfxSmu_SmuState_fault)
    {
        IfxSmu_releaseFSP();
        uint32 timeout_smu = 0x0FFFFFFF;
        do
        {
            __nop();
        } while(IfxSmu_getSmuState() != IfxSmu_SmuState_run && timeout_smu--);
        configApplied = TRUE;
    }
    else
    {
        __debug();
    }

    IfxSmu_temporaryLockConfigRegisters();

    if(configApplied)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * configure the SMU and registers related to alarm setup according to the globalAlarmConfig array
 * */
SmuStatusType initSMUAlarmsSMU(void)
{
    uint8 smuInterruptsToEnable = configArrayIGCS[0].igcs_config | configArrayIGCS[1].igcs_config
            | configArrayIGCS[2].igcs_config;
    boolean configApplied = FALSE;

    /* Configure alarm internal reaction according to globalAlarmConfig set by user */
    for(int i=0; i<USER_ALARM_NUMBER; i++)
    {
        IfxSmu_setAlarmAction(globalAlarmConfig[i].alarm, globalAlarmConfig[i].alarmReaction);

        /* Each IGCS group can trigger up to 3 isr simultaneously, so each alarm that can trigger a specific
         * isr (according to its IGCS group) is put in the corresponding array to speed-up the alarm source
         * detection process */
        for (uint8 k=0; k<3; k++)
        {
            if (globalAlarmConfig[i].alarmReaction == configArrayIGCS[k].igcs_id)
            {
                if (configArrayIGCS[k].igcs_config & 0x1)
                {
                    alarmsThatTriggerIsr0[nbrAlarmsThatTriggerIsr0] = (RuntimeAlarmHandle){&globalAlarmConfig[i],
                                    notPending};
                    nbrAlarmsThatTriggerIsr0++;
                }
                if (configArrayIGCS[k].igcs_config & 0x2)
                {
                    alarmsThatTriggerIsr1[nbrAlarmsThatTriggerIsr1] = (RuntimeAlarmHandle){&globalAlarmConfig[i],
                                    notPending};
                    nbrAlarmsThatTriggerIsr1++;
                }
                if (configArrayIGCS[k].igcs_config & 0x4)
                {
                    alarmsThatTriggerIsr2[nbrAlarmsThatTriggerIsr2] = (RuntimeAlarmHandle){&globalAlarmConfig[i],
                                    notPending};
                    nbrAlarmsThatTriggerIsr2++;
                }
            }
        }

        /* Check if alarm external reaction is enabled */
        if (globalAlarmConfig[i].externalReactionEnabled)
        {
            alarmsThatTriggerFSP[nbrAlarmsThatTriggerFSP] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatTriggerFSP ++;
        }

        /* Check if alarm should trigger Recovery Timer */
        if (globalAlarmConfig[i].triggerRecoveryTimer)
        {
            alarmsThatTriggerRT[nbrAlarmsThatTriggerRT] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatTriggerRT ++;
        }

        if(globalAlarmConfig[i].alarmReaction == IfxSmu_InternalAlarmAction_nmi)
        {
            alarmsThatTriggerNMI[nbrAlarmsThatTriggerNMI] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatTriggerNMI ++;
        }

        if(globalAlarmConfig[i].alarmReaction == IfxSmu_InternalAlarmAction_disabled)
        {
            alarmsThatAreDisabled[nbrAlarmsThatAreDisabled] = (RuntimeAlarmHandle){&globalAlarmConfig[i], notPending};
            nbrAlarmsThatAreDisabled ++;
        }
    }
    /* Unlocks the SMU configuration registers for modification */
    g_SafetyKitStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SafetyKitStatus.unlockConfig == TRUE)
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }
    /* Configure each Interrupt Generation Configuration Set according to user config */
    IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

    SMU_AGC.B.IGCS0 = configArrayIGCS[0].igcs_config;
    configApplied = (SMU_AGC.B.IGCS0 == configArrayIGCS[0].igcs_config);

    SMU_AGC.B.IGCS1 = configArrayIGCS[1].igcs_config;
    configApplied &= (SMU_AGC.B.IGCS1 == configArrayIGCS[1].igcs_config);

    SMU_AGC.B.IGCS2 = configArrayIGCS[2].igcs_config;
    configApplied &= (SMU_AGC.B.IGCS2 == configArrayIGCS[2].igcs_config);

    IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

    /* Enable required interrupts */
    if (smuInterruptsToEnable & 0x1)
    {

        IfxSrc_init(&SRC_SMU_SMU0_SR0, IfxCpu_Irq_getTos(CPU_WHICH_RUN_SMU), ISR_PRORITY_SMU_ISR_0);
        IfxSrc_enable(&SRC_SMU_SMU0_SR0);
    }

    if (smuInterruptsToEnable & 0x2)
    {

        IfxSrc_init(&SRC_SMU_SMU0_SR1, IfxCpu_Irq_getTos(CPU_WHICH_RUN_SMU), ISR_PRORITY_SMU_ISR_1);
        IfxSrc_enable(&SRC_SMU_SMU0_SR1);
    }

    if (smuInterruptsToEnable & 0x4)
    {

        IfxSrc_init(&SRC_SMU_SMU0_SR2, IfxCpu_Irq_getTos(CPU_WHICH_RUN_SMU), ISR_PRORITY_SMU_ISR_2);
        IfxSrc_enable(&SRC_SMU_SMU0_SR2);
    }

    /* Non Maskable Interrupt config/enabling on CPUs */
    /* Comment and/or uncomment depending on the CPU targeted */
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Enable trap requests for the CPU, which takes care of the SMU software */
#if  CPU_WHICH_RUN_SMU == 0
    SCU_TRAPDIS0.B.CPU0SMUT = 0;
#elif CPU_WHICH_RUN_SMU == 1
    SCU_TRAPDIS0.B.CPU1SMUT = 0;
#elif CPU_WHICH_RUN_SMU == 2
    SCU_TRAPDIS0.B.CPU2SMUT = 0;
#elif CPU_WHICH_RUN_SMU == 3
    SCU_TRAPDIS0.B.CPU3SMUT = 0;
#elif CPU_WHICH_RUN_SMU == 4
    SCU_TRAPDIS1.B.CPU4SMUT = 0;
#elif CPU_WHICH_RUN_SMU == 5
    SCU_TRAPDIS1.B.CPU5SMUT = 0;
#endif

    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    if(configApplied)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * This function enable the structure where we save the config
 * */
void initFunctionExecutionStatusSMU(SmuExecutionStatusType *functionExecutionStatus)
{
    functionExecutionStatus->structInitSts                      = NA;
    functionExecutionStatus->smuCoreAlarmConfigSts              = NA;
    functionExecutionStatus->smuCoreKeysTestSts                 = NA;
    functionExecutionStatus->smuCoreKeysTestClearSts            = NA;
    functionExecutionStatus->stdbySmuFspReactionEnableSts       = NA;
    functionExecutionStatus->smuStdbyFSP0DrivingEnableSts       = NA;
    functionExecutionStatus->smuStdbyFSP1DrivingEnableSts       = NA;
    functionExecutionStatus->smuCoreInitSts                     = NA;
    functionExecutionStatus->smuCoreAlarmPESSetSts              = NA;
    functionExecutionStatus->smuCoreFSPConfigSts                = NA;
    functionExecutionStatus->smuCoreFSPReactionToAlarmConfigSts = NA;
    functionExecutionStatus->smuRecoveryTimerConfigSts          = NA;
    functionExecutionStatus->smuCoreSWAlarmTriggerSts           = NA;
#if 0 /* Following variables should be not reset as this function is called after Application
         Start Up Software where ALIVE_ALARM_TEST and SMU REG_MONITOR_TEST are executed */
    functionExecutionStatus->smuCoreAliveTestSts                    = NA;
    functionExecutionStatus->smuCoreAliveTestClearSts               = NA;
    functionExecutionStatus->smuSafetyFlipFlopTriggerTestSts        = NA;
    functionExecutionStatus->smuSafetyFlipFlopTestResultCheckSts    = NA;
    functionExecutionStatus->smuSafetyFlipFlopTestAlarmFlagClearSts = NA;
    functionExecutionStatus->unlockConfigRegisterSMU                = NA;
#endif
}

/*
 * Initial SMU module
 * */
void initSMUModule(void)
{
    /* Prevention of double SMU reset */
    IfxScuWdt_clearSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());
    SCU_WDTSCON1.B.CLRIRF = 1;
    IfxScuWdt_setSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());

    /* Initialize the structure containing the execution state of SMU sensitive functions */
    initFunctionExecutionStatusSMU(&g_SafetyKitStatus.smuStatus);

    /* Enable the security Key test */
    enableKeysTestSMU();

    /* Reset alarmCounter */
    g_SafetyKitStatus.smuAlarmPending.alarmCounter = 0;

    /* Set result to fail */
    SmuStatusType result = fail;

    /* Fill the RuntimeAlarmHandle structures and configure alarms */
    result = initSMUAlarmsSMU();
    g_SafetyKitStatus.smuStatus.smuCoreAlarmConfigSts = result;

    /* Enable and configure the PES */
    uint8 pesAction = onPESIGCS1;

    g_SafetyKitStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SafetyKitStatus.unlockConfig == TRUE)
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    IfxSmu_configAlarmActionPES(pesAction);
    IfxSmu_temporaryLockConfigRegisters();

    /* Validation if PES configuration was successful */
    IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());
    if(MODULE_SMU.AGC.B.PES != pesAction)
    {
        result = fail;
    }
    IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());
    g_SafetyKitStatus.smuStatus.smuCoreAlarmPESSetSts = result;

    /* Enable and configure the recovery Timer (maximum value for the duration is 0xffffff) */
    enableRecoveryTimerSMU(0xffffff);

    /* Enable and configure the FSP */
    enableFSPcorSMU(IfxSmu_FspMode_TimeSwitchingProtocol, IfxSmu_FspPrescalar1_referenceClockDiv2,
            IfxSmu_FspPrescalar2_referenceClockDiv4096);

    enableFSPstdbySMU();

    /* Enable the SMU */
    result = activatSMU();
    g_SafetyKitStatus.smuStatus.smuCoreInitSts = result;

    /* Check if IGCSx group config is valid and if SMU ISRs are reachable */
    result = checkIsrConfigSMU();
    g_SafetyKitStatus.smuStatus.smuCoreAlarmConfigSts &= result;

}

/*
 * This function configures the alarm action for every alarm which has no default alarm configuration set
 * Note: This function is only configuring every alarm with with default alarm group configuration but
 * SMU configuration and interrupt handling is still required and implemented in the function initMMU_Module.
 * Every alarm which is not explicitly reconfigured in the function initSMUModule will keep the default
 * configuration as configured in this function.
 * */
void safetyKitEnableAllSMUAlarms(void)
{
    /* Enable SMU Module */
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    MODULE_SMU.CLC.B.DISS = 0;
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* First determine the target configuration */
    uint32 alarmGroupCF0[IFXSMU_NUM_ALARM_GROUPS] = {0};
    uint32 alarmGroupCF1[IFXSMU_NUM_ALARM_GROUPS] = {0};
    uint32 alarmGroupCF2[IFXSMU_NUM_ALARM_GROUPS] = {0};

    /* Iterate through all groups */
    for(uint8 alarmGroup = 0; alarmGroup < IFXSMU_NUM_ALARM_GROUPS ; alarmGroup++)
    {
        /* Iterate through all alarms of every group */
        for(uint8 alarmPos = 0 ; alarmPos < 32 ; alarmPos++)
        {
            /* Determine if there is already an alarm action configured for the alarm at position alarmPos
             * of group alarmGroup */
            IfxSmu_InternalAlarmAction alarmAction =
                    (IfxSmu_InternalAlarmAction)(((MODULE_SMU.AGCF[alarmGroup][0].U >> alarmPos) & 0x1)      |
                                                 ((MODULE_SMU.AGCF[alarmGroup][1].U >> alarmPos) & 0x1) << 1 |
                                                 ((MODULE_SMU.AGCF[alarmGroup][2].U >> alarmPos) & 0x1) << 2 );

            /* If the alarm is still disabled enable it with the alarm action defined by the macro
             * DEFAULT_ALARM_ACTION */
            if(alarmAction == IfxSmu_InternalAlarmAction_disabled)
            {
                alarmGroupCF0[alarmGroup] |= ( DEFAULT_ALARM_ACTION         & 0x01) << alarmPos;
                alarmGroupCF1[alarmGroup] |= ((DEFAULT_ALARM_ACTION >> 1)   & 0x01) << alarmPos;
                alarmGroupCF2[alarmGroup] |= ((DEFAULT_ALARM_ACTION >> 2)   & 0x01) << alarmPos;
            }
            /* Else don't modify the alarm action. (Write the previously determined alarmAction to the
             * registers alarmGroupCF0,
             * alarmGroupCF1 and alarmGroupCF2 */
            else
            {
                alarmGroupCF0[alarmGroup] |= ( alarmAction         & 0x01) << alarmPos;
                alarmGroupCF1[alarmGroup] |= ((alarmAction >> 1)   & 0x01) << alarmPos;
                alarmGroupCF2[alarmGroup] |= ((alarmAction >> 2)   & 0x01) << alarmPos;
            }
        }
    }

    /* Unlocks the SMU configuration registers for modification */
    g_SafetyKitStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SafetyKitStatus.unlockConfig == TRUE)
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    for(uint8 alarmGroup = 0; alarmGroup < IFXSMU_NUM_ALARM_GROUPS ; alarmGroup++)
    {
        /* Disable the write-protection for registers */
        IfxScuWdt_clearSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());

        MODULE_SMU.AGCF[alarmGroup][0].U = alarmGroupCF0[alarmGroup];
        MODULE_SMU.AGCF[alarmGroup][1].U = alarmGroupCF1[alarmGroup];
        MODULE_SMU.AGCF[alarmGroup][2].U = alarmGroupCF2[alarmGroup];

        /* Restore back the write-protection for registers */
        IfxScuWdt_setSafetyEndinit(IfxScuWdt_getSafetyWatchdogPassword());
    }

    /* After configuration set temporary lock of SMU configuration */
    IfxSmu_temporaryLockConfigRegisters();
}

/*
 * test if the alarm is really a software alarm, then if so triggers it
 * SM:SMU:APPLICATION_SW_ALARM
 * */
SmuStatusType softwareCoreAlarmTriggerSMU(IfxSmu_Alarm alarm)
{
    boolean configApplied = FALSE;

    /* Check that the alarm is of the good group (10) and that the index is strictly lower
     * than 16 to be sure that the alarm given in parameter is a software alarm
    */
    if( ((alarm/32) == 10) & ((alarm%32) < 16) )
    {
        IfxSmu_setAlarmStatus(alarm);
    }

    configApplied = ~IfxSmu_getAlarmStatus(alarm);
    configApplied &= ~(SMU_STS.B.RES);

    if(configApplied)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * clear the alarm status flag in the AG registers and disable all the reaction
 * configured for this alarm.
 * */
SmuStatusType coreAlarmReactionClearSMU(RuntimeAlarmHandle *activeAlarm)
{
    boolean ack = FALSE;
    SmuSR configIGCSGroup = SmuNAN;

    IfxSmu_clearAlarmStatus(activeAlarm->alarmConfig->alarm);
    ack = (IfxSmu_getAlarmStatus(activeAlarm->alarmConfig->alarm) == 0);

    /* Also clear FSP alarm if FSP was configured to be triggered */
    if (activeAlarm->alarmConfig->externalReactionEnabled)
    {
        /* Alarm has triggered the FSP */
        IfxSmu_clearAlarmStatus(IfxSmu_Alarm_SMU_Error_PinFaultStateActivation);
        IfxSmu_releaseFSP();
    }

    /* Check if alarm group triggers a Port Emergency Stop */
    if (MODULE_SMU.AGC.B.PES == (0x1 << (activeAlarm->alarmConfig->alarmReaction - 0x2)))
    {
        /* EMS has been triggered by SMU */
        if (SMU_AEX.B.EMSSTS && MODULE_SCU.EMSR.B.SEMSF)
        {
            /* Clear SMU EMS status flags */
            IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

            SMU_AEXCLR.B.EMSCLR = 1;
            SMU_AEXCLR.B.EMSAEMCLR = 1;

            IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
        }
    }

    /* Get the config of the used IGCS group */
    for (uint8 i=0; i<3; i++)
    {
        if (activeAlarm->alarmConfig->alarmReaction == configArrayIGCS[i].igcs_id)
        {
            configIGCSGroup = configArrayIGCS[i].igcs_config;
            break;
        }
    }

    /* Reset necessary Action EXecuted IRQx flags */
    if (configIGCSGroup & 0x1)
    {
        IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
        SMU_AEXCLR.B.IRQ0CLR = 1;
        IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

        ack &= ~SMU_AEX.B.IRQ0STS;
    }

    if (configIGCSGroup & 0x2)
    {
        IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
        SMU_AEXCLR.B.IRQ1CLR = 1;
        IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

        ack &= ~SMU_AEX.B.IRQ1STS;
    }

    if (configIGCSGroup & 0x4)
    {
        IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());
        SMU_AEXCLR.B.IRQ2CLR = 1;
        IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline ());

        ack &= ~SMU_AEX.B.IRQ2STS;
    }

    /* SMU STDBY exception for undervoltage alarms */
    /* If IfxSmu_Alarm_EVR_Undervoltage_Alarm or IfxSmu_Alarm_HSM_Undervoltage_Alarm is active the
     * corresponding alarm is SMU_stdby is also active, therefore also reset the standby alarms*/
    if(activeAlarm->alarmConfig->alarm == IfxSmu_Alarm_EVR_Undervoltage_Alarm)
    {
        /* Clear the EVR VEXT under voltage alarm in SMU STDBY */
        ack &= clearBitSMUstdby(smuStdbyAlarmEVRVEXTUnderVoltage);
    }

    if(activeAlarm->alarmConfig->alarm == IfxSmu_Alarm_HSM_Undervoltage_Alarm)
    {
        /* Clear the HSM VEXT under voltage alarm in SMU STDBY */
        ack &= clearBitSMUstdby(smuStdbyAlarmHSMVEXTUnderVoltage);
    }

    if(ack)
    {

        /* If the alarm cleared is not the last of the pending alarm list, we need to replace its
         * value in the list by the last alarm of the list to avoid holes in the list
         */
        if (!(g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter - 1]
                == activeAlarm))
        {
            for (uint16 i=0; i<USER_ALARM_NUMBER; i++)
            {
                if (g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[i] == activeAlarm)
                {
                    g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[i] =
                            g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter - 1];
                }
            }
        }
        g_SafetyKitStatus.smuAlarmPending.alarmCounter--;
        activeAlarm->alarmState = notPending;
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * Detect and report every active alarm not already reported in a specific reaction group
 * */
uint16 detectAlarmSourcSMU(RuntimeAlarmHandle *alarmArray, uint16 nbrAlarms)
{
    uint16 nbrAlarmReported = 0;
    for (uint16 i=0; i<nbrAlarms; i++)
    {
        if (alarmArray[i].alarmState == notPending)
        {
            if (IfxSmu_getAlarmStatus(alarmArray[i].alarmConfig->alarm))
            {
                alarmArray[i].alarmState = pending;
                __disable();
                g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[g_SafetyKitStatus.smuAlarmPending.alarmCounter] =&
                        alarmArray[i];
                g_SafetyKitStatus.smuAlarmPending.alarmCounter++;
                __enable();
                nbrAlarmReported++;

                /* Perform callback function if non void */
                if (alarmArray[i].alarmConfig->functionToCallOnDetection != NULL_PTR)
                {
                    (alarmArray[i].alarmConfig->functionToCallOnDetection)();
                }

                /* Stop recovery timer after alarm handling is done. */
                if (alarmArray[i].alarmConfig->triggerRecoveryTimer)
                {
                    if(configRecoveryTimerSMU.RT0)
                    {
                        IfxSmu_stopRT(0);
                    }

                    if(configRecoveryTimerSMU.RT1)
                    {
                        IfxSmu_stopRT(1);
                    }
                }
            }
        }
        else /* alarmArray[i].alarmState == pending */
        {
            if (IfxSmu_getAlarmStatus(alarmArray[i].alarmConfig->alarm))
            {
                /* Same alarm which is still pending is triggered again.
                 * Therefore only increment counter variable and do nothing else*/
                nbrAlarmReported++;
            }
        }
    }
    return nbrAlarmReported;
}

/*
 * Reset all previously active alarms
 * */
SmuStatusType resetAllAlarmsSMU(void)
{

    SmuStatusType ack = fail;
    uint16 nbrAlarmToClear = g_SafetyKitStatus.smuAlarmPending.alarmCounter;

    for (uint16 i=0; i<nbrAlarmToClear; i++)
    {
        if ( IfxSmu_getAlarmStatus(g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[i]->alarmConfig->alarm) && \
                                  (g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[i]->alarmState == pending))
        {
            ack = coreAlarmReactionClearSMU(g_SafetyKitStatus.smuAlarmPending.lastAlarmRaised[i]);
            if (ack == fail)
            {
                return fail;
            }
        }
        else
        {
            g_SafetyKitStatus.smuAlarmPending.alarmCounter--;
        }
    }

    return pass;
}

/*
 * Call out function for NMI
 * */
void safetyKitNmiCallout(IfxCpu_Trap trapWatch)
{
    /* Check if NMI was called due to an SMU alarm */
    if ((IfxSmu_getAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_nmi)) &&
        (IfxScuCcu_getTrapStatusFlag(IfxScuCcu_Traprequest_smu)))
    {
        /* Implement appropriate reaction */
        {
            sint16 nbrRaisedAlarm;
            /* Check if an alarm, which is intended to trigger an NMI has been triggered, if yes stop recovery timer */
            /* Note: if the alarm is triggered a second time before it got reset via the TFT, the function
             * detectAlarmSourcSMU() will not stop the recovery timer. Therefore, when the Stall CPU button is pressed a
             * second time, the recovery timer will timeout and hence it will trigger a reset. */
            nbrRaisedAlarm = detectAlarmSourcSMU(&alarmsThatTriggerNMI[0], nbrAlarmsThatTriggerNMI);
            if (nbrRaisedAlarm > 0)
            {
#if USE_SAFETYKIT_TFT
                popMessage = "NMI ACTIVATED!";
                conio_driver.dialogmode = SHOWSMUALARM;
#endif /* USE_SAFETYKIT_TFT */
                /* ASC_SHELL print is executed from endless background task */
            }

            /* Clear alarm executed status bit*/
            IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_nmi);

            /* Clear SMU Alarm Trap Request Flag */
            IfxScuCcu_clearTrapStatusFlag(IfxScuCcu_Traprequest_smu);
        }
    }
}

/*
 * Alarm handling functions
 * */
void safetyKitWatchdogAlarmHandling(void)
{
    g_SafetyKitStatus.safetyKitRunTask.stopCpuWatchdogService = FALSE;
    g_SafetyKitStatus.safetyKitRunTask.stopSafetyWatchdogService = FALSE;
}

#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#else
    #error "Only TASKING is supported, add pragmas for your compiler"
#endif
