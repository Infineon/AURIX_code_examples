/**********************************************************************************************************************
 * \file SMU_core_FSP.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*----------------------------------Includes-------------------------------------------------------------------------*/
/*********************************************************************************************************************/
#include "01_Smu/SMU/FSP/SMU_core_FSP.h"
#include "SafetyKit_Main.h"

/*********************************************************************************************************************/
/*------------------------------Global variables---------------------------------------------------------------------*/
/*********************************************************************************************************************/
ConfigStructFSPSMU configFSPSMU;
boolean stateFSP = FALSE;
extern uint16 nbrAlarmsThatTriggerFSP;
extern RuntimeAlarmHandle  alarmsThatTriggerFSP[];

/*********************************************************************************************************************/
/*-------------------------Function Prototypes-----------------------------------------------------------------------*/
/*********************************************************************************************************************/
SmuStatusType configSMUFSPcoreFSP0(void);
SmuStatusType configSMUFSPcoreFSP1(void);
SmuStatusType configSMUFSPcore(ConfigStructFSPSMU configFSPSMU);
SmuStatusType configReactionToAlarmSMUFSPcore(void);

/*********************************************************************************************************************/
/*-------------------------Function Implementations------------------------------------------------------------------*/
/*********************************************************************************************************************/
/*
 * enable P33.8 to be used as error pin for FSP0 and checks if the config has really been applied
 * SM:FSP_ERROR_PIN_MONITOR
 * */
SmuStatusType configSMUFSPcoreFSP0(void)
{
    boolean bool = TRUE;

    /* Set driver strength of P33.8 to maximum */
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    P33_PDR1.B.PD8 = 0;
    bool = (P33_PDR1.B.PD8 == 0);
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Set p33.8 as an output, pushpull, general purpose output GPO */
    P33_IOCR8.B.PC8 = 0x10;
    bool &= (P33_IOCR8.B.PC8 == 0x10);

    /* Enable SMU to override pad configuration for FSP pin 8 */
    IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
    P33_PCSR.B.SEL8 = 1;
    bool &= (P33_PCSR.B.SEL8 == 1);
    IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

    if(bool)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * enable P33.10 to be used as error pin for FSP1 and checks if the config has really been applied
 */
SmuStatusType configSMUFSPcoreFSP1(void)
{
    boolean bool;

    /* set driver strength of P33.10 to maximum */
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    P33_PDR1.B.PD10 = 0;
    bool = (P33_PDR1.B.PD10 == 0);
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* set p33.10 as an output, pushpull, general purpose output GPO */
    P33_IOCR8.B.PC10 = 0x10;
    bool &= (P33_IOCR8.B.PC10 == 0x10);

    /* Enable SMU to override pad configuration for FSP pin 10 */
    IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
    P33_PCSR.B.SEL10 = 0;
    bool &= (P33_PCSR.B.SEL10 == 0);
    IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

    if(bool)
        return pass;
    else
        return fail;
}

/*
 * Enable FSP0 to be working with the configuration set in configFSPSMU and checks if the config has
 * really been applied to the FSP registers
 * Note:when the mode chosen is bi-stable or dual rail, to be able to see the fault -> fault free state
 * transition,wait at least 250ns between the triggering of two FSP triggering alarm
 */
SmuStatusType configSMUFSPcore(ConfigStructFSPSMU configFSPSMU)
{
    boolean bool = FALSE;
    boolean fspInFaultFreeState = FALSE;
    boolean discardSmuCmdResult = FALSE;
    SmuStatusType result;

    /* unlock KEYS locked register and enable SMU configuration */
    g_SafetyKitStatus.unlockConfig &= IfxSmu_unlockConfigRegisters();
    if (g_SafetyKitStatus.unlockConfig == TRUE)
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = pass;
    }
    else
    {
        g_SafetyKitStatus.smuStatus.unlockConfigRegisterSMU = fail;
    }

    /* enable FAULT to RUN state transition */
    IfxSmu_enableFaultToRunState(TRUE);

    IfxSmu_setFspMode(configFSPSMU.fspMode);

    /* bool = (MODULE_SMU.FSP.B.MODE == configFSPSMU.fspMode); */
    bool = ( ((MODULE_SMU.FSP.U & 0x60) >> 5) == configFSPSMU.fspMode);

    /* Check if PES in SMU AGC register is enabled */
    IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());
    Ifx_SMU_AGC agcRegVal = MODULE_SMU.AGC;
    IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());

    if(agcRegVal.B.PES != disablePES)
    {
        /* If PES is enabled configure FSP for Port Emergency Stop */
        IfxSmu_enablePortEmergencyStop(TRUE);

        /* Validation if PES configuration was successful. */
        IfxScuWdt_clearSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());
        bool &= (MODULE_SMU.FSP.B.PES == 1);
        IfxScuWdt_setSafetyEndinitInline(IfxScuWdt_getSafetyWatchdogPasswordInline());
    }


    switch (configFSPSMU.fspMode)
    {
        case IfxSmu_FspMode_BiStableProtocol:

            result = configSMUFSPcoreFSP0();
            bool &= (result == pass);

            IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

            /* Give Port control to SMU
             *  PAD in output state
             *  PAD configuration controlled by SMU
             *  Port enable and port output driven by SMU FSP signal (Error Pin)
             *  Puts the FSP0 in output state, pushpull and driven by SMU */
            SMU_PCTL.U = 0x8D;

            IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

            /*  Check if FSP is already in fault free state (FSP pin state is not affected by system reset for example)
                In bistable mode, FSP is in fault free state when FSP0 = 1. (FSP1 is unused, check user manual for
                details) */
            if ((SMU_STS.B.FSP & 0x1) == 1)
            {
                fspInFaultFreeState = TRUE;
            }

            break;

        case IfxSmu_FspMode_dualRailProtocol:

            result = configSMUFSPcoreFSP0();
            bool &= (result == pass);
            result = configSMUFSPcoreFSP1();
            bool &= (result == pass);

            IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

            SMU_FSP.B.PRE1 = configFSPSMU.fspPre1;
            SMU_FSP.B.PRE2 = configFSPSMU.fspPre2;
            SMU_FSP.B.TFSP_HIGH = 0x3FF;

            /* Give Port control to SMU
             * PAD in output state
             * PAD configuration controlled by SMU
             * Port enable and port output driven by SMU FSP signal (Error Pin)
             * Puts the FSP0 and FSP1 in output state, pushpull and driven by SMU */
            SMU_PCTL.U = 0x8F;

            IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

            bool &= (SMU_FSP.B.PRE1 == configFSPSMU.fspPre1);
            bool &= (SMU_FSP.B.PRE2 == configFSPSMU.fspPre2);
            bool &= (SMU_FSP.B.TFSP_HIGH == 0x3FF);
            bool &= ((SMU_PCTL.U && 0xFF) == 0x8F);

            /* Check if FSP is already in fault free state (FSP pin state is not affected by system reset for example)
               In dual rail mode, (FSP0 xor FSP1) == 1 characterize the fault free state, check user manual for more
               details */
            if ((SMU_STS.B.FSP & 0x1) ^ (SMU_STS.B.FSP & 0x2))
            {
                fspInFaultFreeState = TRUE;
            }

            break;

        case IfxSmu_FspMode_TimeSwitchingProtocol:
            result = configSMUFSPcoreFSP0();
            bool &= (result == pass);

            IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

            SMU_FSP.B.PRE1 = configFSPSMU.fspPre1;
            SMU_FSP.B.PRE2 = configFSPSMU.fspPre2;
            SMU_FSP.B.TFSP_HIGH = 0x3FF;

            /* Give Port control to SMU
             * PAD in output state
             * PAD configuration controlled by SMU
             * Port enable and port output driven by SMU FSP signal (Error Pin)
             * Puts the FSP0  in output state, pushpull and driven by SMU */
            SMU_PCTL.U = 0x8D;

            IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

            bool &= (SMU_FSP.B.PRE1 == configFSPSMU.fspPre1);
            bool &= (SMU_FSP.B.PRE2 == configFSPSMU.fspPre2);
            bool &= ((SMU_PCTL.U & 0xFF) == 0x8D);
            bool &= (SMU_FSP.B.TFSP_HIGH == 0x3FF);

            /* In this mode, it is hard to know if the FSP is not already in fault free state without stalling the
             * config and thus program startup for a significant amount of time. To avoid this problem, we can rely
             * on the last reset type (a previous FSP fault free state can only be preserved through system or
             * application reset). Nevertheless, the FSP might still be in fault state, so to avoid any errors, we
             * can just not take into account the result of the SMU FSP release command in this case */
            if ((g_SafetyKitStatus.resetCode.resetType == safetyKitResetTypeSystem) ||
                (g_SafetyKitStatus.resetCode.resetType == safetyKitResetTypeApplication))
            {
                discardSmuCmdResult = TRUE;
            }
            break;

            default:
                break;
    }

    /* If FSP is already in fault free state, issuing the SMU FSP release command will cause an error
     * (command will fail) */
    if (!fspInFaultFreeState)
    {
        /* FSP release */
        SMU_CMD.U = IfxSmu_Command_releaseFSP;

        if (!discardSmuCmdResult)
        {
            bool &= (SMU_STS.B.RES == 0);
        }
    }

    if(bool)
        return pass;
    else
        return fail;
}

/*
 * configures the SMU_AGx_FSP registers according to the alarms that are present in the tab_alarm_FSP_reaction_enabled
 * array and checks if the configurations asked has really been applied
 */
SmuStatusType configReactionToAlarmSMUFSPcore(void)
{
    boolean bool = TRUE;

    /* First disable AG 10 register */
    IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
    MODULE_SMU.AGFSP[10].U = 0x00000000;
    IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

    /* FSP test in bi-stable mode FSP reaction to alarm setup */
    for (int k=0; k<nbrAlarmsThatTriggerFSP; k++)
    {
        IfxSmu_Alarm alarm = alarmsThatTriggerFSP[k].alarmConfig->alarm;
        uint16  alarmGroup  = (int)alarm / 32;
        uint8   alarmPos    = (int)alarm % 32;

        IfxScuWdt_clearSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());

        MODULE_SMU.AGFSP[alarmGroup].U |= (1<<(alarmPos));
        bool &= ((MODULE_SMU.AGFSP[alarmGroup].U && 1<<(alarmPos))== 1);

        IfxScuWdt_setSafetyEndinitInline (IfxScuWdt_getSafetyWatchdogPasswordInline ());
    }

    if(bool)
    {
        return pass;
    }
    else
    {
        return fail;
    }
}

/*
 * configures the FSP for the core alarm
 * Note: when the mode chosen is bi-stable or dual rail, to be able to see wait at least
 * 250ns between the triggering of two FSP triggering alarm
 * */
void enableFSPcorSMU(IfxSmu_FspMode fspMode, IfxSmu_FspPrescalar1 prescalar1, IfxSmu_FspPrescalar2 prescalar2)
{
    if (nbrAlarmsThatTriggerFSP != 0)
    {
        stateFSP = TRUE;

        /* Bi_stable FSP */
        if(fspMode == IfxSmu_FspMode_BiStableProtocol)
        {
            configFSPSMU.fspMode = IfxSmu_FspMode_BiStableProtocol;
        }
        /* Time_switching or Dual_rail FSP config */
        else
        {
            configFSPSMU.fspMode = fspMode;
            /* Tempo duration */
            configFSPSMU.fspPre1 = prescalar1;
            configFSPSMU.fspPre2 = prescalar2;
        }

        SmuStatusType result = fail;
        result = configSMUFSPcore(configFSPSMU);
        g_SafetyKitStatus.smuStatus.smuCoreFSPConfigSts = result;

        result = configReactionToAlarmSMUFSPcore();
        g_SafetyKitStatus.smuStatus.smuCoreFSPReactionToAlarmConfigSts = result;
    }
}
