/**********************************************************************************************************************
 * \file    SafetyKit_QSPI_Safe_Communication.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyKit_Fce.h"
#include "SafetyKit_QSPI_Safe_Communication.h"
#include "IfxPort.h"
#include "SMU.h"
#include "SafetyKit_Cfg.h"
#include "IfxCpu_IntrinsicsTasking.h"
#include "IfxStm.h"
#include "SafetyKit_Main.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* QSPI Master */
#define QSPI4_MASTER              &MODULE_QSPI4   /* SPI Master module                                             */
#define MASTER_DATA_ID            0x01
#define DATA_WIDTH                32              /* 32 bits                                                       */
#define MASTER_CHANNEL_BAUDRATE   1000000         /* Master channel baud rate                                      */
#define DATA_ARRAY_LENGTH         BUFFER_SIZE * BUFFER_SIZE

/*QSPI Slave */
#define QSPI3_SLAVE               &MODULE_QSPI3   /* SPI Slave module                                              */
#define FRAME_SIZE_BIT            ((float64)(DATA_WIDTH * FRAME_SIZE))
#define FRAME_TRANSFER_TIME       ((float64)(1/MASTER_CHANNEL_BAUDRATE * FRAME_SIZE_BIT)) /* 0.224ms one frame time */
#define TOTAL_TIME                (float64)(100.0f + FRAME_TRANSFER_TIME)
#define THRESHOLD                 0.5f               /* 0.5ms */
#define EARLY_FRAME_TIME          TOTAL_TIME - THRESHOLD
#define LATE_FRAME_TIME           TOTAL_TIME + THRESHOLD
#define FRAME_TIMEOUT             (TOTAL_TIME + TOTAL_TIME)

#define SEC_TO_MILLISEC           1000             /* 1sec = 1000ms */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
qspiSafeComm g_qspiSafe;
uint8 g_ErrorTypeQspiSafe = 0;                      /* global variable for the error code */
uint8 g_cyclTimeQSPI = NORMAL_CYCLE_TIME;

volatile boolean g_frameReceived = FALSE;           /* flag once complete frame is received */

uint32 payloadData[DATA_ARRAY_LENGTH] =     /* Payload Data */
{
    0x0e9957bb, 0x1c706c1e, 0x14c3db3f, 0x7fb17a93,
    0xb0d9d5a7, 0x768093e0, 0x88b206a0, 0xc51299e4,
    0x00000011, 0x00000022, 0x00000033, 0x00000044,
    0xaabbccdd, 0x11223344, 0xdeff0022, 0x88df5ef9
};

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initQSPI4Master(void);
void initQSPI4MasterChannel(void);
void initQSPI3Slave(void);
void updateMasterBuffer(void);
void slaveDataValidation(uint32 frameCounterSlaveQSPI);

/*********************************************************************************************************************/
/*----------------------------------------------Function Implementations---------------------------------------------*/
/*********************************************************************************************************************/
IFX_INTERRUPT(masterQSPI4TxISR, CPU_WHICH_RUN_MASTER_QSPI_SAFE_COMM, ISR_PRIORITY_MASTER_TX_QSPI_SAFE);
IFX_INTERRUPT(masterQSPI4RxISR, CPU_WHICH_RUN_MASTER_QSPI_SAFE_COMM, ISR_PRIORITY_MASTER_RX_QSPI_SAFE);
IFX_INTERRUPT(masterQSPI4ErISR, CPU_WHICH_RUN_MASTER_QSPI_SAFE_COMM, ISR_PRIORITY_MASTER_ER_QSPI_SAFE);
IFX_INTERRUPT(slaveQSPI3TxISR, CPU_WHICH_RUN_SLAVE_QSPI_SAFE_COMM, ISR_PRIORITY_SLAVE_TX_QSPI_SAFE);
IFX_INTERRUPT(slaveQSPI3RxISR, CPU_WHICH_RUN_SLAVE_QSPI_SAFE_COMM, ISR_PRIORITY_SLAVE_RX_QSPI_SAFE);
IFX_INTERRUPT(slaveQSPI3ErISR, CPU_WHICH_RUN_SLAVE_QSPI_SAFE_COMM, ISR_PRIORITY_SLAVE_ER_QSPI_SAFE);

/* SPI Master ISR for transmit data */
void masterQSPI4TxISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrTransmit(&g_qspiSafe.spiSafeComMaster);
}

/* SPI Master ISR for receive data */
void masterQSPI4RxISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrReceive(&g_qspiSafe.spiSafeComMaster);
}

/* SPI Master ISR for error */
void masterQSPI4ErISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrError(&g_qspiSafe.spiSafeComMaster);
}

/* SPI Slave ISR for transmit data */
void slaveQSPI3TxISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrTransmit(&g_qspiSafe.spiSafeComSlave);
}

/*
 * SPI Slave ISR for receive data
 * This Interrupt occur for each data of 32 bits received (9 times for one frame)
 * */
void slaveQSPI3RxISR()
{
    static uint8 messageCounter = 0;
    static uint32 frameCounterSlaveQSPI = 0;      /* Frame counter for receiving */

    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrReceive(&g_qspiSafe.spiSafeComSlave);
    messageCounter++;

    /* check if the complete frame of FRAME_SIZE is received */
    if(messageCounter == FRAME_SIZE)
    {
        messageCounter = 0;

        g_frameReceived = TRUE;

        /* data validation */
        slaveDataValidation(frameCounterSlaveQSPI++);

        /* Instruct the SPI Slave to receive a next data stream of defined length */
        IfxQspi_SpiSlave_exchange(&g_qspiSafe.spiSafeComSlave, NULL_PTR,
                &g_qspiSafe.spiSafeComBuffers.qspiSlaveRx.data[0], FRAME_SIZE);

    }
}

/* SPI Slave ISR for error */
void slaveQSPI3ErISR()
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiSlave_isrError(&g_qspiSafe.spiSafeComSlave);
}

/*
 * get time in millisecond
 * */
float64 getMilliSecondTime()
{
    return ((IfxStm_get(&MODULE_STM3) / IfxStm_getFrequency(&MODULE_STM3)) * SEC_TO_MILLISEC);
}

/*
 * button to change the QSPI Cycle time
 * */
void getErrroInjectionStatus(void)
{
    static uint8 flagErrorInjection = 0;
    static boolean previousState = FALSE;
    static boolean currentState;

    /* Current state of button if it is pressed or not */
    currentState = IfxPort_getPinState(ADDITIONAL_BUTTON2.port, ADDITIONAL_BUTTON2.pinIndex);

    /* if the button state is pressed and previous was not press only then we start update check */
    if (TRUE == currentState && FALSE == previousState)
    {
        flagErrorInjection++;
        if (flagErrorInjection == 1)
        {
            g_cyclTimeQSPI = EARLY_CYCLE_TIME;
        }
        else if (flagErrorInjection == 2)
        {
            g_cyclTimeQSPI = LATE_CYCLE_TIME;
        }
        else if (flagErrorInjection == 3)
        {
            g_cyclTimeQSPI = NORMAL_CYCLE_TIME;
            flagErrorInjection = 0;
        }
    }

    /* stored the state if pin */
    previousState = IfxPort_getPinState(ADDITIONAL_BUTTON2.port, ADDITIONAL_BUTTON2.pinIndex);
}

/* QSPI Master initialization
 * This function initializes the QSPI4 module in Master mode.
 */
void initQSPI4Master(void)
{
    IfxQspi_SpiMaster_Config spiMasterConfig;                           /* Define a Master configuration            */

    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, QSPI4_MASTER); /* Initialize it with default values        */

    spiMasterConfig.base.mode = SpiIf_Mode_master;                      /* Configure the mode                       */

    /* Select the port pins for communication */
    const IfxQspi_SpiMaster_Pins qspi4MasterPins = {
        &IfxQspi4_SCLK_P22_3_OUT, IfxPort_OutputMode_pushPull,          /* SCLK Pin                       (CLK)     */
        &IfxQspi4_MTSR_P22_0_OUT, IfxPort_OutputMode_pushPull,          /* MasterTransmitSlaveReceive pin (MOSI)    */
        &IfxQspi4_MRSTB_P22_1_IN, IfxPort_InputMode_pullDown,           /* MasterReceiveSlaveTransmit pin (MISO)    */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                          /* Pad driver mode                          */
    };
    spiMasterConfig.pins = &qspi4MasterPins;                            /* Assign the Master's port pins            */

    /* Set the ISR priorities and the service provider */
    spiMasterConfig.base.txPriority = ISR_PRIORITY_MASTER_TX_QSPI_SAFE;
    spiMasterConfig.base.rxPriority = ISR_PRIORITY_MASTER_RX_QSPI_SAFE;
    spiMasterConfig.base.erPriority = ISR_PRIORITY_MASTER_ER_QSPI_SAFE;
    spiMasterConfig.base.isrProvider = IfxSrc_Tos_cpu2;

    /* Initialize the QSPI Master module */
    IfxQspi_SpiMaster_initModule(&g_qspiSafe.spiSafeComMaster, &spiMasterConfig);
}

/* QSPI Master channel initialization
 * This function initializes the QSPI4 Master channel.
 */
void initQSPI4MasterChannel(void)
{
    /* Define a Master Channel configuration */
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    /* Initialize the configuration with default values */
    IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &g_qspiSafe.spiSafeComMaster);

    /* Set SCLK frequency to 1 MHz */
    spiMasterChannelConfig.base.baudrate = MASTER_CHANNEL_BAUDRATE;
    spiMasterChannelConfig.base.mode.dataWidth = DATA_WIDTH;

    /* Select the port pin for the Chip Select signal */
    const IfxQspi_SpiMaster_Output qspi4SlaveSelect = {                 /* QSPI1 Master selects the QSPI1 Slave     */
        &IfxQspi4_SLSO3_P22_2_OUT, IfxPort_OutputMode_pushPull,         /* Slave Select port pin (CS)               */
        IfxPort_PadDriver_cmosAutomotiveSpeed1                          /* Pad driver mode                          */
    };
    spiMasterChannelConfig.sls.output = qspi4SlaveSelect;

    /* Initialize the QSPI Master channel */
    IfxQspi_SpiMaster_initChannel(&g_qspiSafe.spiSafeComMasterChannel, &spiMasterChannelConfig);
}

/*
 * QSPI Slave initialization
 * This function initializes the QSPI3 module in Slave mode.
 */
void initQSPI3Slave(void)
{
    /* Define the Slave configuration */
    IfxQspi_SpiSlave_Config spiSlaveConfig;

    /* Initialize it with default values */
    IfxQspi_SpiSlave_initModuleConfig(&spiSlaveConfig, QSPI3_SLAVE);
    spiSlaveConfig.protocol.dataWidth = DATA_WIDTH;
    /* Select the port pins for communication */
    const IfxQspi_SpiSlave_Pins qspi3SlavePins = {
        &IfxQspi3_SCLKA_P02_7_IN, IfxPort_InputMode_pullDown,           /* SCLK Pin                       (CLK)     */
        &IfxQspi3_MTSRA_P02_6_IN, IfxPort_InputMode_pullDown,           /* MasterTransmitSlaveReceive pin (MOSI)    */
        &IfxQspi3_MRST_P02_5_OUT, IfxPort_OutputMode_pushPull,          /* MasterReceiveSlaveTransmit pin (MISO)    */
        &IfxQspi3_SLSIA_P02_4_IN, IfxPort_InputMode_pullDown,           /* SlaveSelect Pin                (CS)      */
        IfxPort_PadDriver_cmosAutomotiveSpeed3                          /* Pad driver mode                          */
    };
    spiSlaveConfig.pins = &qspi3SlavePins;                              /* Assign Slave port pins                   */

    /* Set the ISR priorities and the service provider */
    spiSlaveConfig.base.txPriority = ISR_PRIORITY_SLAVE_TX_QSPI_SAFE;
    spiSlaveConfig.base.rxPriority = ISR_PRIORITY_SLAVE_RX_QSPI_SAFE;
    spiSlaveConfig.base.erPriority = ISR_PRIORITY_SLAVE_ER_QSPI_SAFE;
    spiSlaveConfig.base.isrProvider = IfxSrc_Tos_cpu3;

    /* Initialize QSPI Slave module */
    IfxQspi_SpiSlave_initModule(&g_qspiSafe.spiSafeComSlave, &spiSlaveConfig);
}

/* This function initialize the QSPI modules */
void initQSPISafeCommunication(void)
{
    /* Initial button for injecting error */
    IfxPort_setPinModeInput(ADDITIONAL_BUTTON2.port, ADDITIONAL_BUTTON2.pinIndex, IfxPort_Mode_inputPullDown);

    /* Initialize the Slave */
    initQSPI3Slave();

    /* Instruct the SPI Slave to receive a data stream of defined length */
    IfxQspi_SpiSlave_exchange(&g_qspiSafe.spiSafeComSlave, NULL_PTR,
            &g_qspiSafe.spiSafeComBuffers.qspiSlaveRx.data[0], FRAME_SIZE);

    /* Initialize the Master */
    initQSPI4Master();
    initQSPI4MasterChannel();
}

/* QSPI Master SW buffer initialization
 * This function update SW buffers the Master uses.
 */
void updateMasterBuffer(void)
{
    static uint32 frameCounter = 0;
    static uint32 payloadIncrement = 0;
    uint32 crcResult = 0;
    g_qspiSafe.spiSafeComBuffers.qspiMasterTx.dataM.data_id = MASTER_DATA_ID;

    /* circle through payload array data */
    if (payloadIncrement == DATA_ARRAY_LENGTH)
    {
        payloadIncrement = 0;
    }

    /* Fill the data to be sent and calculate CRC on this data */
    for (uint32 i = 0; i < BUFFER_SIZE; i++)
    {
        /* Fill TX Master Buffer with pattern */
        g_qspiSafe.spiSafeComBuffers.qspiMasterTx.dataM.spi4MasterTxBuffer[i] = payloadData[i + payloadIncrement];

        /* calculate CRC on data */
        crcResult = __crc32(crcResult, g_qspiSafe.spiSafeComBuffers.qspiMasterTx.dataM.spi4MasterTxBuffer[i]);
    }
    g_qspiSafe.spiSafeComBuffers.qspiMasterTx.dataM.crc = crcResult;
    g_qspiSafe.spiSafeComBuffers.qspiMasterTx.dataM.frame_counter = frameCounter;
    frameCounter++;
    payloadIncrement = payloadIncrement + BUFFER_SIZE;
}

/* This function starts the data transfer from Master to Slave
 * SM:QSPI:SAFE_COMMUNICATION
 * */
void masterTransmitDataSafeCommQSPI()
{
    uint8 loopTimeout = 0xff;

    /* QSPI data buffers update */
    updateMasterBuffer();

    /* Wait until the previous communication has finished, if any or if the loop timeout comes */
    while ((IfxQspi_SpiMaster_getStatus(&g_qspiSafe.spiSafeComMasterChannel) == SpiIf_Status_busy)
            && (loopTimeout > 0))
    {
        loopTimeout--;
    }

    /* Send a data stream through the SPI Master */
    IfxQspi_SpiMaster_exchange(&g_qspiSafe.spiSafeComMasterChannel,
            &g_qspiSafe.spiSafeComBuffers.qspiMasterTx.data[0], NULL_PTR, FRAME_SIZE);

}
/*
 * function to validate the timing of QSPI
 * */
void slaveTimingValidation(uint64 executionCyle)
{
    static float64 endOfFrameTime, startTime;
    startTime = getMilliSecondTime();
    do
    {
        /* time when the frame transfer is finished */
        endOfFrameTime = (getMilliSecondTime() - startTime);
        endOfFrameTime = endOfFrameTime + (float64) executionCyle;
        if (endOfFrameTime > FRAME_TIMEOUT)
        {
            g_ErrorTypeQspiSafe = 4;
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
            break;
        }
    } while (g_frameReceived == FALSE);

    if (g_ErrorTypeQspiSafe != 4)
    {
        /* check if the frame arrive earlier than the expected time */
        if (endOfFrameTime < EARLY_FRAME_TIME)
        {
            g_ErrorTypeQspiSafe = 1;
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
        }
        /* check if the frame arrive later than the expected time */
        else if (endOfFrameTime > LATE_FRAME_TIME)
        {
            g_ErrorTypeQspiSafe = 2;
            softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
        }
    }

    g_frameReceived = FALSE;
}
/*
 * This function checks if the received data is correct
 * */
void slaveDataValidation(uint32 frameCounterSlaveQSPI)
{
    uint32 error = 0;
    uint32 waitTimeout = 0xffff;
    uint32 calculatedCrcResultSlaveRx = 0;

    /* Wait until the Slave has received all the data or or if the timeout comes */
    while((IfxQspi_SpiSlave_getStatus(&g_qspiSafe.spiSafeComSlave) == SpiIf_Status_busy) &&
            (waitTimeout > 0))
    {
        waitTimeout--;
    }

    /* calculate CRC on Slave received data */
    for (uint8 i=0; i < BUFFER_SIZE ; i++)
    {
        calculatedCrcResultSlaveRx = __crc32(calculatedCrcResultSlaveRx,
                g_qspiSafe.spiSafeComBuffers.qspiSlaveRx.dataS.spi3SlaveRxBuffer[i]);
    }

    /* Check if the slave received data match the master sent one i.e. ID, Frame counter, CRC  */
    if ((MASTER_DATA_ID != g_qspiSafe.spiSafeComBuffers.qspiSlaveRx.dataS.data_id ) ||
        (frameCounterSlaveQSPI != g_qspiSafe.spiSafeComBuffers.qspiSlaveRx.dataS.frame_counter ) ||
        (calculatedCrcResultSlaveRx != g_qspiSafe.spiSafeComBuffers.qspiSlaveRx.dataS.crc))
    {
        error++;
        g_ErrorTypeQspiSafe = 3;
        /* software alarm trigger and alarm window pop up on display */
        softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_QSPI_SAFE);
    }

    /* In case of no errors, toggle the LED_D9 */
    if(error == 0)
    {
        IfxPort_togglePin(LED_D9_PORT);
    }
}
