/**********************************************************************************************************************
 * \file SafetyKit_UndervoltageSimulation.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "09_Fault_Injection/SafetyKit_UndervoltageSimulation.h"
#include "SafetyKit_Main.h"
#include "SafetyKit_Cfg.h"
#include "IfxGpt12.h"
#include "IfxGtm.h"
#include "IfxGtm_Atom_Pwm.h"
#include "IfxGtm_Trig.h" /* Required for GTM to ADC triggering */
#include "IfxEvadc_PinMap.h" /* Required for GTM to ADC triggering */

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* Macros for default period and duty cycle of both ATOM channels */
#define ATOM_UV_FREQUENCY_HZ        ((uint32)20000) /* PWM frequency in Hertz [Hz] */
#define ATOM1_CH0_UV_DUTYCYCLE      ((uint8)100)    /* Default PWM duty cycle in percent [Percent] */
#define ATOM1_CH2_UV_DUTYCYCLE      ((uint8)100)    /* Default PWM duty cycle in percent [Percent] */

/* Macros used to calculate ATOM duty cycle out of GPT12 timer value */
#define POTI_PERCENT_PER_TICK       ((float32)(0.2)) /* This value defines how much duty cycle is reduced per encoder
                                                      * tick rotation (in percent) */
/* If POTI_PERCENT_PER_TICK = 0.5: One rotation tick decrements the duty cycle by a half percent
 * If POTI_PERCENT_PER_TICK = 1: One rotation tick decrements the duty cycle by one percent
 * If POTI_PERCENT_PER_TICK = 2: One rotation tick decrements the duty cycle by two percent
 * and so on ... */
#define GPT_INCREMENTS_PER_TICK     ((uint16)(2.0)) /* Amount of increments of the GPT timer per encoder rotation tick
                                                     * (given by the encoder hardware, observe GPT timer value change
                                                     * in the debugger when rotating the encoder) */

/* This value defines how many rotation ticks are required for adjusting the duty cycle from 100 percent to 0 percent.
 * The value depends on the parameter POTI_PERCENT_PER_TICK                                                          */
#define GPT_VAL_CMP_100_PERCENT     ((uint16)(100 * GPT_INCREMENTS_PER_TICK / POTI_PERCENT_PER_TICK))

/* This value is used to scale the GPT value to percent [0-100] */
#define GPT_VAL_TO_PERCENT          ((float32)(100 / (float32)GPT_VAL_CMP_100_PERCENT))

#define UV_SIM_START_DUTY           ((float32)71.0) /* under-voltage simulation start duty cycle                     */

/* SR1 offset values for GTM triggered ADC measurement for Analog Acquisition demonstrations */
/* If the duty cycle of ATOM1_CH5 is 100 percent the SR1 value of ATOM0_CH5 should be a little bit less, otherwise
 * the EVADC measurement won't be triggered as there is no falling edge */
#define ATOM0_CH5_UV_SR1_DEFAULT_OFFSET ((sint32) - 4)

/* If the duty cycle of ATOM1_CH5 is e.g. 70 percent, the SR1 value of ATOM0_CH5 should be higher, this results in
 * EVADC sampling a little bit later after the falling edge of the PWM signal (During high period the signal is higher
 * than 5v). Parameter value got acquired by testing with the debugger */
#define ATOM0_CH5_UV_SR1_OFFSET         ((sint32)100)

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Atom_Pwm_Driver g_atom1Ch0Handler; /* Timer Driver structure */
IfxGtm_Atom_Pwm_Driver g_atom1Ch2Handler; /* Timer Driver structure */
IfxGtm_Atom_Pwm_Driver g_atom0Ch5Handler; /* Timer Driver structure */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * Two Atom are configured in PMW mode on two different pins :
 * ATOM 1 Channel 0 on pin P02.0
 * ATOM 1 Channel 2 on pin P33.11
 *
 * Encoder is use with GPT1 Timer 2 in incremental mode :
 * T2EUDA on pin P00.8 (direction input signal)
 * T2INA on pin P00.7  (count input signal)
 *
 * Value from GPT12 timer is used to change DutyCycle of one of the ATOM channel to create a PMW controlled current pump
 *
 * IfxSmu_Alarm_HSM_Undervoltage_Alarm alarm and IfxSmu_Alarm_EVR_Undervoltage_Alarm can be triggered with this API
*/
void initUndervoltageSimulation(void)
{
    /*---------------------------------------------------------------------------------------------*/
    /*                    Step 1: Initialize the GPT12 for incremental encoder input               */
    /*---------------------------------------------------------------------------------------------*/
    /* Enable GPT12 clock */
    IfxGpt12_enableModule(&MODULE_GPT120);
    /* External Up/Down Enable via T2EUD-pin */
    IfxGpt12_T2_setDirectionSource(&MODULE_GPT120, IfxGpt12_TimerDirectionSource_external);
    /* Incremental interface mode */
    IfxGpt12_T2_setIncrementalInterfaceInputMode(&MODULE_GPT120, IfxGpt12_IncrementalInterfaceInputMode_bothEdgesTxINOrTxEUD);
    /* Incremental interface mode (edge detection) */
    IfxGpt12_T2_setMode(&MODULE_GPT120, IfxGpt12_Mode_incrementalInterfaceEdgeDetection);

    IfxGpt12_T2_setInterruptEnable(&MODULE_GPT120, FALSE);    /* Disable interrupt generation for T2 */
    IfxGpt12_T2_run(&MODULE_GPT120, IfxGpt12_TimerRun_start); /* Start T2 */

    /* Step 2: Initialize the GTM and the ATOM channel to generate the PWM output signal */
    /* Configure ATOM channel of GTM, GTM and its clocks are already enabled*/

    IfxGtm_enable(&MODULE_GTM);

    /*---------------------------------------------------------------------------------------------*/
    /*                    Step 2: Configure GTM ATOM for the first signal                          */
    /*---------------------------------------------------------------------------------------------*/
    IfxGtm_Atom_Pwm_Config atom1Ch0Config;
    IfxGtm_Atom_Pwm_initConfig(&atom1Ch0Config, &MODULE_GTM); /* Initialize default parameters */

    atom1Ch0Config.atom = UV_SIMULATION_PWM_OUT1.atom; /* Select the ATOM depending on the Pin */
    atom1Ch0Config.atomChannel = UV_SIMULATION_PWM_OUT1.channel; /* Select the channel depending on the Pin */
    atom1Ch0Config.pin.outputPin = &UV_SIMULATION_PWM_OUT1; /* Select the pin as output */
    atom1Ch0Config.synchronousUpdateEnabled = TRUE;    /* Enable synchronous update */
    atom1Ch0Config.immediateStartEnabled = FALSE;
    /* Set the timer Period */
    atom1Ch0Config.period = IfxGtm_Atom_Ch_getClockFrequency(&MODULE_GTM, &MODULE_GTM.ATOM[atom1Ch0Config.atom], \
                                                          UV_SIMULATION_PWM_OUT1.channel)/ ATOM_UV_FREQUENCY_HZ;
    /* Set the timer Duty Cycle */
    atom1Ch0Config.dutyCycle = (uint32)(ATOM1_CH0_UV_DUTYCYCLE * 0.01 * atom1Ch0Config.period);
    atom1Ch0Config.signalLevel = Ifx_ActiveState_high;

    /* Initialize the Atom channel in PWM mode with all configured settings */
    IfxGtm_Atom_Pwm_init(&g_atom1Ch0Handler, &atom1Ch0Config);

    /*---------------------------------------------------------------------------------------------*/
    /*                    Step 3: Configure GTM ATOM for the second signal                         */
    /*---------------------------------------------------------------------------------------------*/
    IfxGtm_Atom_Pwm_Config atom1Ch2Config;
    IfxGtm_Atom_Pwm_initConfig(&atom1Ch2Config, &MODULE_GTM); /* Initialize default parameters */

    atom1Ch2Config.atom = UV_SIMULATION_PWM_OUT2.atom; /* Select the ATOM depending on the Pin */
    atom1Ch2Config.atomChannel = UV_SIMULATION_PWM_OUT2.channel; /* Select the channel depending on the Pin */
    atom1Ch2Config.pin.outputPin = &UV_SIMULATION_PWM_OUT2; /* Select the pin as output */
    atom1Ch2Config.synchronousUpdateEnabled = TRUE; /* Enable synchronous update */
    atom1Ch2Config.immediateStartEnabled = FALSE;
    /* Set the timer Period */
    atom1Ch2Config.period = IfxGtm_Atom_Ch_getClockFrequency(&MODULE_GTM, &MODULE_GTM.ATOM[atom1Ch2Config.atom], \
                                                          UV_SIMULATION_PWM_OUT2.channel)/ ATOM_UV_FREQUENCY_HZ;
    /* Set the timer Duty Cycle */
    atom1Ch2Config.dutyCycle = (uint32)(ATOM1_CH2_UV_DUTYCYCLE * 0.01 * atom1Ch2Config.period);
    atom1Ch2Config.signalLevel = Ifx_ActiveState_high;

    /* Initialize the Atom channel in PWM mode with all configured settings */
    IfxGtm_Atom_Pwm_init(&g_atom1Ch2Handler, &atom1Ch2Config);

    /*---------------------------------------------------------------------------------------------*/
    /*      Step 4: Configure a third ATOM channel which is used to trigger an EVADC measurement   */
    /*      of the current pump signal measured with AN18 / P40.11 to demonstrate Analog           */
    /*      Acquisition FUC 0, Single analog acquisition with two EVADC channels.    */
    /*---------------------------------------------------------------------------------------------*/
    IfxGtm_Atom_Pwm_Config atom0Ch5Config;
    IfxGtm_Atom_Pwm_initConfig(&atom0Ch5Config, &MODULE_GTM); /* Initialize default parameters */

    atom0Ch5Config.atom = UV_SIMULATION_ATOM_ADC_TRIGGER.atom; /* Select the ATOM depending on the Pin */
    atom0Ch5Config.atomChannel = UV_SIMULATION_ATOM_ADC_TRIGGER.channel; /* Select the channel depending on the Pin */
    atom0Ch5Config.pin.outputPin = NULL_PTR; /* Don't configure PIN */
    atom0Ch5Config.synchronousUpdateEnabled = TRUE; /* Enable synchronous update */
    atom0Ch5Config.immediateStartEnabled = FALSE;
    /* Set the timer Period */
    atom0Ch5Config.period = IfxGtm_Atom_Ch_getClockFrequency(&MODULE_GTM, &MODULE_GTM.ATOM[atom0Ch5Config.atom], \
                                                  UV_SIMULATION_ATOM_ADC_TRIGGER.channel)/ ATOM_UV_FREQUENCY_HZ;
    /* Set the timer Duty Cycle */
    atom0Ch5Config.dutyCycle = atom1Ch2Config.dutyCycle + ATOM0_CH5_UV_SR1_DEFAULT_OFFSET;
    atom0Ch5Config.signalLevel = Ifx_ActiveState_high;

    /* Configure GTM to EVADC trigger */
    /* ADC group of signal UV_SIM_SIG1_EVADC_PIN is triggered by GTM ATOM1 CH6 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, (IfxGtm_Trig_AdcGroup)UV_SIM_SIG1_EVADC_PIN.groupId, IfxGtm_Trig_AdcTrig_1, \
                                                 IfxGtm_Trig_AdcTrigSource_atom1, IfxGtm_Trig_AdcTrigChannel_6);
    /* ADC group of signal UV_SIM_SIG2_EVADC_PIN is triggered by GTM ATOM1 CH6 */
    IfxGtm_Trig_toEVadc(&MODULE_GTM, (IfxGtm_Trig_AdcGroup)UV_SIM_SIG2_EVADC_PIN.groupId, IfxGtm_Trig_AdcTrig_1, \
                                                 IfxGtm_Trig_AdcTrigSource_atom1, IfxGtm_Trig_AdcTrigChannel_6);

    /* Initialize the Atom channel in PWM mode with all configured settings */
    IfxGtm_Atom_Pwm_init(&g_atom0Ch5Handler, &atom0Ch5Config);

    /*---------------------------------------------------------------------------------------------*/
    /*                    Step 5: Enable and start both channels synchronously                     */
    /*---------------------------------------------------------------------------------------------*/
    /* Make sure that both channels are of same ATOM and therefore both should have same AGC object */
    if(g_atom1Ch2Handler.agc == g_atom1Ch0Handler.agc)
    {
        /* Create atom channel mask */
        IfxGtm_Atom_Ch atomChannel;
        uint16         enableMask = 0;

        /* Add the first channel to enableMask */
        atomChannel = g_atom1Ch2Handler.atomChannel;
        enableMask |= 1 << atomChannel;

        /* Add the second channel to enableMask */
        atomChannel = g_atom1Ch0Handler.atomChannel;
        enableMask |= 1 << atomChannel;

        /* Add the third channel to enableMask */
        atomChannel = atom0Ch5Config.atomChannel;
        enableMask |= 1 << atomChannel;

        /* Enable and start both channels synchronously
         * Enable update (GLB_CTRL register) */
        IfxGtm_Atom_Agc_setChannelsUpdate       (g_atom1Ch2Handler.agc, IfxGtm_Atom_Agc_buildFeature(enableMask, 0, \
                                                                         IFX_GTM_ATOM_AGC_GLB_CTRL_UPEN_CTRL0_OFF));
        /* Enable channel (configure ENDIS_CTRL register) */
        IfxGtm_Atom_Agc_enableChannels          (g_atom1Ch2Handler.agc, enableMask, 0, FALSE);
        /* Enable output (configure OUTEN_CTRL register) */
        IfxGtm_Atom_Agc_enableChannelsOutput    (g_atom1Ch2Handler.agc, enableMask, 0, FALSE);
        /* Enable the configured channels (set HOST_TRIG in GLB_CTRL register) */
        IfxGtm_Atom_Agc_trigger                 (g_atom1Ch2Handler.agc);
    }
    else
    {
        /* Both ATOM channels have to be of same ATOM module to be started synchronously in this way */
        __debug();
    }
}

/*
 * This function will set the duty cycle for under voltage simulation
 */
void undervoltageSimulationSetDutyCycle(void)
{
    float32 dutyCycle;
    uint16 valueGPT12T2;
    valueGPT12T2 = IfxGpt12_T2_getTimerValue(&MODULE_GPT120);

    /* GPT Timer counter threshold */
    if (valueGPT12T2 > 0xf000)
    {
        IfxGpt12_T2_setTimerValue(&MODULE_GPT120, 0); /* An overflow has occurred while counting down */
    }

    /* Cover 0 and wrong direction of the encoder */
    if((valueGPT12T2 <= (GPT_VAL_CMP_100_PERCENT)) && (valueGPT12T2 != 0))
    {
        dutyCycle = UV_SIM_START_DUTY - (GPT_VAL_TO_PERCENT * (float32)valueGPT12T2);
    }
    else
    {
        dutyCycle = ATOM1_CH2_UV_DUTYCYCLE;
    }

    /* Change duty cycle of the PWM signal accordingly */
    uint32 shadowZeroValue = IfxGtm_Atom_getShadowZero(g_atom1Ch2Handler.atom, g_atom1Ch2Handler.atomChannel);
    uint32 shadowOneValue = (uint32)(dutyCycle * 0.01 * shadowZeroValue);
    IfxGtm_Atom_Ch_setCompareOneShadow(g_atom1Ch2Handler.atom, g_atom1Ch2Handler.atomChannel, shadowOneValue);

    /* Configure the duty cycle of the timer signal which is used to trigger an EVADC measurement accordingly */
    if((shadowOneValue + ATOM0_CH5_UV_SR1_OFFSET) < IfxGtm_Atom_getShadowZero(g_atom0Ch5Handler.atom, g_atom0Ch5Handler.atomChannel))
    {
        /* If the current SR1 value of ATOM1 CH5 is + the offset ATOM1_CH6_UV_SR1_OFFSET would be still less then SR0 */
        IfxGtm_Atom_Ch_setCompareOneShadow(g_atom0Ch5Handler.atom, g_atom0Ch5Handler.atomChannel, \
                                                     (shadowOneValue + ATOM0_CH5_UV_SR1_OFFSET));
    }
    else
    {
        /* If the value plus the offset would be higher than SR0 use the offset ATOM1_CH6_UV_SR1_DEFAULT_OFFSET
         * (which is negative and results in generating a falling edge again) */
        IfxGtm_Atom_Ch_setCompareOneShadow(g_atom0Ch5Handler.atom, g_atom0Ch5Handler.atomChannel, \
                (IfxGtm_Atom_getShadowZero(g_atom0Ch5Handler.atom, g_atom0Ch5Handler.atomChannel) + ATOM0_CH5_UV_SR1_DEFAULT_OFFSET));
    }
}

/*
 * This function is for over writing the GPT timer value
 */
void undervoltageSimulationOverwriteGptTimerVal(uint16 dutyCycleTargetValueInPercent)
{
    /* Calculate GPT timer T2 target value out of the duty cycle target value in percent */
    uint16 targetValueGPT12T2 = ((UV_SIM_START_DUTY - dutyCycleTargetValueInPercent) / POTI_PERCENT_PER_TICK) * GPT_INCREMENTS_PER_TICK;
    /* Get current GPT timer T2 value */
    uint16 currentValueGPT12T2 = IfxGpt12_T2_getTimerValue(&MODULE_GPT120);
    /* Increment/decrement the timer value step by step until the GPT timer value has reached the target value.
     * Refer to the note below */
    do
    {
        if(currentValueGPT12T2 > targetValueGPT12T2)
        {
            currentValueGPT12T2 -= GPT_INCREMENTS_PER_TICK;
        }
        else if(currentValueGPT12T2 < targetValueGPT12T2)
        {
            currentValueGPT12T2 += GPT_INCREMENTS_PER_TICK;
        }
        IfxGpt12_T2_setTimerValue(&MODULE_GPT120, currentValueGPT12T2);

        /* Wait 10ms after each increase to have a time delay between IfxSmu_Alarm_EVR_Undervoltage_Alarm and
         * IfxSmu_Alarm_HSM_Undervoltage_Alarm */
        IfxStm_waitTicks(&MODULE_STM0, IfxStm_getTicksFromMilliseconds(&MODULE_STM0, 10));
    } while(__abs( targetValueGPT12T2 - currentValueGPT12T2) > 0);

    /* Note:
     * The GPT timer value is incremented step by step to reduce the voltage slowly and therefore the IfxSmu_Alarm_EVR_Undervoltage_Alarm
     *  will be triggered a little bit earlier then the IfxSmu_Alarm_HSM_Undervoltage_Alarm. This behavior is wanted because the SMU
     *  alarm which was triggered last will be visualized on the TFT. */
}
