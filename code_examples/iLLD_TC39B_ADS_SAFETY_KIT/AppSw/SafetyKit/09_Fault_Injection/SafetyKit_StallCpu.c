/**********************************************************************************************************************
 * \file SafetyKit_StallCpu.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyKit_StallCpu.h"
#include "SafetyKit_TriggerStmAlarm.h"
#include "SafetyKit_Main.h"
#include "SafetyKit_Cfg.h"
#include "IfxScuEru.h"


#if ISR_PROVIDER_ERU_IN2 == 0
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((ISR_PROVIDER_ERU_IN2 == 1) && (ISR_PROVIDER_ERU_IN2 < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((ISR_PROVIDER_ERU_IN2 == 2) && (ISR_PROVIDER_ERU_IN2 < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((ISR_PROVIDER_ERU_IN2 == 3) && (ISR_PROVIDER_ERU_IN2 < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((ISR_PROVIDER_ERU_IN2 == 4) && (ISR_PROVIDER_ERU_IN2 < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#elif ((ISR_PROVIDER_ERU_IN2 == 5) && (ISR_PROVIDER_ERU_IN2 < IFXCPU_NUM_MODULES))
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #else
        #error "Only TASKING is supported, add pragmas for your compiler"
    #endif
#else
#error "Set ISR_PROVIDER_ERU_IN2 to a valid value!"
#endif
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
ConfigERU g_configERU;                                      /* SCU_ERU global data                                  */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initERU(void);
void stallCpu(void);

IFX_INTERRUPT(isrIn2ER, ISR_PROVIDER_ERU_IN2, ISR_PRIORITY_ERU_IN2);
IFX_INTERRUPT(block_CoreIsr0, 0, ISR_PRIORITY_STALL_CPU);
IFX_INTERRUPT(blockCoreIsr1, 1, ISR_PRIORITY_STALL_CPU);
IFX_INTERRUPT(blockCoreIsr2, 2, ISR_PRIORITY_STALL_CPU);
IFX_INTERRUPT(blockCoreIsr3, 3, ISR_PRIORITY_STALL_CPU);
IFX_INTERRUPT(blockCoreIsr4, 4, ISR_PRIORITY_STALL_CPU);
IFX_INTERRUPT(blockCoreIsr5, 5, ISR_PRIORITY_STALL_CPU);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * SM:SCU:ERU_CONFIG
 * */
void initERU(void)
{
    /* Trigger pin */
     g_configERU.reqPin = STALL_CPU_PIN; /* Select external request pin */

     /* Initialize this pin with pull-down enabled
      * This function will also configure the input multiplexers of the ERU (Register EXISx)
      */
     IfxScuEru_initReqPin(g_configERU.reqPin, IfxPort_InputMode_pullDown);

    /* Determine input channel depending on input pin */
    g_configERU.inputChannel = (IfxScuEru_InputChannel) g_configERU.reqPin->channelId;

    /* Input channel configuration */
    IfxScuEru_enableRisingEdgeDetection(g_configERU.inputChannel);          /* Interrupt triggers on
                                                                               rising edge (Register RENx) and      */
    /* Signal destination */
    g_configERU.outputChannel = IfxScuEru_OutputChannel_1;                  /* OGU channel 1                        */
    /* Event from input ETL1 triggers output OGU1 (signal TRx0) */
    g_configERU.triggerSelect = IfxScuEru_InputNodePointer_1;

    /* Connecting Matrix, Event Trigger Logic ETL block */
    /* Enable generation of trigger event (Register EIENx) */
    IfxScuEru_enableTriggerPulse(g_configERU.inputChannel);
    /* Determination of output channel for trigger event (Register INPx) */
    IfxScuEru_connectTrigger(g_configERU.inputChannel, g_configERU.triggerSelect);

    /* Configure Output channels, OutputGating Unit OGU (Register IGPy) */
    IfxScuEru_setInterruptGatingPattern(g_configERU.outputChannel, IfxScuEru_InterruptGatingPattern_alwaysActive);

    /* Service request configuration */
    /* Get source pointer depending on outputChannel (SRC_SCUERU0 for outputChannel0) */
    g_configERU.src = &MODULE_SRC.SCU.SCUERU[(int) g_configERU.outputChannel % 4];
    IfxSrc_init(g_configERU.src, IRQ_GET_TOS(ISR_PROVIDER_ERU_IN2), ISR_PRIORITY_ERU_IN2);
    IfxSrc_enable(g_configERU.src);
}

/*
 * This function initializes an ERU input pin to trigger an high prioritized interrupt when a button is pressed.
 * This Interrupt is broadcasted to all CPUs. Therefore pressing the button keeps all CPUs trapped in a while
 * loop avoiding that the CPU can take care about other tasks and also the servicing of the watchdogs.
 * Note: only the CPU which takes care about SMU interrupts and servicing the TFT display is not trapped. */
void initCpuStalling(void)
{
    /* General purpose Service request broadcast nodes */
    IfxSrc_init(&SRC_GPSR_GPSR1_SR0, IRQ_GET_TOS(0), ISR_PRIORITY_STALL_CPU);
    IfxSrc_init(&SRC_GPSR_GPSR1_SR1, IRQ_GET_TOS(1), ISR_PRIORITY_STALL_CPU);
    IfxSrc_init(&SRC_GPSR_GPSR1_SR2, IRQ_GET_TOS(2), ISR_PRIORITY_STALL_CPU);
    IfxSrc_init(&SRC_GPSR_GPSR1_SR3, IRQ_GET_TOS(3), ISR_PRIORITY_STALL_CPU);
    IfxSrc_init(&SRC_GPSR_GPSR1_SR4, IRQ_GET_TOS(4), ISR_PRIORITY_STALL_CPU);
    IfxSrc_init(&SRC_GPSR_GPSR1_SR5, IRQ_GET_TOS(5), ISR_PRIORITY_STALL_CPU);

    IfxSrc_enable(&SRC_GPSR_GPSR1_SR0);
    IfxSrc_enable(&SRC_GPSR_GPSR1_SR1);
    IfxSrc_enable(&SRC_GPSR_GPSR1_SR2);
    IfxSrc_enable(&SRC_GPSR_GPSR1_SR3);
    IfxSrc_enable(&SRC_GPSR_GPSR1_SR4);
    IfxSrc_enable(&SRC_GPSR_GPSR1_SR5);

    /*initial ERU */
    initERU();
}

IFX_INTERRUPT(isrIn2ER, ISR_PROVIDER_ERU_IN2, ISR_PRIORITY_ERU_IN2)
{
    IfxCpu_enableInterrupts();

    /* Note: If the Microcontroller Debug Support mode of TLF is not active, TLF will reset AURIX */
    /* Trigger every CPU */
    INT_SRB1.U = 0x3f;
}

IFX_INTERRUPT(block_CoreIsr0, 0, ISR_PRIORITY_STALL_CPU)
{
    IfxCpu_enableInterrupts();

    if(CPU_WHICH_RUN_SMU != IfxCpu_Index_0)
    {
        stallCpu();
    }
}

IFX_INTERRUPT(blockCoreIsr1, 1, ISR_PRIORITY_STALL_CPU)
{
    IfxCpu_enableInterrupts();

    if(CPU_WHICH_RUN_SMU != IfxCpu_Index_1)
    {
        stallCpu();
    }
}

IFX_INTERRUPT(blockCoreIsr2, 2, ISR_PRIORITY_STALL_CPU)
{
    IfxCpu_enableInterrupts();

    if(CPU_WHICH_RUN_SMU != IfxCpu_Index_2)
    {
        stallCpu();
    }
}

IFX_INTERRUPT(blockCoreIsr3, 3, ISR_PRIORITY_STALL_CPU)
{
    IfxCpu_enableInterrupts();

    if(CPU_WHICH_RUN_SMU != IfxCpu_Index_3)
    {
        stallCpu();
    }
}

IFX_INTERRUPT(blockCoreIsr4, 4, ISR_PRIORITY_STALL_CPU)
{
    IfxCpu_enableInterrupts();

    if(CPU_WHICH_RUN_SMU != IfxCpu_Index_4)
    {
        stallCpu();
    }
}

IFX_INTERRUPT(blockCoreIsr5, 5, ISR_PRIORITY_STALL_CPU)
{
    IfxCpu_enableInterrupts();

    if(CPU_WHICH_RUN_SMU != IfxCpu_Index_5)
    {
        stallCpu();
    }
}

/*
 * this function put Cpu in while loop
 * */
void stallCpu(void)
{
    while(!IfxSmu_getAlarmStatus(IfxSmu_Alarm_SCU_Watchdog_TimeOut))
    {
        __nop();
    }
}

/*
 * This functions resets the SMU alarm which is triggering an NMI
 * */
void runCpuStallingBackgroundTask(void)
{
    if(IfxSmu_getAlarmStatus(SMU_ALARM_WHICH_TRIGGERS_NMI))
    {
        IfxSmu_clearAlarmStatus(SMU_ALARM_WHICH_TRIGGERS_NMI);
    }
}

/*
 * This function checks if the STM interrupt routine was not serviced within 1 milliseconds
 * after the ISR was triggered. E.g. when the CPU was stalled. In case a CPU was stalled the
 * STM comparator and the TickCount_1ms is aligned again with the values of the other CPUs
 * */
void checkIfCpuWasStalled(App_Cpu *lcl_AppCpu, IfxCpu_ResourceCpu cpuIndex)
{
#ifdef SAFETYKIT_TRIGGERSTMALARM_H_
    /* Only run the STM monitoring if all STM modules are currently enabled. They might be disabled during STM error injection.*/
    if(checkIfAnySTMisDisabled())
    {
        return;
    }
#endif

    Ifx_STM *stmSfr; /* Pointer to STM register base */
    switch (cpuIndex)
    {
        case IfxCpu_ResourceCpu_0:
            stmSfr = &MODULE_STM0;
            break;
        case IfxCpu_ResourceCpu_1:
            stmSfr = &MODULE_STM1;
            break;
        case IfxCpu_ResourceCpu_2:
            stmSfr = &MODULE_STM2;
            break;
        case IfxCpu_ResourceCpu_3:
            stmSfr = &MODULE_STM3;
            break;
        case IfxCpu_ResourceCpu_4:
            stmSfr = &MODULE_STM4;
            break;
        case IfxCpu_ResourceCpu_5:
            stmSfr = &MODULE_STM5;
            break;
        default:
            while (1)
            {};
            break;
    }

    uint32 timerValueSTM;
    uint32 timerCompareValueSTM;
    uint32 missedCycles = 0;

    /* Save STM timer low value */
    timerValueSTM = IfxStm_getLower(stmSfr);

    /* Get STM timer compare value */
    timerCompareValueSTM = IfxStm_getCompare(stmSfr, IfxStm_Comparator_0);

    /* If by accident the STM comparator is not serviced within 1 ms after ISR is triggered,
     * the comparator value needs to be updated with the current timer value
     * This happens when the CPUs are stalled and released before the safety watchdog overflows
     *
     * First we check if the next trigger of the interrupt will occur in less than 1ms
     * If not, we estimate how many milliseconds have been skipped and we add the corresponding number
     * of ticks to the STM compare register
     * This way we can know how long the program flow has been stalled
     * and we still know precisely the time elapsed since program start
     */
    if ((!((((timerCompareValueSTM - timerValueSTM) < IFX_CFG_STM_TICKS_PER_MS) &&
            (timerCompareValueSTM > timerValueSTM)) ||
            ((((0xFFFFFFFF - timerValueSTM) + timerCompareValueSTM) < IFX_CFG_STM_TICKS_PER_MS) &&
            (timerCompareValueSTM < IFX_CFG_STM_TICKS_PER_MS)))))
    {
        if (timerValueSTM > timerCompareValueSTM)
        {
            missedCycles = ((timerValueSTM - timerCompareValueSTM) / IFX_CFG_STM_TICKS_PER_MS) +1;
        }
        else
        {
            missedCycles = (((0xFFFFFFFF - timerCompareValueSTM) + timerValueSTM) / IFX_CFG_STM_TICKS_PER_MS) +1;
        }
        IfxStm_increaseCompare(stmSfr, IfxStm_Comparator_0, missedCycles*IFX_CFG_STM_TICKS_PER_MS);

        /* Also increase the TickCount variable */
        lcl_AppCpu->TickCount_1ms += missedCycles;
    }
}


#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#else
    #error "Only TASKING is supported, add pragmas for your compiler"
#endif
