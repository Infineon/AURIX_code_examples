/**********************************************************************************************************************
 * \file SafetyKit_Sent_Channel_Redundancy.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <math.h>
#include "IfxSent_Sent.h"
#include "IfxSent.h"
#include "Configuration.h"
#include "SMU.h"

#include "IfxGtm_Tom_Pwm.h"
#include "IfxGtm_Tim_In.h"
#include "IfxGtm_Trig.h"
#include "IfxGtm_Tom.h"
#include "SafetyKit_DA_global.h"
#include "SafetyKit_Sent_Channel_Redundancy.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define PWM_PERIOD          3906              /* PWM period for the TOM 100Hz                                        */

#define START_ANGLE         90.0f             /* both sensor start angle                                             */
#define ANGLE_OFFSET        2.0f              /* 2.0 degree angle offset of sensor 1 to 2                            */
#define SENT_TICK_TIME      3.0E-6            /* TLE5012BD E9200 is by default configured with 3 us                  */
#define SENSOR_ID1          24                /* sensor ID which is actually SPC pulse length 24 * 3 = 72 µs         */
#define SENSOR_ID2          24                /* sensor ID which is actually SPC pulse length 24 * 3 = 72 µs         */

#define THRESHOLD_VALUE     10                /* Threshold value, above this LED as alarm will be on                 */
#define NUM_OF_NIBBLES_FOR_CRC           4                 /* Total number of nibbles used for CRC calculation       */
#define TLE5012B_SPC_ANGLE_RES_12b       360.00f/4095.00f  /* SPC 12 bit angle resolution                            */
#define TLX5012B_SSC_FRAME_CRC_SEED_VAL  0x05u             /* the seed value of the fast CRC circuit from user
                                                              manual of TLE5012 sensor                               */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
float32 g_tomFrequency=0;
AppSENT g_AppSENT;                                               /* global variable for sent struct                 */
static ErrorCountersSENT g_errorCounters = {0};                   /* error count                                     */
IfxGtm_Tom_Pwm_Driver g_tomDriver[2];                             /* Timer Driver structure                          */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void interruptHandlerSENT(AppSENT *sent, uint8 instance);
void initSENTCh4bSPCMode(void);
void initSENTCh9bSPCMode(void);
void initTriggerInputGTMTOM2Ch7(void);
void initTriggerInputGTMTOM0Ch7(void);
void calculateCRC(uint8 instance, uint8 channelId);
static uint8 calculateCRCTLE5012SPC(uint8 *message, uint8 length);

IFX_INTERRUPT(channel4IsrSENT, CPU_WHICH_RUN_SENT_SPC_TASKS, ISR_PRIORITY_SENT_CHANNEL4);
IFX_INTERRUPT(channel9IsrSENT, CPU_WHICH_RUN_SENT_SPC_TASKS, ISR_PRIORITY_SENT_CHANNEL9);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* SENT CH4 interrupt */
void channel4IsrSENT(void)
{
    interruptHandlerSENT(&g_AppSENT, 0);
}

/* SENT CH9 interrupt */
void channel9IsrSENT(void)
{
    interruptHandlerSENT(&g_AppSENT, 1);
}

/* Handle SENT interrupt */
void interruptHandlerSENT(AppSENT *sent, uint8 instance)
{
    IfxSent_Sent_Channel *channel = &sent->sentChannel[instance];
    Ifx_SENT_CH_INTSTAT interruptStatus = IfxSent_Sent_getAndClearInterruptStatus(channel);

    if (interruptStatus.U)
    {
        /* check for error conditions */
        if (interruptStatus.U & IFXSENT_INTERRUPT_STATUS_ERROR_FLAGS)
        {
            /* Receive Buffer Overflow
             * This bit is set after a frame has been received while the old one was
             * not read from RDRx. I.e. the kernel wants to set any of the two
             * interrupts RSI and RDI and finds any of these two interrupts already
             * set. The old data is overwritten by the new data.
             */
            if (interruptStatus.B.RBI)
            {
                g_errorCounters.RBI++;
            }
            /* Transmit Buffer Underflow
             * This bit is set after data has been completely transferred (PLEN
             * exceeded) and no new data was written to SCRx.
             */
            if (interruptStatus.B.TBI)
            {
                g_errorCounters.TBI++;
            }
            /* Frequency Range Error
             * This bit is set after a Synchronization / Calibration pulse was
             * received that deviates more than +- 25% from the nominal value.
             * The referring data is ignored.
             */
            if (interruptStatus.B.FRI)
            {
                g_errorCounters.FRI++;
            }
            /* Frequency Drift Error
             * This bit is set after a subsequent Synchronization / Calibration
             * pulse was received that deviates more than 1.5625% (1/64) from its
             * predecessor.
             */
            if (interruptStatus.B.FDI)
            {
                g_errorCounters.FDI++;
            }

            /* Wrong Number of Nibbles
             * This bit is set after a more nibbles have been received than expected
             * or a Synchronization / Calibration Pulse is received too early thus
             * too few nibbles have been received
             */
            if (interruptStatus.B.NNI)
            {
                g_errorCounters.NNI++;
            }
            /* Nibbles Value out of Range
             * This bit is set after a too long or too short nibble pulse has been
             * received. I.e. value < 0 or value > 15.
             */
            if (interruptStatus.B.NVI)
            {
                g_errorCounters.NVI++;
            }
            /* CRC Error
             * This bit is set if the CRC check fails.
             */
            if (interruptStatus.B.CRCI)
            {
                g_errorCounters.CRCI++;
            }
            /* Wrong Status and Communication Nibble Error
             * In standard Serial Frame Mode (RCR.ESF is cleared), this bit is set
             * if the Status and Communication nibble shows a start bit in a frame
             * other than frame number n x 16.
             * In Extended Serial Frame Mode this bit is without function.
             */
            if (interruptStatus.B.WSI)
            {
                g_errorCounters.WSI++;
            }

            /* Serial Data CRC Error
             * This bit is set if the CRC of the serial message fails.
             * In Extended Serial Message Format, this includes a check of the Serial
             * Communication Nibble for correct 0 values of bit 3 in frames 7, 13 and 18.
             */
            if (interruptStatus.B.SCRI)
            {
                g_errorCounters.SCRI++;
            }

            /* Watch Dog Error
             * This bit is set if the Watch Dog Timer of the channel expires.
             */
            if (interruptStatus.B.WDI)
            {
                g_errorCounters.WDI++;
            }
        }
        /* transaction events */

        /* Receive Data
         * RDI is activated when a received frame is moved to a Receive Data
         * Register RDR. Both RDI and RSI will be issued together in normal use
         * cases where the frame size is not bigger than 8 nibbles and CRC is
         * correct or not checked (if RCRx.CDIS is cleared).
         */
        if (interruptStatus.B.RDI)
        {
            /* Ignore RDI bit, useful only when Frame Length is greater than
             * 8 nibbles since it can indicate that end of frame
             */
        }

        /* Receive Success
         * This bit is set at the successfully received end of a frame.
         * Depending on bit RCRx.CDIS this indicates a successful check of the CRC.
         */
        if (interruptStatus.B.RSI)
        {
            /* decode incoming frame */
            IfxSent_Sent_Frame frame;

            /* read sent channel serial data frame of */
            IfxSent_Sent_readChannelSerialDataFrame(channel, &frame);
            /* update the sensor SENT raw data */
            sent->sentRawData[instance].U = frame.data;
            sent->sentStatus[instance] = frame.statusNibble;
            /* Compare received and calculated CRC */
            calculateCRC(instance, sent->sentChannel[instance].channelId);

            /*raw data conversion to angle in degree i.e. max 360 */
            g_SafetyKitStatus.sentRedundancy.angle[instance] = (float32) (sent->sentRawData[instance].U
                    * TLE5012B_SPC_ANGLE_RES_12b);

            /* apply angle offset value to sensor 2 only */
            if (instance == 1)
            {
                g_SafetyKitStatus.sentRedundancy.angle[instance] = g_SafetyKitStatus.sentRedundancy.angle[instance]
                        - ANGLE_OFFSET;
            }
            /* increment counter */
            ++sent->interruptCounter;
            ++sent->interruptCounterChannel[instance];
        }

        /* Transfer Data
         * This bit is set after the trigger condition was detected. Data to be
         * transferred has been moved internally. Thus a new value can be written
         * to SCRx. This can be used for back to back transfers.
         */
        if (interruptStatus.B.TDI)
        {
        }

        /* Serial Data Received
         * This bit is set after all serial data bits have been received via the
         * Status and Communication nibble. Depending on bit RCRx.SCDIS this
         * indicates a successful check of the CRC.
         */
        if (interruptStatus.B.SDI)
        {
            IfxSent_Sent_SerialMessageFrame g_serialMessage;
            /* decode incoming message */
            IfxSent_Sent_readChannelSerialMessageFrame(channel, &g_serialMessage);
        }
    }
}

/*
 * this function compare the CRC received and calculated
 */
void calculateCRC(uint8 instance, uint8 channelId)
{
    uint8 dataForCrc[NUM_OF_NIBBLES_FOR_CRC];
    /* read received CRC value from sensor */
    g_AppSENT.sentCrcReceived[instance] = IfxSent_readReceivedCrc(g_AppSENT.sent_module.sent, channelId);

    /* swap data as sent by tle5012 sensor and add status because it is included in CRC calculation on sensor side*/
    dataForCrc[0] = g_AppSENT.sentStatus[instance];
    dataForCrc[1] = g_AppSENT.sentRawData[instance].B.nibble2;
    dataForCrc[2] = g_AppSENT.sentRawData[instance].B.nibble1;
    dataForCrc[3] = g_AppSENT.sentRawData[instance].B.nibble0;

    /* calculate CRC on the received data */
    g_AppSENT.sentCrcCalculated[instance] = calculateCRCTLE5012SPC(&dataForCrc[0], NUM_OF_NIBBLES_FOR_CRC);
}

/*
 * This function does the Cyclic Redundancy Check(CRC) calculation for the decoded SPC nibbles.
 * Returns the calculated CRC value.
 * This CRC calculation is taken from TLE5012 sensor user manual
 */
static uint8 calculateCRCTLE5012SPC(uint8 *message, uint8 length)
{
    uint8 crc = TLX5012B_SSC_FRAME_CRC_SEED_VAL;
    uint8 numNibbles, bitData;

    for(numNibbles = 0; numNibbles < length; numNibbles++)
    {
        crc ^= message[numNibbles];
        for(bitData = 0; bitData < 4; bitData++)
        {
            if((crc & 0x08u) != 0)
            {
                crc <<= 1u;
                crc ^= 0x0Du;
            }
            else
            {
                crc <<= 1;
            }
        }
    }
    return (crc & 0x0Fu);
}

/*
 * Initialization of TOM to trigger SPC pulse sensor 1
 * */
void initTriggerInputGTMTOM2Ch7(void)
{
    /* Timer configuration structure */
    IfxGtm_Tom_Pwm_Config g_tomConfig;

    /* Enable GTM */
    IfxGtm_enable(&MODULE_GTM);

    /* Enable the FXU clock */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);

    /* Initialize the configuration with default parameters */
    IfxGtm_Tom_Pwm_initConfig(&g_tomConfig, &MODULE_GTM);
    g_tomConfig.tom = SPC_PULSE_CH4B_TRIGGER_INPUT.tom;             /* Select the TOM depending on the LED          */
    g_tomConfig.tomChannel = SPC_PULSE_CH4B_TRIGGER_INPUT.channel;  /* Select the channel depending on the LED      */
    g_tomConfig.period = PWM_PERIOD;                                /* Set the timer period                         */
    g_tomConfig.clock  = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk2;            /* slow clock low pwm frequency */
    g_tomConfig.dutyCycle = PWM_PERIOD / 2;
    g_tomConfig.pin.outputPin = &SPC_PULSE_CH4B_TRIGGER_INPUT;      /* Set the LED port pin as output               */
    g_tomConfig.synchronousUpdateEnabled = TRUE;                    /* Enable synchronous update                    */
    g_tomConfig.immediateStartEnabled = TRUE;

    /* Initialize the GTM TOM                     */
    IfxGtm_Tom_Pwm_init(&g_tomDriver[0], &g_tomConfig);

    /* Start the PWM */
    IfxGtm_Tom_Pwm_start(&g_tomDriver[0], TRUE);

    /*GTM trigger SPC pulse*/
    IfxGtm_Trig_toSent(&MODULE_GTM, IfxGtm_Trig_SentGroup_5, IfxGtm_Trig_SentTrig_0, IfxGtm_Trig_SentTrigSource_tom2, \
                                                                                      IfxGtm_Trig_SentTrigChannel_6);
}

/*
 * Initialization of GTM TOM to trigger SPC pulse sensor 2
 * */
void initTriggerInputGTMTOM0Ch7(void)
{
    /* Timer configuration structure */
    IfxGtm_Tom_Pwm_Config g_tomConfig;

    /* Enable GTM */
    IfxGtm_enable(&MODULE_GTM);

    /* Enable the FXU clock */
    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);

    /* Initialize the configuration structure with default parameters */
    IfxGtm_Tom_Pwm_initConfig(&g_tomConfig, &MODULE_GTM);
    g_tomConfig.tom = SPC_PULSE_CH9B_TRIGGER_INPUT.tom;             /* Select the TOM depending on the LED          */
    g_tomConfig.tomChannel = SPC_PULSE_CH9B_TRIGGER_INPUT.channel;  /* Select the channel depending on the LED      */
    g_tomConfig.period = PWM_PERIOD;                                /* Set the timer period                         */
    g_tomConfig.clock  = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk2;            /* slow clock for low PWM frequency */
    g_tomConfig.dutyCycle = PWM_PERIOD / 2;
    g_tomConfig.pin.outputPin = &SPC_PULSE_CH9B_TRIGGER_INPUT;      /* Set the LED port pin as output               */
    g_tomConfig.synchronousUpdateEnabled = TRUE;                    /* Enable synchronous update                    */
    g_tomConfig.immediateStartEnabled = TRUE;

    /* Initialize the GTM TOM with user value */
    IfxGtm_Tom_Pwm_init(&g_tomDriver[1], &g_tomConfig);

    /* Start the PWM */
    IfxGtm_Tom_Pwm_start(&g_tomDriver[1], TRUE);

    /*GTM trigger SPC pulse*/
    IfxGtm_Trig_toSent(&MODULE_GTM, IfxGtm_Trig_SentGroup_0, IfxGtm_Trig_SentTrig_0, IfxGtm_Trig_SentTrigSource_tom0, \
                                                                                      IfxGtm_Trig_SentTrigChannel_6);
}

/*
 * Initialization of SPC channel 4
 * */
void initSENTCh4bSPCMode(void)
{
    /* create module config */
    IfxSent_Sent_Config sentConfig;

    IfxSent_Sent_initModuleConfig(&sentConfig, SENT_CH4B_PIN_IN.module);

    /* initialize module */
    IfxSent_Sent_initModule(&g_AppSENT.sent_module, &sentConfig);

    /* create channel config */
    IfxSent_Sent_ChannelConfig sentChannelConfig;
    IfxSent_Sent_initChannelConfig(&sentChannelConfig, &g_AppSENT.sent_module);

    /* define tUnit of the external sensor */
    sentChannelConfig.tUnit = SENT_TICK_TIME;
    /* CRC is disabled, The CPU must perform the CRC on the current data by SW */
    sentChannelConfig.receiveControl.crcModeDisabled = TRUE;
    /* data nibbles per frame */
    sentChannelConfig.receiveControl.frameLength = 3;

    const IfxSent_Sent_Pins sentPins =
    {
        &SENT_CH4B_PIN_IN, IfxPort_InputMode_noPullDevice,  /* SENT input */
        &SPC_CH4_PIN_OUT,     IfxPort_OutputMode_openDrain, /* SENT output */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    /* Assign pins */
    sentChannelConfig.pins = &sentPins;
    sentChannelConfig.channelId = SENT_CH4B_PIN_IN.channelId;
    /* trigger SPC pulse with external source i.e. GTM */
    sentChannelConfig.inputOutputControl.externalTrigger = IfxSent_ExternalTrigger_5;

    /* SPC mode on */
    sentChannelConfig.spcModeOn = TRUE;
    /* range selection SPC mode */
    sentChannelConfig.transmitControl.spcMode = IfxSent_SpcMode_range;
    /* Sensor ID*/
    sentChannelConfig.transmitControl.pulseLength = SENSOR_ID1;
    /* Pulse is based on measured frequency of last Synchronization/Calibration Pulse  */
    sentChannelConfig.transmitControl.timeBase = 0;
    /* pulse generation after each external trigger */
    sentChannelConfig.transmitControl.triggerSource = IfxSent_TriggerSource_externalTrigger;

    /* ISR priorities and interrupt target */
    sentChannelConfig.interrupt.priority = ISR_PRIORITY_SENT_CHANNEL4;
    sentChannelConfig.interrupt.isrProvider = IfxSrc_Tos_cpu3;
    sentChannelConfig.enabledInterrupts.ALL = 0x3FFF;

    /* The TLE5012 provides the nibbles in Big-endian order, Swap the nibbles 0 and 2 */
    sentChannelConfig.nibbleControl.nibblePointer0 = IfxSent_Nibble_2;
    sentChannelConfig.nibbleControl.nibblePointer1 = IfxSent_Nibble_1;
    sentChannelConfig.nibbleControl.nibblePointer2 = IfxSent_Nibble_0;

    /* interrupt requested node */
    sentChannelConfig.interuptNodeControl.errorInterruptNode                    = IfxSent_InterruptNodePointer_trigo0;
    sentChannelConfig.interuptNodeControl.receiveBufferOverflowInterruptNode    = IfxSent_InterruptNodePointer_trigo0;
    sentChannelConfig.interuptNodeControl.receiveDataInterruptNode              = IfxSent_InterruptNodePointer_trigo0;
    sentChannelConfig.interuptNodeControl.receiveSuccessInterruptNode           = IfxSent_InterruptNodePointer_trigo0;
    sentChannelConfig.interuptNodeControl.serialDataReceiveInterruptNode        = IfxSent_InterruptNodePointer_trigo0;
    sentChannelConfig.interuptNodeControl.transferBufferUnderflowInterruptNode  = IfxSent_InterruptNodePointer_trigo0;
    sentChannelConfig.interuptNodeControl.transferDataInterruptNode             = IfxSent_InterruptNodePointer_trigo0;
    sentChannelConfig.interuptNodeControl.watchdogErrorInterruptNode            = IfxSent_InterruptNodePointer_trigo0;

    /* initialize channel */
    IfxSent_Sent_initChannel(&g_AppSENT.sentChannel[0], &sentChannelConfig);
}
/*
 * Initialization of SPC channel 9
 * */
void initSENTCh9bSPCMode(void)
{
    /* create module config */
    IfxSent_Sent_Config sentConfig;

    IfxSent_Sent_initModuleConfig(&sentConfig, SENT_CH9B_PIN_IN.module);

    /* initialize module */
    IfxSent_Sent_initModule(&g_AppSENT.sent_module, &sentConfig);

    /* create channel config */
    IfxSent_Sent_ChannelConfig sentChannelConfig;
    IfxSent_Sent_initChannelConfig(&sentChannelConfig, &g_AppSENT.sent_module);

    /* define tUnit of the external sensor */
    sentChannelConfig.tUnit = SENT_TICK_TIME;
    /* CRC is disabled, The CPU must perform the CRC on the current data by SW */
    sentChannelConfig.receiveControl.crcModeDisabled = TRUE;
    /* data nibbles per frame */
    sentChannelConfig.receiveControl.frameLength = 3;

    const IfxSent_Sent_Pins sentPins =
    {
        &SENT_CH9B_PIN_IN, IfxPort_InputMode_noPullDevice, /* SENT input */
        &SPC_CH9_PIN_OUT,    IfxPort_OutputMode_openDrain, /* SENT output */
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    /* Assign pins */
    sentChannelConfig.pins = &sentPins;
    sentChannelConfig.channelId = SENT_CH9B_PIN_IN.channelId;

    /* trigger SPC pulse with external source i.e. GTM */
    sentChannelConfig.inputOutputControl.externalTrigger = IfxSent_ExternalTrigger_0;

    /* SPC mode on */
    sentChannelConfig.spcModeOn = TRUE;
    /* range selection SPC mode */
    sentChannelConfig.transmitControl.spcMode = IfxSent_SpcMode_range;
    /* Sensor ID*/
    sentChannelConfig.transmitControl.pulseLength = SENSOR_ID2;
    /* Pulse is based on measured frequency of last Synchronization/Calibration Pulse  */
    sentChannelConfig.transmitControl.timeBase = 0;
    /* pulse generation after each external trigger */
    sentChannelConfig.transmitControl.triggerSource = IfxSent_TriggerSource_externalTrigger;

    /* ISR priorities and interrupt target */
    sentChannelConfig.interrupt.priority = ISR_PRIORITY_SENT_CHANNEL9;
    sentChannelConfig.interrupt.isrProvider = IfxSrc_Tos_cpu3;
    sentChannelConfig.enabledInterrupts.ALL = 0x3FFF;

    /* The TLE5012 provides the nibbles in Big-endian order, Swap the nibbles 0 and 2 */
    sentChannelConfig.nibbleControl.nibblePointer0 = IfxSent_Nibble_2;
    sentChannelConfig.nibbleControl.nibblePointer1 = IfxSent_Nibble_1;
    sentChannelConfig.nibbleControl.nibblePointer2 = IfxSent_Nibble_0;

    /* interrupt requested node */
    sentChannelConfig.interuptNodeControl.errorInterruptNode                    = IfxSent_InterruptNodePointer_trigo9;
    sentChannelConfig.interuptNodeControl.receiveBufferOverflowInterruptNode    = IfxSent_InterruptNodePointer_trigo9;
    sentChannelConfig.interuptNodeControl.receiveDataInterruptNode              = IfxSent_InterruptNodePointer_trigo9;
    sentChannelConfig.interuptNodeControl.receiveSuccessInterruptNode           = IfxSent_InterruptNodePointer_trigo9;
    sentChannelConfig.interuptNodeControl.serialDataReceiveInterruptNode        = IfxSent_InterruptNodePointer_trigo9;
    sentChannelConfig.interuptNodeControl.transferBufferUnderflowInterruptNode  = IfxSent_InterruptNodePointer_trigo9;
    sentChannelConfig.interuptNodeControl.transferDataInterruptNode             = IfxSent_InterruptNodePointer_trigo9;
    sentChannelConfig.interuptNodeControl.watchdogErrorInterruptNode            = IfxSent_InterruptNodePointer_trigo9;

    /* initialize channel */
    IfxSent_Sent_initChannel(&g_AppSENT.sentChannel[1], &sentChannelConfig);
}

/*
 * This function init TOM to trigger SPC pulse for sensor
 */
void initTriggerInputGTMTOM(void)
{
    /* initialize TOM to trigger SPC pulse sensor 1 */
    initTriggerInputGTMTOM2Ch7();

    /* initialize TOM to trigger SPC pulse sensor 2 */
    initTriggerInputGTMTOM0Ch7();
}

/*
 * SENT initialization
 * This function initializes the SENT module in Core 3
 * SM:SENT:CHANNEL_REDUNDANCY
 */
void initSENTwithSPCMode()
{
    /* init SENT in SPC mode for sensor1 */
    initSENTCh4bSPCMode();

    /* init SENT in SPC mode for sensor2 */
    initSENTCh9bSPCMode();
}

/*
 * Init SENT and GTM module
 */
void initTLE5012Modules()
{
    /* Initial SENT module in SPC mode for TLE5012 */
    initSENTwithSPCMode();

    /* Initial GTM TOM module for cyclic triggering of SPC Pulse */
    initTriggerInputGTMTOM();
}

/*
 * Function to check SENT redundancy
 *  SM:SENT:CHANNEL_REDUNDANCY
 *  */
void checkRedundancySENT()
{
    static uint8 ignoreValueCount = 0, alarmCount = 0;
    float32 diff1, diff2;

    /* Ignore first some measurement to get accurate/sync value for both sensor */
    if (ignoreValueCount < 20)
    {
        ignoreValueCount++;
    }
    else
    {
        /* Sensor1 move in clockwise and sensor 2 moves in anti clockwise and their intersection/start point is 90°
         * calculate the rotation angle covered by each sensor */
        if (g_SafetyKitStatus.sentRedundancy.angle[0] < START_ANGLE)
        {
            g_SafetyKitStatus.sentRedundancy.angleCover[0] = START_ANGLE - g_SafetyKitStatus.sentRedundancy.angle[0];
            g_SafetyKitStatus.sentRedundancy.angleCover[1] = g_SafetyKitStatus.sentRedundancy.angle[1] - START_ANGLE;
        }
        else if (g_SafetyKitStatus.sentRedundancy.angle[1] < START_ANGLE)
        {
            g_SafetyKitStatus.sentRedundancy.angleCover[0] = 360.00 + START_ANGLE - g_SafetyKitStatus.sentRedundancy.angle[0];
            g_SafetyKitStatus.sentRedundancy.angleCover[1] = 360.00 + g_SafetyKitStatus.sentRedundancy.angle[1] - START_ANGLE;
        }
        else
        {
            g_SafetyKitStatus.sentRedundancy.angleCover[0] = 360.00 + START_ANGLE - g_SafetyKitStatus.sentRedundancy.angle[0];
            g_SafetyKitStatus.sentRedundancy.angleCover[1] = g_SafetyKitStatus.sentRedundancy.angle[1] - START_ANGLE;
        }

        /* calculate minimum difference of two sensors */
        diff1 = fabsf(g_SafetyKitStatus.sentRedundancy.angleCover[0] - g_SafetyKitStatus.sentRedundancy.angleCover[1]);
        diff2 = 360 - diff1;
        g_SafetyKitStatus.sentRedundancy.angleMaximumThreshold = fminf(diff1, diff2);


        if ((g_SafetyKitStatus.sentRedundancy.angleMaximumThreshold > THRESHOLD_VALUE) ||
            (g_AppSENT.sentCrcCalculated[0] != g_AppSENT.sentCrcReceived[0])           ||
            (g_AppSENT.sentCrcCalculated[1] != g_AppSENT.sentCrcReceived[1]))
        {
            if(alarmCount > 5)
            {
                /* It is commented because most of the time magnet is not on the top of the sensor
                 * and hence this alarm will pop up every time. User can uncomment and see the reaction
                 * on tft display */
               /* softwareCoreAlarmTriggerSMU(SOFT_SMU_ALM_PORT_SMs); */
                alarmCount = 0;
            }
            alarmCount++;
        }
    }
}
