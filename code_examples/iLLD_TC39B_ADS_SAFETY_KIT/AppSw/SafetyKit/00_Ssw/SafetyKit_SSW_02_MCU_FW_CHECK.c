/**********************************************************************************************************************
 * \file SafetyKit_SSW_02_MCU_FW_CHECK.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "SafetyKit_SSW.h"
#include "SafetyKit_SSW_02_MCU_FW_CHECK.h"
#include "SafetyKit_SSW_02_MCU_FW_CHECK_tables_TC39B.h"
#include "SafetyKit_Main.h"
#include "IfxMtu.h"
#include "IfxMtu_cfg.h"
#include "IfxEmem.h"
#include "IfxEmem_reg.h"
#include "IfxSmu.h"
#include "IfxDmu_Reg.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
volatile Ifx_SMU_AG g_SafetyKitSmuAlarmRegStatus[IFXSMU_NUM_ALARM_GROUPS];

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
boolean safetyKitFwCheckSmuStmemLclcon(const FwCheckStruct *fwCheckTablSMU, const int structSize,
        const SafetyKitResetType resetType, FwCheckVerificationStruct *fwCheckVerification);
IfxMtu_MbistSel safetyKitFwCheckSsh(const SafetyKitResetType resetType);

IfxMtu_MbistSel safetyKitFwCheckCheckSshRegisters(const MemoryTestedStruct* sshTable, int tableSize);
boolean safetyKitFwCheckEvaluateRamInit(uint16 memoryMask);
boolean safetyKitFwCheckEvaluateLmuInit(uint16 memoryMask);

void safetyKitFwCheckClearSSH(const SafetyKitResetType resetType);
void safetyKitFwCheckClearSmuAlarms(const FwCheckStruct *fwCheckTable, const int tableSize);
void clearFaultStatusAndECCDetectionFSIRAM(void);

void safetyKitFwCheckRetriggerCheck(const SafetyKitResetType resetType);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/*
 * SM:MCU_FW_CHECK
 * */
void safetyKitSswMcuFwCheck(void)
{
    if(g_SafetyKitStatus.resetCode.resetType == safetyKitResetTypeColdpoweron)
    {
        /* Initialize the g_sswStatusXram data if it was a Cold PORST */
        g_sswStatusXram->mcuFwcheckRuns  = 0;
    }

    /* Enable MTU module if not yet enabled */
    boolean mtuWasEnabled = IfxMtu_isModuleEnabled();
    if (mtuWasEnabled == FALSE)
    {
        /* Enable MTU module */
        IfxMtu_enableModule();
    }

    /* Enable EMEM module if not yet enabled */
    boolean ememWasEnabled = IfxEmem_isModuleEnabled();
    if(ememWasEnabled == FALSE)
    {
        /* Enable and unlock MTU module */
        IfxEmem_enableModule(&MODULE_EMEM);
        IfxEmem_setUnlockMode(&MODULE_EMEM);
    }

    /* Take a snapshot of the SMU alarm registers before executing the FW check */
    for(uint8 alarmReg = 0; alarmReg < IFXSMU_NUM_ALARM_GROUPS; alarmReg++)
    {
        g_SafetyKitSmuAlarmRegStatus[alarmReg].U = MODULE_SMU.AG[alarmReg].U;
    }

    /* Increment the firmware check execution counter */
    g_sswStatusXram->mcuFwcheckRuns++;
    if  (
            /* Read SMU alarm register values and compare with expected ones(listed in Appendix A of the
             * Safety Manual)
             * Note: depending on the device and reset type different register values are expected */
            (TRUE == safetyKitFwCheckSmuStmemLclcon(fwCheckSMUTC39B, fwCheckSMUTC39BSize,
                     g_SafetyKitStatus.resetCode.resetType, fwCheckVerificationSMU))   &&
            /* Read SCU_STMEM register values and compare with expected ones(listed in Appendix A of the
             * Safety Manual) */
               (TRUE == safetyKitFwCheckSmuStmemLclcon(fwCheckSTMEMTC39B, fwCheckSTMEMTC39BSize,
                     g_SafetyKitStatus.resetCode.resetType, fwCheckVerificationSTMEM))  &&
            /* Read SCU_LCLCON register values and compare with expected ones (listed in Appendix A of the
             * Safety Manual) */
            (TRUE == safetyKitFwCheckSmuStmemLclcon(fwCheckLCLCONTC39B,  fwCheckLCLCONTC39BSize,
                     g_SafetyKitStatus.resetCode.resetType, fwCheckVerificationLCLCON)) &&
            /* Read SSH register values of all RAM and compare with expected ones (listed in Appendix A of
             * the Safety Manual)*/
            (IfxMtu_MbistSel_none == safetyKitFwCheckSsh(g_SafetyKitStatus.resetCode.resetType))
        )
    {
        /* If all four checks have passed set FW check status variable to "passed" */
        g_SafetyKitStatus.sswStatus.mcuFwcheckStatus = passed;

        /* If all registers and SMU alarm registers have reported the expected values .. */
        /* .. clear the content of the registers mentioned in the Appendix table */
        safetyKitFwCheckClearSSH(g_SafetyKitStatus.resetCode.resetType);
        /* .. clear the SMU alarms SMU_AG0..11 */
        safetyKitFwCheckClearSmuAlarms(fwCheckSMUTC39B, fwCheckSMUTC39BSize);
        /* .. clear the corresponding reset status bits in RSTSTAT register */
        IfxScuRcu_clearColdResetStatus();
    }
    else
    {
        g_SafetyKitStatus.sswStatus.mcuFwcheckStatus = failed;
        /* If FW check has failed during its first execution trigger the check again */
        if(g_sswStatusXram->mcuFwcheckRuns < SAFETKIT_FW_CHECK_MAX_RUNS)
        {
            /* Clear COLD PORST reason to preserve the data on the SCR XRAM */
            IfxScuRcu_clearColdResetStatus();
            safetyKitFwCheckRetriggerCheck(g_SafetyKitStatus.resetCode.resetType);
        }
    }

    /* Disable MTU module if it was disabled */
    if(mtuWasEnabled == FALSE)
    {
        /* Disable again */
        IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
        MTU_CLC.B.DISR = 1;
        IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    }
    /* Disable EMEM module if it was disabled */
    if(ememWasEnabled == FALSE)
    {
        /* Disable again */
        IfxEmem_disableModule(&MODULE_EMEM);
    }
}

/* This function is comparing the actual register values of the registers listed in Safety Manual Appendix A with
 * the expected ones. The expected values are depending on the device type and also the reset type.
 * const FwCheckStruct *FW_CHECK_table => pointer to a structure of type FwCheckStruct. The table consists of a
 * pointer to the address of the register which should be verified and accordingly the expected register values for
 * each reset type.
 * const int tableSize => amount of entries in the FW_CHECK_table
 * const SafetyKitResetType resetType => type of the reset
 * FwCheckVerificationStruct *FW_CHECK_verification => pointer to a structure where the test result will be written
 * into. Can be observed via debugger in case the FW check has failed
 * */
boolean safetyKitFwCheckSmuStmemLclcon (const FwCheckStruct *fwCheckTable, const int tableSize,
        const SafetyKitResetType resetType, FwCheckVerificationStruct *fwCheckVerification)
{
    boolean fwcheckHasPassed = TRUE;
    uint32 registerValue;
    uint32 expectedRegisterValue;

    /* A pointer to the corresponding FwCheckRegisterCheckStruct inside the FW_CHECK_table.
     * The corresponding structure of interest depends on the reset type. */
    const FwCheckRegisterCheckStruct* ptrRegisterCheckStrct;

    /* Iterate through the FW_CHECK_table */
    for(uint8 i = 0; i < tableSize; i++)
    {
        /* Set the pointer to the structure containing the expected register values */
        switch(resetType)
        {
            case safetyKitResetTypeColdpoweron:
            case safetyKitResetTypeLbist:
                ptrRegisterCheckStrct = &fwCheckTable[i].coldPORST;
                break;
            case safetyKitResetTypeWarmpoweron:
                ptrRegisterCheckStrct = &fwCheckTable[i].warmPORST;
                break;
            case safetyKitResetTypeSystem:
                ptrRegisterCheckStrct = &fwCheckTable[i].systemReset;
                break;
            case safetyKitResetTypeApplication:
                ptrRegisterCheckStrct = &fwCheckTable[i].applicationReset;
                break;
            default:
                __debug();
                break;
        }

        /* Read the value of the register which is checked during this iteration */
        registerValue = *(volatile uint32*) fwCheckTable[i].regUnderTest;
        /* Mask the register value in case there are any exceptions. (Refer to the Appendix A of the Safety Manual) */
        registerValue &= ptrRegisterCheckStrct->mask;
        /* Read the expected register value */
        expectedRegisterValue = ptrRegisterCheckStrct->expectedRegVal;

        /* Compare the register value with the expected value and write both the test result and the actual register
         * value into the verification structure. */
        fwCheckVerification[i].regVal = registerValue;
        fwCheckVerification[i].testHasPassed = (registerValue == expectedRegisterValue) ? TRUE : FALSE;
        /* Set fwcheckHasPassed to FALSE in case test has failed for any register during the iteration. */
        if(!fwCheckVerification[i].testHasPassed)
        {
            fwcheckHasPassed = FALSE;
        }
    }

    /* Return result after iteration and comparison of all registers listed in the FW_CHECK_table */
    return fwcheckHasPassed;
}

/*
 * Check the SSH registers and compare with the expected values depending on the reset type
 * */
IfxMtu_MbistSel safetyKitFwCheckSsh(const SafetyKitResetType resetType)
{
    IfxMtu_MbistSel fwcheckSshResult;
    switch (resetType)
    {
        case safetyKitResetTypeColdpoweron :
        case safetyKitResetTypeLbist :
            fwcheckSshResult = safetyKitFwCheckCheckSshRegisters(coldPorstSSHTC39B, coldPorstSSHTC39BSize);
            break;
        case safetyKitResetTypeWarmpoweron :
            fwcheckSshResult = safetyKitFwCheckCheckSshRegisters(warmPorstSSHTC39B, warmPorstSSHTC39BSize);
            break;
        case safetyKitResetTypeSystem :
            fwcheckSshResult = safetyKitFwCheckCheckSshRegisters(systemSSHTC39B, systemSSHTC39BSize);
            break;
        case safetyKitResetTypeApplication :
            fwcheckSshResult = safetyKitFwCheckCheckSshRegisters(applicationSSHTC39B, applicationSSHTC39BSize);
            break;
        default:
            __debug();
            break;
    }
    return fwcheckSshResult;
}

/*
 * clear the SSH registers
 * */
void safetyKitFwCheckClearSSH(const SafetyKitResetType resetType)
{
    /* Get pointer to specific table and set variable about the size of this table */
    const MemoryTestedStruct* sshTable;
    int tableSize;

    switch(resetType)
    {
        case safetyKitResetTypeColdpoweron:
        case safetyKitResetTypeLbist:
                sshTable    = coldPorstSSHTC39B;
                tableSize  = coldPorstSSHTC39BSize;
            break;
        case safetyKitResetTypeWarmpoweron:
                sshTable    = warmPorstSSHTC39B;
                tableSize  = warmPorstSSHTC39BSize;
            break;
        case safetyKitResetTypeSystem:
                sshTable    = systemSSHTC39B;
                tableSize  = systemSSHTC39BSize;
            break;
        case safetyKitResetTypeApplication:
                sshTable    = applicationSSHTC39B;
                tableSize  = applicationSSHTC39BSize;
            break;
        default:
            __debug();
            break;
    }

    /* Now iterate through the table and clear the ECCD, FAULTSTS and ERRINFO register values */
    IfxMtu_MbistSel mbistSel;
    Ifx_MTU_MC *mc;
    int a;
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();

    for (a = 0; a < tableSize ; a++ )
    {
       mbistSel = sshTable[a].sshUnderTest;

       mc = &MODULE_MTU.MC[mbistSel];
       mc->ECCD.U = 0x0;

       IfxScuWdt_clearSafetyEndinit(password);

       mc->FAULTSTS.U = 0x0;
       mc->ECCD.B.TRC = 1;  /* This will clear ERRINFO */

       IfxScuWdt_setSafetyEndinit(password);
    }
}

/*
 * This is the implementation of Erratum from Errata sheet
 * Erratum: [SMU_TC.H012]
 * The SMU alarms ALM7[1] and ALM7[0] are set intentionally after PORST and system reset and shall be
 * cleared by the application SW (cf. SM:MCU_FW_CHECK in Safety Manual) Also, in order to
 * clear the SMU alarms ALM7[1] and ALM7[0], it is necessary to clear the alarms within this MC40.
 * */
void clearFaultStatusAndECCDetectionFSIRAM(void)
{
    uint16 password = IfxScuWdt_getSafetyWatchdogPassword();
    uint16 *ptrEccd = (uint16 *)(0xF0063810);      /* MCi_ECCD and i = 40 */
    *ptrEccd = 0;

    IfxScuWdt_clearSafetyEndinit(password);
    uint16 *ptrFaultsts = (uint16 *)(0xF00638F0);  /* MCi_FAULTSTS and i = 40*/
    *ptrFaultsts = 0;
    IfxScuWdt_setSafetyEndinit(password);
}

/*
 * clear SMU alarm
 * */
void safetyKitFwCheckClearSmuAlarms(const FwCheckStruct *FW_CHECK_table, const int tableSize)
{
    uint16 passwd = IfxScuWdt_getSafetyWatchdogPassword();

    /* erratum SMU_TC.H012*/
    clearFaultStatusAndECCDetectionFSIRAM();

    IfxScuWdt_clearSafetyEndinit(passwd);

    /* Iterate through all SMU alarm status registers listed in the FW_CHECK_table and clear them */
    for(uint8 i = 0; i < tableSize; i++)
    {
        MODULE_SMU.CMD.U = IfxSmu_Command_alarmStatusClear;
        *(volatile uint32 *)FW_CHECK_table[i].regUnderTest = (uint32) 0xFFFFFFFF;
    }

    IfxScuWdt_setSafetyEndinit(passwd);

}

/*
 * retrigger firmware check
 * */
void safetyKitFwCheckRetriggerCheck(const SafetyKitResetType resetType)
{
    /* Initiate the specific reset to trigger an FW check. Note: the reset should be the same type as it was before
     * this FW check execution */
    switch (resetType)
    {
        case safetyKitResetTypeColdpoweron :
        case safetyKitResetTypeLbist :
            /* Trigger Cold PORST */
            safetyKitTriggerColdPorst();
            break;
        case safetyKitResetTypeWarmpoweron :
            safetyKitFwCheckClearSSH(resetType);
            /* Trigger Warm PORST */
            safetyKitTriggerWarmPorst();
            break;
        case safetyKitResetTypeSystem :
            safetyKitFwCheckClearSSH(resetType);
            safetyKitTriggerSwReset(safetyKitResetTypeSystem);
            break;
        case safetyKitResetTypeApplication :
            safetyKitFwCheckClearSSH(resetType);
            safetyKitTriggerSwReset(safetyKitResetTypeApplication);
            break;
        default:
            __debug();
            break;
    }
}

/*
 * This function is comparing the SSH registers of all RAMs with their expected values
 * */
IfxMtu_MbistSel safetyKitFwCheckCheckSshRegisters (const MemoryTestedStruct* sshTable, int tableSize)
{
    IfxMtu_MbistSel mbistSel;
    Ifx_MTU_MC *mc;
    int a;
    volatile uint16 expectedValueFAULTSTS, expectedValueECCD, expectedValueERRINFO;

    /* Iterate through all entries in the SSH_table */
    for (a = 0; a < tableSize; a++)
    {
        /* Get SSH which is tested during this iteration */
        mbistSel = sshTable[a].sshUnderTest;
        /* Get pointer to MC object of tested SSH */
        mc = &MODULE_MTU.MC[mbistSel];

        /* Evaluate which register values are expected for FAULTSTS, ECCD and ERRINFO registers. */
        /* Check which memory type it is and evaluate if the RAM is initialized or not. Depending on this different
         * FAULTSTS values are expected for CPU and LMU memories. */
        if ( CPU_MEM_TYPE == sshTable[a].memoryType)
        {
            if (TRUE == safetyKitFwCheckEvaluateRamInit(sshTable[a].InSelMask))
            {
                expectedValueFAULTSTS = 0x9;
            }
            else
            {
                expectedValueFAULTSTS = 0x1;
            }
        }
        else if ( LMU_MEM_TYPE == sshTable[a].memoryType)
        {
            if (TRUE == safetyKitFwCheckEvaluateLmuInit(sshTable[a].InSelMask))
            {
                expectedValueFAULTSTS = 0x9;
            }
            else
            {
                expectedValueFAULTSTS = 0x1;
            }
        }
        else
        {
            expectedValueFAULTSTS = sshTable[a].sshRegistersDef.faultstsVal;
        }

        expectedValueECCD = sshTable[a].sshRegistersDef.eccdVal;
        expectedValueERRINFO = sshTable[a].sshRegistersDef.errinfoVal;

        /* Exception: If AURIX woke up from standby, overwrite expected values with the dedicated standby values. */
        if (g_SafetyKitStatus.wakeupFromStandby)
        {
            expectedValueFAULTSTS = sshTable[a].sshRegistersStb.faultstsVal;
            expectedValueECCD = sshTable[a].sshRegistersStb.eccdVal;
            expectedValueERRINFO = sshTable[a].sshRegistersStb.errinfoVal;
        }

        /* Finally compare register values of selected memory with the expected ones, if any mismatch is detected
         * return the name of the selected memory and stop the function execution. */
        if (mc->ECCD.U != expectedValueECCD || mc->FAULTSTS.U != expectedValueFAULTSTS
                || mc->ERRINFO[0].U != expectedValueERRINFO)
        {
            return (mbistSel);
        }
    }

    return (IfxMtu_MbistSel_none);
}

/*
 * Verify if CPU memory is initialized
 * */
boolean safetyKitFwCheckEvaluateRamInit(uint16 memoryMask)
{
    if (( RAM_INIT_AT_COLD_WARM == DMU_HF_PROCONRAM.B.RAMIN) ||
        ( RAM_INIT_AT_COLD_ONLY == DMU_HF_PROCONRAM.B.RAMIN))
    {
        if (((DMU_HF_PROCONRAM.B.RAMINSEL) & (uint16) (memoryMask)) == 0)
        {
            return (TRUE);
        }
        else
        {
            return (FALSE);
        }
    }
    else
    {
        return (FALSE);
    }
}

/*
 * Verify if LMU memory is initialized
 * */
boolean safetyKitFwCheckEvaluateLmuInit(uint16 memoryMask)
{
    if ((RAM_INIT_AT_COLD_WARM == DMU_HF_PROCONRAM.B.RAMIN) ||
        (RAM_INIT_AT_COLD_ONLY == DMU_HF_PROCONRAM.B.RAMIN))
    {
        if (((DMU_HF_PROCONRAM.B.LMUINSEL) & (uint16) (memoryMask)) == 0)
        {
            return (TRUE);
        }
        else
        {
            return (FALSE);
        }
    }
    else
    {
        return (FALSE);
    }
}

/*
 * clear all SMU alarm
 * */
void safetyKitClearAllSmuAlarms(void)
{
    safetyKitFwCheckClearSmuAlarms(fwCheckSMUTC39B, fwCheckSMUTC39BSize);
}
