 /**********************************************************************************************************************
 * \file Perf_Meas.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "AppKit_Cfg.h"
#if RUN_PERF_MEAS

#include <Cpu/Std/Ifx_Types.h>
#include <_Impl/IfxCpu_cfg.h>
#include "IfxCbs_reg.h"
#include "Configuration.h"
#include "ConfigurationIsr.h"
#include "conio_tft.h"
#include "Perf_Meas.h"
#include "Ifx_reg.h"

#if IFXGTM_REG_H == 1
// use GTM if available
#include <Gtm/Tom/Timer/IfxGtm_Tom_Timer.h>
#else
// use CCU6
#include <Ccu6/Timer/IfxCcu6_Timer.h>
#endif
#include "AppKit_Main.h"

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if CPU_WHICH_SERVICE_PERF_MEAS == 0
    #if defined(__GNUC__)
    #pragma section ".text_cpu0" ax
    #pragma section ".bss_cpu0" awc0
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu0"
    #pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu0"
    #pragma ghs section bss= ".bss_cpu0"
    #pragma ghs section data=".data_cpu0"
    #endif
#elif ((CPU_WHICH_SERVICE_PERF_MEAS == 1) && (CPU_WHICH_SERVICE_PERF_MEAS < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu1" ax
    #pragma section ".bss_cpu1" awc1
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu1"
    #pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu1"
    #pragma ghs section bss= ".bss_cpu1"
    #pragma ghs section data=".data_cpu1"
    #endif
#elif ((CPU_WHICH_SERVICE_PERF_MEAS == 2) && (CPU_WHICH_SERVICE_PERF_MEAS < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu2" ax
    #pragma section ".bss_cpu2" awc2
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu2"
    #pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu2"
    #pragma ghs section bss= ".bss_cpu2"
    #pragma ghs section data=".data_cpu2"
    #endif
#elif ((CPU_WHICH_SERVICE_PERF_MEAS == 3) && (CPU_WHICH_SERVICE_PERF_MEAS < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu3" ax
    #pragma section ".bss_cpu3" awc3
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu3"
    #pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu3"
    #pragma ghs section bss= ".bss_cpu3"
    #pragma ghs section data=".data_cpu3"
    #endif
#elif ((CPU_WHICH_SERVICE_PERF_MEAS == 4) && (CPU_WHICH_SERVICE_PERF_MEAS < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu4" ax
    #pragma section ".bss_cpu4" awc4
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu4"
    #pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu4"
    #pragma ghs section bss= ".bss_cpu4"
    #pragma ghs section data=".data_cpu4"
    #endif
#elif ((CPU_WHICH_SERVICE_PERF_MEAS == 5) && (CPU_WHICH_SERVICE_PERF_MEAS < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu5" ax
    #pragma section ".bss_cpu5" awc5
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu5"
    #pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu5"
    #pragma ghs section bss= ".bss_cpu5"
    #pragma ghs section data=".data_cpu5"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_PERF_MEAS to a valid value!"
#endif

#if IFXCPU_NUM_MODULES > 5
volatile uint32 cpu5_last_count_value;
volatile float32 cpu5_load;
#endif

#if IFXCPU_NUM_MODULES > 4
volatile uint32 cpu4_last_count_value;
volatile float32 cpu4_load;
#endif

#if IFXCPU_NUM_MODULES > 3
volatile uint32 cpu3_last_count_value;
volatile float32 cpu3_load;
#endif

#if IFXCPU_NUM_MODULES > 2
volatile uint32 cpu2_last_count_value;
volatile float32 cpu2_load;
#endif

#if IFXCPU_NUM_MODULES > 1
volatile uint32 cpu1_last_count_value;
volatile float32 cpu1_load;
#endif

volatile uint32 cpu0_last_count_value;
volatile float32 cpu0_load;

/* this is defined in Cpu0_Main.h */
IFX_EXTERN volatile boolean tft_ready;
IFX_EXTERN App_Cpu g_AppCpu0; /* CPU 0 global data */
IFX_EXTERN App_Cpu g_AppCpu1; /* CPU 1 global data if available */
IFX_EXTERN App_Cpu g_AppCpu2; /* CPU 2 global data if available */
IFX_EXTERN App_Cpu g_AppCpu3; /* CPU 3 global data if available */
IFX_EXTERN App_Cpu g_AppCpu4; /* CPU 4 global data if available */
IFX_EXTERN App_Cpu g_AppCpu5; /* CPU 5 global data if available */

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
#if defined(__GNUC__)
    #pragma section // end bss section
#endif

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void perf_meas_init(void)
{
    // set the start values
#if IFXCPU_NUM_MODULES > 5
    cpu5_ccnt.cpu_idle_counter = 0;
    cpu5_last_count_value = 0;
#endif
#if IFXCPU_NUM_MODULES > 4
    cpu4_ccnt.cpu_idle_counter = 0;
    cpu4_last_count_value = 0;
#endif
#if IFXCPU_NUM_MODULES > 3
    cpu3_ccnt.cpu_idle_counter = 0;
    cpu3_last_count_value = 0;
#endif
#if IFXCPU_NUM_MODULES > 2
    cpu2_ccnt.cpu_idle_counter = 0;
    cpu2_last_count_value = 0;
#endif
#if IFXCPU_NUM_MODULES > 1
    cpu1_ccnt.cpu_idle_counter = 0;
    cpu1_last_count_value = 0;
#endif
    cpu0_ccnt.cpu_idle_counter = 0;
    cpu0_last_count_value = 0;

    // if the CDC is not enabled, then we enable it to use the performance counter
    // performance counter will be switched on in main...
    if (!(__mfcr(CPU_DBGSR) & 0x1))
    {
        CBS_OEC.U = 0xA1;
        CBS_OEC.U = 0x5E;
        CBS_OEC.U = 0xA1;
        CBS_OEC.U = 0x5E;
    }
#if IFXGTM_REG_H == 1
    /* GTM is available, we use the GTM */
    IfxGtm_Tom_Timer driverPerformanceMeasure;
    IfxGtm_Tom_Timer_Config driverConfig;

    IfxGtm_Tom_Timer_initConfig(&driverConfig, &MODULE_GTM);
    driverConfig.tom = PERFORMANCE_MEASURE.tom;
    driverConfig.timerChannel = PERFORMANCE_MEASURE.channel;
    driverConfig.irqModeTimer   = IfxGtm_IrqMode_pulse;
    driverConfig.clock = IfxGtm_Tom_Ch_ClkSrc_cmuFxclk3; // used clock is 100MHz/256
    driverConfig.base.frequency = 1.0f; // we make 1 Hz
    driverConfig.base.minResolution = 0;
    driverConfig.base.isrPriority = ISR_PRIORITY_PERF_MEAS;
    if (CPU_WHICH_SERVICE_PERF_MEAS)
        driverConfig.base.isrProvider = (IfxSrc_Tos)(CPU_WHICH_SERVICE_PERF_MEAS+1);
    else
        driverConfig.base.isrProvider = (IfxSrc_Tos)CPU_WHICH_SERVICE_PERF_MEAS;
    IfxGtm_Tom_Timer_init (&driverPerformanceMeasure, &driverConfig);
    IfxGtm_Tom_Timer_run(&driverPerformanceMeasure);
#else
    /* GTM is not available, we use the CCU6 as 1s timer */
    /* create configuration */
    IfxCcu6_Timer driverPerformanceMeasure;
    IfxCcu6_Timer_Config timerConfig;
    IfxCcu6_Timer_initModuleConfig(&timerConfig, &MODULE_CCU60);

    /* we would like to have an interrupt each 1 second */
    /* our CCU6 runs with 100MHz */
    /* we will not reach the 1s completely */
    /* we set the frqeuency to 12207 Hz which is ~100MHz/8192 (possible prescaler) */
    timerConfig.base.t13Frequency = 12207.0f;

    /* configure the period of the timer */
    timerConfig.base.t13Period = 12207;

    /* select the timer that needs to be started */
    timerConfig.timer = IfxCcu6_TimerId_t13;

    /* select the synchronous operation if both timers need to be start at the same time */
    /* previous selection of timer block can be ignored in this mode */
    timerConfig.synchronousOperation = FALSE;

    /* configure the clock for internal mode */
    timerConfig.clock.t13ExtClockEnabled   = FALSE;
    timerConfig.clock.t13ExtClockInput     = NULL_PTR;
    timerConfig.clock.t13countingInputMode = IfxCcu6_CountingInputMode_internal;

    /* configure the selected timer block */
    timerConfig.timer13.counterValue = 0;

    /* configure the interrupts */
    timerConfig.interrupt1.source         = IfxCcu6_InterruptSource_t13PeriodMatch;
    timerConfig.interrupt1.serviceRequest = IfxCcu6_ServiceRequest_2;
    timerConfig.interrupt1.priority       = ISR_PRIORITY_PERF_MEAS;
    if (CPU_WHICH_SERVICE_PERF_MEAS)
        timerConfig.interrupt1.typeOfService  = (IfxSrc_Tos)(CPU_WHICH_SERVICE_PERF_MEAS+1);
    else
        timerConfig.interrupt1.typeOfService  = (IfxSrc_Tos)(CPU_WHICH_SERVICE_PERF_MEAS);

    /* configure triggers */
    timerConfig.trigger.t13InSyncWithT12 = FALSE;

    /* initialize the module */
    IfxCcu6_Timer_initModule(&driverPerformanceMeasure, &timerConfig);

     IfxCcu6_Timer_start(&driverPerformanceMeasure);
#endif
}

IFX_INTERRUPT(ISR_perf_meas_call, CPU_WHICH_SERVICE_PERF_MEAS, ISR_PRIORITY_PERF_MEAS)
{
    uint32 cpu_counter_diff;
    uint32 act_cpu0_idle_counter=cpu0_ccnt.cpu_idle_counter;
#if IFXCPU_NUM_MODULES > 1
    uint32 act_cpu1_idle_counter=cpu1_ccnt.cpu_idle_counter;
#endif
#if IFXCPU_NUM_MODULES > 2
    uint32 act_cpu2_idle_counter=cpu2_ccnt.cpu_idle_counter;
#endif
#if IFXCPU_NUM_MODULES > 3
    uint32 act_cpu3_idle_counter=cpu3_ccnt.cpu_idle_counter;
#endif
#if IFXCPU_NUM_MODULES > 4
    uint32 act_cpu4_idle_counter=cpu4_ccnt.cpu_idle_counter;
#endif
#if IFXCPU_NUM_MODULES > 5
    uint32 act_cpu5_idle_counter=cpu5_ccnt.cpu_idle_counter;
#endif

    /* now we go to a lower priority than our OS_TICK that we don't have an overflow */
    __bisr(ISR_PRIORITY_OS_TICK-1);

#if IFXGTM_REG_H != 1
    IfxCcu6_clearInterruptStatusFlag(&MODULE_CCU60, IfxCcu6_InterruptSource_t13PeriodMatch);
#endif

    cpu_counter_diff = act_cpu0_idle_counter-cpu0_last_count_value;
    cpu0_last_count_value = act_cpu0_idle_counter;
    cpu0_load = 100.0f - (float32)cpu_counter_diff/(g_AppCpu0.info.cpuFreq/100.0f/(float32)cpu0_ccnt.cpu_ccnt_diff_min);

    if (cpu0_load < 0.0f) cpu0_load = 0.0f;
    // we printout if TFT is ready and conio initialized
    if (tft_ready == TRUE)
    {
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1,  1, (uint8 *)"CPU0 Load %.3f %c ", cpu0_load, 0x25);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1,  2, (uint8 *)"CPU0 Idle Counter-Diff %.10u ", cpu_counter_diff);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1,  3, (uint8 *)"CPU0 in use for %.3e Cycles/s ", g_AppCpu0.info.cpuFreq/100.0f*cpu0_load);
    }

#if IFXCPU_NUM_MODULES > 1
    cpu_counter_diff = act_cpu1_idle_counter-cpu1_last_count_value;
    cpu1_last_count_value = act_cpu1_idle_counter;
    cpu1_load = 100.0f - (float32)cpu_counter_diff/(g_AppCpu1.info.cpuFreq/100.0f/(float32)cpu1_ccnt.cpu_ccnt_diff_min);

    if (cpu1_load < 0.0f) cpu1_load = 0.0f;
    // we printout if TFT is ready and conio initialized
    if (tft_ready == TRUE)
    {
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1,  4, (uint8 *)"CPU1 Load %.3f %c ", cpu1_load, 0x25);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1,  5, (uint8 *)"CPU1 Idle Counter-Diff %.10u ", cpu_counter_diff);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1,  6, (uint8 *)"CPU1 in use for %.3e Cycles/s ", g_AppCpu1.info.cpuFreq/100.0f*cpu1_load);
    }
#endif

#if IFXCPU_NUM_MODULES > 2
    cpu_counter_diff = act_cpu2_idle_counter-cpu2_last_count_value;
    cpu2_last_count_value = act_cpu2_idle_counter;
    cpu2_load = 100.0f - (float32)cpu_counter_diff/(g_AppCpu2.info.cpuFreq/100.0f/(float32)cpu2_ccnt.cpu_ccnt_diff_min);

    if (cpu2_load < 0.0f) cpu2_load = 0.0f;
    // we printout if TFT is ready and conio initialized
    if (tft_ready == TRUE)
    {
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 7, (uint8 *)"CPU2 Load %.3f %c ", cpu2_load, 0x25);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 8, (uint8 *)"CPU2 Idle Counter-Diff %.10u ", cpu_counter_diff);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 9, (uint8 *)"CPU2 in use for %.3e Cycles/s ", g_AppCpu2.info.cpuFreq/100.0f*cpu2_load);
    }
#endif

#if IFXCPU_NUM_MODULES > 3
    cpu_counter_diff = act_cpu3_idle_counter-cpu3_last_count_value;
    cpu3_last_count_value = act_cpu3_idle_counter;
    cpu3_load = 100.0f - (float32)cpu_counter_diff/(g_AppCpu3.info.cpuFreq/100.0f/(float32)cpu3_ccnt.cpu_ccnt_diff_min);

    if (cpu3_load < 0.0f) cpu3_load = 0.0f;
    // we printout if TFT is ready and conio initialized
    if (tft_ready == TRUE)
    {
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 10, (uint8 *)"CPU3 Load %.3f %c ", cpu3_load, 0x25);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 11, (uint8 *)"CPU3 Idle Counter-Diff %.10u ", cpu_counter_diff);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 12, (uint8 *)"CPU3 in use for %.3e Cycles/s ", g_AppCpu3.info.cpuFreq/100.0f*cpu3_load);
    }
#endif

#if IFXCPU_NUM_MODULES > 4
    cpu_counter_diff = act_cpu4_idle_counter-cpu4_last_count_value;
    cpu4_last_count_value = act_cpu4_idle_counter;
    cpu4_load = 100.0f - (float32)cpu_counter_diff/(g_AppCpu4.info.cpuFreq/100.0f/(float32)cpu4_ccnt.cpu_ccnt_diff_min);

    if (cpu4_load < 0.0f) cpu4_load = 0.0f;
    // we printout if TFT is ready and conio initialized
    if (tft_ready == TRUE)
    {
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 13, (uint8 *)"CPU4 Load %.3f %c ", cpu4_load, 0x25);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 14, (uint8 *)"CPU4 Idle Counter-Diff %.10u ", cpu_counter_diff);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 15, (uint8 *)"CPU4 in use for %.3e Cycles/s ", g_AppCpu4.info.cpuFreq/100.0f*cpu4_load);
    }
#endif

#if IFXCPU_NUM_MODULES > 5
    cpu_counter_diff = act_cpu5_idle_counter-cpu5_last_count_value;
    cpu5_last_count_value = act_cpu5_idle_counter;
    cpu5_load = 100.0f - (float32)cpu_counter_diff/(g_AppCpu5.info.cpuFreq/100.0f/(float32)cpu5_ccnt.cpu_ccnt_diff_min);

    if (cpu5_load < 0.0f) cpu5_load = 0.0f;
    // we printout if TFT is ready and conio initialized
    if (tft_ready == TRUE)
    {
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 16, (uint8 *)"CPU5 Load %.3f %c ", cpu5_load, 0x25);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 17, (uint8 *)"CPU5 Idle Counter-Diff %.10u ", cpu_counter_diff);
        conio_ascii_printfxy (DISPLAYSTDOUT1, 1, 18, (uint8 *)"CPU5 in use for %.3e Cycles/s ", g_AppCpu5.info.cpuFreq/100.0f*cpu5_load);
    }
#endif

#if !defined(__DCC__)
    // we need this restore here because we add a bisr instruction manually, Windriver add this automatically
    __rslcx();
#endif
}

#if defined(__DCC__)
void dummy_function_perf_meas_2_avoid_error_with_dcc(void)
{
}
#endif

#if defined(__GNUC__)
#pragma section // end text section
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#endif
#if defined(__ghs__)
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#endif

#endif /* RUN_PERF_MEAS */
