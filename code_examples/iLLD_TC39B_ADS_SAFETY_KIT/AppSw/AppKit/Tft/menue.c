/**********************************************************************************************************************
 * \file menue.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include "AppKit_Cfg.h"
#include <Cpu/Std/Ifx_Types.h>
#include <stdio.h>
#include <string.h>
#include "Configuration.h"
#include "conio_tft.h"
#include "touch.h"
#if USE_RTC
#include "RTC.h"
#endif /* USE_RTC */
#if RUN_BCKLIGHT
#include "background_light.h"
#endif /* RUN_BCKLIGHT */

#if RUN_MEASUREMENT
#include "Measurement.h"
#endif /* RUN_MEASUREMENT */
/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/
void menu_display (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menu_input (sint32 ind, TDISPLAYENTRY * pdisplayentry);
#if USE_RTC
void menu_display_time (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_time (sint32 ind, TDISPLAYENTRY * pdisplayentry);
#endif /* USE_RTC */

#if DO_RUNTIMEMEAS
void menu_select_menu1 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_display_menu2 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_display_menu3 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menu_input_menu3 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_menu3 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
#endif /* DO_RUNTIMEMEAS */

#if USE_ALARM
void menu_select_alarm (sint32 ind, TDISPLAYENTRY * pdisplayentry);
#endif /* USE_ALARM */

#if RUN_BCKLIGHT
void menu_display_background_light (sint32 ind, TDISPLAYENTRY * pdisplayentry);
sint32 menu_input_background_light (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_background_light (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_background_lightplus (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_background_lightminus (sint32 ind, TDISPLAYENTRY * pdisplayentry);
#endif /* RUN_BCKLIGHT */

#if RUN_MEASUREMENT
void menu_display_die_temp (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_die_temp (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_display_core_volt (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_core_volt (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_display_Vddp3 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_Vddp3 (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_display_Vext (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_Vext (sint32 ind, TDISPLAYENTRY * pdisplayentry);
#endif /* RUN_MEASUREMENT */

#if RUN_SLIDESHOW
void menu_display_slideshow (sint32 ind, TDISPLAYENTRY * pdisplayentry);
void menu_select_slideshow (sint32 ind, TDISPLAYENTRY * pdisplayentry);

extern uint32 start_slideshow(void);
extern void stop_slideshow(void);
#endif /* RUN_SLIDESHOW */

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
// *INDENT-OFF*
const TDISPLAYENTRY menulist[19] = {
#if USE_RTC
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 7, 31, 0, &menu_select_time, &menu_display_time, &menu_input, "Date: 24/10/14 Time: 16:00"},
#endif /* USE_RTC */

#if DO_RUNTIMEMEAS
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 12, 2, &menu_select_menu1, &menu_display, &menu_input, "TFT Main Menu"},        //TFT Main Menue
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 5, 3, &menu_display_menu2, &menu_display_menu2, &menu_input, "Menu_2"},    //Time
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 5, 4, &menu_select_menu3, &menu_display_menu3, &menu_input, "Menu_3"},     //Delta
#endif /* DO_RUNTIMEMEAS */

#if USE_ALARM
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 8, 5, &menu_select_alarm, &menu_display, &menu_input, "Set Alarm"},        //Alarmtime
#endif /* USE_ALARM */

#if RUN_BCKLIGHT
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 16, 7, &menu_select_background_light, &menu_display_background_light, &menu_input_background_light, "Background Light: "},
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 15, 8, &menu_select_background_lightplus, &menu_display, &menu_input, "----> Increase: +"},
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 15, 9, &menu_select_background_lightminus, &menu_display, &menu_input, "----> Decrease: -"},
#endif /* RUN_BCKLIGHT */

#if RUN_MEASUREMENT
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 15, 11, &menu_select_die_temp, &menu_display_die_temp, &menu_input, "DIE-Temperature: "},
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 13, 13, &menu_select_core_volt, &menu_display_core_volt, &menu_input, "Core Voltage : "},
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 13, 14, &menu_select_Vddp3, &menu_display_Vddp3, &menu_input, "VDDP3 Voltage: "},
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 13, 15, &menu_select_Vext, &menu_display_Vext, &menu_input, "VEXT Voltage : "},
#endif /* RUN_MEASUREMENT */

#if RUN_SLIDESHOW
{(COLOR_CYAN << 4) | COLOR_BLACK, (COLOR_BLACK << 4) | COLOR_YELLOW, 0, 13, 17, &menu_select_slideshow, &menu_display_slideshow, &menu_input, "Start Slideshow"},
#endif /* RUN_SLIDESHOW */

#if !USE_RTC
{0, 0, 0, 0, 0, 0, 0, 0, " "},
#endif /* !USE_RTC */
#if !DO_RUNTIMEMEAS
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
#endif /* !DO_RUNTIMEMEAS */
#if !USE_ALARM
{0, 0, 0, 0, 0, 0, 0, 0, " "},
#endif /* !USE_ALARM */
#if !RUN_BCKLIGHT
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
#endif /* !RUN_BCKLIGHT */
#if !RUN_MEASUREMENT
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
#endif /* !RUN_MEASUREMENT */
#if !RUN_SLIDESHOW
{0, 0, 0, 0, 0, 0, 0, 0, " "},
#endif /* !RUN_SLIDESHOW */
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "},
{0, 0, 0, 0, 0, 0, 0, 0, " "}  //LAST ENTRY
};
// *INDENT-ON*
/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if DO_RUNTIMEMEAS
extern TCONTROLMENU controlmenu;
#endif /* DO_RUNTIMEMEAS */

#if USE_RTC
extern TIME Time2Set;
#endif /* USE_RTC */
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
void menu_display (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, &pdisplayentry->text[0]);
}

void menu_select (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, &pdisplayentry->text[0]);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}

sint32 menu_input (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    __debug ();
    return (0);
}

#if USE_RTC
void menu_display_time (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
  TIME ActTime;
  rtc_gettime (&ActTime);
  conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
  conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Date: %02x/%02x/%02x Time: %02x:%02x", ActTime.date, ActTime.month, ActTime.year, ActTime.hours, ActTime.minutes);
}

void menu_select_time (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    TIME ActTime;
    rtc_gettime (&ActTime);

    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy(DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Date: %02x/%02x/%02x Time: %02x:%02x", ActTime.date, ActTime.month, ActTime.year, ActTime.hours, ActTime.minutes);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
      conio_driver.dialogmode = SETTIMEON;    //open set time window
      rtc_gettime (&Time2Set);
      touch_driver.touchmode &= ~MASK_TOUCH_UP; //clear
      rtc_calibration();
    }
}
#endif /* USE_RTC */

#if DO_RUNTIMEMEAS
void menu_select_menu1 (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, (uint8 *) "Reset Time");
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        controlmenu.cpuseconds = 0.0f;
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}

void menu_display_menu2 (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Time %f", controlmenu.cpuseconds);
}

void menu_display_menu3 (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Delta %f", controlmenu.cpusecondsdelta);
}

sint32 menu_input_menu3 (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    float32 temp;
    sint32 result;
    result = sscanf ((char *) &conio_driver.scanftext[0], "%f", &temp);
    if (result != 1)
        return (-1);
    controlmenu.cpusecondsdelta = temp;
    return (0);
}

void menu_select_menu3 (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Delta %f", controlmenu.cpusecondsdelta);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        strcpy ((char *) &conio_driver.scanfdescr[0], "Delta ");
        sprintf ((char *) &conio_driver.scanftext[0], "%f", controlmenu.cpusecondsdelta);
        //                     control.cpuseconds=0.0f;
        conio_driver.scanfx = 0;    //actual cursor
        conio_driver.dialogmode = KEYBOARDON; //Keyboard input mode
        conio_driver.input = pdisplayentry->input;
        conio_driver.inputid = ind;
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}
#endif /* DO_RUNTIMEMEAS */

#if USE_ALARM
void menu_select_alarm (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
      conio_driver.dialogmode = SETALARMTIME;    //open set time window
      rtc_gettime (&Time2Set);
      touch_driver.touchmode &= ~MASK_TOUCH_UP; //clear
    }
}
#endif /* USE_ALARM */

#if RUN_BCKLIGHT
void menu_display_background_light (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Background Light: %u", (unsigned int) backgroundlightsize);
}

sint32 menu_input_background_light (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    uint32 temp;
    sint32 result;
    result = sscanf ((char *) &conio_driver.scanftext[0], "%u", (unsigned int *) &temp);
    if (result != 1)
        return (-1);
    if (temp < backgroundlightmin)
        temp = backgroundlightmin;
    if (temp > backgroundlightmax)
        temp = backgroundlightmax;

    backgroundlightsize = temp;

    return (0);
}

void menu_select_background_light (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);    //MENUE
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"Change Light: %u", (unsigned int) backgroundlightsize);   //MENUE
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        strcpy ((char *) &conio_driver.scanfdescr[0], "Light: ");    //PREP of Keyboard Mode
        sprintf ((char *) &conio_driver.scanftext[0], "%u", (unsigned int) backgroundlightsize); //right upper value
        conio_driver.scanfx = 0;    //actual cursor
        conio_driver.dialogmode = KEYBOARDON; //Keyboard input mode
        conio_driver.input = pdisplayentry->input;
        conio_driver.inputid = ind;
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}

void menu_select_background_lightplus (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, (uint8 *) "----> Increase +");
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
        if (backgroundlightsize < backgroundlightmax)
            backgroundlightsize += backgroundlightdelta;
    }
}

void menu_select_background_lightminus (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, (uint8 *) "----> Decrease -");
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
        if (backgroundlightsize > backgroundlightmin)
            backgroundlightsize -= backgroundlightdelta;
    }
}
#endif /* RUN_BCKLIGHT */

#if RUN_MEASUREMENT
void menu_display_die_temp (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"DIE Temperature: %.1f %cC", (float) die_temp, 0xF8);
}

void menu_select_die_temp (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"DIE Temp min: %.1f %cC  max: %.1f %cC", die_lowest, 0xF8, die_highest, 0xF8);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}

void menu_display_core_volt (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"CORE Voltage : %.2f V", (float) core_voltage);
}

void menu_select_core_volt (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"CORE Voltage min : %.2f V  max : %.2f V", core_volt_min, core_volt_max);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}

void menu_display_Vddp3 (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"VDDP3 Voltage: %.2f V", (float) Vddp3);
}

void menu_select_Vddp3 (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"VDDP3 Voltage min: %.2f V  max: %.2f V", Vddp3_min, Vddp3_max);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}

void menu_display_Vext (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"VEXT Voltage : %.2f V", (float) Vext);
}

void menu_select_Vext (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_printfxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y, (const uint8 *)"VEXT Voltage min : %.2f V  max : %.2f V", Vext_min, Vext_max);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP;   //clear
    }
}
#endif /* RUN_MEASUREMENT */

#if RUN_SLIDESHOW
void menu_display_slideshow (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    if (IfxPort_getPinState(SDCARD_USE_CD.port, SDCARD_USE_CD.pinIndex) == TRUE)
    {
        // no sdcard inside, we graying the point
        conio_ascii_textattr (DISPLAYMENU, COLOR_LIGHTGRAY);
        conio_ascii_textbackground (DISPLAYMENU, MENU_BACKGRND);
    }
    else
        conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_display);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
}

void menu_select_slideshow (sint32 ind, TDISPLAYENTRY * pdisplayentry)
{
    if (IfxPort_getPinState(SDCARD_USE_CD.port, SDCARD_USE_CD.pinIndex) == TRUE)
    {
        // no sdcard inside, we graying the point
        conio_ascii_textattr (DISPLAYMENU, COLOR_LIGHTGRAY);
        conio_ascii_textbackground (DISPLAYMENU, MENU_BACKGRND);
        conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
        conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
        return;
    }

    conio_ascii_textattr (DISPLAYMENU, pdisplayentry->color_select);
    conio_ascii_gotoxy (DISPLAYMENU, pdisplayentry->xmin, pdisplayentry->y);
    conio_ascii_cputs (DISPLAYMENU, pdisplayentry->text);
    if ((touch_driver.touchmode & MASK_TOUCH_UP) != 0)
    {
        touch_driver.touchmode &= ~MASK_TOUCH_UP; //clear
        /* if slideshow can start, then the conio_driver.dialogmode is set to SLIDESHOW */
        if (start_slideshow())
            /* there is an error, we must stop the slideshow */
            stop_slideshow();
    }
}
#endif /* RUN_SLIDESHOW */
void showmenu (sint16 x, sint16 y, TDISPLAYENTRY * pmenulist)
{
    sint32 i;
    conio_ascii_textbackground (DISPLAYMENU, MENU_BACKGRND);
    conio_ascii_clrscr (DISPLAYMENU);
    conio_ascii_textcolor (DISPLAYMENU, COLOR_BLACK);
    conio_ascii_textbackground (DISPLAYMENU, COLOR_CYAN);
    for (i = 0; pmenulist[i].select != 0; i += 1)
    {
        if ((x >= pmenulist[i].xmin) && (x <= pmenulist[i].xmax) && (y == pmenulist[i].y))
        {
            if (conio_driver.dialogmode == DIALOGOFF)
            {
                if (pmenulist[i].display == 0)
                    menu_select (i, (struct DISPLAYENTRY *) &pmenulist[i]);
                else
                {
                    pmenulist[i].select (i, (struct DISPLAYENTRY *) &pmenulist[i]);
                }
            }
        }
        else
        {
            if (pmenulist[i].display == 0)
                menu_display (i, (struct DISPLAYENTRY *) &pmenulist[i]);
            else
            {
                pmenulist[i].display (i, (struct DISPLAYENTRY *) &pmenulist[i]);
            }
        }
    }
}
