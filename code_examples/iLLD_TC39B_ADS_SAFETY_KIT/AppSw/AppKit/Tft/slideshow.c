/**********************************************************************************************************************
 * \file slideshow.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include <Cpu/Std/Ifx_Types.h>
#include <_Impl/IfxCpu_cfg.h>
#include "configuration.h"

#if RUN_SLIDESHOW

#include "conio_tft.h"
#include "touch.h"
#include <stdio.h>
#include <string.h>
#include "ff.h"

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/
/* BITMAP_FILE_HEADER without uint16 bfType because compiler increased this to 32bit */
typedef struct BITMAP_FILE_HEADER {
  uint32 bfSize;
  uint16 bfReserved1;
  uint16 bfReserved2;
  uint32 bfOffBits;
} BITMAPFILEHEADER, *PBITMAPFILEHEADER;

typedef struct BITMAP_INFO_HEADER {
  uint32 biSize;
  uint32 biWidth;
  uint32 biHeight;
  uint16 biPlanes;
  uint16 biBitCount;
  uint32 biCompression;
  uint32 biSizeImage;
  uint32 biXPelsPerMeter;
  uint32 biYPelsPerMeter;
  uint32 biClrUsed;
  uint32 biClrImportant;
} BITMAPINFOHEADER, *PBITMAPINFOHEADER;

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if CPU_WHICH_SERVICE_TFT == 0
    #if defined(__GNUC__)
    #pragma section ".text_cpu0" ax
    #pragma section ".bss_cpu0" awc0
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu0"
    #pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
    #pragma section CONST ".rodata_cpu0"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu0"
    #pragma ghs section bss= ".bss_cpu0"
    #pragma ghs section data=".data_cpu0"
    #pragma ghs section rodata=".rodata_cpu0"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 1) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu1" ax
    #pragma section ".bss_cpu1" awc1
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu1"
    #pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
    #pragma section CONST ".rodata_cpu1"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu1"
    #pragma ghs section bss= ".bss_cpu1"
    #pragma ghs section data=".data_cpu1"
    #pragma ghs section rodata=".rodata_cpu1"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 2) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu2" ax
    #pragma section ".bss_cpu2" awc2
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu2"
    #pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
    #pragma section CONST ".rodata_cpu2"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu2"
    #pragma ghs section bss= ".bss_cpu2"
    #pragma ghs section data=".data_cpu2"
    #pragma ghs section rodata=".rodata_cpu2"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 3) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu3" ax
    #pragma section ".bss_cpu3" awc3
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu3"
    #pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
    #pragma section CONST ".rodata_cpu3"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu3"
    #pragma ghs section bss= ".bss_cpu3"
    #pragma ghs section data=".data_cpu3"
    #pragma ghs section rodata=".rodata_cpu3"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 4) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu4" ax
    #pragma section ".bss_cpu4" awc4
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu4"
    #pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
    #pragma section CONST ".rodata_cpu4"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu4"
    #pragma ghs section bss= ".bss_cpu4"
    #pragma ghs section data=".data_cpu4"
    #pragma ghs section rodata=".rodata_cpu4"
    #endif
#elif ((CPU_WHICH_SERVICE_TFT == 5) && (CPU_WHICH_SERVICE_TFT < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu5" ax
    #pragma section ".bss_cpu5" awc5
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu5"
    #pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
    #pragma section CONST ".rodata_cpu5"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu5"
    #pragma ghs section bss= ".bss_cpu5"
    #pragma ghs section data=".data_cpu5"
    #pragma ghs section rodata=".rodata_cpu5"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_TFT to a valid value!"
#endif

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
FATFS Fatfs;        /* File system object */
FIL actFile;        /* File object */
FILINFO fno;        /* File status object */
DIR dir;            /* Directory object */
BITMAPFILEHEADER actFileHeader; /* bitmap file header */
BITMAPINFOHEADER actInfoHeader; /* bitmap info header */
uint32 uiActRow;
uint8 rawRowData[320*3] IFX_ALIGN(4); /* must be align to 32 bit because SDMMC works with aligned buffer only */

#if defined(__GNUC__)
    #pragma section // end bss section
#endif

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
FRESULT scan_files (char* path)
{
    FRESULT res;
    FILINFO fno;
    DIR dir;
    int i;
    char *fn;
#if _USE_LFN
    static char lfn[_MAX_LFN * (0 ? 2 : 1) + 1];
    fno.lfname = lfn;
    fno.lfsize = sizeof(lfn);
#endif


    res = f_opendir(&dir, path);
    if (res == FR_OK) {
        i = strlen(path);
        for (;;) {
            res = f_readdir(&dir, &fno);
            if (res != FR_OK || fno.fname[0] == 0)
            {
                conio_ascii_printf (DISPLAYSTDOUT1, (uint8 *)"Error: %d\n", res);
                break;
            }
            if (fno.fname[0] == '.') continue;
#if _USE_LFN
            fn = *fno.lfname ? fno.lfname : fno.fname;
#else
            fn = fno.fname;
#endif
            if (fno.fattrib & AM_DIR) {
                sprintf(&path[i], "/%s", fn);
                res = scan_files(path);
                if (res != FR_OK)
                {
                    conio_ascii_printf (DISPLAYSTDOUT1, (uint8 *)"Error: %s %d\n", path, res);
                    break;
                }
                path[i] = 0;
            } else {
                conio_ascii_printf (DISPLAYSTDOUT1, (uint8 *)"%s/%s\n", path, fn);
            }
        }
    }
    else
        conio_ascii_printf (DISPLAYSTDOUT1, (uint8 *)"opendir fail: %s %d\n", path, res);

    return res;
}

void stop_slideshow (void)
{
    /* switch to DIALOGOFF */
    conio_driver.dialogmode = DIALOGOFF;
    /* switch to stdout1 to show the error message */
    conio_driver.displaymode = DISPLAYSTDOUT1;
#if IFXGTM_REG_H == 1 && RUN_BCKLIGHT
    /* switch back the backgroundlight to PWM controlled */
    IfxPort_setPinModeOutput(BACKGROUND_LIGHT.pin.port, BACKGROUND_LIGHT.pin.pinIndex, IfxPort_OutputMode_pushPull, BACKGROUND_LIGHT.select);
#endif
    /* we enable our blinking led */
    if (SCU_CHIPID.B.VART == 0x3)
        IfxPort_setPinModeOutput(LIFEHOLD_LED_ADAS.port, LIFEHOLD_LED_ADAS.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    else
        IfxPort_setPinModeOutput(LIFEHOLD_LED.port, LIFEHOLD_LED.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    f_mount(0, 0);      /* UnMount */
}

uint32 start_slideshow (void)
{
    FRESULT res;                //Result

#if IFXGTM_REG_H == 1 && RUN_BCKLIGHT
    /* we enable the background light Application Kit */
    IfxPort_setPinModeOutput(BACKGROUND_LIGHT.pin.port, BACKGROUND_LIGHT.pin.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinState(BACKGROUND_LIGHT.pin.port, BACKGROUND_LIGHT.pin.pinIndex, IfxPort_State_high);
#endif
    /* we disable our blinking led */
    if (SCU_CHIPID.B.VART == 0x3)
        IfxPort_setPinModeInput(LIFEHOLD_LED_ADAS.port, LIFEHOLD_LED_ADAS.pinIndex, IfxPort_InputMode_pullUp); //Set LED0 as Input with pull-up to switch off
    else
        IfxPort_setPinModeInput(LIFEHOLD_LED.port, LIFEHOLD_LED.pinIndex, IfxPort_InputMode_pullUp); //Set LED0 as Input with pull-up to switch off

    f_mount(0, &Fatfs);     /* Register volume work area (never fails) */
    res = f_opendir(&dir, "");
    if (res != FR_OK)
    {
        conio_ascii_printf (DISPLAYSTDOUT1, (uint8 *)"f_opendir error: %d\n", res);
        return 1;
    }
    conio_driver.dialogmode = SLIDESHOW;
    return 0;
}

void slideshow_periodic (void)
{
    FRESULT res;                //Result
    uint16 bfType, usCnt;
    UINT  bytesRead;
    if (actFile.fs == 0)
    {
        // we don't have a file open, we open
        res = f_readdir(&dir, &fno);
        if (res != FR_OK)
        {
            conio_ascii_printf (DISPLAYSTDOUT1, (uint8 *)"f_readdir error: %d\n", res);
            stop_slideshow();
            return;
        }
        if (fno.fname[0] == 0)
        {
            // we don't have more files in this directory, reset the directory to restart
            f_readdir(&dir, 0);
            return;
        }
        // we ignore subdirectories
        if ((fno.fname[0] == '.') || (fno.fattrib & AM_DIR)) return;
        if (fno.lfname == 0) fno.lfname = fno.fname;
        res = f_open(&actFile, fno.lfname, FA_READ);
        if (res != FR_OK)
        {
            // file can't open, we ignore this file
            return;
        }
        /* now we check that the file is ok */
        /* get the file header */
        res = f_read(&actFile, (void *)&bfType, sizeof(uint16), &bytesRead);
        if ((res != FR_OK) || (bytesRead != sizeof(uint16)) || (bfType != 0x4D42))
        {
            // file can't read properly, we ignore this file
            f_close(&actFile);
            return;
        }
        /* get the file header */
        res = f_read(&actFile, (void *)&actFileHeader, sizeof(BITMAPFILEHEADER), &bytesRead);
        if ((res != FR_OK) || (bytesRead != sizeof(BITMAPFILEHEADER)))
        {
            // file can't read properly, we ignore this file
            f_close(&actFile);
            return;
        }
        /* get the bitmap info header */
        res = f_read(&actFile, (void *)&actInfoHeader, sizeof(BITMAPINFOHEADER), &bytesRead);
        if ((res != FR_OK) || (bytesRead != sizeof(BITMAPINFOHEADER)))
        {
            // file can't read properly, we ignore this file
            f_close(&actFile);
            return;
        }
        if ((actInfoHeader.biWidth != TFT_XSIZE))
        {
            // file can't read properly, we ignore this file
            f_close(&actFile);
            return;
        }
        if (actFileHeader.bfOffBits != sizeof(BITMAPFILEHEADER)+sizeof(BITMAPINFOHEADER)+2) f_lseek(&actFile, actFileHeader.bfOffBits);
        uiActRow = 0;
        // we go out here to don't overload this call
        return;
    }
    // if tft_status not 0 the the TFT is busy and we skip here
    if (tft_status != 0) return;
    // we set our row buffer to black
    if (uiActRow < TFT_YSIZE)
    {
        for (usCnt=0;usCnt<TFT_XSIZE; usCnt++) Row_Buff[usCnt] = COLOR_BLACK;
        tft_display_setxy(0, uiActRow);
        if (uiActRow < actInfoHeader.biHeight)
        {
            // we get a new row from the actual file
            res = f_read(&actFile, (void *)&rawRowData, TFT_XSIZE*(actInfoHeader.biBitCount/8), &bytesRead);
            if ((res != FR_OK) || (bytesRead != TFT_XSIZE*(actInfoHeader.biBitCount/8)))
            {
                conio_ascii_printf (DISPLAYSTDOUT1, (uint8 *)"f_read error: %d bytes read: %d\n", res, bytesRead);
                /* if the f_close not work (e.g. card removed) we reset the actfile here */
                if (f_close(&actFile) != FR_OK) actFile.fs = 0;
                stop_slideshow();
                return;
            }
            for (usCnt=0;usCnt<TFT_XSIZE; usCnt++)
            {
                if (actInfoHeader.biBitCount == 24)
                {
                    uint8 r, g, b;
                    // we get the pixeldata and put it to the row buff
                    b = rawRowData[(actInfoHeader.biBitCount/8)*usCnt] >> 3;                 //b has only 5bit
                    g = rawRowData[(actInfoHeader.biBitCount/8)*usCnt+1] >> 2;               //g has only 6bit
                    r = rawRowData[(actInfoHeader.biBitCount/8)*usCnt+2] >> 3;               //r has only 5bit

                    if (usCnt & 0x1) Row_Buff[usCnt-1] = (r << 11) | (g << 5) | b;
                    else Row_Buff[usCnt+1] = (r << 11) | (g << 5) | b;
                }
                else
                    Row_Buff[usCnt] = (rawRowData[(actInfoHeader.biBitCount/8)*usCnt+1]<<8) | rawRowData[(actInfoHeader.biBitCount/8)*usCnt];
            }
        }
        // send the line to tft
        tft_flush_row_buff((void *)0, TFT_XSIZE);
    }
    uiActRow++;
    if (uiActRow == 500) f_close(&actFile);
    touch_event.status = TOUCH_DOWN;

}

#if defined(__GNUC__)
#pragma section // end text section
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#pragma section CONST
#endif
#if defined(__ghs__)
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#pragma ghs section rodata=default
#endif


#endif /* RUN_SLIDESHOW */
