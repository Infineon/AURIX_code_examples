 /**********************************************************************************************************************
 * \file AsclinShellInterface.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include "AppKit_Cfg.h"
#include "assert.h"
#include "AsclinShellInterface.h"
#include "SysSe/Time/Ifx_DateTime.h"
#include "AppKit_main.h"
#if USE_LIN
#include "LinCmds.h"
#endif /* USE_LIN */
#if USE_TLF
#include "TLF3XX8XCmds.h"
#endif /* USE_TLF */
#if USE_SAFETYKIT_TLF
#include "SafetyKit_Tlf35584Cmds.h"
#endif /* USE_SAFETYKIT_TLF */
#if USE_GPIO
#include "GpioCmds.h"
#endif /* USE_GPIO */
#if USE_EVADC
#include "EvadcCmds.h"
#endif /* USE_EVADC */
#if USE_CAN
#include "CanCmds.h"
#endif /* USE_CAN */
#if RUN_MEASUREMENT
#include "Measurement.h"
#endif /* RUN_MEASUREMENT */
#include "assert.h"
#include "Configuration.h"
#include "ConfigurationIsr.h"
#if USE_ETH
#if IFXGETH_REG_H == 1
#include "EthernetCmds.h"
#endif
#endif /* USE_ETH */
#if USE_SAFETYKIT_ASC_SHELL
#include "SafetyKit_SmuCmds.h"
#endif /* USE_SAFETYKIT_ASC_SHELL */

#if CPU_WHICH_SERVICE_ASC_SHELL == 0
    #if defined(__GNUC__)
    #pragma section ".text_cpu0" ax
    #pragma section ".bss_cpu0" awc0
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu0"
    #pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
    #pragma section CONST ".rodata_cpu0"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu0"
    #pragma ghs section bss= ".bss_cpu0"
    #pragma ghs section data=".data_cpu0"
    #pragma ghs section rodata=".rodata_cpu0"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 1) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu1" ax
    #pragma section ".bss_cpu1" awc1
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu1"
    #pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
    #pragma section CONST ".rodata_cpu1"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu1"
    #pragma ghs section bss= ".bss_cpu1"
    #pragma ghs section data=".data_cpu1"
    #pragma ghs section rodata=".rodata_cpu1"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 2) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu2" ax
    #pragma section ".bss_cpu2" awc2
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu2"
    #pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
    #pragma section CONST ".rodata_cpu2"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu2"
    #pragma ghs section bss= ".bss_cpu2"
    #pragma ghs section data=".data_cpu2"
    #pragma ghs section rodata=".rodata_cpu2"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 3) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu3" ax
    #pragma section ".bss_cpu3" awc3
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu3"
    #pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
    #pragma section CONST ".rodata_cpu3"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu3"
    #pragma ghs section bss= ".bss_cpu3"
    #pragma ghs section data=".data_cpu3"
    #pragma ghs section rodata=".rodata_cpu3"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 4) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu4" ax
    #pragma section ".bss_cpu4" awc4
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu4"
    #pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
    #pragma section CONST ".rodata_cpu4"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu4"
    #pragma ghs section bss= ".bss_cpu4"
    #pragma ghs section data=".data_cpu4"
    #pragma ghs section rodata=".rodata_cpu4"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 5) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__GNUC__)
    #pragma section ".text_cpu5" ax
    #pragma section ".bss_cpu5" awc5
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu5"
    #pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
    #pragma section CONST ".rodata_cpu5"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu5"
    #pragma ghs section bss= ".bss_cpu5"
    #pragma ghs section data=".data_cpu5"
    #pragma ghs section rodata=".rodata_cpu5"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_ASC_SHELL to a valid value!"
#endif

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/*#define SHELL_HELP_DESCRIPTION_TEXT                                 \
    "       : Display command list."ENDL                              \
    "             A command followed by a question mark '?' will"ENDL \
    "             show the command syntax"*/

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

boolean AppShell_status(pchar args, void *data, IfxStdIf_DPipe *io);

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
App_AsclinShellInterface g_AsclinShellInterface; /**< \brief Demo information */
volatile boolean AsclinShell_InitDone=FALSE;

#if RUN_PERF_MEAS
#if IFXCPU_NUM_MODULES > 5
extern volatile float32 cpu5_load;
#endif

#if IFXCPU_NUM_MODULES > 4
extern volatile float32 cpu4_load;
#endif

#if IFXCPU_NUM_MODULES > 3
extern volatile float32 cpu3_load;
#endif

#if IFXCPU_NUM_MODULES > 2
extern volatile float32 cpu2_load;
#endif

#if IFXCPU_NUM_MODULES > 1
extern volatile float32 cpu1_load;
#endif

extern volatile float32 cpu0_load;
#endif /* RUN_PERF_MEAS */
/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
#if defined(__GNUC__)
    #pragma section // end bss section
    #if CPU_WHICH_SERVICE_ASC_SHELL == 0
    #pragma section ".rodata_cpu0" ac0
    #endif
    #if ((CPU_WHICH_SERVICE_ASC_SHELL == 1) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu1" ac1
    #endif
    #if ((CPU_WHICH_SERVICE_ASC_SHELL == 2) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu2" ac2
    #endif
    #if ((CPU_WHICH_SERVICE_ASC_SHELL == 3) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu3" ac3
    #endif
    #if ((CPU_WHICH_SERVICE_ASC_SHELL == 4) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu4" ac4
    #endif
    #if ((CPU_WHICH_SERVICE_ASC_SHELL == 5) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #pragma section ".rodata_cpu5" ac5
    #endif
#endif
/** \brief Application shell command list */
const Ifx_Shell_Command AppShell_commands[] = {
#if USE_RTC || RUN_MEASUREMENT || RUN_PERF_MEAS
    {"status", "     : Show the application status", &g_AsclinShellInterface,       &AppShell_status,    },
#endif /* USE_RTC || RUN_MEASUREMENT || RUN_PERF_MEAS */
#if USE_TLF || USE_SAFETYKIT_TLF
    {"standby", "    : Switch TLF35584 to standby or TLF30682 to disable state",   &g_AsclinShellInterface,       &tflStandbyDisable,      },
#endif /* USE_TLF || USE_SAFETYKIT_TLF */
#if USE_GPIO
    {"showport", "   : Show the state of Px.y",   &g_AsclinShellInterface,       &Show_PortState,      },
    {"setport", "    : Set the state of Px.y to state z (0/1)",   &g_AsclinShellInterface,       &Set_PortState,      },
    {"configport", " : Configure Px.y to input or output",   &g_AsclinShellInterface,       &Config_Port,      },
#endif /* USE_GPIO */
#if USE_EVADC
    {"showan", "     : Show the value(s) of ANx [to y]",   &g_AsclinShellInterface,       &Show_ANx_y,      },
#endif /* USE_EVADC */
#if USE_LIN
    {"lininit", "    : Initialize the Lin modules",   &g_AsclinShellInterface,       &lininit,      },
    {"linread", "    : Read from Lin device x with id y n bytes",   &g_AsclinShellInterface,       &linread,      },
    {"linwrite", "   : Write to Lin device x with id y n bytes",   &g_AsclinShellInterface,       &linwrite,      },
#endif /* USE_LIN */
#if USE_CAN
    {"caninit", "    : Initialize the Can modules and nodes with baudrate x",   &g_AsclinShellInterface,       &caninit,      },
    {"cannodeinit", ": Initialize the Can node x with baudrate y",   &g_AsclinShellInterface,       &cannodeinit,      },
    {"cansend", "    : Send values a and b on Can node x with id",   &g_AsclinShellInterface,       &cansend,      },
#endif /* USE_CAN */
#if USE_ETH
#if IFXGETH_REG_H == 1
    {"ping", "       : Send a ping to any address or to the gateway",   &g_AsclinShellInterface,       &ethernetping,      },
    {"netstat", "    : Show status of ethernet",   &g_AsclinShellInterface,       &ethernetstat,      },
#endif
#endif /* USE_ETH */
#if USE_TLF || USE_SAFETYKIT_TLF
    {"showtlf", "    : Show status of TLF register",   &g_AsclinShellInterface,       &showTLFRegister,      },
#endif /* USE_TLF || USE_SAFETYKIT_TLF */
#if USE_SAFETYKIT_ASC_SHELL
    {"trigAlarm", "    : Trigger an SMU alarm",   &g_AsclinShellInterface,       &trigSmuAlarm,      },
#endif /* USE_SAFETYKIT_ASC_SHELL */
    {"help",   SHELL_HELP_DESCRIPTION_TEXT,        &g_AsclinShellInterface.shell, &Ifx_Shell_showHelp, },
    IFX_SHELL_COMMAND_LIST_END
};

#if defined(__GNUC__)
    #pragma section // end rodata section
#endif

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Demo_AsclinShellInterface_SrcDoc_Main_Interrupt
 * \{ */

/** \name Interrupts for Serial interface
 * \{ */

/** \} */

/** \} */

/** \brief Handle Asc0 Rx interrupt
 *
 * \isrProvider \ref ISR_PROVIDER_ASC_0
 * \isrPriority \ref ISR_PRIORITY_ASC_SHELL_RX
 *
 * - Configuration of this interrupt is done by Asc_If_init()
 * - This interrupt is raised each time a data have been received on the serial interface.
 *   and Asc_If_receiveIrq() will be called
 */
IFX_INTERRUPT(ISR_Asc_Shell_rx, CPU_WHICH_SERVICE_ASC_SHELL, ISR_PRIORITY_ASC_SHELL_RX)
{
    IfxCpu_enableInterrupts();
    IfxStdIf_DPipe_onReceive(&g_AsclinShellInterface.stdIf.asc);
}


/** \brief Handle Asc0 Tx interrupt
 *
 * \isrProvider \ref ISR_PROVIDER_ASC_0
 * \isrPriority \ref ISR_PRIORITY_ASC_SHELL_TX
 *
 * - Configuration of this interrupt is done by Asc_If_init()
 * - This interrupt is raised each time the serial interface transmit buffer get empty
 *   and Asc_If_transmitIrq() will be called
 */
IFX_INTERRUPT(ISR_Asc_Shell_tx, CPU_WHICH_SERVICE_ASC_SHELL, ISR_PRIORITY_ASC_SHELL_TX)
{
    IfxCpu_enableInterrupts();
    IfxStdIf_DPipe_onTransmit(&g_AsclinShellInterface.stdIf.asc);
}


/** \brief Handle Asc0 Ex interrupt.
 *
 * \isrProvider \ref CPU_WHICH_SERVICE_ASC_SHELL
 * \isrPriority \ref ISR_PRIORITY_ASC_SHELL_EX
 *
 * - Configuration of this interrupt is done by Asc_If_init()
 * - This interrupt is raised each time an error occurs on the serial interface and
 *   Asc_If_errorIrq() will be called.
 */
IFX_INTERRUPT(ISR_Asc_Shell_ex, CPU_WHICH_SERVICE_ASC_SHELL, ISR_PRIORITY_ASC_SHELL_EX)
{
    IfxCpu_enableInterrupts();
    IfxStdIf_DPipe_onError(&g_AsclinShellInterface.stdIf.asc);
}

/** \brief Handle the 'status' command
 *
 * \par Syntax
 *  - status : Show the application internal state
 */
boolean AppShell_status(pchar args, void *data, IfxStdIf_DPipe *io)
{
    if (Ifx_Shell_matchToken(&args, "?") != FALSE)
    {
        IfxStdIf_DPipe_print(io, "Syntax     : status"ENDL);
        IfxStdIf_DPipe_print(io, "           > Show the application internal state"ENDL);
    }
    else
    {
        Ifx_DateTime rt;
        DateTime_get(&rt);
#if USE_RTC
        IfxStdIf_DPipe_print(io, "Alive: %02d:%02d:%02d"ENDL, rt.hours, rt.minutes, rt.seconds);
#endif /* USE_RTC */
#if RUN_MEASUREMENT
        IfxStdIf_DPipe_print(io, "DIE Temperature : %.1f %cC (min: %.1f %cC  max: %.1f %cC)"ENDL, (float) die_temp, 0xF8, die_lowest, 0xF8, die_highest, 0xF8);
        IfxStdIf_DPipe_print(io, "VEXT Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vext, Vext_min, Vext_max);
        IfxStdIf_DPipe_print(io, "VDDP3 Voltage: %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddp3, Vddp3_min, Vddp3_max);
        IfxStdIf_DPipe_print(io, "CORE Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) core_voltage, core_volt_min, core_volt_max);
#endif /* RUN_MEASUREMENT */

#if RUN_PERF_MEAS
        IfxStdIf_DPipe_print(io, "CPU0 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu0.info.cpuFreq);
        IfxStdIf_DPipe_print(io, "STM0 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu0.info.stmFreq);
        IfxStdIf_DPipe_print(io, "CPU0 Load %.3f %c"ENDL, cpu0_load, 0x25);
        IfxStdIf_DPipe_print(io, "CPU0 in use for %.3e Cycles/s"ENDL, g_AppCpu0.info.cpuFreq/100.0f*cpu0_load);
#if IFXCPU_NUM_MODULES > 1
        IfxStdIf_DPipe_print(io, "CPU1 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu1.info.cpuFreq);
        IfxStdIf_DPipe_print(io, "STM1 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu1.info.stmFreq);
        IfxStdIf_DPipe_print(io, "CPU1 Load %.3f %c"ENDL, cpu1_load, 0x25);
        IfxStdIf_DPipe_print(io, "CPU1 in use for %.3e Cycles/s"ENDL, g_AppCpu1.info.cpuFreq/100.0f*cpu1_load);
#endif
#if IFXCPU_NUM_MODULES > 2
        IfxStdIf_DPipe_print(io, "CPU2 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu2.info.cpuFreq);
        IfxStdIf_DPipe_print(io, "STM2 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu2.info.stmFreq);
        IfxStdIf_DPipe_print(io, "CPU2 Load %.3f %c"ENDL, cpu2_load, 0x25);
        IfxStdIf_DPipe_print(io, "CPU2 in use for %.3e Cycles/s"ENDL, g_AppCpu2.info.cpuFreq/100.0f*cpu2_load);
#endif
#if IFXCPU_NUM_MODULES > 3
        IfxStdIf_DPipe_print(io, "CPU3 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu3.info.cpuFreq);
        IfxStdIf_DPipe_print(io, "STM3 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu3.info.stmFreq);
        IfxStdIf_DPipe_print(io, "CPU3 Load %.3f %c"ENDL, cpu3_load, 0x25);
        IfxStdIf_DPipe_print(io, "CPU3 in use for %.3e Cycles/s"ENDL, g_AppCpu3.info.cpuFreq/100.0f*cpu3_load);
#endif
#if IFXCPU_NUM_MODULES > 4
        IfxStdIf_DPipe_print(io, "CPU4 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu4.info.cpuFreq);
        IfxStdIf_DPipe_print(io, "STM4 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu4.info.stmFreq);
        IfxStdIf_DPipe_print(io, "CPU4 Load %.3f %c"ENDL, cpu4_load, 0x25);
        IfxStdIf_DPipe_print(io, "CPU4 in use for %.3e Cycles/s"ENDL, g_AppCpu4.info.cpuFreq/100.0f*cpu4_load);
#endif
#if IFXCPU_NUM_MODULES > 5
        IfxStdIf_DPipe_print(io, "CPU5 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu5.info.cpuFreq);
        IfxStdIf_DPipe_print(io, "STM5 Frequency: %ld Hz"ENDL, (sint32)g_AppCpu5.info.stmFreq);
        IfxStdIf_DPipe_print(io, "CPU5 Load %.3f %c"ENDL, cpu5_load, 0x25);
        IfxStdIf_DPipe_print(io, "CPU5 in use for %.3e Cycles/s"ENDL, g_AppCpu5.info.cpuFreq/100.0f*cpu5_load);
#endif
#endif /* RUN_PERF_MEAS */
    }

    return TRUE;
}

/** Initialise the serial interafce
 *
 */
void initSerialInterface(void)
{
    {   /** - Serial interface */
        IfxAsclin_Asc_Config config;
        IfxAsclin_Asc_initModuleConfig(&config, ASC_SHELL_TX_PIN.module);
        config.baudrate.baudrate             = CFG_ASC_SHELL_BAUDRATE;
        config.baudrate.oversampling         = IfxAsclin_OversamplingFactor_16;
        config.bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_three;
        config.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;
        config.interrupt.rxPriority          = ISR_PRIORITY_ASC_SHELL_RX;
        config.interrupt.txPriority          = ISR_PRIORITY_ASC_SHELL_TX;
        config.interrupt.erPriority          = ISR_PRIORITY_ASC_SHELL_EX;
        if (CPU_WHICH_SERVICE_ASC_SHELL)
            config.interrupt.typeOfService       = (IfxSrc_Tos)(CPU_WHICH_SERVICE_ASC_SHELL+1);
        else
            config.interrupt.typeOfService       = (IfxSrc_Tos)CPU_WHICH_SERVICE_ASC_SHELL;

        IfxAsclin_Asc_Pins ascPins = {
            .cts       = NULL_PTR,
            .ctsMode   = IfxPort_InputMode_noPullDevice,
            .rx        = &ASC_SHELL_RX_PIN,
            .rxMode    = IfxPort_InputMode_noPullDevice,
            .rts       = NULL_PTR,
            .rtsMode   = IfxPort_OutputMode_pushPull,
            .tx        = &ASC_SHELL_TX_PIN,
            .txMode    = IfxPort_OutputMode_pushPull,
            .pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
        };
        config.pins         = &ascPins;
        config.rxBuffer     = g_AsclinShellInterface.ascBuffer.rx;
        config.txBuffer     = g_AsclinShellInterface.ascBuffer.tx;
        config.txBufferSize = CFG_ASC_TX_BUFFER_SIZE;
        config.rxBufferSize = CFG_ASC_RX_BUFFER_SIZE;
        IfxAsclin_Asc_initModule(&g_AsclinShellInterface.drivers.asc, &config);

        /* Connect the standard asc interface to the device driver*/
        IfxAsclin_Asc_stdIfDPipeInit(&g_AsclinShellInterface.stdIf.asc, &g_AsclinShellInterface.drivers.asc);
    }

    /* Ifx_Console initialisation */
    Ifx_Console_init(&g_AsclinShellInterface.stdIf.asc);

    /* Assert initialisation */
    Ifx_Assert_setStandardIo(&g_AsclinShellInterface.stdIf.asc);
}


void AsclinShellInterface_init(void)
{
    /** - Initialise the time constants */
    /* initTime(); */

    /** - Initialise the serial interface and the console */
    initSerialInterface();

    /** - Enable the global interrupts of this CPU */
    restoreInterrupts(TRUE);

    Ifx_Console_print(ENDL);

    /** - Simple print using IfxAsclin_Asc_write API */
//    Ifx_SizeT count = sizeof("Hello world!  => print using IfxAsclin_Asc_write()\n")/sizeof(char);
//    IfxAsclin_Asc_write(&g_AsclinShellInterface.drivers.asc, "Hello world!  => print using IfxAsclin_Asc_write()\n", &count, TIME_INFINITE);

    /** - Simple print using Ifx_Console_print API */
    //Ifx_Console_print(ENDL "Hello world!  => print using Ifx_Console_print()"ENDL);

    /** - Simple print using IfxStdIf_DPipe_print API */
    //IfxStdIf_DPipe_print(&g_AsclinShellInterface.stdIf.asc, ENDL "Hello world!  => print using IfxStdIf_DPipe_print()"ENDL);
    // correct board version if needed
    IfxStdIf_DPipe_print(&g_AsclinShellInterface.stdIf.asc, "Hello World"ENDL);
    IfxStdIf_DPipe_print(&g_AsclinShellInterface.stdIf.asc, "I am the %s TC3%d%d %s%s with %s..."ENDL, BOARD_TEXT, SCU_CHIPID.B.CHID, SCU_CHIPID.B.CHPK,
            (SCU_CHIPID.B.VART == 0x3)?"ADAS ":" ", SW_VERSION_TEXT, SAFETY_EVA_BOARD);

    Ifx_Console_print(ENDL "Enter 'help' to see the available commands"ENDL);

    AsclinShell_InitDone = TRUE;
    /** - Initialize the shell interface  */
    {
        Ifx_Shell_Config config;
        Ifx_Shell_initConfig(&config);
        config.standardIo     = &g_AsclinShellInterface.stdIf.asc;
        config.commandList[0] = &AppShell_commands[0];

        Ifx_Shell_init(&g_AsclinShellInterface.shell, &config);
    }
}


void AsclinShellInterface_run(void)
{
    /** Handle the shell interface */
    Ifx_Shell_process(&g_AsclinShellInterface.shell);
#ifdef IFXERAY_NUM_MODULES
    /* check if there is anything to print from Eray */
    Print_ErayMsg(&g_AsclinShellInterface.stdIf.asc);
#endif
#if USE_CAN
    /* check if there is anything to print from CAN */
    Print_CanMsg(&g_AsclinShellInterface.stdIf.asc);
#endif /* USE_CAN */
}

#if defined(__GNUC__)
#pragma section // end text section
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#pragma section CONST
#endif
#if defined(__ghs__)
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#pragma ghs section rodata=default
#endif
