/**********************************************************************************************************************
 * \file AppKit_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "AppKit_Main.h"
#include "AppKit_Cfg.h"


#if USE_SCR
#include "IfxSCR_Start.h"
#endif /* USE_SCR */
#include "IfxGeth_Eth.h"

#if IFXGTM_REG_H == 1
#include "IfxGtm.h"
#include "IfxGtm_Cmu.h"
#else
// use CCU6
#include <Ccu6/Timer/IfxCcu6_Timer.h>
#endif

#include "Configuration.h"
#include "ConfigurationIsr.h"

#include "Ifx_reg.h"
#include "IfxScuRcu.h"
#include <_PinMap/IfxAsclin_PinMap.h>
#include <_PinMap/IfxCan_PinMap.h>

#if USE_ALARM
#include "Beeper.h"
#endif /* USE_ALARM */

#if USE_TLF
// include tlf3xx8x
#include "TLF3xx8x.h"
#endif /* USE_TLF */

#if USE_RTC
// include rtc
#include "rtc.h"
#endif /* USE_RTC */

#if USE_ASC_SHELL
// include shell
#include "AsclinShellInterface.h"
#endif /* USE_ASC_SHELL */

#if USE_TFT

// include tft
#include "conio_tft.h"
#if RUN_BCKLIGHT
#include "background_light.h"
#endif /* RUN_BCKLIGHT */
#if USE_RTC
IFX_EXTERN TIME Time2Set;
#endif /* USE_RTC */

#if DO_RUNTIMEMEAS
IFX_EXTERN TCONTROLMENU controlmenu;
#endif /* DO_RUNTIMEMEAS */

#if USE_ETH
#if LWIP_PRINT_VIA_DISPLAY
IFX_EXTERN volatile boolean tft_ready;
#endif /* LWIP_PRINT_VIA_DISPLAY */
#endif /* USE_ETH */

IFX_EXTERN void tft_appl_init (uint8 RtcRunning);

#if DRAW_LOGO
IFX_EXTERN void graph_drawInfineonLogo(void);
#endif /* DRAW_LOGO */

#endif /* USE_TFT */

#if RUN_MEASUREMENT
// include measurement
#include "Measurement.h"
#endif /* RUN_MEASUREMENT */

#if RUN_PERF_MEAS
// include Performance measurement
#include "Perf_Meas.h"
#endif /* RUN_PERF_MEAS */

#if USE_EVADC
// include shell
#include "EvadcAutoScan.h"
#endif

#if USE_ETH
// include lwip
#include "Ifx_Lwip.h"
IFX_EXTERN void set_CGI_SSI_Handler (void);
#ifdef LWIP_PRINT_VIA_DISPLAY
IFX_EXTERN volatile boolean tft_ready;
#endif
#endif /* USE_ETH */

#if USE_CAN
// include CAN
#include "Can.h"
#endif /* USE_CAN */

#if RUN_SLIDESHOW
IFX_EXTERN void disk_timerproc(void);
#endif /* RUN_SLIDESHOW */

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
#if RUN_PERF_MEAS

#if defined(__GNUC__)
#pragma section ".text_cpu0" ax
#pragma section ".bss_cpu0" awc0
#endif
#if defined(__TASKING__)
#pragma section code    "text_cpu0"
#pragma section farbss  "bss_cpu0"
#pragma section fardata "data_cpu0"
#endif
#if defined(__DCC__)
#pragma section CODE ".text_cpu0"
#pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
#endif
#if defined(__ghs__)
#pragma ghs section text=".text_cpu0"
#pragma ghs section bss= ".bss_cpu0"
#pragma ghs section data=".data_cpu0"
#endif

    CpuCcnt cpu0_ccnt;

#if defined(__GNUC__)
#pragma section ".text_cpu1" ax
#pragma section ".bss_cpu1" awc1
#endif
#if defined(__TASKING__)
#pragma section code    "text_cpu1"
#pragma section farbss  "bss_cpu1"
#pragma section fardata "data_cpu1"
#endif
#if defined(__DCC__)
#pragma section CODE ".text_cpu1"
#pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
#endif
#if defined(__ghs__)
#pragma ghs section text=".text_cpu1"
#pragma ghs section bss= ".bss_cpu1"
#pragma ghs section data=".data_cpu1"
#endif

    CpuCcnt cpu1_ccnt;

#if defined(__GNUC__)
#pragma section ".text_cpu2" ax
#pragma section ".bss_cpu2" awc2
#endif
#if defined(__TASKING__)
#pragma section code    "text_cpu2"
#pragma section farbss  "bss_cpu2"
#pragma section fardata "data_cpu2"
#endif
#if defined(__DCC__)
#pragma section CODE ".text_cpu2"
#pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
#endif
#if defined(__ghs__)
#pragma ghs section text=".text_cpu2"
#pragma ghs section bss= ".bss_cpu2"
#pragma ghs section data=".data_cpu2"
#endif

    CpuCcnt cpu2_ccnt;

#if defined(__GNUC__)
#pragma section ".text_cpu3" ax
#pragma section ".bss_cpu3" awc3
#endif
#if defined(__TASKING__)
#pragma section code    "text_cpu3"
#pragma section farbss  "bss_cpu3"
#pragma section fardata "data_cpu3"
#endif
#if defined(__DCC__)
#pragma section CODE ".text_cpu3"
#pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
#endif
#if defined(__ghs__)
#pragma ghs section text=".text_cpu3"
#pragma ghs section bss= ".bss_cpu3"
#pragma ghs section data=".data_cpu3"
#endif

    CpuCcnt cpu3_ccnt;

#if defined(__GNUC__)
#pragma section ".text_cpu4" ax
#pragma section ".bss_cpu4" awc4
#endif
#if defined(__TASKING__)
#pragma section code    "text_cpu4"
#pragma section farbss  "bss_cpu4"
#pragma section fardata "data_cpu4"
#endif
#if defined(__DCC__)
#pragma section CODE ".text_cpu4"
#pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
#endif
#if defined(__ghs__)
#pragma ghs section text=".text_cpu4"
#pragma ghs section bss= ".bss_cpu4"
#pragma ghs section data=".data_cpu4"
#endif

    CpuCcnt cpu4_ccnt;

#if defined(__GNUC__)
#pragma section ".text_cpu5" ax
#pragma section ".bss_cpu5" awc5
#endif
#if defined(__TASKING__)
#pragma section code    "text_cpu5"
#pragma section farbss  "bss_cpu5"
#pragma section fardata "data_cpu5"
#endif
#if defined(__DCC__)
#pragma section CODE ".text_cpu5"
#pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
#endif
#if defined(__ghs__)
#pragma ghs section text=".text_cpu5"
#pragma ghs section bss= ".bss_cpu5"
#pragma ghs section data=".data_cpu5"
#endif

    CpuCcnt cpu5_ccnt;

#if defined(__GNUC__)
#pragma section // end text section
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#endif
#if defined(__ghs__)
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#endif

#endif /* RUN_PERF_MEAS */

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
#if RUN_PERF_MEAS
CpuCcnt * get_cpuX_ccnt(IfxCpu_ResourceCpu cpuIndex);
#endif /* RUN_PERF_MEAS */
#if USE_TLF
unsigned int get_STMx_TIM0_value(IfxCpu_ResourceCpu cpuIndex);
#endif /* USE_TLF */

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* This function initializes the application state structure for all CPUs */
void initAppState(App_Cpu *lcl_AppCpu, IfxCpu_ResourceCpu cpuIndex)
{
    if(cpuIndex == IfxCpu_ResourceCpu_0)
    {
        /* Clear RCU flags if it was a cold reset */
        if (IfxScuRcu_readRawResetStatus() & IFXSCURCU_POWERONRESET_MASK)
        {
            /* we had a cold reset, we need to clear the flags */
            IfxScuRcu_clearColdResetStatus();
        }

        /* In case of wake up via vext ramp up, we clear the corresponding bit to avoid immediate wake up in case of standby entry */
        if (PMS_PMSWSTAT2.B.PWRWKP == 1)
        {
            uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();
            IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
            PMS_PMSWSTATCLR.B.PWRWKPCLR = 1;
            IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
        }
    }

    /* Initialize the application state for all CPUs */
    lcl_AppCpu->info.pllFreq = IfxScuCcu_getPllFrequency();
    lcl_AppCpu->info.cpuFreq = IfxScuCcu_getCpuFrequency(cpuIndex);
    lcl_AppCpu->info.sysFreq = IfxScuCcu_getSpbFrequency();

    switch (cpuIndex) {
        case IfxCpu_ResourceCpu_0:
            lcl_AppCpu->info.stmFreq = IfxStm_getFrequency(&MODULE_STM0);
            break;
#if (IFXCPU_NUM_MODULES > 1)
        case IfxCpu_ResourceCpu_1:
            lcl_AppCpu->info.stmFreq = IfxStm_getFrequency(&MODULE_STM1);
            break;
#endif
#if (IFXCPU_NUM_MODULES > 2)
        case IfxCpu_ResourceCpu_2:
            lcl_AppCpu->info.stmFreq = IfxStm_getFrequency(&MODULE_STM2);
            break;
#endif
#if (IFXCPU_NUM_MODULES > 3)
        case IfxCpu_ResourceCpu_3:
            lcl_AppCpu->info.stmFreq = IfxStm_getFrequency(&MODULE_STM3);
            break;
#endif
#if (IFXCPU_NUM_MODULES > 4)
        case IfxCpu_ResourceCpu_4:
            lcl_AppCpu->info.stmFreq = IfxStm_getFrequency(&MODULE_STM4);
            break;
#endif
#if (IFXCPU_NUM_MODULES > 5)
        case IfxCpu_ResourceCpu_5:
            lcl_AppCpu->info.stmFreq = IfxStm_getFrequency(&MODULE_STM5);
            break;
#endif
        default: while (1) {}; break;
    }

    lcl_AppCpu->TickCount_1ms = 0;
}

/* Default initialization of pins used on Application Kit */
void initPins(void)
{
    /* in case that all our pins are tristate we enable the pull-up on some pins */
    if (PMS_PMSWSTAT.B.TRIST)
    {
        #if USE_TLF
            /* CS to TLF3xx8x */
            IfxPort_setPinModeInput(TLF_CS_PIN.pin.port, TLF_CS_PIN.pin.pinIndex, IfxPort_InputMode_pullUp);
        #endif
        #if USE_TFT
            /* CS to touch */
            IfxPort_setPinModeInput(TOUCH_USE_CHIPSELECT.pin.port, TOUCH_USE_CHIPSELECT.pin.pinIndex, IfxPort_InputMode_pullUp);
            /* CS to TFT */
            IfxPort_setPinModeInput(TFT_USE_CHIPSELECT.pin.port, TFT_USE_CHIPSELECT.pin.pinIndex, IfxPort_InputMode_pullUp);
            /* INT from touch */
            IfxPort_setPinModeInput(TOUCH_USE_INT.port, TOUCH_USE_INT.pinIndex, IfxPort_InputMode_pullUp);
        #endif
        #if USE_SD_CARD
            /* CS to SD card */
            IfxPort_setPinModeInput(SDCARD_USE_CHIPSELECT.pin.port, SDCARD_USE_CHIPSELECT.pin.pinIndex, IfxPort_InputMode_pullUp);
            /* CD from sd card */
            IfxPort_setPinModeInput(SDCARD_USE_CD.port, SDCARD_USE_CD.pinIndex, IfxPort_InputMode_pullUp);
        #endif
        #if USE_CAN
            /* CAN00 TXD */
            IfxPort_setPinModeInput(CAN00_TXD_PIN.pin.port, CAN00_TXD_PIN.pin.pinIndex, IfxPort_InputMode_pullUp);
            #ifdef MODULE_SDMMC0
                /* CAN02 TXD (if SDMMC usable) */
                IfxPort_setPinModeInput(CAN02_TXD_PIN.pin.port, CAN02_TXD_PIN.pin.pinIndex, IfxPort_InputMode_pullUp);
            #endif
        #endif
        #if USE_LIN
            /* LIN TX */
            IfxPort_setPinModeInput(LIN_TXD_PIN.pin.port, LIN_TXD_PIN.pin.pinIndex, IfxPort_InputMode_pullUp);
        #endif
        #if USE_ASC_SHELL
            /* ASC TX */
            IfxPort_setPinModeInput(ASC_SHELL_TX_PIN.pin.port, ASC_SHELL_TX_PIN.pin.pinIndex, IfxPort_InputMode_pullUp);
        #endif
    }
}

void initAppKit(IfxCpu_ResourceCpu cpuIndex)
{
    if(cpuIndex == IfxCpu_ResourceCpu_0)
    {
        initPins();

#if USE_ALARM || RUN_BCKLIGHT || RUN_PERF_MEAS || USE_RTC
#if IFXGTM_REG_H == 1
        IfxGtm_enable(&MODULE_GTM);
        // we set the global clock to 100MHz
        IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, 50000000.0f);
        // set CMU0 frequency
        IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, 50000000.0f);
        // enable CMU0 clock
        IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);
        // enable FX clock
        IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);
#endif
#endif /* USE_ALARM || RUN_BCKLIGHT || RUN_PERF_MEAS || USE_RTC */
    }

#if USE_TLF
    unsigned int stmCountBegin;
    if(CPU_WHICH_RUN_TLF == cpuIndex)
    {
        /* TLF init */
        IfxTLF3XX8X_init();
        /* Disable Window Watchdog and ERR pin */
        IfxTLF3XX8X_unprotect_register();
        IfxTLF3XX8X_disable_window_watchdog();
        IfxTLF3XX8X_disable_err_pin_monitor();
        IfxTLF3XX8X_protect_register();
        stmCountBegin = get_STMx_TIM0_value(cpuIndex);     /* it is necessary to get this value to have minimum 60uS delay for switch to normal state */
    }
#endif /* USE_TLF */

#if USE_ASC_SHELL
    if(CPU_WHICH_SERVICE_ASC_SHELL == cpuIndex)
    {
        AsclinShellInterface_init();
    }
#endif /* USE_ASC_SHELL */

#if USE_RTC
    if(CPU_WHICH_SERVICE_RTC == cpuIndex)
    {
        /* Init the RTC */
        rtc_init();
    }
#endif /* USE_RTC */

#if USE_ALARM
    if(CPU_WHICH_SERVICE_BEEPER == cpuIndex)
    {
        /* initialize Acoustic Transducer */
        beeper_init();
    }
#endif /* USE_ALARM */

#if USE_TFT
    if(CPU_WHICH_SERVICE_TFT == cpuIndex)
    {
#if USE_RTC
        /* we stall here if the RTC is not yet ready */
        while (Rtc_InitDone != TRUE);
        /* get the actual time */
        rtc_gettime (&Time2Set);

        /* clear all flags if it is not running */
        if (Time2Set.flags.B.running == 0)
            Time2Set.flags.U = 0x0;

        /* Init TFT-display */
        tft_appl_init(Time2Set.flags.B.running);
#else /* USE_RTC */
        /* Init TFT-display */
        tft_appl_init(0);
#endif /* USE_RTC */

        /* setup our name string */
        conio_ascii_printfxy (DISPLAYSTDOUT0, 1, 0, (const uint8 *)"%s TC3%X%d %s%s with %s...", BOARD_TEXT_TFT,
                SCU_CHIPID.B.CHID, SCU_CHIPID.B.CHPK, (SCU_CHIPID.B.VART == 0x3)?"ADAS ":" ", BOARD_VERSION_TEXT, SW_VERSION_TEXT);

#if RUN_BCKLIGHT
        /* Init the backroundlight */
        background_light_init();
#else /* RUN_BCKLIGHT */
        // without GTM we can only switch on here the background light
        // as long that there is no timer output on the used pin, there is no PMW for dimming possible
        IfxPort_setPinPadDriver(BACKGROUND_LIGHT.port, BACKGROUND_LIGHT.pinIndex, IfxPort_PadDriver_cmosAutomotiveSpeed1);
        IfxPort_setPinHigh(BACKGROUND_LIGHT.port, BACKGROUND_LIGHT.pinIndex);
        IfxPort_setPinModeOutput(BACKGROUND_LIGHT.port, BACKGROUND_LIGHT.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
#endif /* RUN_BCKLIGHT */

#if DRAW_LOGO
        graph_drawInfineonLogo();
#endif /* DRAW_LOGO */

    } /* CPU_WHICH_SERVICE_TFT */
#endif /* USE_TFT */

#if USE_ETH
    if(CPU_WHICH_SERVICE_ETHERNET == cpuIndex)
    {
        /* initialize the TCP/IP stack */
        /* we stall here if the RTC is not yet ready */
        eth_addr_t ethAddr;
#if USE_RTC
        while (Rtc_InitDone != TRUE);
        uint8 uniqueId[6];
        /* first we get the ethAddr from our Serial RTC device */
        rtc_get_unique_id(&uniqueId[0]);
        ethAddr.addr[0] = uniqueId[0];
        ethAddr.addr[1] = uniqueId[1];
        ethAddr.addr[2] = uniqueId[2];
        ethAddr.addr[3] = uniqueId[3];
        ethAddr.addr[4] = uniqueId[4];
        ethAddr.addr[5] = uniqueId[5];
#else /* USE_RTC */
        ethAddr.addr[0] = 0x54;
        ethAddr.addr[1] = 0x10;
        ethAddr.addr[2] = 0xEC;
        ethAddr.addr[3] = 0xB1;
        ethAddr.addr[4] = 0xB0;
        ethAddr.addr[5] = 0xD9;
#endif /* USE_RTC */

#if USE_ASC_SCHELL
#ifdef LWIP_PRINT_VIA_CONSOLE
        /* we stall here if AsclinShell is not yet ready */
        while (AsclinShell_InitDone != TRUE);
#endif
#endif /* USE_ASC_SCHELL */
#if USE_TFT
#ifdef LWIP_PRINT_VIA_DISPLAY
        /* we stall here if the TFT is not yet ready */
        while (tft_ready != TRUE);
#endif
#endif /* USE_TFT */
        /* initialize the lwip stack with unique id */
        Ifx_Lwip_init(ethAddr);
        /* enable ssi and cgi */
        set_CGI_SSI_Handler();
    }
#endif /* USE_ETH */

#if RUN_MEASUREMENT
    if(CPU_WHICH_SERVICE_MEASUREMENT == cpuIndex)
    {
        /* Init voltage, temperature measurement and lifehold LED */
        measurement_init();
    }
#endif /* RUN_MEASUREMENT */

#if RUN_PERF_MEAS
    if(CPU_WHICH_SERVICE_PERF_MEAS == cpuIndex)
    {
        /* Init the performance measurement */
        perf_meas_init();
    }
#endif /* RUN_PERF_MEAS */

#if USE_EVADC
    if(CPU_WHICH_SERVICE_EVADC == cpuIndex)
    {
        // init vadc
        EvadcAutoScan_init();
        // start vadc autoscan
        EvadcAutoScan_run();
    }
#endif /* USE_EVADC */

#if USE_CAN
    if(CPU_WHICH_SERVICE_CAN == cpuIndex)
    {
        /* set the can nodes to 1MBaud and loopback off */
        IfxCan_init(FALSE, 1000000);
    }
#endif /* USE_CAN */

#if USE_TLF
    if(CPU_WHICH_RUN_TLF == cpuIndex)
    {
        /* we must wait 60ï¿½s before we can go to normal state */
        unsigned int   stmCountEnd;
        stmCountEnd = (unsigned int)(IfxScuCcu_getStmFrequency() * 0.00006f);
        while ((unsigned int)(get_STMx_TIM0_value(cpuIndex) - stmCountBegin) < stmCountEnd)
        {
            /* There is no need to check overflow of the STM timer.
             * When counter after overflow subtracted with counter before overflow,
             * the subtraction result will be as expected, as long as both are unsigned 32 bits
             * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
             *     stmCountNow = 0x00000002 (before overflow)
             *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
        }

        /* Switch TLF to normal state */
        IfxTLF3XX8X_goto_normal_state();
    }
#endif /* USE_TLF */

#if RUN_PERF_MEAS
    /* we wait until our CDC is enabled, that we get correct results from Performance Counter */
    while (!(__mfcr(CPU_DBGSR) & 0x1));

    /* prepare idle measurement, we enable here the performance counter */
    IfxCpu_resetAndStartCounters(IfxCpu_CounterMode_normal);

    CpuCcnt * cpuX_ccnt = get_cpuX_ccnt(cpuIndex);
    /* we set the cpu_ccnt difference of this CPU to maximum value */
    cpuX_ccnt->cpu_ccnt_diff_min = 0xFFFFFFFF;
    cpuX_ccnt->cpu_ccnt_last     = 0xFFFFFFFF;

    /* our first 50 loops are to calculate base load (interrupts off and no other calls) */
    cpuX_ccnt->cpu_uiCnt = 50;

    /* Disable the global interrupts of this CPU for the first loops for measurement */
    IfxCpu_disableInterrupts();
#endif /* RUN_PERF_MEAS */

#if USE_SCR
    if(cpuIndex == IfxCpu_ResourceCpu_0)
    {
        /* we check the boot mode of SCR, if this not zero the SCR is running with a program or under control of a debugger */
        if (PMS_PMSWCR4.B.SCRCFG == 0)
        {
            /* we need to copy the program */
            IfxScr_start();
        }
    }
#endif /* USE_SCR */
}

void runAppKitEndlessLoop(IfxCpu_ResourceCpu cpuIndex)
{
#if RUN_PERF_MEAS
    CpuCcnt * cpuX_ccnt = get_cpuX_ccnt(cpuIndex);

    if (!cpuX_ccnt->cpu_uiCnt)
    {
#if USE_ASC_SHELL
        if(CPU_WHICH_SERVICE_ASC_SHELL == cpuIndex)
        {
            // execute shell
            AsclinShellInterface_run();
        }
#endif /* USE_ASC_SHELL */

#if USE_ETH
        if(CPU_WHICH_SERVICE_ETHERNET == cpuIndex)
        {
            Ifx_Lwip_pollTimerFlags();
            Ifx_Lwip_pollReceiveFlags();
        }
#endif /* USE_ETH */
    }
    else
    {
        cpuX_ccnt->cpu_uiCnt--;
        /* Enable the global interrupts of this CPU */
        if (!cpuX_ccnt->cpu_uiCnt) IfxCpu_enableInterrupts();
    }

    cpuX_ccnt->cpu_ccnt_actual = __mfcr(CPU_CCNT);
    if (cpuX_ccnt->cpu_ccnt_actual < cpuX_ccnt->cpu_ccnt_last) cpuX_ccnt->cpu_ccnt_diff = (cpuX_ccnt->cpu_ccnt_actual & ~0x80000000)-cpuX_ccnt->cpu_ccnt_last;
    else cpuX_ccnt->cpu_ccnt_diff = cpuX_ccnt->cpu_ccnt_actual-cpuX_ccnt->cpu_ccnt_last;
    cpuX_ccnt->cpu_ccnt_diff_min = __minu(cpuX_ccnt->cpu_ccnt_diff_min, cpuX_ccnt->cpu_ccnt_diff);
    cpuX_ccnt->cpu_ccnt_last = cpuX_ccnt->cpu_ccnt_actual;
    //Idle_counter for cpu load measurement
    cpuX_ccnt->cpu_idle_counter++;

#else /* RUN_PERF_MEAS */
#if USE_ASC_SHELL
    if(CPU_WHICH_SERVICE_ASC_SHELL == cpuIndex)
    {
        // execute shell
        AsclinShellInterface_run();
    }
#endif /* USE_ASC_SHELL */

#if USE_ETH
    if(CPU_WHICH_SERVICE_ETHERNET == cpuIndex)
    {
        Ifx_Lwip_pollTimerFlags();
        Ifx_Lwip_pollReceiveFlags();
    }
#endif /* USE_ETH */
#endif /* RUN_PERF_MEAS */
}

void runAppKitStmIsr(App_Cpu *lcl_AppCpu, IfxCpu_ResourceCpu cpuIndex)
{
    /* action to do each 1ms */
#if USE_ETH
    if(CPU_WHICH_SERVICE_ETHERNET == cpuIndex)
    {
        Ifx_Lwip_onTimerTick();
    }
#endif /* USE_ETH */

#if USE_TFT
    if(CPU_WHICH_SERVICE_TFT == cpuIndex)
    {
        /* action to do each REFRESH_TFT/5 ms */
        if ((lcl_AppCpu->TickCount_1ms % (REFRESH_TFT/5)) == 0)
        {
            if (conio_driver.dialogmode == SLIDESHOW)
                IfxSrc_setRequest(&TFT_UPDATE_IRQ);    //trigger the tft lib
        }
        /* action to do each REFRESH_TFT ms */
        if ((lcl_AppCpu->TickCount_1ms % REFRESH_TFT) == 0)
        {
            if (conio_driver.dialogmode != SLIDESHOW)
                IfxSrc_setRequest(&TFT_UPDATE_IRQ);    //trigger the tft lib
        }
    }/* CPU_WHICH_SERVICE_TFT */
#endif /* USE_TFT */

    /* action to do each 10ms */
    if ((lcl_AppCpu->TickCount_1ms % 10) == 0)
    {
#if RUN_SLIDESHOW
        if(CPU_WHICH_SERVICE_SDCARD == cpuIndex)
        {
            disk_timerproc(); // we call the disc timer procedure each 10ms to calculate the timeouts
        }
#endif /* RUN_SLIDESHOW */
    }
    /* action to do each 100ms */
    if ((lcl_AppCpu->TickCount_1ms % 100) == 0)
    {
#if DO_RUNTIMEMEAS
        if(CPU_WHICH_SERVICE_TFT == cpuIndex)
        {
            controlmenu.cpuseconds += controlmenu.cpusecondsdelta;
        }
#endif /* DO_RUNTIMEMEAS */
    }

}

#if RUN_PERF_MEAS
CpuCcnt * get_cpuX_ccnt(IfxCpu_ResourceCpu cpuIndex)
{
    CpuCcnt *cpuX_ccnt;

    switch (cpuIndex)
    {
        case IfxCpu_ResourceCpu_0:
            cpuX_ccnt = &cpu0_ccnt;
            break;
#if (IFXCPU_NUM_MODULES > 1)
        case IfxCpu_ResourceCpu_1:
            cpuX_ccnt = &cpu1_ccnt;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 2)
        case IfxCpu_ResourceCpu_2:
            cpuX_ccnt = &cpu2_ccnt;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 3)
        case IfxCpu_ResourceCpu_3:
            cpuX_ccnt = &cpu3_ccnt;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 4)
        case IfxCpu_ResourceCpu_4:
            cpuX_ccnt = &cpu4_ccnt;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 5)
        case IfxCpu_ResourceCpu_5:
            cpuX_ccnt = &cpu5_ccnt;
            break;
#endif
        default: while (1) {}; break;
    }

    return cpuX_ccnt;
}
#endif /* RUN_PERF_MEAS */

#if USE_TLF
unsigned int get_STMx_TIM0_value(IfxCpu_ResourceCpu cpuIndex)
{
    unsigned int stmCount = 0;
    switch (cpuIndex)
    {
        case IfxCpu_ResourceCpu_0:
            stmCount = STM0_TIM0.U;
            break;
#if (IFXCPU_NUM_MODULES > 1)
        case IfxCpu_ResourceCpu_1:
            stmCount = STM1_TIM0.U;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 2)
        case IfxCpu_ResourceCpu_2:
            stmCount = STM2_TIM0.U;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 3)
        case IfxCpu_ResourceCpu_3:
            stmCount = STM3_TIM0.U;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 4)
        case IfxCpu_ResourceCpu_4:
            stmCount = STM3_TIM0.U;
            break;
#endif
#if (IFXCPU_NUM_MODULES > 5)
        case IfxCpu_ResourceCpu_5:
            stmCount = STM4_TIM0.U;
            break;
#endif
        default: while (1) {}; break;
    }
    return stmCount;
}
#endif /* USE_TLF */
