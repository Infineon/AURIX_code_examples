/**********************************************************************************************************************
 * \file GTM_ATOM_Dual_Active_Bridge_PWM.h.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "GTM_ATOM_Dual_Active_Bridge_PWM.h"
#include "Ifx_Types.h"
#include "IfxGtm_Pwm.h"
#include "IfxPort.h"
#include "IfxPort_Pinmap.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define NUM_OF_CHANNELS      (5u)                                     /* Number of PWM complementary pairs           */
#define PWM_FREQUENCY        (100.0e3)                                /* PWM frequency in [Hz]                       */
#define DEAD_TIME            (0.5e-6f)                                /* Default Dead Time for High and Low Switches */
#define ISR_PRIORITY_ATOM    (20u)                                    /* Interrupt priority number                   */
/* Master Channel */
#define MASTER_CHANNEL       &IfxGtm_ATOM2_0_TOUT32_P33_10_OUT        /* Pin which will be driven by the PWM, P33.10 */
/* High-voltage side(Primary) */
#define HVLV_PRI_PWM_T1      &IfxGtm_ATOM2_1_TOUT27_P33_5_OUT         /* Pin which will be driven by the PWM, P33.5  */
#define HVLV_PRI_PWM_T2      &IfxGtm_ATOM2_1N_TOUT34_P33_12_OUT       /* Pin which will be driven by the PWM, P33.12 */
#define HVLV_PRI_PWM_T3      &IfxGtm_ATOM2_2_TOUT28_P33_6_OUT         /* Pin which will be driven by the PWM, P33.6  */
#define HVLV_PRI_PWM_T4      &IfxGtm_ATOM2_2N_TOUT35_P33_13_OUT       /* Pin which will be driven by the PWM, P33.13 */
/* Low-voltage side(Secondary) */
#define HVLV_SEC_PWM_T1      &IfxGtm_ATOM2_3_TOUT21_P00_12_OUT        /* Pin which will be driven by the PWM, P00.12 */
#define HVLV_SEC_PWM_T2      &IfxGtm_ATOM2_3N_TOUT33_P33_11_OUT       /* Pin which will be driven by the PWM, P33.11 */
#define HVLV_SEC_PWM_T3      &IfxGtm_ATOM2_4_TOUT30_P33_8_OUT         /* Pin which will be driven by the PWM, P33.8  */
#define HVLV_SEC_PWM_T4      &IfxGtm_ATOM2_4N_TOUT29_P33_7_OUT        /* Pin which will be driven by the PWM, P33.7  */

#define INIT_PHASE_SHIFT_RAD (IFX_PI/4)                               /* Initial phase shift in radians              */

/*********************************************************************************************************************/
/*---------------------------------------------------Enumerations----------------------------------------------------*/
/*********************************************************************************************************************/

/* Direction of Charging */
typedef enum
{
    IfxPrim2Sec = 0x0u,         /* Uses Primary Side as Source                                                       */
    IfxSec2Prim = 0x1u          /* Uses Secondary Side as Source                                                     */
} IfxChargingDirection;

/* Runtime States for updating */
typedef enum
{
    IfxPaused = 0x0u,   /* Update mechanism is paused, one can modify corresponding shift ratio                      */
    IfxRun    = 0x1u    /* Updating State                                                                            */
} IfxRT_State;

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* Runtime Handle */
typedef struct
{
    IfxGtm_Pwm              pwm;                            /* PWM Driver handle                                     */
    IfxGtm_Pwm_Channel      channels[NUM_OF_CHANNELS];      /* Array containing channel data after configuration     */
    float32                 dutyCycles[NUM_OF_CHANNELS];    /* Duty Cycle values to hold                             */
    float32                 phases[NUM_OF_CHANNELS];        /* PhaseShift values to hold                             */
    IfxGtm_Pwm_DeadTime     deadTimes[NUM_OF_CHANNELS];     /* PhaseShift values to hold                             */
    IfxChargingDirection    chargingDirection;              /* Charging Direction                                    */
    IfxRT_State             rtState;                        /* Flag to pause runtime update                          */
    /* Single Phase Shift Modulation(SPS) Phase Shift Ratio, Range: -IFX_PI <= spsRad <= IFX_PI                      */
    float32                  spsRad;
} GtmAtomDAB;

IFX_STATIC GtmAtomDAB g_gtmAtomDAB;

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/
static void dutyEventFunction(void *data);                  /* Callback function for ATOM CHO for CCU1 Event         */
void updateGtmAtomDABPhase(float32 spsRadIn);               /* Function to set the duty cycle of the PWM             */

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define the Interrupt Service Routine. */
IFX_INTERRUPT(interruptGtmAtom, 0, ISR_PRIORITY_ATOM);

/* Interrupt Service Routine of the ATOM CH0 */
void interruptGtmAtom(void)
{
    dutyEventFunction(NULL_PTR);
}

/* Callback function for ATOM CHO for CCU1 Event */
void dutyEventFunction(void *data)
{
    updateGtmAtomDABPhase(g_gtmAtomDAB.spsRad);
}

/* This function initializes the ATOM */
void initGtmAtomDAB(void)
{
    IfxGtm_Pwm_Config config;                                 /* Main PWM configuration structure                    */
    IfxGtm_Pwm_ChannelConfig channelConfig[NUM_OF_CHANNELS];  /* Array containing configuration for PWM Channels     */
    IfxGtm_Pwm_DtmConfig dtmConfig[NUM_OF_CHANNELS];          /* Array Containing Dead Time Values for PWM Channels  */
    IfxGtm_Pwm_OutputConfig output[NUM_OF_CHANNELS];          /* Array Containing configuration of Output Pins       */
    IfxGtm_Pwm_InterruptConfig interruptConfig;               /* Interrupt Configuration of Master Channel           */

    /* Default values for Single Phase Shift Modulation Strategy */
    g_gtmAtomDAB.spsRad            = INIT_PHASE_SHIFT_RAD;    /* */
    g_gtmAtomDAB.chargingDirection = IfxPrim2Sec;             /* Selected Charging Direction */
    g_gtmAtomDAB.rtState           = IfxRun;                  /* Allow runtime update        */

    /* Configuration of PWM variables
     * Neither application (in most of the cases) nor the PWM driver need configuration variables post initialization.
     * Hence it is recommended to define such variables within the function (STACK).
     * Alternatively such structures could also be initialized (element-wise) as constant (in ROM)
     */

    /* 1. Configuration structure initialization
     * If the configuration structure is located in the RAM, the initConfig API would be handy to initialize the
     * elements to their default values
     */
    IfxGtm_Pwm_initConfig(&config, &MODULE_GTM);

    /* 2. Output configuration
     * Output configurations are optional.
     */
    /* CH0 configurations */
    output[0].pin                   = (IfxGtm_Pwm_ToutMap*)MASTER_CHANNEL;      /* Master Channel                    */
    output[0].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[0].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[0].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH1 configurations */
    output[1].pin                   = (IfxGtm_Pwm_ToutMap*)HVLV_PRI_PWM_T1;     /* HVLV Primary PWM High-side (T1)   */
    output[1].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVLV_PRI_PWM_T2;     /* HVLV Primary PWM Low-side (T1)    */
    output[1].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[1].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[1].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[1].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH2 configurations */
    output[2].pin                   = (IfxGtm_Pwm_ToutMap*)HVLV_PRI_PWM_T3;     /* HVLV Secondary PWM High-side (T3) */
    output[2].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVLV_PRI_PWM_T4;     /* HVLV Secondary PWM Low-side (T4)  */
    output[2].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[2].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[2].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[2].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH3 configurations */
    output[3].pin                   = (IfxGtm_Pwm_ToutMap*)HVLV_SEC_PWM_T1;     /* HVLV Secondary PWM High-side (T1) */
    output[3].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVLV_SEC_PWM_T2;     /* HVLV Secondary PWM Low-side (T2)  */
    output[3].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[3].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[3].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[3].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH4 configurations */
    output[4].pin                   = (IfxGtm_Pwm_ToutMap*)HVLV_SEC_PWM_T3;     /* HVLV Secondary PWM High-side (T3) */
    output[4].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVLV_SEC_PWM_T4;     /* HVLV Secondary PWM Low-side (T4)  */
    output[4].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[4].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[4].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[4].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */


    /* 3. Dead-time configuration */
    dtmConfig[0].deadTime.rising    = 0.0f;                   /* Master Channel                                      */
    dtmConfig[0].deadTime.falling   = 0.0f;                   /* Master Channel                                      */

    dtmConfig[1].deadTime.rising    = DEAD_TIME;              /* HVLV Primary Rising Dead time in seconds  (T1,T2)   */
    dtmConfig[1].deadTime.falling   = DEAD_TIME;              /* HVLV Primary Falling Dead time in seconds (T1,T2)   */

    dtmConfig[2].deadTime.rising    = DEAD_TIME;              /* HVLV Secondary Rising Dead time in seconds (T3,T4)  */
    dtmConfig[2].deadTime.falling   = DEAD_TIME;              /* HVLV Secondary Falling Dead time in seconds (T3,42) */

    dtmConfig[3].deadTime.rising    = DEAD_TIME;              /* HVLV Secondary Rising Dead time in seconds  (T1,T2) */
    dtmConfig[3].deadTime.falling   = DEAD_TIME;              /* HVLV Secondary Falling Dead time in seconds (T1,T2) */

    dtmConfig[4].deadTime.rising    = DEAD_TIME;              /* HVLV Secondary Rising Dead time in seconds  (T3,T4) */
    dtmConfig[4].deadTime.falling   = DEAD_TIME;              /* HVLV Secondary Falling Dead time in seconds (T3,T4) */

    /* 4. Interrupt configuration */
    interruptConfig.mode          = IfxGtm_IrqMode_pulseNotify;    /* IRQ mode of interrupt                          */
    interruptConfig.isrProvider   = IfxSrc_Tos_cpu0;               /* Type of Service                                */
    interruptConfig.priority      = ISR_PRIORITY_ATOM;             /* Interrupt priority                             */
    interruptConfig.periodEvent   = NULL_PTR;                      /* Not used                                       */
    interruptConfig.dutyEvent     = &dutyEventFunction;            /* Callback function                              */

    /*5. Channel configuration */
    /* Base channel - CH0 Master */
    channelConfig[0].timerCh      = IfxGtm_Pwm_SubModule_Ch_0; /* Atom channel index to be used for base channel     */
    channelConfig[0].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi);
                                                                * only for edge aligned sync channels)               */
    channelConfig[0].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[0].dtm          = &dtmConfig[0];             /* Attach Dead time configuration for this channel    */
    channelConfig[0].output       = &output[0];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[0].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[0].interrupt    = &interruptConfig;          /* Attach Interrupt configuration for this channel    */

    /*Sync channel CH1 configuration(HV_1) */
    channelConfig[1].timerCh      = IfxGtm_Pwm_SubModule_Ch_1; /* Atom channel index to be used for sync channel     */
    channelConfig[1].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                * only for edge aligned sync channels)               */
    channelConfig[1].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[1].dtm          = &dtmConfig[1];             /* Attach Dead time configuration for this channel    */
    channelConfig[1].output       = &output[1];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[1].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[1].interrupt    = NULL_PTR;                  /* Interrupt configuration for this channel           */

    /*Sync channel CH2 configuration(HV_2) */
    channelConfig[2].timerCh      = IfxGtm_Pwm_SubModule_Ch_2; /* Atom channel index to be used for sync channel     */
    channelConfig[2].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                * only for edge aligned sync channels)               */
    channelConfig[2].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[2].dtm          = &dtmConfig[2];             /* Attach Dead time configuration for this channel    */
    channelConfig[2].output       = &output[2];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[2].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[2].interrupt    = NULL_PTR;                  /* Interrupt configuration for this channel           */

    /*Sync channel CH3 configuration(LV_1) */
    channelConfig[3].timerCh      = IfxGtm_Pwm_SubModule_Ch_3; /* Atom channel index to be used for sync channel     */
    channelConfig[3].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                * only for edge aligned sync channels)               */
    channelConfig[3].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[3].dtm          = &dtmConfig[3];             /* Attach Dead time configuration for this channel    */
    channelConfig[3].output       = &output[3];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[3].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[3].interrupt    = NULL_PTR;                  /* Interrupt configuration for this channel           */

    /*Sync channel CH4 configuration(LV_2) */
    channelConfig[4].timerCh      = IfxGtm_Pwm_SubModule_Ch_4; /* Atom channel index to be used for sync channel     */
    channelConfig[4].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                * only for edge aligned sync channels)               */
    channelConfig[4].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[4].dtm          = &dtmConfig[4];             /* Attach Dead time configuration for this channel    */
    channelConfig[4].output       = &output[4];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[4].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[4].interrupt    = NULL_PTR;                  /* Interrupt configuration for this channel           */

    /* 6. Overall configurations */
    config.cluster                = IfxGtm_Cluster_2;                  /* Cluster                                    */
    config.subModule              = IfxGtm_Pwm_SubModule_atom;         /* Sub module                                 */
    config.alignment              = IfxGtm_Pwm_Alignment_edge;         /* Alignment                                  */
    config.syncStart              = TRUE;                              /* Start all channels after init              */
    config.numChannels            = NUM_OF_CHANNELS;                   /* Number of channels configured              */
    config.channels               = &channelConfig[0];                 /* Attach Channel configuration               */
    config.frequency              = PWM_FREQUENCY;                     /* PWM frequency                              */
    config.clockSource.atom       = IfxGtm_Cmu_Clk_0;                  /* Clock source for ATOM                      */
    config.dtmClockSource         = IfxGtm_Dtm_ClockSource_cmuClock0;  /* Clock source for DTM                       */
    config.syncUpdateEnabled      = TRUE;                              /* TRUE: Update compare registers from shadow
                                                                        * at the end of period                       */
    /* 7. Call the init function */
    if(!IfxGtm_isEnabled(&MODULE_GTM))
    {
        float32 frequency;
        /* Enable GTM, it is necessary if the GTM is not initialized earlier */
        IfxGtm_enable(&MODULE_GTM);
        frequency = IfxGtm_Cmu_getModuleFrequency(&MODULE_GTM);
        /* Set the global clock frequency to the max */
        IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, frequency);
        /* Set the CMU CLK0 */
        IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, frequency);
        /* Enable the FXU clock */
        IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);
    }
    /* Initialize the GTM */
    IfxGtm_Pwm_init(&g_gtmAtomDAB.pwm, &g_gtmAtomDAB.channels[0], &config);

    /* 8. Store the current duty values, dead-times and phases for runtime calls */
    g_gtmAtomDAB.dutyCycles[0]= channelConfig[0].duty;
    g_gtmAtomDAB.dutyCycles[1]= channelConfig[1].duty;
    g_gtmAtomDAB.dutyCycles[2]= channelConfig[2].duty;
    g_gtmAtomDAB.dutyCycles[3]= channelConfig[3].duty;
    g_gtmAtomDAB.dutyCycles[4]= channelConfig[4].duty;
    g_gtmAtomDAB.deadTimes[0]= channelConfig[0].dtm->deadTime;
    g_gtmAtomDAB.deadTimes[1]= channelConfig[1].dtm->deadTime;
    g_gtmAtomDAB.deadTimes[2]= channelConfig[2].dtm->deadTime;
    g_gtmAtomDAB.deadTimes[3]= channelConfig[3].dtm->deadTime;
    g_gtmAtomDAB.deadTimes[4]= channelConfig[4].dtm->deadTime;
    g_gtmAtomDAB.phases[0]= channelConfig[0].phase;
    g_gtmAtomDAB.phases[1]= channelConfig[1].phase;
    g_gtmAtomDAB.phases[2]= channelConfig[2].phase;
    g_gtmAtomDAB.phases[3]= channelConfig[3].phase;
    g_gtmAtomDAB.phases[4]= channelConfig[4].phase;
}

/* This function sets the phases of the PWM channels */
void updateGtmAtomDABPhase(float32 spsRadIn)
{
    float32 spsRad;
    float32 spsRadAbs;

    spsRad  = spsRadIn;

    if(g_gtmAtomDAB.rtState == IfxRun)
    {
        /* Check the admissible range of the parameter spsDIn*/
        if(spsRad < (-IFX_PI))
        {
            spsRad = -IFX_PI;
        }
        if (spsRad > IFX_PI)
        {
            spsRad = IFX_PI;
        }
        /* Determine charging direction */
        if(spsRad >= 0)
        {
            g_gtmAtomDAB.chargingDirection = IfxPrim2Sec;
        }

        if(spsRad < 0)
        {
            g_gtmAtomDAB.chargingDirection = IfxSec2Prim;
        }

        /* Calculate phases */
        spsRadAbs = __absf(spsRad);
        if(g_gtmAtomDAB.chargingDirection == IfxPrim2Sec)         /* Charge the Secondary Bridge from Primary Bridge */
        {
            g_gtmAtomDAB.phases[1] = 0.0f;                        /* Phase of HVLV_PRI_PWM_T1, HVLV_PRI_PWM_T2       */
            g_gtmAtomDAB.phases[2] = IFX_PI;                      /* Phase of HVLV_PRI_PWM_T3, HVLV_PRI_PWM_T4       */
            g_gtmAtomDAB.phases[3] = spsRadAbs;                   /* Phase of HVLV_SEC_PWM_T1, HVLV_SEC_PWM_T2       */
            g_gtmAtomDAB.phases[4] = spsRadAbs + IFX_PI;          /* Phase of HVLV_SEC_PWM_T3, HVLV_SEC_PWM_T4       */
        }
        else                                                      /* Charge the Primary Bridge from Secondary Bridge */
        {
            g_gtmAtomDAB.phases[1] = spsRadAbs;                   /* Phase of HVLV_PRI_PWM_T1, HVLV_PRI_PWM_T2       */
            g_gtmAtomDAB.phases[2] = spsRadAbs + IFX_PI;          /* Phase of HVLV_PRI_PWM_T3, HVLV_PRI_PWM_T4       */
            g_gtmAtomDAB.phases[3] = 0.0f;                        /* Phase of HVLV_SEC_PWM_T1, HVLV_SEC_PWM_T2       */
            g_gtmAtomDAB.phases[4] = IFX_PI;                      /* Phase of HVLV_SEC_PWM_T3, HVLV_SEC_PWM_T4       */
        }
    }
    /* Update the iLLD Framework */
    IfxGtm_Pwm_updateChannelsPhase(&g_gtmAtomDAB.pwm, (float32*)&g_gtmAtomDAB.phases[0]);
}
