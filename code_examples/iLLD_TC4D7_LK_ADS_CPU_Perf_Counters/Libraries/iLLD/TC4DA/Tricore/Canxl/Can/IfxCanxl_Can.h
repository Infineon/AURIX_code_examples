/**
 * \file IfxCanxl_Can.h
 * \brief CANXL CAN details
 * \ingroup IfxLld_Canxl
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Canxl_Usage How to use the CANXL Driver?
 * \ingroup IfxLld_Canxl
 *
 * \section IfxLld_Canxl_Overview Overview:
 * This driver is used for tranmission and reception of CAN messages using the Controller Area Network XL interface (CANXL) module on Aurix microcontrollers.\n\n
 *
 * Frame Formats supported:
 *  -# Classical CAN
 *  -# CAN FD
 *  -# CAN XL
 *
 * Functionalities provided:
 *  -# Module initialization
 *  -# Node initialization
 *      -# Operation mode (IfxCanxl_Node_OperationMode)
 *      -# Baud rate calculation
 *      -# TX/RX FIFO and TX priority configuration
 *      -# Time stamp configuration
 *      -# Interrupt
 *      -# Pin configuration
 *      -# Filter configuration
 *  -# Starting and stopping of node
 *  -# Sending and reception of message
 *
 * \section IfxLld_Canxl_Code Coding example
 * \subsection IfxLld_Canxl_Step1 STEP 1 Preparation
 *
 *  \code
 *  //=====================================
 *  // 1. Include Interface File
 *  //=====================================
 *
 *  #include "Canxl/Can/IfxCanxl_Can.h"
 *
 *  //=====================================
 *  // 2. Instantiate variables
 *  //=====================================
 *  IfxCanxl_Can_Config     moduleConfig;
 *  IfxCanxl_Can            moduleHandle;
 *  IfxCanxl_Can_NodeConfig nodeConfig;
 *  IfxCanxl_Can_Node       nodeHandle;
 *
 *  //=====================================
 *  // 3. Set desired CANXL module frequency
 *  //=====================================
 *  IfxClock_setCanXLFrequency(160000000);
 *  IfxClock_setCanXLhFrequency(160000000);
 *  \endcode
 *
 * \subsection IfxLld_Canxl_Step2 STEP 2 Initialize module
 * Following steps are performed in this step:
 *  -# CANXL module clock is turned on
 *  -# Node clock is turned on depending on configuration
 *
 *  \code
 *  IfxCanxl_Can_initModuleConfig(&moduleConfig, &MODULE_CANXL0);
 *
 *  //=====================================
 *  // [Optional] Perform manual module configuration
 *  //=====================================
 *  moduleConfig.enableNode[0] = TRUE;		// Enable node 0
 *  moduleConfig.enableNode[1] = FALSE;		// Disable node 1
 *  moduleConfig.enableNode[2] = FALSE;		// Disable node 2
 *  moduleConfig.enableNode[3] = FALSE;		// Disable node 3
 *
 *  IfxCanxl_Can_initModule(&moduleHandle, &moduleConfig);
 *  \endcode
 *
 * \subsection IfxLld_Canxl_Step3 STEP 3 Initialize node
 * In this step, we will give the address of TX and RX FIFO Queue descriptors and use default configuration for everything else.
 *  \code
 *  //=====================================
 *  // 1. Initialize the config structure for node 0
 *  //=====================================
 *  IfxCanxl_Can_initNodeConfig(&nodeConfig, IfxCanxl_NodeId_0, &moduleHandle);
 *
 *  //=====================================
 *  // 2. Perform manual configuration for tx/rx queue
 *  //=====================================
 *  // Descriptor configuration. Following address can be according to user choice
 *  nodeConfig.txFifoQueue[0].descriptorStartAddress    = 0xB0400000;
 *  nodeConfig.rxFifoQueue[0].descriptorStartAddress    = 0xB0410000;
 *
 *  //=====================================
 *  // 3. Initialize the node
 *  //=====================================
 *  status = IfxCanxl_Can_initNode(&nodeHandle, &nodeConfig);
 *  \endcode
 *
 * <b>[OPTIONAL: ADVANCED]</b> If you want more control of node initialization, node configuration can be changed further.\n
 * See IfxCanxl_Can_NodeConfig structure description for more details.
 *  \code
 *  // Memory organization of RX Data containers
 *  nodeConfig.rxDataContainerMode	= IfxCanxl_RxDataContainer_normal;
 *
 *  // Maximum number of TX message re-transmissions
 *  nodeConfig.maxRetransmissions   = IfxCanxl_MaxMsgRetransmissions_unlimited;
 *
 *  // Unique identifier for XCAN instance
 *  nodeConfig.instanceNumber		= 0u;
 *
 *  // Memory addresses of various RAM sections in CANXL's SRAM. All values must be 32 bit aligned
 *  nodeConfig.ramAddresses.rxFilterStartAddress        = 0;
 *  nodeConfig.ramAddresses.txFifoQueueDescAddress      = 0x100;
 *  nodeConfig.ramAddresses.txPriorityQueueDescAddress  = 0x1000;
 *
 *  // Node should support all frame formats
 *  nodeConfig.mode                         = IfxCanxl_Node_OperationMode_classicalAndFdAndXl;
 *
 *  // Max pending read and write transactions on AXI bridge
 *  nodeConfig.axiParams.read               = IfxCanxl_MaxAxiTransactions_1;
 *  nodeConfig.axiParams.write              = IfxCanxl_MaxAxiTransactions_1;
 *
 *  // Change baud rate to some other value. Example: 8 Mbps
 *  nodeConfig.baudrate.xl.calc.baudrate    = 8000000u;
 *  nodeConfig.baudrate.fd.calc.baudrate    = 8000000u;
 *
 *  // PWM encoder configuration for XL frames
 *  nodeConfig.pwmEncoder.shortPhase        = 0u;
 *  nodeConfig.pwmEncoder.longPhase         = 0u;
 *  nodeConfig.pwmEncoder.offset            = 0u;
 *  nodeConfig.pwmEncoder.enable            = FALSE;
 *
 *  // TX FIFO Queue configuration
 *  nodeConfig.txFifoQueue[0].descriptorStartAddress    = 0xB0400000;   // Start address of TX FIFO Queue link list descriptor in system memory. Must be word aligned
 *  nodeConfig.txFifoQueue[0].numDescriptors            = 4;			// Maximum number of TX descriptors in the TX FIFO Queue link list descriptors. Max value: 1024
 *  nodeConfig.txFifoQueue[0].enable                    = TRUE;			// Configure and enable queue 0
 *  nodeConfig.txFifoQueue[1].enable                    = FALSE;		// DON'T configure queue 1
 *
 *  // TX Priority Queue configuration
 *  nodeConfig.txPriorityQueue.descriptorStartAddress   = 0xB0430000;   // Start address of TX Priority Queue link list descriptor in system memory. Must be word aligned
 *  nodeConfig.txPriorityQueue.numSlots                 = 0x2u;			// Number of Priority Queue slots to be activated. Max value: 32
 *  nodeConfig.txPriorityQueue.enable                   = TRUE;			// TRUE: Configure and enable queue. FALSE: DON'T configure queue
 *
 *  // RX FIFO Queue configuration
 *  nodeConfig.rxFifoQueue[0].descriptorStartAddress    = 0xB0410000;	// Start address of RX FIFO Queue link list descriptor in system memory. MUST be word aligned
 *  nodeConfig.rxFifoQueue[0].numDescriptors            = 4;			// Maximum number of RX descriptors in the RX FIFO Queue link list descriptors. Max value: 1024
 *  nodeConfig.rxFifoQueue[0].dataContainerSize         = 65u;			// Allocated size = dataContainerSize * 32bytes. Normal mode: Size per descriptor. Continuous: Size of single container
 *  nodeConfig.rxFifoQueue[0].dataContainerStartAddress = 0x0u;			// ONLY valid for continuous mode. Defines the Data Container Start Address in system memory. MUST be word aligned
 *  nodeConfig.rxFifoQueue[0].enable                    = TRUE;			// Configure and enable queue 0
 *  nodeConfig.rxFifoQueue[1].enable                    = FALSE;		// DON'T configure queue 1
 *
 *  // Time stamp configuration
 *  nodeConfig.timeStamp.clockSource                    = IfxCanxl_TimebaseClockSource_canInternal;     // Select clock source for timebase generation
 *  nodeConfig.timeStamp.prescaler                      = IfxCanxl_TimebaseClockPrescaler_divBy0;       // Select clock prescaler for timebase generation
 *  nodeConfig.timeStamp.capturePosition                = IfxCanxl_TimeStampPosition_startOfFrame;      // Select Capturing Position
 *  nodeConfig.timeStamp.useNode0Timebase               = FALSE;    // TRUE: Synchronize Node i (i>0) timebase with Node 0. FALSE: Use clock source and prescaler to generate timebase
 *  nodeConfig.timeStamp.enable                         = TRUE;     // Enable Timestamping
 *
 *  // Interrupt configuration
 *  nodeConfig.interrupt.functional.enableMask          = 0xFFu;            // Interrupt enable mask
 *  nodeConfig.interrupt.functional.priority            = 0x1u;             // Priority of the interrupt
 *  nodeConfig.interrupt.functional.typeOfService       = IfxSrc_Tos_cpu0;  // Type of Service
 *  nodeConfig.interrupt.functional.vmId                = IfxSrc_VmId_0;    // Virtual Machine Number
 *  nodeConfig.interrupt.error.enableMask               = 0x0u;				// Interrupt enable mask
 *  nodeConfig.interrupt.safety.enableMask              = 0x0u;				// Interrupt enable mask
 *
 *  // MTI configuration
 *  nodeConfig.mti.enableMask                           = 0x0u;				// Interrupt enable mask
 *
 *  // Pin configuration
 *  IfxCanxl_Can_Pins pins;
 *  pins.rxPin          = &IfxCanxl_RXD00A_P14_8_IN;
 *  pins.rxPinMode      = IfxPort_InputMode_pullUp;
 *  pins.txPin          = &IfxCanxl_TXD00_P01_4_OUT;
 *  pins.txPinMode      = IfxPort_OutputMode_pushPull;
 *  pins.padDriver      = IfxPort_PadDriver_cmosAutomotiveSpeed1;
 *  // Attach pins
 *  nodeConfig.pins     = &pins;
 *
 *  \endcode
 *
 * Now, the node is ready to be started.
 *
 * \subsection IfxLld_Canxl_Step4 STEP 4 Start Node
 *  \code
 *  // Start Node in normal or loopback mode
 *  IfxCanxl_Can_startNode(&nodeHandle, IfxCanxl_Can_StartMode_normal);
 *
 *  // Wait for bus integration
 *  while(IfxCanxl_Node_isBusIntegrationDone(nodeSFR) == FALSE)
 *  {}
 *  \endcode
 *
 * \subsection IfxLld_Canxl_Step5 STEP 5 Start RX Queue
 * Start RX Queue for message reception
 *
 *  \code
 *  //=====================================
 *  // 1. Configure RX descriptors
 *  //=====================================
 *  IfxCanxl_Can_RxDescrConfig  descConfig;
 *  IfxCanxl_RxDescr            *descriptor;
 *
 *  for(int idx = 0; idx < 4; ++idx)
 *  {
 *      descConfig.dataContainerStartAddress    = 0xB0430000 + (0x1000 * idx);	// Configure where received data will be stored
 *      descConfig.rollingCounter               = idx;							// Configure rolling counter
 *
 *      descriptor = &nodeHandle.rxFifoQueue[0].descriptor[idx];				// Get pointer to descriptor
 *
 *      IfxCanxl_Can_configureRxDescriptor(&nodeHandle, descriptor, &descConfig, (uint8)IfxCanxl_RxFifoQueue_0);
 *  }
 *
 *
 *  //=====================================
 *  // 2. Start RX Queue 0
 *  //=====================================
 *  IfxCanxl_Node_startRxFifoQueue(nodeSFR, IfxCanxl_RxFifoQueue_0);
 *  \endcode
 *
 * \subsection IfxLld_Canxl_Step6 STEP 6 Send Message
 * Now we are ready to send and receive messages. Below example is for sending message through FIFO queue. Similar steps can be used for priority queue.\n
 *
 *  \code
 *  //=====================================
 *  // 1. Prepare message
 *  //=====================================
 *  IfxCanxl_Can_TxMessage  txMsg;
 *
 *  txMsg.dataPtr                            = (uint32 *)0xB0410000;	// Pointer to address which contains payload
 *  txMsg.triggerInterrupt                   = TRUE;					// Trigger interrupt once message is sent
 *  txMsg.wrapQueue                          = TRUE;					// Wrap Queue
 *  txMsg.endQueue                           = TRUE;					// End queue after message transmission
 *  txMsg.frameMode                          = IfxCanxl_FrameMode_xl;	// Frame Format of message
 *  // Frame specific setting
 *  txMsg.frame.xl.messageId                 = 0x12u;					// Message ID
 *  txMsg.frame.xl.acceptanceField           = 0x1u;					// Acceptance Field
 *  txMsg.frame.xl.dataLengthCode            = 63u;						// DLC
 *  txMsg.frame.xl.sduType                   = 0x0u;					// SDU Type
 *  txMsg.frame.xl.virtualCanId              = 0x0u;					// Vritual CAN ID
 *  txMsg.frame.xl.faultInjectionRequest     = FALSE;					// Fault injection request
 *
 *  //=====================================
 *  // 2. Send message using Queue 0 of TX FIFO Queue
 *  //=====================================
 *  status = IfxCanxl_Can_sendMessage(&nodeHandle, &txMsg, IfxCanxl_TxQueueType_fifo, (uint8)IfxCanxl_TxFifoQueue_0);
 *
 *  //=====================================
 *  // [OPTIONAL] Check tranmission status
 *  //=====================================
 *
 *  // Wait for transmission interrupt
 *  while(IfxCanxl_Node_getTxFifoInterruptStatus(nodeSFR, queueIndex) == FALSE)
 *  {}
 *
 *  // Clear status after interrupt received
 *  IfxCanxl_Node_clearTxFifoInterruptStatus(nodeSFR, queueIndex);
 *
 *  // Check whether message was sent or descriptor was unvalid and clear corresponding status
 *  if (IfxCanxl_Node_getTxFifoSentStatus(nodeSFR, queueIndex) == TRUE)
 *  {
 *      IfxCanxl_Node_clearTxFifoSentStatus(nodeSFR, queueIndex);
 *  }
 *  else
 *  {
 *      IfxCanxl_Node_clearTxFifoUnvalidStatus(nodeSFR, queueIndex);
 *  }
 *  \endcode
 *
 * \subsection IfxLld_Canxl_Step7 STEP 7 Read Message
 * Message reception status can be polled and thereafter message content can be read.\n
 *
 *  \code
 *  //=====================================
 *  // 1. Poll the descriptor for reception status
 *  //=====================================
 *  while(IfxCanxl_Can_isRxMessageAvailable(&nodeHandle, 0) == FALSE)
 *  {}
 *
 *  //=====================================
 *  // 2. Read message once descriptor is used
 *  //=====================================
 *  IfxCanxl_Can_RxMessage  rxMsg;
 *  // Provide pointer where data needs to be read
 *  rxMsg.dataPtr = &rxData[0];
 *  // Read latest message
 *  status = IfxCanxl_Can_readMessage(&nodeHandle, &rxMsg, IfxCanxl_RxFifoQueue_0);
 *
 *  \endcode
 * After calling the API, rxMsg provides timestamp, header, data size, frame type, message status, and data of CAN packet received.
 *
 * \defgroup IfxLld_Canxl_Can CAN
 * \ingroup IfxLld_Canxl
 * \defgroup IfxLld_Canxl_Can_Enum Enumerations
 * \ingroup IfxLld_Canxl_Can
 * \defgroup IfxLld_Canxl_Can_Structures Data Structures
 * \ingroup IfxLld_Canxl_Can
 * \defgroup IfxLld_Canxl_Can_Functions Interface Functions
 * \ingroup IfxLld_Canxl_Can
 */

#ifndef IFXCANXL_CAN_H
#define IFXCANXL_CAN_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Canxl/Std/IfxCanxl.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro that calculates rolling counter of descriptor according to its position compared to first descriptor
 * First descriptor must always have 0 as rolling counter and subsequent ones must be incremented by 1
 * Difference is calculated and divided by 32 which is the size in bytes of one TX descriptor
 */
#define IFXCANXL_CAN_CALC_TX_RC(startAddress, currentAddress) (uint8)((((uint32)(currentAddress) - (startAddress)) >> 5u) & 0x1FU)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Canxl_Can_Enum
 * \{ */
/** \brief Start mode of XCAN node
 */
typedef enum
{
    IfxCanxl_Can_StartMode_normal       = 0, /**< \brief Start in normal mode */
    IfxCanxl_Can_StartMode_testLoopback = 1  /**< \brief Start in loopback mode */
} IfxCanxl_Can_StartMode;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Canxl_Can_Structures
 * \{ */
/** \brief <  Classic CAN Frame configurations
 */
typedef struct
{
    uint32                  messageId;                   /**< \brief Message ID of CAN frame */
    IfxCanxl_DataLengthCode dataLengthCode;              /**< \brief Data length code in CAN Classic encoding format */
    boolean                 extendedId;                  /**< \brief XTD, Extended Identifier length (enable / disable) */
    boolean                 remoteTransmitRequest;       /**< \brief RTR, Remote Transmit Request (enable / disable) */
    boolean                 faultInjectionRequest;       /**< \brief Fault Injection Request (enable / disable) */
} IfxCanxl_Can_ClassicTxMsgConfig;

/** \brief Data phase baud rate configuration
 */
typedef union
{
    IfxCanxl_DataBaudrateConfig    calc;       /**< \brief Bit timing auto calculation configuration */
    IfxCanxl_DataBaudrateRegConfig reg;        /**< \brief Bit timing register configuration */
} IfxCanxl_Can_DataBaudRate;

/** \brief <  CAN-FD Frame configurations
 */
typedef struct
{
    uint32                  messageId;                   /**< \brief Message ID of CAN frame */
    IfxCanxl_DataLengthCode dataLengthCode;              /**< \brief Data length code in CAN-FD encoding format */
    boolean                 errorStateIndicator;         /**< \brief ESI, Error State Indicator (enable / disable) */
    boolean                 extendedId;                  /**< \brief XTD, Extended Identifier length (enable / disable) */
    boolean                 faultInjectionRequest;       /**< \brief Fault Injection Request (enable / disable) */
    boolean                 brs;                         /**< \brief Bit Rate Switch (0: disabled, 1: enabled) */
} IfxCanxl_Can_FdTxMsgConfig;

/** \brief Structure for Interrupt node Configuration
 */
typedef struct
{
    uint32       enableMask;          /**< \brief Interrupt enable mask */
    Ifx_Priority priority;            /**< \brief Priority of the interrupt */
    IfxSrc_Tos   typeOfService;       /**< \brief Type of Service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
} IfxCanxl_Can_InterruptNodeConfig;

/** \brief Nominal/arbitration phase baud rate configuration
 */
typedef union
{
    IfxCanxl_NominalBaudrateConfig    calc;       /**< \brief Bit timing auto calculation configuration */
    IfxCanxl_NominalBaudrateRegConfig reg;        /**< \brief Bit timing register configuration */
} IfxCanxl_Can_NominalBaudrate;

/** \brief <  CAN-XL Frame configurations
 */
typedef struct
{
    uint32  messageId;                   /**< \brief Priority ID of CAN frame */
    uint32  acceptanceField;             /**< \brief Acceptance Field */
    uint16  dataLengthCode;              /**< \brief Data length code in CAN-XL encoding format */
    uint8   sduType;                     /**< \brief Indicates the type of the protocol embedded in the data field */
    uint8   virtualCanId;                /**< \brief Allows to separate the CAN Bus into virtual buses */
    boolean faultInjectionRequest;       /**< \brief Fault Injection Request (enable / disable) */
} IfxCanxl_Can_XlTxMsgConfig;

/** \} */

/** \addtogroup IfxLld_Canxl_Can_Structures
 * \{ */
/** \brief Max number of possible DMA AXI transactions
 */
typedef struct
{
    IfxCanxl_MaxAxiTransactions read;        /**< \brief maximum read pending transactions */
    IfxCanxl_MaxAxiTransactions write;       /**< \brief maximum write pending transactions */
} IfxCanxl_Can_AxiParams;

/** \brief Baud rate configuration
 */
typedef struct
{
    IfxCanxl_Can_NominalBaudrate nominal;       /**< \brief Nominal baud rate configuration */
    IfxCanxl_Can_DataBaudRate    fd;            /**< \brief FD Data phase baud rate configuration */
    IfxCanxl_Can_DataBaudRate    xl;            /**< \brief XL Data phase baud rate configuration */
} IfxCanxl_Can_BaudrateConfig;

/** \brief <  CAN Frame configurations
 */
typedef union
{
    IfxCanxl_Can_ClassicTxMsgConfig cl;       /**< \brief Classic CAN */
    IfxCanxl_Can_FdTxMsgConfig      fd;       /**< \brief CAN-FD */
    IfxCanxl_Can_XlTxMsgConfig      xl;       /**< \brief CAN-XL */
} IfxCanxl_Can_FrameTxMsgConfig;

/** \brief Structure for Interrupt Configuration
 */
typedef struct
{
    IfxCanxl_Can_InterruptNodeConfig functional;       /**< \brief Configuration for functional interrupts */
    IfxCanxl_Can_InterruptNodeConfig error;            /**< \brief Configuration for error interrupts */
    IfxCanxl_Can_InterruptNodeConfig safety;           /**< \brief Configuration for safety interrupts */
} IfxCanxl_Can_InterruptConfig;

/** \brief Structure for MTI Flags Configuration
 */
typedef struct
{
    uint32 enableMask;       /**< \brief Enable mask */
} IfxCanxl_Can_MtiConfig;

/** \brief Absolute RAM addresses for a given node stored in handle IfxCanxl_Can
 */
typedef struct
{
    uint32 rxFilterStartAddress;             /**< \brief Rx filter start address in SRAM */
    uint32 txFifoQueueDescAddress;           /**< \brief Tx fifo queue descriptor address in SRAM */
    uint32 txPriorityQueueDescAddress;       /**< \brief Tx fifo priority queue descriptor address in SRAM */
} IfxCanxl_Can_NodeRamAddress;

/** \brief RAM offsets for a given node
 */
typedef struct
{
    uint16 rxFilter;                  /**< \brief Offset for rx filter start address from base RAM address */
    uint16 txFifoQueueDesc;           /**< \brief Offset for tx fifo queue descriptor address from base RAM address */
    uint16 txPriorityQueueDesc;       /**< \brief Offset for tx priority fifo queue descriptor address from base RAM address */
} IfxCanxl_Can_NodeRamOffset;

/** \brief Structure for CAN-XL pin configuration
 */
typedef struct
{
    IfxCanxl_Txd_Out  *txPin;           /**< \brief Specifies the transmit pin */
    IfxPort_OutputMode txPinMode;       /**< \brief Specifies the transmit pin output mode */
    IfxCanxl_Rxd_In   *rxPin;           /**< \brief Specifies the receive pin */
    IfxPort_InputMode  rxPinMode;       /**< \brief Specifies the receive pin input mode */
    IfxPort_PadDriver  padDriver;       /**< \brief Specifies the pad driver */
} IfxCanxl_Can_Pins;

/** \brief PWM encoder configuration for XL frames
 */
typedef struct
{
    uint8   shortPhase;       /**< \brief PWM phase Short (PWMS). Valid values are 0x0 to 0x3F (5 bits).
                               * The actual interpretation of this value is that the PWM short phase length is (PWMS + 1) clock cycles long */
    uint8   longPhase;        /**< \brief PWM phase Long (PWML). Valid values are 0x0 to 0x3F (5 bits).
                               * The actual interpretation of this value is that the PWM long phase length is (PWML + 1) clock cycles long */
    uint8   offset;           /**< \brief PWM Offset (PWMO). Valid values are 0x0 to 0x3F (5 bits).
                               * PWMO shall always be smaller than the PWM symbol length (PWMO < PWMS + PWML + 2) */
    boolean enable;           /**< \brief TRUE: Configure PWM encoder. FALSE: DON'T configure */
} IfxCanxl_Can_PwmEncoderConfig;

/** \brief RX FIFO Queue information
 */
typedef struct
{
    uint32            descriptorStartAddress;      /**< \brief Descriptor start address in system memory */
    IfxCanxl_RxDescr *descriptor;                  /**< \brief Pointer to current descriptor */
    uint16            numDescriptors;              /**< \brief Maximum number of RX descriptors in the RX FIFO Queue link list descriptors. Max value: 1024 */
    uint16            dataContainerSizeWords;      /**< \brief Data container size in words */
} IfxCanxl_Can_RxFifoQueue;

/** \brief Structure for RX FIFO Queue Configuration
 */
typedef struct
{
    uint32  descriptorStartAddress;          /**< \brief Start address of RX FIFO Queue link list descriptor in system memory. MUST be word aligned */
    uint16  numDescriptors;                  /**< \brief Maximum number of RX descriptors in the RX FIFO Queue link list descriptors. Max value: 1024 */
    uint16  dataContainerSize;               /**< \brief Allocated size = dataContainerSize * 32bytes. Normal mode: Size per descriptor. Continuous: Size of single container */
    uint32  dataContainerStartAddress;       /**< \brief ONLY valid for continuous mode. Defines the Data Container Start Address in system memory. MUST be word aligned */
    boolean enable;                          /**< \brief TRUE: Configure and enable queue. FALSE: DON'T configure queue */
} IfxCanxl_Can_RxFifoQueueConfig;

/** \brief Structure for Time Stamp Configuration
 */
typedef struct
{
    IfxCanxl_TimebaseClockSource    clockSource;            /**< \brief Select clock source for timebase generation */
    IfxCanxl_TimebaseClockPrescaler prescaler;              /**< \brief Select clock prescaler for timebase generation */
    IfxCanxl_TimeStampPosition      capturePosition;        /**< \brief Select Capturing Position */
    boolean                         useNode0Timebase;       /**< \brief TRUE: Synchronize Node i (i>0) timebase with Node 0. FALSE: Use clock source and prescaler to generate timebase */
    boolean                         enable;                 /**< \brief TRUE: Enable Timestamping. FALSE: Disable timestamping */
} IfxCanxl_Can_TimeStampConfig;

/** \brief Structure for TX FIFO Queue Configuration
 */
typedef struct
{
    uint32  descriptorStartAddress;       /**< \brief Start address of TX FIFO Queue link list descriptor in system memory. Must be word aligned */
    uint16  numDescriptors;               /**< \brief Maximum number of TX descriptors in the TX FIFO Queue link list descriptors. Max value: 1024 */
    boolean enable;                       /**< \brief TRUE: Configure and enable queue. FALSE: DON'T configure queue */
} IfxCanxl_Can_TxFifoQueueConfig;

/** \brief Reference value for Tx filter's
 */
typedef struct
{
    uint8 REFVAL0_0;       /**< \brief Reference value for REFVAL0.REF_VAL0 */
    uint8 REFVAL0_1;       /**< \brief Reference value for REFVAL0.REF_VAL1 */
    uint8 REFVAL0_2;       /**< \brief Reference value for REFVAL0.REF_VAL2 */
    uint8 REFVAL0_3;       /**< \brief Reference value for REFVAL0.REF_VAL3 */
    uint8 REFVAL1_0;       /**< \brief Reference value for REFVAL1.REF_VAL0 */
    uint8 REFVAL1_1;       /**< \brief Reference value for REFVAL1.REF_VAL1 */
    uint8 REFVAL1_2;       /**< \brief Reference value for REFVAL1.REF_VAL2 */
    uint8 REFVAL1_3;       /**< \brief Reference value for REFVAL1.REF_VAL3 */
    uint8 REFVAL2_0;       /**< \brief Reference value for REFVAL2.REF_VAL0 */
    uint8 REFVAL2_1;       /**< \brief Reference value for REFVAL2.REF_VAL1 */
    uint8 REFVAL2_2;       /**< \brief Reference value for REFVAL2.REF_VAL2 */
    uint8 REFVAL2_3;       /**< \brief Reference value for REFVAL2.REF_VAL3 */
    uint8 REFVAL3_0;       /**< \brief Reference value for REFVAL3.REF_VAL0 */
    uint8 REFVAL3_1;       /**< \brief Reference value for REFVAL3.REF_VAL1 */
    uint8 REFVAL3_2;       /**< \brief Reference value for REFVAL3.REF_VAL2 */
    uint8 REFVAL3_3;       /**< \brief Reference value for REFVAL3.REF_VAL3 */
} IfxCanxl_Can_TxFilterRefValue;

/** \brief Structure for TX Priority Queue Configuration
 */
typedef struct
{
    uint32  descriptorStartAddress;       /**< \brief Start address of TX Priority Queue link list descriptor in system memory. Must be word aligned */
    uint8   numSlots;                     /**< \brief Number of Priority Queue slots to be activated. Max value: 32 */
    boolean enable;                       /**< \brief TRUE: Configure and enable queue. FALSE: DON'T configure queue */
} IfxCanxl_Can_TxPriorityQueueConfig;

/** \} */

/** \brief TX FIFO Queue information
 */
typedef struct
{
    uint32 descriptorStartAddress;       /**< \brief Descriptor start address in system memory */
} IfxCanxl_Can_TxFifoQueue;

/** \addtogroup IfxLld_Canxl_Can_Structures
 * \{ */
/** \brief Module handle
 */
typedef struct
{
    Ifx_CANXL                  *canxl;                                    /**< \brief Specifies the pointer to the CAN-XL registers */
    IfxCanxl_Can_NodeRamAddress ramAddressNode[IFXCANXL_NUM_NODES];       /**< \brief Specifies the SRAM addresses for a given node */
} IfxCanxl_Can;

/** \brief Configuration Structure of the Module
 */
typedef struct
{
    Ifx_CANXL                 *canxl;                                    /**< \brief Specifies the pointer to the CANXL registers */
    boolean                    enableNode[IFXCANXL_NUM_NODES];           /**< \brief TRUE: Enables the CANXL node FALSE: No update, retains previous/default value */
    IfxCanxl_Can_NodeRamOffset ramOffsetsNode[IFXCANXL_NUM_NODES];       /**< \brief Specifies the RAM offsets for a given node */
} IfxCanxl_Can_Config;

/** \brief Node handle
 */
typedef struct
{
    Ifx_CANXL                  *canxl;                                     /**< \brief Specifies the pointer to CAN-XL registers */
    Ifx_CANXL_N                *node;                                      /**< \brief Specifies the pointer to CAN-XL node registers */
    IfxCanxl_NodeId             nodeId;                                    /**< \brief Specifies the Node number */
    uint8                       instanceNumber;                            /**< \brief Unique identifier for XCAN instance */
    IfxCanxl_RxDataContainer    rxDataContainerMode;                       /**< \brief Memory organization of RX Data containers */
    IfxCanxl_Can_NodeRamAddress ramAddresses;                              /**< \brief Memory address of various RAM sections in CANXL's RAM */
    uint8                       numRxFilterElements;                       /**< \brief Number of RX filter elements to be used */
    IfxCanxl_Can_RxFifoQueue    rxFifoQueue[IFXCANXL_NUM_RX_QUEUES];       /**< \brief RX FIFO Queue information */
    IfxCanxl_Can_TxFifoQueue    txFifoQueue[IFXCANXL_NUM_TX_QUEUES];       /**< \brief TX FIFO Queue information */
} IfxCanxl_Can_Node;

/** \brief Node Configuration structure
 */
typedef struct
{
    Ifx_CANXL                         *canxl;                                     /**< \brief Specifies the pointer to the CAN-XL registers */
    IfxCanxl_NodeId                    nodeId;                                    /**< \brief Specifies the Node number */
    IfxCanxl_RxDataContainer           rxDataContainerMode;                       /**< \brief Memory organization of RX Data containers */
    IfxCanxl_MaxMsgRetransmissions     maxRetransmissions;                        /**< \brief Maximum number of TX message re-transmissions */
    uint8                              instanceNumber;                            /**< \brief Unique identifier for XCAN instance */
    IfxCanxl_Can_NodeRamAddress        ramAddresses;                              /**< \brief Memory addresses of various RAM sections in CANXL's SRAM. All values must be 32 bit aligned */
    IfxCanxl_Node_OperationMode        mode;                                      /**< \brief Node operation mode */
    IfxCanxl_Can_AxiParams             axiParams;                                 /**< \brief AXI transactions related configuration */
    IfxCanxl_Can_BaudrateConfig        baudrate;                                  /**< \brief Baud rate configuration */
    IfxCanxl_Can_PwmEncoderConfig      pwmEncoder;                                /**< \brief PWM encoder configuration for XL frames */
    IfxCanxl_Can_TxFifoQueueConfig     txFifoQueue[IFXCANXL_NUM_TX_QUEUES];       /**< \brief TX FIFO queue configuration. To use N queues, enable only 0 to N-1 queues. */
    IfxCanxl_Can_TxPriorityQueueConfig txPriorityQueue;                           /**< \brief TX Priority Queue configuration */
    IfxCanxl_Can_RxFifoQueueConfig     rxFifoQueue[IFXCANXL_NUM_RX_QUEUES];       /**< \brief RX FIFO queue configuration. To use N queues, enable only 0 to N-1 queues. */
    IfxCanxl_Can_TimeStampConfig       timeStamp;                                 /**< \brief Time Stamp Configuration */
    IfxCanxl_Can_InterruptConfig       interrupt;                                 /**< \brief Interrupt Configuration */
    IfxCanxl_Can_MtiConfig             mti;                                       /**< \brief MTI flags Configuration */
    IFX_CONST IfxCanxl_Can_Pins       *pins;                                      /**< \brief Structure for CAN-XL pins */
    IfxCanxl_Can_RxFilterGlobalConfig  rxFilterConfig;                            /**< \brief Specifies the rx filter global configuration values */
    boolean                            calculateBitTimingValues;                  /**< \brief Enable / Disable auto calculation of bit timing values for selected XCAN node */
} IfxCanxl_Can_NodeConfig;

/** \brief Absolute Memory address of various RAM sections in CANXL's RAM
 */
typedef struct
{
    uint32 rxFilter;              /**< \brief Define the base address where the RX filter elements are defined in L_MEM */
    uint32 txFifoQueue;           /**< \brief Define the base address where the TX FIFO Queue descriptors are stored in L_MEM */
    uint32 txPriorityQueue;       /**< \brief Define the base address where the TX Priority Queue descriptors are stored in L_MEM */
} IfxCanxl_Can_RamAddress;

/** \brief <  RX Descriptor configuration
 */
typedef struct
{
    uint32  dataContainerStartAddress;       /**< \brief Address in system memory to temporarily hold reception data. MUST be word aligned */
    boolean triggerInterrupt;                /**< \brief Trigger interrupt once RX message has been received (enable / disable) */
    uint8   rollingCounter;                  /**< \brief Used to track the order of TX descriptor fetched */
} IfxCanxl_Can_RxDescrConfig;

/** \brief configuration structure for CANXL RX filter element
 */
typedef struct
{
    uint8                    refIndex0;              /**< \brief Reference Index: provide the index of the reference pair (value and mask) to be used for comparison 0 */
    IfxCanxl_frameHeaderWord wordIndex0;             /**< \brief Word Index: provide the index of the RX message header word to compare, 1 for R0, 2 for R1 and 3 for R2. */
    boolean                  rejectOnMatch0;         /**< \brief Accept or Reject on match: when set to TRUE the RX message is rejected on match otherwise accepted on match */
    uint8                    refIndex1;              /**< \brief Reference Index: provide the index of the reference pair (value and mask) to be used for comparison 1 */
    IfxCanxl_frameHeaderWord wordIndex1;             /**< \brief Word Index: provide the index of the RX message header word to compare, 1 for R0, 2 for R1 and 3 for R2. */
    boolean                  rejectOnMatch1;         /**< \brief Accept or Reject on match: when set to TRUE the RX message is rejected on match otherwise accepted on match */
    boolean                  enableBlackList;        /**< \brief BlackList: When set to TRUE the BLK bit defined in the RX message header is set to 1 */
    boolean                  interruptOnMatch;       /**< \brief Interrupt: When set to TRUE an interrupt is triggered to the system when a match is detected */
    IfxCanxl_RxFifoQueue     rxFifoQueueIndex;       /**< \brief RX FIFO Queue number to store the receive CAN data */
} IfxCanxl_Can_RxFilterElementConfig;

/** \brief configuration CANXL RX filter element reference and mask values
 */
typedef struct
{
    uint32 refValue;        /**< \brief Reference value (32-bit value) */
    uint32 maskValue;       /**< \brief Mask value (32-bit value) */
} IfxCanxl_Can_RxFilterRefMaskConfig;

/** \brief <  RX Message structure
 */
typedef struct
{
    uint64               timeStamp;             /**< \brief Time stamp information */
    IfxCanxl_RxHeader    header;                /**< \brief Header of CAN frame */
    uint32              *dataPtr;               /**< \brief Pointer to CAN Payload to be provided by user */
    uint32               dataSizeInWords;       /**< \brief CAN Payload length in words */
    IfxCanxl_FrameMode   frameMode;             /**< \brief CAN Frame format */
    IfxCanxl_RxMsgStatus msgStatus;             /**< \brief Reception status */
} IfxCanxl_Can_RxMessage;

/** \brief <  TX Descriptor configuration
 */
typedef struct
{
    uint32                       *dataPtr;                /**< \brief Data pointer for transmission */
    IfxCanxl_FrameMode            frameMode;              /**< \brief CAN Frame format */
    IfxCanxl_Can_FrameTxMsgConfig frame;                  /**< \brief CAN Frame related configurations */
    uint8                         rollingCounter;         /**< \brief Used to track the order of TX descriptor fetched */
    boolean                       wrapQueue;              /**< \brief TRUE: Next message descriptor is declared at the initial start address of the TX FIFO Queue
                                                           * FALSE: Next message descriptor is declared at (current address + 32 byte). */
    boolean                       endQueue;               /**< \brief TRUE: Deactivate queue after this message. FALSE: Process next descriptor. Only applicable for FIFO Queue. */
    boolean                       triggerInterrupt;       /**< \brief Trigger interrupt once TX message has been transmitted (enable / disable) */
} IfxCanxl_Can_TxDescrConfig;

/** \brief configuration structure for CANXL TX filtering
 */
typedef struct
{
    boolean                        enableInterrupt;      /**< \brief TRUE: Enable the Interrupt trigger when msg is rejected by the Tx filter FALSE: Disable the Tx filter interrupt */
    boolean                        mode;                 /**< \brief TRUE: Msg are Tx when allowed by TX filter (match). FALSE: Msg are Tx when rejected by TX filter (no match) */
    uint8                          combineFilter;        /**< \brief Set [n] bit field to combine REF_VAL[n] and REF_VAL[n+1] values i.e msg is Tx by [n] filter element only if it matches both values i.e. REF_VAL[n] and REF_VAL[n+1] */
    uint8                          maskFilter;           /**< \brief Set [n] bit field to enable the value and mask mode i.e.  REF_VAL[n] contains value and REF_VAL[n+1] contains mask */
    uint16                         validFilters;         /**< \brief When validFilters[n] = 1 the reference value defined for the TX filter n is valid. When validFilters[n] = 0 the ref value for [n] TX filter element is invalid */
    uint16                         fieldMatch;           /**< \brief Set [n] bit field if match needs to be performed with SDT field of CANXL msg. Reset [n] field if match needs to be performed with VCID field of CANXL msg */
    IfxCanxl_Can_TxFilterRefValue *refValue;             /**< \brief Pointer to TX filter reference values. */
} IfxCanxl_Can_TxFilterConfig;

/** \brief <  TX Message structure
 */
typedef struct
{
    uint32                       *dataPtr;                /**< \brief Data pointer for transmission */
    IfxCanxl_FrameMode            frameMode;              /**< \brief CAN Frame format */
    IfxCanxl_Can_FrameTxMsgConfig frame;                  /**< \brief CAN Frame related configurations */
    boolean                       triggerInterrupt;       /**< \brief Trigger interrupt once TX message has been transmitted (enable / disable) */
    boolean                       wrapQueue;              /**< \brief TRUE: Next message descriptor is declared at the initial start address of the TX FIFO Queue
                                                           * FALSE: Next message descriptor is declared at (current address + 32 byte). */
    boolean                       endQueue;               /**< \brief TRUE: Deactivate queue after this message. FALSE: Process next descriptor. Only applicable for FIFO Queue. */
} IfxCanxl_Can_TxMessage;

/** \} */

/** \addtogroup IfxLld_Canxl_Can_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initialises the CANXL Module
 * \param canxl Specifies the module handle
 * \param config Configuration structure of the module
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initModule(IfxCanxl_Can *canxl, IfxCanxl_Can_Config *config);

/** \brief Fills the configuration stucture of the CANXL Module with default values
 * \param config Configuration structure to be filled with default values
 * \param canxl Specifies the pointer to the CANXL registers
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initModuleConfig(IfxCanxl_Can_Config *config, Ifx_CANXL *canxl);

/** \brief Fills the configuration structure of the Node with default values
 * \param config Configuration structure of the Node
 * \param nodeId Node index
 * \param canxl Specifies the module handle
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initNodeConfig(IfxCanxl_Can_NodeConfig *config, IfxCanxl_NodeId nodeId, IfxCanxl_Can *canxl);

/** \brief Initialixes the CAN Node
 * \param node CAN-XL Node handle
 * \param config Configuration structure of the Node
 * \return TRUE: Returns TRUE if the operation was successful
 * FALSE: Returns FALSE if the operation was unsuccessful
 */
IFX_EXTERN boolean IfxCanxl_Can_initNode(IfxCanxl_Can_Node *node, IfxCanxl_Can_NodeConfig *config);

/** \brief Initializes TX FIFO Queue
 * \param node Pointer to CAN-XL node handle
 * \param config Pointer to configuration structure of TX FIFO Queue
 * \param idx Queue index
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initTxFifoQueue(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxFifoQueueConfig *config, IfxCanxl_TxFifoQueue idx);

/** \brief Initializes TX Priority Queue
 * \param node Pointer to CAN-XL node handle
 * \param config Pointer to configuration structure of TX Priority Queue
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initTxPriorityQueue(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxPriorityQueueConfig *config);

/** \brief Initializes RX FIFO Queue
 * \param node Pointer to CAN-XL node handle
 * \param config Pointer to configuration structure of RX FIFO Queue
 * \param idx Queue index
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initRxFifoQueue(IfxCanxl_Can_Node *node, IfxCanxl_Can_RxFifoQueueConfig *config, IfxCanxl_RxFifoQueue idx);

/** \brief Initializes the node interrupts and Src pointers
 * \param node Pointer to CAN-XL node handle
 * \param config Pointer to interrupt configuration structure
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initInterrupts(IfxCanxl_Can_Node *node, IfxCanxl_Can_InterruptConfig *config);

/** \brief Initializes time stamping functionality of CAN-XL node
 * \param node Pointer to CAN-XL node handle
 * \param config Time stamp configuration structure
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_initTimeStamp(IfxCanxl_Can_Node *node, IfxCanxl_Can_TimeStampConfig *config);

/** \brief Starts the node's message handler and protocol controller
 * \param node Pointer to CAN-XL node handle
 * \param mode Normal operation or loopback operation
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_startNode(IfxCanxl_Can_Node *node, IfxCanxl_Can_StartMode mode);

/** \brief Stops the node's message handler and protocol controller
 * \param node Pointer to CAN-XL node handle
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_stopNode(IfxCanxl_Can_Node *node);

/** \brief Configures the TX filter
 * \param node Pointer to CAN-XL node registers
 * \param config Pointer to configuration structure of TX filter
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_configureTxFilter(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxFilterConfig *config);

/** \brief Configures the RX filter elements
 * \param node Pointer to CAN-XL node registers
 * \param rxFilterIndex index for RX filter elements. Range = [0, 255]
 * \param config Configuration structure for RX filter element
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_configureRxFilterElements(IfxCanxl_Can_Node *node, uint8 rxFilterIndex, IfxCanxl_Can_RxFilterElementConfig *config);

/** \brief Configures the RX filter reference/mask values pairs
 * \param node Pointer to CAN-XL node registers
 * \param rxFilterRefIndex Ref/mask index for RX filter elements. Range = [0, 255]
 * \param config Configuration structure for RX filter element reference/mask values pair
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_configureRxFilterRefMaskValues(IfxCanxl_Can_Node *node, uint8 rxFilterRefIndex, IfxCanxl_Can_RxFilterRefMaskConfig *config);

/** \brief Transmits a CAN message
 * Note: Message is sent when it wins the arbitration. The API does not wait for transmission but only configures the queue.
 * \param node Pointer to CAN-XL node handle
 * \param msg Structure for Message configuration
 * \param queueType TX Queue type which will send the message
 * \param queueIndex TX Queue Index which will send the message. Range: 0-7 for queueType = fifo and 0-31 for queueType = priority
 * \return Operation status. TRUE: Queue configured to send message. FALSE: Queue could not be configured
 */
IFX_EXTERN boolean IfxCanxl_Can_sendMessage(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxMessage *msg, IfxCanxl_TxQueueType queueType, uint8 queueIndex);

/** \brief Reads one received CAN message
 * \param node Pointer to CAN-XL node handle
 * \param msg RX Message information. Provide dataPtr where payload should be stored
 * \param queueIndex RX Queue Index whose message is to be received. Range: 0-7
 * \return Operation status. TRUE: Successfully read one message. FALSE: Error happened while reading
 */
IFX_EXTERN boolean IfxCanxl_Can_readMessage(IfxCanxl_Can_Node *node, IfxCanxl_Can_RxMessage *msg, IfxCanxl_RxFifoQueue queueIndex);

/** \brief Returns descriptor pointer for TX queue if queue is not running/active
 * node Pointer to CAN-XL node handle
 * \param node Pointer to CAN-XL node handle
 * \param queueType TX Queue type which will send the message
 * \param queueIndex TX Queue Index which will send the message. Range: 0-7 for queueType = fifo and 0-31 for queueType = priority
 * \return Descriptor Pointer
 */
IFX_EXTERN IfxCanxl_TxDescr *IfxCanxl_Can_getTxDescrPtr(IfxCanxl_Can_Node *node, IfxCanxl_TxQueueType queueType, uint8 queueIndex);

/** \brief Configures TX descriptor for message transmission
 * \param node Pointer to CAN-XL node handle
 * \param descriptor Pointer to descriptor
 * \param config Structure for descriptor configuration
 * \param queueType TX Queue type which will send the message
 * \param queueIndex TX Queue Index which will send the message. Range: 0-7 for queueType = fifo and 0-31 for queueType = priority
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_configureTxDescriptor(IfxCanxl_Can_Node *node, IfxCanxl_TxDescr *descriptor, IfxCanxl_Can_TxDescrConfig *config, IfxCanxl_TxQueueType queueType, uint8 queueIndex);

/** \brief Configures RX descriptor for message reception
 * \param node Pointer to CAN-XL node handle
 * \param descriptor Pointer to descriptor
 * \param config Structure for descriptor configuration
 * \param queueIndex RX Queue Index which will send the message. Range: 0-7
 * \return None
 */
IFX_EXTERN void IfxCanxl_Can_configureRxDescriptor(IfxCanxl_Can_Node *node, IfxCanxl_RxDescr *descriptor, IfxCanxl_Can_RxDescrConfig *config, uint8 queueIndex);

/** \brief Checks whether RX message is available in queue
 * \param node Pointer to CAN-XL node handle
 * \param queueIndex RX Queue Index which will send the message. Range: 0-7
 * \return TRUE: Message is available
 */
IFX_EXTERN boolean IfxCanxl_Can_isRxMessageAvailable(IfxCanxl_Can_Node *node, uint8 queueIndex);

/** \} */

#endif /* IFXCANXL_CAN_H */
