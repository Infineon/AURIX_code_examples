/**
 * \file IfxScrSsc.h
 * \brief SCR SSC basic functionality
 * \ingroup IfxLld_ScrSsc
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *  \defgroup IfxLld_Scr_Ssc_Usage How to use the Ssc driver?
 *  \ingroup IfxLld_Scr
 *
 *  Steps to use the driver:
 *
 *  \section IfxLld_Scr_Ssc_Preparation Preparation
 *  \subsection IfxLld_Scr_Ssc_Include Include Files
 *
 *  Include following header file into your C code:
 *  \code
 *  #include <Ssc/Std/IfxScrSsc.h>
 *  #include <Cpu/Std/IfxScrCpuIrq.h>
 *  #include <Port/Std/IfxScrPort.h>
 *  \endcode
 *
 *  \subsection IfxLld_Scr_Ssc_Interrupt Interrupt Handler Installation
 *  Add the interrupt service routines to your C code:
 *  \code
 *  #define __INTNO(nr) ((8*nr)+3)
 *
 *  void __interrupt(__INTNO(IfxScrCpuIrq_InterruptNode_adc_ssc)) ssc_interrupt(void)
 *  {
 *      // Transmit next data if no ongoing transmission
 *  	if(TRUE == IfxScrCpuIrq_getSscInterruptStatus(IfxScrCpuIrq_SscInterrupt_transmit))
 *  	{
 *  	    uint8 rxdata = 0u;
 *  		uint8 txdata = 0x55;
 *  	    IfxScrCpuIrq_clearSscInterruptFlag(IfxScrCpuIrq_SscInterrupt_transmit);
 *  		IfxScrSsc_startTx(txdata);
 *  		rxdata = IfxScrSsc_getRxData();
 *  	}
 *
 *  	if(TRUE == IfxScrCpuIrq_getSscInterruptStatus(IfxScrCpuIrq_SscInterrupt_error))
 *  	{
 *  	    IfxScrCpuIrq_clearSscInterruptFlag(IfxScrCpuIrq_SscInterrupt_error);
 *  		//Error handling
 *  	}
 *  }
 *  \endcode
 *
 *  \subsection IfxLld_Scr_Ssc Module Initialization
 *  \code
 *  // Enable global interrupt
 *  IfxScrCpuIrq_enableGlobalInterrupt();
 *
 *  //Enable interrupt for Ssc
 *  IfxScrCpuIrq_enableInterruptNode(IfxScrCpuIrq_InterruptNode_adc_ssc);
 *  IfxScrCpuIrq_setPriority(IfxScrCpuIrq_InterruptNode_adc_ssc, IfxScrCpuIrq_Priority_3);
 *
 *  //Port configuration for MTSR, MRST, SCLK and SS
 *  IfxScrPort_PinConfig mtsrPinCfg = {IfxScrPort_Index_02, IfxScrPort_PinIndex_2, IfxScrPort_IoControl_output_pushpullAlt2, IfxScrPort_PadDriver_cmosAutomotiveSpeed1};
 *  IfxScrPort_PinConfig mrstPinCfg = {IfxScrPort_Index_00, IfxScrPort_PinIndex_5, IfxScrPort_IoControl_input_tristate, IfxScrPort_PadDriver_cmosAutomotiveSpeed1};
 *  IfxScrPort_PinConfig clkPinCfg = {IfxScrPort_Index_00, IfxScrPort_PinIndex_1, IfxScrPort_IoControl_output_pushpullAlt2, IfxScrPort_PadDriver_cmosAutomotiveSpeed1};
 *  IfxScrPort_PinConfig ssPinCfg = {IfxScrPort_Index_00, IfxScrPort_PinIndex_0, IfxScrPort_IoControl_output_pushpullGpio, IfxScrPort_PadDriver_cmosAutomotiveSpeed1};
 *
 *  IfxScrPort_configurePin(&mtsrPinCfg);
 *  IfxScrPort_enablePortPad(mtsrPinCfg.port,mtsrPinCfg.pin);
 *  IfxScrPort_configurePin(&mrstPinCfg);
 *  IfxScrPort_enablePortPad(mrstPinCfg.port,mrstPinCfg.pin);
 *  IfxScrPort_configurePin(&clkPinCfg);
 *  IfxScrPort_enablePortPad(clkPinCfg.port,clkPinCfg.pin);
 *  IfxScrPort_configurePin(&ssPinCfg);
 *  IfxScrPort_enablePortPad(ssPinCfg.port,ssPinCfg.pin);
 *
 *  // Enable module
 *  IfxScrScu_enableModule(IfxScrScu_Module_ssc);
 *
 *  IfxScrSsc_Config sscConfig;
 *  sscConfig.mode = IfxScrSsc_Mode_master;
 *  sscConfig.dataWidth = IfxScrSsc_DataWidth_8bits;
 *  sscConfig.txDataOrientation = IfxScrSsc_dataOrientation_msbFirst;
 *  sscConfig.shiftClockPhase = IfxScrSsc_ClockPhase_latchOnLeadingEdge;
 *  sscConfig.shiftClockPolarity = IfxScrSsc_ClockPolarity_idleHigh;
 *  sscConfig.enableLoopback = FALSE;
 *  sscConfig.enableTransmitBufferReadyInterrupt = TRUE;
 *  sscConfig.enableDataReceivedInterrupt = FALSE;
 *  sscConfig.enableReceiveFifoFullInterrupt = FALSE;
 *  sscConfig.enableReceiveFifoEmptyInterrupt = FALSE:
 *  sscConfig.enableReceiveErrorInterrupt = TRUE;
 *  sscConfig.enableTransmitErrorInterrupt = TRUE;
 *  sscConfig.enableBaudrateErrorInterrupt = FALSE;
 *  sscConfig.baudrate = 2000000; //2M
 *
 *  // Initialize module
 *  IfxScrSsc_initModule(&sscConfig);
 *
 *  IfxScrSsc_setMasterModeRxInput(IfxScrSsc_InputSel_A);
 *
 *  //Enter operation mode
 *  IfxScrSsc_enterOperationMode();
 *
 *  //Transmit data
 *  uint8 data = 0xAA;
 *  //Slave select
 *  IfxScrPort_setPinLow(ssPinCfg.port,ssPinCfg.pin);
 *  IfxScrSsc_startTx(data);
 *
 *  //Slave deselect
 *  IfxScrPort_setPinHigh(ssPinCfg.port,ssPinCfg.pin);
 *
 *  //In polling mode IfxScrSsc_isTransmitBufferReady api can be used to get the buffer status
 *
 *  \endcode
 *
 * \defgroup IfxLld_ScrSsc_Std_Enumerations Enums
 * \ingroup IfxLld_ScrSsc_Std
 * \defgroup IfxLld_ScrSsc_Std_DataStructures Data structures
 * \ingroup IfxLld_ScrSsc_Std
 * \defgroup IfxLld_ScrSsc_Std_TxFunctionality Tx Functionality
 * \ingroup IfxLld_ScrSsc_Std
 * \defgroup IfxLld_ScrSsc_Std_RxFunctionality Rx Functionality
 * \ingroup IfxLld_ScrSsc_Std
 * \defgroup IfxLld_ScrSsc_Std_init SSC Initialization Functionality
 * \ingroup IfxLld_ScrSsc_Std
 *
 */

#ifndef IFXSCRSSC_H
#define IFXSCRSSC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxScrSsc_cfg.h"
#include "_Reg/IfxScr_reg.h"
#include "_Reg/IfxScr_bf.h"

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_ScrSsc_Std_Enumerations
 * \{ */

/** \brief List of SSC events which require query
 */

typedef enum
{
    IfxScrSsc_Event_transmitError    = 0, /**< \brief  Indicates That Transfer triggered before updating SSC_TBL in SSC slave*/
    IfxScrSsc_Event_receiveError     = 1, /**< \brief  Indicated reception of new data while Rx FIFO is full*/
    IfxScrSsc_Event_receiveFifoEmpty = 2, /**< \brief  Indicates FIFO empty */
    IfxScrSsc_Event_baudrateError    = 3, /**< \brief  Indicates an error in actual baudrate of >2 or <0.5 times the configured baudrate */
    IfxScrSsc_Event_busy             = 4, /**< \brief Indicates Transfer in progress */
    IfxScrSsc_Event_receiveFifoFull  = 5  /**< \brief  Indicates FIFO full */
}IfxScrSsc_Event;

/** \brief Enumeration describing data width selection
 */

typedef enum
{
    IfxScrSsc_DataWidth_4bits = 3,        /**< \brief  Transfer Data width 4 bits*/
    IfxScrSsc_DataWidth_5bits = 4,        /**< \brief  Transfer Data width 5 bits*/
    IfxScrSsc_DataWidth_6bits = 5,        /**< \brief  Transfer Data width 6 bits*/
    IfxScrSsc_DataWidth_7bits = 6,        /**< \brief  Transfer Data width 7 bits*/
    IfxScrSsc_DataWidth_8bits = 7         /**< \brief  Transfer Data width 8 bits*/
}IfxScrSsc_DataWidth;

/** \brief Enumeration describing SSC input select for Master mode, Slave mode and slave mode Clock input
 */

typedef enum
{
    IfxScrSsc_InputSel_A = 0,          /**< \brief  SSC input select A */
    IfxScrSsc_InputSel_B = 1,          /**< \brief  SSC input select B */
    IfxScrSsc_InputSel_C = 2,          /**< \brief  SSC input select C */
    IfxScrSsc_InputSel_D = 3           /**< \brief  SSC input select D */
}IfxScrSsc_InputSel;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_ScrSsc_Std_DataStructures
 * \{ */
/** \brief SSC configuration structure
 */
typedef struct
{
    uint8               mode;                   /* SSC mode of operation Master and Slave */
    IfxScrSsc_DataWidth dataWidth;              /* Data width to be sent in one SPI transfer */
    uint8               txDataOrientation;      /* Set IfxScrSsc_dataOrientation_msbFirst -->  Tx/Rx must start from MSB.*/
                                                /* Set IfxScrSsc_dataOrientation_lsbFirst -->  Tx/Rx must start from LSB.*/
    uint8               shiftClockPhase;        /* Set IfxScrSsc_ClockPhase_latchOnLeadingEdge --> latch receive data on the leading clock edge, shift on trailing edge,
                                                 *  Set IfxScrSsc_ClockPhase_latchOnTrailingEdge --> Shift transmit data on the leading clock edge, latch on trailing edge*/
    uint8               shiftClockPolarity;     /* Clock Polarity - Signal levels in idle mode and definition of leading and trailing edges. Following are the options available:
                                                 * Set IfxScrSsc_ClockPolarity_idleLow - Idle clock line is low, leading clock edge is low-to-high transition.
                                                 * Set TrIfxScrSsc_ClockPolarity_idleHighue  - Idle clock line is high, leading clock edge is high-to-low transition.
                                                 */
    boolean enableLoopback;                     /* Loopback feature. Options are TRUE and FALSE */
    boolean enableTransmitBufferReadyInterrupt; /* Set True --> Enable interrupt to indicate that transmit buffer can be reloaded with new data.*/
    boolean enableDataReceivedInterrupt;        /* Set True --> Enable interrupt on data rxThe configured number of bits has been transmitted and shifted to the
                                                 * receive buffer.*/
    boolean enableReceiveFifoFullInterrupt;     /* Set True --> Enable interrupt in case FIFO gets filled.*/
    boolean enableReceiveFifoEmptyInterrupt;    /* Set True --> Enable interrupt in case FIFO gets empty.*/
    boolean enableReceiveErrorInterrupt;        /* Set Tre --> Enable interrupt in case new data frame is completely received while the FIFO is full.*/
    boolean enableTransmitErrorInterrupt;       /* Set True --> Enable interrupt in case corrupted data is sent.This is a slave-only interrupt.Options are TRUE and FALSE*/
    boolean enableBaudrateErrorInterrupt;       /* Set True --> Enable interrupt in case incoming clock signal deviates from the
                                                 * programmed baud-rate by more than 100%.This is a slave-only interrupt.*/
    uint32  baudrate;                           /* Baudrate (in bits per second) */
}IfxScrSsc_Config;

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_ScrSsc_Std_init
 * \{ */

/** \brief Configures SSC.After calling this API the user has to enter the Operating Mode by calling IfxScrSsc_enterOperationMode().
 * \param sscConfig SSC configuration structure
 * \return None
 */

IFX_INLINE void IfxScrSsc_initModule(IfxScrSsc_Config *sscConfig);

/** \brief Configure SSC baudrate
 * \param baudrate The baudrate(in baud per sec) to be set.Note that there might be deviations
 * \return None
 */

IFX_INLINE void IfxScrSsc_setBaudrate(uint32 baudrate);

/** \brief Queries status of the specified event
 * \param event The event whose status is to be queried.Following are the options:
 *              IfxScrSsc_Event_transmitError
 *              IfxScrSsc_Event_receiveError
 *              IfxScrSsc_Event_receiveFifoEmpty
 *              IfxScrSsc_Event_baudrateErro 3
 *              IfxScrSsc_Event_busy
 *              IfxScrSsc_Event_receiveFifoFull
 * \return Status of the event.TRUE implies ocuurence/ongoing of event.FALSE implies non-occurence/end of event
 */

IFX_INLINE boolean IfxScrSsc_getStatus(IfxScrSsc_Event event);

/** \brief Enters Operation mode.Required for transmission and reception
 * \return None
 */

IFX_INLINE void IfxScrSsc_enterOperationMode(void);

/** \brief Enters Programming mode.Required for configuring SSC(including baudrate)
 * \return None
 */

IFX_INLINE void IfxScrSsc_enterProgrammingMode(void);

/** \brief Function to set master mode receive input
 * \param input Input selection
 * \return None
 */
IFX_INLINE void IfxScrSsc_setMasterModeRxInput(IfxScrSsc_InputSel input);

/** \brief Function to set slave mode receive input
 * \param input Input selection
 * \return None
 */
IFX_INLINE void IfxScrSsc_setSlaveModeRxInput(IfxScrSsc_InputSel input);

/** \brief Function to set slave mode clock input
 * \param input Input selection
 * \return None
 */
IFX_INLINE void IfxScrSsc_setSlaveModeClockInput(IfxScrSsc_InputSel input);

/** \} */

/** \addtogroup IfxLld_ScrSsc_Std_TxFunctionality
 * \{ */

/** \brief Function to  transmit data.
 * \param data Data to be transmitted
 * \return None
 */

IFX_INLINE void IfxScrSsc_startTx(uint8 data);

/** \brief Queries whether the Tx Buffer(SSC_TBL) is ready to accept new data for transmission.
 * \return Status of Transmit Buffer.TRUE - Ready and new data may be loaded using IfxScrSsc_startTx(). FALSE - Buffer not ready for new data.
 */

IFX_INLINE boolean IfxScrSsc_isTransmitBufferReady(void);

/** \brief Clears the Tx Buffer(SSC_TBL) flag.
 * \return None
 */

IFX_INLINE void IfxScrSsc_clearTransmitBufferReadyFlag(void);

/** \} */

/** \addtogroup IfxLld_ScrSsc_Std_RxFunctionality
 * \{ */

/** \brief Reads out data rom Rx FIFO
 * \return Rx data.Depending on the data-width selected, masking of additional bits may be required.
 */

IFX_INLINE uint8 IfxScrSsc_getRxData(void);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScrSsc_initModule(IfxScrSsc_Config *sscConfig)
{
    /*Enter Programming Mode
     * Both will write to the same address as both will evaluate to (*(__sfr volatile uint8*)(0x8a)).So shouldn't matter. Still Confirm with Eswar:which amongst the two to be done.*/
    SCR_SSC_CONOH.U &= 0x7F;
    SCR_SSC_CONPH.U &= 0x7F;

    SCR_SSC_CONPL.U  = (sscConfig->dataWidth) | (sscConfig->txDataOrientation << IFX_SCR_SSC_CONPL_HB_OFF) | (sscConfig->shiftClockPhase << IFX_SCR_SSC_CONPL_PH_OFF) | (sscConfig->shiftClockPolarity << IFX_SCR_SSC_CONPL_PO_OFF) | (sscConfig->enableLoopback << IFX_SCR_SSC_CONPL_LB_OFF);

    /* Bitfield SCR_SSC_CONPH.EN is not required to be as for programming it needs to be 0. */
    SCR_SSC_CONPH.U = (sscConfig->enableTransmitErrorInterrupt) | (sscConfig->enableReceiveErrorInterrupt << IFX_SCR_SSC_CONPH_REN_OFF) | (sscConfig->enableBaudrateErrorInterrupt << IFX_SCR_SSC_CONPH_BEN_OFF) | (sscConfig->mode << IFX_SCR_SSC_CONPH_MS_OFF);

    SCR_IR_PAGE.U   = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    SCR_IR_MODIEN.U = (sscConfig->enableTransmitErrorInterrupt | (sscConfig->enableReceiveErrorInterrupt | sscConfig->enableBaudrateErrorInterrupt) | (sscConfig->enableTransmitBufferReadyInterrupt << IFX_SCR_IR_MODIEN_TIREN_OFF) | (sscConfig->enableDataReceivedInterrupt << IFX_SCR_IR_MODIEN_RIREN_OFF) | (sscConfig->enableReceiveFifoEmptyInterrupt << IFX_SCR_IR_MODIEN_RFEIEN_OFF) | (sscConfig->enableReceiveFifoFullInterrupt << IFX_SCR_IR_MODIEN_RFFIEN_OFF));

    float br = ((10000000 / (sscConfig->baudrate)) - 0.5);
    SCR_SSC_BRL.U = (uint8)((uint16)br & 0x00FFU);
    SCR_SSC_BRH.U = (uint8)(((uint16)br & 0xFF00) >> 8u);
}


IFX_INLINE void IfxScrSsc_setBaudrate(uint32 baudrate)
{
    /* Both should work as both evaluate to (*(__sfr volatile uint8*)(0x8a)). Confirm with Eswar once and check which one to keep */
    SCR_SSC_CONOH.U &= ~(1u << IFX_SCR_SSC_CONOH_EN_OFF);
    SCR_SSC_CONPH.U &= ~(1u << IFX_SCR_SSC_CONPH_EN_OFF);
    /*
     * br = ((20000000/2*baudrate) - 1.0)+0.5
     * 0.5 added for rounding off
     * */

    float br = ((10000000 / baudrate) - 0.5);
    SCR_SSC_BRL.U = (uint8)((uint16)br & 0x00FFU);
    SCR_SSC_BRH.U = (uint8)(((uint16)br & 0xFF00) >> 8u);
}


IFX_INLINE boolean IfxScrSsc_getStatus(IfxScrSsc_Event event)
{
    return (boolean)((SCR_SSC_CONOH.U & (1u << event)) >> event);
}


IFX_INLINE void IfxScrSsc_startTx(uint8 data)
{
    /* Write data to SSC_TBL to trigger transmission */
    SCR_SSC_TBL.U = data;
}


IFX_INLINE uint8 IfxScrSsc_getRxData(void)
{
	/* Assembly code is used because compiler generated assembly
	 * contained MOV R,direct which took 2 cycles. Result was wrong
	 * behaviour when FIFO was read. First read data is lost and second
	 * is moved to the destination.
	 */
	uint8 var;
	__asm(" mov\t A, 140\n"
		  " mov\t %0,A ":"=d"(var));
	return var;
}


IFX_INLINE void IfxScrSsc_enterOperationMode(void)
{
    /* Both should work as both evaluate to (*(__sfr volatile uint8*)(0x8a)). Confirm with Eswar once and check which one to keep */
    SCR_SSC_CONOH.U |= (1u << IFX_SCR_SSC_CONOH_EN_OFF);
    SCR_SSC_CONPH.U |= (1u << IFX_SCR_SSC_CONPH_EN_OFF);

    /* Inserting required delay before loading SSC_TBL register */
    uint8 i;

    for (i = 0; i < 4; i++)
    {
        __asm("nop\n");
    }
}


IFX_INLINE void IfxScrSsc_enterProgrammingMode(void)
{
    /* Both should work as both evaluate to (*(__sfr volatile uint8*)(0x8a)). Confirm with Eswar once and check which one to keep */
    SCR_SSC_CONOH.U &= ~(1u << IFX_SCR_SSC_CONOH_EN_OFF);
    SCR_SSC_CONPH.U &= ~(1u << IFX_SCR_SSC_CONPH_EN_OFF);
}


IFX_INLINE void IfxScrSsc_setMasterModeRxInput(IfxScrSsc_InputSel input)
{
    SCR_SCU_PAGE.U      = (SCR_SCU_PAGE.U & (uint8)0xF8U) | (uint8)(0x02);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x2))
    {}
    SCR_SCU_MODPISEL1.U = ((SCR_SCU_MODPISEL1.U & ~(IFX_SCR_SCU_MODPISEL1_MIS_MSK << IFX_SCR_SCU_MODPISEL1_MIS_OFF)) | \
                           (uint8)(input << IFX_SCR_SCU_MODPISEL1_MIS_OFF));
}


IFX_INLINE void IfxScrSsc_setSlaveModeRxInput(IfxScrSsc_InputSel input)
{
    SCR_SCU_PAGE.U      = (SCR_SCU_PAGE.U & (uint8)0xF8U) | (uint8)(0x02);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x2))
    {}
    SCR_SCU_MODPISEL1.U = ((SCR_SCU_MODPISEL1.U & ~(IFX_SCR_SCU_MODPISEL1_SIS_MSK << IFX_SCR_SCU_MODPISEL1_SIS_OFF)) | \
                           (uint8)(input << IFX_SCR_SCU_MODPISEL1_SIS_OFF));
}


IFX_INLINE void IfxScrSsc_setSlaveModeClockInput(IfxScrSsc_InputSel input)
{
    SCR_SCU_PAGE.U      = (SCR_SCU_PAGE.U & (uint8)0xF8U) | (uint8)(0x02);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x2))
    {}
    SCR_SCU_MODPISEL1.U = ((SCR_SCU_MODPISEL1.U & ~(uint8)(IFX_SCR_SCU_MODPISEL1_CIS_MSK << IFX_SCR_SCU_MODPISEL1_CIS_OFF)) | \
                           (uint8)(input << IFX_SCR_SCU_MODPISEL1_CIS_OFF));
}


IFX_INLINE boolean IfxScrSsc_isTransmitBufferReady(void)
{
    SCR_IR_PAGE.U = SCR_IR_PAGE.U & (uint8)0xF8U;
    return (boolean)((SCR_IR_CON1.U & (1u << IFX_SCR_IR_CON1_TIR_OFF)) >> IFX_SCR_IR_CON1_TIR_OFF);
}


IFX_INLINE void IfxScrSsc_clearTransmitBufferReadyFlag(void)
{
    SCR_IR_PAGE.U = SCR_IR_PAGE.U & (uint8)0xF8U;
    SCR_IR_CON1.U = SCR_IR_CON1.U & ~(1u << IFX_SCR_IR_CON1_TIR_OFF);
}


#endif /* IFXSCRSSC_H */
