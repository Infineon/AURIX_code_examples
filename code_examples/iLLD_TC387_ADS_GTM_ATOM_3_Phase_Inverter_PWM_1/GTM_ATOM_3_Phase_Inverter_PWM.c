/**********************************************************************************************************************
 * \file GTM_ATOM_3_Phase_Inverter_PWM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "GTM_ATOM_3_Phase_Inverter_PWM.h"
#include "Ifx_Types.h"
#include "IfxGtm_Pwm.h"
#include "IfxPort.h"
#include "IfxPort_Pinmap.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define NUM_OF_CHANNELS         (3)                                    /* Number of PWM complementary pairs          */
#define PWM_FREQUENCY           (20.0E3)                               /* PWM frequency in [Hz]                      */
#define ISR_PRIORITY_ATOM       (20)                                   /* Interrupt priority number                  */

#define PHASE_U_HS              &IfxGtm_ATOM1_0_TOUT0_P02_0_OUT        /* Pin which will be driven by the PWM, P02.0 */
#define PHASE_U_LS              &IfxGtm_ATOM1_0N_TOUT7_P02_7_OUT       /* Pin which will be driven by the PWM, P02.7 */
#define PHASE_V_HS              &IfxGtm_ATOM1_1_TOUT1_P02_1_OUT        /* Pin which will be driven by the PWM, P02.1 */
#define PHASE_V_LS              &IfxGtm_ATOM1_1N_TOUT4_P02_4_OUT       /* Pin which will be driven by the PWM, P02.4 */
#define PHASE_W_HS              &IfxGtm_ATOM1_2_TOUT2_P02_2_OUT        /* Pin which will be driven by the PWM, P02.2 */
#define PHASE_W_LS              &IfxGtm_ATOM1_2N_TOUT5_P02_5_OUT       /* Pin which will be driven by the PWM, P02.5 */

#define PHASE_U_DUTY            (25.0f)                                /* Initial PWM duty cycle of phase U in [%]   */
#define PHASE_V_DUTY            (50.0f)                                /* Initial PWM duty cycle of phase V in [%]   */
#define PHASE_W_DUTY            (75.0f)                                /* Initial PWM duty cycle of phase W in [%]   */
#define PHASE_DUTY_STEP         (10.0f)                                /* PWM duty cycle step in [%]                 */

#define LED                     &MODULE_P13, 0       /* LED which will be toggled in Interrupt Service Routine (ISR) */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
typedef struct
{
        IfxGtm_Pwm          pwm;                                /* PWM Driver handle                                 */
        IfxGtm_Pwm_Channel  channels[NUM_OF_CHANNELS];          /* Array containing channel data after configuration */
        float32             dutyCycles[NUM_OF_CHANNELS];        /* Duty Cycle values to hold                         */
        float32             phases[NUM_OF_CHANNELS];            /* PhaseShift values to hold                         */
        IfxGtm_Pwm_DeadTime deadTimes[NUM_OF_CHANNELS];         /* PhaseShift values to hold                         */
} GtmAtom3phInv;

IFX_STATIC GtmAtom3phInv g_gtmAtom3phInv;

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define the Interrupt Service Routine. */
IFX_INTERRUPT(interruptGtmAtom, 0, ISR_PRIORITY_ATOM);

/* Interrupt Service Routine of the ATOM */
void interruptGtmAtom(void)
{
    IfxPort_togglePin(LED);                                                      /* Toggle the LED                   */
}

/* Period interrupt callback function */
void IfxGtm_periodEventFunction(void *data)
{

}

/* This function initializes the ATOM */
void initGtmAtom3phInv(void)
{
    /* Configuration variables
     * Neither application (in most of the cases) nor the PWM driver need configuration variables post initialization.
     * It is recommended to define such variables within the function (local), alternatively such structures could
     * also be initialized (element-wise) as constant (in FLASH)
     */
    IfxGtm_Pwm_Config config;                                /* Main PWM configuration structure                     */
    IfxGtm_Pwm_ChannelConfig channelConfig[NUM_OF_CHANNELS]; /* Array containing configuration for each channel      */
    IfxGtm_Pwm_DtmConfig dtmConfig[NUM_OF_CHANNELS];         /* Only needed if using DTM module                      */
    IfxGtm_Pwm_InterruptConfig interruptConfig;              /* Only needed if using interrupt. Can also be an array */
    IfxGtm_Pwm_OutputConfig output[NUM_OF_CHANNELS];         /* Only needed if connected to pin                      */

    /* 1. Configuration structure initialization
     * If the configuration structure is located in the RAM, the initConfig API would be handy to initialize the
     * elements to their default values
     */
    IfxGtm_Pwm_initConfig(&config, &MODULE_GTM);

    /* 2. Output configuration
     * Output configurations are optional.
     */

    /* CH0 configurations */
    output[0].pin                   = (IfxGtm_Pwm_ToutMap*)PHASE_V_HS;          /* Phase V PWM High-side             */
    output[0].complementaryPin      = (IfxGtm_Pwm_ToutMap*)PHASE_V_LS;          /* Phase V PWM Low-side              */
    output[0].polarity              = Ifx_ActiveState_high;                     /* Active low/high of pin            */
    output[0].complementaryPolarity = Ifx_ActiveState_low;                      /* Active low/high of pin            */
    output[0].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[0].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH1 configurations */
    output[1].pin                   = (IfxGtm_Pwm_ToutMap*)PHASE_U_HS;          /* Phase U PWM High-side             */
    output[1].complementaryPin      = (IfxGtm_Pwm_ToutMap*)PHASE_U_LS;          /* Phase U PWM Low-side              */
    output[1].polarity              = Ifx_ActiveState_high;                     /* Active low/high of pin            */
    output[1].complementaryPolarity = Ifx_ActiveState_low;                      /* Active low/high of pin            */
    output[1].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[1].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH2 configurations */
    output[2].pin                   = (IfxGtm_Pwm_ToutMap*)PHASE_W_HS;          /* Phase W PWM High-side             */
    output[2].complementaryPin      = (IfxGtm_Pwm_ToutMap*)PHASE_W_LS;          /* Phase W PWM Low-side              */
    output[2].polarity              = Ifx_ActiveState_high;                     /* Active low/high of pin            */
    output[2].complementaryPolarity = Ifx_ActiveState_low;                      /* Active low/high of pin            */
    output[2].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[2].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* 3. Dead-time configuration */

    dtmConfig[0].deadTime.rising    = 1e-6f;                /* Rising Dead time in seconds                           */
    dtmConfig[0].deadTime.falling   = 1e-6f;                /* Falling Dead time in seconds                          */

    dtmConfig[1].deadTime.rising    = 1e-6f;                /* Rising Dead time in seconds                           */
    dtmConfig[1].deadTime.falling   = 1e-6f;                /* Falling Dead time in seconds                          */

    dtmConfig[2].deadTime.rising    = 1e-6f;                /* Rising Dead time in seconds                           */
    dtmConfig[2].deadTime.falling   = 1e-6f;                /* Falling Dead time in seconds                          */

    /* 4. [Optional] Interrupt configuration, Example configuration of interrupt for base channel                    */

    interruptConfig.mode          = IfxGtm_IrqMode_pulseNotify;  /* IRQ mode of interrupt                            */
    interruptConfig.isrProvider   = IfxSrc_Tos_cpu0;             /* Type of Service                                  */
    interruptConfig.priority      = ISR_PRIORITY_ATOM;           /* Interrupt priority                               */
    /* Connect callback function for period event interrupt */
    interruptConfig.periodEvent   = IfxGtm_periodEventFunction;
    interruptConfig.dutyEvent     = NULL_PTR;                /* Do not duty event interrupt                          */

    /*5. Channel configuration */
    /*Base channel - CH0 configuration. */
    channelConfig[0].timerCh      = IfxGtm_Pwm_SubModule_Ch_0;   /* Atom channel index to be used for sync channel   */
    channelConfig[0].phase        = 0.0f;                        /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                  * only for edge aligned sync channels)             */
    channelConfig[0].duty         = PHASE_V_DUTY;                /* PWM duty in % (range: 0.0 .. 100.0)              */
    channelConfig[0].dtm          = &dtmConfig[0];               /* Dead time configuration for this channel         */
    channelConfig[0].output       = &output[0];                  /* Pin connections and polarities for this channel  */
    channelConfig[0].mscOut       = NULL_PTR;                    /* MSC configuration for this channel               */
    channelConfig[0].interrupt    = &interruptConfig;            /* Attach Interrupt configuration for this channel  */

    /* Sync channel - CH1 configuration */
    channelConfig[1].timerCh      = IfxGtm_Pwm_SubModule_Ch_1;   /* Atom channel index to be used for base channel   */
    channelConfig[1].phase        = 0.0f;                        /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                  * only for edge aligned sync channels)             */
    channelConfig[1].duty         = PHASE_U_DUTY;                /* PWM duty in % (range: 0.0 .. 100.0) */
    channelConfig[1].dtm          = &dtmConfig[1];               /* Attach Dead time configuration for this channel  */
    channelConfig[1].output       = &output[1];                  /* Pin connections and polarities for this channel  */
    channelConfig[1].mscOut       = NULL_PTR;                    /* MSC configuration for this channel               */
    channelConfig[1].interrupt    = NULL_PTR;                    /* Interrupt configuration for this channel         */

    /*Sync channel CH2 configuration.*/
    channelConfig[2].timerCh      = IfxGtm_Pwm_SubModule_Ch_2;   /* Atom channel index to be used for sync channel   */
    channelConfig[2].phase        = 0.0f;                        /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                  * only for edge aligned sync channels)             */
    channelConfig[2].duty         = PHASE_W_DUTY;                /* PWM duty in % (range: 0.0 .. 100.0)              */
    channelConfig[2].dtm          = &dtmConfig[2];               /* Dead time configuration for this channel         */
    channelConfig[2].output       = &output[2];                  /* Pin connections and polarities for this channel  */
    channelConfig[2].mscOut       = NULL_PTR;                    /* MSC configuration for this channel               */
    channelConfig[2].interrupt    = NULL_PTR;                    /* Interrupt configuration for this channel         */

    /* 6. Other configurations */

    config.cluster                = IfxGtm_Cluster_1;                  /* Cluster                                    */
    config.subModule              = IfxGtm_Pwm_SubModule_atom;         /* Sub module                                 */
    config.alignment              = IfxGtm_Pwm_Alignment_center;       /* Alignment                                  */
    config.syncStart              = TRUE;                              /* Start all channels after init              */
    config.numChannels            = NUM_OF_CHANNELS;                   /* Number of channels configured              */
    config.channels               = channelConfig;                     /* Attach Channel configuration               */
    config.frequency              = PWM_FREQUENCY;                     /* PWM frequency                              */
    config.clockSource.atom       = IfxGtm_Cmu_Clk_0;                  /* Clock source for atom                      */
    config.dtmClockSource         = IfxGtm_Dtm_ClockSource_cmuClock0;  /* Clock source for dtm                       */
    config.syncUpdateEnabled      = TRUE;                              /* TRUE: Update compare registers from shadow
                                                                        * at the end of period */

    /* 7. Call the init function */

    if(!IfxGtm_isEnabled(&MODULE_GTM))
    {
        float32 frequency;
        /* Enable GTM, it is necessary if the GTM is not initialized earlier */
        IfxGtm_enable(&MODULE_GTM);

        frequency = IfxGtm_Cmu_getModuleFrequency(&MODULE_GTM);
        /* Set the global clock frequency to the max */
        IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, frequency);
        /* Set the CMU CLK0 */
        IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, frequency);
        /* Enable the FXU clock */
        IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);
    }

    IfxGtm_Pwm_init(&g_gtmAtom3phInv.pwm, &g_gtmAtom3phInv.channels[0], &config);

    /* 8. Store the current duty values and dead-times for runtime calls */
    g_gtmAtom3phInv.dutyCycles[0]= channelConfig[0].duty;
    g_gtmAtom3phInv.dutyCycles[1]= channelConfig[1].duty;
    g_gtmAtom3phInv.dutyCycles[2]= channelConfig[2].duty;
    g_gtmAtom3phInv.deadTimes[0]= channelConfig[0].dtm->deadTime;
    g_gtmAtom3phInv.deadTimes[1]= channelConfig[1].dtm->deadTime;
    g_gtmAtom3phInv.deadTimes[2]= channelConfig[2].dtm->deadTime;

    IfxPort_setPinModeOutput(LED, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);   /* Set pin mode         */
}

/* This function update duty cycles */
void updateGtmAtom3phInvDuty(void)
{
    g_gtmAtom3phInv.dutyCycles[0] += PHASE_DUTY_STEP;                       /* Increment PWM duty cycle of phase U   */
    g_gtmAtom3phInv.dutyCycles[1] += PHASE_DUTY_STEP;                       /* Increment PWM duty cycle of phase V   */
    g_gtmAtom3phInv.dutyCycles[2] += PHASE_DUTY_STEP;                       /* Increment PWM duty cycle of phase W   */

    if((g_gtmAtom3phInv.dutyCycles[0] + PHASE_DUTY_STEP) >= 100)
    {
        g_gtmAtom3phInv.dutyCycles[0] = 0;                                 /* Set duty to zero                       */
    }
    if((g_gtmAtom3phInv.dutyCycles[1] + PHASE_DUTY_STEP) >= 100)
    {
        g_gtmAtom3phInv.dutyCycles[1] = 0;                                 /* Set duty to zero                       */
    }
    if((g_gtmAtom3phInv.dutyCycles[2] + PHASE_DUTY_STEP) >= 100)
    {
        g_gtmAtom3phInv.dutyCycles[2] = 0;                                  /* Set duty to zero                      */
    }

    /* Update duty of all configured channels to requested values immediately */
    IfxGtm_Pwm_updateChannelsDutyImmediate(&g_gtmAtom3phInv.pwm, (float32*)g_gtmAtom3phInv.dutyCycles);
}
