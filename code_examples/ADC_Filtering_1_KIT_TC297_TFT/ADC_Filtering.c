/**********************************************************************************************************************
 * \file ADC_Filtering.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "ADC_Filtering.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* ADC parameters */
#define CHANNELS_NUM                4       /* Number of used channels                                              */
#define GROUPS_NUM                  2       /* Number of used groups                                                */

#define DMM_DATA_REDUCTION          0x0     /* Value of DMM bit field to set Standard Data Reduction Mode           */
#define DMM_RESULT_FILTERING        0x1     /* Value of DMM bit field to set Result Filtering Mode                  */
#define DRCTR_DATA_REDUCTION        0x3     /* Value of DRCTR to accumulate 4 conversions                           */
#define DRCTR_FIR_COEFF             0x4     /* Value of DRCTR to apply a FIR filter with coefficients a=1, b=0, c=2 */
#define DRCTR_IIR_COEFF             0xF     /* Value of DRCTR to apply a IIR filter with coefficients a=3, b=4      */

/* Possible values for FIR/IIR filter coefficients:
 * --------------------------------------------------------------------------------------------------------
 * |          Average filter          | * |          FIR filter         | * |         IIR filter          |
 * ------------------------------------ * ------------------------------- * -------------------------------
 * | DMM | DRCTR | Accumulated values | * | DMM | DRCTR | COEFFICIENTS  | * | DMM | DRCTR | COEFFICIENTS  |
 * ------------------------------------ * ------------------------------- * -------------------------------
 * | 0x0 |  0x0  | Disabled           | * | 0x1 |  0x0  | a=2, b=1, c=0 | * | 0x1 |  0xE  | a=2, b=2      |
 * | 0x0 |  0x1  | 2 results average  | * | 0x1 |  0x1  | a=1, b=2, c=0 | * |>0x1 |  0xF  | a=3, b=4      |
 * | 0x0 |  0x2  | 3 results average  | * | 0x1 |  0x2  | a=2, b=0, c=1 | * |     |       |               |
 * |>0x0 |  0x3  | 4 results average  | * | 0x1 |  0x3  | a=1, b=1, c=1 | * |     |       |               |
 * |     |       |                    | * |>0x1 |  0x4  | a=1, b=0, c=2 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x5  | a=3, b=1, c=0 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x6  | a=2, b=2, c=0 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x7  | a=1, b=3, c=0 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x8  | a=3, b=0, c=1 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0x9  | a=2, b=1, c=1 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xA  | a=1, b=2, c=1 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xB  | a=2, b=0, c=2 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xC  | a=1, b=1, c=2 | * |     |       |               |
 * |     |       |                    | * | 0x1 |  0xD  | a=1, b=0, c=3 | * |     |       |               |
 * --------------------------------------------------------------------------------------------------------
 *
 * When selecting different coefficients, make sure to set the correct DIV_FACTOR.
 */

/* UART parameters */
#define ISR_PRIORITY_ASCLIN_TX      10      /* Priority of the interrupt ISR Transmit                               */
#define ISR_PRIORITY_ASCLIN_RX      20      /* Priority of the interrupt ISR Receive                                */
#define ISR_PRIORITY_ASCLIN_ER      30      /* Priority of the interrupt ISR Errors                                 */

#define ASC_TX_BUFFER_SIZE          64      /* UART transmission buffer size in bytes                               */
#define ASC_RX_BUFFER_SIZE          64      /* UART reception buffer size in bytes                                  */
#define ASC_PRESCALER               1       /* Division ratio of the predivider for UART communication              */
#define ASC_BAUDRATE                115200  /* Baud rate of the ASCLIN UART communication                           */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void initVADCModule(void);                  /* Function to initialize the VADC module with default parameters       */
void initVADCGroups(void);                  /* Function to initialize the VADC group                                */
void initVADCChannels(void);                /* Function to initialize the VADC used channels                        */
void applyFiltering(void);                  /* Function to apply the filters to the VADC channels                   */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Variables for the VADC */
IfxVadc_Adc g_vadc;                                     /* Global variable for configuring the VADC module          */
IfxVadc_Adc_Group g_vadcGroup[GROUPS_NUM];              /* Global array for configuring the VADC groups             */
IfxVadc_Adc_Channel g_vadcChannel[CHANNELS_NUM];        /* Global array for configuring the VADC channels           */

channel g_chn[] = { {&IfxVadc_G0_0_AN0_IN, (IfxVadc_ChannelResult) 0  },   /* AN0 pin    (Average filter channel)   */
                    {&IfxVadc_G0_2_AN2_IN, (IfxVadc_ChannelResult) 7  },   /* AN2 pin    (FIR filter channel)       */
                    {&IfxVadc_G0_3_AN3_IN, (IfxVadc_ChannelResult) 15 },   /* AN3 pin    (IIR filter channel)       */
                    {&IfxVadc_G1_0_AN8_IN, (IfxVadc_ChannelResult) 1  }    /* AN8 pin    (No data modification)     */
};

/* Variables for UART */
IfxAsclin_Asc g_asc;                                    /* Global variable for configuring the ASCLIN module        */
IfxStdIf_DPipe g_stdInterface;                          /* Global variable for configuring the standard interface   */

/* The transfer buffers allocate memory for the data itself and for the FIFO runtime variables.
 * 8 more bytes have to be added to ensure a proper circular buffer handling independent from the address to which
 * the buffers have been located.
 */
uint8 g_AscTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 g_AscRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the VADC module */
void initADC(void)
{
    initVADCModule();                                                   /* Initialize the VADC module               */
    initVADCGroups();                                                   /* Initialize the VADC groups               */
    initVADCChannels();                                                 /* Initialize the used channels             */
    applyFiltering();                                                   /* Configure the Data Modification registers*/

    /* Start the scan */
    IfxVadc_Adc_startBackgroundScan(&g_vadc);
}

/* Function to initialize the VADC module with default parameters */
void initVADCModule(void)
{
    IfxVadc_Adc_Config adcConf;                                         /* Define a configuration structure         */
    IfxVadc_Adc_initModuleConfig(&adcConf, &MODULE_VADC);               /* Fill it with default values              */
    IfxVadc_Adc_initModule(&g_vadc, &adcConf);                          /* Apply the default configuration          */
}

/* Function to initialize the VADC groups */
void initVADCGroups(void)
{
    /* Initialize the groups */
    IfxVadc_Adc_GroupConfig adcGroupConf;                               /* Define a configuration structure         */
    IfxVadc_Adc_initGroupConfig(&adcGroupConf, &g_vadc);                /* Fill it with default values              */

    /* Enable the background scan source and the background auto scan functionality */
    adcGroupConf.arbiter.requestSlotBackgroundScanEnabled = TRUE;
    adcGroupConf.backgroundScanRequest.autoBackgroundScanEnabled = TRUE;

    /* Enable the gate in "always" mode (no edge detection) */
    adcGroupConf.backgroundScanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    /* Set the group 0 as master group */
    adcGroupConf.master = IfxVadc_GroupId_0;

    /* Initialize all the used groups with the same settings */
    uint8 grp;
    for(grp = 0; grp < GROUPS_NUM; grp++)
    {
        adcGroupConf.groupId = (IfxVadc_GroupId)grp;                    /* Select the group                         */

        /* Apply the configuration to the group, with group 0 as a master:
         * make sure that the index of the group in the array corresponds to the used group IDs
         */
        IfxVadc_Adc_initGroup(&g_vadcGroup[grp], &adcGroupConf);
    }

}

/* Function to initialize the used VADC channels */
void initVADCChannels(void)
{
    IfxVadc_Adc_ChannelConfig adcChannelConf;                   /* Configuration structure                          */

    uint16 chnNum;
    for(chnNum = 0; chnNum < CHANNELS_NUM; chnNum++)            /* The channels included in g_chn are initialized   */
    {
        /* Fill the configuration with default values */
        IfxVadc_Adc_initChannelConfig(&adcChannelConf, &g_vadcGroup[g_chn[chnNum].analogInput->groupId]);

        /* Set the channel ID and the corresponding result register */
        adcChannelConf.channelId = g_chn[chnNum].analogInput->channelId;
        adcChannelConf.resultRegister = g_chn[chnNum].resultRegister;
        adcChannelConf.backgroundChannel = TRUE;                /* Enable the background scan for the channel       */

        /* Apply the channel configuration */
        IfxVadc_Adc_initChannel(&g_vadcChannel[chnNum], &adcChannelConf);

        /* Add the channel to the background scan:
         * Set the the corresponding input channel of the respective group to be added in the background scan sequence
         */
        unsigned chnEnableBit = (1 << adcChannelConf.channelId);
        unsigned mask = chnEnableBit;
        IfxVadc_Adc_setBackgroundScan(&g_vadc, &g_vadcGroup[g_chn[chnNum].analogInput->groupId], chnEnableBit, mask);
    }

}

/* Function to apply the filters to the VADC channels */
void applyFiltering(void)
{
    /* Accumulate 4 result values within the result register before generating a final result for AN0 */
    VADC_G0_RCR0.B.DMM = DMM_DATA_REDUCTION;        /* Set the Data Modification Mode bit field to Standard Data Reduction */
    VADC_G0_RCR0.B.DRCTR = DRCTR_DATA_REDUCTION;    /* Configure the Result Register 0 of Group 0 to accumulate 4 conversions */

    /* Apply a 3rd order Finite Impulse Response Filter (FIR) to the result register G0RES7 (AN2) */
    VADC_G0_RCR7.B.DMM = DMM_RESULT_FILTERING;      /* Set the Data Modification Mode bit field to Result filtering mode */
    VADC_G0_RCR7.B.DRCTR = DRCTR_FIR_COEFF;         /* Configure the Result Register 7 of Group 0 to apply a FIR filter (a=1, b=0, c=2) */

    /* Apply a 1st order Infinite Impulse Response Filter (IIR) to the result register G0RES15 (AN3) */
    VADC_G0_RCR15.B.DMM = DMM_RESULT_FILTERING;     /* Set the Data Modification Mode bit field to Result filtering mode */
    VADC_G0_RCR15.B.DRCTR = DRCTR_IIR_COEFF;        /* Configure the Result Register 15 of Group 0 to apply an IIR filter (a=3, b=4) */
}

/* Function to read the VADC measurements */
uint16 readADCValue(uint8 channel)
{
    Ifx_VADC_RES conversionResult;                                      /* Variable to store the conversion result  */
    conversionResult.U = 0;                                             /* Initialize the value to 0                */

    /* Read ADC conversion until a valid one is read.
     * Since the AN0 pin is using the Standard Data Reduction mode, it is needed to check both the Valid Flag (VF == 1)
     * and the Data Reduction Counter (DRC == 0) bit fields to be sure that the read measurement is correct.
     */
    while(conversionResult.B.VF != 1 || conversionResult.B.DRC != 0)
    {
        conversionResult = IfxVadc_Adc_getResult(&g_vadcChannel[channel]);
    }

    return conversionResult.B.RESULT;
}

/* ASCLIN TX Interrupt Service Routine */
IFX_INTERRUPT(asclinTxISR, 0, ISR_PRIORITY_ASCLIN_TX);

void asclinTxISR(void)
{
    IfxStdIf_DPipe_onTransmit(&g_stdInterface);
}

/* ASCLIN RX Interrupt Service Routine */
IFX_INTERRUPT(asclinRxISR, 0, ISR_PRIORITY_ASCLIN_RX);

void asclinRxISR(void)
{
    IfxStdIf_DPipe_onReceive(&g_stdInterface);
}

/* ASCLIN Error Interrupt Service Routine */
IFX_INTERRUPT(asclinErISR, 0, ISR_PRIORITY_ASCLIN_ER);

void asclinErISR(void)
{
    IfxStdIf_DPipe_onError(&g_stdInterface);
}

/* Function that returns if new data is available */
boolean isDataAvailable(void)
{
    /* If new data is available, return true */
    if(IfxAsclin_Asc_getReadCount(&g_asc) > 0)
    {
        return TRUE;
    }
    else /* Else, return false */
    {
        return FALSE;
    }
}

/* Function to receive data over ASC */
void receiveData(char *data, Ifx_SizeT length)
{
    /* Receive data */
    IfxAsclin_Asc_read(&g_asc, data, &length, TIME_INFINITE);
}

/* Function to initialize the ASCLIN module */
void initUART(void)
{
    IfxAsclin_Asc_Config ascConf;

    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN0);

    /* Set the desired baud rate */
    ascConf.baudrate.prescaler = ASC_PRESCALER;
    ascConf.baudrate.baudrate = ASC_BAUDRATE;
    ascConf.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;            /* Set the oversampling factor      */

    /* Configure the sampling mode */
    ascConf.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;             /* Set the number of samples per bit*/
    ascConf.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;    /* Set the first sample position    */

    /* ISR priorities and interrupt target */
    ascConf.interrupt.txPriority = ISR_PRIORITY_ASCLIN_TX;
    ascConf.interrupt.rxPriority = ISR_PRIORITY_ASCLIN_RX;
    ascConf.interrupt.erPriority = ISR_PRIORITY_ASCLIN_ER;
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    /* FIFO configuration */
    ascConf.txBuffer = g_AscTxBuffer;
    ascConf.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConf.rxBuffer = g_AscRxBuffer;
    ascConf.rxBufferSize = ASC_RX_BUFFER_SIZE;

    /* Pin configuration */
    const IfxAsclin_Asc_Pins pins = {
            NULL, IfxPort_InputMode_pullUp,                                     /* CTS port pin not used            */
            &IfxAsclin0_RXA_P14_1_IN, IfxPort_InputMode_pullUp,                 /* RX port pin                      */
            NULL, IfxPort_OutputMode_pushPull,                                  /* RTS port pin not used            */
            &IfxAsclin0_TX_P14_0_OUT, IfxPort_OutputMode_pushPull,              /* TX port pin                      */
            IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;

    /* Initialize the module */
    IfxAsclin_Asc_initModule(&g_asc, &ascConf);

    /* Initialize the Standard Interface */
    IfxAsclin_Asc_stdIfDPipeInit(&g_stdInterface, &g_asc);
}
