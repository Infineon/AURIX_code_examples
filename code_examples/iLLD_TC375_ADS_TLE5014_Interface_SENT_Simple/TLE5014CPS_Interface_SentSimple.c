/**********************************************************************************************************************
 * \file TLE5014CPS_Interface_SentSimple.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxSent_Sent.h"
#include "IfxSent_PinMap.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Data Structures---------------------------------------------------*/
/*********************************************************************************************************************/

/*Data Structure to contain SENT communication errors*/
typedef struct
{
    uint32 rxOverflow;                   /* Count for Receive Buffer Overflow */
    uint32 txUnderflow;                  /* Count for Transmit Buffer Overflow error */
    uint32 errorFreqRange;               /* Count for Frequency Range error */
    uint32 errorFreqDrift;               /* Count for Frequency Drift error */
    uint32 errorWrongNumOfNibbles;       /* Count for Wrong Number of Nibbles error */
    uint32 errorNibbleValueRange;        /* Count for Wrong Nibble Value error */
    uint32 errorCrcFast;                 /* Count for CRC error for Fast Message */
    uint32 errorWrongStatusCom;          /* Count for Wrong Status Nibble */
    uint32 errorCrcSlowSerial;           /* Count for CRC error for Short Serial Message */
    uint32 errorWatchdog;                /* Count for Watchdog errors */
}TLE5014CPS_SENT_Errors;

/*Data Structure to contain Sensor Data*/
typedef struct
{
    IfxSent_Sent_Frame sentFrame;        /* Sent Frame data structure*/
    float32            angle;            /* Angle information after processing the received data*/
    float32            unitTime;         /* Unit time what is actually configured by the driver*/
    uint32             secureComError;   /* Count of secure communication, if occurs*/
    uint8              rollingCnt;       /* Rolling counter value that is to be updated*/
    boolean            hooked;           /* Are the driver and sensor synchronized? */
    TLE5014CPS_SENT_Errors  errors;
}TLE5014CPS_Data;

/* Bit-field Data Structure interpret SENT Message Frame*/
typedef union
{
    uint32 U;
    struct
    {
        uint32 ANGLE        :12;         /* BITS00:11 Angle Value*/
        uint32 ROL_COUNTER  :8;          /* BITS12:19 Rolling Counter*/
        uint32 INIBBLE      :4;          /* BITS19:23 Inverted Nibble*/
        uint32              :8;          /* BITS24:31 Unused two nibbles*/
    }B;
}TLE5014CPS_dataSENTMode;

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxSent_Sent g_sent;                                               /* module data for SENT */
IfxSent_Sent_Channel g_sentChannel_TLE5014CPS_0;                   /* SENT channel Data*/

TLE5014CPS_Data g_TLE5014CPS;                                      /* Sensor Data */

#define TLE5014CPS_SENT_TICK_TIME          3.0E-6                 /* TLE5014F16D is by default configured with 3.0us*/
#define TLE5014CPS_SENT_PIN                IfxSent_SENT7B_P00_8_IN/* SENT input pin*/
#define TLE5014CPS_SENT_INTPRIO            6                      /* Interrupt Priority*/
#define TLE5014CPS_ANGLE_DATA_CONST        360.0f/(1<<12)         /* Angle data constant that comes from sensor data sheet*/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

IFX_STATIC TLE5014CPS_dataSENTMode receivedData; /*Static data to be used for intermediate processing of received
                                                     information from sensor                                         */

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/* SENT initialization
 * This function initializes the SENT module
 */
void TLE5014CPS_Interface_Sent_doInit(void)
{
    /* Create module configuration */
    IfxSent_Sent_Config sentConfig;
    IfxSent_Sent_initModuleConfig(&sentConfig, TLE5014CPS_SENT_PIN.module);

    /* Initialize module */
    IfxSent_Sent_initModule(&g_sent, &sentConfig);

    /* Create channel configuration */
    IfxSent_Sent_ChannelConfig sentChannelConfig;
    IfxSent_Sent_initChannelConfig(&sentChannelConfig, &g_sent);

    /* define tUnit of the external sensor */
    sentChannelConfig.tUnit = TLE5014CPS_SENT_TICK_TIME;                         /*desired unit time*/
    sentChannelConfig.receiveControl.endPulseIgnored = FALSE;
    sentChannelConfig.receiveControl.crcModeDisabled = FALSE;
    sentChannelConfig.receiveControl.serialDataProcessingEnabled= FALSE;
    sentChannelConfig.receiveControl.extendedSerialFrameMode= IfxSent_ExtendedSerialFrameMode_standard;

    sentChannelConfig.receiveControl.frameLength = 6;
    sentChannelConfig.spcModeOn= FALSE;
    sentChannelConfig.transmitControl.triggerSource = IfxSent_TriggerSource_off;  /* start the SPC when sensor pulls
                                                                                     the signal low                  */

    /* The TLE5014 provides the nibbles in Big-endian order, Swap the nibbles 0 and 2 */
    sentChannelConfig.nibbleControl.nibblePointer0= IfxSent_Nibble_2;  /*Specifies receive data target nibble pointer to nibble 2*/
    sentChannelConfig.nibbleControl.nibblePointer1= IfxSent_Nibble_1;  /*Specifies receive data target nibble pointer to nibble 1*/
    sentChannelConfig.nibbleControl.nibblePointer2= IfxSent_Nibble_0;  /*Specifies receive data target nibble pointer to nibble 0*/
    sentChannelConfig.nibbleControl.nibblePointer3= IfxSent_Nibble_4;  /*Specifies receive data target nibble pointer to nibble 4*/
    sentChannelConfig.nibbleControl.nibblePointer4= IfxSent_Nibble_3;  /*Specifies receive data target nibble pointer to nibble 3*/
    sentChannelConfig.nibbleControl.nibblePointer5= IfxSent_Nibble_5;  /*Specifies receive data target nibble pointer to nibble 5*/

    /* ISR priorities and interrupt target */
    sentChannelConfig.interrupt.priority = TLE5014CPS_SENT_INTPRIO;    /*Specifies the interrupt priority*/
    sentChannelConfig.interrupt.isrProvider = IfxSrc_Tos_cpu0;

    sentChannelConfig.enabledInterrupts.enable.frequencyDriftErrorInterrupt= 0;
    sentChannelConfig.enabledInterrupts.enable.frequencyRangeErrorInterrupt= 0;


    const IfxSent_Sent_Pins sentPins =
    {
        &TLE5014CPS_SENT_PIN, IfxPort_InputMode_noPullDevice,                                   /* SENT input */
        NULL_PTR,  IfxPort_OutputMode_openDrain,                                               /* SPC output Not used*/
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };

    sentChannelConfig.pins = &sentPins;
    sentChannelConfig.channelId = TLE5014CPS_SENT_PIN.channelId;

    /* initialize channel */
    IfxSent_Sent_initChannel(&g_sentChannel_TLE5014CPS_0, &sentChannelConfig);

    MODULE_SENT.CH[7].INTEN.B.FRI= 0;
    MODULE_SENT.CH[7].INTEN.B.FDI= 0;
    MODULE_SENT.CH[7].INTEN.B.RBI= 0;

    g_TLE5014CPS.unitTime= IfxSent_getChannelUnitTime(g_sent.sent, g_sentChannel_TLE5014CPS_0.channelId);

}

/*Function to update the sent frame data*/
IFX_INLINE void TLE5014CPS_Interface_Sent_updateData(TLE5014CPS_Data *data)
{
    receivedData.U = g_TLE5014CPS.sentFrame.data;     /*stores the received information from sensor*/

    /*checking the rolling counter values with the updated values*/
    if(receivedData.B.ROL_COUNTER != data->rollingCnt)
    {
        if(!data->hooked)
        {
            /* Not hooked yet, first instance of check, expected to have difference with rolling counter             */
            data->hooked= TRUE;
        }
        else
        {
            /* There is a secure data validation */
            data->secureComError++;
        }
        data->rollingCnt= receivedData.B.ROL_COUNTER;
    }
    else
    {
        /* Secure communication is working, update angle */
        data->angle= receivedData.B.ANGLE * TLE5014CPS_ANGLE_DATA_CONST;
    }

    /* Update the rolling counter at receiver side */
    data->rollingCnt++;
    data->rollingCnt &= 0xFF;
}

/*Function to be used to retrieve the events which triggered the interrupt */
IFX_INTERRUPT(TLE5014CPS_Interface_Sent_serviceInterrupt, 0, TLE5014CPS_SENT_INTPRIO)
{
    Ifx_SENT_CH_INTSTAT status= IfxSent_Sent_getAndClearInterruptStatus(&g_sentChannel_TLE5014CPS_0);

    if((status.U & 0x7u) != 0)
    {
        /* No errors for received data */
        IfxSent_Sent_readChannelSerialDataFrame(&g_sentChannel_TLE5014CPS_0, &g_TLE5014CPS.sentFrame);
        TLE5014CPS_Interface_Sent_updateData(&g_TLE5014CPS);
    }

    if((status.B.FDI) != 0)
    {
         g_TLE5014CPS.errors.errorFreqDrift++;                                       /* Update frequency drift error */
    }

    if((status.B.CRCI) != 0)
    {
         g_TLE5014CPS.errors.errorCrcFast++;                                                     /* Update CRC error */
    }

    if((status.B.FRI) != 0)
    {
         g_TLE5014CPS.errors.errorFreqRange++;                                       /* Update frequency range error */
    }

    if((status.B.NNI) != 0)
    {
         g_TLE5014CPS.errors.errorWrongNumOfNibbles++;                       /* Update Wrong number of nibbles error */
    }

    if((status.B.NVI) != 0)
    {
         g_TLE5014CPS.errors.errorNibbleValueRange++;                             /* Update nibble value range error */
    }

    if((status.B.RBI) != 0)
    {
         g_TLE5014CPS.errors.rxOverflow++;                                   /* Update Receive buffer overflow error */
    }

    if((status.B.SCRI) != 0)
    {
         g_TLE5014CPS.errors.errorCrcSlowSerial++;                          /* Update CRC for slow serial data error */
    }

    if((status.B.TBI) != 0)
    {
         g_TLE5014CPS.errors.txUnderflow++;                                /* Update Transmit buffer underflow error */
    }

    if((status.B.WDI) != 0)
    {
         g_TLE5014CPS.errors.errorWatchdog++;                                               /* Update Watchdog error */
    }

    if((status.B.WSI) != 0)
    {
         g_TLE5014CPS.errors.errorWrongStatusCom++;                                     /* Update Wrong status error */
    }
}
