/**********************************************************************************************************************
 * \file SdCard_Read_Write.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "SdCard_Read_Write.h"
#include "serialio.h"
/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
char txData[200]="Write and read to/from an SDcard on the A2G_TC397XA_3V3_TFT Application Kit"
        "The SDMMC is configured in 4bit mode and the transfers are done using the SDMA and MultiBlock command";
char rxData[sizeof(txData)];

/*Configuration of UART pin and module*/
SERIALIO_t SERIALIO =
{
        .asclin = &MODULE_ASCLIN0,
        .tx_pin = &IfxAsclin0_TX_P14_0_OUT,
        .rx_pin = &IfxAsclin0_RXA_P14_1_IN
};

uint32 g_TickCount_1ms;
FATFS g_FatFs;
UINT Nb_Data=0;

BYTE work[FF_MAX_SS]; /* Work area (larger is better for processing time) */
FIL fil;        /* File object */
FRESULT fr;     /* FatFs return code */

uint64 stoptime, starttime, result=0;
/*********************************************************************************************************************/
/*----------------------------------------------Function Implementations---------------------------------------------*/
/*********************************************************************************************************************/
void Initializations()
{
    /* Initialize STM */
    IfxStm_CompareConfig stmCompareConfig;

    /* Suspend by debugger enabled */
    IfxStm_enableOcdsSuspend(&MODULE_STM0);

    /* Constructor of configuration */
    IfxStm_initCompareConfig(&stmCompareConfig);

    /* change the comparator configuration */
    stmCompareConfig.triggerPriority      = ISR_PRIORITY_OS_TICK;
    stmCompareConfig.comparatorInterrupt  = IfxStm_ComparatorInterrupt_ir0; /*User must select the interrupt output */
    stmCompareConfig.ticks                = IFX_CFG_STM_TICKS_PER_MS*10;    /* we start after 10ms */
    stmCompareConfig.typeOfService        = IfxSrc_Tos_cpu0;

    /* Now Compare functionality is initialized */
    IfxStm_initCompare(&MODULE_STM0, &stmCompareConfig);

    /* Initialize Serial Output */
    SERIALIO_Init(UART_BAUDRATE);
}
void Read_Write_File()
{
    /* Give a work area to the default drive */
    printf("Mount SD card: ");
    fr = f_mount(&g_FatFs, "", 0);
    print_result(fr);

    /* Write to a text file and close it, if file does not exist it will be created*/
    printf("Open file Message.txt: ");
    fr = f_open(&fil, "Message.txt", FA_OPEN_ALWAYS|FA_WRITE);
    print_result(fr);

    printf("Write the Message: ");
    fr = f_write(&fil, &txData, sizeof(txData), &Nb_Data);
    print_result(fr);
    fr = f_close(&fil);

    /*Reset the number of data to reuse for read operation*/
    Nb_Data=0;

    /* Read from a text file and close it*/
    printf("Read the message: ");
    fr = f_open(&fil, "Message.txt", FA_READ);
    fr = f_read(&fil, &rxData, sizeof(rxData), &Nb_Data);
    print_result(fr);
    fr = f_close(&fil);
    printf(rxData);

    return;
}


void print_result(FRESULT fr) {
    switch(fr) {
        case FR_OK:
            printf("Succeeded");
            break;
        case FR_DISK_ERR:
            printf("hard error occurred in the low level disk I/O layer");
            break;
        case FR_INT_ERR:
            printf("Assertion failed");
            break;
        case FR_NOT_READY:
            printf("The physical drive cannot work");
            break;
        case FR_NO_FILE:
            printf("Could not find the file");
            break;
        case FR_NO_PATH:
            printf("Could not find the path");
            break;
        case FR_INVALID_NAME:
            printf("The path name format is invalid");
            break;
        case FR_DENIED:
            printf("Access denied due to prohibited access or directory full");
            break;
        case FR_EXIST:
            printf("Access denied due to prohibited access");
            break;
        case FR_INVALID_OBJECT:
            printf("The file/directory object is invalid");
            break;
        case FR_WRITE_PROTECTED:
            printf("The physical drive is write protected");
            break;
        case FR_INVALID_DRIVE:
            printf("The logical drive number is invalid");
            break;
        case FR_NOT_ENABLED:
            printf("The volume has no work area");
            break;
        case FR_NO_FILESYSTEM:
            printf("There is no valid FAT volume");
            break;
        case FR_MKFS_ABORTED:
            printf("The f_mkfs() aborted due to any problem");
            break;
        case FR_TIMEOUT:
            printf("Could not get a grant to access the volume within defined period");
            break;
        case FR_LOCKED:
            printf("The operation is rejected according to the file sharing policy");
            break;
        case FR_NOT_ENOUGH_CORE:
            printf("LFN working buffer could not be allocated");
            break;
        case FR_TOO_MANY_OPEN_FILES:
            printf("Number of open files > FF_FS_LOCK");
            break;
        case FR_INVALID_PARAMETER:
            printf("Given parameter is invalid");
            break;
        default:
            printf("Unexpected error");
    }
    printf("\n\r");
}

IFX_INTERRUPT (UsrIsr_Stm_0, 0, ISR_PRIORITY_OS_TICK)
{
    /* Set next 1ms scheduler tick alarm */
    IfxStm_increaseCompare(&MODULE_STM0, IfxStm_Comparator_0, IFX_CFG_STM_TICKS_PER_MS);

    /*Increase tick count by 1ms*/
    g_TickCount_1ms++;

    /* Enable the global interrupts of this CPU */
    IfxCpu_enableInterrupts();

    /* action to do each 10ms */
    if ((g_TickCount_1ms % 10) == 0)
    {
        /*we call the disc timer procedure each 10ms to calculate the timeouts*/
        disk_timerproc();
    }
}
