/**
 * \file mmc_sdmmc.c
 * \brief MMC via SDMMC function definition for using with FAT FS sw package .
 *
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/*-----------------------------------------------------------------------*/
/* Low level disk I/O module skeleton for FatFs     (C)ChaN, 2016        */
/*-----------------------------------------------------------------------*/
/* If a working storage control module is available, it should be        */
/* attached to the FatFs via a glue function rather than modifying it.   */
/* This is an example of glue functions to attach various exsisting      */
/* storage control modules to the FatFs module with a defined API.       */
/*-----------------------------------------------------------------------*/

#include "configuration.h"

#ifdef MODULE_SDMMC0
/* if our device don't contains an SDMMC module we exclude this part from compiling */

#include "Sdmmc/Sd/IfxSdmmc_Sd.h"
#include "diskio.h"     /* FatFs lower layer API */
#include <Cpu/Std/IfxCpu.h>

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/
/* SD R2 response (CSD) */
#define SD_CSD_CSDVER(resp)             MMC_RSP_BITS((resp), 126, 2)
#define SD_CSD_CSDVER_1_0               0
#define SD_CSD_CSDVER_2_0               1
#define SD_CSD_TAAC(resp)               MMC_RSP_BITS((resp), 112, 8)
#define SD_CSD_TAAC_1_5_MSEC            0x26
#define SD_CSD_NSAC(resp)               MMC_RSP_BITS((resp), 104, 8)
#define SD_CSD_SPEED(resp)              MMC_RSP_BITS((resp), 96, 8)
#define SD_CSD_SPEED_25_MHZ             0x32
#define SD_CSD_SPEED_50_MHZ             0x5a
#define SD_CSD_CCC(resp)                MMC_RSP_BITS((resp), 84, 12)
#define SD_CSD_CCC_BASIC                (1 << 0)        /* basic */
#define SD_CSD_CCC_BR                   (1 << 2)        /* block read */
#define SD_CSD_CCC_BW                   (1 << 4)        /* block write */
#define SD_CSD_CCC_ERASE                (1 << 5)        /* erase */
#define SD_CSD_CCC_WP                   (1 << 6)        /* write protection */
#define SD_CSD_CCC_LC                   (1 << 7)        /* lock card */
#define SD_CSD_CCC_AS                   (1 << 8)        /*application specific*/
#define SD_CSD_CCC_IOM                  (1 << 9)        /* I/O mode */
#define SD_CSD_CCC_SWITCH               (1 << 10)       /* switch */
#define SD_CSD_READ_BL_LEN(resp)        MMC_RSP_BITS((resp), 80, 4)
#define SD_CSD_READ_BL_PARTIAL(resp)    MMC_RSP_BITS((resp), 79, 1)
#define SD_CSD_WRITE_BLK_MISALIGN(resp) MMC_RSP_BITS((resp), 78, 1)
#define SD_CSD_READ_BLK_MISALIGN(resp)  MMC_RSP_BITS((resp), 77, 1)
#define SD_CSD_DSR_IMP(resp)            MMC_RSP_BITS((resp), 76, 1)
#define SD_CSD_C_SIZE(resp)             MMC_RSP_BITS((resp), 62, 12)
#define SD_CSD_CAPACITY(resp)           ((SD_CSD_C_SIZE((resp))+1) << \
        (SD_CSD_C_SIZE_MULT((resp))+2))
#define SD_CSD_V2_C_SIZE(resp)          MMC_RSP_BITS((resp), 48, 22)
#define SD_CSD_V2_CAPACITY(resp)        ((SD_CSD_V2_C_SIZE((resp))+1) << 10)
#define SD_CSD_V2_BL_LEN                0x9     /* 512 */
#define SD_CSD_VDD_R_CURR_MIN(resp)     MMC_RSP_BITS((resp), 59, 3)
#define SD_CSD_VDD_R_CURR_MAX(resp)     MMC_RSP_BITS((resp), 56, 3)
#define SD_CSD_VDD_W_CURR_MIN(resp)     MMC_RSP_BITS((resp), 53, 3)
#define SD_CSD_VDD_W_CURR_MAX(resp)     MMC_RSP_BITS((resp), 50, 3)
#define SD_CSD_VDD_RW_CURR_100mA        0x7
#define SD_CSD_VDD_RW_CURR_80mA         0x6
#define SD_CSD_C_SIZE_MULT(resp)        MMC_RSP_BITS((resp), 47, 3)
#define SD_CSD_ERASE_BLK_EN(resp)       MMC_RSP_BITS((resp), 46, 1)
#define SD_CSD_SECTOR_SIZE(resp)        MMC_RSP_BITS((resp), 39, 7) /* +1 */
#define SD_CSD_WP_GRP_SIZE(resp)        MMC_RSP_BITS((resp), 32, 7) /* +1 */
#define SD_CSD_WP_GRP_ENABLE(resp)      MMC_RSP_BITS((resp), 31, 1)
#define SD_CSD_R2W_FACTOR(resp)         MMC_RSP_BITS((resp), 26, 3)
#define SD_CSD_WRITE_BL_LEN(resp)       MMC_RSP_BITS((resp), 22, 4)
#define SD_CSD_RW_BL_LEN_2G             0xa
#define SD_CSD_RW_BL_LEN_1G             0x9
#define SD_CSD_WRITE_BL_PARTIAL(resp)   MMC_RSP_BITS((resp), 21, 1)
#define SD_CSD_FILE_FORMAT_GRP(resp)    MMC_RSP_BITS((resp), 15, 1)
#define SD_CSD_COPY(resp)               MMC_RSP_BITS((resp), 14, 1)
#define SD_CSD_PERM_WRITE_PROTECT(resp) MMC_RSP_BITS((resp), 13, 1)
#define SD_CSD_TMP_WRITE_PROTECT(resp)  MMC_RSP_BITS((resp), 12, 1)
#define SD_CSD_FILE_FORMAT(resp)        MMC_RSP_BITS((resp), 10, 2)

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/
typedef struct
{
        int csd_ver;                /*!< CSD structure format */
        int mmc_ver;                /*!< MMC version (for CID format) */
        int capacity;               /*!< total number of sectors */
        int sector_size;            /*!< sector size in bytes */
        int read_block_len;         /*!< block length for reads */
        int card_command_class;     /*!< Card Command Class for SD */
        int tr_speed;               /*!< Max transfer speed */
} sdmmc_csd_t;

typedef struct
{
        IfxSdmmc_Sd sd;
}  App_Sdmmc_Mmc;

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if defined(__GNUC__)
#pragma section ".text_cpu0" ax
#pragma section ".bss_cpu0" awc0
#endif
#if defined(__TASKING__)
#pragma section code    "text_cpu0"
#pragma section farbss  "bss_cpu0"
#pragma section fardata "data_cpu0"
#pragma section farrom  "rodata_cpu0"
#endif
#if defined(__DCC__)
#pragma section CODE ".text_cpu0"
#pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
#pragma section CONST ".rodata_cpu0"
#endif
#if defined(__ghs__)
#pragma ghs section text=".text_cpu0"
#pragma ghs section bss= ".bss_cpu0"
#pragma ghs section data=".data_cpu0"
#pragma ghs section rodata=".rodata_cpu0"
#endif


App_Sdmmc_Mmc g_Sdmmc_Mmc;

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
#if defined(__GNUC__)
#pragma section // end bss section
#endif

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
static inline uint32 MMC_RSP_BITS(uint32 *src, int start, int len)
{
    uint32 mask = (len % 32 == 0) ? 0xffffffffU : 0xffffffffU >> (32 - (len % 32));
    uint32 word = start / 32;
    uint32 shift = start % 32;
    uint32 right = src[word] >> shift;
    uint32 left = (len + shift <= 32) ? 0 : src[word + 1] << ((32 - shift) % 32);
    return (left | right) & mask;
}

static sint32 sdmmc_decode_csd(IfxSdmmc_Response *response, sdmmc_csd_t* out_csd)
{
    out_csd->csd_ver = SD_CSD_CSDVER((uint32*)response);
    switch (out_csd->csd_ver)
    {
        case SD_CSD_CSDVER_2_0:
            out_csd->capacity = SD_CSD_V2_CAPACITY((uint32*)response);
            out_csd->read_block_len = SD_CSD_V2_BL_LEN;
            break;
        case SD_CSD_CSDVER_1_0:
            out_csd->capacity = SD_CSD_CAPACITY((uint32*)response);
            out_csd->read_block_len = SD_CSD_READ_BL_LEN((uint32*)response);
            break;
        default:
            return -1;
    }
    out_csd->card_command_class = SD_CSD_CCC((uint32*)response);
    int read_bl_size = 1 << out_csd->read_block_len;
    out_csd->sector_size = __minu(read_bl_size, 512);
    if (out_csd->sector_size < read_bl_size) {
        out_csd->capacity *= read_bl_size / out_csd->sector_size;
    }
    int speed = SD_CSD_SPEED((uint32*)response);
    if (speed == SD_CSD_SPEED_50_MHZ) {
        out_csd->tr_speed = 50000000;
    } else {
        out_csd->tr_speed = 25000000;
    }
    return 0;
}

static sint32 sdmmc_send_cmd_send_status(IfxSdmmc_Sd *sd, IfxSdmmc_CardStatus* out_status)
{
    IfxSdmmc_Status   status = IfxSdmmc_Status_success;
    IfxSdmmc_Response response;
    uint32            argument = 0;

    argument |= (uint32)(g_Sdmmc_Mmc.sd.cardInfo.rca << 16);
    status = IfxSdmmc_sendCommand(g_Sdmmc_Mmc.sd.sdmmcSFR, IfxSdmmc_Command_sendStatus, argument, IfxSdmmc_ResponseType_r1, &response);

    if ((status == IfxSdmmc_Status_success) && (out_status != NULL))
    {
        *out_status = response.cardStatus;
    }

    return status;

}

static sint32 sdmmc_send_cmd_send_csd(IfxSdmmc_Sd *sd, sdmmc_csd_t* csd)
{
    IfxSdmmc_Status   status = IfxSdmmc_Status_success;
    IfxSdmmc_Response response;
    uint32            argument = 0;

    argument |= (uint32)(g_Sdmmc_Mmc.sd.cardInfo.rca << 16);
    status = IfxSdmmc_sendCommand(g_Sdmmc_Mmc.sd.sdmmcSFR, IfxSdmmc_Command_sendCSD, argument, IfxSdmmc_ResponseType_r2, &response);

    if ((status == IfxSdmmc_Status_success) && (csd != NULL))
    {
        sdmmc_decode_csd(&response, csd);
    }

    return status;

}

/*-----------------------------------------------------------------------*/
/* Get Drive Status                                                      */
/*-----------------------------------------------------------------------*/

DSTATUS disk_status_sdmmc (
        BYTE pdrv       /* Physical drive number to identify the drive */
)
{
    if (pdrv) return STA_NOINIT;

    DSTATUS card_status = STA_NOINIT | STA_PROTECT;
    if (sdmmc_send_cmd_send_status(&(g_Sdmmc_Mmc.sd), NULL) == IfxSdmmc_Status_success)
    {
        card_status &= ~STA_NOINIT;
        IfxSdmmc_CardLockStatus lock_status;
        if (IfxSdmmc_Sd_getLockStatus(&(g_Sdmmc_Mmc.sd), &lock_status) == IfxSdmmc_Status_success)
        {
            if (lock_status != IfxSdmmc_CardLockStatus_locked)
            {
                card_status &= ~STA_PROTECT;
            }
        }
    }

    return card_status;
}



/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
/*-----------------------------------------------------------------------*/

DSTATUS disk_initialize_sdmmc (
        BYTE pdrv               /* Physical drive nmuber to identify the drive */
)
{
    DSTATUS stat = STA_NOINIT | STA_PROTECT;

    IfxSdmmc_Sd_Config config;
    /* fill the config structure with default values*/
    IfxSdmmc_Sd_initModuleConfig(&config, &MODULE_SDMMC0);

    IfxSdmmc_Sd_Pins pins;
    pins.clk = &SDCARD_CLK_PIN;
    pins.cmd = &SDCARD_CMD_PIN;
    pins.dat0 = &SDCARD_DAT0_PIN;
    pins.dat1 = &SDCARD_DAT1_PIN;
    pins.dat2 = &SDCARD_DAT2_PIN;
    pins.dat3 = &SDCARD_DAT3_PIN;
    pins.inputMode = IfxPort_InputMode_pullUp;
    pins.pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1;
    config.pins = &pins;

    /*Change bus width*/
    config.cardConfig.dataWidth = IfxSdmmc_SdDataTransferWidth_4Bit;

    // device identification clock frequency
    //   config.hostConfig.usePresetValues = FALSE;
    //    config.hostConfig.frequency = 400000;

    /*change speed mode*/
    config.cardConfig.speedMode = IfxSdmmc_SdSpeedMode_high;

    /* select DMA type if DMA is used*/
    config.useDma = TRUE;
    config.dmaConfig.dmaType = IfxSdmmc_DmaType_sdma;

    config.interruptConfig.commandCompleteInterruptEnable   = TRUE;
    config.interruptConfig.transferCompleteInterruptEnable  = TRUE;
    config.interruptConfig.commandTimeoutInterruptEnable    = FALSE;
    config.interruptConfig.dataTimeoutInterruptEnable       = FALSE;


    if (IfxSdmmc_Sd_initModule(&(g_Sdmmc_Mmc.sd), &config) == IfxSdmmc_Status_success)
    {
        stat &= ~STA_NOINIT;
    }

    if ((g_Sdmmc_Mmc.sd.cardState & IfxSdmmc_CardState_locked) == 0)
    {
        stat &= ~STA_PROTECT;
    }

    IfxSdmmc_configureClock(g_Sdmmc_Mmc.sd.sdmmcSFR, 25000000);

    return stat;
}



/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
/*-----------------------------------------------------------------------*/

DRESULT disk_read_sdmmc (
        BYTE pdrv,      /* Physical drive number to identify the drive */
        BYTE *buff,     /* Data buffer to store read data */
        DWORD sector,   /* Start sector in LBA */
        UINT count      /* Number of sectors to read */
)
{
    if (disk_status_sdmmc(pdrv) & STA_NOINIT) return RES_NOTRDY;
    if (!count) return RES_PARERR;
    if (IfxSdmmc_Sd_readMultiBlock(&(g_Sdmmc_Mmc.sd), sector, (uint32*)buff,count,IfxSdmmc_BlockBoundarySize_512K ) != IfxSdmmc_Status_success)
    {
        return  RES_ERROR;
    }

    return RES_OK;
}



/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
/*-----------------------------------------------------------------------*/

DRESULT disk_write_sdmmc (
        BYTE pdrv,          /* Physical drive nmuber to identify the drive */
        const BYTE *buff,   /* Data to be written */
        DWORD sector,       /* Start sector in LBA */
        UINT count          /* Number of sectors to write */
)
{
    if (disk_status_sdmmc(pdrv) & STA_NOINIT) return RES_NOTRDY;
    if (!count) return RES_PARERR;

    if (IfxSdmmc_Sd_writeMultiBlock(&(g_Sdmmc_Mmc.sd), sector, (uint32*)buff,count,IfxSdmmc_BlockBoundarySize_512K ) != IfxSdmmc_Status_success)
    {
        return  RES_ERROR;
    }

    return RES_OK;
}
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
/*-----------------------------------------------------------------------*/

DRESULT disk_ioctl_sdmmc (
        BYTE pdrv,      /* Physical drive number (0..) */
        BYTE cmd,       /* Control code */
        void *buff      /* Buffer to send/receive control data */
)
{
    sdmmc_csd_t csd;
    DRESULT res;
    if (disk_status_sdmmc(pdrv) & STA_NOINIT) return RES_NOTRDY;    /* Check if card is in the socket */

    res = RES_ERROR;
    switch (cmd) {
        case CTRL_SYNC :        /* Make sure that no pending write process */
            res = RES_OK;
            break;

        case GET_SECTOR_COUNT : /* Get number of sectors on the disk (DWORD) */
            sdmmc_send_cmd_send_csd(&(g_Sdmmc_Mmc.sd), &csd);
            *(DWORD*)buff = csd.capacity;
            res = RES_OK;
            break;

        case GET_BLOCK_SIZE :   /* Get erase block size in unit of sector (DWORD) */
            sdmmc_send_cmd_send_csd(&(g_Sdmmc_Mmc.sd), &csd);
            *(DWORD*)buff = csd.sector_size;
            res = RES_OK;
            break;


        default:
            res = RES_PARERR;
    }

    return res;
}

#endif // MODULE_SDMMC0
