/**
 * \file IfxClock.c
 * \brief CLOCK  basic functionality
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxClock.h"
#include "IfxDmu_reg.h"

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

/** \brief Flash wait state config
 */
IFX_STATIC IFX_CONST IfxClock_FlashWaitstateConfig IfxClock_defaultFlashWaitstateConfig = IFXCLOCK_CFG_FLASH_WAITSTATE;

#if defined(IFX_CLOCK_DISABLE_RAMPCON)
/** \brief This is a structure array and the values are defined at the Clock  implementation as a macro
 */
IFX_STATIC IFX_CONST uint8 IfxClock_defaultPllConfigSteps[] = {
    IFXCLOCK_CFG_PLL_STEPS
};
#endif

/******************************************************************************/
/*-----------------------Exported Variables/Constants-------------------------*/
/******************************************************************************/

IFX_CONST float32                   IfxClock_MA_PerPll_percent[IfxClock_PerPllModulationAmplitude_count] = {
    0.01f,
    0.02f,
    0.03f,
    0.04f,
    0.05f,
    0.06f,
    0.07f,
    0.08f,
    0.09f,
    0.10f,
    0.11f,
    0.12f,
    0.13f,
    0.14f,
    0.15f
};

IFX_CONST float32                   IfxClock_MA_percent[IfxClock_ModulationAmplitude_count] = {
    0.5f,
    1.0f,
    1.25f,
    1.5f,
    2.0f,
    2.5f
};

IFX_CONST float32                   IfxClock_X_Gain_Value[IfxClock_XGain_count] = {
    0.0f,
    0.0f,
    0.25f,
    0.5f,
    1.0f,
    2.0f,
    4.0f
};

IFX_CONST IfxClock_Config           IfxClock_defaultClockConfig = {
    IFX_CFG_CLOCK_XTAL_FREQUENCY,
    IFXCLOCK_CFG_SYS_PLL_INITIAL_STEP,
    IFXCLOCK_CFG_PER_PLL_INITIAL_STEP,
#if !defined(IFX_CLOCK_DISABLE_RAMPCON)
    {400},
#endif
#if defined(IFX_CLOCK_DISABLE_RAMPCON)
    {
        sizeof(IfxClock_defaultPllConfigSteps) / sizeof(uint8),
        IfxClock_defaultPllConfigSteps
    },
#endif
    IFXCLOCK_CFG_CLK_DISTRIBUTION,
    &IfxClock_defaultFlashWaitstateConfig,
    &IfxClock_defaultModConfig,
    &IfxClock_defaultPerPllModConfig,
    IfxClock_PllInputClockSelection_fOsc0,
    IfxClock_SysClockSourceSelect_pll,
    IfxClock_PerClockSourceSelect_pll,
    IFXCLOCK_CFG_CLK_OSCCON
};

IFX_CONST IfxClock_Mod_Config       IfxClock_defaultModConfig = {
    IfxClock_ModEn_disabled,                                    /* disable is default */
    IfxClock_ModulationAmplitude_1p25,                          /* default value */
};

IFX_CONST IfxClock_perPllMod_Config IfxClock_defaultPerPllModConfig = {
    IfxClock_ModEn_disabled,                                          /* disable is default */
    IfxClock_PerPllModulationAmplitude_0p10,                          /* default value */
};

uint32                              IfxClock_xtalFrequency = IFX_CFG_CLOCK_XTAL_FREQUENCY;

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxClock_calRGainParameters(IfxClock_ModulationAmplitude modamp, IfxClock_RGain_Values *RGain_P)
{
    float32    mod_amp       = IfxClock_MA_percent[modamp];
    float32   *RGainNom_Temp = &(RGain_P->RGainNom);
    uint16    *RGain_Temp    = &(RGain_P->RGainHex);
    uint32    *Delta_RnDGain = &(RGain_P->DeltaRnDGain);
    Ifx_CLOCK *clock         = &MODULE_CLOCK;
    float32    Fosc_Hz       = (float32)IfxClock_getOscFrequency();
    float32    Fdco_hz       = (Fosc_Hz * (clock->SYSPLLCON0.B.NDIV + 1)) / (clock->SYSPLLCON0.B.PDIV + 1);

    *RGainNom_Temp = IFXCLOCK_GET_RGAIN_NOM(mod_amp, Fdco_hz);
    *RGain_Temp    = IFXCLOCK_GET_RGAIN_HEX(*RGainNom_Temp);
    *Delta_RnDGain = IFXCLOCK_GET_DELTA_RANDD(*RGain_Temp);
}


void IfxClock_perPllCalRGainParameters(IfxClock_PerPllModulationAmplitude modamp, IfxClock_RGain_Values *RGain_P)
{
    float32    mod_amp       = IfxClock_MA_PerPll_percent[modamp];
    float32   *RGainNom_Temp = &(RGain_P->RGainNom);
    uint16    *RGain_Temp    = &(RGain_P->RGainHex);
    uint32    *Delta_RnDGain = &(RGain_P->DeltaRnDGain);
    Ifx_CLOCK *clock         = &MODULE_CLOCK;
    float32    Fosc_Hz       = (float32)IfxClock_getOscFrequency();
    float32    Fdco_hz       = (Fosc_Hz * (clock->PERPLLCON0.B.NDIV + 1)) / (clock->PERPLLCON0.B.PDIV + 1);

    *RGainNom_Temp = IFXCLOCK_GET_RGAIN_NOM(mod_amp, Fdco_hz);
    *RGain_Temp    = IFXCLOCK_GET_RGAIN_HEX(*RGainNom_Temp);
    *Delta_RnDGain = IFXCLOCK_GET_DELTA_RANDD(*RGain_Temp);
}


boolean IfxClock_calXCorrParameters(float32 RGainNom, IfxClock_XCorr_Values *XCorr_P)
{
    float32        XCorrNom_Temp;
    uint32         XCorr_Temp;
    uint32         XGain_Temp;
    uint32         XTol_Temp;
    IfxClock_XGain xgain_index;
    boolean        status   = 1;
    float32        Fosc_Hz  = (float32)IfxClock_getOscFrequency();
    float32        Fosc_MHz = Fosc_Hz / 1000000;

    /* Default values are 0 - if no match - then 0 will be reported back */
    XCorr_Temp    = 0;
    XCorrNom_Temp = 0;
    XGain_Temp    = 0;
    XTol_Temp     = 0;

    /* algorithm to find out the right XCORR and XGain values */
    /* loop through the allowed XGain values and see if XCORR arrives in range of 150-350 */
    for (xgain_index = IfxClock_XGain_4p0; xgain_index >= IfxClock_XGain_0p25; xgain_index--)
    {
        XCorrNom_Temp = IFXCLOCK_GET_XCORR_NOM(Fosc_MHz, RGainNom, IfxClock_X_Gain_Value[xgain_index]);

        if ((XCorrNom_Temp >= IFXCLOCK_XCORR_LOWER_LIMIT)
            && (XCorrNom_Temp <= IFXCLOCK_XCORR_HIGHER_LIMIT))
        {
            XGain_Temp = xgain_index;
            XCorr_Temp = IFXCLOCK_GET_XCORR_HEX(XCorrNom_Temp);
            break;
        }
        else
        {
            XCorrNom_Temp = 0;
        }
    }

    if (XCorr_Temp != 0)
    {
        XTol_Temp = IFXCLOCK_GET_XTOL(XCorr_Temp);
        status    = 0; /* we have found a good XCorr and XGain value combo */
    }

    /* write back */
    XCorr_P->XCorrNom = XCorrNom_Temp;
    XCorr_P->XCorr    = XCorr_Temp;
    XCorr_P->XGain    = XGain_Temp;
    XCorr_P->XTol     = XTol_Temp;

    return status;
}


#if !defined(IFX_ILLD_PPU_USAGE)
boolean IfxClock_configureCcuPll(const IfxClock_Config *pllCfg)
{
    uint32 timeoutCycleCount = 0U;
    uint8  initError         = 0U;
    timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {
        IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    /* Disable SMU Alarms System-PLL Out Of Range event, Peripheral-PLL Out Of Range event */
    {
        boolean index = 0;
        IfxSmu_setSafetyAlarmAction(IfxSmu_Alarm_SF_CLOCKING_SystemPllCrystalClockFrequencyOutOfRange, IfxSmu_InternalAlarmAction_disabled, index);
        IfxSmu_setSafetyAlarmAction(IfxSmu_Alarm_SF_CLOCKING_PeripheralPllCrystalClockFrequencyOutOfRange, IfxSmu_InternalAlarmAction_disabled, index);
    }

    /* If Crystal Osc powered down then do the Osc power-up, since it takes ~3ms to power up*/
    /* TC49xA step workaround due to HW bug */
    if (CLOCK_OSCCON.B.MODE == 7U)
    {
        CLOCK_OSCCON.B.MODE = 3U;
        Ifx__mem_barrier
#if (IFX_CFG_CLOCK_EXT_CLOCK == 1)
        CLOCK_OSCCON.B.MODE = 2U;     /* external clock selected */
#else
        CLOCK_OSCCON.B.MODE = 0U;     /*oscillator enabled */
#endif
    }
    else
    {
        if ((CLOCK_OSCCON.B.MODE != 2U) && (CLOCK_OSCCON.B.MODE != 0U))
        {
            IfxClock_powerOnCrystalOsc();
        }
    }

    /* If Ramp Osc powered down then do the Osc power-up */
    if (CLOCK_RAMPSTAT.B.ACTIVE != 1U)
    {
        IfxClock_powerOnRampOsc();
    }

    CLOCK_RAMPMON.B.FLLLDEN = 0x1;

    {
        Ifx_CLOCK_OSCCON osccon;
        osccon.U = CLOCK_OSCCON.U & ~pllCfg->osccon.mask;

        /* Now configure the oscillator, required oscillator mode in external crystal */
        if (pllCfg->pllInputClockSelection == IfxClock_PllInputClockSelection_fOsc0)
        {
            Ifx_CLOCK_OSCMON1 scuOscmon;
            scuOscmon.U = CLOCK_OSCMON1.U;

            if ((uint32)(pllCfg->xtalFrequency / 1000000U) >= 16U)
            {
                scuOscmon.B.OSCVAL = (uint32)(pllCfg->xtalFrequency / 1000000U) - 15U; /*XTAL range 16MHz to 50MHz*/
            }
            else
            {
                scuOscmon.B.OSCVAL = 0U;
            }

            scuOscmon.B.SMONEN = 1U;
            scuOscmon.B.PMONEN = 1U;
            /*Note: Oscillator Watchdog Reset (OSCRES) is not required when the PLLs are powered down*/
            CLOCK_OSCMON1.U    = scuOscmon.U;
        }

        timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        osccon.U         |= (pllCfg->osccon.value & pllCfg->osccon.mask);

        CLOCK_OSCCON.U    = osccon.U;

        timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        /* PLL input selection */
#if (IFX_CLOCK_BYPASS_FOSC_F == 1)

        if (pllCfg->pllInputClockSelection == IfxClock_PllInputClockSelection_fOsc_f)
        {
            /* When the crystal has a frequency greater than 20 MHz, the fOsc_f cannot be used */
            if ((uint32)IfxClock_xtalFrequency > 20000000)
            {
                initError = 1;
                return (boolean)initError;
            }
        }

#endif

        CLOCK_OSCCON.B.INSEL = pllCfg->pllInputClockSelection;
    }

    /* Crtstal Osc may take up to 3ms until it produces a stable clock */
    IfxClock_waitWithWdtService(IFXCLOCK_OSC_WAITTIME);

    if (pllCfg->pllInputClockSelection == IfxClock_PllInputClockSelection_fOsc0)
    {
        if (((CLOCK_OSCSTAT.B.SOWDS != 0U) || (CLOCK_OSCSTAT.B.POWDS != 0U)) && ((uint32)(pllCfg->xtalFrequency / 1000000U) >= 16U))

        {
            initError = 1U;
        }
    }

    /* Check if Sys and PLL clockSrc is not equal to backup */
    if ((pllCfg->SysClockSourceSelect != IfxClock_SysClockSourceSelect_back) &&
        (pllCfg->PerClockSourceSelect != IfxClock_PerClockSourceSelect_back))
    {
        /* Configure the Sys PLL and Per PLL dividers (N, P, K2/K3/K4) to desired frequencies (400MHz).
         *    For Sys PLL, Should the K2 divider be the final value
         *    For Per PLL, Should the K3/K4 divider be the final value.
         */

        if (pllCfg->SysClockSourceSelect == IfxClock_SysClockSourceSelect_pll)
        {
            /* Step 1. PLL off (By default PLL will be in off state) */
            /* Step 2. Check for CCU lock bit with a timeout of at least 100 micro seconds */

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

#ifdef IXCLOCK_PTE_WORKAROUND

            CLOCK_SYSPLLCON0.U = 0x00001800u;

            timeoutCycleCount  = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

#endif

            /* Step 3. Configure K-dividers in SYSPLLCON1 register*/
            /* K2PREDIV = div by 2 and K2DIV = 0x01*/

            CLOCK_SYSPLLCON1.U = IFXCLOCK_SYSPLL_KXDIV_KXPREDIV_INITIAL_VALUE;

            /* Step 4. Power Up System PLL - with PDIV and NDIV */

            Ifx_CLOCK_SYSPLLCON0 sysPllCon0;

            sysPllCon0.U        = CLOCK_SYSPLLCON0.U;
            sysPllCon0.U        = CLOCK_SYSPLLCON0.U;
            sysPllCon0.B.PDIV   = pllCfg->sysPllConfig.pDivider;
            sysPllCon0.B.NDIV   = pllCfg->sysPllConfig.nDivider;
            sysPllCon0.B.PLLPWR = 1;

            CLOCK_SYSPLLCON0.U  = sysPllCon0.U;

            /* Step 5. Check for CCU lock bit with a timeout of at least 100 micro seconds */

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 6. Check if PLL is powered: SYSPLLSTAT.PWRSTAT == 1 with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_SYSPLLSTAT.B.PWRSTAT != 1U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 7. Wait for 1ms to avoid jitter */
            IfxClock_waitWithWdtService(IFXCLOCK_SYSPLL_POWERUP_WAITTIME); /* 1 mS */

            /* Step 8. Check for SysPLL lock with a timeout of at least 100 micro seconds*/
            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_SYSPLLSTAT.B.PLLLOCK != 1U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 9. Configure KxPREDIV */
            /* Set K2PREDIV to final value */

            Ifx_CLOCK_SYSPLLCON1 sysPllCon1;

            sysPllCon1.U          = CLOCK_SYSPLLCON1.U;
            sysPllCon1.B.K2PREDIV = pllCfg->sysPllConfig.k2PreDivider;
            CLOCK_SYSPLLCON1.U    = sysPllCon1.U;

            /* Step 10. Wait for 10 micro seconds  */
            /* Check for CCU lock bit with delay of 100 micro seconds*/

            IfxClock_waitWithWdtService(IFXCLOCK_CCUSTAT_LCK_WAITTIME); /* 10 micro seconds */

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 11. Configure KxDIV */
            /* Step 11.a. Set K2DIV to final value */

            sysPllCon1.U       = CLOCK_SYSPLLCON1.U;
            sysPllCon1.B.K2DIV = pllCfg->sysPllConfig.k2Divider;

            CLOCK_SYSPLLCON1.U = sysPllCon1.U;

            /* Step 11.b. Check for CCU lock bit with a timeout of at least 100 micro seconds */

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }
        }

        if (pllCfg->PerClockSourceSelect == IfxClock_PerClockSourceSelect_pll)
        {
            /* Step 1. PLL off (By default PLL will be in off state) */
            /* Step 2. Check for CCU lock bit with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 3. Configure K-dividers in PERPLLCON1 register*/
            /* Step 3a. KxPREDIV = div by 2 */

            CLOCK_PERPLLCON1.U = IFXCLOCK_PERPLL_KXPREDIV_INITIAL_VALUE;

            /* Step 3b. Check for CCU lock bit with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 3c. Set KxDIV = 0x01 (PERPLLCON1.KxDIV = 0x01)*/

            Ifx_CLOCK_PERPLLCON1 perPllCon1;

            perPllCon1.U       = CLOCK_PERPLLCON1.U;

            perPllCon1.U      |= IFXCLOCK_PERPLL_KXDIV_INITIAL_VALUE;

            CLOCK_PERPLLCON1.U = perPllCon1.U;

            /* Step 3d. Check for CCU lock bit with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

#ifdef IXCLOCK_PTE_WORKAROUND

            timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            IfxClock_waitWithWdtService(IFXCLOCK_CCUSTAT_LCKLOCK_WAITTIME);

            CLOCK_PERPLLCON0.B.RESLD = 1; /* Restart PER PLL lock detection */
#endif
            /* Step 4. Power Up Peripheral PLL - with PDIV and NDIV */

            Ifx_CLOCK_PERPLLCON0 perPllCon0;

            perPllCon0.U        = CLOCK_PERPLLCON0.U;
            perPllCon0.U        = CLOCK_PERPLLCON0.U;
            perPllCon0.B.PDIV   = pllCfg->perPllConfig.pDivider;
            perPllCon0.B.NDIV   = pllCfg->perPllConfig.nDivider;
            perPllCon0.B.PLLPWR = 1;

            CLOCK_PERPLLCON0.U  = perPllCon0.U;

            /* Step 5. Check for CCU lock bit with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 6. Check if PLL is powered: PERPLLSTAT.PWRSTAT == 1 with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_PERPLLSTAT.B.PWRSTAT != 1U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 7. Wait for 1ms to avoid jitter */

            IfxClock_waitWithWdtService(IFXCLOCK_PERPLL_POWERUP_WAITTIME); /* 1 mS */

            /* Step 8. Check for PLL lock: PERPLLSTAT.PLLLOCK == 1 with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_PERPLLSTAT.B.PLLLOCK != 1U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 9. Configure KxPREDIV */
            /* Set KxPREDIV to final value */

            perPllCon1.B.K2PREDIV = pllCfg->perPllConfig.k2PreDivider;
            perPllCon1.B.K3PREDIV = pllCfg->perPllConfig.k3PreDivider;
            perPllCon1.B.K4PREDIV = pllCfg->perPllConfig.k4PreDivider;

            CLOCK_PERPLLCON1.U    = perPllCon1.U;

            /* Step 10. Wait for 10 micro seconds  */
            /* Check for CCU lock bit with a timeout of at least 100 micro seconds*/

            IfxClock_waitWithWdtService(IFXCLOCK_CCUSTAT_LCK_WAITTIME); /* 10 micro seconds */

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }

            /* Step 11. Configure KxDIV */
            /* Step 11.a Set KxDIV to final value */

            perPllCon1.U       = CLOCK_PERPLLCON1.U;
            perPllCon1.B.K2DIV = pllCfg->perPllConfig.k2Divider;
            perPllCon1.B.K3DIV = pllCfg->perPllConfig.k3Divider;
            perPllCon1.B.K4DIV = pllCfg->perPllConfig.k4Divider;

            CLOCK_PERPLLCON1.U = perPllCon1.U;

            /* Step 11.b. Check for CCU lock bit with a timeout of at least 100 micro seconds*/

            timeoutCycleCount = IFXCLOCK_CCUSTAT_LCK_BIT_TIMEOUT_COUNT;

            while (CLOCK_CCUSTAT.B.LCK != 0U)
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }
        }
    }

    /* Clear SMU Alarms System-PLL Out Of Range event, Peripheral-PLL Out Of Range event */
    {
        boolean index = 0;
        IfxSmu_smuSafeClearAlarmStatus(IfxSmu_Alarm_SF_CLOCKING_SystemPllCrystalClockFrequencyOutOfRange, index);
        IfxSmu_smuSafeClearAlarmStatus(IfxSmu_Alarm_SF_CLOCKING_PeripheralPllCrystalClockFrequencyOutOfRange, index);
    }

#if !defined(IFX_CLOCK_DISABLE_RAMPCON)
    /* Configure the Ramp oscillator (RAMPCON UFL, SZ, WAIT) for the desired Sys PLL frequency (450MHZ) and enable CMD to ramp up.
     * Enable clock source (CCUCON.CLKSELS = RAMP) to RAMPCON frequency. */

    /* Select framp as the clock for DCCU */
    {
        Ifx_CLOCK_CCUCON ccucon0;
        ccucon0.U         = CLOCK_CCUCON.U;
        ccucon0.B.CLKSELS = IfxClock_SysClockSourceSelect_ramp;
        ccucon0.B.CLKSELP = IfxClock_SysClockSourceSelect_back;

        timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_CCUCON.U = ccucon0.U;
    }

    timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

    while (CLOCK_RAMPSTAT.B.FLLLOCK != 1U)
    {
        IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    {
        Ifx_CLOCK_RAMPCON0 rampcon;
        rampcon.U         = CLOCK_RAMPCON0.U;
        rampcon.B.UFL     = pllCfg->rampConfig.rampOscUpperFreqLimit; //upper target frequency in 1 MHz steps
        rampcon.B.CMD     = IfxClock_RampSeqCmd_rampUp;

        timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_RAMPCON0.U = rampcon.U;
    }

    /* Wait for Ramp oscillator to reach the desired frequency */
    timeoutCycleCount = IFXCLOCK_PLL_RAMPOSC_TIMEOUT_COUNT;

    while (IfxClock_getRampFreqStatus() != IfxClock_RampFreqStatus_atTop)
    {
        IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

#endif

    timeoutCycleCount = IFXCLOCK_PLL_LOCK_TIMEOUT_COUNT;

    while (CLOCK_SYSPLLSTAT.B.PLLLOCK == 0U)
    {
        IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    timeoutCycleCount = IFXCLOCK_PLL_LOCK_TIMEOUT_COUNT;

    while (CLOCK_PERPLLSTAT.B.PLLLOCK == 0)
    {
        IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    /* Inline API to power up the OSC (~3ms max time) and  power up the RAMP OSC after the LBIST in ASSW
     * Legacy way of configurations should be maintained.
     * The config structure for legacy can be moved out and removed later, provide a warning for the same.
     * In CLOCK init check the bit for Power up and then perform
     * */

    {
        Ifx_CLOCK_CCUCON ccucon;
        ccucon.U          = CLOCK_CCUCON.U;
        ccucon.B.CLKSELP  = pllCfg->PerClockSourceSelect; /*Select the Clock source */
        ccucon.B.CLKSELS  = pllCfg->SysClockSourceSelect;

        timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_CCUCON.U = ccucon.U;
    }
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    return (boolean)initError;
}


#endif

void IfxClock_distributeClock(IfxClock_ClockDistributionConfig *clockDistributionConfig)
{
    if (clockDistributionConfig != NULL_PTR)
    {
        IfxClock_distributeClockInline(clockDistributionConfig);
    }
}


uint32 IfxClock_getAsclinSFrequency(void)
{
    uint32 freq             = 0;
    uint32 source           = 0;

    uint8  asclinclkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint8  actualDiv        = CLOCK_PERCCUCON1.B.ASCLINSDIV;

    switch (CLOCK_PERCCUCON1.B.CLKSELASCLINS)
    {
    case 1:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1); /* fPLL1 */

        if (actualDiv)
        {
            freq = source / asclinclkdiv[actualDiv];
        }
    }
    break;
    case 2:
    {
        freq = IfxClock_getOsc0Frequency(); /* fXTAL1 */
    }
    break;
    default:
        freq = 0U;
        break;
    }

    return freq;
}


uint32 IfxClock_getCpbFrequency(void)
{
    uint32 cpbFrequency    = 0;
    uint32 sourceFrequency = 0;
    uint8  clkdiv[16]      = {4, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint8  actualDiv       = CLOCK_SYSCCUCON0.B.CPBDIV;

    if (actualDiv != 0)
    {
        sourceFrequency = IfxClock_getSysSourceFrequency();

        if (CLOCK_SYSCCUCON0.B.LPDIV == 0)
        {
            cpbFrequency = sourceFrequency / clkdiv[actualDiv];
        }
        else
        {
            cpbFrequency = sourceFrequency / 120;
        }
    }

    return cpbFrequency;
}


uint32 IfxClock_getCpuFrequency(void)
{
    uint32 frequency = IfxClock_getSriFrequency();

    return frequency;
}


uint32 IfxClock_getFsiFrequency(void)
{
    uint32               frequency;
    Ifx_CLOCK_SYSCCUCON0 sysccucon0    = CLOCK_SYSCCUCON0;
    uint8                clkclkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    if (sysccucon0.B.FSIDIV == 0)
    {
        frequency = 0U;
    }
    else
    {
        frequency = IfxClock_getSriFrequency();
        frequency = frequency / clkclkdiv[sysccucon0.B.FSIDIV];
    }

    return frequency;
}


uint32 IfxClock_getMcanFrequency(void)
{
    uint32 mcanFreq   = 0;
    uint32 mcanSource = 0;
    uint8  clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint8  actualDiv  = CLOCK_PERCCUCON0.B.MCANDIV;

    switch (CLOCK_PERCCUCON0.B.CLKSELMCAN)
    {
    case 1:
    {
        mcanSource = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1); /* fPLL1*/

        if (actualDiv != 0)
        {
            mcanFreq = mcanSource / clkdiv[actualDiv];
        }
    }
    break;
    case 2:
    {
        mcanFreq = IfxClock_getOsc0Frequency();
    }
    break;
    default:
        mcanFreq = 0U;
        break;
    }

    return mcanFreq;
}


uint32 IfxClock_getModuleFrequency(void)
{
    uint32             spbFreq;
    uint32             moduleFreq;
    Ifx_CLOCK_EXTFDCON scuFdr;
    scuFdr.U = CLOCK_EXTFDCON.U;
    spbFreq  = IfxClock_getSpbFrequency();

    if (scuFdr.B.DM == 1)
    {
        moduleFreq = spbFreq / (1024 - scuFdr.B.STEP);
    }
    else if (scuFdr.B.DM == 2)
    {
        moduleFreq = (spbFreq * scuFdr.B.STEP) / 1024;
    }
    else
    {
        moduleFreq = 0U;
    }

    return moduleFreq;
}


uint32 IfxClock_getMscFrequency(void)
{
    uint32 mscFreq    = 0;
    uint32 mscSource  = 0;
    uint8  clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint8  actualDiv  = CLOCK_PERCCUCON0.B.MSCDIV;

    switch (CLOCK_PERCCUCON0.B.CLKSELMSC)
    {
    case 1:
    {
        mscSource = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1); /* fPLL1 */
    }
    break;
    case 2:
    {
        mscSource = IfxClock_getPerSourceFrequency(IfxClock_Fsource_2); /* fPLL2 */
    }
    break;
    default:
        mscFreq = 0U;
        break;
    }

    if (actualDiv != 0)
    {
        mscFreq = mscSource / clkdiv[actualDiv];
    }

    return mscFreq;
}


uint32 IfxClock_getPerPllFrequency1(void)
{
    Ifx_CLOCK *clock = &MODULE_CLOCK;
    uint64     pllFrequency1;
    uint64     oscFreq;
    float32    preDiv[4] = {1.0f, 2.0f, 1.2f, 1.6f};
    oscFreq       = IfxClock_getOscFrequency();
    /* 0.5 added for rounding off to nearest integer */
    pllFrequency1 = (oscFreq * (clock->PERPLLCON0.B.NDIV + 1)) / ((clock->PERPLLCON0.B.PDIV + 1) * ((clock->PERPLLCON1.B.K2DIV + 1) * (preDiv[clock->PERPLLCON1.B.K2PREDIV]))) + 0.5f;
    pllFrequency1 = pllFrequency1 * clock->PERPLLSTAT.B.PLLLOCK * clock->PERPLLSTAT.B.PWRSTAT;
    return (uint32)pllFrequency1;
}


uint32 IfxClock_getPerPllFrequency2(void)
{
    Ifx_CLOCK *clock = &MODULE_CLOCK;
    uint64     pllFrequency2;
    uint64     oscFreq;
    float32    preDiv[16] = {1.0f, 1.1f, 1.2f, 1.0f, 1.4f, 1.0f, 1.6f, 1.7f, 1.0f, 1.0f, 2.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};
    oscFreq       = IfxClock_getOscFrequency();
    pllFrequency2 = (oscFreq * (clock->PERPLLCON0.B.NDIV + 1)) / ((clock->PERPLLCON0.B.PDIV + 1) * ((clock->PERPLLCON1.B.K3DIV + 1) * (preDiv[clock->PERPLLCON1.B.K3PREDIV]))) + 0.5f;
    pllFrequency2 = pllFrequency2 * clock->PERPLLSTAT.B.PLLLOCK * clock->PERPLLSTAT.B.PWRSTAT;
    return (uint32)pllFrequency2;
}


uint32 IfxClock_getPerPllFrequency3(void)
{
    Ifx_CLOCK *clock = &MODULE_CLOCK;
    uint64     pllFrequency3;
    uint64     oscFreq;
    float32    preDiv[4] = {1.0f, 2.0f, 1.2f, 1.6f};
    oscFreq       = IfxClock_getOscFrequency();
    pllFrequency3 = (oscFreq * (clock->PERPLLCON0.B.NDIV + 1)) / ((clock->PERPLLCON0.B.PDIV + 1) * ((clock->PERPLLCON1.B.K4DIV + 1) * (preDiv[clock->PERPLLCON1.B.K4PREDIV]))) + 0.5f;
    pllFrequency3 = pllFrequency3 * clock->PERPLLSTAT.B.PLLLOCK * clock->PERPLLSTAT.B.PWRSTAT;
    return (uint32)pllFrequency3;
}


uint32 IfxClock_getPerSourceFrequency(IfxClock_Fsource fsource)
{
    uint32 sourcefreq = 0;

    if (CLOCK_CCUSTAT.B.CLKSELP == IfxClock_PerClockSourceSelect_pll)
    {
        switch (fsource)
        {
        case IfxClock_Fsource_1:
            sourcefreq = IfxClock_getPerPllFrequency1();
            break;
        case IfxClock_Fsource_2:
            sourcefreq = IfxClock_getPerPllFrequency2();
            break;
        case IfxClock_Fsource_3:
            sourcefreq = IfxClock_getPerPllFrequency3();
            break;
        default:
            /* */
            break;
        }
    }
    else
    {
        /* IfxClock_SysClockSourceSelect_back: */
        sourcefreq = IfxClock_getEvrFrequency();
    }

    return sourcefreq;
}


uint32 IfxClock_getPllFrequency(void)
{
    Ifx_CLOCK *clock = &MODULE_CLOCK;
    uint64     oscFreq;
    uint64     freq;
    float32    preDiv[4] = {1.0f, 2.0f, 1.2f, 1.6f};

    oscFreq = IfxClock_getOscFrequency();
    freq    = (oscFreq * (clock->SYSPLLCON0.B.NDIV + 1)) / ((clock->SYSPLLCON0.B.PDIV + 1) * ((clock->SYSPLLCON1.B.K2DIV + 1) * (preDiv[clock->SYSPLLCON1.B.K2PREDIV]))) + 0.5f;
    freq    = freq * clock->SYSPLLSTAT.B.PLLLOCK * clock->SYSPLLSTAT.B.PWRSTAT;
    return (uint32)freq;
}


uint32 IfxClock_getPllPpuFrequency(void)
{
    Ifx_CLOCK *clock = &MODULE_CLOCK;
    uint64     oscFreq;
    uint64     freq;
    float32    preDiv[16] = {1.0f, 1.1f, 1.2f, 1.0f, 1.4f, 1.0f, 1.6f, 1.7f, 1.0f, 1.0f, 2.0f, 1.0f, 1.0f, 1.0f, 1.0f, 1.0f};

    oscFreq = IfxClock_getOscFrequency();
    freq    = (oscFreq * (clock->SYSPLLCON0.B.NDIV + 1)) / ((clock->SYSPLLCON0.B.PDIV + 1) * ((clock->SYSPLLCON1.B.K3DIV + 1) * (preDiv[clock->SYSPLLCON1.B.K3PREDIV]))) + 0.5f;
    return (uint32)freq;
}


uint32 IfxClock_getQspiFrequency(void)
{
    uint32 freq       = 0;
    uint32 source     = 0;
    uint8  clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint8  actualDiv  = CLOCK_PERCCUCON0.B.QSPIDIV;

    switch (CLOCK_PERCCUCON0.B.CLKSELQSPI)
    {
    case 1:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1);
    }
    break;
    case 2:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_2);
    }
    break;
    default:
        freq = 0U;
        break;
    }

    if (actualDiv != 0)
    {
        freq = source / clkdiv[actualDiv];
    }

    return freq;
}


uint32 IfxClock_getSpbFrequency(void)
{
    uint32 spbFrequency;
    uint32 sourceFrequency;
    sourceFrequency = IfxClock_getSysSourceFrequency();
    uint8  clkdiv[16] = {4, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    if (CLOCK_SYSCCUCON0.B.LPDIV == 0)
    {
        /*Not in low power mode */
        spbFrequency = sourceFrequency / clkdiv[CLOCK_SYSCCUCON0.B.SPBDIV];
    }
    else
    {
        spbFrequency = sourceFrequency / 120;
    }

    return spbFrequency;
}


uint32 IfxClock_getSriFrequency(void)
{
    uint32 sriFrequency;
    uint32 sourceFrequency;
    sourceFrequency = IfxClock_getSysSourceFrequency();
    uint8  clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    if (CLOCK_SYSCCUCON0.B.LPDIV == 0)
    {
        /*Not in low power mode */
        sriFrequency = sourceFrequency / clkdiv[CLOCK_SYSCCUCON0.B.SRIDIV];
    }
    else
    {
        sriFrequency = sourceFrequency / 120;
    }

    return sriFrequency;
}


uint32 IfxClock_getSysSourceFrequency(void)
{
    uint32 sourcefreq = 0;

    switch (CLOCK_CCUSTAT.B.CLKSELS)
    {
    case IfxClock_SysClockSourceSelect_back:
        sourcefreq = IfxClock_getEvrFrequency();
        break;

    case IfxClock_SysClockSourceSelect_pll:
        sourcefreq = IfxClock_getPllFrequency();

        break;
    case IfxClock_SysClockSourceSelect_ramp:
        sourcefreq = IfxClock_getRampFrequency();
        break;
    default:
        sourcefreq = 0U;
        break;
    }

    return sourcefreq;
}


uint32 IfxClock_getPpuSourceFrequency(void)
{
    uint32 sourcefreq = 0;

    switch (CLOCK_CCUSTAT.B.CLKSELS)
    {
    case IfxClock_SysClockSourceSelect_back:
        sourcefreq = IfxClock_getEvrFrequency();
        break;

    case IfxClock_SysClockSourceSelect_pll:
        sourcefreq = IfxClock_getPllPpuFrequency();

        break;
    case IfxClock_SysClockSourceSelect_ramp:
        sourcefreq = IfxClock_getRampFrequency() / 2u;
        break;
    default:
        sourcefreq = 0U;
        break;
    }

    return sourcefreq;
}


uint32 IfxClock_getTpbFrequency(void)
{
    uint32 tpbFrequency = 0;
    uint32 sourceFrequency;

    if (CLOCK_SYSCCUCON0.B.TPBDIV != 0)
    {
        sourceFrequency = IfxClock_getSysSourceFrequency();
        uint8 clkdiv[16] = {4, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

        if (CLOCK_SYSCCUCON0.B.LPDIV == 0)
        {
            /*Not in low power mode */
            tpbFrequency = sourceFrequency / clkdiv[CLOCK_SYSCCUCON0.B.TPBDIV];
        }
        else
        {
            tpbFrequency = sourceFrequency / 120;
        }
    }

    return tpbFrequency;
}


#if !defined(IFX_ILLD_PPU_USAGE)
boolean IfxClock_init(const IfxClock_Config *config)
{
    boolean status = 0;

    if ((config != NULL_PTR) && (config->flashFconWaitStateConfig != ((void *)0)))
    {
        DMU_GP_HOST_DFWAIT.B.RFLASH = config->flashFconWaitStateConfig->dFlashWaitCycles;
        DMU_GP_HOST_PFWAIT.B.RFLASH = config->flashFconWaitStateConfig->pFlashWaitCycles;
    }

    if (config != NULL_PTR)
    {
        status = IfxClock_distributeClockInline(&config->clockDistribution);
    }
    else
    {
        status = 1U;
    }

    if (!status)
    {
        /* Store the crystal frequency */
        IfxClock_xtalFrequency = config->xtalFrequency;
        status                 = IfxClock_configureCcuPll(config);
    }

#ifndef IFX_CLOCK_SKIP_PLL_MODULATION_INIT

    if (!status)
    {
        IfxClock_modulation_init(config->modulationConfig);             /* initialize system Pll modulation */
        IfxClock_perPllModulation_init(config->perPllmodulationConfig); /* initialize peripheral Pll modulation */
    }

#endif

#if defined(IFX_CLOCK_DISABLE_RAMPCON)

    if (!status)
    {
        IfxClock_throttleSysPllClockInline(&config->sysPllThrottleConfig);
    }

#endif

    return status;
}


void IfxClock_initConfig(IfxClock_Config *cfg)
{
    *cfg = IfxClock_defaultClockConfig;
}


#endif

void IfxClock_modulation_init(const IfxClock_Mod_Config *Mod_Cfg)
{
    uint8                        initError         = 0;
    uint32                       timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;
    IfxClock_RGain_Values        RGain_P;
    IfxClock_XCorr_Values        XCorr_P;
    IfxClock_ModEn               mod_enable = Mod_Cfg->Mod_Enable;
    IfxClock_ModulationAmplitude Mod_Amp    = Mod_Cfg->Mod_Amp;

    Ifx_CLOCK_SYSPLLCON0         syspllcon0;
    Ifx_CLOCK_SYSPLLCON2         syspllcon2;

    if (mod_enable == IfxClock_ModEn_enabled)   /* do this only if modulation is enabled */
    {
        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_SYSPLLCON0.B.MODEN = 0x0;

        /* Get the parameters */
        IfxClock_calRGainParameters(Mod_Amp, &RGain_P);
        (void)IfxClock_calXCorrParameters(RGain_P.RGainNom, &XCorr_P);

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

        /* write all registers here */

        /* Write SYSPLLCON2 with RGain */
        syspllcon2.U        = CLOCK_SYSPLLCON2.U;
        syspllcon2.B.MODCFG = IFXCLOCK_GET_MODCFG(RGain_P.RGainHex);

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_SYSPLLCON2.U      = syspllcon2.U;
        CLOCK_SMODCON0.U        = 0x0;

        CLOCK_SMODCON0.B.CAL_EN = 1;
#if !defined(IFX_ILLD_PPU_USAGE)
        IfxClock_waitWithWdtService(IFXCLOCK_MODULATION_CAL_EN_TOGGLE_WAIT_TIME); /* 100 nano second wait to ensure toggling */
#endif
        CLOCK_SMODCON0.B.CAL_EN = 0;

        /* enable modulation now */
        syspllcon0.U       = CLOCK_SYSPLLCON0.U;
        syspllcon0.B.MODEN = (uint32)IfxClock_ModEn_enabled;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_SYSPLLCON0.U = syspllcon0.U;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

        while (CLOCK_SYSPLLSTAT.B.MODRUN != 1U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }

    IFX_UNUSED_PARAMETER(initError)
}


uint32 IfxClock_setAsclinFFrequency(uint32 asclinFFreq)
{
    uint32               freq       = 0;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint32               source     = IfxClock_getPerSourceFrequency(IfxClock_Fsource_2);
    Ifx_CLOCK_PERCCUCON1 perccucon1 = CLOCK_PERCCUCON1;

    uint32               asclinFDiv = (uint32)__roundf(source / asclinFFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (asclinFDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon1.B.ASCLINFDIV = clkdiv[asclinFDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON1.U = perccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getAsclinFFrequency();
    return freq;
}


uint32 IfxClock_setAsclinSFrequency(uint32 asclinSFreq)
{
    uint32               freq       = 0;
    uint32               source     = 0;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    Ifx_CLOCK_PERCCUCON1 perccucon1 = CLOCK_PERCCUCON1;

    switch (perccucon1.B.CLKSELASCLINS)
    {
    case 1:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1);
    }
    break;
    case 2:
    {
        source = IfxClock_getOsc0Frequency();
    }
    break;
    default:
        /* source*/
        break;
    }

    uint32 asclinSDiv = (uint32)__roundf(source / asclinSFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (asclinSDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon1.B.ASCLINSDIV = clkdiv[asclinSDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON1.U = perccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getAsclinSFrequency();
    return freq;
}


uint32 IfxClock_setCpbFrequency(uint32 cpbFreq)
{
    Ifx_CLOCK_SYSCCUCON0 sysccucon0;
    uint32               inputFreq  = IfxClock_getSysSourceFrequency();
    uint32               cpbDiv     = (uint32)(inputFreq / cpbFreq);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (cpbDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon0.U        = CLOCK_SYSCCUCON0.U;
    sysccucon0.B.CPBDIV = clkdiv[cpbDiv];
    sysccucon0.B.UP     = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON0.U = sysccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getCpbFrequency();
}


uint32 IfxClock_setFsiFrequency(uint32 fsiFreq)
{
    uint32               frequency = 0;
    Ifx_CLOCK_SYSCCUCON0 ccucon0   = CLOCK_SYSCCUCON0;

    uint32               fsiDiv;
    frequency = IfxClock_getSriFrequency();
    fsiDiv    = (uint32)__roundf(frequency / fsiFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (fsiDiv <= IFXCLOCK_DIVIDER_15));
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    ccucon0.U        = CLOCK_SYSCCUCON0.U;
    ccucon0.B.FSIDIV = fsiDiv;
    ccucon0.B.UP     = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON0.U = ccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    frequency = IfxClock_getFsiFrequency();

    return frequency;
}


uint32 IfxClock_setI2cFrequency(uint32 i2cFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getPerSourceFrequency(IfxClock_Fsource_2);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    Ifx_CLOCK_PERCCUCON0 perccucon0;
    uint32               i2cDiv     = (uint32)__roundf(source / i2cFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (i2cDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon0.U        = CLOCK_PERCCUCON0.U;
    perccucon0.B.I2CDIV = clkdiv[i2cDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON0.U = perccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getI2cFrequency();
    return freq;
}


uint32 IfxClock_setMcanFrequency(uint32 mcanFreq)
{
    uint32               source     = 0;
    Ifx_CLOCK_PERCCUCON0 perccucon0 = CLOCK_PERCCUCON0;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    switch (perccucon0.B.CLKSELMCAN)
    {
    case 1:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1);
    }
    break;
    case 2:
    {
        source = IfxClock_getOsc0Frequency();
    }
    break;
    default:
        /* source */
        break;
    }

    uint32 mcanDiv = (uint32)__roundf(source / mcanFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (mcanDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon0.B.MCANDIV = clkdiv[mcanDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON0.U = perccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getMcanFrequency();
}


uint32 IfxClock_setMcanhFrequency(uint32 mcanhFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getSysSourceFrequency();
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    Ifx_CLOCK_SYSCCUCON1 sysccucon1;
    uint32               mcanhDiv   = (uint32)__roundf(source / mcanhFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (mcanhDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon1.U          = CLOCK_SYSCCUCON1.U;
    sysccucon1.B.MCANHDIV = clkdiv[mcanhDiv];
    sysccucon1.B.UP       = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON1.U = sysccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getMcanhFrequency();
    return freq;
}


uint32 IfxClock_setMscFrequency(uint32 mscFreq)
{
    uint32               mscSource  = 0;
    Ifx_CLOCK_PERCCUCON0 perccucon0 = CLOCK_PERCCUCON0;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    switch (perccucon0.B.CLKSELMSC)
    {
    case 1:
    {
        mscSource = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1);
    }
    break;
    case 2:
    {
        mscSource = IfxClock_getPerSourceFrequency(IfxClock_Fsource_2);
    }
    break;
    default:
        /* mscSource  */
        break;
    }

    uint32 mscDiv = (uint32)__roundf(mscSource / mscFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (mscDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon0.B.MSCDIV = clkdiv[mscDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON0.U = perccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getMscFrequency();
}


uint32 IfxClock_setQspiFrequency(uint32 qspiFreq)
{
    uint32               source     = 0;
    Ifx_CLOCK_PERCCUCON0 perccucon0 = CLOCK_PERCCUCON0;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    switch (CLOCK_PERCCUCON0.B.CLKSELQSPI)
    {
    case 1:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1);
    }
    break;
    case 2:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_2);
    }
    break;
    default:
        /* source */
        break;
    }

    uint32 qspiDiv = (uint32)__roundf(source / qspiFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (qspiDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon0.B.QSPIDIV = clkdiv[qspiDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON0.U = perccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getQspiFrequency();
}


uint32 IfxClock_setSpbFrequency(uint32 spbFreq)
{
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    Ifx_CLOCK_SYSCCUCON0 sysccucon0;
    uint32               inputFreq  = IfxClock_getSysSourceFrequency();
    uint32               spbDiv     = (uint32)(inputFreq / spbFreq);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (spbDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon0.U        = CLOCK_SYSCCUCON0.U;
    sysccucon0.B.SPBDIV = clkdiv[spbDiv];
    sysccucon0.B.UP     = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON0.U = sysccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getSpbFrequency();
}


uint32 IfxClock_setSriFrequency(uint32 sriFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getSysSourceFrequency();
    Ifx_CLOCK_SYSCCUCON0 sysccucon0;
    uint32               sriDiv     = (uint32)__roundf(source / sriFreq);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (sriDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon0.U        = CLOCK_SYSCCUCON0.U;
    sysccucon0.B.SRIDIV = clkdiv[sriDiv];
    sysccucon0.B.UP     = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON0.U = sysccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getSriFrequency();
    return freq;
}


uint32 IfxClock_setStmFrequency(uint32 stmFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getSysSourceFrequency();
    Ifx_CLOCK_SYSCCUCON0 sysccucon0;
    uint32               stmDiv     = (uint32)__roundf(source / stmFreq);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (stmDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon0.U        = CLOCK_SYSCCUCON0.U;
    sysccucon0.B.STMDIV = clkdiv[stmDiv];
    sysccucon0.B.UP     = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON0.U = sysccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getStmFrequency();
    return freq;
}


uint32 IfxClock_setTpbFrequency(uint32 tpbFreq)
{
    /* TODO: check whether it is necessary to disable trap and/or the safety */
    Ifx_CLOCK_SYSCCUCON0 sysccucon0;
    uint32               inputFreq  = IfxClock_getSysSourceFrequency();
    uint32               tpbDiv     = (uint32)(inputFreq / tpbFreq);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (tpbDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    //   IfxScuWdt_clearCpuEndinit (l_EndInitPW);
    //   CLOCK_TRAPDIS.U = CLOCK_TRAPDIS.U | 0x3E0U;
    //   IfxScuWdt_setCpuEndinit (l_EndInitPW);

    sysccucon0.U        = CLOCK_SYSCCUCON0.U;
    sysccucon0.B.TPBDIV = clkdiv[tpbDiv];
    sysccucon0.B.UP     = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON0.U = sysccucon0.U;

    //    IfxScuWdt_clearCpuEndinit (l_EndInitPW);
    //    CLOCK_TRAPDIS.U = CLOCK_TRAPDIS.U & (uint32)~0x3E0UL;
    //    IfxScuWdt_setCpuEndinit (l_EndInitPW);
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getTpbFrequency();
}


uint32 IfxClock_setXGeth0Frequency(uint32 gethFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getSysSourceFrequency();
    Ifx_CLOCK_SYSCCUCON1 sysccucon1;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint32               gethDiv    = (uint32)__roundf(source / gethFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (gethDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon1.U         = CLOCK_SYSCCUCON1.U;
    sysccucon1.B.GETHDIV = clkdiv[gethDiv];
    sysccucon1.B.UP      = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON1.U = sysccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getXGeth0Frequency();
    return freq;
}


uint32 IfxClock_seteGtmFrequency(uint32 eGtmFreq)
{
    Ifx_CLOCK_SYSCCUCON1 sysccucon1 = CLOCK_SYSCCUCON1;
    uint32               eGtmDiv    = 0;

    uint32               inputFreq  = IfxClock_getSysSourceFrequency();
    eGtmDiv = (uint32)__roundf(inputFreq / eGtmFreq);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (eGtmDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon1.B.EGTMDIV = clkdiv[eGtmDiv];
    sysccucon1.B.UP      = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON1.U = sysccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_geteGtmFrequency();
}


uint32 IfxClock_setXspiFrequency(uint32 xSpiFreq)
{
    uint32               freq        = 0U;
    uint8                i           = 0U, j = 0U;
    uint32               relError    = xSpiFreq;
    uint32               newRelError = 0U;
    uint32               limit       = xSpiFreq / 1000000U;
    uint32               pllDcoFreq  = IfxClock_getPerPllDcoFrequency();
    uint8                k4DivBest   = 0U, k4PreDivBest = 0U;
    uint32               k4PreDiv[4] = {10, 20, 12, 16};
    Ifx_CLOCK_PERPLLCON1 perPllCon1;

    for (i = 1U; i <= 8U; i++)
    {
        for (j = 0; j < 4U; j++)
        {
            freq        = (uint32)(pllDcoFreq) / (uint32)(i * k4PreDiv[j]);

            newRelError = Ifx__abs((sint32)(xSpiFreq - (freq * 10)));

            if (relError > newRelError)
            {
                relError     = newRelError;
                k4DivBest    = i;
                k4PreDivBest = j;
            }

            if (relError <= limit)
            {
                break;
            }
        }

        if (relError <= limit)
        {
            break;
        }
    }

    perPllCon1.U          = CLOCK_PERPLLCON1.U;

    perPllCon1.B.K4DIV    = k4DivBest - 1;
    perPllCon1.B.K4PREDIV = k4PreDivBest;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERPLLCON1.U = perPllCon1.U;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    freq = IfxClock_getXspiFrequency();

    return freq;
}


uint32 IfxClock_initPll3Dividers(IfxClock_K4divider k4Div, IfxClock_K4PreDivider k4PreDiv)
{
    Ifx_CLOCK_PERPLLCON1 perpllcon1;

    perpllcon1.U          = CLOCK_PERPLLCON1.U;

    perpllcon1.B.K4DIV    = k4Div;
    perpllcon1.B.K4PREDIV = k4PreDiv;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    CLOCK_PERPLLCON1.U = perpllcon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getXspiFrequency();
}


boolean IfxClock_switchToBackupClock(const IfxClock_Config *cfg)
{
    uint8 initError = 0;

    if (CLOCK_CCUCON.B.CLKSELS == IfxClock_SysClockSourceSelect_back) /* Already source is backup clock */
    {
        return initError;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    /*Start Pll ramp down sequence */

    {
        Ifx_CLOCK_CCUCON ccucon0;
        ccucon0.U         = CLOCK_CCUCON.U;
#if !defined(IFX_CLOCK_DISABLE_RAMPCON)
        ccucon0.B.CLKSELS = IfxClock_SysClockSourceSelect_ramp; /*Select the Rampcon as fsource0/1/2 for the clock distribution */
#endif
        ccucon0.B.CLKSELP = IfxClock_SysClockSourceSelect_back;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {}

        CLOCK_CCUCON.U = ccucon0.U;
    }

#if !defined(IFX_CLOCK_DISABLE_RAMPCON)
    // TODO:  check for PSTAT needed or Not ?
    /* Configure the Ramp oscillator (RAMPCON UFL, SZ, WAIT) for the desired Sys PLL frequency (100MHZ) and enable CMD to ramp down.
     * Enable clock source (CCUCON.CLKSELS = RAMP) to RAMPCON frequency. */
    {
        Ifx_CLOCK_RAMPCON0 rampcon;
        rampcon.U     = CLOCK_RAMPCON0.U;
        rampcon.B.UFL = 100;                               /*upper target frequency in 1 MHz steps */
        rampcon.B.CMD = IfxClock_RampSeqCmd_rampDown;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {}

        CLOCK_RAMPCON0.U = rampcon.U;
    }

    {
        uint32 timeoutCycleCount;

        /* Wait for Ramp oscillator to reach the desired frequency */
        timeoutCycleCount = IFXCLOCK_PLL_RAMPOSC_TIMEOUT_COUNT;

        while (IfxClock_getRampFreqStatus() != IfxClock_RampFreqStatus_atBase)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }
#else
    {
        uint8  pllStepsCount;
        uint32 timeoutCycleCount;
        uint8  i;

        /*Start Pll ramp down sequence */
        for (pllStepsCount = cfg->sysPllThrottleConfig.numOfSteps; pllStepsCount > 0; pllStepsCount--)
        {                   /*iterate through number of pll steps */
            timeoutCycleCount = IFXCLOCK_PLL_K2DIV_COUNT << 5;

            while ((CLOCK_CCUSTAT.B.LCK != 0U) && timeoutCycleCount--)
            {}

            /*Now set the K2 divider value for the step corresponding to step count */
            CLOCK_SYSPLLCON1.B.K2DIV = cfg->sysPllThrottleConfig.pllSteps[pllStepsCount - 1];

            /*Wait for 6 PLL0 cycles corresponding to the pll step */
            for (i = 0; i < IFXCLOCK_PLL_K2DIV_COUNT; i++)
            {}
        }
    }
#endif

    {
        Ifx_CLOCK_CCUCON ccucon0;
        ccucon0.U         = CLOCK_CCUCON.U;
        ccucon0.B.CLKSELS = IfxClock_SysClockSourceSelect_back; /*Select the Rampcon as fsource0/1/2 for the clock distribution */

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {}

        CLOCK_CCUCON.U = ccucon0.U;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {}
    }
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif
    return initError;
}


void IfxClock_configureAccessToClock(IfxApApu_ApuConfig *apConfig)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_CLOCK.ACCEN, (IfxApApu_ApuConfig *)apConfig);
}


uint32 IfxClock_getSriCsFrequency(void)
{
    uint32 sriFrequency;
    uint32 sourceFrequency;
    sourceFrequency = IfxClock_getSysSourceFrequency();

    if (CLOCK_SYSCCUCON0.B.LPDIV == 0)
    {
        /*Not in low power mode */
        if (CLOCK_SYSCCUCON0.B.SRICSDIV == 0U)
        {
            sriFrequency = IfxClock_getSriFrequency();
        }
        else
        {
            sriFrequency = (IfxClock_getSriFrequency() / 2U);
        }
    }
    else
    {
        sriFrequency = sourceFrequency / 120;
    }

    return sriFrequency;
}


uint32 IfxClock_getCanXLFrequency(void)
{
    uint32 canFreq    = 0;
    uint32 canSource  = 0;
    uint8  clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint8  actualDiv  = CLOCK_PERCCUCON1.B.CANXLDIV;

    switch (CLOCK_PERCCUCON1.B.CLKSELCANXL)
    {
    case 1:
    {
        canSource = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1); /* fPLL1*/

        if (actualDiv != 0)
        {
            canFreq = canSource / clkdiv[actualDiv];
        }
    }
    break;
    case 2:
    {
        canFreq = IfxClock_getOsc0Frequency();
    }
    break;
    default:
        canFreq = 0U;
        break;
    }

    return canFreq;
}


uint32 IfxClock_setCanXLFrequency(uint32 canXLFreq)
{
    uint32               source     = 0;
    Ifx_CLOCK_PERCCUCON1 perccucon1 = CLOCK_PERCCUCON1;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};

    switch (perccucon1.B.CLKSELCANXL)
    {
    case 1:
    {
        source = IfxClock_getPerSourceFrequency(IfxClock_Fsource_1);
    }
    break;
    case 2:
    {
        source = IfxClock_getOsc0Frequency();
    }
    break;
    default:
        /* source */
        break;
    }

    uint32 canDiv = (uint32)__roundf(source / canXLFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (canDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon1.B.CANXLDIV = clkdiv[canDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON1.U = perccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    return IfxClock_getCanXLFrequency();
}


uint32 IfxClock_setCanXLhFrequency(uint32 canXlhFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getSysSourceFrequency();
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    Ifx_CLOCK_SYSCCUCON1 sysccucon1;
    uint32               canhDiv    = (uint32)__roundf(source / canXlhFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (canhDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon1.U           = CLOCK_SYSCCUCON1.U;
    sysccucon1.B.CANXLHDIV = clkdiv[canhDiv];
    sysccucon1.B.UP        = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON1.U = sysccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getCanXLhFrequency();
    return freq;
}


uint32 IfxClock_setLethFrequency(uint32 lethFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getSysSourceFrequency();
    Ifx_CLOCK_SYSCCUCON1 sysccucon1;
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    uint32               lethDiv    = (uint32)__roundf(source / lethFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (lethDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    sysccucon1.U         = CLOCK_SYSCCUCON1.U;
    sysccucon1.B.LETHDIV = clkdiv[lethDiv];
    sysccucon1.B.UP      = 1;

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_SYSCCUCON1.U = sysccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getLethFrequency();
    return freq;
}


void IfxClock_enableExtClockOut0(IfxClock_ClkSel0 Clk_Sel, const uint32 freqHz, IfxClock_Clk0Mode mode)
{
    Ifx_CLOCK_EXTCON   extcon;
    Ifx_CLOCK_EXTFDCON extfdcon;

    extfdcon.U    = CLOCK_EXTFDCON.U;
    extcon.U      = CLOCK_EXTCON.U;

    extcon.B.SEL0 = (uint32)Clk_Sel;

    if (IfxClock_ClkSel0_fFRAC == Clk_Sel)
    {
        if (mode == IfxClock_Clk0Mode_normal)
        {
            extfdcon.B.DM = 1U;

            /* normal divider mode */
            if (freqHz == (IfxClock_getSpbFrequency() / 2))
            {
                extfdcon.B.STEP = 0x3FFu;
            }
            else
            {
                extfdcon.B.STEP = (uint32)(1024u - (IfxClock_getSpbFrequency() / (2u * freqHz)));
            }
        }
        else
        {
            /* fractional divider mode */
            extfdcon.B.DM   = 2U;
            extfdcon.B.STEP = (uint32)(((2u * freqHz) * 1024u) / (IfxClock_getSpbFrequency()));
        }
    }

    extcon.B.EN0 = 1U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif
    CLOCK_EXTFDCON.U = extfdcon.U;
    CLOCK_EXTCON.U   = extcon.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif
}


void IfxClock_enableExtClockOut1(IfxClock_ClkSel1 Clk_Sel, const uint32 freqHz, IfxClock_Clk1Negation sel)
{
    Ifx_CLOCK_EXTCON extcon;

    extcon.U      = CLOCK_EXTCON.U;

    extcon.B.SEL1 = (uint32)Clk_Sel;

    if (IfxClock_ClkSel1_fDIV1 == Clk_Sel)
    {
        extcon.B.DIV1  = (uint32)((IfxClock_getSpbFrequency() / freqHz) - 1U);
        extcon.B.NSEL1 = sel;
    }

    extcon.B.EN1 = 1U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif
    CLOCK_EXTCON.U = extcon.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif
}


uint32 IfxClock_getExtClock0Frequency(void)
{
    uint32 freq = 0u;

    if (CLOCK_EXTCON.B.EN0) //	EXTCLK0 enabled
    {
        switch (CLOCK_EXTCON.B.SEL0)
        {
        case 0:
            freq = IfxClock_getEvrFrequency();         //	fBACK
            break;
        case 1:
            freq = IfxClock_getRampFrequency();        //	fRAMP
            break;
        case 2:
            freq = IfxClock_getOscFrequency();         //	fOSC
            break;
        case 3:
            freq = IfxClock_getPllFrequency();         //	fPLL0
            break;
        case 4:
            freq = IfxClock_getPerPllFrequency1();     //	fPLL1
            break;
        case 5:
            freq = IfxClock_getPerPllFrequency2();     //	fPLL2
            break;
        case 6:
            freq = IfxClock_getPerPllFrequency3();     //	fPLL3
            break;
        case 7:
            freq = IfxClock_getModuleFrequency() / 2u; //	fFRAC
            break;
        case 8:
            freq = IfxClock_getSpbFrequency();         //	fSPB
            break;
        case 9:
            freq = IfxClock_getCpbFrequency();         //  fCPB
            break;
        case 0xa:
            freq = IfxClock_getTpbFrequency();         //	fTPB
            break;
        case 0xb:
            freq = IfxClock_getSriFrequency();         //	fSRI
            break;
        case 0xc:
            freq = IfxClock_getFsiFrequency();         //	fFSI
            break;
        case 0xe:
            freq = IfxClock_getStmFrequency();         //	fSTM
            break;
        case 0x10:
            freq = IfxClock_geteGtmFrequency();        // feGTM
            break;

        case 0x11:
            freq = IfxClock_getXGeth0Frequency();   // fGETH
            break;
        case 0x12:
            freq = IfxClock_getMcanhFrequency();    //fMCANH
            break;
        case 0x16:
            freq = IfxClock_getLethFrequency();     //fLETH
            break;
        case 0x17:
            freq = IfxClock_getPpuFrequency();      //fPPU
            break;
        case 0x18:
            freq = IfxClock_getCanXLhFrequency();   //fCANXLH
            break;
        default:
            freq = 0;
        }
    }

    return freq;
}


uint32 IfxClock_getExtClock1Frequency(void)
{
    uint32 freq = 0u;

    if (CLOCK_EXTCON.B.EN1)     //	EXTCLK1 enabled
    {
        switch (CLOCK_EXTCON.B.SEL1)
        {
        case 0:
            freq = IfxClock_getEvrFrequency();                             //	fBACK
            break;
        case 1:
            freq = IfxClock_getRampFrequency();                            //	fRAMP
            break;
        case 2:
            freq = IfxClock_getOscFrequency();                             //	fOSC
            break;
        case 3:
            freq = IfxClock_getPllFrequency();                             //	fPLL0
            break;
        case 4:
            freq = IfxClock_getPerPllFrequency1();                         //	fPLL1
            break;
        case 5:
            freq = IfxClock_getPerPllFrequency2();                         //	fPLL2
            break;
        case 6:
            freq = IfxClock_getPerPllFrequency3();                         //	fPLL3
            break;
        case 7:
            freq = IfxClock_getSpbFrequency() / (CLOCK_EXTCON.B.DIV1 + 1); //	fDIV1
            break;
        case 9:
            freq = IfxClock_getMt0Frequency();                             //  fMT0
            break;
        case 0xa:
            freq = IfxClock_getErayFrequency();                            //   fERAY
            break;
        case 0xb:
            freq = IfxClock_getMcanFrequency();                            //	fMCAN
            break;
        case 0xc:
            freq = IfxClock_getAdcFrequency();                             //	fADC
            break;
        case 0xd:
            freq = IfxClock_getQspiFrequency();                            //	fQSPI
            break;
        case 0xe:
            freq = IfxClock_getMscFrequency();                             //	fMSC
            break;
        case 0xf:
            freq = IfxClock_getI2cFrequency();                             // fI2C
            break;
        case 0x10:
            freq = IfxClock_getAsclinFFrequency();                         // fASCLINF
            break;
        case 0x11:
            freq = IfxClock_getAsclinSFrequency();                         //fASCLINS
            break;
        case 0x13:
            freq = IfxClock_getXspiFrequency();                            // fXSPI
            break;
        case 0x14:
            freq = IfxClock_getSdmmcFrequency();                           // fSDMMC
            break;
        case 0x15:
            freq = IfxClock_getPpuFrequency();                             //fPPU
            break;
        case 0x16:
            freq = IfxClock_getCanXLFrequency();                           //fCANXL
            break;
        case 0x17:
            freq = IfxClock_getLeth100Frequency();                         //fLETH100
            break;
        case 0x18:
            freq = IfxClock_getXspislFrequency();                          //fXSPISL
            break;
        default:
            freq = 0;
        }
    }

    return freq;
}


boolean IfxClock_configureRampOscillator(uint32 rampFreq, IfxClock_RampSeqCmd rampSeqCmd)
{
    uint8 initError = 0;

    if (rampSeqCmd == IfxClock_RampSeqCmd_rampUp)
    {
        /* Configure the Ramp oscillator (RAMPCON UFL) for the desired Sys PLL frequency and enable CMD to ramp up */
        IfxClock_configureRampUp(rampFreq);
    }

    else if (rampSeqCmd == IfxClock_RampSeqCmd_rampDown)
    {
        /*	Configure the Ramp oscillator (RAMPCON UFL) for the desired Sys PLL frequency (100MHZ) and enable CMD to ramp down */
        Ifx_CLOCK_RAMPCON0 rampcon;
        rampcon.U     = CLOCK_RAMPCON0.U;
        rampcon.B.UFL = 100;                                              //upper target frequency in 1 MHz steps
        rampcon.B.CMD = IfxClock_RampSeqCmd_rampDown;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {}

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif
        CLOCK_RAMPCON0.U = rampcon.U;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

        {
            uint32 timeoutCycleCount;

            /* Wait for Ramp oscillator to reach the base frequency (100MHZ) */
            timeoutCycleCount = IFXCLOCK_PLL_RAMPOSC_TIMEOUT_COUNT;

            while ((IfxClock_getRampFreqStatus() != IfxClock_RampFreqStatus_atBase) && (CLOCK_RAMPSTAT.B.FLLLOCK != 1))
            {
                IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
            }
        }

        /* Now Ramp up to the desired frequency */
        IfxClock_configureRampUp(rampFreq);
    }

    else
    {
        /* No default case */
    }

    return (boolean)initError;
}


void IfxClock_perPllModulation_init(const IfxClock_perPllMod_Config *Mod_Cfg)
{
    uint8                              initError         = 0;
    uint32                             timeoutCycleCount = IFXCLOCK_CCUCON_LCK_BIT_TIMEOUT_COUNT;
    IfxClock_RGain_Values              RGain_P;
    IfxClock_XCorr_Values              XCorr_P;
    IfxClock_ModEn                     mod_enable = Mod_Cfg->Mod_Enable;
    IfxClock_PerPllModulationAmplitude Mod_Amp    = Mod_Cfg->Mod_Amp;

    Ifx_CLOCK_PERPLLCON0               perpllcon0;
    Ifx_CLOCK_PERPLLCON2               perpllcon2;

    if (mod_enable == IfxClock_ModEn_enabled)   /* do this only if modulation is enabled */
    {
        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_PERPLLCON0.B.MODEN = 0x0;

        /* Get the parameters */
        IfxClock_perPllCalRGainParameters(Mod_Amp, &RGain_P);
        (void)IfxClock_calXCorrParameters(RGain_P.RGainNom, &XCorr_P);

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

        /* write all registers here */

        /* Write PERPLLCON2 with RGain */
        perpllcon2.U        = CLOCK_PERPLLCON2.U;
        perpllcon2.B.MODCFG = IFXCLOCK_GET_MODCFG(RGain_P.RGainHex);

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_PERPLLCON2.U = perpllcon2.U;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_PMODCON0.U = 0x0;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_PMODCON0.B.CAL_EN = 1;
#if !defined(IFX_ILLD_PPU_USAGE)
        IfxClock_waitWithWdtService(IFXCLOCK_MODULATION_CAL_EN_TOGGLE_WAIT_TIME); /* 100 nano second wait to ensure toggling */
#endif

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_PMODCON0.B.CAL_EN = 0;
        /* enable modulation now */

        perpllcon0.U       = CLOCK_PERPLLCON0.U;
        perpllcon0.B.MODEN = (uint32)IfxClock_ModEn_enabled;

        while (CLOCK_CCUSTAT.B.LCK != 0U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        CLOCK_PERPLLCON0.U = perpllcon0.U;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

        while (CLOCK_PERPLLSTAT.B.MODRUN != 1U)
        {
            IFXCLOCK_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }
    }

    IFX_UNUSED_PARAMETER(initError)
}


uint32 IfxClock_setXspislFrequency(uint32 xspislFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getPerSourceFrequency(IfxClock_Fsource_3);
    uint8                clkdiv[16] = {1, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    Ifx_CLOCK_PERCCUCON1 perccucon1;
    uint32               xspislDiv  = (uint32)__roundf(source / xspislFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (xspislDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon1.U           = CLOCK_PERCCUCON1.U;
    perccucon1.B.XSPISLDIV = clkdiv[xspislDiv];

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON1.U = perccucon1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getXspislFrequency();
    return freq;
}


uint32 IfxClock_setPpuFrequency(uint32 ppuFreq)
{
    uint32               freq       = 0;
    uint32               source     = IfxClock_getPpuSourceFrequency();
    uint8                clkdiv[16] = {0, 1, 2, 3, 4, 5, 6, 6, 8, 8, 10, 10, 12, 12, 12, 15};
    Ifx_CLOCK_PERCCUCON0 perccucon0;
    uint32               ppuDiv     = (uint32)__roundf(source / ppuFreq);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (ppuDiv <= IFXCLOCK_DIVIDER_15));

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_config);
#endif

    perccucon0.U = CLOCK_PERCCUCON0.U;

    if (ppuFreq != 0)
    {
        perccucon0.B.PPUDIV = clkdiv[ppuDiv];
    }
    else
    {
        perccucon0.B.PPUDIV = 0;
    }

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    CLOCK_PERCCUCON0.U = perccucon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTE, IfxApProt_State_run);
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {}

    freq = IfxClock_getPpuFrequency();
    return freq;
}
