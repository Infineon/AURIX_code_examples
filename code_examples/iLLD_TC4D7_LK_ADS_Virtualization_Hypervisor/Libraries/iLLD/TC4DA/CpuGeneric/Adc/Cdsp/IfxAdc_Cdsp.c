/**
 * \file IfxAdc_Cdsp.c
 * \brief ADC CDSP details
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxAdc_Cdsp.h"

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to convert buffer size in half word from enum
 * \param value Enum of circular buffer
 * \return Return size of buffer in bytes from enum value
 */
IFX_INLINE uint16 IfxAdc_Cdsp_getBufferSize(IfxAdc_Cdsp_BufferSize value);

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to the configure boundary
 * \param dsp Pointer to Dsp core sfr
 * \param config pointer to configuration of boundary
 * \return None
 */
IFX_STATIC void IfxAdc_Cdsp_configureBoundary(Ifx_ADC_CDSP_DSP *dsp, IfxAdc_Cdsp_BoundaryConfig *config);

/** \brief Setup Triggers for DSP core
 * \param dsp Pointer to DSP core sfr
 * \param triggerCfg Pointer to the trigger Configuration
 * \return None
 */
IFX_STATIC void IfxAdc_Cdsp_setupTriggers(Ifx_ADC_CDSP_DSP *dsp, IfxAdc_Cdsp_TriggerConfig *triggerCfg);

/** \brief Function to setup the result buffer.
 * \param queueConfig Pointer to queue configuration
 * \param dsp Pointer to dsp core handle
 * \return Return
 * FALSE --> Setting up of result buffer is successful
 * TRUE --> Issue in setting up of result buffer
 */
IFX_STATIC boolean IfxAdc_Cdsp_setupBuffer(IfxAdc_Cdsp_QueueConfig *queueConfig, IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to the configure DMA
 * \param queue Pointer to queue configuration
 * \param dsp Pointer to handle of Dsp core
 * \return None
 */
IFX_STATIC void IfxAdc_Cdsp_configureDma(IfxAdc_Cdsp_QueueConfig *queue, IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to update internal handle information from DMA.
 * \param dsp Pointer to dsp core handle
 * \return None
 */
IFX_STATIC void IfxAdc_Cdsp_updateHandleInfoFromDma(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Configures the software Integrator of the Cdsp core
 * \param dsp Pointer to DSP core sfr
 * \param integratorCfg Pointer to the software Integrator Configuration
 * \return None
 */
IFX_STATIC void IfxAdc_Cdsp_setupIntegrator(Ifx_ADC_CDSP_DSP *dsp, IfxAdc_Cdsp_SwIntegratorConfig *integratorCfg);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint16 IfxAdc_Cdsp_getBufferSize(IfxAdc_Cdsp_BufferSize value)
{
    uint16 bufferSize = 1u;

    while (value != 0u)
    {
        bufferSize = (bufferSize << 1u);
        value--;
    }

    //Buffer size in half words.
    bufferSize = (bufferSize >> 1u);

    return bufferSize;
}


/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAdc_Cdsp_initModule(IfxAdc_Cdsp *cdsp, const IfxAdc_Cdsp_Config *config)
{
    //1. Update handle
    cdsp->cdspSFR = &(config->adcSFR->CDSP);
    /* Enable clock for global parts of Cdsp*/
    IfxAdc_enableCdspGlobal();
}


void IfxAdc_Cdsp_initModuleConfig(IfxAdc_Cdsp_Config *config, Ifx_ADC *adc)
{
    //Initialize structure member to default values
    config->adcSFR = adc;
}


void IfxAdc_Cdsp_initDspCore(IfxAdc_Cdsp_Dsp *dsp, IfxAdc_Cdsp_DspCoreConfig *config)
{
    /* Declare, initialize variables/pointers */
    IfxAdc_CdspCore           coreId           = config->coreId;
    Ifx_ADC_CDSP             *modptr           = &(config->adcSFR->CDSP);
    Ifx_ADC_CDSP_DSP         *dspSfrPtr        = &(config->adcSFR->CDSP.DSP[coreId]);
    IfxAdc_Cdsp_ResultConfig *resultCfg        = &(config->resultCfg);
    IfxAdc_Cdsp_ResultSrvReq *resultServReqPtr = config->resSrvReqCfg;
    IfxAdc_Cdsp_EventSrvReq  *eventServReqPtr  = config->eventSrvReqCfg;
    IfxAdc_Cdsp_AlarmSrvReq  *alarmServReqPtr  = config->alarmSrvReqCfg;
    IfxAdc_Cdsp_MemoryConfig *memPtr           = config->memCfg;
    IfxAdc_Cdsp_QueueConfig  *queueCfgPtr      = config->queueCfg;
    IfxAdc_Cdsp_DmaConfig    *dmaCfgPtr        = NULL_PTR;
    volatile Ifx_SRC_SRCR    *src              = NULL_PTR;
    uint16                    index            = 0u;

    // Update Handle
    dsp->cdspSFR                   = modptr;
    dsp->dspSFR                    = dspSfrPtr;
    dsp->coreId                    = coreId;
    dsp->dataReadWidth             = resultCfg->dataReadWidth;
    dsp->fifoEnabled               = !(resultCfg->disableFifo);
    dsp->inputSel                  = config->inputSel;
    dsp->timeStampEnabled          = resultCfg->enableTimeStamp;
    dsp->state                     = IfxAdc_Cdsp_CoreState_uninitialized;
    dsp->fifoLevel                 = resultCfg->fifoSrvLevel;
    dsp->filterchain.filterchainId = config->filterchainSel;

    Ifx_ADC_CDSP_DSP_DSPCFG dspCfg;
    Ifx_ADC_CDSP_DSP_SRCFG  srcfg;

    //1. Enable DSP clock
    IfxAdc_enableCdspClock(coreId);

    // Read relevant registers
    dspCfg.U = dspSfrPtr->DSPCFG.U;
    srcfg.U  = dspSfrPtr->SRCFG.U;

    //2. Select input and input monitor for CDSP (TMADC, DSADC, EXMOD or GP)
    dspCfg.B.INPSEL = config->inputSel;
    dspCfg.B.HSIMON = config->inputMonitor;

    //3. Integrator configuration
    if (config->integratorCfg != NULL_PTR)
    {
        IfxAdc_Cdsp_setupIntegrator(dspSfrPtr, config->integratorCfg);
    }

    //4. Result configuration (clear fifo)
    /* Clear errors (Read, Write, Service Request, Timestamp, Integrator and boundary)*/
    {
        dspSfrPtr->CHERRCL.U = 0u;
    }
    /* Configure data read, fifo fill level and flush fifo */
    {
        dspCfg.B.DRM   = (resultCfg->disableFifo) ? (uint32)(0x01U) : (uint32)(resultCfg->dataReadWidth);
        dspCfg.B.TSM   = resultCfg->enableTimeStamp;
        dspCfg.B.SRLVL = resultCfg->fifoSrvLevel;
        dspCfg.B.RDM   = resultCfg->readAsUnsigned;
        dspCfg.B.FIFL  = 1u;
    }

    //5. Boundary configuration
    IfxAdc_Cdsp_configureBoundary(dspSfrPtr, config->bndCfg);

    //6. Timestamp configuration if needed
    if (config->timestampCfg != NULL_PTR)
    {
        dspCfg.B.TSCLK  = config->timestampCfg->clk;
        dspCfg.B.TSCRUN = config->timestampCfg->startCounter;
    }

    //Queue Configuration
    if (queueCfgPtr != NULL_PTR)
    {
        dmaCfgPtr = (queueCfgPtr->dmaCfg);

        /* Initialize and update the handle with buffer address and size*/
        IfxAdc_Cdsp_setupBuffer(queueCfgPtr, dsp);

        /* DMA configuration */
        if (dmaCfgPtr != NULL_PTR)
        {
            IfxAdc_Cdsp_configureDma(queueCfgPtr, dsp);
        }
        else
        {
            /* If DMA not configured update handle with FALSE*/
            dsp->queue.dma.useDma = FALSE;
        }
    }

    //7. Service Request configuration
    if (resultServReqPtr != NULL_PTR)
    {
        /*update Handle for result handler */
        dsp->resHandler = resultServReqPtr->resHandler;

        srcfg.B.SR0E    = resultServReqPtr->sr0Enable;
        src             = IfxAdc_getCdspSrcPointer(coreId, IfxAdc_CdspServiceReq_result);
        IfxSrc_init(src, resultServReqPtr->typeOfService, resultServReqPtr->priority, resultServReqPtr->vmId);
        IfxSrc_enable(src);
    }

    /* Timestamp, wakeup event service request configuration */
    if (eventServReqPtr != NULL_PTR)
    {
        srcfg.B.SR1E = eventServReqPtr->sr1Mode;
        src          = IfxAdc_getCdspSrcPointer(coreId, IfxAdc_CdspServiceReq_event);
        IfxSrc_init(src, eventServReqPtr->typeOfService, eventServReqPtr->priority, eventServReqPtr->vmId);
        IfxSrc_enable(src);
    }

    if (alarmServReqPtr != NULL_PTR)
    {
        srcfg.B.SR2E = alarmServReqPtr->sr2Enable;
        src          = IfxAdc_getCdspSrcPointer(coreId, IfxAdc_CdspServiceReq_alarm);
        IfxSrc_init(src, alarmServReqPtr->typeOfService, alarmServReqPtr->priority, alarmServReqPtr->vmId);
        IfxSrc_enable(src);
    }

    //8. Trigger Configuration
    IfxAdc_Cdsp_setupTriggers(dspSfrPtr, config->triggerCfg);

    //9. Pin configuration if any

    /* Write registers back */
    dspSfrPtr->SRCFG.U  = srcfg.U;
    dspSfrPtr->DSPCFG.U = dspCfg.U;

    //10 If memory pointer not NULL
    if (memPtr != NULL_PTR)
    {
        /* Reset Dsp Core*/
        IfxAdc_resetCdspCore(modptr, coreId);

        /* Wait till the ARC core is in halt state*/
        while (!IfxAdc_getCdspCoreHaltStatus(modptr, coreId))
        {}

        /* Clear CDSP ICCM and DCCM memory to avoid Ecc errors */
        uint32 *IccmAddr = (uint32 *)IFXADC_CDSP_GETICCM_ADDRESS(coreId);
        uint32 *dccmAddr = (uint32 *)IFXADC_CDSP_GETDCCM_ADDRESS(coreId);

        for (index = 0u; index < (ADC_CDSP_DSP0_ICCM_SIZE / 4U); index++)
        {
            IccmAddr[index] = 0u;
        }

        for (index = 0u; index < (ADC_CDSP_DSP0_DCCM_SIZE / 4U); index++)
        {
            dccmAddr[index] = 0u;
        }

        /* Load configuration in ICCM  memory.*/
        if (memPtr->codeMemSrcAddrPtr != NULL_PTR)
        {
            IfxAdc_loadCdspMemory(memPtr->codeMemSrcAddrPtr, (void *)IFXADC_CDSP_GETICCM_ADDRESS(coreId), memPtr->codeSize);
        }

        /* Load configuration in DCCM memory */
        if (memPtr->dataMemSrcAddrPtr != NULL_PTR)
        {
            IfxAdc_loadCdspMemory(memPtr->dataMemSrcAddrPtr, (void *)IFXADC_CDSP_GETDCCM_ADDRESS(coreId), memPtr->dataSize);
        }

/* FFT filter output data size*/
        if (dsp->filterchain.filterchainId == IfxAdc_Cdsp_FilterChainSel_fft)
        {
            // Get the number of samples configured for FFT filter
            dsp->filterchain.fftSize = IfxAdc_Cdsp_getNumOfSamples(dsp);

            if (dsp->filterchain.fftSize > 1u)
            {
                // output of fft filter size (frequency bins) NoOfSamples/2
                dsp->filterchain.fftSize = (dsp->filterchain.fftSize >> 1);
            }

            if (dmaCfgPtr != NULL_PTR)
            {
                IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (dsp->filterchain.fftSize != dsp->queue.size));
            }
        }

        /* Run Dsp Core*/
        if (config->runCdspCore)
        {
            IfxAdc_runCdspCore(modptr, coreId);
        }
    }

    dsp->state = IfxAdc_Cdsp_CoreState_initialized;
}


void IfxAdc_Cdsp_initDspCoreConfig(IfxAdc_Cdsp_DspCoreConfig *config, Ifx_ADC *adc)
{
    //Initialize all to default values
    const IfxAdc_Cdsp_DspCoreConfig defaultConfig = {
        .coreId         = IfxAdc_CdspCore_0,
        .inputSel       = IfxAdc_CdspInput_dsadc0,
        .inputMonitor   = IfxAdc_CdspInputMonitor_dsadc0,
        .adcSFR         = NULL_PTR,
        .timestampCfg   = NULL_PTR,
        .integratorCfg  = NULL_PTR,
        .bndCfg         = NULL_PTR,
        .triggerCfg     = NULL_PTR,
        .resSrvReqCfg   = NULL_PTR,
        .eventSrvReqCfg = NULL_PTR,
        .alarmSrvReqCfg = NULL_PTR,
        .memCfg         = NULL_PTR,
        .queueCfg       = NULL_PTR,
        .resultCfg      = {
            .readAsUnsigned  = FALSE,
            .enableTimeStamp = FALSE,
            .disableFifo     = FALSE,
            .dataReadWidth   = IfxAdc_CdspDataReadWidth_16Bit,
            .fifoSrvLevel    = IfxAdc_CdspFifoSrLevel_1
        },
        .runCdspCore    = TRUE,
        .filterchainSel = IfxAdc_Cdsp_FilterChainSel_basic,
    };

    *config        = defaultConfig;

    config->adcSFR = adc;
}


IFX_STATIC void IfxAdc_Cdsp_configureBoundary(Ifx_ADC_CDSP_DSP *dsp, IfxAdc_Cdsp_BoundaryConfig *config)
{
    Ifx_ADC_CDSP_DSP *coreSfr = dsp;

    if (config != NULL_PTR)
    {
        /* Read register */
        Ifx_ADC_CDSP_DSP_BNDCFG   bndCfg;
        Ifx_ADC_CDSP_DSP_BOUNDSEL bndSel;
        bndCfg.U           = coreSfr->BNDCFG.U;
        bndSel.U           = coreSfr->BOUNDSEL.U;

        bndSel.B.BOUNDARYL = config->lowerBound;
        bndSel.B.BOUNDARYU = config->upperBound;

        bndCfg.B.BNDMODE   = config->boundaryMode;
        bndCfg.B.HYSTEN    = config->hystEn;
        bndCfg.B.SR2CFG    = config->srvReqConfig;

        /* Write register back */
        coreSfr->BNDCFG.U   = bndCfg.U;
        coreSfr->BOUNDSEL.U = bndSel.U;
    }
}


IFX_STATIC void IfxAdc_Cdsp_setupTriggers(Ifx_ADC_CDSP_DSP *dsp, IfxAdc_Cdsp_TriggerConfig *triggerCfg)
{
    Ifx_ADC_CDSP_DSP *coreSfr = dsp;

    if (triggerCfg != NULL_PTR)
    {
        /* Boundary trigger configuration */
        if (triggerCfg->boundaryTrig != NULL_PTR)
        {
            Ifx_ADC_CDSP_DSP_BNDTRCFG bndTrCfg;
            bndTrCfg.B.BNDTRDLY = triggerCfg->boundaryTrig->delay;
            bndTrCfg.B.BNDTRM   = triggerCfg->boundaryTrig->edgeSel;
            bndTrCfg.B.BNDTRS   = triggerCfg->boundaryTrig->triggerSel;
            coreSfr->BNDTRCFG.U = bndTrCfg.U;
        }

        /* Timestamp trigger configuration */
        if (triggerCfg->timestampTrig != NULL_PTR)
        {
            Ifx_ADC_CDSP_DSP_TSTRCFG tsTrCfg;
            tsTrCfg.B.TSTRDLY  = triggerCfg->timestampTrig->delay;
            tsTrCfg.B.TSTRM    = triggerCfg->timestampTrig->edgeSel;
            tsTrCfg.B.TSTRS    = triggerCfg->timestampTrig->triggerSel;
            coreSfr->TSTRCFG.U = tsTrCfg.U;
        }

        /* Service request trigger configuration */
        if (triggerCfg->serviceReqTrig != NULL_PTR)
        {
            Ifx_ADC_CDSP_DSP_SRTRCFG srTrCfg;
            srTrCfg.B.SRTRDLY  = triggerCfg->serviceReqTrig->delay;
            srTrCfg.B.SRTRS    = triggerCfg->serviceReqTrig->triggerSel;
            coreSfr->SRTRCFG.U = srTrCfg.U;
        }

        if (triggerCfg->softwareTrig != NULL_PTR)
        {
            Ifx_ADC_CDSP_DSP_SWTRCFG swTrCfg;
            swTrCfg.B.SWTRDLY  = triggerCfg->softwareTrig->delay;
            swTrCfg.B.SWTRS    = triggerCfg->softwareTrig->triggerSel;
            swTrCfg.B.SWTRM    = triggerCfg->softwareTrig->edgeSel;
            coreSfr->SWTRCFG.U = swTrCfg.U;
        }
    }
}


uint16 IfxAdc_Cdsp_readDspCoreResult(IfxAdc_Cdsp_Dsp *dsp)
{
    Ifx_ADC_CDSP_DSP *dspSfrPtr  = dsp->dspSFR;
    uint16           *resultPtr  = &(dsp->result.result0[0]);
    uint16            result     = (uint16)dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;
    uint32            tempResVal = 0u;

    //RES 0
    if (IfxAdc_getCdspResultEvent(dsp->cdspSFR, dsp->coreId, IfxAdc_CdspResultReg_0))
    {
        /* Clear result event */
        IfxAdc_clearCdspResultEvent(dsp->cdspSFR, dsp->coreId, IfxAdc_CdspResultReg_0);
        dsp->result.timestampStatus = FALSE;

        if (dsp->fifoEnabled)
        {
            uint8 fillLevel = IfxAdc_getCdspFifoFillLevel(dsp->cdspSFR, dsp->coreId);
            uint8 readIndex = 0u;

            if ((dsp->timeStampEnabled) && (dsp->dspSFR->TSTMP.B.TSVAL))
            {
                dsp->result.timestampStatus = TRUE; // set the timstamp status for the valid timestamp
                tempResVal                  = dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;
                dsp->result.timestamp       = (uint16)tempResVal;
                readIndex++;

                if ((dsp->dataReadWidth == IfxAdc_CdspDataReadWidth_32Bit) && (readIndex < fillLevel))
                {
                    *resultPtr++ = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);
                    readIndex++;
                }
            }

            while (readIndex < fillLevel)
            {
                tempResVal   = dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;
                *resultPtr++ = (uint16)tempResVal;
                readIndex++;

                if ((dsp->dataReadWidth == IfxAdc_CdspDataReadWidth_32Bit) && (readIndex < fillLevel))
                {
                    *resultPtr++ = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);
                    readIndex++;
                }
            }

            result = dsp->result.result0[0];
        }
        else
        {
            tempResVal = dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;

            if ((dsp->timeStampEnabled) && (dsp->dspSFR->TSTMP.B.TSVAL))
            {
                dsp->result.timestampStatus = TRUE;
                dsp->result.timestamp       = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);
            }

            *resultPtr++ = (uint16)(tempResVal);

            if ((dsp->dataReadWidth == IfxAdc_CdspDataReadWidth_32Bit) && (dsp->timeStampEnabled == FALSE))
            {
                *resultPtr = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);
            }

            result = dsp->result.result0[0];
        }
    }

    return result;
}


uint16 IfxAdc_Cdsp_getNumberOfResults(IfxAdc_Cdsp_Dsp *dsp)
{
    uint16 validResult = 0u;

    if (!dsp->queue.dma.useDma)
    {
        if (dsp->queue.bufferType == IfxAdc_Cdsp_BufferType_linearWithTimestamp)
        {
            // First value in buffer will be timestamp so subtracting valid results by 1
            validResult = (dsp->queue.validResult - 1u);
        }
        else
        {
            validResult = dsp->queue.validResult;
        }
    }
    else //DMA: Calculate valid results from DMA destination address
    {
        IfxAdc_Cdsp_updateHandleInfoFromDma(dsp);
        validResult = dsp->queue.validResult;
    }

    return validResult;
}


IFX_STATIC boolean IfxAdc_Cdsp_setupBuffer(IfxAdc_Cdsp_QueueConfig *queueConfig, IfxAdc_Cdsp_Dsp *dsp)
{
    uint16 *localBufferPtr = (uint16 *)queueConfig->bufferPtr;
    boolean status         = FALSE;
    uint8   index          = 0u;
    uint16  buffersize     = IfxAdc_Cdsp_getBufferSize(queueConfig->size);

    /* Check if Buffer size is not zero and BufferPtr is not NULL */
    if ((buffersize != 0U) && (localBufferPtr != NULL_PTR))
    {
        /* Update the handle for buffer address and size */
        dsp->queue.bufferPtr    = (uint16 *)localBufferPtr;
        dsp->queue.writeIndex   = 0u;
        dsp->queue.readIndex    = 0u;
        dsp->queue.size         = buffersize;
        dsp->queue.bufferFull   = FALSE;
        dsp->queue.validResult  = 0u;
        dsp->queue.queueEnabled = TRUE;
        dsp->queue.buffHandler  = queueConfig->bufferFullHandler;
        dsp->queue.bufferType   = queueConfig->bufferType;

        /* Flushing the user provided buffer */
        for (index = 0u; index < buffersize; index++)
        {
            localBufferPtr[index] = (uint16)0U;
        }
    }
    else
    {
        /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
        dsp->queue.queueEnabled = FALSE;
        status                  = TRUE;
    }

    return status;
}


void IfxAdc_Cdsp_writeBuffer(IfxAdc_Cdsp_Dsp *dsp)
{
    Ifx_ADC_CDSP_DSP *dspSfrPtr        = dsp->dspSFR;
    uint16            localWriteIndex  = dsp->queue.writeIndex;
    uint16            localValidResult = dsp->queue.validResult;
    boolean           localBufferFull  = dsp->queue.bufferFull;
    uint16           *resultbufferPtr  = (uint16 *)(dsp->queue.bufferPtr);
    uint32            tempResVal       = 0u;
    uint16            bufferSize       = dsp->queue.size;
    uint16            numResult        = 0u;

    /* Read FIFO fill level from register */
    uint8             fillLevel = IfxAdc_getCdspFifoFillLevel(dsp->cdspSFR, dsp->coreId);
    uint8             readIndex = 0u;

    /* Number of result to check for buffer full status.*/
    numResult = localValidResult + fillLevel;

    if ((dsp->queue.bufferFull == TRUE) && (dsp->queue.bufferType != IfxAdc_Cdsp_BufferType_circular))
    {
        /* Linear Buffer is Full. */
    }
    else
    {
        /* Check if number of new results exceed buffer size. If yes update fillLevel and update buffer full status */
        if (numResult >= bufferSize)
        {
            /* Update buffer full status in local variable */
            localBufferFull = TRUE;

            if (dsp->queue.bufferType != IfxAdc_Cdsp_BufferType_circular)
            {
                /* Update fill level to read result until buffer is not full*/
                fillLevel = bufferSize - localValidResult;
            }
        }

        /* Check result event flag for RES0. RES1 and RES2 are not supported as they do no support FIFO mode*/
        if (IfxAdc_getCdspResultEvent(dsp->cdspSFR, dsp->coreId, IfxAdc_CdspResultReg_0))
        {
            /* DRM = 2 : 32 bit read access.*/
            if (dsp->dataReadWidth == IfxAdc_CdspDataReadWidth_32Bit)
            {
                while (readIndex < fillLevel)
                {
                    /* Read result value in local variable */
                    tempResVal                       = dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;
                    resultbufferPtr[localWriteIndex] = (uint16)tempResVal;                                                   // Update lower 16 bit result value in buffer
                    localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                    readIndex++;

                    resultbufferPtr[localWriteIndex] = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);           //Update higher 16 bit result in buffer
                    localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                    readIndex++;
                }
            }
            else /*DRM = 1: 16 bit read access. Upper part of the result register contains sign bit*/
            {
                while (readIndex < fillLevel)
                {
                    /* Read result value in local variable */
                    tempResVal                       = dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;
                    resultbufferPtr[localWriteIndex] = (uint16)tempResVal;                                                   // Update lower 16 bit result value in buffer
                    localWriteIndex                  = ((localWriteIndex + 1u) >= bufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
                    readIndex++;
                }
            }

            /* Clear RES0 result event */
            IfxAdc_clearCdspResultEvent(dsp->cdspSFR, dsp->coreId, IfxAdc_CdspResultReg_0);
        }
    }

    /*Update the write pointer and valid results in handle*/
    dsp->queue.writeIndex = localWriteIndex;
    dsp->queue.bufferFull = localBufferFull;

    if (!localBufferFull)
    {
        dsp->queue.validResult += readIndex;
    }
    else
    {
        /* valid result should not access buffer size */
        dsp->queue.validResult = bufferSize;
    }
}


sint16 IfxAdc_Cdsp_readCircularBufferResult(IfxAdc_Cdsp_Dsp *dsp)
{
    uint16  result           = 0u;
    uint16  bufferSize       = dsp->queue.size;
    uint16  localReadIndex   = dsp->queue.readIndex;
    uint16  localValidResult = dsp->queue.validResult;
    uint16 *resultbufferPtr  = (uint16 *)(dsp->queue.bufferPtr);

    /* Return result 0 if buffer empty */
    if (localValidResult == 0U)
    {
        result = 0U;
    }
    else
    {
        /* If buffer is full the updating the read index since the current read index will contain the latest value */
        if (dsp->queue.bufferFull)
        {
            localReadIndex = dsp->queue.writeIndex;
        }

        /* Read immediate result from buffer based on read index */
        result                  = resultbufferPtr[localReadIndex];
        localReadIndex          = ((localReadIndex + 1u) >= bufferSize) ? 0u : (localReadIndex + 1u); // Increment read index
        dsp->queue.readIndex    = localReadIndex;                                                     //Update read index in handle
        dsp->queue.validResult -= 1U;                                                                 //Decrement and update valid result count
        dsp->queue.bufferFull   = FALSE;                                                              //Update buffer full status
    }

    return result;
}


IfxAdc_Status IfxAdc_Cdsp_readStreamResult(IfxAdc_Cdsp_Dsp *dsp, uint16 *resBuff, uint16 size)
{
    uint16        index            = 0u;
    uint16        bufferSize       = dsp->queue.size;
    IfxAdc_Status status           = IfxAdc_Status_success;
    uint16        localReadIndex   = dsp->queue.readIndex;
    uint16        localValidResult = dsp->queue.validResult;
    uint16       *resultbufferPtr  = (uint16 *)(dsp->queue.bufferPtr);

    /* Return Error if buffer empty or number of valid result in buffer is less than size */
    if ((localValidResult == 0U) || (localValidResult < size))
    {
        /* If buffer empty, return Error */
        status = IfxAdc_Status_failure;
    }
    else
    {
        /* Store the result from internal buffer to application buffer*/
        for (index = 0u; index < size; index++)
        {
            resBuff[index] = resultbufferPtr[localReadIndex];
            localReadIndex = ((localReadIndex + 1u) >= bufferSize) ? 0u : (localReadIndex + 1u);
        }

        dsp->queue.readIndex   = localReadIndex;   //Update read index in handle
        localValidResult      -= size;             // Decrement valid result
        dsp->queue.bufferFull  = FALSE;            // Update buffer full status
        dsp->queue.validResult = localValidResult; // Update valid result
    }

    return status;
}


void IfxAdc_Cdsp_resultIsr(IfxAdc_Cdsp_Dsp *dsp)
{
    IfxAdc_Cdsp_Queue *localquePtr = &(dsp->queue);

    /* Check if queue enable */
    if (localquePtr->queueEnabled)
    {
        /* Store the result from hardware FIFO to software buffer */
        IfxAdc_Cdsp_writeBuffer(dsp);

        /* Check if callback configured if buffer is full */
        if ((localquePtr->bufferFull) && (localquePtr->buffHandler != NULL_PTR))
        {
            /* Do Callback if buffer gets full */
            (*localquePtr->buffHandler)();
        }
    }

    /* Check if callback configured for result event */
    if (dsp->resHandler != NULL_PTR)
    {
        /* Callback for each result event */
        (*dsp->resHandler)();
    }
}


IFX_STATIC void IfxAdc_Cdsp_configureDma(IfxAdc_Cdsp_QueueConfig *queue, IfxAdc_Cdsp_Dsp *dsp)
{
    Ifx_ADC_CDSP_DSP          *dspSfrPtr       = dsp->dspSFR;
    IfxAdc_Cdsp_DmaConfig     *dmaCfgPtr       = (queue->dmaCfg);
    IfxAdc_Cdsp_Dma           *dspDmaHandlePtr = &(dsp->queue.dma);
    IfxAdc_Cdsp_DmaSrvReq     *dmaSrvReqPtr    = (dmaCfgPtr->dmaSrvReqCfg);
    Ifx_DMA                   *dmaSFR          = (Ifx_DMA *)(IfxDma_cfg_indexMap[dmaCfgPtr->dmaId].module);
    IfxAdc_Cdsp_FilterChainSel filterchainId   = dsp->filterchain.filterchainId;

    //Update handle
    dspDmaHandlePtr->useDma = TRUE;
    dspDmaHandlePtr->dmaId  = dmaCfgPtr->dmaId;

    //DMA Module handle
    IfxDma_Dma dma;

    if (dmaSFR->CLC.B.DISS)
    {
        // DMA module configuration
        IfxDma_Dma_Config dmaConfig;
        IfxDma_Dma_initModuleConfig(&dmaConfig, dmaSFR);
        //Enable clock of DMA
        IfxDma_Dma_initModule(&dma, &dmaConfig);
    }

    IfxDma_Dma_createModuleHandle(&dma, dmaSFR);

    //DMA channel configuration
    IfxDma_Dma_ChannelConfig dmaCfg;
    IfxDma_Dma_initChannelConfig(&dmaCfg, &dma);

    {
        /* Update DMA channel id from queue configuration to channel configuration */
        dmaCfg.channelId = dmaCfgPtr->channelId;

        /* Common DMA channel configuration */
        dmaCfg.requestSource              = IfxDma_ChannelRequestSource_peripheral; //DMA request will be raised by CDSP result event
        dmaCfg.pattern                    = IfxDma_ChannelPattern_0_disable;
        dmaCfg.shadowControl              = IfxDma_ChannelShadow_none;
        dmaCfg.timestampEnabled           = FALSE;
        dmaCfg.wrapSourceInterruptEnabled = FALSE;
        dmaCfg.hardwareRequestEnabled     = TRUE;                         // will be triggered from CDSP result service request

        /* Source Address configuration */
        if (filterchainId == IfxAdc_Cdsp_FilterChainSel_fft)
        {
            dmaCfg.sourceAddress               = (uint32)(&dspSfrPtr->DCCM[0] + IFXADC_CDSP_FFT_DCCM_OFFSET); // DCCM  memory address
            dmaCfg.sourceCircularBufferEnabled = FALSE;
        }
        else
        {
            dmaCfg.sourceAddress               = (uint32)&(dspSfrPtr->RES[0].U);     // Result register address
            dmaCfg.sourceCircularBufferEnabled = TRUE;
        }

        dmaCfg.sourceAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
        dmaCfg.sourceAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;

        /* Destination Address configuration */
        dmaCfg.destinationAddress                   = (uint32)queue->bufferPtr;        //Destination buffer address
        dmaCfg.destinationAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
        dmaCfg.destinationAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;

        if (queue->bufferType == IfxAdc_Cdsp_BufferType_circular)
        {
            dmaCfg.transferCount                    = 1u;
            dmaCfg.requestMode                      = IfxDma_ChannelRequestMode_oneTransferPerRequest;
            dmaCfg.operationMode                    = IfxDma_ChannelOperationMode_continuous;     // hw request enable remains set after transaction
            dmaCfg.destinationAddressCircularRange  = (IfxDma_ChannelIncrementCircular)queue->size;
            dmaCfg.destinationCircularBufferEnabled = TRUE;
            dmaCfg.wrapDestinationInterruptEnabled  = FALSE;
        }
        else //Linear Buffer
        {
            if (filterchainId != IfxAdc_Cdsp_FilterChainSel_fft)
            {
                /* Set the transfer count to 1 for 32bit and 16bit data width */
                if (dsp->dataReadWidth == IfxAdc_CdspDataReadWidth_16Bit)
                {
                    dmaCfg.transferCount = (dsp->queue.size * 2u) / ((dsp->fifoLevel + 1u) * ((dsp->dataReadWidth + 1u) * 2));
                }
                else
                {
                    dmaCfg.transferCount = (dsp->queue.size * 2u) / ((dsp->fifoLevel + 1u) * ((dsp->dataReadWidth - 1u) * 2));
                }

                dmaCfg.requestMode = IfxDma_ChannelRequestMode_oneTransferPerRequest;
            }
            else
            {
                /* transfer count for dma  = queue_size / 4; (Number of samples) */
                dmaCfg.transferCount = (dsp->queue.size) >> (2u);
                dmaCfg.requestMode   = IfxDma_ChannelRequestMode_completeTransactionPerRequest;
            }

            dmaCfg.operationMode                    = IfxDma_ChannelOperationMode_single;     // hw request is disabled after transaction
            dmaCfg.destinationAddressCircularRange  = IfxDma_ChannelIncrementCircular_none;
            dmaCfg.destinationCircularBufferEnabled = FALSE;
            dmaCfg.wrapDestinationInterruptEnabled  = FALSE;
            dmaCfg.channelInterruptEnabled          = TRUE;
            dmaCfg.channelInterruptControl          = IfxDma_ChannelInterruptControl_thresholdLimitMatch;     //Interrupt will be raised when TCOUNT = 0
        }

        if (filterchainId != IfxAdc_Cdsp_FilterChainSel_fft)
        {
            /* Block mode is selected based on the configured Fifo fill level
             * If Fifo fill level is 4 dma block mode is selected as IfxDma_ChannelMove_4(4 DMA move per DMA transfer) */
            if (dsp->dataReadWidth == IfxAdc_CdspDataReadWidth_16Bit)
            {
                if (dsp->fifoLevel < IfxAdc_CdspFifoSrLevel_3)
                {
                    dmaCfg.blockMode = (IfxDma_ChannelMove)dsp->fifoLevel;
                }
                else if (dsp->fifoLevel == IfxAdc_CdspFifoSrLevel_3)
                {
                    dmaCfg.blockMode = IfxDma_ChannelMove_3; //3 DMA move per DMA transfer
                }
                else
                {
                    dmaCfg.blockMode = IfxDma_ChannelMove_4; //4 DMA move per DMA transfer
                }

                dmaCfg.moveSize                   = IfxDma_ChannelMoveSize_16bit;
                dmaCfg.sourceAddressCircularRange = IfxDma_ChannelIncrementCircular_2;       //Keep the same address
            }
            else
            {
                dmaCfg.moveSize                   = IfxDma_ChannelMoveSize_32bit;
                dmaCfg.blockMode                  = (IfxDma_ChannelMove)(dsp->fifoLevel >> 1);
                dmaCfg.sourceAddressCircularRange = IfxDma_ChannelIncrementCircular_4; //Keep the same address
            }
        }
        else
        {
            dmaCfg.moveSize                   = IfxDma_ChannelMoveSize_32bit;
            dmaCfg.blockMode                  = IfxDma_ChannelMove_1;
            dmaCfg.sourceAddressCircularRange = IfxDma_ChannelIncrementCircular_none;
        }

        /* DMA interrupt configuration */
        if (dmaSrvReqPtr != NULL_PTR)
        {
            dmaCfg.channelInterruptTypeOfService = dmaSrvReqPtr->typeOfService;
            dmaCfg.channelVmId                   = dmaSrvReqPtr->vmId;
            dmaCfg.channelInterruptPriority      = dmaSrvReqPtr->priority;
        }

        IfxDma_Dma_initChannel(&(dspDmaHandlePtr->channel), &dmaCfg);
    }
}


IfxAdc_Cdsp_Result IfxAdc_Cdsp_readResult(IfxAdc_Cdsp_Dsp *dsp)
{
    IfxAdc_Cdsp_Result result     = {0};
    Ifx_ADC_CDSP_DSP  *dspSfrPtr  = dsp->dspSFR;
    uint32             tempResVal = 0u;

    if (IfxAdc_getCdspResultEvent(dsp->cdspSFR, dsp->coreId, IfxAdc_CdspResultReg_0))
    {
        if (dsp->timeStampEnabled == FALSE)
        {
            tempResVal       = dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;
            result.result    = tempResVal;
            result.timestamp = 0u;
        }
        else
        {
            tempResVal    = dspSfrPtr->RES[IfxAdc_CdspResultReg_0].U;
            result.result = (sint16)tempResVal;

            if (dsp->dspSFR->TSTMP.B.TSVAL)
            {
                result.timestamp = (uint16)(tempResVal >> IFX_ADC_CDSP_DSP_RES_CRESULTHI_OFF);
            }
        }
    }

    return result;
}


IFX_STATIC void IfxAdc_Cdsp_updateHandleInfoFromDma(IfxAdc_Cdsp_Dsp *dsp)
{
    uint16 *resultbufferPtr  = (uint16 *)(dsp->queue.bufferPtr);
    uint16  localReadIndex   = dsp->queue.readIndex;
    uint16  localWriteIndex  = 0u;
    uint16 *writePtr         = (uint16 *)dsp->queue.dma.channel.channel->DADR.U;
    uint16  bufferSize       = dsp->queue.size;
    boolean bufferWrapStatus = dsp->queue.dma.channel.channel->CHCSR.B.WRPD;

    localWriteIndex = (uint16)(writePtr - resultbufferPtr);

    /* Buffer empty : Read index same as write index and buffer not full*/
    if ((localReadIndex == localWriteIndex) && (!bufferWrapStatus))
    {
        dsp->queue.validResult = 0u;
    }
    else if ((localReadIndex == localWriteIndex) && (bufferWrapStatus)) //Buffer full
    {
        dsp->queue.validResult = bufferSize;                            //buffer full
        dsp->queue.bufferFull  = TRUE;
    }
    else if ((localReadIndex < localWriteIndex) && (bufferWrapStatus))  //Buffer overflow. Update read Index
    {
        /* Buffer overflow. Updating the read index since the current read index will contain the new results */
        dsp->queue.validResult = bufferSize;                            //buffer full
        dsp->queue.bufferFull  = TRUE;
        dsp->queue.readIndex   = localWriteIndex;
    }
    else if (localWriteIndex < localReadIndex)
    {
        dsp->queue.validResult = (uint16)(bufferSize - localReadIndex + localWriteIndex);
    }
    else
    {
        dsp->queue.validResult = (uint16)(localWriteIndex - localReadIndex);
    }

    /* Clear buffer warp status */
    if (bufferWrapStatus)
    {
        IfxDma_getAndClearChannelWrapDestinationBufferInterrupt(dsp->queue.dma.channel.dma, dsp->queue.dma.channel.channelId);
    }

    /*Update information in handle from DMA address */
    dsp->queue.writeIndex = localWriteIndex;
}


IfxAdc_Status IfxAdc_Cdsp_setupResultBuffer(IfxAdc_Cdsp_Dsp *dsp, void *buffer, IfxAdc_Cdsp_BufferSize size)
{
    uint16                    *localBufferPtr = (uint16 *)buffer;
    IfxAdc_Status              status         = IfxAdc_Status_success;
    uint8                      index          = 0u;
    uint16                     buffersize     = IfxAdc_Cdsp_getBufferSize(size);
    uint32                     transferCount  = 0u;
    IfxAdc_Cdsp_FilterChainSel filterchainId  = dsp->filterchain.filterchainId;

    /* Check if Fifo enabled, Buffer size is not zero and BufferPtr is not NULL */
    if ((buffersize != 0U) && (localBufferPtr != NULL_PTR))
    {
        /* Update the handle for buffer address and size */
        dsp->queue.bufferPtr    = (uint16 *)localBufferPtr;
        dsp->queue.writeIndex   = 0u;
        dsp->queue.readIndex    = 0u;
        dsp->queue.size         = buffersize;
        dsp->queue.bufferFull   = FALSE;
        dsp->queue.validResult  = 0u;
        dsp->queue.queueEnabled = TRUE;

        /* Flushing the fifo */
        for (index = 0u; index < buffersize; index++)
        {
            localBufferPtr[index] = (uint16)0U;
        }

        /* If Dma configured update the destination address in Dma configuration */
        if (dsp->queue.dma.useDma)
        {
            /*1. Update destination Address */
            IfxDma_Dma_setChannelDestinationAddress(&(dsp->queue.dma.channel), (uint32)localBufferPtr);

            if (dsp->queue.bufferType != IfxAdc_Cdsp_BufferType_circular)
            {
                if (filterchainId != IfxAdc_Cdsp_FilterChainSel_fft)
                {
                    if (dsp->dataReadWidth == IfxAdc_CdspDataReadWidth_16Bit)
                    {
                        transferCount = (dsp->queue.size * 2u) / ((dsp->fifoLevel + 1u) * ((dsp->dataReadWidth + 1u) * 2));
                    }
                    else
                    {
                        transferCount = (dsp->queue.size * 2u) / ((dsp->fifoLevel + 1u) * ((dsp->dataReadWidth - 1u) * 2));
                    }
                }
                else
                {
                    transferCount = (dsp->queue.size) >> (2u);
                }

                /* Update transfer count */
                IfxDma_Dma_setChannelTransferCount(&(dsp->queue.dma.channel), transferCount);
                /* Enable channel hardware transaction request */
                IfxDma_enableChannelTransaction(dsp->queue.dma.channel.dma, dsp->queue.dma.channel.channelId);
            }
            else
            {
                /*2. Circular Buffer: Update Circular Address rang. */
                IfxDma_setCircularBufferDestinationLength(dsp->queue.dma.channel.dma, dsp->queue.dma.channel.channelId, size);
                /* Update transfer count */
                IfxDma_Dma_setChannelTransferCount(&(dsp->queue.dma.channel), 1u);
            }
        }
    }
    else
    {
        /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
        dsp->queue.queueEnabled = FALSE;
        status                  = IfxAdc_Status_failure;
    }

    return status;
}


IFX_STATIC void IfxAdc_Cdsp_setupIntegrator(Ifx_ADC_CDSP_DSP *dsp, IfxAdc_Cdsp_SwIntegratorConfig *integratorCfg)
{
    Ifx_ADC_CDSP_DSP      *coreSfr = dsp;
    Ifx_ADC_CDSP_DSP_SWCFG swCfg;

    swCfg.U          = coreSfr->SWCFG.U;

    swCfg.B.SWMODE   = integratorCfg->softwareMode;
    swCfg.B.WC       = integratorCfg->windowSizeControl;

    coreSfr->SWCFG.U = swCfg.U;
}


IfxAdc_Status IfxAdc_Cdsp_readLoFilterResult(IfxAdc_Cdsp_Dsp *dsp, IfxAdc_Cdsp_ResultLo *resultPtr)
{
    IfxAdc_Status status = IfxAdc_Status_failure;

    if (resultPtr != NULL_PTR)
    {
        resultPtr->angularVelocity = (float32)((dsp->dspSFR->RES[IfxAdc_CdspResultReg_0].U) * (float32)(0.00001));
        resultPtr->estimatedAngle  = (float32)((dsp->dspSFR->RES[IfxAdc_CdspResultReg_1].U) * (float32)(0.00001));
        resultPtr->angularError    = (float32)(dsp->dspSFR->RES[IfxAdc_CdspResultReg_2].U);

        status                     = IfxAdc_Status_success;
    }

    return status;
}


IfxAdc_Status IfxAdc_Cdsp_readFftFilterResult(IfxAdc_Cdsp_Dsp *dsp, uint32 *resultBuff)
{
    Ifx_ADC_CDSP_DSP *dspSfrPtr         = dsp->dspSFR;
    uint32            frequencyBinIndex = dsp->filterchain.fftSize;
    uint32           *fftresultPtr      = (uint32 *)(&dspSfrPtr->DCCM[0] + IFXADC_CDSP_FFT_DCCM_OFFSET);
    IfxAdc_Status     status            = IfxAdc_Status_failure;
    uint8             index             = 0u;

    /* the result event RES0 is check in application and result buffer should not be a null ptr */
    if (resultBuff != NULL_PTR)
    {
        /* Copy the FFT result (frequency bins) from DCCM memory to result buffer */
        for (index = 0u; index < frequencyBinIndex; index++)
        {
            resultBuff[index] = fftresultPtr[index];
        }

        status = IfxAdc_Status_success;
    }

    return status;
}


IfxAdc_Status IfxAdc_Cdsp_readPredictiveMaintenanceResult(IfxAdc_Cdsp_Dsp *dsp, IfxAdc_Cdsp_ResultPredictiveMaintenance *resultPtr)
{
    Ifx_ADC_CDSP_DSP *dspSfrPtr     = dsp->dspSFR;
    uint8             numOfChannels = (uint16)(dspSfrPtr->DCCM[0]);
    uint8             index         = 0u;
    IfxAdc_Status     status        = IfxAdc_Status_failure;

    if (resultPtr != NULL_PTR)
    {
        for (index = 0u; index < numOfChannels; index++)
        {
            uint32 *stat0ResultPtr = (uint32 *)(&dspSfrPtr->DCCM[0] + IFXADC_CDSP_STAT0_DCCM_OFFSET + (index * 2u));
            resultPtr[index].minValue = (sint16)stat0ResultPtr[0];
            resultPtr[index].maxValue = (sint16)(stat0ResultPtr[0] >> 16u);
            resultPtr[index].avgValue = (sint16)stat0ResultPtr[1];
        }

        status = IfxAdc_Status_success;
    }

    return status;
}
