/**
 * \file IfxEgtm_regdef.h
 * \brief
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 * Version: MC_ACE_A3G_HSI_EGTM/V0.2.1.1.2
 * Specification: latest @ 2024-03-18 instance sheet @ MC_A3G_HWDDSOC_FUNCTIONAL_INSTANCE_SHEET/V13.2.1.1.0
 * MAY BE CHANGED BY USER [yes/no]: No
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or 
 * the company in which ordinary course of business you are acting and (ii) 
 * Infineon Technologies AG or its licensees. If and as long as no such 
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or 
 * organization obtaining a copy of the software and accompanying 
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the 
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxSfr_Egtm_Registers Egtm Registers
 * \ingroup IfxSfr
 * 
 * \defgroup IfxSfr_Egtm_Registers_Bitfields Bitfields
 * \ingroup IfxSfr_Egtm_Registers
 * 
 * \defgroup IfxSfr_Egtm_Registers_union Register unions
 * \ingroup IfxSfr_Egtm_Registers
 * 
 * \defgroup IfxSfr_Egtm_Registers_struct Memory map
 * \ingroup IfxSfr_Egtm_Registers
 */
#ifndef IFXEGTM_REGDEF_H
#define IFXEGTM_REGDEF_H 1
/******************************************************************************/
#include "Ifx_TypesReg.h"
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

/******************************************************************************/
#if defined (__TASKING__)
#pragma warning 586
#endif
/******************************************************************************/

/** \addtogroup IfxSfr_Egtm_Registers_Bitfields
 * \{  */
/** \brief PRS access enable register */
typedef struct _Ifx_EGTM_ACCEN_PRS_Bits
{
    __IO Ifx_UReg_32Bit RD00:1;            /**< \brief [0:0] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD01:1;            /**< \brief [1:1] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD02:1;            /**< \brief [2:2] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD03:1;            /**< \brief [3:3] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD04:1;            /**< \brief [4:4] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD05:1;            /**< \brief [5:5] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD06:1;            /**< \brief [6:6] Read access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit RD07:1;            /**< \brief [7:7] Read access enable for PRS q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [15:8] \internal Reserved */
    __IO Ifx_UReg_32Bit WR00:1;            /**< \brief [16:16] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR01:1;            /**< \brief [17:17] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR02:1;            /**< \brief [18:18] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR03:1;            /**< \brief [19:19] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR04:1;            /**< \brief [20:20] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR05:1;            /**< \brief [21:21] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR06:1;            /**< \brief [22:22] Write access enable for PRS q (rw) */
    __IO Ifx_UReg_32Bit WR07:1;            /**< \brief [23:23] Write access enable for PRS q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_ACCEN_PRS_Bits;

/** \brief Read access enable register A */
typedef struct _Ifx_EGTM_ACCEN_RDA_Bits
{
    __IO Ifx_UReg_32Bit EN00:1;            /**< \brief [0:0] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN01:1;            /**< \brief [1:1] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN02:1;            /**< \brief [2:2] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN03:1;            /**< \brief [3:3] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN04:1;            /**< \brief [4:4] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN05:1;            /**< \brief [5:5] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN06:1;            /**< \brief [6:6] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN07:1;            /**< \brief [7:7] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN08:1;            /**< \brief [8:8] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN09:1;            /**< \brief [9:9] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Read access enable for Master TAG ID q - ENq (rw) */
} Ifx_EGTM_ACCEN_RDA_Bits;

/** \brief Read access enable register B */
typedef struct _Ifx_EGTM_ACCEN_RDB_FPI_Bits
{
    __IO Ifx_UReg_32Bit EN32:1;            /**< \brief [0:0] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN33:1;            /**< \brief [1:1] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN34:1;            /**< \brief [2:2] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN35:1;            /**< \brief [3:3] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN36:1;            /**< \brief [4:4] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN37:1;            /**< \brief [5:5] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN38:1;            /**< \brief [6:6] Read access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN39:1;            /**< \brief [7:7] Read access enable for Master TAG ID q - ENq (rw) */
    __I  Ifx_UReg_32Bit :24;               /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_ACCEN_RDB_FPI_Bits;

/** \brief VM access enable register */
typedef struct _Ifx_EGTM_ACCEN_VM_Bits
{
    __IO Ifx_UReg_32Bit RD00:1;            /**< \brief [0:0] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD01:1;            /**< \brief [1:1] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD02:1;            /**< \brief [2:2] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD03:1;            /**< \brief [3:3] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD04:1;            /**< \brief [4:4] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD05:1;            /**< \brief [5:5] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD06:1;            /**< \brief [6:6] Read access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit RD07:1;            /**< \brief [7:7] Read access enable for VM ID q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [15:8] \internal Reserved */
    __IO Ifx_UReg_32Bit WR00:1;            /**< \brief [16:16] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR01:1;            /**< \brief [17:17] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR02:1;            /**< \brief [18:18] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR03:1;            /**< \brief [19:19] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR04:1;            /**< \brief [20:20] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR05:1;            /**< \brief [21:21] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR06:1;            /**< \brief [22:22] Write access enable for VM ID q (rw) */
    __IO Ifx_UReg_32Bit WR07:1;            /**< \brief [23:23] Write access enable for VM ID q (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_ACCEN_VM_Bits;

/** \brief Write access enable register A */
typedef struct _Ifx_EGTM_ACCEN_WRA_Bits
{
    __IO Ifx_UReg_32Bit EN00:1;            /**< \brief [0:0] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN01:1;            /**< \brief [1:1] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN02:1;            /**< \brief [2:2] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN03:1;            /**< \brief [3:3] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN04:1;            /**< \brief [4:4] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN05:1;            /**< \brief [5:5] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN06:1;            /**< \brief [6:6] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN07:1;            /**< \brief [7:7] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN08:1;            /**< \brief [8:8] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN09:1;            /**< \brief [9:9] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN10:1;            /**< \brief [10:10] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN11:1;            /**< \brief [11:11] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN12:1;            /**< \brief [12:12] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN13:1;            /**< \brief [13:13] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN14:1;            /**< \brief [14:14] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN15:1;            /**< \brief [15:15] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN16:1;            /**< \brief [16:16] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN17:1;            /**< \brief [17:17] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN18:1;            /**< \brief [18:18] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN19:1;            /**< \brief [19:19] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN20:1;            /**< \brief [20:20] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN21:1;            /**< \brief [21:21] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN22:1;            /**< \brief [22:22] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN23:1;            /**< \brief [23:23] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN24:1;            /**< \brief [24:24] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN25:1;            /**< \brief [25:25] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN26:1;            /**< \brief [26:26] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN27:1;            /**< \brief [27:27] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN28:1;            /**< \brief [28:28] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN29:1;            /**< \brief [29:29] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN30:1;            /**< \brief [30:30] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN31:1;            /**< \brief [31:31] Write access enable for Master TAG ID q - ENq (rw) */
} Ifx_EGTM_ACCEN_WRA_Bits;

/** \brief Write access enable register B */
typedef struct _Ifx_EGTM_ACCEN_WRB_FPI_Bits
{
    __IO Ifx_UReg_32Bit EN32:1;            /**< \brief [0:0] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN33:1;            /**< \brief [1:1] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN34:1;            /**< \brief [2:2] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN35:1;            /**< \brief [3:3] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN36:1;            /**< \brief [4:4] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN37:1;            /**< \brief [5:5] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN38:1;            /**< \brief [6:6] Write access enable for Master TAG ID q - ENq (rw) */
    __IO Ifx_UReg_32Bit EN39:1;            /**< \brief [7:7] Write access enable for Master TAG ID q - ENq (rw) */
    __I  Ifx_UReg_32Bit :24;               /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_ACCEN_WRB_FPI_Bits;

/** \brief eGTM to ADC output selection register 0 */
typedef struct _Ifx_EGTM_ADC_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] eGTM to ADC trigger 0 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [12:8] eGTM to ADC trigger 1 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [20:16] eGTM to ADC trigger 2 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:5;            /**< \brief [28:24] eGTM to ADC trigger 3 output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_ADC_OUT_Bits;

/** \brief eGTM to ASCLIN0 output selection register. 0<28 then interface exists. */
typedef struct _Ifx_EGTM_ASCLIN_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:5;             /**< \brief [4:0] eGTM to ASCLIN0 trigger output selection (rw) */
    __I  Ifx_UReg_32Bit :27;               /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_ASCLIN_OUT_Bits;

/** \brief eGTM to CAN0 output selection register 0. 0*4+ 0<24 then interface exists. */
typedef struct _Ifx_EGTM_CAN_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:4;             /**< \brief [3:0] eGTM to CAN0 trigger 0 output selection (rw) */
    __I  Ifx_UReg_32Bit :28;               /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CAN_OUT_Bits;

/** \brief Clock control register */
typedef struct _Ifx_EGTM_CLC_Bits
{
    __IO Ifx_UReg_32Bit DISR:1;            /**< \brief [0:0] Module Disable Request Bit - DISR (rw) */
    __I  Ifx_UReg_32Bit DISS:1;            /**< \brief [1:1] Module Disable Status Bit - DISS (rh) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [2:2] \internal Reserved */
    __IO Ifx_UReg_32Bit EDIS:1;            /**< \brief [3:3] Sleep Mode Enable Control - EDIS (rw) */
    __I  Ifx_UReg_32Bit :28;               /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLC_Bits;

/** \brief eGTM AEI bridge mode register */
typedef struct _Ifx_EGTM_CLS_AEI_BRIDGE_MODE_Bits
{
    __IO Ifx_Strict_32Bit BRG_MODE:1;      /**< \brief [0:0] Defines the operation mode for the AEI bridge (rw) */
    __IO Ifx_Strict_32Bit MSK_WR_RSP:1;    /**< \brief [1:1] Mask write response (rw) */
    __IO Ifx_Strict_32Bit BYPASS_SYNC:1;    /**< \brief [2:2] Bypass synchronizer storage elements (rw) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [7:3] \internal Reserved */
    __I  Ifx_Strict_32Bit MODE_UP_PGR:1;    /**< \brief [8:8] Mode update in progress. (rh) */
    __IO Ifx_Strict_32Bit BUFF_OVL:1;      /**< \brief [9:9] Buffer overflow register (rw1ch) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [11:10] \internal Reserved */
    __I  Ifx_Strict_32Bit SYNC_INPUT_REG:1;    /**< \brief [12:12] Additional pipelined stage in synchronous bridge mode (r) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [15:13] \internal Reserved */
    __IO Ifx_Strict_32Bit BRG_RST:1;       /**< \brief [16:16] Bridge software reset (rw) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [23:17] \internal Reserved */
    __I  Ifx_Strict_32Bit BUFF_DPT:8;      /**< \brief [31:24] Buffer depth of AEI bridge (r) */
} Ifx_EGTM_CLS_AEI_BRIDGE_MODE_Bits;

/** \brief eGTM AEI bridge pointer 1 register */
typedef struct _Ifx_EGTM_CLS_AEI_BRIDGE_PTR1_Bits
{
    __I  Ifx_Strict_32Bit NEW_TRAN_PTR:5;    /**< \brief [4:0] New transaction pointer (rh) */
    __I  Ifx_Strict_32Bit FIRST_RSP_PTR:5;    /**< \brief [9:5] First response pointer (rh) */
    __I  Ifx_Strict_32Bit TRAN_IN_PGR:5;    /**< \brief [14:10] Transaction in progress pointer (acquire) (rh) */
    __I  Ifx_Strict_32Bit ABT_TRAN_PGR:5;    /**< \brief [19:15] Aborted transaction in progress pointer (rh) */
    __I  Ifx_Strict_32Bit FBC:6;           /**< \brief [25:20] Free buffer count (rh) */
    __I  Ifx_Strict_32Bit RSP_TRAN_RDY:6;    /**< \brief [31:26] Response transactions ready (rh) */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR1_Bits;

/** \brief eGTM AEI bridge pointer 2 register */
typedef struct _Ifx_EGTM_CLS_AEI_BRIDGE_PTR2_Bits
{
    __I  Ifx_Strict_32Bit TRAN_IN_PGR2:5;    /**< \brief [4:0] Transaction in progress pointer (aquire2) (rh) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR2_Bits;

/** \brief eGTM AEI timeout exception address register */
typedef struct _Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT_Bits
{
    __I  Ifx_Strict_32Bit TO_ADDR:21;      /**< \brief [20:0] AEI timeout address (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [23:21] \internal Reserved */
    __I  Ifx_Strict_32Bit TO_W1R0:1;       /**< \brief [24:24] AEI timeout Read/Write flag (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [31:25] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT_Bits;

/** \brief eGTM AEI non-zero status register */
typedef struct _Ifx_EGTM_CLS_ARCH_AEI_STA_XPT_Bits
{
    __I  Ifx_Strict_32Bit ADDR:21;         /**< \brief [20:0] AEI exception address (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [23:21] \internal Reserved */
    __I  Ifx_Strict_32Bit W1R0:1;          /**< \brief [24:24] AEI exception Read/Write flag (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [31:25] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_AEI_STA_XPT_Bits;

/** \brief eGTM configuration register */
typedef struct _Ifx_EGTM_CLS_ARCH_CFG_Bits
{
    __IO Ifx_Strict_32Bit SRC_IN_MUX:1;    /**< \brief [0:0] ##suppress##Input source selection for signal TIM[i]_AUX_IN ( input port AUX_IN at module TIM)##suppress## (rw) */
    __I  Ifx_Strict_32Bit :31;             /**< \brief [31:1] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_CFG_Bits;

/** \brief eGTM Cluster Clock Configuration */
typedef struct _Ifx_EGTM_CLS_ARCH_CLK_CFG_Bits
{
    __IO Ifx_Strict_32Bit CLS0_CLK_DIV:2;    /**< \brief [1:0] Cluster [j] Clock Divider (rwh) */
    __IO Ifx_Strict_32Bit CLS1_CLK_DIV:2;    /**< \brief [3:2] Cluster [j] Clock Divider (rwh) */
    __IO Ifx_Strict_32Bit CLS2_CLK_DIV:2;    /**< \brief [5:4] Cluster [j] Clock Divider (rwh) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_CLK_CFG_Bits;

/** \brief eGTM global control register */
typedef struct _Ifx_EGTM_CLS_ARCH_CTRL_Bits
{
    __IO Ifx_Strict_32Bit RF_PROT:1;       /**< \brief [0:0] RST and FORCINT protection (rw) */
    __IO Ifx_Strict_32Bit TO_MODE:2;       /**< \brief [2:1] AEI timeout mode (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit TO_VAL:8;        /**< \brief [11:4] AEI timeout value (rw) */
    __I  Ifx_Strict_32Bit :20;             /**< \brief [31:12] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_CTRL_Bits;

/** \brief eGTM error interrupt enable register */
typedef struct _Ifx_EGTM_CLS_ARCH_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit AEI_TO_XPT_EIRQ_EN:1;    /**< \brief [0:0] ##suppress##AEI_TO_XPT_EIRQ error interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_ADDR_EIRQ_EN:1;    /**< \brief [1:1] ##suppress##AEI_USP_ADDR_EIRQ error interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit AEI_IM_ADDR_EIRQ_EN:1;    /**< \brief [2:2] ##suppress##AEI_IM_ADDR_EIRQ error interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_BE_EIRQ_EN:1;    /**< \brief [3:3] ##suppress##AEI_USP_BE_EIRQ error interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [6:4] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK_EN_ERR_EIRQ_EN:1;    /**< \brief [7:7] ##suppress##CLK_EN_ERR_EIRQ interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit CLK_PER_ERR_EIRQ_EN:1;    /**< \brief [8:8] ##suppress##CLK_PER_ERR_EIRQ interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_EIRQ_EN_Bits;

/** \brief eGTM interrupt enable register */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit AEI_TO_XPT_IRQ_EN:1;    /**< \brief [0:0] ##suppress##AEI_TO_XPT_IRQ interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_ADDR_IRQ_EN:1;    /**< \brief [1:1] ##suppress##AEI_USP_ADDR_IRQ interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit AEI_IM_ADDR_IRQ_EN:1;    /**< \brief [2:2] ##suppress##AEI_IM_ADDR_IRQ interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit AEI_USP_BE_IRQ_EN:1;    /**< \brief [3:3] ##suppress##AEI_USP_BE_IRQ interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [6:4] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK_EN_ERR_IRQ_EN:1;    /**< \brief [7:7] ##suppress##CLK_EN_ERR_IRQ interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit CLK_PER_ERR_IRQ_EN:1;    /**< \brief [8:8] ##suppress##CLK_PER_ERR_IRQ interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_EN_Bits;

/** \brief eGTM Software interrupt generation register */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_AEI_TO_XPT:1;    /**< \brief [0:0] ##suppress##Trigger the bit GTM_IRQ_NOTIFY.AEI_TO_XPT by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_AEI_USP_ADDR:1;    /**< \brief [1:1] ##suppress##Trigger the bit GTM_IRQ_NOTIFY.AEI_USP_ADDR by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_AEI_IM_ADDR:1;    /**< \brief [2:2] ##suppress##Trigger the bit GTM_IRQ_NOTIFY.AEI_IM_ADDR by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_AEI_USP_BE:1;    /**< \brief [3:3] ##suppress##Trigger the bit GTM_IRQ_NOTIFY.AEI_USP_BE by software.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [6:4] \internal Reserved */
    __IO Ifx_Strict_32Bit TRG_CLK_EN_ERR:1;    /**< \brief [7:7] ##suppress##Trigger the bit GTM_IRQ_NOTIFY.CLK_EN_ERR by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_CLK_PER_ERR:1;    /**< \brief [8:8] ##suppress##Trigger the bit GTM_IRQ_NOTIFY.CLK_PER_ERR by software.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_FORCINT_Bits;

/** \brief eGTM toplevel interrupts mode selection */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] Interrupt strategy mode selection for the AEI timeout and address monitoring interrupts. (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_MODE_Bits;

/** \brief eGTM Interrupt notification register */
typedef struct _Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit AEI_TO_XPT:1;    /**< \brief [0:0] AEI timeout exception occurred (rw1ch) */
    __IO Ifx_Strict_32Bit AEI_USP_ADDR:1;    /**< \brief [1:1] AEI unsupported address interrupt (rw1ch) */
    __IO Ifx_Strict_32Bit AEI_IM_ADDR:1;    /**< \brief [2:2] AEI illegal Module address interrupt (rw1ch) */
    __IO Ifx_Strict_32Bit AEI_USP_BE:1;    /**< \brief [3:3] AEI unsupported byte enable interrupt (rw1ch) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [6:4] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK_EN_ERR:1;    /**< \brief [7:7] Clock enable error interrupt (rw1ch) */
    __IO Ifx_Strict_32Bit CLK_PER_ERR:1;    /**< \brief [8:8] Clock period error interrupt (rw1ch) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [23:9] \internal Reserved */
    __I  Ifx_Strict_32Bit CLK_EN_ERR_STATE:2;    /**< \brief [25:24] Erroneous clock enable state (rh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [27:26] \internal Reserved */
    __I  Ifx_Strict_32Bit CLK_EN_EXP_STATE:2;    /**< \brief [29:28] Expected clock enable state (rh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY_Bits;

/** \brief eGTM version control register */
typedef struct _Ifx_EGTM_CLS_ARCH_REV_Bits
{
    __I  Ifx_Strict_32Bit REL_ITER:4;      /**< \brief [3:0] Delivery number (r) */
    __I  Ifx_Strict_32Bit REL_BASE:8;      /**< \brief [11:4] Release step (r) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [15:12] \internal Reserved */
    __I  Ifx_Strict_32Bit VENDOR_CODE:4;    /**< \brief [19:16] Device encoding digit 1 (r) */
    __I  Ifx_Strict_32Bit DEVICE_CODE:4;    /**< \brief [23:20] Device encoding digit 0 (r) */
    __I  Ifx_Strict_32Bit VER_MINOR:4;     /**< \brief [27:24] Minor version number (r) */
    __I  Ifx_Strict_32Bit VER_MAJOR:4;     /**< \brief [31:28] Major version number (r) */
} Ifx_EGTM_CLS_ARCH_REV_Bits;

/** \brief eGTM global reset register */
typedef struct _Ifx_EGTM_CLS_ARCH_RST_Bits
{
    __I  Ifx_Strict_32Bit :27;             /**< \brief [26:0] \internal Reserved */
    __IO Ifx_Strict_32Bit BRIDGE_MODE_WRDIS:1;    /**< \brief [27:27] ##suppress##BRIDGE_MODE write disable##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [31:28] \internal Reserved */
} Ifx_EGTM_CLS_ARCH_RST_Bits;

/** \brief ATOM[i] AGC action time base register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_ACT_TB_Bits
{
    __IO Ifx_Strict_32Bit ACT_TB:24;       /**< \brief [23:0] ##suppress##Action time base. When the selected TBU time base CCM[i]_TBU_TS0/CCM[i]_TBU_TS1/CCM[i]_TBU_TS2 is "cyclically greater than or equal to" the action time base ATOM[i]_AGC_ACT_TB.ACT_TB, the compare event specified in ATOM[i]_AGC_ACT_TB.ACT_TB is considered to have occurred in the past and so the trigger ATOM_CTRL_TRIG is immediately generated in AGC unit if ATOM[i]_AGC_ACT_TB.TB_TRIG is 1. Please refer to chapter eGTM Architecture for more information about cyclic event compare strategy.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB_TRIG:1;       /**< \brief [24:24] Set trigger request (rwh) */
    __IO Ifx_Strict_32Bit TBU_SEL:2;       /**< \brief [26:25] Selection of time base used for comparison (rw) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [31:27] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_ACT_TB_Bits;

/** \brief ATOM[i] AGC enable/disable control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_CTRL0:2;    /**< \brief [1:0] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL1:2;    /**< \brief [3:2] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL2:2;    /**< \brief [5:4] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL3:2;    /**< \brief [7:6] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL4:2;    /**< \brief [9:8] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL5:2;    /**< \brief [11:10] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL6:2;    /**< \brief [13:12] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL7:2;    /**< \brief [15:14] ##suppress##ATOM [i] channel [k] enable/disable control register.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_Bits;

/** \brief ATOM[i] AGC enable/disable status register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_STAT0:2;    /**< \brief [1:0] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT1:2;    /**< \brief [3:2] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT2:2;    /**< \brief [5:4] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT3:2;    /**< \brief [7:6] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT4:2;    /**< \brief [9:8] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT5:2;    /**< \brief [11:10] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT6:2;    /**< \brief [13:12] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT7:2;    /**< \brief [15:14] ##suppress##ATOM [i] channel [k] enable/disable status register##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT_Bits;

/** \brief ATOM[i] AGC force update control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL_Bits
{
    __IO Ifx_Strict_32Bit FUPD_CTRL0:2;    /**< \brief [1:0] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL1:2;    /**< \brief [3:2] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL2:2;    /**< \brief [5:4] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL3:2;    /**< \brief [7:6] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL4:2;    /**< \brief [9:8] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL5:2;    /**< \brief [11:10] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL6:2;    /**< \brief [13:12] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL7:2;    /**< \brief [15:14] ##suppress##Force update of ATOM channel [k] operation registers##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH0:2;    /**< \brief [17:16] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH1:2;    /**< \brief [19:18] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH2:2;    /**< \brief [21:20] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH3:2;    /**< \brief [23:22] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH4:2;    /**< \brief [25:24] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH5:2;    /**< \brief [27:26] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH6:2;    /**< \brief [29:28] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH7:2;    /**< \brief [31:30] ##suppress##Reset ATOM[i]_CH[k]_CN0 of channel [k] on force update event##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL_Bits;

/** \brief ATOM[i] AGC global control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL_Bits
{
    __IO Ifx_Strict_32Bit HOST_TRIG:1;     /**< \brief [0:0] ##suppress##Trigger request signal (see AGC) to update the register ATOM[i]_AGC_ENDIS_STAT and ATOM[i]_AGC_OUTEN_STAT##suppress## (rw1c) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [7:1] \internal Reserved */
    __IO Ifx_Strict_32Bit RST_CH0:1;       /**< \brief [8:8] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH1:1;       /**< \brief [9:9] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH2:1;       /**< \brief [10:10] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH3:1;       /**< \brief [11:11] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH4:1;       /**< \brief [12:12] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH5:1;       /**< \brief [13:13] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH6:1;       /**< \brief [14:14] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit RST_CH7:1;       /**< \brief [15:15] Software reset of channel [k] (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL0:2;    /**< \brief [17:16] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL1:2;    /**< \brief [19:18] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL2:2;    /**< \brief [21:20] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL3:2;    /**< \brief [23:22] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL4:2;    /**< \brief [25:24] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL5:2;    /**< \brief [27:26] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL6:2;    /**< \brief [29:28] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL7:2;    /**< \brief [31:30] ##suppress##ATOM channel [k] enable update of register ATOM[i]_CH[k]_CM0, ATOM[i]_CH[k]_CM1, ATOM[i]_CH[k]_CTRL.SL and ATOM[i]_CH[k]_CTRL.CLK_SRC from ATOM[i]_CH[k]_SR0, ATOM[i]_CH[k]_SR1, ATOM[i]_CH[k]_CTRL_SR.SL_SR and ATOM[i]_CH[k]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL_Bits;

/** \brief ATOM[i] AGC internal trigger control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG_Bits
{
    __IO Ifx_Strict_32Bit INT_TRIG0:2;     /**< \brief [1:0] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG1:2;     /**< \brief [3:2] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG2:2;     /**< \brief [5:4] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG3:2;     /**< \brief [7:6] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG4:2;     /**< \brief [9:8] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG5:2;     /**< \brief [11:10] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG6:2;     /**< \brief [13:12] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG7:2;     /**< \brief [15:14] ##suppress##Select input signal ATOM_CH_TRIGOUT[k:k] as a trigger source##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG_Bits;

/** \brief ATOM[i] AGC output enable control register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_CTRL0:2;    /**< \brief [1:0] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL1:2;    /**< \brief [3:2] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL2:2;    /**< \brief [5:4] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL3:2;    /**< \brief [7:6] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL4:2;    /**< \brief [9:8] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL5:2;    /**< \brief [11:10] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL6:2;    /**< \brief [13:12] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL7:2;    /**< \brief [15:14] ##suppress##Output enable control of ATOM [i] channel [k] output ATOM_OUT[x:x]##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_Bits;

/** \brief ATOM[i] AGC output enable status register */
typedef struct _Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_STAT0:2;    /**< \brief [1:0] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT1:2;    /**< \brief [3:2] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT2:2;    /**< \brief [5:4] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT3:2;    /**< \brief [7:6] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT4:2;    /**< \brief [9:8] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT5:2;    /**< \brief [11:10] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT6:2;    /**< \brief [13:12] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT7:2;    /**< \brief [15:14] ##suppress##Output enable status of ATOM [i] channel [x] output ATOM_OUT[k:k]##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT_Bits;

/** \brief ATOM[i] channel [x] CCU0 compare register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CM0_Bits
{
    __IO Ifx_Strict_32Bit CM0:24;          /**< \brief [23:0] ##suppress##ATOM CCU0 compare register.##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CM0_Bits;

/** \brief ATOM[i] channel [x] CCU1 compare register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CM1_Bits
{
    __IO Ifx_Strict_32Bit CM1:24;          /**< \brief [23:0] ##suppress##ATOM CCU1 compare register.##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CM1_Bits;

/** \brief ATOM[i] channel [x] CCU0 counter register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CN0_Bits
{
    __IO Ifx_Strict_32Bit CN0:24;          /**< \brief [23:0] ##suppress##ATOM CCU0 counter register.##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CN0_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ##suppress##ATOM channel mode select.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] ##suppress##Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB:5;           /**< \brief [8:4] ##suppress##ATOM Mode control bits.##suppress## (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy select. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rwh) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] ##suppress##CMU clock source##suppress## (rwh) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0 (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] Enable trigger of one-shot pulse by the selected trigger signal (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] ##suppress##Select EXT_TRIGIN[x:x] as trigger signal##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] ##suppress##Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] ##suppress##Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM [i] channel [x].##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [28:27] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] Enable force update by external trigger signal (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ##suppress##ATOM Freeze Mode enable##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_Bits;

/** \brief ATOM[i] channel [x] control2 register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL2_Bits
{
    __IO Ifx_Strict_32Bit HRES:1;          /**< \brief [0:0] ##suppress##ATOM[i]_CH[x]_CTRL2.HRES: ATOM high-resolution support##suppress## (rw) */
    __I  Ifx_Strict_32Bit :31;             /**< \brief [31:1] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CTRL2_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ##suppress##ATOM channel mode select, but not applicable in SOMB mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] ##suppress##Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB10:2;         /**< \brief [5:4] Signal level control (rw) */
    __IO Ifx_Strict_32Bit ACB42:3;         /**< \brief [8:6] Compare strategy (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy select. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] ##suppress##CMU clock source but not applicable in SOMB mode##suppress## (rw) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update. (rwh) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMB mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] ##suppress##Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMB mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] ##suppress##Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMB mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] ##suppress##Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] ##suppress##Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM [i] channel [x].##suppress## (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "##suppress##'Serve last' ARU communication strategy, but not applicable in SOMP mode.##suppress##" (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode, but not applicable in SOMB mode. (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [28:27] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ##suppress##ATOM Freeze Mode enable##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ##suppress##ATOM channel mode select##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] ##suppress##Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB10:2;         /**< \brief [5:4] Signal level control (rw) */
    __IO Ifx_Strict_32Bit ACB42:3;         /**< \brief [8:6] Compare strategy (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy select. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] ##suppress##CMU clock source but not applicable in SOMC mode##suppress## (rw) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update. (rwh) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] ##suppress##Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMC mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] ##suppress##Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMC mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] ##suppress##Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] ##suppress##Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM channel x.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [25:25] \internal Reserved */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode, but not applicable in SOMC mode. (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [28:27] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update, but not applicable in SOMC mode. (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ##suppress##ATOM freeze mode enable##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ##suppress##ATOM channel mode select.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] ##suppress##Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2, but not applicable in SOMI mode.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB0:1;          /**< \brief [4:4] ##suppress##ATOM output control##suppress## (rw) */
    __IO Ifx_Strict_32Bit ACB41:4;         /**< \brief [8:5] ##suppress##ATOM Mode control bits but not applicable in SOMI mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy selection, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] ##suppress##CMU clock source but not applicable in SOMI mode##suppress## (rw) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] ##suppress##Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMI mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] ##suppress##Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMI mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] ##suppress##Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] ##suppress##Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM channel x.##suppress## (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "##suppress##'Serve last' ARU communication strategy, but not applicable in SOMI mode.##suppress##" (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode, but not applicable in SOMI mode. (rw) */
    __IO Ifx_Strict_32Bit ABM:1;           /**< \brief [27:27] ##suppress##ARU blocking mode, but not applicable in SOMI mode.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ##suppress##ATOM freeze mode enable configuration but it is not valid and supported in SOMI mode.##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ##suppress##ATOM channel mode select##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] ##suppress##Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2, but not applicable in SOMP mode.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [5:3] \internal Reserved */
    __IO Ifx_Strict_32Bit BITREV:1;        /**< \brief [6:6] ##suppress##PCM mode enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit SR0_TRIG:1;      /**< \brief [7:7] ##suppress##SR0 used for ATOM_OUT_T of instance i and channel x##suppress## (rw) */
    __IO Ifx_Strict_32Bit ACB4:1;          /**< \brief [8:8] ##suppress##ATOM output control, but not applicable in SOMP mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy selection, but not applicable in SOMP mode. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode, but not applicable in SOMP mode. (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rwh) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] ##suppress##CMU clock source for SOMP mode##suppress## (rwh) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update, but not applicable in SOMP mode. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0 (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] ##suppress##Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] ##suppress##Select EXT_TRIGIN[x:x] as trigger signal##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] ##suppress##Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] ##suppress##Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM [i] channel [x].##suppress## (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "##suppress##'Serve last' ARU communication strategy, but not applicable in SOMP mode.##suppress##" (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode (rw) */
    __IO Ifx_Strict_32Bit ABM:1;           /**< \brief [27:27] ##suppress##ARU blocking mode, but not applicable in SOMP mode.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ##suppress##ATOM Freeze Mode enable##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP_Bits;

/** \brief ATOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS_Bits
{
    __IO Ifx_Strict_32Bit MODE:2;          /**< \brief [1:0] ##suppress##ATOM channel mode select.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB12_SEL:1;      /**< \brief [2:2] ##suppress##Select time base value CCM[i]_TBU_TS1 or CCM[i]_TBU_TS2, but not applicable in SOMS mode.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __IO Ifx_Strict_32Bit ACB0:1;          /**< \brief [4:4] Shift direction (rw) */
    __IO Ifx_Strict_32Bit ACB21:2;         /**< \brief [6:5] ##suppress##ATOM output control, but not applicable in SOMS mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit DSO:1;           /**< \brief [7:7] Double shift output (rw) */
    __IO Ifx_Strict_32Bit ACB4:1;          /**< \brief [8:8] ##suppress##ATOM output control, but not applicable in SOMS mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit CMP_CTRL:1;      /**< \brief [9:9] CCU[x] compare strategy selection, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit EUPM:1;          /**< \brief [10:10] Extended update mode, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Initial signal level. (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] ##suppress##CMU clock source for SOMS mode##suppress## (rwh) */
    __IO Ifx_Strict_32Bit WR_REQ:1;        /**< \brief [16:16] CPU Write request bit for late compare register update, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period, , but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up/down counter mode, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0, but not applicable in SOMS mode. (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] ##suppress##Enable trigger of one-shot pulse by trigger signal ATOM_CH_TRIGOUT[x-1:x-1] or EXT_TRIGIN[x:x], but not applicable in SOMS mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] ##suppress##Select EXT_TRIGIN[x:x] as trigger signal, but not applicable in SOMS mode.##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] ##suppress##Select EXT_TRIGIN[x:x] as potential output signal ATOM_CH_TRIGOUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] ##suppress##Trigger output selection (output signal ATOM_CH_TRIGOUT[x:x]) of module ATOM channel x.##suppress## (rw) */
    __IO Ifx_Strict_32Bit SLA:1;           /**< \brief [25:25] "##suppress##'Serve last' ARU communication strategy, but not applicable in SOMS mode.##suppress##" (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode (rw) */
    __IO Ifx_Strict_32Bit ABM:1;           /**< \brief [27:27] ##suppress##ARU blocking mode, but not applicable in SOMS mode.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [28:28] \internal Reserved */
    __IO Ifx_Strict_32Bit EXT_FUPD:1;      /**< \brief [29:29] External forced update (rw) */
    __IO Ifx_Strict_32Bit SOMB:1;          /**< \brief [30:30] SOMB mode (rw) */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ##suppress##ATOM Freeze Mode enable##suppress## (rw) */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS_Bits;

/** \brief ATOM[i] channel [x] control shadow register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_CTRL_SR_Bits
{
    __I  Ifx_Strict_32Bit :11;             /**< \brief [10:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SL_SR:1;         /**< \brief [11:11] ##suppress##Shadow register for ATOM[i]_CH[x]_CTRL.SL##suppress## (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC_SR:4;    /**< \brief [15:12] ##suppress##Shadow register for ATOM[i]_CH[x]_CTRL.CLK_SRC##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SR_Bits;

/** \brief ATOM[i] channel [x] interrupt enable register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC_IRQ_EN:1;    /**< \brief [0:0] ##suppress##ATOM_CCU0TC[x]_IRQ interrupt enable.##suppress## (rw) */
    __IO Ifx_Strict_32Bit CCU1TC_IRQ_EN:1;    /**< \brief [1:1] ##suppress##ATOM_CCU1TC[x]_IRQ interrupt enable.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_EN_Bits;

/** \brief ATOM[i] channel [x] software interrupt generation */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_CCU0TC:1;    /**< \brief [0:0] ##suppress##Trigger the bit ATOM[i]_CH[x]_IRQ_NOTIFY.CCU0TC by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_CCU1TC:1;    /**< \brief [1:1] ##suppress##Trigger the bit ATOM[i]_CH[x]_IRQ_NOTIFY.CCU1TC by software.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT_Bits;

/** \brief ATOM[i] channel [x] interrupt mode configuration register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE_Bits;

/** \brief ATOM[i] channel [x] interrupt notification register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC:1;        /**< \brief [0:0] CCU0 Trigger condition interrupt for channel [x]. (rw1ch) */
    __IO Ifx_Strict_32Bit CCU1TC:1;        /**< \brief [1:1] CCU Trigger condition interrupt for channel [x]. (rw1ch) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY_Bits;

/** \brief ATOM[i] channel [x] CCU0 compare shadow register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_SR0_Bits
{
    __IO Ifx_Strict_32Bit SR0:24;          /**< \brief [23:0] ##suppress##ATOM channel [x] shadow register SR0.##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_SR0_Bits;

/** \brief ATOM[i] channel [x] CCU1 compare shadow register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_SR1_Bits
{
    __IO Ifx_Strict_32Bit SR1:24;          /**< \brief [23:0] ##suppress##ATOM channel [x] shadow register SR1.##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_SR1_Bits;

/** \brief ATOM[i] channel [x] status register */
typedef struct _Ifx_EGTM_CLS_ATOM_CH_STAT_Bits
{
    __I  Ifx_Strict_32Bit OL:1;            /**< \brief [0:0] ##suppress##Output signal level of ATOM_OUT[x:x].##suppress## (rh) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [15:1] \internal Reserved */
    __I  Ifx_Strict_32Bit ACBI:5;          /**< \brief [20:16] ##suppress##ATOM Mode control bits.##suppress## (rh) */
    __I  Ifx_Strict_32Bit DV:1;            /**< \brief [21:21] ##suppress##Valid ARUdata stored in compare registers.##suppress## (rh) */
    __IO Ifx_Strict_32Bit WRF:1;           /**< \brief [22:22] Write request of CPU failed for late update. (rw1ch) */
    __I  Ifx_Strict_32Bit DR:1;            /**< \brief [23:23] ##suppress##ARU dataData rejected flag##suppress## (rh) */
    __I  Ifx_Strict_32Bit ACBO:5;          /**< \brief [28:24] ##suppress##ATOM Internal status bits.##suppress## (rh) */
    __IO Ifx_Strict_32Bit OSM_RTF:1;       /**< \brief [29:29] One-shot mode retrigger failed flag. (rw1ch) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH_STAT_Bits;

/** \brief CCM[i] ATOM Output Register */
typedef struct _Ifx_EGTM_CLS_CCM_ATOM_OUT_Bits
{
    __I  Ifx_Strict_32Bit ATOM_I_OUT0:1;    /**< \brief [0:0] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT1:1;    /**< \brief [1:1] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT2:1;    /**< \brief [2:2] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT3:1;    /**< \brief [3:3] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT4:1;    /**< \brief [4:4] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT5:1;    /**< \brief [5:5] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT6:1;    /**< \brief [6:6] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT7:1;    /**< \brief [7:7] ##suppress##Output level snapshot of CCM_ATOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N0:1;    /**< \brief [8:8] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N1:1;    /**< \brief [9:9] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N2:1;    /**< \brief [10:10] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N3:1;    /**< \brief [11:11] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N4:1;    /**< \brief [12:12] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N5:1;    /**< \brief [13:13] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N6:1;    /**< \brief [14:14] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_I_OUT_N7:1;    /**< \brief [15:15] ##suppress##Output level snapshot of CCM_ATOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT0:1;    /**< \brief [16:16] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT1:1;    /**< \brief [17:17] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT2:1;    /**< \brief [18:18] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT3:1;    /**< \brief [19:19] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT4:1;    /**< \brief [20:20] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT5:1;    /**< \brief [21:21] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT6:1;    /**< \brief [22:22] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT7:1;    /**< \brief [23:23] Output level snapshot of ATOM[i+1]_OUT channel [x] (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N0:1;    /**< \brief [24:24] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N1:1;    /**< \brief [25:25] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N2:1;    /**< \brief [26:26] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N3:1;    /**< \brief [27:27] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N4:1;    /**< \brief [28:28] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N5:1;    /**< \brief [29:29] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N6:1;    /**< \brief [30:30] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_IP1_OUT_N7:1;    /**< \brief [31:31] ##suppress##Output level snapshot of CCM_ATOM_OUT[x:x] of instance i+1 channel x##suppress## (rh) */
} Ifx_EGTM_CLS_CCM_ATOM_OUT_Bits;

/** \brief CCM[i] Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_CFG_Bits
{
    __IO Ifx_Strict_32Bit EN_TIM:1;        /**< \brief [0:0] ##suppress##Enable TIM##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_TOM_SPE_TDTM:1;    /**< \brief [1:1] ##suppress##Enable TOM, SPE and TDTM##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_ATOM_ADTM:1;    /**< \brief [2:2] ##suppress##Enable ATOM and ADTM##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [6:3] \internal Reserved */
    __IO Ifx_Strict_32Bit EN_CMP_MON:1;    /**< \brief [7:7] ##suppress##Enable CMP and MON##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [15:8] \internal Reserved */
    __I  Ifx_Strict_32Bit CLS_CLK_DIV:2;    /**< \brief [17:16] Cluster Clock Divider (rh) */
    __I  Ifx_Strict_32Bit :14;             /**< \brief [31:18] \internal Reserved */
} Ifx_EGTM_CLS_CCM_CFG_Bits;

/** \brief CCM[i] CMU Clock Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_CMU_CLK_CFG_Bits
{
    __IO Ifx_Strict_32Bit CLK0_SRC:2;      /**< \brief [1:0] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [3:2] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK1_SRC:2;      /**< \brief [5:4] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [7:6] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK2_SRC:2;      /**< \brief [9:8] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [11:10] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK3_SRC:2;      /**< \brief [13:12] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [15:14] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK4_SRC:2;      /**< \brief [17:16] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [19:18] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK5_SRC:2;      /**< \brief [21:20] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [23:22] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK6_SRC:2;      /**< \brief [25:24] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [27:26] \internal Reserved */
    __IO Ifx_Strict_32Bit CLK7_SRC:2;      /**< \brief [29:28] Clock [y] source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_CCM_CMU_CLK_CFG_Bits;

/** \brief CCM[i] CMU Fixed Clock Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG_Bits
{
    __IO Ifx_Strict_32Bit FXCLK0_SRC:4;    /**< \brief [3:0] Fixed clock 0 source signal selector (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG_Bits;

/** \brief CCM[i] Hardware Configuration Register */
typedef struct _Ifx_EGTM_CLS_CCM_HW_CONF_Bits
{
    __I  Ifx_Strict_32Bit :1;              /**< \brief [0:0] \internal Reserved */
    __I  Ifx_Strict_32Bit BRIDGE_MODE_RST:1;    /**< \brief [1:1] Bridge mode after reset (r) */
    __I  Ifx_Strict_32Bit SYNC_INPUT_REG:1;    /**< \brief [2:2] Additional pipelined stage in synchronous bridge mode (r) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [3:3] \internal Reserved */
    __I  Ifx_Strict_32Bit ATOM_OUT_RST:1;    /**< \brief [4:4] ##suppress##CCM_ATOM_OUT reset level##suppress## (r) */
    __I  Ifx_Strict_32Bit ATOM_TRIG_CHAIN:3;    /**< \brief [7:5] ##suppress##ATOM trigger chain length without synchronization register##suppress## (r) */
    __I  Ifx_Strict_32Bit TOM_OUT_RST:1;    /**< \brief [8:8] ##suppress##CCM_TOM_OUT reset level##suppress## (r) */
    __I  Ifx_Strict_32Bit TOM_TRIG_CHAIN:3;    /**< \brief [11:9] ##suppress##TOM trigger chain length without synchronization register##suppress## (r) */
    __I  Ifx_Strict_32Bit RAM_INIT_RST:1;    /**< \brief [12:12] RAM initialization from reset (r) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [14:13] \internal Reserved */
    __I  Ifx_Strict_32Bit RESET_ACTIVE:1;    /**< \brief [15:15] Active level of asynchronous reset (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_LEVEL:1;    /**< \brief [16:16] Signalize availability of Level IRQ mode (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_PULSE:1;    /**< \brief [17:17] Signalize availability of Pulse IRQ mode (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_PULSE_NOTIFY:1;    /**< \brief [18:18] Signalize availability of Pulse Notify IRQ mode (r) */
    __I  Ifx_Strict_32Bit IRQ_MODE_SINGLE_PULSE:1;    /**< \brief [19:19] Signalize availability of Single Pulse IRQ mode (r) */
    __I  Ifx_Strict_32Bit ATOM_TRIG_INTCHAIN:4;    /**< \brief [23:20] ##suppress##ATOM internal trigger chain length for pipeline register##suppress## (r) */
    __I  Ifx_Strict_32Bit TOM_TRIG_INTCHAIN:5;    /**< \brief [28:24] ##suppress##TOM internal trigger chain length for pipeline register##suppress## (r) */
    __I  Ifx_Strict_32Bit INT_CLK_EN_GEN:1;    /**< \brief [29:29] Internal clock enable generation (r) */
    __I  Ifx_Strict_32Bit AEI_ADDR_PIPELINE_STAGE:1;    /**< \brief [30:30] Address pipeline stage implemented (r) */
    __I  Ifx_Strict_32Bit AEI_RDATA_PIPELINE_STAGE:1;    /**< \brief [31:31] Read data pipeline stage implemented (r) */
} Ifx_EGTM_CLS_CCM_HW_CONF_Bits;

/** \brief CCM[i] Protection Register */
typedef struct _Ifx_EGTM_CLS_CCM_PROT_Bits
{
    __IO Ifx_Strict_32Bit CLS_PROT:1;      /**< \brief [0:0] Cluster Protection (rw) */
    __I  Ifx_Strict_32Bit :31;             /**< \brief [31:1] \internal Reserved */
} Ifx_EGTM_CLS_CCM_PROT_Bits;

/** \brief CCM[i] TIM AUX Input Source Register */
typedef struct _Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC_Bits
{
    __IO Ifx_Strict_32Bit SRC_CH0:1;       /**< \brief [0:0] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 0##suppress## (rw) */
    __IO Ifx_Strict_32Bit SRC_CH1:1;       /**< \brief [1:1] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 1##suppress## (rw) */
    __IO Ifx_Strict_32Bit SRC_CH2:1;       /**< \brief [2:2] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 2##suppress## (rw) */
    __IO Ifx_Strict_32Bit SRC_CH3:1;       /**< \brief [3:3] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 3##suppress## (rw) */
    __IO Ifx_Strict_32Bit SRC_CH4:1;       /**< \brief [4:4] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 4##suppress## (rw) */
    __IO Ifx_Strict_32Bit SRC_CH5:1;       /**< \brief [5:5] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 5##suppress## (rw) */
    __IO Ifx_Strict_32Bit SRC_CH6:1;       /**< \brief [6:6] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 6##suppress## (rw) */
    __IO Ifx_Strict_32Bit SRC_CH7:1;       /**< \brief [7:7] ##suppress##Defines CCM_AUX_IN source of TIM[i] channel 7##suppress## (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [15:8] \internal Reserved */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH0:1;    /**< \brief [16:16] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH1:1;    /**< \brief [17:17] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH2:1;    /**< \brief [18:18] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH3:1;    /**< \brief [19:19] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH4:1;    /**< \brief [20:20] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH5:1;    /**< \brief [21:21] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH6:1;    /**< \brief [22:22] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SEL_OUT_N_CH7:1;    /**< \brief [23:23] ##suppress##Use timer output signals (coming from DTM_OUT0 ports) or the inverted output signals (coming from DTM_OUT1 ports) as CCM_AUX_IN source of TIM[i] channel [x]##suppress## (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC_Bits;

/** \brief CCM[i] TOM Output Register */
typedef struct _Ifx_EGTM_CLS_CCM_TOM_OUT_Bits
{
    __I  Ifx_Strict_32Bit TOM_OUT0:1;      /**< \brief [0:0] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT1:1;      /**< \brief [1:1] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT2:1;      /**< \brief [2:2] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT3:1;      /**< \brief [3:3] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT4:1;      /**< \brief [4:4] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT5:1;      /**< \brief [5:5] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT6:1;      /**< \brief [6:6] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT7:1;      /**< \brief [7:7] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT8:1;      /**< \brief [8:8] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT9:1;      /**< \brief [9:9] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT10:1;     /**< \brief [10:10] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT11:1;     /**< \brief [11:11] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT12:1;     /**< \brief [12:12] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT13:1;     /**< \brief [13:13] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT14:1;     /**< \brief [14:14] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT15:1;     /**< \brief [15:15] ##suppress##Output level snapshot of CCM_TOM_OUT channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N0:1;    /**< \brief [16:16] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N1:1;    /**< \brief [17:17] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N2:1;    /**< \brief [18:18] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N3:1;    /**< \brief [19:19] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N4:1;    /**< \brief [20:20] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N5:1;    /**< \brief [21:21] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N6:1;    /**< \brief [22:22] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N7:1;    /**< \brief [23:23] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N8:1;    /**< \brief [24:24] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N9:1;    /**< \brief [25:25] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N10:1;    /**< \brief [26:26] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N11:1;    /**< \brief [27:27] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N12:1;    /**< \brief [28:28] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N13:1;    /**< \brief [29:29] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N14:1;    /**< \brief [30:30] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_OUT_N15:1;    /**< \brief [31:31] ##suppress##Output level snapshot of CCM_TOM_OUT_N channel [x]##suppress## (rh) */
} Ifx_EGTM_CLS_CCM_TOM_OUT_Bits;

/** \brief CDTM[i]_DTM[d] channel control register 1 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1_Bits
{
    __IO Ifx_Strict_32Bit O1SEL_0:1;       /**< \brief [0:0] Output 1 select channel 0 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_0:1;       /**< \brief [1:1] Input 1 select channel 0 (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [2:2] \internal Reserved */
    __IO Ifx_Strict_32Bit SWAP_0:1;        /**< \brief [3:3] ##suppress##Swap outputs DTM_OUT0[0:0] of instance d and DTM_OUT1[0:0] of instance d (before final output register)##suppress## (rw) */
    __IO Ifx_Strict_32Bit O1F_0:2;         /**< \brief [5:4] Output 1 function channel 0 (rw) */
    __IO Ifx_Strict_32Bit XDT_EN_0_1:1;    /**< \brief [6:6] Cross dead-time enable on channel 0 and 1 (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [7:7] \internal Reserved */
    __IO Ifx_Strict_32Bit O1SEL_1:1;       /**< \brief [8:8] Output 1 select channel 1 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_1:1;       /**< \brief [9:9] Input 1 select channel 1 (rw) */
    __IO Ifx_Strict_32Bit SH_EN_1:1;       /**< \brief [10:10] Shift enable channel 1 (rw) */
    __IO Ifx_Strict_32Bit SWAP_1:1;        /**< \brief [11:11] ##suppress##Swap outputs DTM_OUT0[1:1] of instance d and DTM_OUT1[1:1] of instance d (before final output register)##suppress## (rw) */
    __IO Ifx_Strict_32Bit O1F_1:2;         /**< \brief [13:12] Output 1 function channel 1 (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [15:14] \internal Reserved */
    __IO Ifx_Strict_32Bit O1SEL_2:1;       /**< \brief [16:16] Output 1 select channel 2 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_2:1;       /**< \brief [17:17] Input 1 select channel 2 (rw) */
    __IO Ifx_Strict_32Bit SH_EN_2:1;       /**< \brief [18:18] Shift enable channel 2 (rw) */
    __IO Ifx_Strict_32Bit SWAP_2:1;        /**< \brief [19:19] ##suppress##Swap outputs DTM_OUT0[2:2] of instance d and DTM_OUT1[2:2] of instance d (before final output register)##suppress## (rw) */
    __IO Ifx_Strict_32Bit O1F_2:2;         /**< \brief [21:20] Output 1 function channel 2 (rw) */
    __IO Ifx_Strict_32Bit XDT_EN_2_3:1;    /**< \brief [22:22] Cross dead-time enable on channel 2 and 3 (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [23:23] \internal Reserved */
    __IO Ifx_Strict_32Bit O1SEL_3:1;       /**< \brief [24:24] Output 1 select channel 3 (rw) */
    __IO Ifx_Strict_32Bit I1SEL_3:1;       /**< \brief [25:25] Input 1 select channel 3 (rw) */
    __IO Ifx_Strict_32Bit SH_EN_3:1;       /**< \brief [26:26] Shift enable channel 3 (rw) */
    __IO Ifx_Strict_32Bit SWAP_3:1;        /**< \brief [27:27] ##suppress##Swap outputs DTM_OUT0[3:3] of instance d and DTM_OUT1[3:3] of instance d (before final output register)##suppress## (rw) */
    __IO Ifx_Strict_32Bit O1F_3:2;         /**< \brief [29:28] Output 1 function channel 3 (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1_Bits;

/** \brief CDTM[i]_DTM[d] channel control register 2 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_Bits
{
    __IO Ifx_Strict_32Bit POL0_0:1;        /**< \brief [0:0] Polarity on output 0 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit OC0_0:1;         /**< \brief [1:1] Output 0 control channel 0 (rwh) */
    __IO Ifx_Strict_32Bit SL0_0:1;         /**< \brief [2:2] Signal level on output 0 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit DT0_0:1;         /**< \brief [3:3] Dead-time path enable on output 0 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit POL1_0:1;        /**< \brief [4:4] Polarity on output 1 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit OC1_0:1;         /**< \brief [5:5] Output 1 control channel 0 (rwh) */
    __IO Ifx_Strict_32Bit SL1_0:1;         /**< \brief [6:6] Signal level on output 1 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit DT1_0:1;         /**< \brief [7:7] Dead-time path enable on output 1 channel 0 (rwh) */
    __IO Ifx_Strict_32Bit POL0_1:1;        /**< \brief [8:8] Polarity on output 0 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit OC0_1:1;         /**< \brief [9:9] Output 0 control channel 1 (rwh) */
    __IO Ifx_Strict_32Bit SL0_1:1;         /**< \brief [10:10] Signal level on output 0 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit DT0_1:1;         /**< \brief [11:11] Dead-time path enable on output 0 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit POL1_1:1;        /**< \brief [12:12] Polarity on output 1 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit OC1_1:1;         /**< \brief [13:13] Output 1 control channel 1 (rwh) */
    __IO Ifx_Strict_32Bit SL1_1:1;         /**< \brief [14:14] Signal level on output 1 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit DT1_1:1;         /**< \brief [15:15] Dead-time path enable on output 1 channel 1 (rwh) */
    __IO Ifx_Strict_32Bit POL0_2:1;        /**< \brief [16:16] Polarity on output 0 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit OC0_2:1;         /**< \brief [17:17] Output 0 control channel 2 (rwh) */
    __IO Ifx_Strict_32Bit SL0_2:1;         /**< \brief [18:18] Signal level on output 0 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit DT0_2:1;         /**< \brief [19:19] Dead-time path enable on output 0 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit POL1_2:1;        /**< \brief [20:20] Polarity on output 1 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit OC1_2:1;         /**< \brief [21:21] Output 1 control channel 2 (rwh) */
    __IO Ifx_Strict_32Bit SL1_2:1;         /**< \brief [22:22] Signal level on output 1 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit DT1_2:1;         /**< \brief [23:23] Dead-time path enable on output 1 channel 2 (rwh) */
    __IO Ifx_Strict_32Bit POL0_3:1;        /**< \brief [24:24] Polarity on output 0 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit OC0_3:1;         /**< \brief [25:25] Output 0 control channel 3 (rwh) */
    __IO Ifx_Strict_32Bit SL0_3:1;         /**< \brief [26:26] Signal level on output 0 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit DT0_3:1;         /**< \brief [27:27] Dead-time path enable on output 0 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit POL1_3:1;        /**< \brief [28:28] Polarity on output 1 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit OC1_3:1;         /**< \brief [29:29] Output 1 control channel 3 (rwh) */
    __IO Ifx_Strict_32Bit SL1_3:1;         /**< \brief [30:30] Signal level on output 1 channel 3 (rwh) */
    __IO Ifx_Strict_32Bit DT1_3:1;         /**< \brief [31:31] Dead-time path enable on output 1 channel 3 (rwh) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_Bits;

/** \brief CDTM[i] DTM[d] channel control register 2 shadow */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR_Bits
{
    __IO Ifx_Strict_32Bit POL0_0_SR:1;     /**< \brief [0:0] Polarity on output 0 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_0_SR:1;      /**< \brief [1:1] Output 0 control channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_0_SR:1;      /**< \brief [2:2] Signal level on output 0 channel 0 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_0_SR:1;      /**< \brief [3:3] Dead-time path enable on output 0 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_0_SR:1;     /**< \brief [4:4] Polarity on output 1 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_0_SR:1;      /**< \brief [5:5] Output 1 control channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_0_SR:1;      /**< \brief [6:6] Signal level on output 1 channel 0 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_0_SR:1;      /**< \brief [7:7] Dead-time path enable on output 1 channel 0 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL0_1_SR:1;     /**< \brief [8:8] Polarity on output 0 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_1_SR:1;      /**< \brief [9:9] Output 0 control channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_1_SR:1;      /**< \brief [10:10] Signal level on output 0 channel 1 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_1_SR:1;      /**< \brief [11:11] Dead-time path enable on output 0 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_1_SR:1;     /**< \brief [12:12] Polarity on output 1 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_1_SR:1;      /**< \brief [13:13] Output 1 control channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_1_SR:1;      /**< \brief [14:14] Signal level on output 1 channel 1 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_1_SR:1;      /**< \brief [15:15] Dead-time path enable on output 1 channel 1 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL0_2_SR:1;     /**< \brief [16:16] Polarity on output 0 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_2_SR:1;      /**< \brief [17:17] Output 0 control channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_2_SR:1;      /**< \brief [18:18] Signal level on output 0 channel 2 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_2_SR:1;      /**< \brief [19:19] Dead-time path enable on output 0 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_2_SR:1;     /**< \brief [20:20] Polarity on output 1 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_2_SR:1;      /**< \brief [21:21] Output 1 control channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_2_SR:1;      /**< \brief [22:22] Signal level on output 1 channel 2 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_2_SR:1;      /**< \brief [23:23] Dead-time path enable on output 1 channel 2 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL0_3_SR:1;     /**< \brief [24:24] Polarity on output 0 channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC0_3_SR:1;      /**< \brief [25:25] Output 0 control channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL0_3_SR:1;      /**< \brief [26:26] Signal level on output 0 channel 3 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT0_3_SR:1;      /**< \brief [27:27] Dead-time path enable on output 0 channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit POL1_3_SR:1;     /**< \brief [28:28] Polarity on output 1 channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit OC1_3_SR:1;      /**< \brief [29:29] Output 1 control channel 3 shadow register (rw) */
    __IO Ifx_Strict_32Bit SL1_3_SR:1;      /**< \brief [30:30] Signal level on output 1 channel 3 shadow register (rwh) */
    __IO Ifx_Strict_32Bit DT1_3_SR:1;      /**< \brief [31:31] Dead-time path enable on output 1 channel 3 shadow register (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR_Bits;

/** \brief CDTM[i]_DTM[d] channel control register 3 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3_Bits
{
    __IO Ifx_Strict_32Bit CII0:1;          /**< \brief [0:0] Combinational input invert channel 0 (rw) */
    __IO Ifx_Strict_32Bit CIS0:1;          /**< \brief [1:1] Combinational input select channel 0 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_0:1;       /**< \brief [2:2] Input selection for dead-time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_0:1;       /**< \brief [3:3] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [7:4] \internal Reserved */
    __IO Ifx_Strict_32Bit CII1:1;          /**< \brief [8:8] Combinational input invert channel 1 (rw) */
    __IO Ifx_Strict_32Bit CIS1:1;          /**< \brief [9:9] Combinational input select channel 1 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_1:1;       /**< \brief [10:10] Input selection for dead-time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_1:1;       /**< \brief [11:11] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [15:12] \internal Reserved */
    __IO Ifx_Strict_32Bit CII2:1;          /**< \brief [16:16] Combinational input invert channel 2 (rw) */
    __IO Ifx_Strict_32Bit CIS2:1;          /**< \brief [17:17] Combinational input select channel 2 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_2:1;       /**< \brief [18:18] Input selection for dead-time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_2:1;       /**< \brief [19:19] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [23:20] \internal Reserved */
    __IO Ifx_Strict_32Bit CII3:1;          /**< \brief [24:24] Combinational input invert channel 3 (rw) */
    __IO Ifx_Strict_32Bit CIS3:1;          /**< \brief [25:25] Combinational input select channel 3 (rw) */
    __IO Ifx_Strict_32Bit TSEL0_3:1;       /**< \brief [26:26] Input selection for dead-time / edge trigger generation (rw) */
    __IO Ifx_Strict_32Bit TSEL1_3:1;       /**< \brief [27:27] Input selection combinational logic path (rw) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [31:28] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3_Bits;

/** \brief CDTM[i]_DTM[d] channel [x] dead-time reload values */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_Bits
{
    __IO Ifx_Strict_32Bit RELRISE:13;      /**< \brief [12:0] Reload value for rising edge dead-time (rwh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [15:13] \internal Reserved */
    __IO Ifx_Strict_32Bit RELFALL:13;      /**< \brief [28:16] Reload value for falling edge dead-time (rwh) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [30:29] \internal Reserved */
    __IO Ifx_Strict_32Bit HRES:1;          /**< \brief [31:31] ##suppress##high-resolution PWM support##suppress## (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_Bits;

/** \brief CDTM[i]_DTM[d] channel [x] dead-time shadow values */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR_Bits
{
    __IO Ifx_Strict_32Bit RELRISE_SR:13;    /**< \brief [12:0] Shadow value for rising edge dead-time (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [13:13] \internal Reserved */
    __IO Ifx_Strict_32Bit RELRISE_UPD_FE0RE1:1;    /**< \brief [14:14] ##suppress##Control if falling edge or rising edge triggers update of CDTM[i]_DTM[d]_CH[x]_DTV.RELRISE##suppress## (rw) */
    __IO Ifx_Strict_32Bit RELRISE_UPD_EN:1;    /**< \brief [15:15] ##suppress##Control bit to enable update of CDTM[i]_DTM[d]_CH[x]_DTV.RELRISE##suppress## (rw) */
    __IO Ifx_Strict_32Bit RELFALL_SR:13;    /**< \brief [28:16] Shadow value for falling edge dead-time (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [29:29] \internal Reserved */
    __IO Ifx_Strict_32Bit RELFALL_UPD_FE0RE1:1;    /**< \brief [30:30] ##suppress##Control if falling edge or rising edge triggers update of CDTM[i]_DTM[d]_CH[x]_DTV.RELFALL##suppress## (rw) */
    __IO Ifx_Strict_32Bit RELFALL_UPD_EN:1;    /**< \brief [31:31] ##suppress##Control bit to enable update of CDTM[i]_DTM[d]_CH[x]_DTV.RELFALL##suppress## (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR_Bits;

/** \brief CDTM[i]_DTM[d] channel shadow register */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CH_SR_Bits
{
    __IO Ifx_Strict_32Bit SL0_0_SR_SR:1;    /**< \brief [0:0] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_0_SR##suppress## (rw) */
    __IO Ifx_Strict_32Bit SL1_0_SR_SR:1;    /**< \brief [1:1] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_0_SR##suppress## (rw) */
    __IO Ifx_Strict_32Bit SL0_1_SR_SR:1;    /**< \brief [2:2] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_1_SR##suppress## (rw) */
    __IO Ifx_Strict_32Bit SL1_1_SR_SR:1;    /**< \brief [3:3] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_1_SR##suppress## (rw) */
    __IO Ifx_Strict_32Bit SL0_2_SR_SR:1;    /**< \brief [4:4] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_2_SR##suppress## (rw) */
    __IO Ifx_Strict_32Bit SL1_2_SR_SR:1;    /**< \brief [5:5] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_2_SR##suppress## (rw) */
    __IO Ifx_Strict_32Bit SL0_3_SR_SR:1;    /**< \brief [6:6] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL0_3_SR##suppress## (rw) */
    __IO Ifx_Strict_32Bit SL1_3_SR_SR:1;    /**< \brief [7:7] ##suppress##Shadow register for bit CDTM[i]_DTM[d]_CH_CTRL2_SR.SL1_3_SR##suppress## (rw) */
    __I  Ifx_Strict_32Bit :24;             /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CH_SR_Bits;

/** \brief CDTM[i]_DTM[d] global configuration and control register */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_SEL:2;       /**< \brief [1:0] Clock resolution selection (rw) */
    __IO Ifx_Strict_32Bit DTM_SEL:2;       /**< \brief [3:2] ##suppress##Select DTM update and PSU_SHUT_OFF reset signal##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE:3;      /**< \brief [6:4] Update mode (rw) */
    __IO Ifx_Strict_32Bit CH_SHUTOFF_EN:1;    /**< \brief [7:7] Individual shutoff feature enable (rw) */
    __IO Ifx_Strict_32Bit SR_UPD_EN:1;     /**< \brief [8:8] Shadow register update enable (rw) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [15:9] \internal Reserved */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST:1;    /**< \brief [16:16] Shutoff reset (rw) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [31:17] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL_Bits;

/** \brief CDTM[i]_DTM[d] global configuration and control register 2 */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_CTRL2_Bits
{
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_0:3;    /**< \brief [2:0] Channel 0: Select input signal to be used as shutoff signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_0:1;    /**< \brief [3:3] Channel 0: Configure if the selected shutoff input signal used as shutoff output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_0:2;    /**< \brief [5:4] ##suppress##Channel 0: Control the update mode of the internal SHUTOFF_SYNC_0 signal.##suppress## (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_0:1;    /**< \brief [6:6] ##suppress##Channel 0: Clear of internal signal SHUTOFF_SYNC_0 if selected as control source.##suppress## (rw) */
    __IO Ifx_Strict_32Bit WR_EN_0:1;       /**< \brief [7:7] Channel 0: Write enable of bit fields (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_1:3;    /**< \brief [10:8] Channel 1: Select input signal to be used as shutoff signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_1:1;    /**< \brief [11:11] Channel 1: Configure if the selected shutoff input signal used as shutoff output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_1:2;    /**< \brief [13:12] ##suppress##Channel 1: Control the update mode of the internal SHUTOFF_SYNC_1 signal.##suppress## (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_1:1;    /**< \brief [14:14] ##suppress##Channel 1: Clear of internal signal SHUTOFF_SYNC_1 if selected as control source.##suppress## (rw) */
    __IO Ifx_Strict_32Bit WR_EN_1:1;       /**< \brief [15:15] Channel 1: Write enable of bit fields (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_2:3;    /**< \brief [18:16] Channel 2: Select input signal to be used as shutoff signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_2:1;    /**< \brief [19:19] Channel 2: Configure if the selected shutoff input signal used as shutoff output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_2:2;    /**< \brief [21:20] ##suppress##Channel 2: Control the update mode of the internal SHUTOFF_SYNC_2 signal.##suppress## (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_2:1;    /**< \brief [22:22] ##suppress##Channel 2: Clear of internal signal SHUTOFF_SYNC_2 if selected as control source.##suppress## (rw) */
    __IO Ifx_Strict_32Bit WR_EN_2:1;       /**< \brief [23:23] Channel 2: Write enable of bit fields (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_SEL_3:3;    /**< \brief [26:24] Channel 3: Select input signal to be used as shutoff signal. (rw) */
    __IO Ifx_Strict_32Bit SHUTOFF_POL_3:1;    /**< \brief [27:27] Channel 3: Configure if the selected shutoff input signal used as shutoff output signal is inverted or not. (rw) */
    __IO Ifx_Strict_32Bit UPD_MODE_3:2;    /**< \brief [29:28] ##suppress##Channel 3: Control the update mode of the internal SHUTOFF_SYNC_3 signal.##suppress## (rw) */
    __IO Ifx_Strict_32Bit SHUT_OFF_RST_3:1;    /**< \brief [30:30] ##suppress##Channel 3: Clear of internal signal SHUTOFF_SYNC_3 if selected as control source.##suppress## (rw) */
    __IO Ifx_Strict_32Bit WR_EN_3:1;       /**< \brief [31:31] Channel 3: Write enable of bit fields (rw) */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL2_Bits;

/** \brief CDTM[i]_DTM[d] phase shift unit configuration and control register */
typedef struct _Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL_Bits
{
    __IO Ifx_Strict_32Bit RELBLK:10;       /**< \brief [9:0] Reload value blanking window (rw) */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [15:10] \internal Reserved */
    __IO Ifx_Strict_32Bit PSU_IN_SEL:1;    /**< \brief [16:16] PSU input select (rw) */
    __IO Ifx_Strict_32Bit IN_POL:1;        /**< \brief [17:17] Input polarity (rw) */
    __IO Ifx_Strict_32Bit TIM_SEL:1;       /**< \brief [18:18] ##suppress##TIM input select##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [19:19] \internal Reserved */
    __IO Ifx_Strict_32Bit SHIFT_SEL:2;     /**< \brief [21:20] Shift select (rw) */
    __I  Ifx_Strict_32Bit :10;             /**< \brief [31:22] \internal Reserved */
} Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL_Bits;

/** \brief CMP error interrupt enable register */
typedef struct _Ifx_EGTM_CLS_CMP_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit ABWC0_EN_EIRQ:1;    /**< \brief [0:0] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC1_EN_EIRQ:1;    /**< \brief [1:1] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC2_EN_EIRQ:1;    /**< \brief [2:2] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC3_EN_EIRQ:1;    /**< \brief [3:3] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC4_EN_EIRQ:1;    /**< \brief [4:4] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC5_EN_EIRQ:1;    /**< \brief [5:5] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC6_EN_EIRQ:1;    /**< \brief [6:6] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC7_EN_EIRQ:1;    /**< \brief [7:7] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC8_EN_EIRQ:1;    /**< \brief [8:8] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC9_EN_EIRQ:1;    /**< \brief [9:9] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC10_EN_EIRQ:1;    /**< \brief [10:10] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC11_EN_EIRQ:1;    /**< \brief [11:11] ##suppress##Enable ABWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC0_EN_EIRQ:1;    /**< \brief [12:12] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC1_EN_EIRQ:1;    /**< \brief [13:13] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC2_EN_EIRQ:1;    /**< \brief [14:14] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC3_EN_EIRQ:1;    /**< \brief [15:15] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC4_EN_EIRQ:1;    /**< \brief [16:16] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC5_EN_EIRQ:1;    /**< \brief [17:17] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC6_EN_EIRQ:1;    /**< \brief [18:18] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC7_EN_EIRQ:1;    /**< \brief [19:19] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC8_EN_EIRQ:1;    /**< \brief [20:20] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC9_EN_EIRQ:1;    /**< \brief [21:21] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC10_EN_EIRQ:1;    /**< \brief [22:22] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC11_EN_EIRQ:1;    /**< \brief [23:23] ##suppress##Enable TBWC comparator [c] interrupt source for CMP_EIRQ line##suppress## (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_EIRQ_EN_Bits;

/** \brief CMP comparator enable register */
typedef struct _Ifx_EGTM_CLS_CMP_EN_Bits
{
    __IO Ifx_Strict_32Bit ABWC0_EN:1;      /**< \brief [0:0] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC1_EN:1;      /**< \brief [1:1] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC2_EN:1;      /**< \brief [2:2] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC3_EN:1;      /**< \brief [3:3] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC4_EN:1;      /**< \brief [4:4] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC5_EN:1;      /**< \brief [5:5] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC6_EN:1;      /**< \brief [6:6] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC7_EN:1;      /**< \brief [7:7] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC8_EN:1;      /**< \brief [8:8] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC9_EN:1;      /**< \brief [9:9] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC10_EN:1;     /**< \brief [10:10] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit ABWC11_EN:1;     /**< \brief [11:11] Enable comparator channel [c] in ABWC (rw) */
    __IO Ifx_Strict_32Bit TBWC0_EN:1;      /**< \brief [12:12] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC1_EN:1;      /**< \brief [13:13] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC2_EN:1;      /**< \brief [14:14] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC3_EN:1;      /**< \brief [15:15] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC4_EN:1;      /**< \brief [16:16] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC5_EN:1;      /**< \brief [17:17] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC6_EN:1;      /**< \brief [18:18] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC7_EN:1;      /**< \brief [19:19] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC8_EN:1;      /**< \brief [20:20] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC9_EN:1;      /**< \brief [21:21] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC10_EN:1;     /**< \brief [22:22] Enable comparator channel [c] in TBWC (rw) */
    __IO Ifx_Strict_32Bit TBWC11_EN:1;     /**< \brief [23:23] Enable comparator channel [c] in TBWC (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_EN_Bits;

/** \brief CMP interrupt enable register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit ABWC0_EN_IRQ:1;    /**< \brief [0:0] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC1_EN_IRQ:1;    /**< \brief [1:1] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC2_EN_IRQ:1;    /**< \brief [2:2] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC3_EN_IRQ:1;    /**< \brief [3:3] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC4_EN_IRQ:1;    /**< \brief [4:4] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC5_EN_IRQ:1;    /**< \brief [5:5] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC6_EN_IRQ:1;    /**< \brief [6:6] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC7_EN_IRQ:1;    /**< \brief [7:7] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC8_EN_IRQ:1;    /**< \brief [8:8] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC9_EN_IRQ:1;    /**< \brief [9:9] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC10_EN_IRQ:1;    /**< \brief [10:10] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit ABWC11_EN_IRQ:1;    /**< \brief [11:11] ##suppress##Enable CMP_IRQ_NOTIFY.ABWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC0_EN_IRQ:1;    /**< \brief [12:12] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC1_EN_IRQ:1;    /**< \brief [13:13] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC2_EN_IRQ:1;    /**< \brief [14:14] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC3_EN_IRQ:1;    /**< \brief [15:15] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC4_EN_IRQ:1;    /**< \brief [16:16] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC5_EN_IRQ:1;    /**< \brief [17:17] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC6_EN_IRQ:1;    /**< \brief [18:18] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC7_EN_IRQ:1;    /**< \brief [19:19] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC8_EN_IRQ:1;    /**< \brief [20:20] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC9_EN_IRQ:1;    /**< \brief [21:21] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC10_EN_IRQ:1;    /**< \brief [22:22] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __IO Ifx_Strict_32Bit TBWC11_EN_IRQ:1;    /**< \brief [23:23] ##suppress##Enable CMP_IRQ_NOTIFY.TBWC[c] interrupt source for CMP_IRQ line##suppress## (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_EN_Bits;

/** \brief CMP interrupt force register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_ABWC0:1;     /**< \brief [0:0] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC1:1;     /**< \brief [1:1] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC2:1;     /**< \brief [2:2] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC3:1;     /**< \brief [3:3] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC4:1;     /**< \brief [4:4] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC5:1;     /**< \brief [5:5] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC6:1;     /**< \brief [6:6] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC7:1;     /**< \brief [7:7] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC8:1;     /**< \brief [8:8] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC9:1;     /**< \brief [9:9] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC10:1;    /**< \brief [10:10] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ABWC11:1;    /**< \brief [11:11] ##suppress##Trigger the CMP_IRQ_NOTIFY.ABWC[c] bit (ATOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC0:1;     /**< \brief [12:12] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC1:1;     /**< \brief [13:13] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC2:1;     /**< \brief [14:14] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC3:1;     /**< \brief [15:15] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC4:1;     /**< \brief [16:16] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC5:1;     /**< \brief [17:17] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC6:1;     /**< \brief [18:18] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC7:1;     /**< \brief [19:19] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC8:1;     /**< \brief [20:20] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC9:1;     /**< \brief [21:21] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC10:1;    /**< \brief [22:22] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TBWC11:1;    /**< \brief [23:23] ##suppress##Trigger CMP_IRQ_NOTIFY.TBWC[c] bit (TOM [c]) by software##suppress## (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_FORCINT_Bits;

/** \brief CMP interrupt mode configuration register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_MODE_Bits;

/** \brief CMP event notification register */
typedef struct _Ifx_EGTM_CLS_CMP_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit ABWC0:1;         /**< \brief [0:0] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC1:1;         /**< \brief [1:1] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC2:1;         /**< \brief [2:2] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC3:1;         /**< \brief [3:3] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC4:1;         /**< \brief [4:4] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC5:1;         /**< \brief [5:5] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC6:1;         /**< \brief [6:6] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC7:1;         /**< \brief [7:7] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC8:1;         /**< \brief [8:8] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC9:1;         /**< \brief [9:9] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC10:1;        /**< \brief [10:10] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ABWC11:1;        /**< \brief [11:11] ##suppress##ATOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC0:1;         /**< \brief [12:12] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC1:1;         /**< \brief [13:13] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC2:1;         /**< \brief [14:14] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC3:1;         /**< \brief [15:15] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC4:1;         /**< \brief [16:16] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC5:1;         /**< \brief [17:17] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC6:1;         /**< \brief [18:18] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC7:1;         /**< \brief [19:19] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC8:1;         /**< \brief [20:20] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC9:1;         /**< \brief [21:21] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC10:1;        /**< \brief [22:22] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TBWC11:1;        /**< \brief [23:23] ##suppress##TOM sub-modules output bitwise comparator [c] error indication##suppress## (rw1ch) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMP_IRQ_NOTIFY_Bits;

/** \brief CMU control for clock resolution generator [x] */
typedef struct _Ifx_EGTM_CLS_CMU_CLKX_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_CNT:24;      /**< \brief [23:0] Clock count. Defines count value for the clock divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLKX_CTRL_Bits;

/** \brief CMU control for clock resolution generator 6 */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_6_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_CNT:24;      /**< \brief [23:0] ##suppress##Clock count. Define count value for the clock resolution generator responsible for CMU_CLK_RES[6:6] generation.##suppress## (rwh) */
    __IO Ifx_Strict_32Bit CLK_SEL:2;       /**< \brief [25:24] Source selection (rwh) */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [31:26] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_6_CTRL_Bits;

/** \brief CMU control for clock resolution generator 7 */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_7_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK_CNT:24;      /**< \brief [23:0] ##suppress##Clock count. Define count value for the clock resolution generator responsible for CMU_CLK_RES[7:7] generation.##suppress## (rwh) */
    __IO Ifx_Strict_32Bit CLK_SEL:2;       /**< \brief [25:24] Source selection (rwh) */
    __I  Ifx_Strict_32Bit :6;              /**< \brief [31:26] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_7_CTRL_Bits;

/** \brief CMU control for clock resolution generator */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CLK0_EXT_DIVIDER:1;    /**< \brief [0:0] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK1_EXT_DIVIDER:1;    /**< \brief [1:1] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK2_EXT_DIVIDER:1;    /**< \brief [2:2] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK3_EXT_DIVIDER:1;    /**< \brief [3:3] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK4_EXT_DIVIDER:1;    /**< \brief [4:4] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK5_EXT_DIVIDER:1;    /**< \brief [5:5] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK6_EXT_DIVIDER:1;    /**< \brief [6:6] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK7_EXT_DIVIDER:1;    /**< \brief [7:7] Input selection for Clock Resolution Generator [x] (rwh) */
    __IO Ifx_Strict_32Bit CLK8_EXT_DIVIDER:1;    /**< \brief [8:8] ##suppress##Source selection for CMU_CLK_RES[8:8]##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_CTRL_Bits;

/** \brief CMU clock enable */
typedef struct _Ifx_EGTM_CLS_CMU_CLK_EN_Bits
{
    __IO Ifx_Strict_32Bit EN_CLK0:2;       /**< \brief [1:0] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK1:2;       /**< \brief [3:2] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK2:2;       /**< \brief [5:4] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK3:2;       /**< \brief [7:6] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK4:2;       /**< \brief [9:8] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK5:2;       /**< \brief [11:10] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK6:2;       /**< \brief [13:12] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_CLK7:2;       /**< \brief [15:14] ##suppress##Enable clock resolution CMU_CLK_RES[x:x]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_ECLK0:2;      /**< \brief [17:16] ##suppress##Enable clock CMU_ECLK[z:z]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_ECLK1:2;      /**< \brief [19:18] ##suppress##Enable clock CMU_ECLK[z:z]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_ECLK2:2;      /**< \brief [21:20] ##suppress##Enable clock CMU_ECLK[z:z]##suppress## (rwh) */
    __IO Ifx_Strict_32Bit EN_FXCLK:2;      /**< \brief [23:22] ##suppress##Enable clock resolution CMU_FXCLK_RES##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_CLK_EN_Bits;

/** \brief The denominator for the external clock resolution generator [z] */
typedef struct _Ifx_EGTM_CLS_CMU_ECLK_DEN_Bits
{
    __IO Ifx_Strict_32Bit ECLK_DEN:24;     /**< \brief [23:0] The denominator for external clock resolution generator. Defines denominator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_ECLK_DEN_Bits;

/** \brief The numerator for the external clock resolution generator [z] */
typedef struct _Ifx_EGTM_CLS_CMU_ECLK_NUM_Bits
{
    __IO Ifx_Strict_32Bit ECLK_NUM:24;     /**< \brief [23:0] The numerator for external clock resolution generator. Defines numerator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_ECLK_NUM_Bits;

/** \brief CMU control for selection of FCR subblock input */
typedef struct _Ifx_EGTM_CLS_CMU_FXCLK_CTRL_Bits
{
    __IO Ifx_Strict_32Bit FXCLK_SEL:4;     /**< \brief [3:0] ##suppress##Input selection for EN_FXCLK line##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_CMU_FXCLK_CTRL_Bits;

/** \brief The denominator for CMU global clock resolution generator */
typedef struct _Ifx_EGTM_CLS_CMU_GCLK_DEN_Bits
{
    __IO Ifx_Strict_32Bit GCLK_DEN:24;     /**< \brief [23:0] Denominator for global resolution generator. Defines denominator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_GCLK_DEN_Bits;

/** \brief The numerator for CMU global clock resolution generator */
typedef struct _Ifx_EGTM_CLS_CMU_GCLK_NUM_Bits
{
    __IO Ifx_Strict_32Bit GCLK_NUM:24;     /**< \brief [23:0] Numerator for global clock resolution generator. Defines numerator of the fractional divider. (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_CMU_GCLK_NUM_Bits;

/** \brief ICM_IRQG_0 */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_0_Bits
{
    __I  Ifx_Strict_32Bit :4;              /**< \brief [3:0] \internal Reserved */
    __I  Ifx_Strict_32Bit AEI_IRQ:1;       /**< \brief [4:4] ##suppress##ICM_IRQG_0.AEI_IRQ: AEI_IRQ interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit CMP_IRQ:1;       /**< \brief [5:5] ##suppress##CMP shared sub-module interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE0_IRQ:1;      /**< \brief [6:6] ##suppress##SPE[j] shared sub-module interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE1_IRQ:1;      /**< \brief [7:7] ##suppress##SPE[j] shared sub-module interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE2_IRQ:1;      /**< \brief [8:8] ##suppress##SPE[j] shared sub-module interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit :23;             /**< \brief [31:9] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_0_Bits;

/** \brief ICM Interrupt group register covering TIM0, TIM1, TIM2, TIM3 */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_2_Bits
{
    __I  Ifx_Strict_32Bit TIM0_CH0_IRQ:1;    /**< \brief [0:0] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH1_IRQ:1;    /**< \brief [1:1] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH2_IRQ:1;    /**< \brief [2:2] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH3_IRQ:1;    /**< \brief [3:3] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH4_IRQ:1;    /**< \brief [4:4] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH5_IRQ:1;    /**< \brief [5:5] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH6_IRQ:1;    /**< \brief [6:6] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH7_IRQ:1;    /**< \brief [7:7] TIM0 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH0_IRQ:1;    /**< \brief [8:8] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH1_IRQ:1;    /**< \brief [9:9] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH2_IRQ:1;    /**< \brief [10:10] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH3_IRQ:1;    /**< \brief [11:11] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH4_IRQ:1;    /**< \brief [12:12] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH5_IRQ:1;    /**< \brief [13:13] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH6_IRQ:1;    /**< \brief [14:14] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH7_IRQ:1;    /**< \brief [15:15] TIM1 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH0_IRQ:1;    /**< \brief [16:16] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH1_IRQ:1;    /**< \brief [17:17] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH2_IRQ:1;    /**< \brief [18:18] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH3_IRQ:1;    /**< \brief [19:19] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH4_IRQ:1;    /**< \brief [20:20] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH5_IRQ:1;    /**< \brief [21:21] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH6_IRQ:1;    /**< \brief [22:22] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH7_IRQ:1;    /**< \brief [23:23] TIM2 shared interrupt channel [x] (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_2_Bits;

/** \brief ICM_IRQG_ATOM_[g]_CI */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI_Bits
{
    __I  Ifx_Strict_32Bit ATOM_M0_CH0_IRQ:1;    /**< \brief [0:0] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH1_IRQ:1;    /**< \brief [1:1] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH2_IRQ:1;    /**< \brief [2:2] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH3_IRQ:1;    /**< \brief [3:3] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH4_IRQ:1;    /**< \brief [4:4] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH5_IRQ:1;    /**< \brief [5:5] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH6_IRQ:1;    /**< \brief [6:6] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M0_CH7_IRQ:1;    /**< \brief [7:7] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH0_IRQ:1;    /**< \brief [8:8] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH1_IRQ:1;    /**< \brief [9:9] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH2_IRQ:1;    /**< \brief [10:10] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH3_IRQ:1;    /**< \brief [11:11] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH4_IRQ:1;    /**< \brief [12:12] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH5_IRQ:1;    /**< \brief [13:13] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH6_IRQ:1;    /**< \brief [14:14] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M1_CH7_IRQ:1;    /**< \brief [15:15] ##suppress##ATOM[j] channel [x] interrupt ([j]=4*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH0_IRQ:1;    /**< \brief [16:16] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH1_IRQ:1;    /**< \brief [17:17] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH2_IRQ:1;    /**< \brief [18:18] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH3_IRQ:1;    /**< \brief [19:19] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH4_IRQ:1;    /**< \brief [20:20] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH5_IRQ:1;    /**< \brief [21:21] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH6_IRQ:1;    /**< \brief [22:22] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit ATOM_M2_CH7_IRQ:1;    /**< \brief [23:23] ##suppress##ATOMm channel [x] interrupt ([j]=4*[g]+2)##suppress## (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI_Bits;

/** \brief ICM Interrupt group register 1 for channel error interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_CEI1_Bits
{
    __I  Ifx_Strict_32Bit TIM0_CH0_EIRQ:1;    /**< \brief [0:0] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH1_EIRQ:1;    /**< \brief [1:1] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH2_EIRQ:1;    /**< \brief [2:2] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH3_EIRQ:1;    /**< \brief [3:3] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH4_EIRQ:1;    /**< \brief [4:4] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH5_EIRQ:1;    /**< \brief [5:5] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH6_EIRQ:1;    /**< \brief [6:6] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM0_CH7_EIRQ:1;    /**< \brief [7:7] TIM0 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH0_EIRQ:1;    /**< \brief [8:8] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH1_EIRQ:1;    /**< \brief [9:9] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH2_EIRQ:1;    /**< \brief [10:10] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH3_EIRQ:1;    /**< \brief [11:11] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH4_EIRQ:1;    /**< \brief [12:12] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH5_EIRQ:1;    /**< \brief [13:13] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH6_EIRQ:1;    /**< \brief [14:14] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM1_CH7_EIRQ:1;    /**< \brief [15:15] TIM1 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH0_EIRQ:1;    /**< \brief [16:16] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH1_EIRQ:1;    /**< \brief [17:17] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH2_EIRQ:1;    /**< \brief [18:18] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH3_EIRQ:1;    /**< \brief [19:19] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH4_EIRQ:1;    /**< \brief [20:20] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH5_EIRQ:1;    /**< \brief [21:21] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH6_EIRQ:1;    /**< \brief [22:22] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit TIM2_CH7_EIRQ:1;    /**< \brief [23:23] TIM2 channel [x] error interrupt (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_CEI1_Bits;

/** \brief ICM_IRQG_CLS_[g]_MEI */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI_Bits
{
    __I  Ifx_Strict_32Bit TIM_M0_EIRQ:1;    /**< \brief [0:0] Error interrupt TIM[j]_EIRQ (j=4*[g]) (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [1:1] \internal Reserved */
    __I  Ifx_Strict_32Bit SPE_M0_EIRQ:1;    /**< \brief [2:2] Error interrupt SPE[j]_EIRQ ([j]=4*[g]+0) (rh) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [7:3] \internal Reserved */
    __I  Ifx_Strict_32Bit TIM_M1_EIRQ:1;    /**< \brief [8:8] Error interrupt TIM[j]_EIRQ ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [9:9] \internal Reserved */
    __I  Ifx_Strict_32Bit SPE_M1_EIRQ:1;    /**< \brief [10:10] Error interrupt SPE[j]_EIRQ ([j]=4*[g]+1) (rh) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [15:11] \internal Reserved */
    __I  Ifx_Strict_32Bit TIM_M2_EIRQ:1;    /**< \brief [16:16] Error interrupt TIM[j]_EIRQ ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [17:17] \internal Reserved */
    __I  Ifx_Strict_32Bit SPE_M2_EIRQ:1;    /**< \brief [18:18] Error interrupt SPE[j]_EIRQ ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [26:19] \internal Reserved */
    __I  Ifx_Strict_32Bit FIFO_M3_EIRQ:1;    /**< \brief [27:27] Error interrupt FIFO[j]_EIRQ ([j]=4*[g]+2) (rh) */
    __I  Ifx_Strict_32Bit :4;              /**< \brief [31:28] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI_Bits;

/** \brief ICM Interrupt group register for module error interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_MEI_Bits
{
    __I  Ifx_Strict_32Bit GTM_EIRQ:1;      /**< \brief [0:0] AEI error interrupt request (rh) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [3:1] \internal Reserved */
    __I  Ifx_Strict_32Bit TIM0_EIRQ:1;     /**< \brief [4:4] ##suppress##TIM[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM1_EIRQ:1;     /**< \brief [5:5] ##suppress##TIM[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM2_EIRQ:1;     /**< \brief [6:6] ##suppress##TIM[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit :13;             /**< \brief [19:7] \internal Reserved */
    __I  Ifx_Strict_32Bit SPE0_EIRQ:1;     /**< \brief [20:20] ##suppress##SPE[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE1_EIRQ:1;     /**< \brief [21:21] ##suppress##SPE[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE2_EIRQ:1;     /**< \brief [22:22] ##suppress##SPE[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [23:23] \internal Reserved */
    __I  Ifx_Strict_32Bit CMP_EIRQ:1;      /**< \brief [24:24] ##suppress##CMP error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [31:25] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_MEI_Bits;

/** \brief ICM Interrupt group SPE for module Error Interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI_Bits
{
    __I  Ifx_Strict_32Bit SPE0_EIRQ:1;     /**< \brief [0:0] ##suppress##SPE[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE1_EIRQ:1;     /**< \brief [1:1] ##suppress##SPE[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE2_EIRQ:1;     /**< \brief [2:2] ##suppress##SPE[j] error interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit :29;             /**< \brief [31:3] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI_Bits;

/** \brief ICM Interrupt group SPE for module Interrupt information */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_SPE_CI_Bits
{
    __I  Ifx_Strict_32Bit SPE0_IRQ:1;      /**< \brief [0:0] ##suppress##SPE[j] interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE1_IRQ:1;      /**< \brief [1:1] ##suppress##SPE[j] interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit SPE2_IRQ:1;      /**< \brief [2:2] ##suppress##SPE[j] interrupt##suppress## (rh) */
    __I  Ifx_Strict_32Bit :29;             /**< \brief [31:3] \internal Reserved */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CI_Bits;

/** \brief ICM_IRQG_TOM_[g]_CI */
typedef struct _Ifx_EGTM_CLS_ICM_IRQG_TOM_CI_Bits
{
    __I  Ifx_Strict_32Bit TOM_M0_CH0_IRQ:1;    /**< \brief [0:0] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH1_IRQ:1;    /**< \brief [1:1] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH2_IRQ:1;    /**< \brief [2:2] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH3_IRQ:1;    /**< \brief [3:3] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH4_IRQ:1;    /**< \brief [4:4] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH5_IRQ:1;    /**< \brief [5:5] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH6_IRQ:1;    /**< \brief [6:6] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH7_IRQ:1;    /**< \brief [7:7] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH8_IRQ:1;    /**< \brief [8:8] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH9_IRQ:1;    /**< \brief [9:9] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH10_IRQ:1;    /**< \brief [10:10] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH11_IRQ:1;    /**< \brief [11:11] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH12_IRQ:1;    /**< \brief [12:12] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH13_IRQ:1;    /**< \brief [13:13] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH14_IRQ:1;    /**< \brief [14:14] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M0_CH15_IRQ:1;    /**< \brief [15:15] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+0)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH0_IRQ:1;    /**< \brief [16:16] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH1_IRQ:1;    /**< \brief [17:17] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH2_IRQ:1;    /**< \brief [18:18] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH3_IRQ:1;    /**< \brief [19:19] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH4_IRQ:1;    /**< \brief [20:20] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH5_IRQ:1;    /**< \brief [21:21] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH6_IRQ:1;    /**< \brief [22:22] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH7_IRQ:1;    /**< \brief [23:23] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH8_IRQ:1;    /**< \brief [24:24] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH9_IRQ:1;    /**< \brief [25:25] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH10_IRQ:1;    /**< \brief [26:26] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH11_IRQ:1;    /**< \brief [27:27] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH12_IRQ:1;    /**< \brief [28:28] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH13_IRQ:1;    /**< \brief [29:29] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH14_IRQ:1;    /**< \brief [30:30] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
    __I  Ifx_Strict_32Bit TOM_M1_CH15_IRQ:1;    /**< \brief [31:31] ##suppress##TOM[j] channel [x] interrupt ([j]=2*[g]+1)##suppress## (rh) */
} Ifx_EGTM_CLS_ICM_IRQG_TOM_CI_Bits;

/** \brief MON status register */
typedef struct _Ifx_EGTM_CLS_MON_STATUS_Bits
{
    __IO Ifx_Strict_32Bit ACT_CMU0:1;      /**< \brief [0:0] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU1:1;      /**< \brief [1:1] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU2:1;      /**< \brief [2:2] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU3:1;      /**< \brief [3:3] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU4:1;      /**< \brief [4:4] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU5:1;      /**< \brief [5:5] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU6:1;      /**< \brief [6:6] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMU7:1;      /**< \brief [7:7] ##suppress##CCM[1]_CLK_RES activity [x]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX0:1;    /**< \brief [8:8] ##suppress##CCM[1]_FXCLK_RES activity [y]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX1:1;    /**< \brief [9:9] ##suppress##CCM[1]_FXCLK_RES activity [y]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX2:1;    /**< \brief [10:10] ##suppress##CCM[1]_FXCLK_RES activity [y]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX3:1;    /**< \brief [11:11] ##suppress##CCM[1]_FXCLK_RES activity [y]##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit ACT_CMUFX4:1;    /**< \brief [12:12] ##suppress##CCM[1]_FXCLK_RES activity [y]##suppress## (rw1ch) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [13:13] \internal Reserved */
    __IO Ifx_Strict_32Bit ACT_CMU8:1;      /**< \brief [14:14] ##suppress##CCM[1]_CLK_RES[8:8] activity##suppress## (rw1ch) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [15:15] \internal Reserved */
    __I  Ifx_Strict_32Bit CMP_ERR:1;       /**< \brief [16:16] ##suppress##Error detected at CMP##suppress## (rh) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [31:17] \internal Reserved */
} Ifx_EGTM_CLS_MON_STATUS_Bits;

/** \brief SPE[i] Command Register */
typedef struct _Ifx_EGTM_CLS_SPE_CMD_Bits
{
    __IO Ifx_Strict_32Bit SPE_CTRL_CMD:2;    /**< \brief [1:0] ##suppress##SPE control command##suppress## (rw) */
    __I  Ifx_Strict_32Bit :14;             /**< \brief [15:2] \internal Reserved */
    __IO Ifx_Strict_32Bit SPE_UPD_TRIG:1;    /**< \brief [16:16] ##suppress##SPE updater trigger##suppress## (rwch) */
    __I  Ifx_Strict_32Bit :15;             /**< \brief [31:17] \internal Reserved */
} Ifx_EGTM_CLS_SPE_CMD_Bits;

/** \brief SPE[i] Control Status Register */
typedef struct _Ifx_EGTM_CLS_SPE_CTRL_STAT_Bits
{
    __IO Ifx_Strict_32Bit EN:1;            /**< \brief [0:0] ##suppress##SPE Sub-module enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit SIE0:1;          /**< \brief [1:1] ##suppress##SPE Input [k] enable for TIM[i]_CH[x:x], TIM[i]_CH[y:y], TIM[i]_CH[z:z].##suppress## (rw) */
    __IO Ifx_Strict_32Bit SIE1:1;          /**< \brief [2:2] ##suppress##SPE Input [k] enable for TIM[i]_CH[x:x], TIM[i]_CH[y:y], TIM[i]_CH[z:z].##suppress## (rw) */
    __IO Ifx_Strict_32Bit SIE2:1;          /**< \brief [3:3] ##suppress##SPE Input [k] enable for TIM[i]_CH[x:x], TIM[i]_CH[y:y], TIM[i]_CH[z:z].##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIG_SEL:2;      /**< \brief [5:4] Select trigger input signal (rw) */
    __IO Ifx_Strict_32Bit TIM_SEL:1;       /**< \brief [6:6] ##suppress##Select TIM input signal##suppress## (rw) */
    __IO Ifx_Strict_32Bit FSOM:1;          /**< \brief [7:7] Fast Shutoff Mode (rw) */
    __IO Ifx_Strict_32Bit SPE_PAT_PTR:3;    /**< \brief [10:8] ##suppress##Pattern selector for TOM output signals.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [11:11] \internal Reserved */
    __IO Ifx_Strict_32Bit AIP:3;           /**< \brief [14:12] Input pattern that was detected by a regular input pattern change. (rw) */
    __IO Ifx_Strict_32Bit ADIR:1;          /**< \brief [15:15] ##suppress##Rotation direction. Will be reflected in the signal SPE[i]_DIR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit PIP:3;           /**< \brief [18:16] Previous input pattern that was detected by a regular input pattern change. (rw) */
    __IO Ifx_Strict_32Bit PDIR:1;          /**< \brief [19:19] Previous rotation direction (rw) */
    __I  Ifx_Strict_32Bit NIP:3;           /**< \brief [22:20] New input pattern that was detected. (rh) */
    __IO Ifx_Strict_32Bit ETRIG_SEL:1;     /**< \brief [23:23] ##suppress##Extended trigger selection of signal TRIG_SEL##suppress## (rw) */
    __IO Ifx_Strict_32Bit FSOL:8;          /**< \brief [31:24] ##suppress##Fast Shutoff Level for TOM[i] channel 0 to 7##suppress## (rw) */
} Ifx_EGTM_CLS_SPE_CTRL_STAT_Bits;

/** \brief SPE[i] Control Status Register 2 */
typedef struct _Ifx_EGTM_CLS_SPE_CTRL_STAT2_Bits
{
    __I  Ifx_Strict_32Bit :8;              /**< \brief [7:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SPE_PAT_PTR_BWD:3;    /**< \brief [10:8] ##suppress##Pattern selector for TOM output signals in case of SPE[i]_CMD.SPE_CTRL_CMD = 0b01 (e.g. backward direction).##suppress## (rw) */
    __I  Ifx_Strict_32Bit :21;             /**< \brief [31:11] \internal Reserved */
} Ifx_EGTM_CLS_SPE_CTRL_STAT2_Bits;

/** \brief SPE[i] Error Interrupt Enable Register */
typedef struct _Ifx_EGTM_CLS_SPE_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit SPE_NIPD_EIRQ_EN:1;    /**< \brief [0:0] SPE_NIPD_EIRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_DCHG_EIRQ_EN:1;    /**< \brief [1:1] SPE_DCHG_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_PERR_EIRQ_EN:1;    /**< \brief [2:2] SPE_PERR_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_BIS_EIRQ_EN:1;    /**< \brief [3:3] ##suppress##SPE[i]_BIS_EIRQ error interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_RCMP_EIRQ_EN:1;    /**< \brief [4:4] ##suppress##SPE[i]_RCMP_EIRQ error interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_EIRQ_EN_Bits;

/** \brief SPE[i] Interrupt Enable Register */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit SPE_NIPD_IRQ_EN:1;    /**< \brief [0:0] SPE_NIPD_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_DCHG_IRQ_EN:1;    /**< \brief [1:1] SPE_DCHG_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_PERR_IRQ_EN:1;    /**< \brief [2:2] SPE_PERR_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_BIS_IRQ_EN:1;    /**< \brief [3:3] SPE_BIS_IRQ interrupt enable (rw) */
    __IO Ifx_Strict_32Bit SPE_RCMP_IRQ_EN:1;    /**< \brief [4:4] SPE_RCMP_IRQ interrupt enable (rw) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_EN_Bits;

/** \brief SPE[i] Interrupt Generation By Software */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_SPE_NIPD:1;    /**< \brief [0:0] ##suppress##Trigger SPE[i]_IRQ_NOTIFY.SPE_NIPD by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_DCHG:1;    /**< \brief [1:1] ##suppress##Trigger SPE[i]_IRQ_NOTIFY.SPE_DCHG by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_PERR:1;    /**< \brief [2:2] ##suppress##Trigger SPE[i]_IRQ_NOTIFY.SPE_PERR by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_BIS:1;    /**< \brief [3:3] ##suppress##Trigger SPE[i]_IRQ_NOTIFY.SPE_BIS by software.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_SPE_RCMP:1;    /**< \brief [4:4] ##suppress##Trigger SPE[i]_IRQ_NOTIFY.SPE_RCMP by software.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_FORCINT_Bits;

/** \brief SPE[i] Interrupt Mode Configuration Register */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_MODE_Bits;

/** \brief SPE[i] Interrupt Notification Register */
typedef struct _Ifx_EGTM_CLS_SPE_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit SPE_NIPD:1;      /**< \brief [0:0] New input pattern interrupt occurred (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_DCHG:1;      /**< \brief [1:1] SPE_DIR bit changed on behalf of new input pattern. (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_PERR:1;      /**< \brief [2:2] Wrong or invalid pattern detected at input. (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_BIS:1;       /**< \brief [3:3] Bouncing input signal detected (rw1ch) */
    __IO Ifx_Strict_32Bit SPE_RCMP:1;      /**< \brief [4:4] ##suppress##SPE revolution counter match event##suppress## (rw1ch) */
    __I  Ifx_Strict_32Bit :27;             /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_CLS_SPE_IRQ_NOTIFY_Bits;

/** \brief SPE[i] Output Control Register */
typedef struct _Ifx_EGTM_CLS_SPE_OUT_CTRL_Bits
{
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL0:2;    /**< \brief [1:0] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL1:2;    /**< \brief [3:2] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL2:2;    /**< \brief [5:4] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL3:2;    /**< \brief [7:6] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL4:2;    /**< \brief [9:8] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL5:2;    /**< \brief [11:10] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL6:2;    /**< \brief [13:12] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_CTRL7:2;    /**< \brief [15:14] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_SPE_OUT_CTRL_Bits;

/** \brief SPE[i] Output Definition Register [p] */
typedef struct _Ifx_EGTM_CLS_SPE_OUT_PAT_Bits
{
    __IO Ifx_Strict_32Bit SPE_OUT_PAT0:2;    /**< \brief [1:0] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT1:2;    /**< \brief [3:2] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT2:2;    /**< \brief [5:4] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT3:2;    /**< \brief [7:6] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT4:2;    /**< \brief [9:8] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT5:2;    /**< \brief [11:10] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT6:2;    /**< \brief [13:12] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_OUT_PAT7:2;    /**< \brief [15:14] ##suppress##SPE output control value for TOM channel [o]##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_SPE_OUT_PAT_Bits;

/** \brief SPE[i] Input Pattern Definition Register */
typedef struct _Ifx_EGTM_CLS_SPE_PAT_Bits
{
    __IO Ifx_Strict_32Bit IP0_VAL:1;       /**< \brief [0:0] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP0_PAT:3;       /**< \brief [3:1] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP1_VAL:1;       /**< \brief [4:4] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP1_PAT:3;       /**< \brief [7:5] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP2_VAL:1;       /**< \brief [8:8] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP2_PAT:3;       /**< \brief [11:9] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP3_VAL:1;       /**< \brief [12:12] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP3_PAT:3;       /**< \brief [15:13] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP4_VAL:1;       /**< \brief [16:16] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP4_PAT:3;       /**< \brief [19:17] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP5_VAL:1;       /**< \brief [20:20] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP5_PAT:3;       /**< \brief [23:21] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP6_VAL:1;       /**< \brief [24:24] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP6_PAT:3;       /**< \brief [27:25] Input pattern [t] (rw) */
    __IO Ifx_Strict_32Bit IP7_VAL:1;       /**< \brief [28:28] Input pattern [t] is a valid pattern. (rw) */
    __IO Ifx_Strict_32Bit IP7_PAT:3;       /**< \brief [31:29] Input pattern [t] (rw) */
} Ifx_EGTM_CLS_SPE_PAT_Bits;

/** \brief SPE[i] Revolution Counter Compare Value */
typedef struct _Ifx_EGTM_CLS_SPE_REV_CMP_Bits
{
    __IO Ifx_Strict_32Bit REV_CMP:24;      /**< \brief [23:0] Input signal revolution counter compare value (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_SPE_REV_CMP_Bits;

/** \brief SPE[i] Input Revolution Counter */
typedef struct _Ifx_EGTM_CLS_SPE_REV_CNT_Bits
{
    __IO Ifx_Strict_32Bit REV_CNT:24;      /**< \brief [23:0] Input signal revolution counter (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_SPE_REV_CNT_Bits;

/** \brief TBU channel 0 base */
typedef struct _Ifx_EGTM_CLS_TBU_CH0_BASE_Bits
{
    __IO Ifx_Strict_32Bit BASE:27;         /**< \brief [26:0] Time base value for channel 0 (rwh) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [31:27] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH0_BASE_Bits;

/** \brief TBU channel 0 control */
typedef struct _Ifx_EGTM_CLS_TBU_CH0_CTRL_Bits
{
    __IO Ifx_Strict_32Bit LOW_RES:1;       /**< \brief [0:0] ##suppress##TBU_CH0_BASE register resolution##suppress## (rwh) */
    __IO Ifx_Strict_32Bit CH_CLK_SRC:3;    /**< \brief [3:1] Clock source for channel 0, channel 1 and channel 2 time base counter (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH0_CTRL_Bits;

/** \brief TBU channel 1 control */
typedef struct _Ifx_EGTM_CLS_TBU_CH1_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CH_MODE:1;       /**< \brief [0:0] Channel mode (rwh) */
    __IO Ifx_Strict_32Bit CH_CLK_SRC:3;    /**< \brief [3:1] Clock source for channel 1 time base counter (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH1_CTRL_Bits;

/** \brief TBU channel 2 control */
typedef struct _Ifx_EGTM_CLS_TBU_CH2_CTRL_Bits
{
    __IO Ifx_Strict_32Bit CH_MODE:1;       /**< \brief [0:0] Channel mode (rwh) */
    __IO Ifx_Strict_32Bit CH_CLK_SRC:3;    /**< \brief [3:1] Clock source for channel 2 time base counter (rwh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH2_CTRL_Bits;

/** \brief TBU global channel enable */
typedef struct _Ifx_EGTM_CLS_TBU_CHEN_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_CH0:2;     /**< \brief [1:0] ##suppress##TBU channel [y] enable/disable control##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_CH1:2;     /**< \brief [3:2] ##suppress##TBU channel [y] enable/disable control##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_CH2:2;     /**< \brief [5:4] ##suppress##TBU channel [y] enable/disable control##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CHEN_Bits;

/** \brief TBU channel [x] base */
typedef struct _Ifx_EGTM_CLS_TBU_CH_BASE_Bits
{
    __IO Ifx_Strict_32Bit BASE:24;         /**< \brief [23:0] Time base value for channel [x] (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TBU_CH_BASE_Bits;

/** \brief TIM[i] channel [x] SMU counter register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_CNT_Bits
{
    __I  Ifx_Strict_32Bit CNT:24;          /**< \brief [23:0] Actual SMU counter value (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_CNT_Bits;

/** \brief TIM[i] channel [x] SMU shadow counter register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_CNTS_Bits
{
    __IO Ifx_Strict_32Bit CNTS:24;         /**< \brief [23:0] Counter shadow register (rwh) */
    __I  Ifx_Strict_32Bit ECNT:8;          /**< \brief [31:24] Edge counter (rh) */
} Ifx_EGTM_CLS_TIM_CH_CNTS_Bits;

/** \brief TIM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_CTRL_Bits
{
    __IO Ifx_Strict_32Bit TIM_EN:1;        /**< \brief [0:0] ##suppress##TIM channel [x] enable##suppress## (rwh) */
    __IO Ifx_Strict_32Bit TIM_MODE:3;      /**< \brief [3:1] ##suppress##TIM channel [x] mode##suppress## (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [4:4] One-shot mode (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [5:5] \internal Reserved */
    __IO Ifx_Strict_32Bit CICTRL:1;        /**< \brief [6:6] Channel Input Control (rw) */
    __IO Ifx_Strict_32Bit TBU0_SEL:1;      /**< \brief [7:7] ##suppress##TIM_TBU_TS0 bits input select for TIM0_CH[x]_GPR0 and TIM0_CH[x]_GPR1##suppress## (rw) */
    __IO Ifx_Strict_32Bit GPR0_SEL:2;      /**< \brief [9:8] ##suppress##Selection for TIM[i]_CH[x]_GPR0 register##suppress## (rw) */
    __IO Ifx_Strict_32Bit GPR1_SEL:2;      /**< \brief [11:10] ##suppress##Selection for TIM[i]_CH[x]_GPR1 register##suppress## (rw) */
    __IO Ifx_Strict_32Bit CNTS_SEL:1;      /**< \brief [12:12] ##suppress##Selection for TIM[i]_CH[x]_CNTS register##suppress## (rw) */
    __IO Ifx_Strict_32Bit DSL:1;           /**< \brief [13:13] Signal level control (rw) */
    __IO Ifx_Strict_32Bit ISL:1;           /**< \brief [14:14] Ignore signal level (rw) */
    __IO Ifx_Strict_32Bit ECNT_RESET:1;    /**< \brief [15:15] Enables resetting of counter in certain modes (rw) */
    __IO Ifx_Strict_32Bit FLT_EN:1;        /**< \brief [16:16] Filter enable for channel [x] (rw) */
    __IO Ifx_Strict_32Bit FLT_CNT_FRQ:2;    /**< \brief [18:17] Filter counter frequency select (rw) */
    __IO Ifx_Strict_32Bit EXT_CAP_EN:1;    /**< \brief [19:19] ##suppress##Enables external capture mode. The selected TIM mode is only sensitive to external capture pulses the input event changes are ignored.##suppress## (rw) */
    __IO Ifx_Strict_32Bit FLT_MODE_RE:1;    /**< \brief [20:20] Filter mode for rising edge (rw) */
    __IO Ifx_Strict_32Bit FLT_CTR_RE:1;    /**< \brief [21:21] Filter counter mode for rising edge (rw) */
    __IO Ifx_Strict_32Bit FLT_MODE_FE:1;    /**< \brief [22:22] Filter mode for falling edge (rw) */
    __IO Ifx_Strict_32Bit FLT_CTR_FE:1;    /**< \brief [23:23] Filter counter mode for falling edge (rw) */
    __IO Ifx_Strict_32Bit CLK_SEL:3;       /**< \brief [26:24] ##suppress##CMU clock source select for channel##suppress## (rw) */
    __IO Ifx_Strict_32Bit FR_ECNT_OFL:1;    /**< \brief [27:27] Extended Edge counter overflow behavior (rw) */
    __IO Ifx_Strict_32Bit EGPR0_SEL:1;     /**< \brief [28:28] ##suppress##Extension of TIM[i]_CH[x]_CTRL.GPR0_SEL bit field##suppress## (rw) */
    __IO Ifx_Strict_32Bit EGPR1_SEL:1;     /**< \brief [29:29] ##suppress##Extension of TIM[i]_CH[x]_CTRL.GPR1_SEL bit field##suppress## (rw) */
    __IO Ifx_Strict_32Bit TOCTRL:2;        /**< \brief [31:30] Timeout control (rw) */
} Ifx_EGTM_CLS_TIM_CH_CTRL_Bits;

/** \brief TIM[i] channel [x] SMU edge counter register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_ECNT_Bits
{
    __I  Ifx_Strict_32Bit ECNT:16;         /**< \brief [15:0] Edge counter (rh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_ECNT_Bits;

/** \brief TIM[i] channel [x] extended control register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_ECTRL_Bits
{
    __IO Ifx_Strict_32Bit EXT_CAP_SRC:4;    /**< \brief [3:0] ##suppress##Defines selected source for triggering the TIM_EXT_CAPTURE functionality.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [4:4] \internal Reserved */
    __IO Ifx_Strict_32Bit USE_PREV_TDU_IN:1;    /**< \brief [5:5] ##suppress##Select input data source for TDU##suppress## (rw) */
    __IO Ifx_Strict_32Bit TODET_IRQ_SRC:2;    /**< \brief [7:6] ##suppress##Selection of source for TIM_TODET_IRQ##suppress## (rw) */
    __IO Ifx_Strict_32Bit TDU_START:3;     /**< \brief [10:8] ##suppress##Defines condition which will start the TDU unit.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [11:11] \internal Reserved */
    __IO Ifx_Strict_32Bit TDU_STOP:3;      /**< \brief [14:12] ##suppress##Defines condition which will stop the TDU unit.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [15:15] \internal Reserved */
    __IO Ifx_Strict_32Bit TDU_RESYNC:4;    /**< \brief [19:16] ##suppress##Defines condition which will resynchronize the TDU unit.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [21:20] \internal Reserved */
    __IO Ifx_Strict_32Bit USE_LUT:2;       /**< \brief [23:22] Generate filter input by lookup-table (rw) */
    __IO Ifx_Strict_32Bit EFLT_CTR_RE:1;    /**< \brief [24:24] ##suppress##Extension of bit field TIM[i]_CH[x]_CTRL.FLT_CTR_RE##suppress## (rw) */
    __IO Ifx_Strict_32Bit EFLT_CTR_FE:1;    /**< \brief [25:25] ##suppress##Extension of bit field TIM[i]_CH[x]_CTRL.FLT_CTR_FE##suppress## (rw) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [27:26] \internal Reserved */
    __IO Ifx_Strict_32Bit SWAP_CAPTURE:1;    /**< \brief [28:28] ##suppress##Swap point in time of capturing TIM[i]_CH[x]_CNTS and TIM[i]_CH[x]_GPR1##suppress## (rw) */
    __IO Ifx_Strict_32Bit IMM_START:1;     /**< \brief [29:29] Start the measurement immediately (rw) */
    __IO Ifx_Strict_32Bit ECLK_SEL:1;      /**< \brief [30:30] ##suppress##Extension of bit field TIM[i]_CH[x]_CTRL.CLK_SEL##suppress## (rw) */
    __IO Ifx_Strict_32Bit USE_PREV_CH_IN:1;    /**< \brief [31:31] ##suppress##Select input data source for TIM channel##suppress## (rw) */
} Ifx_EGTM_CLS_TIM_CH_ECTRL_Bits;

/** \brief TIM[i] channel [x] error interrupt enable register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_EIRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit NEWVAL_EIRQ_EN:1;    /**< \brief [0:0] TIM_NEWVAL[x]_EIRQ error interrupt enable (rw) */
    __IO Ifx_Strict_32Bit ECNTOFL_EIRQ_EN:1;    /**< \brief [1:1] ##suppress##TIM_ECNTOFL_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit CNTOFL_EIRQ_EN:1;    /**< \brief [2:2] ##suppress##TIM_CNTOFL_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit GPROFL_EIRQ_EN:1;    /**< \brief [3:3] ##suppress##TIM_GPROFL_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit TODET_EIRQ_EN:1;    /**< \brief [4:4] ##suppress##TIM_TODET_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit GLITCHDET_EIRQ_EN:1;    /**< \brief [5:5] ##suppress##TIM_GLITCHDET_IRQ[x:x] interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_EIRQ_EN_Bits;

/** \brief TIM[i] channel [x] filter parameter 1 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_FLT_FE_Bits
{
    __IO Ifx_Strict_32Bit FLT_FE:24;       /**< \brief [23:0] Filter parameter for falling edge (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_FLT_FE_Bits;

/** \brief TIM[i] channel [x] filter parameter 0 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_FLT_RE_Bits
{
    __IO Ifx_Strict_32Bit FLT_RE:24;       /**< \brief [23:0] Filter parameter for rising edge (rw) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_FLT_RE_Bits;

/** \brief TIM[i] channel [x] general-purpose 0 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_GPR0_Bits
{
    __IO Ifx_Strict_32Bit GPR0:24;         /**< \brief [23:0] Input signal characteristic parameter 0 (rwh) */
    __I  Ifx_Strict_32Bit ECNT:8;          /**< \brief [31:24] ##suppress##Edge counter, value refers to TIM[i]_CH[x]_ECNT.ECNT[7:0].##suppress## (rh) */
} Ifx_EGTM_CLS_TIM_CH_GPR0_Bits;

/** \brief TIM[i] channel [x] general-purpose 1 register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_GPR1_Bits
{
    __IO Ifx_Strict_32Bit GPR1:24;         /**< \brief [23:0] Input signal characteristic parameter 1 (rwh) */
    __I  Ifx_Strict_32Bit ECNT:8;          /**< \brief [31:24] ##suppress##Edge counter, value refers to TIM[i]_CH[x]_ECNT.ECNT[7:0].##suppress## (rh) */
} Ifx_EGTM_CLS_TIM_CH_GPR1_Bits;

/** \brief TIM[i] channel [x] interrupt enable register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit NEWVAL_IRQ_EN:1;    /**< \brief [0:0] ##suppress##TIM_NEWVAL_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit ECNTOFL_IRQ_EN:1;    /**< \brief [1:1] ##suppress##TIM_ECNTOFL_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit CNTOFL_IRQ_EN:1;    /**< \brief [2:2] ##suppress##TIM_CNTOFL_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit GPROFL_IRQ_EN:1;    /**< \brief [3:3] ##suppress##TIM_GPROFL_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit TODET_IRQ_EN:1;    /**< \brief [4:4] ##suppress##TIM_TODET_IRQ[x:x] interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit GLITCHDET_IRQ_EN:1;    /**< \brief [5:5] ##suppress##TIM_GLITCHDET_IRQ[x:x] interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_EN_Bits;

/** \brief TIM[i] channel [x] force interrupt register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_NEWVAL:1;    /**< \brief [0:0] ##suppress##Trigger the bit TIM[i]_CH[x]_IRQ_NOTIFY.NEWVAL by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_ECNTOFL:1;    /**< \brief [1:1] Trigger the bit TIM_CHx_IRQ_NOTIFY.ECNTOFL by software (rw) */
    __IO Ifx_Strict_32Bit TRG_CNTOFL:1;    /**< \brief [2:2] ##suppress##Trigger the bit TIM[i]_CH[x]_IRQ_NOTIFY.CNTOFL by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_GPROFL:1;    /**< \brief [3:3] ##suppress##Trigger the bit TIM[i]_CH[x]_IRQ_NOTIFY.GPROFL by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_TODET:1;     /**< \brief [4:4] ##suppress##Trigger the bit TIM[i]_CH[x]_IRQ_NOTIFY.TODET by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_GLITCHDET:1;    /**< \brief [5:5] ##suppress##Trigger the bit TIM[i]_CH[x]_IRQ_NOTIFY.GLITCHDET by software##suppress## (rw) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT_Bits;

/** \brief TIM[i] channel [x] interrupt mode configuration register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection of channel [x] (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_MODE_Bits;

/** \brief TIM[i] channel [x] interrupt notification register */
typedef struct _Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit NEWVAL:1;        /**< \brief [0:0] New measurement value detected by the channel [x] ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit ECNTOFL:1;       /**< \brief [1:1] ECNT counter overflow of channel [x] ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit CNTOFL:1;        /**< \brief [2:2] ##suppress##SMU TIM[i]_CH[x]_CNT counter overflow of channel [x], ([x]:0...m-1)##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit GPROFL:1;        /**< \brief [3:3] ##suppress##TIM[i]_CH[x]_GPR0 and TIM[i]_CH[x]_GPR1 data overflow, old data not read out before new data has arrived at input pin, ([x]:0...m-1)##suppress## (rw1ch) */
    __IO Ifx_Strict_32Bit TODET:1;         /**< \brief [4:4] Timeout reached for input signal of channel [x], ([x]:0...m-1) (rw1ch) */
    __IO Ifx_Strict_32Bit GLITCHDET:1;     /**< \brief [5:5] Glitch detected on channel [x], ([x]:0...m-1) (rw1ch) */
    __I  Ifx_Strict_32Bit :26;             /**< \brief [31:6] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY_Bits;

/** \brief TIM[i]_CH[x]_TDUC */
typedef struct _Ifx_EGTM_CLS_TIM_CH_TDUC_Bits
{
    __IO Ifx_Strict_32Bit TO_CNT:8;        /**< \brief [7:0] Current Timeout value slice0 for channel [y] (rwh) */
    __IO Ifx_Strict_32Bit TO_CNT1:8;       /**< \brief [15:8] Current Timeout value slice1 for channel [y] (rwh) */
    __IO Ifx_Strict_32Bit TO_CNT2:8;       /**< \brief [23:16] Current Timeout value slice2 for channel [y] (rwh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_TDUC_Bits;

/** \brief TIM[i]_CH[x]_TDUV */
typedef struct _Ifx_EGTM_CLS_TIM_CH_TDUV_Bits
{
    __IO Ifx_Strict_32Bit TOV:8;           /**< \brief [7:0] Time out compare value slice0 for channel [y] (rw) */
    __IO Ifx_Strict_32Bit TOV1:8;          /**< \brief [15:8] Time out compare value slice1 for channel [y] (rw) */
    __IO Ifx_Strict_32Bit TOV2:8;          /**< \brief [23:16] Time out compare value slice2 for channel [y] (rw) */
    __IO Ifx_Strict_32Bit SLICING:2;       /**< \brief [25:24] Cascading of counter slices (rw) */
    __IO Ifx_Strict_32Bit TCS_USE_SAMPLE_EVT:1;    /**< \brief [26:26] ##suppress##Use TDU_SAMPLE_EVT as Timeout Clock##suppress## (rw) */
    __IO Ifx_Strict_32Bit TDU_SAME_CNT_CLK:1;    /**< \brief [27:27] Define clocking of TO_CNT, TO_CNT1 (rw) */
    __IO Ifx_Strict_32Bit TCS:3;           /**< \brief [30:28] Timeout clock selection (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH_TDUV_Bits;

/** \brief TIM[i] input value observation register */
typedef struct _Ifx_EGTM_CLS_TIM_INP_VAL_Bits
{
    __I  Ifx_Strict_32Bit F_OUT0:1;        /**< \brief [0:0] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_OUT1:1;        /**< \brief [1:1] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_OUT2:1;        /**< \brief [2:2] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_OUT3:1;        /**< \brief [3:3] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_OUT4:1;        /**< \brief [4:4] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_OUT5:1;        /**< \brief [5:5] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_OUT6:1;        /**< \brief [6:6] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_OUT7:1;        /**< \brief [7:7] ##suppress##Signal channel [x] after TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN0:1;         /**< \brief [8:8] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN1:1;         /**< \brief [9:9] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN2:1;         /**< \brief [10:10] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN3:1;         /**< \brief [11:11] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN4:1;         /**< \brief [12:12] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN5:1;         /**< \brief [13:13] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN6:1;         /**< \brief [14:14] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit F_IN7:1;         /**< \brief [15:15] ##suppress##Signal channel [x] after INPSRC selection, before TIM FLT unit##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN0:1;       /**< \brief [16:16] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN1:1;       /**< \brief [17:17] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN2:1;       /**< \brief [18:18] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN3:1;       /**< \brief [19:19] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN4:1;       /**< \brief [20:20] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN5:1;       /**< \brief [21:21] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN6:1;       /**< \brief [22:22] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit TIM_IN7:1;       /**< \brief [23:23] ##suppress##Signal channel [x] after TIM input signal synchronization##suppress## (rh) */
    __I  Ifx_Strict_32Bit :8;              /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_CLS_TIM_INP_VAL_Bits;

/** \brief TIM[i] AUX IN source selection register */
typedef struct _Ifx_EGTM_CLS_TIM_IN_SRC_Bits
{
    __IO Ifx_Strict_32Bit VAL0:2;          /**< \brief [1:0] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE0:2;         /**< \brief [3:2] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL1:2;          /**< \brief [5:4] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE1:2;         /**< \brief [7:6] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL2:2;          /**< \brief [9:8] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE2:2;         /**< \brief [11:10] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL3:2;          /**< \brief [13:12] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE3:2;         /**< \brief [15:14] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL4:2;          /**< \brief [17:16] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE4:2;         /**< \brief [19:18] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL5:2;          /**< \brief [21:20] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE5:2;         /**< \brief [23:22] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL6:2;          /**< \brief [25:24] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE6:2;         /**< \brief [27:26] Input source to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit VAL7:2;          /**< \brief [29:28] Value to be fed to channel [x] (rwh) */
    __IO Ifx_Strict_32Bit MODE7:2;         /**< \brief [31:30] Input source to channel [x] (rwh) */
} Ifx_EGTM_CLS_TIM_IN_SRC_Bits;

/** \brief TIM[i] global software reset register */
typedef struct _Ifx_EGTM_CLS_TIM_RST_Bits
{
    __IO Ifx_Strict_32Bit RST_CH0:1;       /**< \brief [0:0] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH1:1;       /**< \brief [1:1] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH2:1;       /**< \brief [2:2] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH3:1;       /**< \brief [3:3] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH4:1;       /**< \brief [4:4] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH5:1;       /**< \brief [5:5] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH6:1;       /**< \brief [6:6] Software reset of channel [x] (rw) */
    __IO Ifx_Strict_32Bit RST_CH7:1;       /**< \brief [7:7] Software reset of channel [x] (rw) */
    __I  Ifx_Strict_32Bit :24;             /**< \brief [31:8] \internal Reserved */
} Ifx_EGTM_CLS_TIM_RST_Bits;

/** \brief TOM[i] channel [x] CCU0 compare register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CM0_Bits
{
    __IO Ifx_Strict_32Bit CM0:16;          /**< \brief [15:0] ##suppress##TOM[i] channel [x] CCU0 compare register##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CM0_Bits;

/** \brief TOM[i] channel [x] CCU1 compare register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CM1_Bits
{
    __IO Ifx_Strict_32Bit CM1:16;          /**< \brief [15:0] ##suppress##TOM[i] channel [x] CCU1 compare register##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CM1_Bits;

/** \brief TOM[i] channel [x] CCU0 counter */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CN0_Bits
{
    __IO Ifx_Strict_32Bit CN0:16;          /**< \brief [15:0] ##suppress##TOM[i] CCU0 counter##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CN0_Bits;

/** \brief TOM[i] channel [x] control register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CTRL_Bits
{
    __I  Ifx_Strict_32Bit :7;              /**< \brief [6:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SR0_TRIG:1;      /**< \brief [7:7] ##suppress##TOM[i]_CH[x]_SR0 is used to generate a trigger on output TOM_OUT_T[x:x] if equal to TOM[i]_CH[x]_CN0.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :3;              /**< \brief [10:8] \internal Reserved */
    __IO Ifx_Strict_32Bit SL:1;            /**< \brief [11:11] Signal level for pulse width (rwh) */
    __IO Ifx_Strict_32Bit CLK_SRC:4;       /**< \brief [15:12] Clock source select for channel (rwh) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [16:16] \internal Reserved */
    __IO Ifx_Strict_32Bit TRIG_PULSE:1;    /**< \brief [17:17] Trigger output pulse length of one cluster clock period (rw) */
    __IO Ifx_Strict_32Bit UDMODE:2;        /**< \brief [19:18] Up-down counter mode (rw) */
    __IO Ifx_Strict_32Bit RST_CCU0:1;      /**< \brief [20:20] Reset source of CCU0 (rw) */
    __IO Ifx_Strict_32Bit OSM_TRIG:1;      /**< \brief [21:21] One-shot pulse generation enabled by the selected trigger signal (rw) */
    __IO Ifx_Strict_32Bit EXT_TRIG:1;      /**< \brief [22:22] ##suppress##Select TOM_EXT_TRIGIN[x:x] as trigger signal##suppress## (rw) */
    __IO Ifx_Strict_32Bit EXTTRIGOUT:1;    /**< \brief [23:23] ##suppress##Select TOM_EXT_TRIGIN[x:x] as potential output signal TOM_CH_TRIGOUT[x:x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRIGOUT:1;       /**< \brief [24:24] ##suppress##Trigger output selection (output signal TOM_CH_TRIGOUT[x:x]) of module TOM channel [x]##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPE_TRIG:1;      /**< \brief [25:25] ##suppress##SPE trigger to reset TOM[i]_CH[x]_CN0##suppress## (rw) */
    __IO Ifx_Strict_32Bit OSM:1;           /**< \brief [26:26] One-shot mode. (rw) */
    __IO Ifx_Strict_32Bit BITREV:1;        /**< \brief [27:27] ##suppress##Bit-reversing of output of counter TOM[i]_CH[x]_CN0.##suppress## (rw) */
    __IO Ifx_Strict_32Bit SPEM:1;          /**< \brief [28:28] ##suppress##SPE output mode enable for channel.##suppress## (rw) */
    __IO Ifx_Strict_32Bit GCM:1;           /**< \brief [29:29] Gated Counter Mode enable (rw) */
    __I  Ifx_Strict_32Bit :1;              /**< \brief [30:30] \internal Reserved */
    __IO Ifx_Strict_32Bit FREEZE:1;        /**< \brief [31:31] ##suppress##TOM[i] Freeze Mode enable##suppress## (rw) */
} Ifx_EGTM_CLS_TOM_CH_CTRL_Bits;

/** \brief TOM[i] channel [x] control shadow register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_CTRL_SR_Bits
{
    __I  Ifx_Strict_32Bit :11;             /**< \brief [10:0] \internal Reserved */
    __IO Ifx_Strict_32Bit SL_SR:1;         /**< \brief [11:11] ##suppress##Shadow register for TOM[i]_CH[x]_CTRL.SL##suppress## (rw) */
    __IO Ifx_Strict_32Bit CLK_SRC_SR:4;    /**< \brief [15:12] ##suppress##Shadow register for TOM[i]_CH[x]_CTRL.CLK_SRC##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_CTRL_SR_Bits;

/** \brief TOM[i] channel [x] interrupt enable register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_EN_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC_IRQ_EN:1;    /**< \brief [0:0] ##suppress##TOM_CCU0TC[x]_IRQ interrupt enable##suppress## (rw) */
    __IO Ifx_Strict_32Bit CCU1TC_IRQ_EN:1;    /**< \brief [1:1] ##suppress##TOM_CCU1TC[x]_IRQ interrupt enable##suppress## (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_EN_Bits;

/** \brief TOM[i] channel [x] force interrupt register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT_Bits
{
    __IO Ifx_Strict_32Bit TRG_CCU0TC:1;    /**< \brief [0:0] ##suppress##Trigger the bit TOM[i]_CH[x]_IRQ_NOTIFY.CCU0TC by software##suppress## (rw) */
    __IO Ifx_Strict_32Bit TRG_CCU1TC:1;    /**< \brief [1:1] ##suppress##Trigger the bit TOM[i]_CH[x]_IRQ_NOTIFY.CCU1TC by software##suppress## (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT_Bits;

/** \brief TOM[i] channel [x] interrupt mode register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_MODE_Bits
{
    __IO Ifx_Strict_32Bit IRQ_MODE:2;      /**< \brief [1:0] IRQ mode selection (rw) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_MODE_Bits;

/** \brief TOM[i] channel [x] interrupt notification register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY_Bits
{
    __IO Ifx_Strict_32Bit CCU0TC:1;        /**< \brief [0:0] CCU0 Trigger condition interrupt for channel [x] (rw1ch) */
    __IO Ifx_Strict_32Bit CCU1TC:1;        /**< \brief [1:1] CCU1 Trigger condition interrupt for channel [x] (rw1ch) */
    __I  Ifx_Strict_32Bit :30;             /**< \brief [31:2] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY_Bits;

/** \brief TOM[i] channel [x] CCU0 compare shadow register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_SR0_Bits
{
    __IO Ifx_Strict_32Bit SR0:16;          /**< \brief [15:0] ##suppress##TOM[i] channel [x] shadow register TOM[i]_CH[x]_SR0 for update of compare register TOM[i]_CH[x]_CM0##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_SR0_Bits;

/** \brief TOM[i] channel [x] CCU1 compare shadow register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_SR1_Bits
{
    __IO Ifx_Strict_32Bit SR1:16;          /**< \brief [15:0] ##suppress##TOM[i] channel [x] shadow register TOM[i]_CH[x]_SR1 for update of compare register TOM[i]_CH[x]_CM1##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_SR1_Bits;

/** \brief TOM[i] channel [x] status register */
typedef struct _Ifx_EGTM_CLS_TOM_CH_STAT_Bits
{
    __I  Ifx_Strict_32Bit OL:1;            /**< \brief [0:0] ##suppress##Output level of output TOM_OUT[x:x]##suppress## (rh) */
    __I  Ifx_Strict_32Bit :28;             /**< \brief [28:1] \internal Reserved */
    __IO Ifx_Strict_32Bit OSM_RTF:1;       /**< \brief [29:29] One-shot mode retrigger failed flag (rw1ch) */
    __I  Ifx_Strict_32Bit :2;              /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH_STAT_Bits;

/** \brief TOM[i] TGC [g] action time base register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_ACT_TB_Bits
{
    __IO Ifx_Strict_32Bit ACT_TB:24;       /**< \brief [23:0] ##suppress##Action time base. When the selected TBU time base CCM[i]_TBU_TS0/CCM[i]_TBU_TS1/CCM[i]_TBU_TS2 is "cyclically greater than or equal to" the action time base TOM[i]_TGC[g]_ACT_TB.ACT_TB, the compare event specified in TOM[i]_TGC[g]_ACT_TB.ACT_TB is considered to have occurred in the past and so the trigger CTRL_TRIG is immediately generated in TGC[g] unit if TOM[i]_TGC[g]_ACT_TB.TB_TRIG is 1. Please refer to chapter eGTM Architecture for more information about cyclic event compare strategy.##suppress## (rw) */
    __IO Ifx_Strict_32Bit TB_TRIG:1;       /**< \brief [24:24] Set trigger request (rwh) */
    __IO Ifx_Strict_32Bit TBU_SEL:2;       /**< \brief [26:25] Selection of time base used for comparison (rw) */
    __I  Ifx_Strict_32Bit :5;              /**< \brief [31:27] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_ACT_TB_Bits;

/** \brief TOM[i] TGC [g] enable/disable control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_CTRL0:2;    /**< \brief [1:0] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL1:2;    /**< \brief [3:2] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL2:2;    /**< \brief [5:4] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL3:2;    /**< \brief [7:6] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL4:2;    /**< \brief [9:8] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL5:2;    /**< \brief [11:10] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL6:2;    /**< \brief [13:12] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __IO Ifx_Strict_32Bit ENDIS_CTRL7:2;    /**< \brief [15:14] ##suppress##TOM[i] channel [x] (x=c + g*8) enable/disable control register.##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL_Bits;

/** \brief TOM[i] TGC [g] enable/disable status register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT_Bits
{
    __IO Ifx_Strict_32Bit ENDIS_STAT0:2;    /**< \brief [1:0] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT1:2;    /**< \brief [3:2] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT2:2;    /**< \brief [5:4] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT3:2;    /**< \brief [7:6] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT4:2;    /**< \brief [9:8] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT5:2;    /**< \brief [11:10] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT6:2;    /**< \brief [13:12] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __IO Ifx_Strict_32Bit ENDIS_STAT7:2;    /**< \brief [15:14] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable/disable status register##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT_Bits;

/** \brief TOM[i] TGC [g] force update control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL_Bits
{
    __IO Ifx_Strict_32Bit FUPD_CTRL0:2;    /**< \brief [1:0] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL1:2;    /**< \brief [3:2] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL2:2;    /**< \brief [5:4] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL3:2;    /**< \brief [7:6] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL4:2;    /**< \brief [9:8] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL5:2;    /**< \brief [11:10] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL6:2;    /**< \brief [13:12] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit FUPD_CTRL7:2;    /**< \brief [15:14] ##suppress##Force update control of operation registers of TOM[i] channel [x] (x = c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH0:2;    /**< \brief [17:16] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH1:2;    /**< \brief [19:18] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH2:2;    /**< \brief [21:20] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH3:2;    /**< \brief [23:22] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH4:2;    /**< \brief [25:24] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH5:2;    /**< \brief [27:26] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH6:2;    /**< \brief [29:28] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
    __IO Ifx_Strict_32Bit RSTCN0_CH7:2;    /**< \brief [31:30] ##suppress##Reset TOM[i]_CH[x]_CN0 of channel [x] (x=c + g*8) with the force update event##suppress## (rw) */
} Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL_Bits;

/** \brief TOM[i] TGC [g] global control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL_Bits
{
    __IO Ifx_Strict_32Bit HOST_TRIG:1;     /**< \brief [0:0] ##suppress##Trigger request signal to update the register TOM[i]_TGC[g]_ENDIS_STAT, TOM[i]_TGC[g]_OUTEN_STAT##suppress## (rw1c) */
    __I  Ifx_Strict_32Bit :7;              /**< \brief [7:1] \internal Reserved */
    __IO Ifx_Strict_32Bit RST_CH0:1;       /**< \brief [8:8] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH1:1;       /**< \brief [9:9] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH2:1;       /**< \brief [10:10] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH3:1;       /**< \brief [11:11] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH4:1;       /**< \brief [12:12] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH5:1;       /**< \brief [13:13] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH6:1;       /**< \brief [14:14] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit RST_CH7:1;       /**< \brief [15:15] Software reset of channel [x]; x = c + g*8 (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL0:2;    /**< \brief [17:16] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL1:2;    /**< \brief [19:18] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL2:2;    /**< \brief [21:20] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL3:2;    /**< \brief [23:22] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL4:2;    /**< \brief [25:24] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL5:2;    /**< \brief [27:26] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL6:2;    /**< \brief [29:28] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
    __IO Ifx_Strict_32Bit UPEN_CTRL7:2;    /**< \brief [31:30] ##suppress##TOM[i] channel [x] ( x=c + g*8 ) enable update of register TOM[i]_CH[x]_CM0, TOM[i]_CH[x]_CM1, TOM[i]_CH[x]_CTRL.SL and TOM[i]_CH[x]_CTRL.CLK_SRC from TOM[i]_CH[x]_SR0, TOM[i]_CH[x]_SR1, TOM[i]_CH[x]_CTRL_SR.SL_SR and TOM[i]_CH[x]_CTRL_SR.CLK_SRC_SR.##suppress## (rw) */
} Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL_Bits;

/** \brief TOM[i] TGC [g] internal trigger control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_INT_TRIG_Bits
{
    __IO Ifx_Strict_32Bit INT_TRIG0:2;     /**< \brief [1:0] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG1:2;     /**< \brief [3:2] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG2:2;     /**< \brief [5:4] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG3:2;     /**< \brief [7:6] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG4:2;     /**< \brief [9:8] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG5:2;     /**< \brief [11:10] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG6:2;     /**< \brief [13:12] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __IO Ifx_Strict_32Bit INT_TRIG7:2;     /**< \brief [15:14] ##suppress##Select input signal TOM_CH_TRIGOUT[x:x] as a trigger source for TGC[g] (x=c + g*8)##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_INT_TRIG_Bits;

/** \brief TOM[i] TGC [g] output enable control register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_CTRL0:2;    /**< \brief [1:0] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL1:2;    /**< \brief [3:2] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL2:2;    /**< \brief [5:4] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL3:2;    /**< \brief [7:6] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL4:2;    /**< \brief [9:8] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL5:2;    /**< \brief [11:10] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL6:2;    /**< \brief [13:12] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __IO Ifx_Strict_32Bit OUTEN_CTRL7:2;    /**< \brief [15:14] ##suppress##Output enable control of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rw) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL_Bits;

/** \brief TOM[i] TGC [g] output enable status register */
typedef struct _Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT_Bits
{
    __IO Ifx_Strict_32Bit OUTEN_STAT0:2;    /**< \brief [1:0] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT1:2;    /**< \brief [3:2] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT2:2;    /**< \brief [5:4] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT3:2;    /**< \brief [7:6] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT4:2;    /**< \brief [9:8] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT5:2;    /**< \brief [11:10] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT6:2;    /**< \brief [13:12] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __IO Ifx_Strict_32Bit OUTEN_STAT7:2;    /**< \brief [15:14] ##suppress##Output enable status of TOM [i] channel [x] output TOM_OUT[x:x], x=c+g*8##suppress## (rwh) */
    __I  Ifx_Strict_32Bit :16;             /**< \brief [31:16] \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT_Bits;

/** \brief Dither ATOM 0 Channel 0 passing the DTMs */
typedef struct _Ifx_EGTM_DITH_ATCH_Bits
{
    __IO Ifx_UReg_32Bit DITACT:1;          /**< \brief [0:0] Dither Activation ATOM 0 Channel 0 (rw) */
    __IO Ifx_UReg_32Bit DM:2;              /**< \brief [2:1] Dither Mode Channel 0 (rwh) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [3:3] \internal Reserved */
    __IO Ifx_UReg_32Bit RDM:1;             /**< \brief [4:4] Rotate Dither Mode for Channel 0 (rw) */
    __IO Ifx_UReg_32Bit DITBIT:3;          /**< \brief [7:5] Amount of Dither Bits (rw) */
    __I  Ifx_UReg_32Bit ADITMAX:8;         /**< \brief [15:8] Actual Dither Maximum Value (rh) */
    __IO Ifx_UReg_32Bit DRC:8;             /**< \brief [23:16] Dither Reverse Counter (rw) */
    __I  Ifx_UReg_32Bit ADRC:8;            /**< \brief [31:24] Actual DRC value for channel 0 (rh) */
} Ifx_EGTM_DITH_ATCH_Bits;

/** \brief Cluster 0 DTMAUX input 0 selection register */
typedef struct _Ifx_EGTM_DTMAUX_IN_Bits
{
    __IO Ifx_UReg_32Bit SEL0:3;            /**< \brief [2:0] Input selection for CDTM0_DTM0_AUXINy (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [3:3] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL1:3;            /**< \brief [6:4] Input selection for CDTM0_DTM1_AUXINy (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [7:7] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL2:3;            /**< \brief [10:8] Input selection for CDTM0_DTM2_AUXINy (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [11:11] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:3;            /**< \brief [14:12] Input selection for CDTM0_DTM3_AUXINy (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [15:15] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL4:3;            /**< \brief [18:16] Input selection for CDTM0_DTM4_AUXINy (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [19:19] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL5:3;            /**< \brief [22:20] Input selection for CDTM0_DTM5_AUXINy (rw) */
    __I  Ifx_UReg_32Bit :9;                /**< \brief [31:23] \internal Reserved */
} Ifx_EGTM_DTMAUX_IN_Bits;

/** \brief eGTM to LCDCDC output trigger selection register */
typedef struct _Ifx_EGTM_LCDCDC_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:4;             /**< \brief [3:0] eGTM to LCDCDC trigger output selection (rw) */
    __I  Ifx_UReg_32Bit :28;               /**< \brief [31:4] \internal Reserved */
} Ifx_EGTM_LCDCDC_OUT_Bits;

/** \brief Selection of INHCON stream for MSC */
typedef struct _Ifx_EGTM_MSCSELIN_INHCON_Bits
{
    __IO Ifx_UReg_32Bit MMSC0:3;           /**< \brief [2:0] Select the INHCON source of the existing MSC0 (rw) */
    __I  Ifx_UReg_32Bit :29;               /**< \brief [31:3] \internal Reserved */
} Ifx_EGTM_MSCSELIN_INHCON_Bits;

/** \brief Selection of INHECON stream for MSC */
typedef struct _Ifx_EGTM_MSCSELIN_INHECON_Bits
{
    __IO Ifx_UReg_32Bit MMSC0:3;           /**< \brief [2:0] Select the INHECON source of the existing MSC0 (rw) */
    __I  Ifx_UReg_32Bit :29;               /**< \brief [31:3] \internal Reserved */
} Ifx_EGTM_MSCSELIN_INHECON_Bits;

/** \brief Selection of INLCON stream for MSC */
typedef struct _Ifx_EGTM_MSCSELIN_INLCON_Bits
{
    __IO Ifx_UReg_32Bit MMSC0:3;           /**< \brief [2:0] Select the INLCON source of the existing MSC0 (rw) */
    __I  Ifx_UReg_32Bit :29;               /**< \brief [31:3] \internal Reserved */
} Ifx_EGTM_MSCSELIN_INLCON_Bits;

/** \brief Selection of INLECON stream for MSC */
typedef struct _Ifx_EGTM_MSCSELIN_INLECON_Bits
{
    __IO Ifx_UReg_32Bit MMSC0:3;           /**< \brief [2:0] Select the INLECON source of the existing MSC0 (rw) */
    __I  Ifx_UReg_32Bit :29;               /**< \brief [31:3] \internal Reserved */
} Ifx_EGTM_MSCSELIN_INLECON_Bits;

/** \brief eGTM to MSC SET0 output selection register 0 */
typedef struct _Ifx_EGTM_MSCSET_CON0_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:5;            /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON0_Bits;

/** \brief eGTM to MSC SET0 output selection register 1 */
typedef struct _Ifx_EGTM_MSCSET_CON1_Bits
{
    __IO Ifx_UReg_32Bit SEL4:5;            /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL5:5;            /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL6:5;            /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL7:5;            /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON1_Bits;

/** \brief eGTM to MSC SET0 output selection register 2 */
typedef struct _Ifx_EGTM_MSCSET_CON2_Bits
{
    __IO Ifx_UReg_32Bit SEL8:5;            /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL9:5;            /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL10:5;           /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL11:5;           /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON2_Bits;

/** \brief eGTM to MSC SET0 output selection register 3 */
typedef struct _Ifx_EGTM_MSCSET_CON3_Bits
{
    __IO Ifx_UReg_32Bit SEL12:5;           /**< \brief [4:0] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL13:5;           /**< \brief [12:8] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL14:5;           /**< \brief [20:16] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL15:5;           /**< \brief [28:24] SET0.x signal output selection (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_MSCSET_CON3_Bits;

/** \brief eGTM to input bus MSC0_INHCON signal selection register */
typedef struct _Ifx_EGTM_MSC_INHCON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] 0th bus line INHCON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] 0th bus line INHCON.x SETi signal selection (rw) */
} Ifx_EGTM_MSC_INHCON_Bits;

/** \brief eGTM to input bus MSC0_INHECON signal selection register */
typedef struct _Ifx_EGTM_MSC_INHECON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] 0th bus line INHECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] 0th bus line INHECON.x SETi signal selection (rw) */
} Ifx_EGTM_MSC_INHECON_Bits;

/** \brief eGTM to input bus MSC0_INLCON signal selection register */
typedef struct _Ifx_EGTM_MSC_INLCON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] 0th bus line INLCONx SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] 0th bus line INLCONx SETi signal selection (rw) */
} Ifx_EGTM_MSC_INLCON_Bits;

/** \brief eGTM to input bus MSC0_INLECON signal selection register */
typedef struct _Ifx_EGTM_MSC_INLECON_Bits
{
    __IO Ifx_UReg_32Bit SEL0:2;            /**< \brief [1:0] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:2;            /**< \brief [3:2] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:2;            /**< \brief [5:4] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:2;            /**< \brief [7:6] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:2;            /**< \brief [9:8] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:2;            /**< \brief [11:10] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:2;            /**< \brief [13:12] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:2;            /**< \brief [15:14] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL8:2;            /**< \brief [17:16] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL9:2;            /**< \brief [19:18] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL10:2;           /**< \brief [21:20] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL11:2;           /**< \brief [23:22] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL12:2;           /**< \brief [25:24] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL13:2;           /**< \brief [27:26] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL14:2;           /**< \brief [29:28] 0th bus line INLECON.x SETi signal selection (rw) */
    __IO Ifx_UReg_32Bit SEL15:2;           /**< \brief [31:30] 0th bus line INLECON.x SETi signal selection (rw) */
} Ifx_EGTM_MSC_INLECON_Bits;

/** \brief OCDS TBU0 trigger register */
typedef struct _Ifx_EGTM_OCDS_OTBU0T_Bits
{
    __IO Ifx_UReg_32Bit CV:27;             /**< \brief [26:0] Compare value (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [27:27] \internal Reserved */
    __IO Ifx_UReg_32Bit CM:2;              /**< \brief [29:28] Compare mode (rw) */
    __I  Ifx_UReg_32Bit :2;                /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_OCDS_OTBU0T_Bits;

/** \brief OCDS TBU1 trigger register */
typedef struct _Ifx_EGTM_OCDS_OTBU1T_Bits
{
    __IO Ifx_UReg_32Bit CV:24;             /**< \brief [23:0] Compare value (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [27:24] \internal Reserved */
    __IO Ifx_UReg_32Bit EN:1;              /**< \brief [28:28] Enable (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_OCDS_OTBU1T_Bits;

/** \brief OCDS TBU2 trigger register */
typedef struct _Ifx_EGTM_OCDS_OTBU2T_Bits
{
    __IO Ifx_UReg_32Bit CV:24;             /**< \brief [23:0] Compare value (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [27:24] \internal Reserved */
    __IO Ifx_UReg_32Bit EN:1;              /**< \brief [28:28] Enable (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_OCDS_OTBU2T_Bits;

/** \brief OCDS trigger set control 0 register */
typedef struct _Ifx_EGTM_OCDS_OTSC0_Bits
{
    __IO Ifx_UReg_32Bit B0LMT:3;           /**< \brief [2:0] OTGB0 TS16_IOS low-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [3:3] \internal Reserved */
    __IO Ifx_UReg_32Bit B0LMI:4;           /**< \brief [7:4] OTGB0 TS16_IOS low-byte module instance (rw) */
    __IO Ifx_UReg_32Bit B0HMT:3;           /**< \brief [10:8] OTGB0 TS16_IOS high-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [11:11] \internal Reserved */
    __IO Ifx_UReg_32Bit B0HMI:4;           /**< \brief [15:12] OTGB0 TS16_IOS high-byte module instance (rw) */
    __IO Ifx_UReg_32Bit B1LMT:3;           /**< \brief [18:16] OTGB1 TS16_IOS low-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [19:19] \internal Reserved */
    __IO Ifx_UReg_32Bit B1LMI:4;           /**< \brief [23:20] OTGB1 TS16_IOS low-byte module instance (rw) */
    __IO Ifx_UReg_32Bit B1HMT:3;           /**< \brief [26:24] OTGB1 TS16_IOS high-byte module type (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [27:27] \internal Reserved */
    __IO Ifx_UReg_32Bit B1HMI:4;           /**< \brief [31:28] OTGB1 TS16_IOS high-byte module instance (rw) */
} Ifx_EGTM_OCDS_OTSC0_Bits;

/** \brief OCDS trigger set select register */
typedef struct _Ifx_EGTM_OCDS_OTSS_Bits
{
    __IO Ifx_UReg_32Bit OTGB0:4;           /**< \brief [3:0] Trigger set for OTGB0 (rw) */
    __I  Ifx_UReg_32Bit :4;                /**< \brief [7:4] \internal Reserved */
    __IO Ifx_UReg_32Bit OTGB1:4;           /**< \brief [11:8] Trigger set for OTGB1 (rw) */
    __I  Ifx_UReg_32Bit :20;               /**< \brief [31:12] \internal Reserved */
} Ifx_EGTM_OCDS_OTSS_Bits;

/** \brief OCDS control and status register */
typedef struct _Ifx_EGTM_OCS_Bits
{
    __I  Ifx_UReg_32Bit :24;               /**< \brief [23:0] \internal Reserved */
    __IO Ifx_UReg_32Bit SUS:4;             /**< \brief [27:24] OCDS suspend control (rw) */
    __O  Ifx_UReg_32Bit SUS_P:1;           /**< \brief [28:28] SUS write protection (w) */
    __I  Ifx_UReg_32Bit SUSSTA:1;          /**< \brief [29:29] Suspend state (rh) */
    __I  Ifx_UReg_32Bit :2;                /**< \brief [31:30] \internal Reserved */
} Ifx_EGTM_OCS_Bits;

/** \brief Resource Protection Register */
typedef struct _Ifx_EGTM_PROT_Bits
{
    __IO Ifx_UReg_32Bit STATE:3;           /**< \brief [2:0] Resource protection state (rwh) */
    __O  Ifx_UReg_32Bit SWEN:1;            /**< \brief [3:3] State write enable (w) */
    __I  Ifx_UReg_32Bit :12;               /**< \brief [15:4] \internal Reserved */
    __IO Ifx_UReg_32Bit VM:3;              /**< \brief [18:16] Virtual Machine definition for PROT owner (rw) */
    __IO Ifx_UReg_32Bit VMEN:1;            /**< \brief [19:19] Virtual Machine definition Enable for PROT owner (rw) */
    __IO Ifx_UReg_32Bit PRS:3;             /**< \brief [22:20] Protection Set definition for PROT owner (rw) */
    __IO Ifx_UReg_32Bit PRSEN:1;           /**< \brief [23:23] Protection Set definition Enable for PROT owner (rw) */
    __IO Ifx_UReg_32Bit TAGID:6;           /**< \brief [29:24] TAG ID definition for PROT owner (rw) */
    __IO Ifx_UReg_32Bit ODEF:1;            /**< \brief [30:30] Enable for PROT owner definition (rw) */
    __O  Ifx_UReg_32Bit OWEN:1;            /**< \brief [31:31] Owner write enable (w) */
} Ifx_EGTM_PROT_Bits;

/** \brief eGTM to PSI5-S0 output trigger selection register */
typedef struct _Ifx_EGTM_PSI5S_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL0:4;            /**< \brief [3:0] eGTM to PSI5-Sn trigger 0 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:4;            /**< \brief [7:4] eGTM to PSI5-Sn trigger 1 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:4;            /**< \brief [11:8] eGTM to PSI5-Sn trigger 2 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:4;            /**< \brief [15:12] eGTM to PSI5-Sn trigger 3 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:4;            /**< \brief [19:16] eGTM to PSI5-Sn trigger 4 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:4;            /**< \brief [23:20] eGTM to PSI5-Sn trigger 5 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL6:4;            /**< \brief [27:24] eGTM to PSI5-Sn trigger 6 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL7:4;            /**< \brief [31:28] eGTM to PSI5-Sn trigger 7 output selection (rw) */
} Ifx_EGTM_PSI5S_OUT_Bits;

/** \brief eGTM to PSI5 output trigger selection register */
typedef struct _Ifx_EGTM_PSI5_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL0:4;            /**< \brief [3:0] eGTM to PSI5 trigger 0 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:4;            /**< \brief [7:4] eGTM to PSI5 trigger 1 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:4;            /**< \brief [11:8] eGTM to PSI5 trigger 2 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL3:4;            /**< \brief [15:12] eGTM to PSI5 trigger 3 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:4;            /**< \brief [19:16] eGTM to PSI5 trigger 4 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:4;            /**< \brief [23:20] eGTM to PSI5 trigger 5 output selection (rw) */
    __I  Ifx_UReg_32Bit :8;                /**< \brief [31:24] \internal Reserved */
} Ifx_EGTM_PSI5_OUT_Bits;

/** \brief eGTM to QSPI0 output selection register. 0<8 then interface exists. */
typedef struct _Ifx_EGTM_QSPI_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL:5;             /**< \brief [4:0] eGTM to QSPI0 trigger output selection (rw) */
    __I  Ifx_UReg_32Bit :27;               /**< \brief [31:5] \internal Reserved */
} Ifx_EGTM_QSPI_OUT_Bits;

/** \brief Reset control register A */
typedef struct _Ifx_EGTM_RST_CTRLA_Bits
{
    __IO Ifx_UReg_32Bit KRST:1;            /**< \brief [0:0] Kernel Reset - KRST (rw1sh) */
    __I  Ifx_UReg_32Bit :7;                /**< \brief [7:1] \internal Reserved */
    __IO Ifx_UReg_32Bit GRSTEN0:1;         /**< \brief [8:8] Enable for Global Module Reset Group 0 - GRSTEN0 (rw) */
    __IO Ifx_UReg_32Bit GRSTEN1:1;         /**< \brief [9:9] Enable for Global Module Reset Group 1 - GRSTEN1 (rw) */
    __IO Ifx_UReg_32Bit GRSTEN2:1;         /**< \brief [10:10] Enable for Global Module Reset Group 2 - GRSTEN2 (rw) */
    __IO Ifx_UReg_32Bit GRSTEN3:1;         /**< \brief [11:11] Enable for Global Module Reset Group 3 - GRSTEN3 (rw) */
    __I  Ifx_UReg_32Bit :20;               /**< \brief [31:12] \internal Reserved */
} Ifx_EGTM_RST_CTRLA_Bits;

/** \brief Reset control register B */
typedef struct _Ifx_EGTM_RST_CTRLB_Bits
{
    __IO Ifx_UReg_32Bit KRST:1;            /**< \brief [0:0] Kernel Reset - KRST (rw1sh) */
    __I  Ifx_UReg_32Bit :30;               /**< \brief [30:1] \internal Reserved */
    __O  Ifx_UReg_32Bit STATCLR:1;         /**< \brief [31:31] Kernel Reset Status Clear - STATCLR (w) */
} Ifx_EGTM_RST_CTRLB_Bits;

/** \brief Reset status register */
typedef struct _Ifx_EGTM_RST_STAT_Bits
{
    __I  Ifx_UReg_32Bit KRST:1;            /**< \brief [0:0] Kernel Reset Status - KRST (rh) */
    __I  Ifx_UReg_32Bit :7;                /**< \brief [7:1] \internal Reserved */
    __I  Ifx_UReg_32Bit GRST0:1;           /**< \brief [8:8] Status for Global Module Reset Group 0 - GRST0 (rh) */
    __I  Ifx_UReg_32Bit GRST1:1;           /**< \brief [9:9] Status for Global Module Reset Group 1 - GRST1 (rh) */
    __I  Ifx_UReg_32Bit GRST2:1;           /**< \brief [10:10] Status for Global Module Reset Group 2 - GRST2 (rh) */
    __I  Ifx_UReg_32Bit GRST3:1;           /**< \brief [11:11] Status for Global Module Reset Group 3 - GRST3 (rh) */
    __I  Ifx_UReg_32Bit :20;               /**< \brief [31:12] \internal Reserved */
} Ifx_EGTM_RST_STAT_Bits;

/** \brief eGTM to SCU output selection register 0 eGTM_SCU_TRIG(0) */
typedef struct _Ifx_EGTM_SCU_OUT_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] eGTM to SCU trigger 0 output selection  eGTM_SCU_TRIG(0) (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [7:5] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [12:8] eGTM to SCU trigger 1 output selection  eGTM_SCU_TRIG(1) (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [15:13] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [20:16] eGTM to SCU trigger 2 output selection  eGTM_SCU_TRIG(2) (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [23:21] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:5;            /**< \brief [28:24] eGTM to SCU trigger 3 output selection  eGTM_SCU_TRIG(3) (rw) */
    __I  Ifx_UReg_32Bit :3;                /**< \brief [31:29] \internal Reserved */
} Ifx_EGTM_SCU_OUT_Bits;

/** \brief eGTM to SENT0 trigger x output selection register A */
typedef struct _Ifx_EGTM_SENT_OUTA_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] eGTM to SENTn trigger 0 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [9:5] eGTM to SENTn trigger 1 output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [14:10] eGTM to SENTn trigger 2 output selection (rw) */
    __I  Ifx_UReg_32Bit :17;               /**< \brief [31:15] \internal Reserved */
} Ifx_EGTM_SENT_OUTA_Bits;

/** \brief Spare Bits */
typedef struct _Ifx_EGTM_SPARE_Bits
{
    __IO Ifx_UReg_32Bit SPABA:4;           /**< \brief [3:0] Spare Bits A - For future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABB:4;           /**< \brief [7:4] Spare Bits B - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABC:4;           /**< \brief [11:8] Spare Bits C - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABD:4;           /**< \brief [15:12] Spare Bits D - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABE:4;           /**< \brief [19:16] Spare Bits E - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABF:4;           /**< \brief [23:20] Spare Bits F - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABG:4;           /**< \brief [27:24] Spare Bits G - for future extensions (rwh) */
    __IO Ifx_UReg_32Bit SPABH:4;           /**< \brief [31:28] Spare Bits H - for future extensions (rwh) */
} Ifx_EGTM_SPARE_Bits;

/** \brief TIM0 input selection register */
typedef struct _Ifx_EGTM_TIMINSEL_Bits
{
    __IO Ifx_UReg_32Bit CH0SEL:4;          /**< \brief [3:0] eGTM TIM0 channel 0 input selection (rw) */
    __IO Ifx_UReg_32Bit CH1SEL:4;          /**< \brief [7:4] eGTM TIM0 channel 1 input selection (rw) */
    __IO Ifx_UReg_32Bit CH2SEL:4;          /**< \brief [11:8] eGTM TIM0 channel 2 input selection (rw) */
    __IO Ifx_UReg_32Bit CH3SEL:4;          /**< \brief [15:12] eGTM TIM0 channel 3 input selection (rw) */
    __IO Ifx_UReg_32Bit CH4SEL:4;          /**< \brief [19:16] eGTM TIM0 channel 4 input selection (rw) */
    __IO Ifx_UReg_32Bit CH5SEL:4;          /**< \brief [23:20] eGTM TIM0 channel 5 input selection (rw) */
    __IO Ifx_UReg_32Bit CH6SEL:4;          /**< \brief [27:24] eGTM TIM0 channel 6 input selection (rw) */
    __IO Ifx_UReg_32Bit CH7SEL:4;          /**< \brief [31:28] eGTM TIM0 channel 7 input selection (rw) */
} Ifx_EGTM_TIMINSEL_Bits;

/** \brief TIM0 input selection register group B */
typedef struct _Ifx_EGTM_TIMINSELB_Bits
{
    __IO Ifx_UReg_32Bit CH0SEL:4;          /**< \brief [3:0] eGTM TIM0 channel 0 input selection group B (rw) */
    __IO Ifx_UReg_32Bit CH1SEL:4;          /**< \brief [7:4] eGTM TIM0 channel 1 input selection group B (rw) */
    __IO Ifx_UReg_32Bit CH2SEL:4;          /**< \brief [11:8] eGTM TIM0 channel 2 input selection group B (rw) */
    __IO Ifx_UReg_32Bit CH3SEL:4;          /**< \brief [15:12] eGTM TIM0 channel 3 input selection group B (rw) */
    __IO Ifx_UReg_32Bit CH4SEL:4;          /**< \brief [19:16] eGTM TIM0 channel 4 input selection group B (rw) */
    __IO Ifx_UReg_32Bit CH5SEL:4;          /**< \brief [23:20] eGTM TIM0 channel 5 input selection group B (rw) */
    __IO Ifx_UReg_32Bit CH6SEL:4;          /**< \brief [27:24] eGTM TIM0 channel 6 input selection group B (rw) */
    __IO Ifx_UReg_32Bit CH7SEL:4;          /**< \brief [31:28] eGTM TIM0 channel 7 input selection group B (rw) */
} Ifx_EGTM_TIMINSELB_Bits;

/** \brief Instance Selection for TIM[0] channel[0] */
typedef struct _Ifx_EGTM_TIMS_CH_ADCSEL_Bits
{
    __I  Ifx_UReg_32Bit RES0:32;           /**< \brief [31:0] Reserved, must be written with 0, shall read 0. (r) */
} Ifx_EGTM_TIMS_CH_ADCSEL_Bits;

/** \brief eGTM to Ports signal TOUT output selection register 0 */
typedef struct _Ifx_EGTM_TOUTSEL_Bits
{
    __IO Ifx_UReg_32Bit SEL0:5;            /**< \brief [4:0] eGTM to Ports signal TOUT(0*6+0) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL1:5;            /**< \brief [9:5] eGTM to Ports signal TOUT(0*6+1) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL2:5;            /**< \brief [14:10] eGTM to Ports signal TOUT(0*6+2) output selection (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [15:15] \internal Reserved */
    __IO Ifx_UReg_32Bit SEL3:5;            /**< \brief [20:16] eGTM to Ports signal TOUT(0*6+3) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL4:5;            /**< \brief [25:21] eGTM to Ports signal TOUT(0*6+4) output selection (rw) */
    __IO Ifx_UReg_32Bit SEL5:5;            /**< \brief [30:26] eGTM to Ports signal TOUT(0*6+5) output selection (rw) */
    __I  Ifx_UReg_32Bit :1;                /**< \brief [31:31] \internal Reserved */
} Ifx_EGTM_TOUTSEL_Bits;

/** \}  */
/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_egtm_Registers_union
 * \{   */
/** \brief PRS access enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_PRS_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_PRS;

/** \brief Read access enable register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_RDA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_RDA;

/** \brief Read access enable register B   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_RDB_FPI_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_RDB_FPI;

/** \brief VM access enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_VM_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_VM;

/** \brief Write access enable register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_WRA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_WRA;

/** \brief Write access enable register B   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ACCEN_WRB_FPI_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_ACCEN_WRB_FPI;

/** \brief eGTM to ADC output selection register 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ADC_OUT_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_ADC_OUT;

/** \brief eGTM to ASCLIN0 output selection register. 0<28 then interface exists.   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_ASCLIN_OUT_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_ASCLIN_OUT;

/** \brief eGTM to CAN0 output selection register 0. 0*4+ 0<24 then interface exists.   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CAN_OUT_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_CAN_OUT;

/** \brief Clock control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLC_Bits B;                   /**< \brief Bitfield access */
} Ifx_EGTM_CLC;

/** \brief eGTM AEI bridge mode register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_AEI_BRIDGE_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_AEI_BRIDGE_MODE;

/** \brief eGTM AEI bridge pointer 1 register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_AEI_BRIDGE_PTR1_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR1;

/** \brief eGTM AEI bridge pointer 2 register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_AEI_BRIDGE_PTR2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_AEI_BRIDGE_PTR2;

/** \brief eGTM AEI timeout exception address register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT;

/** \brief eGTM AEI non-zero status register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_AEI_STA_XPT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_AEI_STA_XPT;

/** \brief eGTM configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_CFG_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_CFG;

/** \brief eGTM Cluster Clock Configuration   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_CLK_CFG_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_CLK_CFG;

/** \brief eGTM global control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_CTRL_Bits B;         /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_CTRL;

/** \brief eGTM error interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_EIRQ_EN_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_EIRQ_EN;

/** \brief eGTM interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_EN_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_EN;

/** \brief eGTM Software interrupt generation register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_FORCINT;

/** \brief eGTM toplevel interrupts mode selection   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_MODE_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_MODE;

/** \brief eGTM Interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY;

/** \brief eGTM version control register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_REV_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_REV;

/** \brief eGTM global reset register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ARCH_RST_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ARCH_RST;

/** \brief ATOM[i] AGC action time base register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_ACT_TB_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_ACT_TB;

/** \brief ATOM[i] AGC enable/disable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL;

/** \brief ATOM[i] AGC enable/disable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT;

/** \brief ATOM[i] AGC force update control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL;

/** \brief ATOM[i] AGC global control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL;

/** \brief ATOM[i] AGC internal trigger control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG;

/** \brief ATOM[i] AGC output enable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL;

/** \brief ATOM[i] AGC output enable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT;

/** \brief ATOM[i] channel [x] CCU0 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CM0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CM0;

/** \brief ATOM[i] channel [x] CCU1 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CM1_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CM1;

/** \brief ATOM[i] channel [x] CCU0 counter register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CN0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CN0;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL;

/** \brief ATOM[i] channel [x] control2 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL2_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL2;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP;

/** \brief ATOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS;

/** \brief ATOM[i] channel [x] control shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_CTRL_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_CTRL_SR;

/** \brief ATOM[i] channel [x] interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_EN_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_EN;

/** \brief ATOM[i] channel [x] software interrupt generation   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT;

/** \brief ATOM[i] channel [x] interrupt mode configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE;

/** \brief ATOM[i] channel [x] interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY;

/** \brief ATOM[i] channel [x] CCU0 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_SR0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_SR0;

/** \brief ATOM[i] channel [x] CCU1 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_SR1_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_SR1;

/** \brief ATOM[i] channel [x] status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ATOM_CH_STAT_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ATOM_CH_STAT;

/** \brief CCM[i] ATOM Output Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_ATOM_OUT_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_ATOM_OUT;

/** \brief CCM[i] Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_CFG_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_CFG;

/** \brief CCM[i] CMU Clock Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_CMU_CLK_CFG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_CMU_CLK_CFG;

/** \brief CCM[i] CMU Fixed Clock Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG;

/** \brief CCM[i] Hardware Configuration Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_HW_CONF_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_HW_CONF;

/** \brief CCM[i] 2. Hardware Configuration Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
} Ifx_EGTM_CLS_CCM_HW_CONF2;

/** \brief CCM[i] Protection Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_PROT_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_PROT;

/** \brief CCM[i] TIM AUX Input Source Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC;

/** \brief CCM[i] TOM Output Register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CCM_TOM_OUT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CCM_TOM_OUT;

/** \brief CDTM[i]_DTM[d] channel control register 1   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1;

/** \brief CDTM[i]_DTM[d] channel control register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2;

/** \brief CDTM[i] DTM[d] channel control register 2 shadow   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR;

/** \brief CDTM[i]_DTM[d] channel control register 3   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3;

/** \brief CDTM[i]_DTM[d] channel [x] dead-time reload values   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV;

/** \brief CDTM[i]_DTM[d] channel [x] dead-time shadow values   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR;

/** \brief CDTM[i]_DTM[d] channel shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CH_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CH_SR;

/** \brief CDTM[i]_DTM[d] global configuration and control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CTRL_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL;

/** \brief CDTM[i]_DTM[d] global configuration and control register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_CTRL2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_CTRL2;

/** \brief CDTM[i]_DTM[d] phase shift unit configuration and control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL;

/** \brief CMP error interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_EIRQ_EN_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_EIRQ_EN;

/** \brief CMP comparator enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_EN_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_EN;

/** \brief CMP interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_EN_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_EN;

/** \brief CMP interrupt force register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_FORCINT;

/** \brief CMP interrupt mode configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_MODE_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_MODE;

/** \brief CMP event notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMP_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMP_IRQ_NOTIFY;

/** \brief CMU control for clock resolution generator [x]   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLKX_CTRL_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLKX_CTRL;

/** \brief CMU control for clock resolution generator 6   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_6_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_6_CTRL;

/** \brief CMU control for clock resolution generator 7   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_7_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_7_CTRL;

/** \brief CMU control for clock resolution generator   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_CTRL;

/** \brief CMU clock enable   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_CLK_EN_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_CLK_EN;

/** \brief The denominator for the external clock resolution generator [z]   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_ECLK_DEN_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_ECLK_DEN;

/** \brief The numerator for the external clock resolution generator [z]   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_ECLK_NUM_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_ECLK_NUM;

/** \brief CMU control for selection of FCR subblock input   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_FXCLK_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_FXCLK_CTRL;

/** \brief The denominator for CMU global clock resolution generator   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_GCLK_DEN_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_GCLK_DEN;

/** \brief The numerator for CMU global clock resolution generator   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_CMU_GCLK_NUM_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_CMU_GCLK_NUM;

/** \brief ICM_IRQG_0   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_0;

/** \brief ICM Interrupt group register covering TIM0, TIM1, TIM2, TIM3   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_2_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_2;

/** \brief ICM_IRQG_ATOM_[g]_CI   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI;

/** \brief ICM Interrupt group register 1 for channel error interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_CEI1_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_CEI1;

/** \brief ICM_IRQG_CLS_[g]_MEI   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI;

/** \brief ICM Interrupt group register for module error interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_MEI_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_MEI;

/** \brief ICM Interrupt group SPE for module Error Interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI;

/** \brief ICM Interrupt group SPE for module Interrupt information   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_SPE_CI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_SPE_CI;

/** \brief ICM_IRQG_TOM_[g]_CI   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_ICM_IRQG_TOM_CI_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_ICM_IRQG_TOM_CI;

/** \brief MON status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_MON_STATUS_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_MON_STATUS;

/** \brief SPE[i] Command Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_CMD_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_CMD;

/** \brief SPE[i] Control Status Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_CTRL_STAT_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_CTRL_STAT;

/** \brief SPE[i] Control Status Register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_CTRL_STAT2_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_CTRL_STAT2;

/** \brief SPE[i] Error Interrupt Enable Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_EIRQ_EN_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_EIRQ_EN;

/** \brief SPE[i] Interrupt Enable Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_EN_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_EN;

/** \brief SPE[i] Interrupt Generation By Software   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_FORCINT;

/** \brief SPE[i] Interrupt Mode Configuration Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_MODE_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_MODE;

/** \brief SPE[i] Interrupt Notification Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_IRQ_NOTIFY;

/** \brief SPE[i] Output Control Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_OUT_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_OUT_CTRL;

/** \brief SPE[i] Output Definition Register [p]   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_OUT_PAT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_OUT_PAT;

/** \brief SPE[i] Input Pattern Definition Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_PAT_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_PAT;

/** \brief SPE[i] Revolution Counter Compare Value   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_REV_CMP_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_REV_CMP;

/** \brief SPE[i] Input Revolution Counter   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_SPE_REV_CNT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_SPE_REV_CNT;

/** \brief TBU channel 0 base   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH0_BASE_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH0_BASE;

/** \brief TBU channel 0 control   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH0_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH0_CTRL;

/** \brief TBU channel 1 control   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH1_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH1_CTRL;

/** \brief TBU channel 2 control   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH2_CTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH2_CTRL;

/** \brief TBU global channel enable   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CHEN_Bits B;          /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CHEN;

/** \brief TBU channel [x] base   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TBU_CH_BASE_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TBU_CH_BASE;

/** \brief TIM[i] channel [x] SMU counter register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_CNT_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_CNT;

/** \brief TIM[i] channel [x] SMU shadow counter register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_CNTS_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_CNTS;

/** \brief TIM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_CTRL_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_CTRL;

/** \brief TIM[i] channel [x] SMU edge counter register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_ECNT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_ECNT;

/** \brief TIM[i] channel [x] extended control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_ECTRL_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_ECTRL;

/** \brief TIM[i] channel [x] error interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_EIRQ_EN_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_EIRQ_EN;

/** \brief TIM[i] channel [x] filter parameter 1 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_FLT_FE_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_FLT_FE;

/** \brief TIM[i] channel [x] filter parameter 0 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_FLT_RE_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_FLT_RE;

/** \brief TIM[i] channel [x] general-purpose 0 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_GPR0_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_GPR0;

/** \brief TIM[i] channel [x] general-purpose 1 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_GPR1_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_GPR1;

/** \brief TIM[i] channel [x] interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_EN_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_EN;

/** \brief TIM[i] channel [x] force interrupt register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT;

/** \brief TIM[i] channel [x] interrupt mode configuration register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_MODE;

/** \brief TIM[i] channel [x] interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY;

/** \brief TIM[i]_CH[x]_TDUC   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_TDUC_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_TDUC;

/** \brief TIM[i]_CH[x]_TDUV   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_CH_TDUV_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_CH_TDUV;

/** \brief TIM[i] input value observation register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_INP_VAL_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_INP_VAL;

/** \brief TIM[i] AUX IN source selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_IN_SRC_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_IN_SRC;

/** \brief TIM[i] global software reset register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TIM_RST_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TIM_RST;

/** \brief TOM[i] channel [x] CCU0 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CM0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CM0;

/** \brief TOM[i] channel [x] CCU1 compare register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CM1_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CM1;

/** \brief TOM[i] channel [x] CCU0 counter   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CN0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CN0;

/** \brief TOM[i] channel [x] control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CTRL_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CTRL;

/** \brief TOM[i] channel [x] control shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_CTRL_SR_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_CTRL_SR;

/** \brief TOM[i] channel [x] interrupt enable register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_EN_Bits B;     /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_EN;

/** \brief TOM[i] channel [x] force interrupt register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT;

/** \brief TOM[i] channel [x] interrupt mode register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_MODE_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_MODE;

/** \brief TOM[i] channel [x] interrupt notification register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY;

/** \brief TOM[i] channel [x] CCU0 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_SR0_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_SR0;

/** \brief TOM[i] channel [x] CCU1 compare shadow register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_SR1_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_SR1;

/** \brief TOM[i] channel [x] status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_CH_STAT_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_CH_STAT;

/** \brief TOM[i] TGC [g] action time base register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_ACT_TB_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_ACT_TB;

/** \brief TOM[i] TGC [g] enable/disable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL;

/** \brief TOM[i] TGC [g] enable/disable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT;

/** \brief TOM[i] TGC [g] force update control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL;

/** \brief TOM[i] TGC [g] global control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL;

/** \brief TOM[i] TGC [g] internal trigger control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_INT_TRIG_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_INT_TRIG;

/** \brief TOM[i] TGC [g] output enable control register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL;

/** \brief TOM[i] TGC [g] output enable status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT_Bits B;    /**< \brief Bitfield access */
} Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT;

/** \brief Dither ATOM 0 Channel 0 passing the DTMs   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_DITH_ATCH_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_DITH_ATCH;

/** \brief Cluster 0 DTMAUX input 0 selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_DTMAUX_IN_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_DTMAUX_IN;

/** \brief FOUT Selection for Encoder Interface 0   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
} Ifx_EGTM_FOUTENC;

/** \brief eGTM to LCDCDC output trigger selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_LCDCDC_OUT_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_LCDCDC_OUT;

/** \brief Selection of INHCON stream for MSC   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSELIN_INHCON_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_MSCSELIN_INHCON;

/** \brief Selection of INHECON stream for MSC   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSELIN_INHECON_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_MSCSELIN_INHECON;

/** \brief Selection of INLCON stream for MSC   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSELIN_INLCON_Bits B;       /**< \brief Bitfield access */
} Ifx_EGTM_MSCSELIN_INLCON;

/** \brief Selection of INLECON stream for MSC   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSELIN_INLECON_Bits B;      /**< \brief Bitfield access */
} Ifx_EGTM_MSCSELIN_INLECON;

/** \brief eGTM to MSC SET0 output selection register 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON0_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON0;

/** \brief eGTM to MSC SET0 output selection register 1   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON1_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON1;

/** \brief eGTM to MSC SET0 output selection register 2   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON2_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON2;

/** \brief eGTM to MSC SET0 output selection register 3   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSCSET_CON3_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSCSET_CON3;

/** \brief eGTM to input bus MSC0_INHCON signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INHCON_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INHCON;

/** \brief eGTM to input bus MSC0_INHECON signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INHECON_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INHECON;

/** \brief eGTM to input bus MSC0_INLCON signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INLCON_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INLCON;

/** \brief eGTM to input bus MSC0_INLECON signal selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_MSC_INLECON_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_MSC_INLECON;

/** \brief OCDS TBU0 trigger register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTBU0T_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTBU0T;

/** \brief OCDS TBU1 trigger register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTBU1T_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTBU1T;

/** \brief OCDS TBU2 trigger register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTBU2T_Bits B;           /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTBU2T;

/** \brief OCDS trigger set control 0 register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTSC0_Bits B;            /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTSC0;

/** \brief OCDS trigger set select register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCDS_OTSS_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_OCDS_OTSS;

/** \brief OCDS control and status register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_OCS_Bits B;                   /**< \brief Bitfield access */
} Ifx_EGTM_OCS;

/** \brief Resource Protection Register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_PROT_Bits B;                  /**< \brief Bitfield access */
} Ifx_EGTM_PROT;

/** \brief eGTM to PSI5-S0 output trigger selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_PSI5S_OUT_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_PSI5S_OUT;

/** \brief eGTM to PSI5 output trigger selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_PSI5_OUT_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_PSI5_OUT;

/** \brief eGTM to QSPI0 output selection register. 0<8 then interface exists.   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_QSPI_OUT_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_QSPI_OUT;

/** \brief Reset control register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_RST_CTRLA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_RST_CTRLA;

/** \brief Reset control register B   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_RST_CTRLB_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_RST_CTRLB;

/** \brief Reset status register   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_RST_STAT_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_RST_STAT;

/** \brief eGTM to SCU output selection register 0 eGTM_SCU_TRIG(0)   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_SCU_OUT_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_SCU_OUT;

/** \brief eGTM to SENT0 trigger x output selection register A   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_SENT_OUTA_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_SENT_OUTA;

/** \brief Spare Bits   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_SPARE_Bits B;                 /**< \brief Bitfield access */
} Ifx_EGTM_SPARE;

/** \brief TIM0 input selection register   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_TIMINSEL_Bits B;              /**< \brief Bitfield access */
} Ifx_EGTM_TIMINSEL;

/** \brief TIM0 input selection register group B   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_TIMINSELB_Bits B;             /**< \brief Bitfield access */
} Ifx_EGTM_TIMINSELB;

/** \brief Instance Selection for TIM[0] channel[0]   */
typedef union
{
    __I  Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __I  Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_TIMS_CH_ADCSEL_Bits B;        /**< \brief Bitfield access */
} Ifx_EGTM_TIMS_CH_ADCSEL;

/** \brief eGTM to Ports signal TOUT output selection register 0   */
typedef union
{
    __IO Ifx_UReg_32Bit U;                 /**< \brief Unsigned access */
    __IO Ifx_SReg_32Bit I;                 /**< \brief Signed access */
    Ifx_EGTM_TOUTSEL_Bits B;               /**< \brief Bitfield access */
} Ifx_EGTM_TOUTSEL;

/** \}  */

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ARCH_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ARCH object */
typedef volatile struct _Ifx_EGTM_CLS_ARCH
{
       __I  Ifx_EGTM_CLS_ARCH_REV               REV;                    /**< \brief 0, eGTM version control register*/
       __IO Ifx_EGTM_CLS_ARCH_RST               RST;                    /**< \brief 4, eGTM global reset register*/
       __IO Ifx_EGTM_CLS_ARCH_CTRL              CTRL;                   /**< \brief 8, eGTM global control register*/
       __IO Ifx_EGTM_CLS_ARCH_CFG               CFG;                    /**< \brief C, eGTM configuration register*/
       __I  Ifx_EGTM_CLS_ARCH_AEI_ADDR_XPT      AEI_ADDR_XPT;           /**< \brief 10, eGTM AEI timeout exception address register*/
       __I  Ifx_EGTM_CLS_ARCH_AEI_STA_XPT       AEI_STA_XPT;            /**< \brief 14, eGTM AEI non-zero status register*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_NOTIFY        IRQ_NOTIFY;             /**< \brief 18, eGTM Interrupt notification register*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_EN            IRQ_EN;                 /**< \brief 1C, eGTM interrupt enable register*/
       __IO Ifx_EGTM_CLS_ARCH_EIRQ_EN           EIRQ_EN;                /**< \brief 20, eGTM error interrupt enable register*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_FORCINT       IRQ_FORCINT;            /**< \brief 24, eGTM Software interrupt generation register*/
       __IO Ifx_EGTM_CLS_ARCH_IRQ_MODE          IRQ_MODE;               /**< \brief 28, eGTM toplevel interrupts mode selection*/
       __IO Ifx_EGTM_CLS_ARCH_CLK_CFG           CLK_CFG;                /**< \brief 2C, eGTM Cluster Clock Configuration*/
       __I  Ifx_UReg_8Bit                       reserved_30[4];         /**< \brief 30, \internal Reserved */
} Ifx_EGTM_CLS_ARCH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_AEI_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief AEI object */
typedef volatile struct _Ifx_EGTM_CLS_AEI
{
       __IO Ifx_EGTM_CLS_AEI_BRIDGE_MODE        BRIDGE_MODE;            /**< \brief 0, eGTM AEI bridge mode register*/
       __I  Ifx_EGTM_CLS_AEI_BRIDGE_PTR1        BRIDGE_PTR1;            /**< \brief 4, eGTM AEI bridge pointer 1 register*/
       __I  Ifx_EGTM_CLS_AEI_BRIDGE_PTR2        BRIDGE_PTR2;            /**< \brief 8, eGTM AEI bridge pointer 2 register*/
       __I  Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
} Ifx_EGTM_CLS_AEI;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMU_CLK_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CLK object */
typedef volatile struct _Ifx_EGTM_CLS_CMU_CLK
{
       __IO Ifx_EGTM_CLS_CMU_CLKX_CTRL          CTRL;                   /**< \brief 0, CMU control for clock resolution generator [x]*/
} Ifx_EGTM_CLS_CMU_CLK;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMU_ECLK_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief ECLK object */
typedef volatile struct _Ifx_EGTM_CLS_CMU_ECLK
{
       __IO Ifx_EGTM_CLS_CMU_ECLK_NUM           NUM;                    /**< \brief 0, The numerator for the external clock resolution generator [z]*/
       __IO Ifx_EGTM_CLS_CMU_ECLK_DEN           DEN;                    /**< \brief 4, The denominator for the external clock resolution generator [z]*/
} Ifx_EGTM_CLS_CMU_ECLK;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMU_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CMU object */
typedef volatile struct _Ifx_EGTM_CLS_CMU
{
       __IO Ifx_EGTM_CLS_CMU_CLK_EN             CLK_EN;                 /**< \brief 0, CMU clock enable*/
       __IO Ifx_EGTM_CLS_CMU_GCLK_NUM           GCLK_NUM;               /**< \brief 4, The numerator for CMU global clock resolution generator*/
       __IO Ifx_EGTM_CLS_CMU_GCLK_DEN           GCLK_DEN;               /**< \brief 8, The denominator for CMU global clock resolution generator*/
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK0;                   /**< \brief C, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK1;                   /**< \brief 10, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK2;                   /**< \brief 14, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK3;                   /**< \brief 18, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK4;                   /**< \brief 1C, */
        __IO Ifx_EGTM_CLS_CMU_CLK                CLK5;                   /**< \brief 20, */
       __IO Ifx_EGTM_CLS_CMU_CLK_6_CTRL         CLK_6_CTRL;             /**< \brief 24, CMU control for clock resolution generator 6*/
       __IO Ifx_EGTM_CLS_CMU_CLK_7_CTRL         CLK_7_CTRL;             /**< \brief 28, CMU control for clock resolution generator 7*/
       __IO Ifx_EGTM_CLS_CMU_ECLK               ECLK[3];                /**< \brief 2C, */
       __IO Ifx_EGTM_CLS_CMU_FXCLK_CTRL         FXCLK_CTRL;             /**< \brief 44, CMU control for selection of FCR subblock input*/
       __I  Ifx_UReg_8Bit                       reserved_48[4];         /**< \brief 48, \internal Reserved */
       __IO Ifx_EGTM_CLS_CMU_CLK_CTRL           CLK_CTRL;               /**< \brief 4C, CMU control for clock resolution generator*/
} Ifx_EGTM_CLS_CMU;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TBU_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_TBU_CH
{
       __IO Ifx_EGTM_CLS_TBU_CH_BASE            BASE;                   /**< \brief 0, TBU channel [x] base*/
} Ifx_EGTM_CLS_TBU_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TBU_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief TBU object */
typedef volatile struct _Ifx_EGTM_CLS_TBU
{
       __IO Ifx_EGTM_CLS_TBU_CHEN               CHEN;                   /**< \brief 0, TBU global channel enable*/
       __IO Ifx_EGTM_CLS_TBU_CH0_CTRL           CH0_CTRL;               /**< \brief 4, TBU channel 0 control*/
       __IO Ifx_EGTM_CLS_TBU_CH0_BASE           CH0_BASE;               /**< \brief 8, TBU channel 0 base*/
       __IO Ifx_EGTM_CLS_TBU_CH1_CTRL           CH1_CTRL;               /**< \brief C, TBU channel 1 control*/
        __IO Ifx_EGTM_CLS_TBU_CH                 CH1;                    /**< \brief 10, */
       __IO Ifx_EGTM_CLS_TBU_CH2_CTRL           CH2_CTRL;               /**< \brief 14, TBU channel 2 control*/
        __IO Ifx_EGTM_CLS_TBU_CH                 CH2;                    /**< \brief 18, */
       __I  Ifx_UReg_8Bit                       reserved_1C[16];        /**< \brief 1C, \internal Reserved */
} Ifx_EGTM_CLS_TBU;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_IRQG_CLS_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief IRQG_CLS object */
typedef volatile struct _Ifx_EGTM_CLS_ICM_IRQG_CLS
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_CLS_MEI       MEI;                    /**< \brief 0, ICM_IRQG_CLS_[g]_MEI*/
} Ifx_EGTM_CLS_ICM_IRQG_CLS;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_IRQG_ATOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief IRQG_ATOM object */
typedef volatile struct _Ifx_EGTM_CLS_ICM_IRQG_ATOM
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_ATOM_CI       CI;                     /**< \brief 0, ICM_IRQG_ATOM_[g]_CI*/
} Ifx_EGTM_CLS_ICM_IRQG_ATOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_IRQG_TOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief IRQG_TOM object */
typedef volatile struct _Ifx_EGTM_CLS_ICM_IRQG_TOM
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_TOM_CI        CI;                     /**< \brief 0, ICM_IRQG_TOM_[g]_CI*/
} Ifx_EGTM_CLS_ICM_IRQG_TOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ICM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ICM object */
typedef volatile struct _Ifx_EGTM_CLS_ICM
{
       __I  Ifx_EGTM_CLS_ICM_IRQG_0             IRQG_0;                 /**< \brief 0, ICM_IRQG_0*/
       __I  Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_2             IRQG_2;                 /**< \brief 8, ICM Interrupt group register covering TIM0, TIM1, TIM2, TIM3*/
       __I  Ifx_UReg_8Bit                       reserved_C[36];         /**< \brief C, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_MEI           IRQG_MEI;               /**< \brief 30, ICM Interrupt group register for module error interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_34[4];         /**< \brief 34, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_CEI1          IRQG_CEI1;              /**< \brief 38, ICM Interrupt group register 1 for channel error interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_3C[120];       /**< \brief 3C, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_SPE_CEI       IRQG_SPE_CEI;           /**< \brief B4, ICM Interrupt group SPE for module Error Interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_B8[88];        /**< \brief B8, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM_IRQG_CLS           IRQG_CLS[1];            /**< \brief 110, */
       __I  Ifx_UReg_8Bit                       reserved_114[92];       /**< \brief 114, \internal Reserved */
       __I  Ifx_EGTM_CLS_ICM_IRQG_SPE_CI        IRQG_SPE_CI;            /**< \brief 170, ICM Interrupt group SPE for module Interrupt information*/
       __I  Ifx_UReg_8Bit                       reserved_174[28];       /**< \brief 174, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM_IRQG_ATOM          IRQG_ATOM[1];           /**< \brief 190, */
       __I  Ifx_UReg_8Bit                       reserved_194[12];       /**< \brief 194, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM_IRQG_TOM           IRQG_TOM[2];            /**< \brief 1A0, */
       __I  Ifx_UReg_8Bit                       reserved_1A8[16];       /**< \brief 1A8, \internal Reserved */
} Ifx_EGTM_CLS_ICM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_MON_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief MON object */
typedef volatile struct _Ifx_EGTM_CLS_MON
{
       __IO Ifx_EGTM_CLS_MON_STATUS             STATUS;                 /**< \brief 0, MON status register*/
       __I  Ifx_UReg_8Bit                       reserved_4[8];          /**< \brief 4, \internal Reserved */
} Ifx_EGTM_CLS_MON;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CMP_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CMP object */
typedef volatile struct _Ifx_EGTM_CLS_CMP
{
       __IO Ifx_EGTM_CLS_CMP_EN                 EN;                     /**< \brief 0, CMP comparator enable register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_NOTIFY         IRQ_NOTIFY;             /**< \brief 4, CMP event notification register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_EN             IRQ_EN;                 /**< \brief 8, CMP interrupt enable register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_FORCINT        IRQ_FORCINT;            /**< \brief C, CMP interrupt force register*/
       __IO Ifx_EGTM_CLS_CMP_IRQ_MODE           IRQ_MODE;               /**< \brief 10, CMP interrupt mode configuration register*/
       __IO Ifx_EGTM_CLS_CMP_EIRQ_EN            EIRQ_EN;                /**< \brief 14, CMP error interrupt enable register*/
} Ifx_EGTM_CLS_CMP;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TIM_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_TIM_CH
{
       __IO Ifx_EGTM_CLS_TIM_CH_GPR0            GPR0;                   /**< \brief 0, TIM[i] channel [x] general-purpose 0 register*/
       __IO Ifx_EGTM_CLS_TIM_CH_GPR1            GPR1;                   /**< \brief 4, TIM[i] channel [x] general-purpose 1 register*/
       __I  Ifx_EGTM_CLS_TIM_CH_CNT             CNT;                    /**< \brief 8, TIM[i] channel [x] SMU counter register*/
       __I  Ifx_EGTM_CLS_TIM_CH_ECNT            ECNT;                   /**< \brief C, TIM[i] channel [x] SMU edge counter register*/
       __IO Ifx_EGTM_CLS_TIM_CH_CNTS            CNTS;                   /**< \brief 10, TIM[i] channel [x] SMU shadow counter register*/
       __IO Ifx_EGTM_CLS_TIM_CH_TDUC            TDUC;                   /**< \brief 14, TIM[i]_CH[x]_TDUC*/
       __IO Ifx_EGTM_CLS_TIM_CH_TDUV            TDUV;                   /**< \brief 18, TIM[i]_CH[x]_TDUV*/
       __IO Ifx_EGTM_CLS_TIM_CH_FLT_RE          FLT_RE;                 /**< \brief 1C, TIM[i] channel [x] filter parameter 0 register*/
       __IO Ifx_EGTM_CLS_TIM_CH_FLT_FE          FLT_FE;                 /**< \brief 20, TIM[i] channel [x] filter parameter 1 register*/
       __IO Ifx_EGTM_CLS_TIM_CH_CTRL            CTRL;                   /**< \brief 24, TIM[i] channel [x] control register*/
       __IO Ifx_EGTM_CLS_TIM_CH_ECTRL           ECTRL;                  /**< \brief 28, TIM[i] channel [x] extended control register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_NOTIFY      IRQ_NOTIFY;             /**< \brief 2C, TIM[i] channel [x] interrupt notification register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_EN          IRQ_EN;                 /**< \brief 30, TIM[i] channel [x] interrupt enable register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_FORCINT     IRQ_FORCINT;            /**< \brief 34, TIM[i] channel [x] force interrupt register*/
       __IO Ifx_EGTM_CLS_TIM_CH_IRQ_MODE        IRQ_MODE;               /**< \brief 38, TIM[i] channel [x] interrupt mode configuration register*/
       __IO Ifx_EGTM_CLS_TIM_CH_EIRQ_EN         EIRQ_EN;                /**< \brief 3C, TIM[i] channel [x] error interrupt enable register*/
       __I  Ifx_UReg_8Bit                       reserved_40[64];        /**< \brief 40, \internal Reserved */
} Ifx_EGTM_CLS_TIM_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TIM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief TIM object */
typedef volatile struct _Ifx_EGTM_CLS_TIM
{
       __IO Ifx_EGTM_CLS_TIM_CH                 CH[8];                  /**< \brief 0, */
       __I  Ifx_EGTM_CLS_TIM_INP_VAL            INP_VAL;                /**< \brief 400, TIM[i] input value observation register*/
       __IO Ifx_EGTM_CLS_TIM_IN_SRC             IN_SRC;                 /**< \brief 404, TIM[i] AUX IN source selection register*/
       __IO Ifx_EGTM_CLS_TIM_RST                RST;                    /**< \brief 408, TIM[i] global software reset register*/
} Ifx_EGTM_CLS_TIM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TOM_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_TOM_CH
{
       __IO Ifx_EGTM_CLS_TOM_CH_CTRL            CTRL;                   /**< \brief 0, TOM[i] channel [x] control register*/
       __IO Ifx_EGTM_CLS_TOM_CH_SR0             SR0;                    /**< \brief 4, TOM[i] channel [x] CCU0 compare shadow register*/
       __IO Ifx_EGTM_CLS_TOM_CH_SR1             SR1;                    /**< \brief 8, TOM[i] channel [x] CCU1 compare shadow register*/
       __IO Ifx_EGTM_CLS_TOM_CH_CM0             CM0;                    /**< \brief C, TOM[i] channel [x] CCU0 compare register*/
       __IO Ifx_EGTM_CLS_TOM_CH_CM1             CM1;                    /**< \brief 10, TOM[i] channel [x] CCU1 compare register*/
       __IO Ifx_EGTM_CLS_TOM_CH_CN0             CN0;                    /**< \brief 14, TOM[i] channel [x] CCU0 counter*/
       __IO Ifx_EGTM_CLS_TOM_CH_STAT            STAT;                   /**< \brief 18, TOM[i] channel [x] status register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_NOTIFY      IRQ_NOTIFY;             /**< \brief 1C, TOM[i] channel [x] interrupt notification register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_EN          IRQ_EN;                 /**< \brief 20, TOM[i] channel [x] interrupt enable register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_FORCINT     IRQ_FORCINT;            /**< \brief 24, TOM[i] channel [x] force interrupt register*/
       __IO Ifx_EGTM_CLS_TOM_CH_IRQ_MODE        IRQ_MODE;               /**< \brief 28, TOM[i] channel [x] interrupt mode register*/
       __I  Ifx_UReg_8Bit                       reserved_2C[4];         /**< \brief 2C, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM_CH_CTRL_SR         CTRL_SR;                /**< \brief 30, TOM[i] channel [x] control shadow register*/
       __I  Ifx_UReg_8Bit                       reserved_34[12];        /**< \brief 34, \internal Reserved */
} Ifx_EGTM_CLS_TOM_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TOM_TGC_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief TGC object */
typedef volatile struct _Ifx_EGTM_CLS_TOM_TGC
{
       __IO Ifx_EGTM_CLS_TOM_TGC_GLB_CTRL       GLB_CTRL;               /**< \brief 0, TOM[i] TGC [g] global control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_ACT_TB         ACT_TB;                 /**< \brief 4, TOM[i] TGC [g] action time base register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_FUPD_CTRL      FUPD_CTRL;              /**< \brief 8, TOM[i] TGC [g] force update control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_INT_TRIG       INT_TRIG;               /**< \brief C, TOM[i] TGC [g] internal trigger control register*/
       __I  Ifx_UReg_8Bit                       reserved_10[48];        /**< \brief 10, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM_TGC_ENDIS_CTRL     ENDIS_CTRL;             /**< \brief 40, TOM[i] TGC [g] enable/disable control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_ENDIS_STAT     ENDIS_STAT;             /**< \brief 44, TOM[i] TGC [g] enable/disable status register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_OUTEN_CTRL     OUTEN_CTRL;             /**< \brief 48, TOM[i] TGC [g] output enable control register*/
       __IO Ifx_EGTM_CLS_TOM_TGC_OUTEN_STAT     OUTEN_STAT;             /**< \brief 4C, TOM[i] TGC [g] output enable status register*/
       __I  Ifx_UReg_8Bit                       reserved_50[48];        /**< \brief 50, \internal Reserved */
} Ifx_EGTM_CLS_TOM_TGC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_TOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief TOM object */
typedef volatile struct _Ifx_EGTM_CLS_TOM
{
       __IO Ifx_EGTM_CLS_TOM_CH                 CH[16];                 /**< \brief 0, */
       __I  Ifx_UReg_8Bit                       reserved_400[48];       /**< \brief 400, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM_TGC                TGC[2];                 /**< \brief 430, */
} Ifx_EGTM_CLS_TOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ATOM_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_CLS_ATOM_CH
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       union
       {
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMI      CTRL_SOMI;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMC      CTRL_SOMC;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMP      CTRL_SOMP;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMS      CTRL_SOMS;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SOMB      CTRL_SOMB;              /**< \brief 4, ATOM[i] channel [x] control register*/
            __IO Ifx_EGTM_CLS_ATOM_CH_CTRL           CTRL;                   /**< \brief 4, ATOM[i] channel [x] control register*/
       };
       __IO Ifx_EGTM_CLS_ATOM_CH_SR0            SR0;                    /**< \brief 8, ATOM[i] channel [x] CCU0 compare shadow register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_SR1            SR1;                    /**< \brief C, ATOM[i] channel [x] CCU1 compare shadow register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CM0            CM0;                    /**< \brief 10, ATOM[i] channel [x] CCU0 compare register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CM1            CM1;                    /**< \brief 14, ATOM[i] channel [x] CCU1 compare register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CN0            CN0;                    /**< \brief 18, ATOM[i] channel [x] CCU0 counter register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_STAT           STAT;                   /**< \brief 1C, ATOM[i] channel [x] status register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_NOTIFY     IRQ_NOTIFY;             /**< \brief 20, ATOM[i] channel [x] interrupt notification register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_EN         IRQ_EN;                 /**< \brief 24, ATOM[i] channel [x] interrupt enable register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_FORCINT    IRQ_FORCINT;            /**< \brief 28, ATOM[i] channel [x] software interrupt generation*/
       __IO Ifx_EGTM_CLS_ATOM_CH_IRQ_MODE       IRQ_MODE;               /**< \brief 2C, ATOM[i] channel [x] interrupt mode configuration register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CTRL2          CTRL2;                  /**< \brief 30, ATOM[i] channel [x] control2 register*/
       __IO Ifx_EGTM_CLS_ATOM_CH_CTRL_SR        CTRL_SR;                /**< \brief 34, ATOM[i] channel [x] control shadow register*/
       __I  Ifx_UReg_8Bit                       reserved_38[72];        /**< \brief 38, \internal Reserved */
} Ifx_EGTM_CLS_ATOM_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ATOM_AGC_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief AGC object */
typedef volatile struct _Ifx_EGTM_CLS_ATOM_AGC
{
       __IO Ifx_EGTM_CLS_ATOM_AGC_GLB_CTRL      GLB_CTRL;               /**< \brief 0, ATOM[i] AGC global control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_ENDIS_CTRL    ENDIS_CTRL;             /**< \brief 4, ATOM[i] AGC enable/disable control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_ENDIS_STAT    ENDIS_STAT;             /**< \brief 8, ATOM[i] AGC enable/disable status register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_ACT_TB        ACT_TB;                 /**< \brief C, ATOM[i] AGC action time base register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_OUTEN_CTRL    OUTEN_CTRL;             /**< \brief 10, ATOM[i] AGC output enable control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_OUTEN_STAT    OUTEN_STAT;             /**< \brief 14, ATOM[i] AGC output enable status register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_FUPD_CTRL     FUPD_CTRL;              /**< \brief 18, ATOM[i] AGC force update control register*/
       __IO Ifx_EGTM_CLS_ATOM_AGC_INT_TRIG      INT_TRIG;               /**< \brief 1C, ATOM[i] AGC internal trigger control register*/
} Ifx_EGTM_CLS_ATOM_AGC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_ATOM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ATOM object */
typedef volatile struct _Ifx_EGTM_CLS_ATOM
{
       __IO Ifx_EGTM_CLS_ATOM_CH                CH[8];                  /**< \brief 0, */
       __I  Ifx_UReg_8Bit                       reserved_400[64];       /**< \brief 400, \internal Reserved */
       __IO Ifx_EGTM_CLS_ATOM_AGC               AGC;                    /**< \brief 440, */
} Ifx_EGTM_CLS_ATOM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CCM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CCM object */
typedef volatile struct _Ifx_EGTM_CLS_CCM
{
       __I  Ifx_UReg_8Bit                       reserved_0[468];        /**< \brief 0, \internal Reserved */
       __I  Ifx_EGTM_CLS_CCM_HW_CONF2           HW_CONF2;               /**< \brief 1D4, CCM[i] 2. Hardware Configuration Register*/
       __I  Ifx_UReg_8Bit                       reserved_1D8[4];        /**< \brief 1D8, \internal Reserved */
       __I  Ifx_EGTM_CLS_CCM_HW_CONF            HW_CONF;                /**< \brief 1DC, CCM[i] Hardware Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_TIM_AUX_IN_SRC     TIM_AUX_IN_SRC;         /**< \brief 1E0, CCM[i] TIM AUX Input Source Register*/
       __I  Ifx_UReg_8Bit                       reserved_1E4[4];        /**< \brief 1E4, \internal Reserved */
       __I  Ifx_EGTM_CLS_CCM_TOM_OUT            TOM_OUT;                /**< \brief 1E8, CCM[i] TOM Output Register*/
       __I  Ifx_EGTM_CLS_CCM_ATOM_OUT           ATOM_OUT;               /**< \brief 1EC, CCM[i] ATOM Output Register*/
       __IO Ifx_EGTM_CLS_CCM_CMU_CLK_CFG        CMU_CLK_CFG;            /**< \brief 1F0, CCM[i] CMU Clock Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_CMU_FXCLK_CFG      CMU_FXCLK_CFG;          /**< \brief 1F4, CCM[i] CMU Fixed Clock Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_CFG                CFG;                    /**< \brief 1F8, CCM[i] Configuration Register*/
       __IO Ifx_EGTM_CLS_CCM_PROT               PROT;                   /**< \brief 1FC, CCM[i] Protection Register*/
} Ifx_EGTM_CLS_CCM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CDTM_DTM_struct
 * \{  */
/******************************************************************************/
/** \name Object L4
 * \{  */
/** \brief DTM object */
typedef volatile struct _Ifx_EGTM_CLS_CDTM_DTM
{
       __IO Ifx_EGTM_CLS_CDTM_DTM_CTRL          CTRL;                   /**< \brief 0, CDTM[i]_DTM[d] global configuration and control register*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL1      CH_CTRL1;               /**< \brief 4, CDTM[i]_DTM[d] channel control register 1*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2      CH_CTRL2;               /**< \brief 8, CDTM[i]_DTM[d] channel control register 2*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL2_SR   CH_CTRL2_SR;            /**< \brief C, CDTM[i] DTM[d] channel control register 2 shadow*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_PS_CTRL       PS_CTRL;                /**< \brief 10, CDTM[i]_DTM[d] phase shift unit configuration and control register*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_DTV        CH_DTV[4];              /**< \brief 14, CDTM[i]_DTM[d] channel [x] dead-time reload values*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_SR         CH_SR;                  /**< \brief 24, CDTM[i]_DTM[d] channel shadow register*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_CTRL3      CH_CTRL3;               /**< \brief 28, CDTM[i]_DTM[d] channel control register 3*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CTRL2         CTRL2;                  /**< \brief 2C, CDTM[i]_DTM[d] global configuration and control register 2*/
       __IO Ifx_EGTM_CLS_CDTM_DTM_CH_DTV_SR     CH_DTV_SR[4];           /**< \brief 30, CDTM[i]_DTM[d] channel [x] dead-time shadow values*/
} Ifx_EGTM_CLS_CDTM_DTM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_CDTM_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief CDTM object */
typedef volatile struct _Ifx_EGTM_CLS_CDTM
{
       __IO Ifx_EGTM_CLS_CDTM_DTM               DTM[6];                 /**< \brief 0, */
} Ifx_EGTM_CLS_CDTM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_SPE_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief SPE object */
typedef volatile struct _Ifx_EGTM_CLS_SPE
{
       __IO Ifx_EGTM_CLS_SPE_CTRL_STAT          CTRL_STAT;              /**< \brief 0, SPE[i] Control Status Register*/
       __IO Ifx_EGTM_CLS_SPE_PAT                PAT;                    /**< \brief 4, SPE[i] Input Pattern Definition Register*/
       __IO Ifx_EGTM_CLS_SPE_OUT_PAT            OUT_PAT[8];             /**< \brief 8, SPE[i] Output Definition Register [p]*/
       __IO Ifx_EGTM_CLS_SPE_OUT_CTRL           OUT_CTRL;               /**< \brief 28, SPE[i] Output Control Register*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_NOTIFY         IRQ_NOTIFY;             /**< \brief 2C, SPE[i] Interrupt Notification Register*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_EN             IRQ_EN;                 /**< \brief 30, SPE[i] Interrupt Enable Register*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_FORCINT        IRQ_FORCINT;            /**< \brief 34, SPE[i] Interrupt Generation By Software*/
       __IO Ifx_EGTM_CLS_SPE_IRQ_MODE           IRQ_MODE;               /**< \brief 38, SPE[i] Interrupt Mode Configuration Register*/
       __IO Ifx_EGTM_CLS_SPE_EIRQ_EN            EIRQ_EN;                /**< \brief 3C, SPE[i] Error Interrupt Enable Register*/
       __IO Ifx_EGTM_CLS_SPE_REV_CNT            REV_CNT;                /**< \brief 40, SPE[i] Input Revolution Counter*/
       __IO Ifx_EGTM_CLS_SPE_REV_CMP            REV_CMP;                /**< \brief 44, SPE[i] Revolution Counter Compare Value*/
       __IO Ifx_EGTM_CLS_SPE_CTRL_STAT2         CTRL_STAT2;             /**< \brief 48, SPE[i] Control Status Register 2*/
       __IO Ifx_EGTM_CLS_SPE_CMD                CMD;                    /**< \brief 4C, SPE[i] Command Register*/
} Ifx_EGTM_CLS_SPE;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CLS_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CLS object */
typedef volatile struct _Ifx_EGTM_CLS
{
       __IO Ifx_EGTM_CLS_ARCH                   ARCH;                   /**< \brief 0, */
       __I  Ifx_UReg_8Bit                       reserved_34[12];        /**< \brief 34, \internal Reserved */
       __IO Ifx_EGTM_CLS_AEI                    AEI;                    /**< \brief 40, */
       __I  Ifx_UReg_8Bit                       reserved_50[48];        /**< \brief 50, \internal Reserved */
       __IO Ifx_EGTM_CLS_CMU                    CMU;                    /**< \brief 80, */
       __I  Ifx_UReg_8Bit                       reserved_D0[48];        /**< \brief D0, \internal Reserved */
       __IO Ifx_EGTM_CLS_TBU                    TBU;                    /**< \brief 100, */
       __I  Ifx_UReg_8Bit                       reserved_12C[724];      /**< \brief 12C, \internal Reserved */
       __IO Ifx_EGTM_CLS_ICM                    ICM;                    /**< \brief 400, */
       __I  Ifx_UReg_8Bit                       reserved_5B8[200];      /**< \brief 5B8, \internal Reserved */
       __IO Ifx_EGTM_CLS_MON                    MON;                    /**< \brief 680, */
       __I  Ifx_UReg_8Bit                       reserved_68C[52];       /**< \brief 68C, \internal Reserved */
       __IO Ifx_EGTM_CLS_CMP                    CMP;                    /**< \brief 6C0, */
       __I  Ifx_UReg_8Bit                       reserved_6D8[296];      /**< \brief 6D8, \internal Reserved */
       __IO Ifx_EGTM_CLS_TIM                    TIM;                    /**< \brief 800, */
       __I  Ifx_UReg_8Bit                       reserved_C0C[1012];     /**< \brief C0C, \internal Reserved */
       __IO Ifx_EGTM_CLS_TOM                    TOM;                    /**< \brief 1000, */
       __I  Ifx_UReg_8Bit                       reserved_1530[720];     /**< \brief 1530, \internal Reserved */
       __IO Ifx_EGTM_CLS_ATOM                   ATOM;                   /**< \brief 1800, */
       __I  Ifx_UReg_8Bit                       reserved_1C60[9120];    /**< \brief 1C60, \internal Reserved */
       __IO Ifx_EGTM_CLS_CCM                    CCM;                    /**< \brief 4000, */
       __I  Ifx_UReg_8Bit                       reserved_4200[512];     /**< \brief 4200, \internal Reserved */
       __IO Ifx_EGTM_CLS_CDTM                   CDTM;                   /**< \brief 4400, */
       __I  Ifx_UReg_8Bit                       reserved_4580[1664];    /**< \brief 4580, \internal Reserved */
       __IO Ifx_EGTM_CLS_SPE                    SPE;                    /**< \brief 4C00, */
       __I  Ifx_UReg_8Bit                       reserved_4C50[111536];    /**< \brief 4C50, \internal Reserved */
} Ifx_EGTM_CLS;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_RST_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief RST object */
typedef volatile struct _Ifx_EGTM_RST
{
       __IO Ifx_EGTM_RST_CTRLA                  CTRLA;                  /**< \brief 0, Reset control register A*/
       __IO Ifx_EGTM_RST_CTRLB                  CTRLB;                  /**< \brief 4, Reset control register B*/
       __I  Ifx_EGTM_RST_STAT                   STAT;                   /**< \brief 8, Reset status register*/
} Ifx_EGTM_RST;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CL_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_CL_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for cluster 0*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for cluster 0*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for cluster 0*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for cluster 0*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for cluster 0*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for cluster 0*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_CL_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CL_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CL object */
typedef volatile struct _Ifx_EGTM_CL
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       __IO Ifx_EGTM_CL_ACCEN                   ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_CL;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CTRL_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_CTRL_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for control logic*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for control logic*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for control logic*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for control logic*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for control logic*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for control logic*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_CTRL_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CTRL_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CTRL object */
typedef volatile struct _Ifx_EGTM_CTRL
{
       __IO Ifx_EGTM_PROT                       PROTE;                  /**< \brief 0, PROT register Endinit for control logic*/
       __IO Ifx_EGTM_CTRL_ACCEN                 ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_CTRL;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_WRAP_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_WRAP_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for wrapper logic*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_WRAP_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_WRAP_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief WRAP object */
typedef volatile struct _Ifx_EGTM_WRAP
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       __IO Ifx_EGTM_WRAP_ACCEN                 ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_WRAP;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CTRLGTM_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_CTRLGTM_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for wrapper logic*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_CTRLGTM_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CTRLGTM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CTRLGTM object */
typedef volatile struct _Ifx_EGTM_CTRLGTM
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       __IO Ifx_EGTM_CTRLGTM_ACCEN              ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_CTRLGTM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_SAFEGTM_ACCEN_struct
 * \{  */
/******************************************************************************/
/** \name Object L3
 * \{  */
/** \brief ACCEN object */
typedef volatile struct _Ifx_EGTM_SAFEGTM_ACCEN
{
       __IO Ifx_EGTM_ACCEN_WRA                  WRA;                    /**< \brief 0, Write access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_WRB_FPI              WRB;                    /**< \brief 4, Write access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDA                  RDA;                    /**< \brief 8, Read access enable register A for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_RDB_FPI              RDB;                    /**< \brief C, Read access enable register B for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_VM                   VM;                     /**< \brief 10, VM access enable register for wrapper logic*/
       __IO Ifx_EGTM_ACCEN_PRS                  PRS;                    /**< \brief 14, PRS access enable register for wrapper logic*/
       __I  Ifx_UReg_8Bit                       reserved_18[8];         /**< \brief 18, \internal Reserved */
} Ifx_EGTM_SAFEGTM_ACCEN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_SAFEGTM_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief SAFEGTM object */
typedef volatile struct _Ifx_EGTM_SAFEGTM
{
       __I  Ifx_UReg_8Bit                       reserved_0[4];          /**< \brief 0, \internal Reserved */
       __IO Ifx_EGTM_SAFEGTM_ACCEN              ACCEN;                  /**< \brief 4, */
} Ifx_EGTM_SAFEGTM;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_OCDS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief OCDS object */
typedef volatile struct _Ifx_EGTM_OCDS
{
       __IO Ifx_EGTM_OCDS_OTBU0T                OTBU0T;                 /**< \brief 0, OCDS TBU0 trigger register*/
       __IO Ifx_EGTM_OCDS_OTBU1T                OTBU1T;                 /**< \brief 4, OCDS TBU1 trigger register*/
       __IO Ifx_EGTM_OCDS_OTBU2T                OTBU2T;                 /**< \brief 8, OCDS TBU2 trigger register*/
       __I  Ifx_UReg_8Bit                       reserved_C[4];          /**< \brief C, \internal Reserved */
       __IO Ifx_EGTM_OCDS_OTSS                  OTSS;                   /**< \brief 10, OCDS trigger set select register*/
       __IO Ifx_EGTM_OCDS_OTSC0                 OTSC0;                  /**< \brief 14, OCDS trigger set control 0 register*/
} Ifx_EGTM_OCDS;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_MSCSET_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief MSCSET object */
typedef volatile struct _Ifx_EGTM_MSCSET
{
       __IO Ifx_EGTM_MSCSET_CON0                CON0;                   /**< \brief 0, eGTM to MSC SET0 output selection register 0*/
       __IO Ifx_EGTM_MSCSET_CON1                CON1;                   /**< \brief 4, eGTM to MSC SET0 output selection register 0*/
       __IO Ifx_EGTM_MSCSET_CON2                CON2;                   /**< \brief 8, eGTM to MSC SET0 output selection register 0*/
       __IO Ifx_EGTM_MSCSET_CON3                CON3;                   /**< \brief C, eGTM to MSC SET0 output selection register 0*/
} Ifx_EGTM_MSCSET;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_MSC_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief MSC object */
typedef volatile struct _Ifx_EGTM_MSC
{
       __IO Ifx_EGTM_MSC_INLCON                 INLCON;                 /**< \brief 0, eGTM to input bus MSC0_INLCON signal selection register*/
       __IO Ifx_EGTM_MSC_INHCON                 INHCON;                 /**< \brief 4, eGTM to input bus MSC0_INHCON signal selection register*/
       __IO Ifx_EGTM_MSC_INLECON                INLECON;                /**< \brief 8, eGTM to input bus MSC0_INLECON signal selection register*/
       __IO Ifx_EGTM_MSC_INHECON                INHECON;                /**< \brief C, eGTM to input bus MSC0_INHECON signal selection register*/
} Ifx_EGTM_MSC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_MSCSELIN_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief MSCSELIN object */
typedef volatile struct _Ifx_EGTM_MSCSELIN
{
       __IO Ifx_EGTM_MSCSELIN_INLCON            INLCON;                 /**< \brief 0, Selection of INLCON stream for MSC*/
       __IO Ifx_EGTM_MSCSELIN_INHCON            INHCON;                 /**< \brief 4, Selection of INHCON stream for MSC*/
       __IO Ifx_EGTM_MSCSELIN_INLECON           INLECON;                /**< \brief 8, Selection of INLECON stream for MSC*/
       __IO Ifx_EGTM_MSCSELIN_INHECON           INHECON;                /**< \brief C, Selection of INHECON stream for MSC*/
} Ifx_EGTM_MSCSELIN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_PSI5_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5 object */
typedef volatile struct _Ifx_EGTM_PSI5
{
       __IO Ifx_EGTM_PSI5_OUT                   OUT;                    /**< \brief 0, eGTM to PSI5 output trigger selection register*/
} Ifx_EGTM_PSI5;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_PSI5S_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief PSI5S object */
typedef volatile struct _Ifx_EGTM_PSI5S
{
       __IO Ifx_EGTM_PSI5S_OUT                  OUT;                    /**< \brief 0, eGTM to PSI5-S0 output trigger selection register*/
} Ifx_EGTM_PSI5S;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_LCDCDC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief LCDCDC object */
typedef volatile struct _Ifx_EGTM_LCDCDC
{
       __IO Ifx_EGTM_LCDCDC_OUT                 OUT;                    /**< \brief 0, eGTM to LCDCDC output trigger selection register*/
} Ifx_EGTM_LCDCDC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_CAN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief CAN object */
typedef volatile struct _Ifx_EGTM_CAN
{
       __IO Ifx_EGTM_CAN_OUT                    OUT[4];                 /**< \brief 0, eGTM to CAN0 output selection register 0. 0*4+ 0<24 then interface exists.*/
} Ifx_EGTM_CAN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_QSPI_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief QSPI object */
typedef volatile struct _Ifx_EGTM_QSPI
{
       __IO Ifx_EGTM_QSPI_OUT                   OUT;                    /**< \brief 0, eGTM to QSPI0 output selection register. 0<8 then interface exists.*/
} Ifx_EGTM_QSPI;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_ASCLIN_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ASCLIN object */
typedef volatile struct _Ifx_EGTM_ASCLIN
{
       __IO Ifx_EGTM_ASCLIN_OUT                 OUT;                    /**< \brief 0, eGTM to ASCLIN0 output selection register. 0<28 then interface exists.*/
} Ifx_EGTM_ASCLIN;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_SENT_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief SENT object */
typedef volatile struct _Ifx_EGTM_SENT
{
       __IO Ifx_EGTM_SENT_OUTA                  OUTA;                   /**< \brief 0, eGTM to SENT0 trigger x output selection register A*/
       __I  Ifx_UReg_8Bit                       reserved_4[4];          /**< \brief 4, \internal Reserved */
} Ifx_EGTM_SENT;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_ADC_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief ADC object */
typedef volatile struct _Ifx_EGTM_ADC
{
       __IO Ifx_EGTM_ADC_OUT                    OUT[3];                 /**< \brief 0, eGTM to ADC output selection register 0*/
} Ifx_EGTM_ADC;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_DTMAUX_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DTMAUX object */
typedef volatile struct _Ifx_EGTM_DTMAUX
{
       __IO Ifx_EGTM_DTMAUX_IN                  IN[2];                  /**< \brief 0, Cluster 0 DTMAUX input 0 selection register*/
} Ifx_EGTM_DTMAUX;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_SCU_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief SCU object */
typedef volatile struct _Ifx_EGTM_SCU
{
       __IO Ifx_EGTM_SCU_OUT                    OUT[3];                 /**< \brief 0, eGTM to SCU output selection register 0 eGTM_SCU_TRIG(0)*/
} Ifx_EGTM_SCU;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_DITH_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief DITH object */
typedef volatile struct _Ifx_EGTM_DITH
{
       __IO Ifx_EGTM_DITH_ATCH                  ATCH[8];                /**< \brief 0, Dither ATOM 0 Channel 0 passing the DTMs*/
} Ifx_EGTM_DITH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_TIMS_CH_struct
 * \{  */
/******************************************************************************/
/** \name Object L2
 * \{  */
/** \brief CH object */
typedef volatile struct _Ifx_EGTM_TIMS_CH
{
       __I  Ifx_EGTM_TIMS_CH_ADCSEL             ADCSEL;                 /**< \brief 0, Instance Selection for TIM[0] channel[0]*/
} Ifx_EGTM_TIMS_CH;

/******************************************************************************/
/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_TIMS_struct
 * \{  */
/******************************************************************************/
/** \name Object L1
 * \{  */
/** \brief TIMS object */
typedef volatile struct _Ifx_EGTM_TIMS
{
       __IO Ifx_EGTM_TIMS_CH                    CH[8];                  /**< \brief 0, */
} Ifx_EGTM_TIMS;

/******************************************************************************/
/** \addtogroup IfxSfr_Egtm_Registers_struct
 * \{  */
/******************************************************************************/
/** \name Object L0
 * \{  */

/** \brief EGTM object */
typedef volatile struct _Ifx_EGTM
{
       __IO Ifx_EGTM_CLS                        CLS[3];                 /**< \brief 0, */
       __IO Ifx_EGTM_CLC                        CLC;                    /**< \brief 60000, Clock control register*/
       __IO Ifx_EGTM_OCS                        OCS;                    /**< \brief 60004, OCDS control and status register*/
       __I  Ifx_UReg_8Bit                       reserved_60008[8];      /**< \brief 60008, \internal Reserved */
       __IO Ifx_EGTM_RST                        RST;                    /**< \brief 60010, */
       __IO Ifx_EGTM_PROT                       PROTSE;                 /**< \brief 6001C, PROT register Safe Endinit*/
       __IO Ifx_EGTM_CL                         CL[3];                  /**< \brief 60020, Protection per cluster*/
       __I  Ifx_UReg_8Bit                       reserved_6008C[324];    /**< \brief 6008C, \internal Reserved */
       __IO Ifx_EGTM_CTRL                       CTRL;                   /**< \brief 601D0, Protection of UBS Registers*/
       __IO Ifx_EGTM_WRAP                       WRAP;                   /**< \brief 601F4, Protection of Wrapper Registers*/
       __IO Ifx_EGTM_CTRLGTM                    CTRLGTM;                /**< \brief 60218, Protection of CMU, TBU, ICM ,DPLL, ARCH and AEI related registers*/
       __IO Ifx_EGTM_SAFEGTM                    SAFEGTM;                /**< \brief 6023C, Protection of CMP and MON*/
       __I  Ifx_UReg_8Bit                       reserved_60260[544];    /**< \brief 60260, \internal Reserved */
       __IO Ifx_EGTM_SPARE                      SPARE;                  /**< \brief 60480, Spare Bits*/
       __I  Ifx_UReg_8Bit                       reserved_60484[124];    /**< \brief 60484, \internal Reserved */
       __IO Ifx_EGTM_OCDS                       OCDS;                   /**< \brief 60500, Hardware breakpoint enable register*/
       __I  Ifx_UReg_8Bit                       reserved_60518[2792];    /**< \brief 60518, \internal Reserved */
       __IO Ifx_EGTM_TIMINSEL                   TIMINSEL[3];            /**< \brief 61000, TIM0 input selection register*/
       __I  Ifx_UReg_8Bit                       reserved_6100C[68];     /**< \brief 6100C, \internal Reserved */
       __IO Ifx_EGTM_TIMINSELB                  TIMINSELB[3];           /**< \brief 61050, TIM0 input selection register group B*/
       __I  Ifx_UReg_8Bit                       reserved_6105C[164];    /**< \brief 6105C, \internal Reserved */
       __IO Ifx_EGTM_TOUTSEL                    TOUTSEL[49];            /**< \brief 61100, eGTM to Ports signal TOUT output selection register 0*/
       __I  Ifx_UReg_8Bit                       reserved_611C4[60];     /**< \brief 611C4, \internal Reserved */
       __IO Ifx_EGTM_MSCSET                     MSCSET[4];              /**< \brief 61200, */
       __I  Ifx_UReg_8Bit                       reserved_61240[80];     /**< \brief 61240, \internal Reserved */
       __IO Ifx_EGTM_MSC                        MSC[3];                 /**< \brief 61290, */
       __I  Ifx_UReg_8Bit                       reserved_612C0[16];     /**< \brief 612C0, \internal Reserved */
       __IO Ifx_EGTM_MSCSELIN                   MSCSELIN;               /**< \brief 612D0, MSC select incoming stream*/
       __I  Ifx_UReg_8Bit                       reserved_612E0[288];    /**< \brief 612E0, \internal Reserved */
       __IO Ifx_EGTM_PSI5                       PSI5;                   /**< \brief 61400, eGTM to PSI5 output trigger selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61404[12];     /**< \brief 61404, \internal Reserved */
       __IO Ifx_EGTM_PSI5S                      PSI5S[2];               /**< \brief 61410, eGTM to PSI5-S0 output trigger selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61418[8];      /**< \brief 61418, \internal Reserved */
       __IO Ifx_EGTM_LCDCDC                     LCDCDC;                 /**< \brief 61420, eGTM to LCDCDC output trigger selection register*/
       __I  Ifx_UReg_8Bit                       reserved_61424[92];     /**< \brief 61424, \internal Reserved */
       __IO Ifx_EGTM_CAN                        CAN[6];                 /**< \brief 61480, */
       __I  Ifx_UReg_8Bit                       reserved_614E0[32];     /**< \brief 614E0, \internal Reserved */
       __I  Ifx_EGTM_FOUTENC                    FOUTENC[1];             /**< \brief 61500, FOUT Selection for Encoder Interface 0*/
       __I  Ifx_UReg_8Bit                       reserved_61504[124];    /**< \brief 61504, \internal Reserved */
       __IO Ifx_EGTM_QSPI                       QSPI[8];                /**< \brief 61580, eGTM to QSPI0 output selection register. 0<8 then interface exists.*/
       __I  Ifx_UReg_8Bit                       reserved_615A0[96];     /**< \brief 615A0, \internal Reserved */
       __IO Ifx_EGTM_ASCLIN                     ASCLIN[28];             /**< \brief 61600, eGTM to ASCLIN0 output selection register. 0<28 then interface exists.*/
       __I  Ifx_UReg_8Bit                       reserved_61670[16];     /**< \brief 61670, \internal Reserved */
       __IO Ifx_EGTM_SENT                       SENT[2];                /**< \brief 61680, */
       __I  Ifx_UReg_8Bit                       reserved_61690[112];    /**< \brief 61690, \internal Reserved */
       __IO Ifx_EGTM_ADC                        ADC;                    /**< \brief 61700, */
       __I  Ifx_UReg_8Bit                       reserved_6170C[116];    /**< \brief 6170C, \internal Reserved */
       __IO Ifx_EGTM_DTMAUX                     DTMAUX[3];              /**< \brief 61780, */
       __I  Ifx_UReg_8Bit                       reserved_61798[104];    /**< \brief 61798, \internal Reserved */
       __IO Ifx_EGTM_SCU                        SCU;                    /**< \brief 61800, */
       __I  Ifx_UReg_8Bit                       reserved_6180C[52];     /**< \brief 6180C, \internal Reserved */
       __IO Ifx_EGTM_DITH                       DITH0;                  /**< \brief 61840, */
       __IO Ifx_EGTM_DITH                       DITH1;                  /**< \brief 61860, */
       __IO Ifx_EGTM_DITH                       DITH2;                  /**< \brief 61880, */
       __I  Ifx_UReg_8Bit                       reserved_618A0[608];    /**< \brief 618A0, \internal Reserved */
       __IO Ifx_EGTM_TIMS                       TIMS[3];                /**< \brief 61B00, */
       __I  Ifx_UReg_8Bit                       reserved_61B60[5280];    /**< \brief 61B60, \internal Reserved */
} Ifx_EGTM;

/** \}  */
/******************************************************************************/
/** \}  */

/******************************************************************************/
#if defined (_TASKING_)
#pragma restore
#endif
/******************************************************************************/

/******************************************************************************/

/******************************************************************************/

#endif /* IFXEGTM_REGDEF_H */
