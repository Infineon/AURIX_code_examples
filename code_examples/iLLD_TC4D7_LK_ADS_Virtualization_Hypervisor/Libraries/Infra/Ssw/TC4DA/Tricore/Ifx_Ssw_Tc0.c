/**
 * \file Ifx_Ssw_Tc0.c
 * \brief Startup Software for Core0
 *
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2025-02-12 06:00:55
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/*******************************************************************************
**                      Includes                                              **
*******************************************************************************/
#include "Ifx_Cfg.h"
#include "Ifx_Ssw.h"
#include "Ifx_Ssw_Infra.h"
#include "Ifx_Cfg_Ssw.h"
#include "IfxHv_CpuVmSched.h"
#include "IfxCpu_reg.h"
#include "Ifx_Cfg_Vm1.h"
/*******************************************************************************
**                       Macros                                               **
*******************************************************************************/
#ifndef IFX_CFG_SSW_ENABLE_TRICORE0_PCACHE
#define IFX_CFG_SSW_ENABLE_TRICORE0_PCACHE (1U)
#endif

#ifndef IFX_CFG_SSW_ENABLE_TRICORE0_DCACHE
#define IFX_CFG_SSW_ENABLE_TRICORE0_DCACHE (1U)
#endif

/*******************************************************************************
**                       Prototypes & Externals                               **
*******************************************************************************/
/** !IMPORTANT: The SSW Configuration shall be defined at Application SW Configuration
 * Please refer to iLLD demos for startup sw configuration (Ifx_Cfg_Ssw.c and .h)
 */
IFX_SSW_USED static void __StartUpSoftware(void);
IFX_SSW_USED static void __StartUpSoftware_Phase2(void);
IFX_SSW_USED static void __StartUpSoftware_Phase3(void);
IFX_SSW_USED static void __StartUpSoftware_Phase4(void);
IFX_SSW_USED static void __StartUpSoftware_Phase5(void);
IFX_SSW_USED static void __StartUpSoftware_Phase6(void);
IFX_SSW_USED static void __StartUpSoftware_Phase7MulticoreStartup(void);
IFX_SSW_USED static void __StartUpSoftware_KeyoffPhase(void);
IFX_SSW_USED static void __Core0_start(void);
IFX_SSW_COMMON_LINKER_SYMBOLS();
IFX_SSW_CORE_LINKER_SYMBOLS(0, 0);
IFX_SSW_CORE_LINKER_SYMBOLS(0, 1);
IFX_SSW_CORE_LINKER_SYMBOLS(0, 2);
IFX_SSW_CORE_LINKER_SYMBOLS(0, 3);
IFX_SSW_CORE_LINKER_SYMBOLS(0, 4);
IFX_SSW_CORE_LINKER_SYMBOLS(0, 5);
IFX_SSW_CORE_LINKER_SYMBOLS(0, 6);
IFX_SSW_CORE_LINKER_SYMBOLS(0, 7);


/* Dummy definitions to prevent Pre-fetch SMU alarms */
IFX_SSW_WEAK void Ifx_Ssw_Pms_Init(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Pms_InitCheck(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Lbist(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Monbist(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_PowerOnCrystalOsc(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_MbistDsprsDmaRam(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_CsrmSync_B(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_ShutdownPwrDomains(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Mbist(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_CsrmSync_C(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Pmic_VoltageShift(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Autosar_ServicesStart(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_XtalSrc_Check(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_PllInit(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_CsrmSync_D(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Smu(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_SafetyLibraryTests(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_AP_Init(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_MultiCore_Sync_Cpu0(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Keyoff_Lbist(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Keyoff_Mbist(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Keyoff_SafetyLibraryTests(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_Keyoff_MbistDsprsDmaRam(void)
{}

IFX_SSW_WEAK void Ifx_Ssw_FwCheck(void)
{}
/*******************************************************************************
**                       Defines                                              **
*******************************************************************************/

extern void core0_vm1_main(void);
extern void core0_vm2_main(void);
extern void core0_vm3_main(void);
extern void core0_vm4_main(void);
extern void core0_vm5_main(void);
extern void core0_vm6_main(void);
extern void core0_vm7_main(void);

#if defined(__TASKING__)
__asm("\t .extern core0_vm1_main");
__asm("\t .extern core0_vm2_main");
__asm("\t .extern core0_vm3_main");
__asm("\t .extern core0_vm4_main");
__asm("\t .extern core0_vm5_main");
__asm("\t .extern core0_vm6_main");
__asm("\t .extern core0_vm7_main");
#endif

static void __StartUpSoftware(void)
{
    /* By default mapped to empty, skip only if configured */
    IFX_CFG_SSW_SKIP_STARTUP_ROUTINE(0);

    /* Trap vector table initialization is necessary if it is not same as default value */
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(0, 0));


    /*Initialize the context save area for CPU0. Function Calls Possible */
    /* Setup the context save area linked list to PSPR */
    Ifx_Ssw_initCSA((unsigned int *)IFX_CFG_SSW_CSA_BOOT_PTR_START, (unsigned int *)IFX_CFG_SSW_CSA_BOOT_PTR_END);

    /* Set the PSW to its reset value in case of a warm start,clear PSW.IS */
    Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);

    /* Initialize A1 pointer to use the global constants with small data addressing */
    Ifx_Ssw_setAddressReg(a1, __SDATA2(0));
    /* Set A0 Pointer to access global variables with small data addressing */
    Ifx_Ssw_setAddressReg(a0, __SDATA1(0));
    /* These to be un commented if A8 and A9 are required to be initialized */
    Ifx_Ssw_setAddressReg(a8, __SDATA3(0));
    Ifx_Ssw_setAddressReg(a9, __SDATA4(0));

	{	
		unsigned short cpuWdtPassword    = Ifx_Ssw_getCpuWatchdogPasswordInline(&MODULE_WTU.WDTCPU[0]);
		unsigned short systemWdtPassword = Ifx_Ssw_getSystemWatchdogPasswordInline();

		/* servicing watchdog timers */
		Ifx_Ssw_serviceCpuWatchdog(&MODULE_WTU.WDTCPU[0], cpuWdtPassword);
		Ifx_Ssw_serviceSystemWatchdog(systemWdtPassword);
	}
	
	/* FW_Check incl. SMU Alarm Flag check */
    Ifx_Ssw_FwCheck();
    
    /* This phase is executed only if last reset is not of type application reset */
    if (Ifx_Ssw_isApplicationReset() != 1U)
    {
        Ifx_Ssw_jumpToFunction(__StartUpSoftware_Phase2);
    }
    else
    {
        if(Ifx_Ssw_isKeyoffMarkerSet())
		{
			Ifx_Ssw_jumpToFunction(__StartUpSoftware_KeyoffPhase);
		}
		else
		{
		    /* Initialize the CSA and stack pointer */
            IFX_SSW_INIT_CONTEXT(0,0);

            /* Initialization of C runtime variables and CPP constructors and destructors */
            (void)Ifx_Ssw_doCppInit();
			Ifx_Ssw_jumpToFunction(__StartUpSoftware_Phase6);
		}
    }
}


static void __StartUpSoftware_Phase2(void)
{
    /* Power and EVRC configurations */
    Ifx_Ssw_Pms_Init();

    /* Power and EVRC Checks */
    Ifx_Ssw_Pms_InitCheck();

	{	
		unsigned short cpuWdtPassword    = Ifx_Ssw_getCpuWatchdogPasswordInline(&MODULE_WTU.WDTCPU[0]);
		unsigned short systemWdtPassword = Ifx_Ssw_getSystemWatchdogPasswordInline();

		/* servicing watchdog timers */
		Ifx_Ssw_serviceCpuWatchdog(&MODULE_WTU.WDTCPU[0], cpuWdtPassword);
		Ifx_Ssw_serviceSystemWatchdog(systemWdtPassword);
	}

    Ifx_Ssw_jumpToFunction(__StartUpSoftware_Phase3);
}


static void __StartUpSoftware_Phase3(void)
{
    /* LBIST Tests and evaluation */
    Ifx_Ssw_Lbist();

    /* MONBIST Tests and evaluation */
    Ifx_Ssw_Monbist();
    
    {
    	unsigned short cpuWdtPassword    = Ifx_Ssw_getCpuWatchdogPasswordInline(&MODULE_WTU.WDTCPU[0]);
    	unsigned short systemWdtPassword = Ifx_Ssw_getSystemWatchdogPasswordInline();

    	/* Prolong the watchdog timeout to ~20ms considering Fspb=50MHz, it will become ~10ms after PLL init as Fspb=100MHz */
    	Ifx_Ssw_changeCpuWatchdogReload(&MODULE_WTU.WDTCPU[0], cpuWdtPassword, (IFX_CFG_SSW_WDG_RELOAD_VALUE));
    	Ifx_Ssw_changeSystemWatchdogReload(systemWdtPassword, (IFX_CFG_SSW_WDG_RELOAD_VALUE));
    }
    
    /* MBIST Tests and Evaluation on DSPR0-5 and DMARAM */
    Ifx_Ssw_MbistDsprsDmaRam();

    /* CSRM SYNC Point */
    Ifx_Ssw_CsrmSync_B();
    
    /* Initialize the CSA and stack pointer */
	IFX_SSW_INIT_CONTEXT(0,0);

    /* MBIST Tests and evaluation for SSHs other than DSPR0-5 and DMARAM */
    Ifx_Ssw_Mbist();
    
    /* Hook functions to initialize application specific HW extensions */
    hardware_init_hook();

    /* Initialization of C runtime variables and CPP constructors and destructors */
    (void)Ifx_Ssw_doCppInit();
	
    /* Hook functions to initialize application specific SW extensions */
    software_init_hook();
	
    Ifx_Ssw_jumpToFunction(__StartUpSoftware_Phase4);
}


static void __StartUpSoftware_Phase4(void)
{
    /* Shutdown PowerDomains which are not used */
    Ifx_Ssw_ShutdownPwrDomains();
    
    /* PMIC Voltage Shift */
    Ifx_Ssw_Pmic_VoltageShift();
        
    /* CSRM SYNC Point */
    Ifx_Ssw_CsrmSync_C();

    /* AUTOSAR Services start */
    Ifx_Ssw_Autosar_ServicesStart();

    Ifx_Ssw_jumpToFunction(__StartUpSoftware_Phase5);
}


static void __StartUpSoftware_Phase5(void)
{
    {
        /* Update safety and cpu watchdog reload value*/
        unsigned short cpuWdtPassword    = Ifx_Ssw_getCpuWatchdogPasswordInline(&MODULE_WTU.WDTCPU[0]);
        unsigned short systemWdtPassword = Ifx_Ssw_getSystemWatchdogPasswordInline();

        /* servicing watchdog timers */
        Ifx_Ssw_serviceCpuWatchdog(&MODULE_WTU.WDTCPU[0], cpuWdtPassword);
        Ifx_Ssw_serviceSystemWatchdog(systemWdtPassword);
    }
    
	#if (IFX_CFG_SSW_ENABLE_PLL_INIT == 1)
		/* Switch on XTAL, since the Crystal needs ~3ms to stabilize */
		Ifx_Ssw_PowerOnCrystalOsc();
	
        /* Check if the input clock is stable, e.g MMIC source */
        Ifx_Ssw_XtalSrc_Check();
	
        /* Initialize the clock system and Configure Flash Wait States */
        Ifx_Ssw_PllInit();
	#endif /* IFX_CFG_SSW_ENABLE_PLL_INIT == 1 */

    Ifx_Ssw_jumpToFunction(__StartUpSoftware_Phase6);
}


static void __StartUpSoftware_Phase6(void)
{
    /* SMU alarm handling */
    Ifx_Ssw_Smu();

    {
        /* Update safety and cpu watchdog reload value*/
        unsigned short cpuWdtPassword    = Ifx_Ssw_getCpuWatchdogPasswordInline(&MODULE_WTU.WDTCPU[0]);
        unsigned short systemWdtPassword = Ifx_Ssw_getSystemWatchdogPasswordInline();

        /* servicing watchdog timers */
        Ifx_Ssw_serviceCpuWatchdog(&MODULE_WTU.WDTCPU[0], cpuWdtPassword);
        Ifx_Ssw_serviceSystemWatchdog(systemWdtPassword);
    }
    
    /* Safety Library Tests */
    Ifx_Ssw_SafetyLibraryTests();

    Ifx_Ssw_jumpToFunction(__StartUpSoftware_Phase7MulticoreStartup);
}


static void __StartUpSoftware_Phase7MulticoreStartup(void)
{
    /* PROT and APU related configurations */
    Ifx_Ssw_AP_Init();

    Ifx_Ssw_Barrier();

    /* Start remaining cores */
#if (IFX_CFG_SSW_ENABLE_TRICORE1 != 0)
    Ifx_Ssw_startCore(&MODULE_CPU1, (unsigned int)__START(1, 0));           /*The status returned by function call is ignored */
    /* 100uS delay in subsequent CPU start */
    Ifx_Ssw_delay();
#endif /* #if (IFX_CFG_CPU_CSTART_ENABLE_TRICORE1 != 0)*/

#if (IFX_CFG_SSW_ENABLE_TRICORE2 != 0)
    Ifx_Ssw_startCore(&MODULE_CPU2, (unsigned int)__START(2, 0));           /*The status returned by function call is ignored */
    /* 100uS delay in subsequent CPU start */
    Ifx_Ssw_delay();
#endif /* #if (IFX_CFG_CPU_CSTART_ENABLE_TRICORE2 != 0)*/

#if (IFX_CFG_SSW_ENABLE_TRICORE3 != 0)
    Ifx_Ssw_startCore(&MODULE_CPU3, (unsigned int)__START(3, 0));           /*The status returned by function call is ignored */
    /* 100uS delay in subsequent CPU start */
    Ifx_Ssw_delay();
#endif /* #if (IFX_CFG_CPU_CSTART_ENABLE_TRICORE3 != 0)*/

#if (IFX_CFG_SSW_ENABLE_TRICORE4 != 0)
    Ifx_Ssw_startCore(&MODULE_CPU4, (unsigned int)__START(4, 0));           /*The status returned by function call is ignored */
    /* 100uS delay in subsequent CPU start */
    Ifx_Ssw_delay();
#endif /* #if (IFX_CFG_CPU_CSTART_ENABLE_TRICORE4 != 0)*/

#if (IFX_CFG_SSW_ENABLE_TRICORE5 != 0)
    Ifx_Ssw_startCore(&MODULE_CPU5, (unsigned int)__START(5, 0));           /*The status returned by function call is ignored */
#endif /* #if (IFX_CFG_CPU_CSTART_ENABLE_TRICORE5 != 0)*/


    /* CSRM SYNC Point */
    Ifx_Ssw_CsrmSync_D();
    
    Ifx_Ssw_jumpToFunction(__Core0_start);
}


static void __Core0_start(void)
{
    /* Enable/ Disable the caches depending on the configuration. At this point cache are invalidated */
    {
        Ifx_CPU_PCON0 pcon0;
        pcon0.U       = 0;
        pcon0.B.PCBYP = IFX_CFG_SSW_ENABLE_TRICORE0_PCACHE ? 0 : 1; /* depending on the enable bypass bit is reset/set */
        Ifx_Ssw_MTCR(CPU_PCON0, pcon0.U);
    }

    {
        Ifx_CPU_DCON0 dcon0;
        dcon0.U       = 0;
        dcon0.B.DCBYP = IFX_CFG_SSW_ENABLE_TRICORE0_DCACHE ? 0 : 1; /* depending on the enable bypass bit is reset/set */
        Ifx_Ssw_MTCR(CPU_DCON0, dcon0.U);
    }

    /* Trap vector table for HV mode initialization is necessary when HV mode is enabled */
    Ifx_Ssw_MTCR(CPU_BHV, (unsigned int)__TRAPTABHV_CPU00);
    /* Load Base Address of Trap Vector Table. */
    Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(0, 0));

    /* Base interrupt vector table initialized */
    Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(0, 0));
    /* Interrupt stack pointer is configured */
    Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(0, 0));

#if (IFX_CFG_SSW_ENABLE_TRICORE0 == 0)
    /* Set the CPU 0 to Idle mode, if it is not needed to be enabled */
    Ifx_Ssw_setCpu0Idle();
#endif

    /* MultiCore synchronization hooks to execute Safety Library tests */
    Ifx_Ssw_MultiCore_Sync_Cpu0();

    {
    	unsigned short cpuWdtPassword    = Ifx_Ssw_getCpuWatchdogPasswordInline(&MODULE_WTU.WDTCPU[0]);
    	unsigned short systemWdtPassword = Ifx_Ssw_getSystemWatchdogPasswordInline();

    	/* Reducing the timeout again to initial*/
    	Ifx_Ssw_changeCpuWatchdogReload(&MODULE_WTU.WDTCPU[0], cpuWdtPassword, (IFX_CFG_SSW_WDG_INITIAL_VALUE));
    	Ifx_Ssw_changeSystemWatchdogReload(systemWdtPassword, (IFX_CFG_SSW_WDG_INITIAL_VALUE));
    }
    
    /*Call Hypervisor Function */
    Ifx_Ssw_jumpToFunction(core0_vm0_start);
}


IFX_SSW_USED static void core_vm1_start(void)
{
	IFX_SSW_CORE_VM_START(0,1);

    /* Call main function of CPU0 VM 1 */
    Ifx_Ssw_jumpToFunction(core0_vm1_main);
}

IFX_SSW_USED static void core_vm2_start(void)
{
	IFX_SSW_CORE_VM_START(0,2);

    /* Call main function of CPU0 VM 2 */
    Ifx_Ssw_jumpToFunction(core0_vm2_main);
}

IFX_SSW_USED static void core_vm3_start(void)
{
	IFX_SSW_CORE_VM_START(0,3);

    /* Call main function of CPU0 VM 3 */
    Ifx_Ssw_jumpToFunction(core0_vm3_main);
}

IFX_SSW_USED static void core_vm4_start(void)
{
	IFX_SSW_CORE_VM_START(0,4);

    /* Call main function of CPU0 VM 4 */
    Ifx_Ssw_jumpToFunction(core0_vm4_main);
}

IFX_SSW_USED static void core_vm5_start(void)
{
	IFX_SSW_CORE_VM_START(0,5);

    /* Call main function of CPU0 VM 5 */
    Ifx_Ssw_jumpToFunction(core0_vm5_main);
}

IFX_SSW_USED static void core_vm6_start(void)
{
	IFX_SSW_CORE_VM_START(0,6);

    /* Call main function of CPU0 VM 6 */
    Ifx_Ssw_jumpToFunction(core0_vm6_main);
}

IFX_SSW_USED static void core_vm7_start(void)
{
	IFX_SSW_CORE_VM_START(0,7);

    /* Call main function of CPU0 VM 7 */
    Ifx_Ssw_jumpToFunction(core0_vm7_main);
}



static void __StartUpSoftware_KeyoffPhase(void)
{
	/* Key-off LBIST Tests and evaluation */
    Ifx_Ssw_Keyoff_Lbist();

    {
    	unsigned short cpuWdtPassword    = Ifx_Ssw_getCpuWatchdogPasswordInline(&MODULE_WTU.WDTCPU[0]);
    	unsigned short systemWdtPassword = Ifx_Ssw_getSystemWatchdogPasswordInline();

    	Ifx_Ssw_changeCpuWatchdogReload(&MODULE_WTU.WDTCPU[0], cpuWdtPassword, (IFX_CFG_SSW_WDG_RELOAD_VALUE));
    	Ifx_Ssw_changeSystemWatchdogReload(systemWdtPassword, (IFX_CFG_SSW_WDG_RELOAD_VALUE));
    }
    /* MBIST Tests and Evaluation for RAMs in FAILID excl. PSPR0 */
    Ifx_Ssw_Keyoff_MbistDsprsDmaRam();

    /* Initialize the CSA and stack pointer */
	IFX_SSW_INIT_CONTEXT(0,0);

    /* MBIST Tests for remaining */
    Ifx_Ssw_Keyoff_Mbist();
    
    /* Key-off assigned tests (LFM) and store result */
    Ifx_Ssw_Keyoff_SafetyLibraryTests();

	/* Clear Key-off Marker, normally the code shall not reach here */
	Ifx_Ssw_clearKeyoffMarker();

	/* Go into infinite loop */
    Ifx_Ssw_infiniteLoop();

}

/******************************************************************************
 *                        reset vector address                                *
 *****************************************************************************/
#if defined(__TASKING__)
#pragma protect on
#pragma section code "start"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start" x
#elif defined(__DCC__)
#pragma section CODE ".start" X
#elif defined(__ghs__)
#pragma ghs section text=".start"
#endif

IFX_SSW_USED void _START(void)
{
	Ifx_Ssw_Start(IFX_CFG_SSW_CSA_USTACK_PTR, __StartUpSoftware);
}


/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

#if defined(__TASKING__)
#pragma protect on
#pragma section code "start_cpu01"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start_cpu01" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start_cpu01"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start_cpu01" x
#elif defined(__DCC__)
#pragma section CODE ".start_cpu01" X
#elif defined(__ghs__)
#pragma ghs section text=".start_cpu01"
#endif

IFX_SSW_USED void _START01(void)
{
    Ifx_Ssw_jumpToFunction(core_vm1_start);
}

/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

#if defined(__TASKING__)
#pragma protect on
#pragma section code "start_cpu02"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start_cpu02" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start_cpu02"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start_cpu02" x
#elif defined(__DCC__)
#pragma section CODE ".start_cpu02" X
#elif defined(__ghs__)
#pragma ghs section text=".start_cpu02"
#endif

IFX_SSW_USED void _START02(void)
{
    Ifx_Ssw_jumpToFunction(core_vm2_start);
}

/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

#if defined(__TASKING__)
#pragma protect on
#pragma section code "start_cpu03"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start_cpu03" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start_cpu03"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start_cpu03" x
#elif defined(__DCC__)
#pragma section CODE ".start_cpu03" X
#elif defined(__ghs__)
#pragma ghs section text=".start_cpu03"
#endif

IFX_SSW_USED void _START03(void)
{
    Ifx_Ssw_jumpToFunction(core_vm3_start);
}

/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

#if defined(__TASKING__)
#pragma protect on
#pragma section code "start_cpu04"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start_cpu04" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start_cpu04"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start_cpu04" x
#elif defined(__DCC__)
#pragma section CODE ".start_cpu04" X
#elif defined(__ghs__)
#pragma ghs section text=".start_cpu04"
#endif

IFX_SSW_USED void _START04(void)
{
    Ifx_Ssw_jumpToFunction(core_vm4_start);
}

/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

#if defined(__TASKING__)
#pragma protect on
#pragma section code "start_cpu05"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start_cpu05" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start_cpu05"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start_cpu05" x
#elif defined(__DCC__)
#pragma section CODE ".start_cpu05" X
#elif defined(__ghs__)
#pragma ghs section text=".start_cpu05"
#endif

IFX_SSW_USED void _START05(void)
{
    Ifx_Ssw_jumpToFunction(core_vm5_start);
}

/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

#if defined(__TASKING__)
#pragma protect on
#pragma section code "start_cpu06"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start_cpu06" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start_cpu06"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start_cpu06" x
#elif defined(__DCC__)
#pragma section CODE ".start_cpu06" X
#elif defined(__ghs__)
#pragma ghs section text=".start_cpu06"
#endif

IFX_SSW_USED void _START06(void)
{
    Ifx_Ssw_jumpToFunction(core_vm6_start);
}

/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

#if defined(__TASKING__)
#pragma protect on
#pragma section code "start_cpu07"
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#pragma section ".start_cpu07" x
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=".start_cpu07"
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#pragma section ".start_cpu07" x
#elif defined(__DCC__)
#pragma section CODE ".start_cpu07" X
#elif defined(__ghs__)
#pragma ghs section text=".start_cpu07"
#endif

IFX_SSW_USED void _START07(void)
{
    Ifx_Ssw_jumpToFunction(core_vm7_start);
}

/* reset the sections defined above, to normal region */
#if defined(__TASKING__)
#pragma protect restore
#pragma section code restore
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma section
#elif defined(__HIGHTEC__) && defined(__clang__)
#pragma clang section text=""
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma section
#elif defined(__DCC__)
#pragma section CODE
#elif defined(__ghs__)
#pragma ghs section text=default
#endif

