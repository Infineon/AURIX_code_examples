/**
 * \file Ifx_Ssw_Infra.h
 * \brief Startup Software support functions.
 *
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2024-05-30 13:40:02
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#ifndef IFX_SSW_INFRA_H
#define IFX_SSW_INFRA_H 1

#include "Ifx_Ssw_Compilers.h"
#include "Ifx_Cfg_Ssw.h"
#include "IfxCpu_reg.h"
#include "IfxCpu_bf.h"
#include "IfxWtu_reg.h"
#include "IfxWtu_bf.h"
#include "IfxSmm_reg.h"
#include "IfxSmm_bf.h"
#include "IfxClock_reg.h"
#include "IfxQspi_reg.h"
#include "IfxPort_reg.h"
#include "IfxPms_reg.h"
#include "IfxVmt_reg.h"
#include "IfxVmt_bf.h"
/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Mask values is used to invert the password value bits */
#define IFX_SSW_WDT_PASSWORD_INVERT_MSK             (0x007FU)

/** \brief Disable write protection  */
#define IFX_SSW_PMIC_DISABLE_PROTECTION             (0x0D02B5CAU)

/** \brief Enable write protection  */
#define IFX_SSW_PMIC_ENABLE_PROTECTION              (0x5502D396U)

/** \brief PMIC core voltage */
#define IFX_SSW_PMIC_CORE_VOLTAGE_0_95V             (0x1800D838U)

/** \brief PMIC core voltage */
#define IFX_SSW_PMIC_CORE_VOLTAGE_1V                (0x6F00D438U)

/** \brief CSA size */
#define IFX_SSW_CSA_SIZE                            16U

/* \brief CSA START pointer in PSPR0 location */
#ifndef IFX_CFG_SSW_CSA_BOOT_PTR_START
#define IFX_CFG_SSW_CSA_BOOT_PTR_START              (0x7010EC00)
#endif

/* \brief CSA END pointer in PSPR0 location */
#ifndef IFX_CFG_SSW_CSA_BOOT_PTR_END
#define IFX_CFG_SSW_CSA_BOOT_PTR_END                (0x7010FC00)
#endif

/* \brief USTACK pointer in PSPR0 location */
#ifndef IFX_CFG_SSW_CSA_USTACK_PTR
#define IFX_CFG_SSW_CSA_USTACK_PTR                  (0x7010EB00)
#endif

#ifndef IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS
#define IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS   (0.0001)
#endif

#ifndef IFX_CFG_SSW_EVR_OSC_FREQUENCY
#define IFX_CFG_SSW_EVR_OSC_FREQUENCY               (100000000.0)
#endif

#ifndef IFX_CFG_SSW_SYSCLK_PIN_FREQUENCY
#define IFX_CFG_SSW_SYSCLK_PIN_FREQUENCY            (20000000.0)
#endif

#ifndef IFX_CFG_SSW_XTAL_FREQUENCY
#define IFX_CFG_SSW_XTAL_FREQUENCY                  (IFX_CFG_CLOCK_XTAL_FREQUENCY)
#endif

#ifndef IFX_CFG_SSW_CCUCON_LCK_BIT_TIMEOUT_COUNT
#define IFX_CFG_SSW_CCUCON_LCK_BIT_TIMEOUT_COUNT    (0x1000U)
#endif

#ifndef IFX_CFG_SSW_QSPI_KERNEL_RESET_TIMEOUT_COUNT
#define IFX_CFG_SSW_QSPI_KERNEL_RESET_TIMEOUT_COUNT (0x1000U)
#endif

#ifndef IFX_CFG_SSW_QSPI_FIFO_EMPTY_TIMEOUT_COUNT
#define IFX_CFG_SSW_QSPI_FIFO_EMPTY_TIMEOUT_COUNT   (0xC350U)
#endif

#ifndef IFX_CFG_SSW_QSPI_CLOCK_ENABLE_TIMEOUT_COUNT
#define IFX_CFG_SSW_QSPI_CLOCK_ENABLE_TIMEOUT_COUNT (0x1000U)
#endif

#ifndef IFX_CFG_SSW_CLOCK_EXT_CLOCK
#define IFX_CFG_SSW_CLOCK_EXT_CLOCK                 (0U)
#endif

#ifndef IFX_CFG_SSW_PCXI
#define IFX_CFG_SSW_PCXI                            (0x3C0041U)
#endif

#ifndef IFX_CFG_SSW_CSA_PTR
#define IFX_CFG_SSW_CSA_PTR(val)                                               \
    ((unsigned int)((unsigned int)val & ((unsigned int)0XFU << 28U)) >> 12U) | \
    ((unsigned int)((unsigned int)val & ((unsigned int)0XFFFFU << 6U)) >> 6U)
#endif

#define IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(tVar, tErr) \
    {                                              \
        if (((signed int)--tVar) <= 0)             \
        {                                          \
            tErr = (unsigned char)1;               \
            break;                                 \
        }                                          \
        else                                       \
        {                                          \
        }                                          \
    }

/* QSPI module */
#ifndef IFX_CFG_SSW_MODULE_QSPI_PMIC
#define IFX_CFG_SSW_MODULE_QSPI_PMIC        MODULE_QSPI2
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_MTSR_PORT
#define IFX_CFG_SSW_MODULE_QSPI_MTSR_PORT   MODULE_P15
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_MTSR_PIN
#define IFX_CFG_SSW_MODULE_QSPI_MTSR_PIN    (6U)
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_MTSR_ALTSEL
#define IFX_CFG_SSW_MODULE_QSPI_MTSR_ALTSEL (3U)
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_MRST_PORT
#define IFX_CFG_SSW_MODULE_QSPI_MRST_PORT   MODULE_P15
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_MRST_PIN
#define IFX_CFG_SSW_MODULE_QSPI_MRST_PIN    (7U)
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_MRST_ALTSEL
#define IFX_CFG_SSW_MODULE_QSPI_MRST_ALTSEL (1U)
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_SCLK_PORT
#define IFX_CFG_SSW_MODULE_QSPI_SCLK_PORT   MODULE_P15
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_SCLK_PIN
#define IFX_CFG_SSW_MODULE_QSPI_SCLK_PIN    (8U)
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_SCLK_ALTSEL
#define IFX_CFG_SSW_MODULE_QSPI_SCLK_ALTSEL (3U)
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_SLSO_PORT
#define IFX_CFG_SSW_MODULE_QSPI_SLSO_PORT   MODULE_P15
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_SLSO_PIN
#define IFX_CFG_SSW_MODULE_QSPI_SLSO_PIN    (2U)
#endif

#ifndef IFX_CFG_SSW_MODULE_QSPI_SLSO_ALTSEL
#define IFX_CFG_SSW_MODULE_QSPI_SLSO_ALTSEL (3U)
#endif

#ifndef IFX_CFG_SSW_QSPI_SLSO
#define IFX_CFG_SSW_QSPI_SLSO               (0)
#endif

#ifndef IFX_CFG_SSW_QSPI_MRIS
#define IFX_CFG_SSW_QSPI_MRIS               (0x1) // MRST2B;
#endif

#define IFX_CFG_SSW_SET_PORT_MTSR(port, pin, altSel) \
    {                                                \
        Ifx_P_PADCFG_DRVCFG drvCfg;                  \
        drvCfg.B.DIR              = 1u;              \
        drvCfg.B.MODE             = altSel;          \
        drvCfg.B.OD               = 0u;              \
        drvCfg.B.PD               = 0u;              \
        drvCfg.B.PL               = 0u;              \
        port.PADCFG[pin].DRVCFG.U = drvCfg.U;        \
    }

#define IFX_CFG_SSW_SET_PORT_MRST(port, pin, altSel) \
    {                                                \
        Ifx_P_PADCFG_DRVCFG drvCfg;                  \
        drvCfg.B.DIR              = 0u;              \
        drvCfg.B.MODE             = altSel;          \
        drvCfg.B.OD               = 0u;              \
        drvCfg.B.PD               = 0u;              \
        drvCfg.B.PL               = 0u;              \
        port.PADCFG[pin].DRVCFG.U = drvCfg.U;        \
    }

#define IFX_CFG_SSW_SET_PORT_SCLK(port, pin, altSel) \
    {                                                \
        Ifx_P_PADCFG_DRVCFG drvCfg;                  \
        drvCfg.B.DIR              = 1u;              \
        drvCfg.B.MODE             = altSel;          \
        drvCfg.B.OD               = 0u;              \
        drvCfg.B.PD               = 0u;              \
        drvCfg.B.PL               = 0u;              \
        port.PADCFG[pin].DRVCFG.U = drvCfg.U;        \
    }

#define IFX_CFG_SSW_SET_PORT_SLSO(port, pin, altSel) \
    {                                                \
        Ifx_P_PADCFG_DRVCFG drvCfg;                  \
        drvCfg.B.DIR              = 1u;              \
        drvCfg.B.MODE             = altSel;          \
        drvCfg.B.OD               = 0u;              \
        drvCfg.B.PD               = 0u;              \
        drvCfg.B.PL               = 0u;              \
        port.PADCFG[pin].DRVCFG.U = drvCfg.U;        \
    }

/* \brief Macro to select if the user wants to return from main */
#ifndef IFX_CFG_SSW_RETURN_FROM_MAIN
#define IFX_CFG_SSW_RETURN_FROM_MAIN (0U)
#endif

/* Workaround done as below to Maintain backward compatibility */
#ifdef IFX_CFG_SSW_RETURN_FROM_MAIN
#if IFX_CFG_SSW_RETURN_FROM_MAIN == 1
/* Do Nothing */
#elif IFX_CFG_SSW_RETURN_FROM_MAIN == 0
#undef IFX_CFG_SSW_RETURN_FROM_MAIN
#else
/* Do Nothing */
#endif
#endif

#define Ifx_Ssw_disableVirtualization()                                                    \
    Ifx_Ssw_MTCR(CPU_VCON0, (unsigned int)0U);                                             \
    Ifx_Ssw_MTCR(CPU_PSW, (unsigned int)0xB00U);                                           \
    Ifx_Ssw_RFH();
	
#define IFX_SSW_INIT_CONTEXT(cpu,vm)                                                       \
    {                                                                                      \
        /* Load user stack pointer */                                                      \
        Ifx_Ssw_setAddressReg(a10, __USTACK(cpu,vm));                                      \
        Ifx_Ssw_DSYNC();                                                                   \
                                                                                           \
        /*Initialize the context save area for CPU0. Function Calls Possible */            \
        /* Setup the context save area linked list */                                      \
        Ifx_Ssw_initCSA((unsigned int *)__CSA(cpu,vm), (unsigned int *)__CSA_END(cpu,vm)); \
        /* Clears any instruction buffer */                                                \
        Ifx_Ssw_ISYNC();                                                                   \
    }

#define IFX_SSW_CORE_VM_START(cpu,vm)														\
{																							\
	Ifx_Ssw_MTCR(CPU_PSW, IFX_CFG_SSW_PSW_DEFAULT);											\
	IFX_SSW_INIT_CONTEXT(cpu,vm);															\
	Ifx_Ssw_MTCR(CPU_BTV, (unsigned int)__TRAPTAB(cpu,vm));									\
	Ifx_Ssw_MTCR(CPU_BIV, (unsigned int)__INTTAB(cpu,vm));									\
	Ifx_Ssw_MTCR(CPU_ISP, (unsigned int)__ISTACK(cpu,vm));									\
}

#ifndef IFX_CFG_SSW_WDG_RELOAD_VALUE
#define IFX_CFG_SSW_WDG_RELOAD_VALUE (0xFFC2u)  /*10ms~(62*163.84us), WdgStep=163.84us, Fspb=100MHz */
#endif

#define  IFX_CFG_SSW_WDG_INITIAL_VALUE (0xFFFCu)
/******************************************************************************/
/*-------------------------Infrastructure Functions---------------------------*/
/******************************************************************************/

/** \brief Fetch current password of CPU Watchdog module.
 *
 * This API will fetch current Watchdog password for CPU WDT Hardware module.
 * password is needed to be passed with most of the WDT APIs.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern unsigned short Ifx_Ssw_getCpuWatchdogPassword(Ifx_WTU_WDTCPU *watchdog);

/** \brief Fetch current password of Safety Watchdog module.
 *
 * This API will fetch current Watchdog password for Safety WDT Hardware module.
 * password is needed to be passed with most of the WDT APIs.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern unsigned short Ifx_Ssw_getSafetyWatchdogPassword(void);

/** \brief Fetch current password of Security(CSRM) Watchdog module.
 *
 * This API will fetch current Watchdog password for Security WDT Hardware module.
 * password is needed to be passed with most of the WDT APIs.
 * \return password Existing (Application specific) password for the Watchdog module.
 */
extern unsigned short Ifx_Ssw_getSecurityWatchdogPassword(void);

/** \brief Disable CPU Watchdog functionality.
 *
 * This API will disable Watchdog functionality of CPU WDT Hardware module. The Watchdog timers will stop counting
 * after this API call.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void Ifx_Ssw_disableCpuWatchdog(Ifx_WTU_WDTCPU *watchdog, unsigned int password);

/** \brief API to enable CPU Watchdog functionality.
 *
 *   This API will enable Watchdog functionality of CPU WDT Hardware module. The Watchdog timers need to be serviced
 *   periodically after this API call.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void Ifx_Ssw_enableCpuWatchdog(Ifx_WTU_WDTCPU *watchdog, unsigned int password);

/** \brief Disable System Watchdog functionality.
 *
 * This API will disable Watchdog functionality of System WDT Hardware module. The Watchdog timers will stop counting
 * after this API call.
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void Ifx_Ssw_disableSystemWatchdog(unsigned int password);

/** \brief Enable System Watchdog functionality.
 *
 * This API will enable Watchdog functionality of System WDT Hardware module. The Watchdog timers need to be serviced
 * periodically after this API call.
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void Ifx_Ssw_enableSystemWatchdog(unsigned int password);

/** \brief WTU API to change CPU Watchdog timer reload value.
 *
 * This API will change Watchdog timer reload value to new one for CPU WDT Hardware module.
 * The Watchdog timers will be reloaded with this value after every serice of Watchdog.
 * User need to have the password stored locally in the caller function.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param reload Reload value for the timer.
 * \return None
 */
extern void Ifx_Ssw_changeCpuWatchdogReload(Ifx_WTU_WDTCPU *watchdog, unsigned int password, unsigned int reload);

/** \brief WTU API to change System Watchdog timer reload value.
 *
 * This API will change Watchdog timer reload value to new one for System WDT Hardware module.
 * The Watchdog timers will be reloaded with this value after every serice of Watchdog.
 * User need to have the password stored locally in the caller function.
 * \param password Existing (Application specific) password for the Watchdog module.
 * \param reload Reload value for the timer.
 * \return None
 */
extern void Ifx_Ssw_changeSystemWatchdogReload(unsigned int password, unsigned int reload);

/** \brief Disable Security(CSRM) Watchdog functionality.
 *
 * This API will disable Watchdog functionality of Security WDT Hardware module. The Watchdog timers will stop counting
 * after this API call.
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
void Ifx_Ssw_disableSecurityWatchdog(unsigned int password);

/** \brief Enable Security(CSRM) Watchdog functionality.
 *
 * This API will enable Watchdog functionality of Security WDT Hardware module. The Watchdog timers need to be serviced
 * periodically after this API call.
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
void Ifx_Ssw_enableSecurityWatchdog(unsigned int password);

/** \brief Set the program counter for the CPU specified and start the CPU
 * \param cpu Pointer to the CPU HW module (register memory map)
 * \param programCounter Program counter value to start the CPU
 */
extern void Ifx_Ssw_startCore(Ifx_CPU *cpu, unsigned int programCounter);

/** \brief Set CPU0 to idle state */
extern void Ifx_Ssw_setCpu0Idle(void);

/** \brief Initialise the C runtime environment */
extern void Ifx_Ssw_doCppInit(void);

/** \brief De-initialize the C/Cpp runtime environment */
extern void Ifx_Ssw_doCppExit(int status);

/** \brief Returns the system timer frequency.
 * \return the system timer frequency in Hz.
 */
extern unsigned int Ifx_Ssw_getStmFrequency(void);

/** \brief API to service CPU Watchdog functionality.
 *
 *   This API will service Watchdog functionality corresponding to CPU WDT Hardware module.
 *   User need to use this API call periodically. This API results in reloading of the Watchdog Timer.
 * \param watchdog pointer to the watchdog register map of CPU WDT hardware instance.
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void Ifx_Ssw_serviceCpuWatchdog(Ifx_WTU_WDTCPU *watchdog, unsigned int password);

/** \brief API to service System Watchdog functionality.
 *
 * This API will service Watchdog functionality corresponding to System WDT Hardware module.
 * User need to use this API call periodically. This API results in reloading of the Watchdog Timer.
 * \param password Existing (Application specific) password for the Watchdog module.
 * \return None
 */
extern void Ifx_Ssw_serviceSystemWatchdog(unsigned int password);

/** \brief API to provide a delay
 *
 * This API will provide the 100us delay required before starting another Core
 * \return None
 */
extern void Ifx_Ssw_delay(void);

/** \brief API to set core voltage to 1V.
 * \return None
 */
extern void Ifx_Ssw_PmicSetVcore1v(void);

/** \brief API to set core voltage to 0.95V.
 * \return None
 */
extern void Ifx_Ssw_PmicSetVcore0_95v(void);

/** \brief API to clear SRAM.
 * \param vmt Pointer to the VMT module sfr.
 * \param ssh Instance number(MCi).
 * \return None
 */
extern void IfxSsw_clearSram(Ifx_VMT* vmt, unsigned int ssh);

/** \brief Hook for application specific hardware extensions.
 * \return None
 */
extern void hardware_init_hook(void);

/** \brief Hook for application specific software extensions.
 * \return None
 */
extern void software_init_hook(void);

IFX_SSW_INLINE unsigned short Ifx_Ssw_getCpuWatchdogPasswordInline(Ifx_WTU_WDTCPU *watchdog)
{
    unsigned short password = 0;
    /* Read Password from CTRLA register
     * When read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CTRLA.B.PW;
    password ^= IFX_SSW_WDT_PASSWORD_INVERT_MSK;
    return password;
}


IFX_SSW_INLINE unsigned short Ifx_Ssw_getSystemWatchdogPasswordInline(void)
{
    unsigned short  password = 0;
    Ifx_WTU_WDTSYS *watchdog = &MODULE_WTU.WDTSYS;

    /* Read Password from Safety WDT CTRLA register
     * When read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CTRLA.B.PW;
    password ^= IFX_SSW_WDT_PASSWORD_INVERT_MSK;
    return password;
}


IFX_SSW_INLINE unsigned short Ifx_Ssw_getSecurityWatchdogPasswordInline(void)
{
    unsigned short password = 0;
    Ifx_WTU_WDTSEC *watchdog = &MODULE_WTU.WDTSEC;

    /* Read Password from Safety WDT CTRLA register
     * !!! NOTE: !!! when read bottom six bit of password are inverted so we have
     * to toggle them before returning password */
    password  = watchdog->CTRLA.B.PW;
    password ^= IFX_SSW_WDT_PASSWORD_INVERT_MSK;

    return password;
}


IFX_SSW_INLINE unsigned char Ifx_Ssw_isApplicationReset(void)
{
    unsigned char status = 0U;

    status = SMM_RSTSTATH.B.APPRST;

    return status;
}


/** \brief Set the Key-off marker used by STL in shutdown phase.
 * \return None
 */
IFX_SSW_INLINE void Ifx_Ssw_setKeyoffMarker(void)
{
	PMS_CLDPORSTUSRINFO.B.DATA = 0x1u;
}


/** \brief Clear the Key-off marker used by STL in shutdown phase.
 * \return None
 */
IFX_SSW_INLINE void Ifx_Ssw_clearKeyoffMarker(void)
{
	PMS_CLDPORSTUSRINFO.B.DATA = 0x0u;
}


/** \brief Check whether Key-off marker is set
 * \return None
 */
IFX_SSW_INLINE unsigned char Ifx_Ssw_isKeyoffMarkerSet(void)
{
    unsigned char status = 0u;

    status = PMS_CLDPORSTUSRINFO.B.DATA;

    return status;
}


IFX_SSW_INLINE void Ifx_Ssw_initCSA(unsigned int *csaBegin, unsigned int *csaEnd)
{
    unsigned int  k;
    unsigned int  nxt_cxi_val = 0U;
    unsigned int *prvCsa      = 0U;
    unsigned int *nxtCsa      = csaBegin;
    unsigned int  numOfCsa    = (((unsigned int)csaEnd - (unsigned int)csaBegin) / 64U);

    for (k = 0U; k < numOfCsa; k++)
    {
        nxt_cxi_val = ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFU << 28U)) >> 12U) | \
                      ((unsigned int)((unsigned int)nxtCsa & ((unsigned int)0XFFFFU << 6U)) >> 6U);

        if (k == 0U)
        {
            Ifx_Ssw_MTCR(CPU_FCX, nxt_cxi_val);   /* store the new pcxi value to LCX */
        }
        else
        {
            *prvCsa = nxt_cxi_val;
        }

        if (k == (numOfCsa - 3U))
        {
            Ifx_Ssw_MTCR(CPU_LCX, nxt_cxi_val);   /* Last but 2 context save area is pointed in LCX to know if there is CSA depletion */
        }

        prvCsa  = (unsigned int *)nxtCsa;
        nxtCsa += IFX_SSW_CSA_SIZE; /* next CSA */
    }

    *prvCsa = 0U;                   /* Store null pointer in last CSA (= very first time!) */

    Ifx_Ssw_DSYNC();
}


IFX_SSW_INLINE unsigned int Ifx_Ssw_getRampFrequency(void)
{
    unsigned int freq = 0U;

    /* Check if ramp is locked at top and return or if at base return 100Mhz */
    if (CLOCK_RAMPSTAT.B.SSTAT == 0U)
    {
        if (CLOCK_RAMPSTAT.B.FSTAT == 2U)
        {
            /* Convert to Mhz and return */
            freq = (unsigned int)(((unsigned int)CLOCK_RAMPCON0.B.UFL) * (1000000U));
        }
        else if (CLOCK_RAMPSTAT.B.FSTAT == 1U)
        {
            freq = (unsigned int)(100000000U);
        }
        else
        {
            /* Return 0 if freq is in between the base and UFL */
            freq = 0U;
        }
    }
    else
    {
        /* Return 0 if status is not idle */
        freq = 0U;
    }

    return freq;
}

#endif /* IFX_SSW_INFRA_H */
