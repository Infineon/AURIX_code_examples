/**********************************************************************************************************************
 * \file IfxHv_CpuVmSched.h
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#ifndef IFX_HV_CPUVMSCHED_H
#define IFX_HV_CPUVMSCHED_H
#include "Ifx_Cfg_Hv.h"
#include "Ifx_Ssw_Compilers.h"
#include "IfxCpu_reg.h"
#include "IfxSrc_reg.h"
#include "IfxInt_reg.h"
#include "IfxInt_bf.h"

/* Number of virtual machines per core */
#define IFX_NUM_VM 7u

/* Type definition for VM state */
typedef enum
{
    VM_INIT,
    VM_RUN,
    VM_WAIT,
    VM_SUSPEND
}VmStateType;

/* Type definition for VM-IDs used in the Demo */
typedef enum
{
    HV_VM1,
    HV_VM2,
    HV_VM3,
    HV_VM4,
    HV_VM5,
    HV_VM6,
    HV_VM7
}VmIdType;

/* Type definition for VM numbers */
typedef enum
{
    VM0,
    VM1,
    VM2,
    VM3,
    VM4,
    VM5,
    VM6,
    VM7
}VmNumType;
/* Type definition for MPU-L2 PRS sets */
typedef enum
{
    PRS0,
    PRS1,
    PRS2,
    PRS3,
    PRS4,
    PRS5,
    PRS6,
    PRS7
}L2MpuPrsNumType;
/* Type definition for VM specific data*/
typedef struct
{
    volatile VmStateType  State;
    volatile unsigned int Psw;
    volatile unsigned int Fcx;
    volatile unsigned int Pcxi;
}VmDataType;
/* Type definition for HV specific data*/
typedef struct
{
    volatile VmIdType CurrRunningVm;
}HvDataType;

typedef struct
{
    Ifx_CPU_PSW     PSW;
    Ifx_CPU_CORECON CORECON;
    Ifx_CPU_BIV     BIV;
    Ifx_CPU_BTV     BTV;
    Ifx_CPU_ISP     ISP;
    Ifx_CPU_FCX     FCX;
    Ifx_CPU_LCX     LCX;
    Ifx_CPU_CCTRL   CCTRL;
    Ifx_CPU_CCNT    CCNT;
    Ifx_CPU_ICNT    ICNT;
    Ifx_CPU_M1CNT   M1CNT;
    Ifx_CPU_M2CNT   M2CNT;
    Ifx_CPU_M3CNT   M3CNT;
    Ifx_CPU_DPR_L   DPR0_L;
    Ifx_CPU_DPR_U   DPR0_U;
    Ifx_CPU_DPR_L   DPR1_L;
    Ifx_CPU_DPR_U   DPR1_U;
    Ifx_CPU_DPR_L   DPR2_L;
    Ifx_CPU_DPR_U   DPR2_U;
    Ifx_CPU_CPR_L   CPR0_L;
    Ifx_CPU_CPR_U   CPR0_U;
    Ifx_CPU_CPR_L   CPR1_L;
    Ifx_CPU_CPR_U   CPR1_U;
    Ifx_CPU_CPXE    CPXE0;
    Ifx_CPU_DPRE    DPRE0;
    Ifx_CPU_DPWE    DPWE0;
    Ifx_CPU_AREG    A0;
    Ifx_CPU_AREG    A1;
    Ifx_CPU_AREG    A8;
    Ifx_CPU_AREG    A9;
}Hr2Context;

extern const IfxHv_StmCompareConfig  IfxHv0_StmConfig;
extern const IfxHv_StmCompareConfig  IfxHv1_StmConfig;
extern const IfxHv_StmCompareConfig  IfxHv2_StmConfig;
extern const IfxHv_StmCompareConfig  IfxHv3_StmConfig;
extern const IfxHv_StmCompareConfig  IfxHv4_StmConfig;
extern const IfxHv_StmCompareConfig  IfxHv5_StmConfig;

extern const IfxHv_VmThresholdConfig IfxHv0_VmThresholdConfig;
extern const IfxHv_VmThresholdConfig IfxHv1_VmThresholdConfig;
extern const IfxHv_VmThresholdConfig IfxHv2_VmThresholdConfig;
extern const IfxHv_VmThresholdConfig IfxHv3_VmThresholdConfig;
extern const IfxHv_VmThresholdConfig IfxHv4_VmThresholdConfig;
extern const IfxHv_VmThresholdConfig IfxHv5_VmThresholdConfig;

extern void   IfxHv_disableCpuWatchdog(void);
extern void   IfxHv_disableSystemWatchdog(void);
extern uint32 IfxHv_getStmFrequency(void);

IFXHV_INLINE void Ifx_Ssw_Hv_saveHr2Context(Hr2Context *hr2Context);
IFXHV_INLINE void Ifx_Ssw_Hv_restoreHr2Context(Hr2Context *hr2Context);
IFXHV_INLINE void Ifx_Ssw_Hv_resetHr2Context(Hr2Context *hr2Context);

/* Prepare for VM re-scheduling:
 * 1. Restore the current executing VM context (PCXI).
 * 2. Set next executing VM to Run.
 * */
IFXHV_INLINE void Ifx_Hv_restoreVmState(HvDataType *hv, VmDataType *outVm, VmNumType vmToRun);

/* Set current VM state to wait
 * 1. Save PCXI registers of VM
 */
IFXHV_INLINE void Ifx_Hv_saveVmState(VmDataType *inVm);

IFXHV_INLINE void Ifx_Hv_setPsw(unsigned int pswAddr);

IFXHV_INLINE void Ifx_Ssw_Hv_saveHr2Context(Hr2Context *hr2Context)
{
    hr2Context->PSW.U     = IFXHV_MFCR(CPU_PSW);
    hr2Context->CORECON.U = IFXHV_MFCR(CPU_HVHRB_CORECON);
    hr2Context->BIV.U     = IFXHV_MFCR(CPU_HVHRB_BIV);
    hr2Context->BTV.U     = IFXHV_MFCR(CPU_HVHRB_BTV);
    hr2Context->ISP.U     = IFXHV_MFCR(CPU_HVHRB_ISP);
    hr2Context->FCX.U     = IFXHV_MFCR(CPU_HVHRB_FCX);
    hr2Context->LCX.U     = IFXHV_MFCR(CPU_HVHRB_LCX);
    hr2Context->DPR0_L.U  = IFXHV_MFCR(CPU_HVHRB_DPR0_L);
    hr2Context->DPR0_U.U  = IFXHV_MFCR(CPU_HVHRB_DPR0_U);
    hr2Context->DPR1_L.U  = IFXHV_MFCR(CPU_HVHRB_DPR1_L);
    hr2Context->DPR1_U.U  = IFXHV_MFCR(CPU_HVHRB_DPR1_U);
    hr2Context->DPR2_L.U  = IFXHV_MFCR(CPU_HVHRB_DPR2_L);
    hr2Context->DPR2_U.U  = IFXHV_MFCR(CPU_HVHRB_DPR2_U);
    hr2Context->CPR0_L.U  = IFXHV_MFCR(CPU_HVHRB_CPR0_L);
    hr2Context->CPR0_U.U  = IFXHV_MFCR(CPU_HVHRB_CPR0_U);
    hr2Context->CPR1_L.U  = IFXHV_MFCR(CPU_HVHRB_CPR1_L);
    hr2Context->CPR1_U.U  = IFXHV_MFCR(CPU_HVHRB_CPR1_U);
    hr2Context->CPXE0.U   = IFXHV_MFCR(CPU_HVHRB_CPXE_0);
    hr2Context->DPRE0.U   = IFXHV_MFCR(CPU_HVHRB_DPRE_0);
    hr2Context->DPWE0.U   = IFXHV_MFCR(CPU_HVHRB_DPWE_0);
    hr2Context->A0.U      = IFXHV_MFCR(CPU_HVHRB_A0);
    hr2Context->A1.U      = IFXHV_MFCR(CPU_HVHRB_A1);
    hr2Context->A8.U      = IFXHV_MFCR(CPU_HVHRB_A8);
    hr2Context->A9.U      = IFXHV_MFCR(CPU_HVHRB_A9);
}


IFXHV_INLINE void Ifx_Ssw_Hv_restoreHr2Context(Hr2Context *hr2Context)
{
    IFXHV_MTCR(CPU_PSW, hr2Context->PSW.U);
    IFXHV_MTCR(CPU_HVHRB_CORECON, hr2Context->CORECON.U);
    IFXHV_MTCR(CPU_HVHRB_BIV, hr2Context->BIV.U);
    IFXHV_MTCR(CPU_HVHRB_BTV, hr2Context->BTV.U);
    IFXHV_MTCR(CPU_HVHRB_ISP, hr2Context->ISP.U);
    IFXHV_MTCR(CPU_HVHRB_FCX, hr2Context->FCX.U);
    IFXHV_MTCR(CPU_HVHRB_LCX, hr2Context->LCX.U);
    IFXHV_MTCR(CPU_HVHRB_DPR0_L, hr2Context->DPR0_L.U);
    IFXHV_MTCR(CPU_HVHRB_DPR0_U, hr2Context->DPR0_U.U);
    IFXHV_MTCR(CPU_HVHRB_DPR1_L, hr2Context->DPR1_L.U);
    IFXHV_MTCR(CPU_HVHRB_DPR1_U, hr2Context->DPR1_U.U);
    IFXHV_MTCR(CPU_HVHRB_DPR2_L, hr2Context->DPR2_L.U);
    IFXHV_MTCR(CPU_HVHRB_DPR2_U, hr2Context->DPR2_U.U);
    IFXHV_MTCR(CPU_HVHRB_CPR0_L, hr2Context->CPR0_L.U);
    IFXHV_MTCR(CPU_HVHRB_CPR0_U, hr2Context->CPR0_U.U);
    IFXHV_MTCR(CPU_HVHRB_CPR1_L, hr2Context->CPR1_L.U);
    IFXHV_MTCR(CPU_HVHRB_CPR1_U, hr2Context->CPR1_U.U);
    IFXHV_MTCR(CPU_HVHRB_CPXE_0, hr2Context->CPXE0.U);
    IFXHV_MTCR(CPU_HVHRB_DPRE_0, hr2Context->DPRE0.U);
    IFXHV_MTCR(CPU_HVHRB_DPWE_0, hr2Context->DPWE0.U);
    IFXHV_MTCR(CPU_HVHRB_A0, hr2Context->A0.U);
    IFXHV_MTCR(CPU_HVHRB_A1, hr2Context->A1.U);
    IFXHV_MTCR(CPU_HVHRB_A8, hr2Context->A8.U);
    IFXHV_MTCR(CPU_HVHRB_A9, hr2Context->A9.U);
}


IFXHV_INLINE void Ifx_Ssw_Hv_resetHr2Context(Hr2Context *hr2Context)
{
    IFXHV_MTCR(CPU_PSW, IFX_CFG_HV_PSW_DEFAULT);
    IFXHV_MTCR(CPU_HVHRB_CORECON, 0U);
    IFXHV_MTCR(CPU_HVHRB_BIV, 0U);
    IFXHV_MTCR(CPU_HVHRB_BTV, 0U);
    IFXHV_MTCR(CPU_HVHRB_ISP, 0U);
    IFXHV_MTCR(CPU_HVHRB_FCX, 0U);
    IFXHV_MTCR(CPU_HVHRB_LCX, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPR0_L, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPR0_U, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPR1_L, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPR1_U, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPR2_L, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPR2_U, 0U);
    IFXHV_MTCR(CPU_HVHRB_CPR0_L, 0U);
    IFXHV_MTCR(CPU_HVHRB_CPR0_U, 0U);
    IFXHV_MTCR(CPU_HVHRB_CPR1_L, 0U);
    IFXHV_MTCR(CPU_HVHRB_CPR1_U, 0U);
    IFXHV_MTCR(CPU_HVHRB_CPXE_0, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPRE_0, 0U);
    IFXHV_MTCR(CPU_HVHRB_DPWE_0, 0U);
    IFXHV_MTCR(CPU_HVHRB_A0, 0U);
    IFXHV_MTCR(CPU_HVHRB_A1, 0U);
    IFXHV_MTCR(CPU_HVHRB_A8, 0U);
    IFXHV_MTCR(CPU_HVHRB_A9, 0U);
}


IFXHV_INLINE void Ifx_Hv_restoreVmState(HvDataType *hv, VmDataType *outVm, VmNumType vmToRun)
{
    /* Prepare for VM re-scheduling:
     * 1. Restore the current executing VM context (PCXI).
     * 2. Set next executing VM to Run.
     * */
    IFXHV_MTCR(CPU_PCXI, outVm->Pcxi);
    hv->CurrRunningVm = (VmIdType)(vmToRun - 1U);
    outVm->State      = VM_RUN;
    IFXHV_MTCR(CPU_VCON2, (vmToRun | (vmToRun << 8u)));
}


IFXHV_INLINE void Ifx_Hv_saveVmState(VmDataType *inVm)
{
    /* Set current VM state to wait
     * 1. Save PCXI registers of VM
     */
    inVm->Pcxi  = IFXHV_MFCR(CPU_PCXI);
    inVm->State = VM_WAIT;
}


IFXHV_INLINE void Ifx_Hv_setPsw(unsigned int pswAddr)
{
    volatile unsigned int *pswCsaAddress = (unsigned int *)(pswAddr);
    *pswCsaAddress = 0xB80U;
}


IFXHV_INLINE void Hv_setCsaAddress(volatile unsigned int *vmcsaAddress, VmIdType VmId)
{
    unsigned int offset       = 0;
    unsigned int segment      = 0;
    unsigned int pcxiReg      = 0;
    unsigned int pswCSAOffset = 0;

    /*
     * Compute Link Word (PCXI register) from CSA address as below.
     *    - bits 6:21 of CSA corresponds to Offset and copied to PCXI.PCXO
     *    - bits 28:31 of CSA corresponds to Segment and copied to PCXI.PCXS
     */
    offset  = ((((unsigned int)vmcsaAddress) >> 6) & 0xFFFF);
    segment = ((((unsigned int)vmcsaAddress) >> 12) & 0xF0000);

    /*
     * Enable PIE, UL
     */
    pcxiReg  = (3 << 20) + offset + segment;
    pcxiReg += (VmId * 2);

    /*
     * Compute PSW CSA Offset
     */
    pswCSAOffset = (VmId * 128) + 4;

    IFXHV_MTCR(CPU_PCXI, pcxiReg);
    IFXHV_MTCR(CPU_FCX, (pcxiReg + 1u));
    Ifx_Hv_setPsw(((unsigned int)vmcsaAddress) + pswCSAOffset);
}


void Hv0_Vm_PreEmptionScheduler(void);
void Hv1_Vm_PreEmptionScheduler(void);
void Hv2_Vm_PreEmptionScheduler(void);
void Hv3_Vm_PreEmptionScheduler(void);
void Hv4_Vm_PreEmptionScheduler(void);
void Hv5_Vm_PreEmptionScheduler(void);

IFX_INTERRUPT_FUNC void Hv0_Vm_Scheduler(void);
IFX_INTERRUPT_FUNC void Hv1_Vm_Scheduler(void);
IFX_INTERRUPT_FUNC void Hv2_Vm_Scheduler(void);
IFX_INTERRUPT_FUNC void Hv3_Vm_Scheduler(void);
IFX_INTERRUPT_FUNC void Hv4_Vm_Scheduler(void);
IFX_INTERRUPT_FUNC void Hv5_Vm_Scheduler(void);

extern void core0_vm0_start(void);
extern void core1_vm0_start(void);
extern void core2_vm0_start(void);
extern void core3_vm0_start(void);
extern void core4_vm0_start(void);
extern void core5_vm0_start(void);

#endif /* IFX_HV_CPUVMSCHED_H */
