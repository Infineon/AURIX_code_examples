/**
 * \file Ifx_Cfg_Ssw.c
 * \brief Configuration file for the Startup Software
 *
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 * $Date: 2023-10-17 13:08:18
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Ifx_Cfg_Ssw.h"
#include "Ifx_Ssw_Infra.h"
#if (IFX_CFG_SSW_ENABLE_LBIST == 1)
#include "IfxApProt.h"
#include "IfxTriLbist.h"
#endif
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
#if defined(__TASKING__)
#pragma optimize RL
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma GCC optimize ("O1")
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma GCC optimize ("O1")
#endif

/** Hook API for FW_Check incl. SMU Alarm Flag check
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * check FW and the SMU alarm flags. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_FW_CHECK == 1U)
void Ifx_Ssw_FwCheck(void)
{
	/* TODO: To be updated as per A3G spec */
}
#endif

/** Hook API for PMS Initialization
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * initialize the PMS EVR module. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_PMS_INIT == 1U)
void Ifx_Ssw_Pms_Init(void)
{
    /* TODO: To be updated as per A3G spec */
}


/** Hook API for PMS Initialization check
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * cross verify the PMS configuration with the required values. This hook is by default defined to empty
 * call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_PMS_INIT_CHECK == 1U)
void Ifx_Ssw_Pms_InitCheck(void)
{
    /* TODO: To be updated as per A3G spec */
}


#endif /* End of Ifx_Ssw_Pms_InitCheck() */
#endif /* End of Ifx_Ssw_Pms_Init() */

/** Hook API for LBIST check
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * do LBIST checks. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_LBIST == 1)
void Ifx_Ssw_Lbist(void)
{
    uint16 result;

    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTSE, IfxApProt_State_config);
    TRI_ACCEN_WRA.U = 0xFFFFFFFFU;
    TRI_ACCEN_WRB.U = 0xFFFFFFFFU;
    IfxApProt_setState((Ifx_PROT_PROT *)&TRI_PROTSE, IfxApProt_State_run);

    result = IfxTriLbist_evaluateResult(&IfxTriLbist_keyOnDefaultConfig.signature[0]);

    if (result) // Failure or Not executed.
    {
        if (IfxTriLbist_getFailCount() >= 2)
        {
            /* after 3 faulty LBIST execution
             * signal a permanent fault */
            Ifx_Ssw_debug();
        }
        else
        {
            /* increment Fail count */
            IfxTriLbist_incrementFailCount();
        }

        /* Clear LBIST Status registers */
        IfxTriLbist_resetLbist();

        IfxTriLbist_triggerInline(&IfxTriLbist_keyOnDefaultConfig);
    }
    else
    {
        /* Success */
    }
}


#endif

/** Hook API for MONBIST check
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * do MONBIST checks. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_MONBIST == 1)
void Ifx_Ssw_Monbist(void)
{
    /* TODO: To be updated as per A3G spec */
}


#endif

/** Hook API do MBIST for DSPR0-DSPR5
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * do MBIST for DSPR0. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_MBIST_DSPRS_DMARAM == 1)
void Ifx_Ssw_MbistDsprsDmaRam(void)
{
    /* TODO: To be updated as per A3G spec */
}


#endif

/** Hook API to shutdown the unused power domains
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * to shutdown the unused power domains. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_SHUTDOWN_UNUSED_PWRDOMAINS == 1)
void Ifx_Ssw_ShutdownPwrDomains(void)
{}

#endif

/** Callout hook API macro for PLL initialization
 * This callout hook is referenced in Startup sequence. This need to be configured by application to
 * initialize the PLL. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_PLL_INIT == 1U
#include "IfxClock.h"

void Ifx_Ssw_PowerOnCrystalOsc(void)
{
    Ifx_CLOCK_OSCCON scuOsccon;
    unsigned int     initError         = 0U;
    unsigned int     timeoutCycleCount = IFX_CFG_SSW_CCUCON_LCK_BIT_TIMEOUT_COUNT;
    scuOsccon.U = CLOCK_OSCCON.U;

#if (IFX_CFG_SSW_CLOCK_EXT_CLOCK == 1)
    /* external clock selected */
    scuOsccon.B.MODE = 2U;
#else
    /* oscillator enabled */
    scuOsccon.B.MODE = 0U;
#endif

    while (CLOCK_CCUSTAT.B.LCK != 0U)
    {
        IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
    }

    CLOCK_OSCCON.U = scuOsccon.U;

    if (initError)
    {
        Ifx_Ssw_debug();
    }
}


void Ifx_Ssw_PllInit(void)
{
    if (IfxClock_init(&IfxClock_defaultClockConfig) != 0U)
    {
        __debug();
    }
}


#endif /* End of IFX_CFG_SSW_ENABLE_PLL_INIT */

/** Callout hook API macro for XTAL Source Check
 * This need to be configured by application to do XTAL Source checks.
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_XTALSRC_CHECK == 1U
void Ifx_Ssw_XtalSrc_Check(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_XTALSRC_CHECK */

/** Callout hook API macro to configure PMIC Voltage shift
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_PMIC_VOLTAGESHIFT == 1U
void Ifx_Ssw_Pmic_VoltageShift(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_PMIC_VOLTAGESHIFT */

/** Callout hook API macro to configure AUTOSAR Services Start
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_AUTOSAR_SERVICESTART == 1U
void Ifx_Ssw_Autosar_ServicesStart(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_AUTOSAR_SERVICESTART */

/** Callout hook API macro for MBIST check for SSHs, other than DSPR0-5 and DMARAM
 * This callout hook is referenced in Startup sequence. This need to be configured by application to
 * do MBIST checks. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_MBIST == 1U
void Ifx_Ssw_Mbist(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_MBIST */

/** Callout hook API macro for SMU alarm handling
 * This need to be configured by application to do SMU alarm handling.
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_SMU == 1U
void Ifx_Ssw_Smu(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_SMU */

/** Callout hook API macro for STL startup tests
 * This need to be configured by application to do STL startup tests.
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_SAFETY_LIBRARY_TESTS == 1U
void Ifx_Ssw_SafetyLibraryTests(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_SAFETY_LIBRARY_TESTS */

/** Hook API for Key-off LBIST check
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * do LBIST checks. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_KEYOFF_LBIST == 1)
void Ifx_Ssw_Keyoff_Lbist(void)
{
    /* TODO: To be updated as per A3G spec */
}


#endif

/** Callout hook API macro for Key-off MBIST check for SSHs, other than DSPR0-5 and DMARAM
 * This callout hook is referenced in Startup sequence. This need to be configured by application to
 * do MBIST checks. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_KEYOFF_MBIST == 1U
void Ifx_Ssw_Keyoff_Mbist(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_MBIST */

/** Hook API do MBIST for Key-off DSPR0-DSPR5
 * This hook is referenced in Startup sequence. This need to be configured by application to
 * do MBIST for DSPR0. This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if (IFX_CFG_SSW_ENABLE_KEYOFF_MBIST_DSPRS_DMARAM == 1)
void Ifx_Ssw_Keyoff_MbistDsprsDmaRam(void)
{
    /* TODO: To be updated as per A3G spec */
}


#endif

/** Callout hook API macro for Key-off STL startup tests
 * This need to be configured by application to do STL startup tests.
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_KEYOFF_SAFETY_LIBRARY_TESTS == 1U
void Ifx_Ssw_Keyoff_SafetyLibraryTests(void)
{}

#endif /* End of IFX_CFG_SSW_ENABLE_SAFETY_LIBRARY_TESTS */

/** Callout hook API macro for PROT and APU initialization
 * This need to be configured by application to do PROT and APU initialization.
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
#if IFX_CFG_SSW_ENABLE_AP_INIT == 1U
#include "IfxCpu_reg.h"
#include "IfxInt_reg.h"
void Ifx_Ssw_AP_Init(void)
{
    /* Access for the Core specific SFRRs, DSPRs,
     * DMLUs , INTs and STMs enabled for all
     * masters. This needs to be updated
     * by user as per his needs
     */
    /* Access for the Core specific SFRRs, DSPRs,
     * DMLUs , INTs and STMs enabled for all
     * masters. This needs to be updated
     * by user as per his needs
     */
    CPU0_PROTSFRSE.U       = 0x0;
    CPU0_ACCENSFRCFG_WRA.U = 0xFFFFFFFFU;

    CPU1_PROTSFRSE.U       = 0x0;
    CPU1_ACCENSFRCFG_WRA.U = 0xFFFFFFFFU;

    CPU2_PROTSFRSE.U       = 0x0;
    CPU2_ACCENSFRCFG_WRA.U = 0xFFFFFFFFU;

    CPU3_PROTSFRSE.U       = 0x0;
    CPU3_ACCENSFRCFG_WRA.U = 0xFFFFFFFFU;

    CPU4_PROTSFRSE.U       = 0x0;
    CPU4_ACCENSFRCFG_WRA.U = 0xFFFFFFFFU;

    CPU5_PROTSFRSE.U       = 0x0;
    CPU5_ACCENSFRCFG_WRA.U = 0xFFFFFFFFU;

    for (unsigned int i = 0; i < 8; i++)
    {
        CPU0_PROTSTMSE.U       = i << 8U;
        CPU0_ACCENSTMCFG_WRA.U = 0xFFFFFFFFU;

        CPU1_PROTSTMSE.U       = i << 8U;
        CPU1_ACCENSTMCFG_WRA.U = 0xFFFFFFFFU;

        CPU2_PROTSTMSE.U       = i << 8U;
        CPU2_ACCENSTMCFG_WRA.U = 0xFFFFFFFFU;

        CPU3_PROTSTMSE.U       = i << 8U;
        CPU3_ACCENSTMCFG_WRA.U = 0xFFFFFFFFU;

        CPU4_PROTSTMSE.U       = i << 8U;
        CPU4_ACCENSTMCFG_WRA.U = 0xFFFFFFFFU;

        CPU5_PROTSTMSE.U       = i << 8U;
        CPU5_ACCENSTMCFG_WRA.U = 0xFFFFFFFFU;
    }

    for (unsigned int i = 0; i < 16; i++)
    {
        CPU0_PROTDLMUSE.U       = i << 8U;
        CPU0_ACCENDLMUCFG_WRA.U = 0xFFFFFFFFU;
        CPU0_ACCENDLMUCFG_WRB.U = 0xFFFFFFFFU;
        CPU1_PROTDLMUSE.U       = i << 8U;
        CPU1_ACCENDLMUCFG_WRA.U = 0xFFFFFFFFU;
        CPU1_ACCENDLMUCFG_WRB.U = 0xFFFFFFFFU;
        CPU2_PROTDLMUSE.U       = i << 8U;
        CPU2_ACCENDLMUCFG_WRA.U = 0xFFFFFFFFU;
        CPU2_ACCENDLMUCFG_WRB.U = 0xFFFFFFFFU;
        CPU3_PROTDLMUSE.U       = i << 8U;
        CPU3_ACCENDLMUCFG_WRA.U = 0xFFFFFFFFU;
        CPU3_ACCENDLMUCFG_WRB.U = 0xFFFFFFFFU;
        CPU4_PROTDLMUSE.U       = i << 8U;
        CPU4_ACCENDLMUCFG_WRA.U = 0xFFFFFFFFU;
        CPU4_ACCENDLMUCFG_WRB.U = 0xFFFFFFFFU;
        CPU5_PROTDLMUSE.U       = i << 8U;
        CPU5_ACCENDLMUCFG_WRA.U = 0xFFFFFFFFU;
        CPU5_ACCENDLMUCFG_WRB.U = 0xFFFFFFFFU;

        CPU0_PROTSPRSE.U        = i << 8U;
        CPU0_ACCENSPRCFG_WRA.U  = 0xFFFFFFFFU;
        CPU0_ACCENSPRCFG_WRB.U  = 0xFFFFFFFFU;

        CPU1_PROTSPRSE.U        = i << 8U;
        CPU1_ACCENSPRCFG_WRA.U  = 0xFFFFFFFFU;
        CPU1_ACCENSPRCFG_WRB.U  = 0xFFFFFFFFU;

        CPU2_PROTSPRSE.U        = i << 8U;
        CPU2_ACCENSPRCFG_WRA.U  = 0xFFFFFFFFU;
        CPU2_ACCENSPRCFG_WRB.U  = 0xFFFFFFFFU;

        CPU3_PROTSPRSE.U        = i << 8U;
        CPU3_ACCENSPRCFG_WRA.U  = 0xFFFFFFFFU;
        CPU3_ACCENSPRCFG_WRB.U  = 0xFFFFFFFFU;

        CPU4_PROTSPRSE.U        = i << 8U;
        CPU4_ACCENSPRCFG_WRA.U  = 0xFFFFFFFFU;
        CPU4_ACCENSPRCFG_WRB.U  = 0xFFFFFFFFU;

        CPU5_PROTSPRSE.U        = i << 8U;
        CPU5_ACCENSPRCFG_WRA.U  = 0xFFFFFFFFU;
        CPU5_ACCENSPRCFG_WRB.U  = 0xFFFFFFFFU;
    }

    INT_TOS0_ACCENSCFG_WRA.U  = 0xFFFFFFFFU;
    INT_TOS1_ACCENSCFG_WRA.U  = 0xFFFFFFFFU;
    INT_TOS2_ACCENSCFG_WRA.U  = 0xFFFFFFFFU;
    INT_TOS3_ACCENSCFG_WRA.U  = 0xFFFFFFFFU;
    INT_TOS4_ACCENSCFG_WRA.U  = 0xFFFFFFFFU;
    INT_TOS5_ACCENSCFG_WRA.U  = 0xFFFFFFFFU;

    INT_TOS0_ACCENSCTRL_WRA.U = 0xFFFFFFFFU;
    INT_TOS1_ACCENSCTRL_WRA.U = 0xFFFFFFFFU;
    INT_TOS2_ACCENSCTRL_WRA.U = 0xFFFFFFFFU;
    INT_TOS3_ACCENSCTRL_WRA.U = 0xFFFFFFFFU;
    INT_TOS4_ACCENSCTRL_WRA.U = 0xFFFFFFFFU;
    INT_TOS5_ACCENSCTRL_WRA.U = 0xFFFFFFFFU;
}


#endif /* End of IFX_CFG_SSW_ENABLE_AP_INIT */

/** Hook API macro for MultiCore Sync before Core0 Application Entry
 * This hook is used to run STL tests before Application Entry
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_MultiCore_Sync_Cpu0(void)
{}


/** Hook API macro for MultiCore Sync before Core1 Application Entry
 * This hook is used to run STL tests before Application Entry
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_MultiCore_Sync_Cpu1(void)
{}


/** Hook API macro for MultiCore Sync before Core2 Application Entry
 * This hook is used to run STL tests before Application Entry
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_MultiCore_Sync_Cpu2(void)
{}


/** Hook API macro for MultiCore Sync before Core3 Application Entry
 * This hook is used to run STL tests before Application Entry
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_MultiCore_Sync_Cpu3(void)
{}


/** Hook API macro for MultiCore Sync before Core4 Application Entry
 * This hook is used to run STL tests before Application Entry
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_MultiCore_Sync_Cpu4(void)
{}


/** Hook API macro for MultiCore Sync before Core5 Application Entry
 * This hook is used to run STL tests before Application Entry
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_MultiCore_Sync_Cpu5(void)
{}


/** Hook API macro for CSRM SYNC POINT B
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_CsrmSync_B(void)
{}


/** Callout hook API macro for CSRM SYNC POINT C
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_CsrmSync_C(void)
{}

/** Callout hook API macro for CSRM SYNC POINT D
 * This hook is by default defined to empty call by startup implementation.
 * \param none
 * \return none
 */
void Ifx_Ssw_CsrmSync_D(void)
{}

/** \brief Hook for application specific hardware extensions.
 * \return None
 */
void hardware_init_hook(void)
{
	Ifx_CPU_CORE_ID reg;
	reg.U = __mfcr(CPU_CORE_ID);
	
	if( reg.B.CORE_ID == 0u)				/* Clear SRAM only from Core0*/
	{
		IfxSsw_clearSram(&MODULE_VMT0, 23); /*LMU0*/
		IfxSsw_clearSram(&MODULE_VMT0, 24); /*LMU1*/
		IfxSsw_clearSram(&MODULE_VMT1, 0);  /*LMU2*/
		IfxSsw_clearSram(&MODULE_VMT1, 1);  /*LMU3*/
		IfxSsw_clearSram(&MODULE_VMT0, 25); /*LMU4*/
		IfxSsw_clearSram(&MODULE_VMT0, 26); /*LMU5*/
		IfxSsw_clearSram(&MODULE_VMT0, 27); /*LMU6*/
		IfxSsw_clearSram(&MODULE_VMT1, 2);  /*LMU7*/
		IfxSsw_clearSram(&MODULE_VMT1, 3);  /*LMU8*/
		IfxSsw_clearSram(&MODULE_VMT1, 4);  /*LMU9*/
	}
}

#if defined(__TASKING__)
#pragma endoptimize
#elif defined(__HIGHTEC__) && !defined(__clang__)
#pragma GCC reset_options
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
#pragma GCC reset_options
#endif
