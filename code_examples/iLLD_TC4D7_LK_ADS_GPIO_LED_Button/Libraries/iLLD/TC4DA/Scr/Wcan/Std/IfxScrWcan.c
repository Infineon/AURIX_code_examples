/**
 * \file IfxScrWcan.c
 * \brief SCR WCAN basic functionality
 * \ingroup IfxLld_ScrWcan
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxScrWcan.h"

/******************************************************************************/
/*-----------------------Exported Variables/Constants-------------------------*/
/******************************************************************************/

IFX_CONST IfxScrWcan_BaudrateConfig baudrateLookup[4] = {
    {IfxScrWcan_PrescalerDiv_1, 0x64, 0x33},                                             /* For 1Mbps */
    {IfxScrWcan_PrescalerDiv_2, 0x64, 0x33},                                             /* For 500kbps */
    {IfxScrWcan_PrescalerDiv_4, 0x64, 0x33},                                             /* For 250kbps */
    {IfxScrWcan_PrescalerDiv_8, 0x64, 0x33}                                              /* For 125kbps */
};
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScrWcan_initModule(IfxScrWcan_Config *wcanConfig)
{
    uint8 dataLength = wcanConfig->dataLength;

    if (dataLength > 8)
    {
        dataLength = 8;
    }

    /* +5% of BTL1_CTRL value and -5% of BTL1_CTRL(bit time quanta) value*/
    float upper = 1.05 * baudrateLookup[wcanConfig->baudrate].bitTq;
    float lower = 0.95 * baudrateLookup[wcanConfig->baudrate].bitTq;

    /* Enabling clock to WCAN(WCAN_EN) and enabling permission to configure baudrate and bit timing(CCE)*/
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U);

    /* Configuring WCAN interrupts */
    SCR_WCAN_INTMRSLT.U = (wcanConfig->enableTimeoutInterrupt | (wcanConfig->enableSysErrorInterrupt << IFX_SCR_WCAN_INTMRSLT_ERRMASK_OFF) | (wcanConfig->enableWufInterrupt << IFX_SCR_WCAN_INTMRSLT_WUFMASK_OFF) | (wcanConfig->enableWupInterrupt << IFX_SCR_WCAN_INTMRSLT_WUPMASK_OFF));

    SCR_WCAN_CFG.U      = (1u << IFX_SCR_WCAN_CFG_WCAN_EN_OFF) | (1u << IFX_SCR_WCAN_CFG_CCE_OFF) | (wcanConfig->receiverInput << IFX_SCR_WCAN_CFG_WCANRXDIS_OFF);

    /* Configuring the Baud Rate and bit timing */
    /* Enabling CDR usage and setting ESF= ERR_SCALE_FACT16. SCR_WCAN_PAGE = 0 already */
    SCR_WCAN_CDR_CTRL.U       = (1u << IFX_SCR_WCAN_CDR_CTRL_CDREN_OFF) | (1u << IFX_SCR_WCAN_CDR_CTRL_ESF_OFF);
    SCR_WCAN_CDR_UPPER_CTRL.U = (uint8)upper;
    SCR_WCAN_CDR_LOWER_CTRL.U = (uint8)lower;

    SCR_WCAN_PAGE.U           = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;

    /* Configuring sample point, prescalar and timequanta for 1bit in Can frame */
    SCR_WCAN_BTL2_CTRL.U = ((baudrateLookup[wcanConfig->baudrate].samplePoint & ~(IFX_SCR_WCAN_BTL2_CTRL_BRP_MSK << IFX_SCR_WCAN_BTL2_CTRL_BRP_OFF)) | (baudrateLookup[wcanConfig->baudrate].prescaler << IFX_SCR_WCAN_BTL2_CTRL_BRP_OFF));
    SCR_WCAN_BTL1_CTRL.U = baudrateLookup[wcanConfig->baudrate].bitTq;

    /*TODO : CAN FD configuration FD_CTRL*/
    SCR_WCAN_PAGE.U     = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_CFG.U      = (SCR_WCAN_CFG.U & ~((1u << IFX_SCR_WCAN_CFG_CCE_OFF) | (1u << IFX_SCR_WCAN_CFG_SELWK_EN_OFF)));       /* CCE=0 and SElWK_EN=0 */

    SCR_WCAN_PAGE.U     = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;
    /* Setting the data length for the message to be filtered */
    SCR_WCAN_DLC_CTRL.U = dataLength;

    /* Setting the ID, ID mask and IDE for the CAN message to be filtered */
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x02u;

    if (wcanConfig->canVersion == IfxScrWcan_CanVersion_standard)
    {
        /* For Standard CAN messages, Bits 0 to 17 are don't care and bits 18 to 28 contain the 11 bit ID */
        SCR_WCAN_ID2_CTRL.U      = (uint8)(wcanConfig->idFilter << 2u);
        SCR_WCAN_ID3_CTRL.U      = (uint8)(((wcanConfig->idFilter >> 4u) & 0xFCU) | wcanConfig->canVersion); /* Shift of 8-2(due to it starting from 18th bit) -2() */

        SCR_WCAN_MASK_ID2_CTRL.U = (uint8)(wcanConfig->idFilterMask << 2u);
        SCR_WCAN_MASK_ID3_CTRL.U = (uint8)(wcanConfig->idFilterMask >> 4u);                                  /* Shift of 8-2(due to it starting from 18th bit) -2() */
    }
    else if (wcanConfig->canVersion == IfxScrWcan_CanVersion_extended)
    {
        SCR_WCAN_ID0_CTRL.U      = (uint8)(wcanConfig->idFilter);
        SCR_WCAN_ID1_CTRL.U      = (uint8)(wcanConfig->idFilter >> 8u);
        SCR_WCAN_ID2_CTRL.U      = (uint8)(wcanConfig->idFilter >> 16u);
        SCR_WCAN_ID3_CTRL.U      = (uint8)(((wcanConfig->idFilter >> 22u) & 0xFCU) | wcanConfig->canVersion);

        SCR_WCAN_MASK_ID0_CTRL.U = (uint8)(wcanConfig->idFilterMask);
        SCR_WCAN_MASK_ID1_CTRL.U = (uint8)(wcanConfig->idFilterMask >> 8u);
        SCR_WCAN_MASK_ID2_CTRL.U = (uint8)(wcanConfig->idFilterMask >> 16u);
        SCR_WCAN_MASK_ID3_CTRL.U = (uint8)(wcanConfig->idFilterMask >> 22u);
    }

    /* Setting data for the CAN messages to be filtered according to datalength */
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x03u;

    SCR_WCAN_DATA0_CTRL.U = wcanConfig->dataFilter[0];
    SCR_WCAN_DATA1_CTRL.U = wcanConfig->dataFilter[1];
    SCR_WCAN_DATA2_CTRL.U = wcanConfig->dataFilter[2];
    SCR_WCAN_DATA3_CTRL.U = wcanConfig->dataFilter[3];
    SCR_WCAN_DATA4_CTRL.U = wcanConfig->dataFilter[4];
    SCR_WCAN_DATA5_CTRL.U = wcanConfig->dataFilter[5];
    SCR_WCAN_DATA6_CTRL.U = wcanConfig->dataFilter[6];
    SCR_WCAN_DATA7_CTRL.U = wcanConfig->dataFilter[7];

    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_CFG.U |= (1 << IFX_SCR_WCAN_CFG_SELWK_EN_OFF);    /* Enabling the protocol handler SELWK_EN=1 */

    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;

    while (SCR_WCAN_INTESTAT0.U & 1U != 1)   /* Wait till SWACK=1 */
    {}
}


void IfxScrWcan_setBaudrate(uint8 baudrate)
{
    /* +5% of BTL1_CTRL value and -5% of BTL1_CTRL(bit time quanta) value*/
    float upper = 1.05 * baudrateLookup[baudrate].bitTq;
    float lower = 0.95 * baudrateLookup[baudrate].bitTq;

    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_CFG.U  = SCR_WCAN_CFG.U | (1u << IFX_SCR_WCAN_CFG_CCE_OFF);  /* CCE=1 */

    /* Configuring the Baud Rate and bit timing */

    /* Enabling CDR usage and setting ESF= ERR_SCALE_FACT16. SCR_WCAN_PAGE = 0 already */
    SCR_WCAN_CDR_CTRL.U       = (1u << IFX_SCR_WCAN_CDR_CTRL_CDREN_OFF) | (1u << IFX_SCR_WCAN_CDR_CTRL_ESF_OFF);
    SCR_WCAN_CDR_UPPER_CTRL.U = (uint8)upper;
    SCR_WCAN_CDR_LOWER_CTRL.U = (uint8)lower;

    SCR_WCAN_PAGE.U           = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;

    SCR_WCAN_BTL2_CTRL.U      = ((baudrateLookup[baudrate].samplePoint & ~(IFX_SCR_WCAN_BTL2_CTRL_BRP_MSK << IFX_SCR_WCAN_BTL2_CTRL_BRP_OFF)) | (baudrateLookup[baudrate].prescaler << IFX_SCR_WCAN_BTL2_CTRL_BRP_OFF));
    SCR_WCAN_BTL1_CTRL.U      = baudrateLookup[baudrate].bitTq;

    SCR_WCAN_PAGE.U           = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_CFG.U            = SCR_WCAN_CFG.U & ~(1u << IFX_SCR_WCAN_CFG_CCE_OFF); /* CCE=0 */
}
