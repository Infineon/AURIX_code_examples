/**
 * \file IfxPcieDma.h
 * \brief PCIE  basic functionality
 * \ingroup IfxLld_Pcie
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pcie_Std_Dma Dma Basic Functionality
 * \ingroup IfxLld_Pcie_Std
 * \defgroup IfxLld_Pcie_Std_Dma_Enumerations Enumerations
 * \ingroup IfxLld_Pcie_Std_Dma
 * \defgroup IfxLld_Pcie_Std_Dma_Structures Structures
 * \ingroup IfxLld_Pcie_Std_Dma
 * \defgroup IfxLld_Pcie_Std_Dma_Functions Functions
 * \ingroup IfxLld_Pcie_Std_Dma
 */

#ifndef IFXPCIEDMA_H
#define IFXPCIEDMA_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Pcie/Std/IfxPcie.h"
#include "_Impl/IfxPcie_cfg.h"
#include "IfxPcie_dsp_bf.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Transfer List Data Element
 */
#define IFXPCIEDMA_TRANSFER_LIST_DATA_ELEMENT(sourceAddr, destAddr, size, localInt, remoteInt, cycleBit) \
    (uint32)((uint32)0u | ((uint32)remoteInt << 4u) | ((uint32)localInt << 3u) | ((uint32)(cycleBit))),  \
    (uint32)size,                                                                                        \
    (uint32)(sourceAddr),                                                                                \
    (uint32)((uint64)sourceAddr >> 32u),                                                                 \
    (uint32)(destAddr),                                                                                  \
    (uint32)((uint64)destAddr >> 32u)

/** \brief Transfer List Link Element
 */
#define IFXPCIEDMA_TRANSFER_LIST_LINK_ELEMENT(llPointer, toggleCycleBit, cycleBit)                    \
    (uint32)((uint32)0u | ((uint32)1 << 2u) | ((uint32)toggleCycleBit << 1u) | ((uint32)(cycleBit))), \
    (uint32)0u,                                                                                       \
    (uint32)(llPointer),                                                                              \
    (uint32)((uint64)llPointer >> 32u),                                                               \
    (uint32)(0),                                                                                      \
    (uint32)(0)

/** \brief Transfer List List Element Size
 */
#define IFXPCIEDMA_TRANSFER_LIST_ELEMENT_WORD_SIZE ((uint32)6)

/** \brief Word count from Transfer List count
 */
#define IFXPCIEDMA_TRANSFER_LIST_ELEMENT_WORD_COUNT(listSize) (listSize * IFXPCIEDMA_TRANSFER_LIST_ELEMENT_WORD_SIZE)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Std_Dma_Enumerations
 * \{ */
/** \brief DMA channel ID
 */
typedef enum
{
    IfxPcieDma_Channel_0 = 0,  /**< \brief DMA channel 0 */
    IfxPcieDma_Channel_1,      /**< \brief DMA channel 1 */
    IfxPcieDma_Channel_2,      /**< \brief DMA channel 2 */
    IfxPcieDma_Channel_3,      /**< \brief DMA channel 3 */
    IfxPcieDma_Channel_count   /**< \brief MAX number of DMA Channels */
} IfxPcieDma_Channel;

/** \brief DMA channel arbitration weight . This is used for MultiChannel arbitration
 */
typedef enum
{
    IfxPcieDma_ChannelArbWeight_1,   /**< \brief DMA Channel Arbitration Weight 1 */
    IfxPcieDma_ChannelArbWeight_2,   /**< \brief DMA Channel Arbitration Weight 2 */
    IfxPcieDma_ChannelArbWeight_3,   /**< \brief DMA Channel Arbitration Weight 3 */
    IfxPcieDma_ChannelArbWeight_4,   /**< \brief DMA Channel Arbitration Weight 4 */
    IfxPcieDma_ChannelArbWeight_5,   /**< \brief DMA Channel Arbitration Weight 5 */
    IfxPcieDma_ChannelArbWeight_6,   /**< \brief DMA Channel Arbitration Weight 6 */
    IfxPcieDma_ChannelArbWeight_7,   /**< \brief DMA Channel Arbitration Weight 7 */
    IfxPcieDma_ChannelArbWeight_8,   /**< \brief DMA Channel Arbitration Weight 8 */
    IfxPcieDma_ChannelArbWeight_9,   /**< \brief DMA Channel Arbitration Weight 9 */
    IfxPcieDma_ChannelArbWeight_10,  /**< \brief DMA Channel Arbitration Weight 10 */
    IfxPcieDma_ChannelArbWeight_11,  /**< \brief DMA Channel Arbitration Weight 11 */
    IfxPcieDma_ChannelArbWeight_12,  /**< \brief DMA Channel Arbitration Weight 12 */
    IfxPcieDma_ChannelArbWeight_13,  /**< \brief DMA Channel Arbitration Weight 13 */
    IfxPcieDma_ChannelArbWeight_14,  /**< \brief DMA Channel Arbitration Weight 14 */
    IfxPcieDma_ChannelArbWeight_15,  /**< \brief DMA Channel Arbitration Weight 15 */
    IfxPcieDma_ChannelArbWeight_16,  /**< \brief DMA Channel Arbitration Weight 16 */
    IfxPcieDma_ChannelArbWeight_17,  /**< \brief DMA Channel Arbitration Weight 17 */
    IfxPcieDma_ChannelArbWeight_18,  /**< \brief DMA Channel Arbitration Weight 18 */
    IfxPcieDma_ChannelArbWeight_19,  /**< \brief DMA Channel Arbitration Weight 19 */
    IfxPcieDma_ChannelArbWeight_20,  /**< \brief DMA Channel Arbitration Weight 20 */
    IfxPcieDma_ChannelArbWeight_21,  /**< \brief DMA Channel Arbitration Weight 21 */
    IfxPcieDma_ChannelArbWeight_22,  /**< \brief DMA Channel Arbitration Weight 22 */
    IfxPcieDma_ChannelArbWeight_23,  /**< \brief DMA Channel Arbitration Weight 23 */
    IfxPcieDma_ChannelArbWeight_24,  /**< \brief DMA Channel Arbitration Weight 24 */
    IfxPcieDma_ChannelArbWeight_25,  /**< \brief DMA Channel Arbitration Weight 25 */
    IfxPcieDma_ChannelArbWeight_26,  /**< \brief DMA Channel Arbitration Weight 26 */
    IfxPcieDma_ChannelArbWeight_27,  /**< \brief DMA Channel Arbitration Weight 27 */
    IfxPcieDma_ChannelArbWeight_28,  /**< \brief DMA Channel Arbitration Weight 28 */
    IfxPcieDma_ChannelArbWeight_29,  /**< \brief DMA Channel Arbitration Weight 29 */
    IfxPcieDma_ChannelArbWeight_30,  /**< \brief DMA Channel Arbitration Weight 30 */
    IfxPcieDma_ChannelArbWeight_31,  /**< \brief DMA Channel Arbitration Weight 31 */
    IfxPcieDma_ChannelArbWeight_32   /**< \brief DMA Channel Arbitration Weight 32 */
} IfxPcieDma_ChannelArbWeight;

/** \brief DMA channel Mode
 */
typedef enum
{
    IfxPcieDma_ChannelMode_contextBased,  /**< \brief DMA channel Operates using context registers */
    IfxPcieDma_ChannelMode_txList         /**< \brief DMA channel operates using Tx List */
} IfxPcieDma_ChannelMode;

/** \brief DMA channel status
 */
typedef enum
{
    IfxPcieDma_ChannelStatus_unknown = 0,  /**< \brief Status unknown */
    IfxPcieDma_ChannelStatus_running,      /**< \brief Channel running */
    IfxPcieDma_ChannelStatus_halted,       /**< \brief Channel halted */
    IfxPcieDma_ChannelStatus_stopped       /**< \brief Channel stopped */
} IfxPcieDma_ChannelStatus;

/** \brief DMA channel Type
 */
typedef enum
{
    IfxPcieDma_ChannelType_read,  /**< \brief DMA channel direction write */
    IfxPcieDma_ChannelType_write  /**< \brief DMA channel direction read */
} IfxPcieDma_ChannelType;

/** \brief DMA HW error types
 */
typedef enum
{
    IfxPcieDma_Error_none = 0,        /**< \brief No DMA error */
    IfxPcieDma_Error_busError,        /**< \brief The DMA channel has received an error response from the AHB/AXI bus (or RTRGT1 interface when the AHB/AXI Bridge is not used) while reading data from it. It's fatal error. */
    IfxPcieDma_Error_llFetch,         /**< \brief DMA Write/Read Channel has recieved error reponse while reading a Linked list element from local memory. Its a fatal Error. */
    IfxPcieDma_Error_unsupportedReq,  /**< \brief Dma read channel has received a PCIe Unsupported Request CPL status from remote device in response to MRd request. */
    IfxPcieDma_Error_cplAbort,        /**< \brief Dma read channel has received a PCIe Completer abort CPL status from remote device in response to MRd request. */
    IfxPcieDma_Error_cplTimeout,      /**< \brief The DMA Read Channel has timed-out while waiting for the remote device to respond to the MRd Request,or a malformed CplD has been received. Non-fatal error */
    IfxPcieDma_Error_dataPoisoning    /**< \brief The DMA Read Channel has detected data poisoning in the CPL from the remote device in response to the MRd Request. Non-fatal error. */
} IfxPcieDma_Error;

/** \brief DMA Interrupt Mode
 */
typedef enum
{
    IfxPcieDma_InterruptMode_none   = -1, /**< \brief DMA Local interrupt */
    IfxPcieDma_InterruptMode_local  = 0,  /**< \brief DMA Local interrupt */
    IfxPcieDma_InterruptMode_remote = 1   /**< \brief DMA Remote interrupt */
} IfxPcieDma_InterruptMode;

/** \brief DMA Interrupt type
 */
typedef enum
{
    IfxPcieDma_InterruptType_none  = -1, /**< \brief No Interrupt */
    IfxPcieDma_InterruptType_done  = 0,  /**< \brief DMA Done interrupt */
    IfxPcieDma_InterruptType_abort = 1   /**< \brief DMA Abort interrupt */
} IfxPcieDma_InterruptType;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Std_Dma_Structures
 * \{ */
/** \brief DMA Transfer List Element Word 0 Bits
 */
typedef struct
{
    uint32 CB : 1;             /**< \brief [0:0]cycle Bit */
    uint32 TCB : 1;            /**< \brief [1:1] TCB : only for Link Element */
    uint32 LLP : 1;            /**< \brief [2:2] Link element */
    uint32 LIE : 1;            /**< \brief [3:3] Local Interrupt Enable : only for Data Element */
    uint32 RIE : 1;            /**< \brief [4:4] Local Interrupt Enable : only for Data Element */
    uint32 reserved : 26;      /**< \brief Reserved */
} IfxPcieDma_TxListWord0_Bits;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Dma_Structures
 * \{ */
/** \brief DMA LL data element Word 0
 */
typedef union
{
    IfxPcieDma_TxListWord0_Bits B;       /**< \brief DMA Tx List element W0 Bits */
    uint32                      U;       /**< \brief DMA Tx List element W0 word */
} IfxPcieDma_TxListWord0;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Dma_Structures
 * \{ */
/** \brief DMA data element or descriptor structure
 */
typedef struct
{
    IfxPcieDma_TxListWord0 W0;                 /**< \brief Word 0 */
    uint32                 transferSize;       /**< \brief Transfer size of DMA operation */
    uint32                 sarLow;             /**< \brief Source address lower 32 bit address */
    uint32                 sarHigh;            /**< \brief Source address 32bit high */
    uint32                 darLow;             /**< \brief Destination address 32bit low */
    uint32                 darHigh;            /**< \brief Destination address 32bit high */
} IfxPcieDma_TxListDataElement;

/** \brief DMA Link element in DMA linked list operation
 */
typedef struct
{
    IfxPcieDma_TxListWord0 W0;                /**< \brief Word 0 */
    uint32                 reserved_32;       /**< \brief Reserved */
    uint32                 LinkPtrLow;        /**< \brief Link element ptr low */
    uint32                 LinkPtrHigh;       /**< \brief Link element pointer high */
    uint32                 reserved[2];       /**< \brief Reserved */
} IfxPcieDma_TxListLinkElement;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Dma_Structures
 * \{ */
/** \brief APU config strucuture. Configure PROTSE separately.
 */
typedef struct
{
    IfxApApu_ApuConfig apuConfig[IFXPCIE_CFG_NUM_DMA_WRITE_CHANNELS];       /**< \brief APU config for read/write channel */
} IfxPcieDma_ApConfig;

/** \brief DMA Transfer List element
 */
typedef union
{
    IfxPcieDma_TxListDataElement dataElement;       /**< \brief DMA data element */
    IfxPcieDma_TxListLinkElement linkElement;       /**< \brief DMA link element */
} IfxPcieDma_TxListElement;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Dma_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Set the DMA doorbell by writing channel number. This starts the DMA channel.
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return None
 */
IFX_EXTERN void IfxPcieDma_startChannel(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Abort transfer
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return None
 */
IFX_EXTERN void IfxPcieDma_stopChannel(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Get the DMA channel status
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return IfxPcieDma_ChannelStatus status of the channel
 */
IFX_EXTERN IfxPcieDma_ChannelStatus IfxPcieDma_getChannelStatus(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Get DMA transfer size of the current operation
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return uint32 size of current transfer
 */
IFX_EXTERN uint32 IfxPcieDma_getTransferSize(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Enable Link List operation
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return None
 */
IFX_EXTERN void IfxPcieDma_enableChannelTxListOperation(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Disable Link List operation
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return None
 */
IFX_EXTERN void IfxPcieDma_disableChannelTxListOperation(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Set CCS bit in the Control register
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param ccsValue CCS value (0, 1).
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelCCS(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, uint8 ccsValue);

/** \brief Get the current Data Element ptr in the LL DMA operation
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return uint64 Pointer to current LL element
 */
IFX_EXTERN uint32 *IfxPcieDma_getChannelCurrentTxListPtr(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief DMA soft reset
 * \param dmaSFR Pointer to DMA capability register
 * \param chType Channel Type
 * \return None
 */
IFX_EXTERN void IfxPcieDma_softReset(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_ChannelType chType);

/** \brief Set DMA channel control flags
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param tlpFlags Word format TLP Flags
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelTlpParams(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, uint32 tlpFlags);

/** \brief Set DMA channel control flags
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param localInt if TRUE: local Interrupt is Enabled
 * \param remoteInt if TRUE: remote Interrupt is Enabled
 * \return None
 */
IFX_EXTERN void IfxPcieDma_enableChannelInterrupts(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, boolean localInt, boolean remoteInt);

/** \brief Set Interrupt Mask for a Local Channel Interrupt
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param doneInt if TRUE: mask DONE interrupt
 * \param abortInt if TRUE: mask ABORT interrupt
 * \return None
 */
IFX_EXTERN void IfxPcieDma_maskChannelInterrupts(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, boolean doneInt, boolean abortInt);

/** \brief Clear a Local Channel Interrupt
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param doneInt if TRUE: clear DONE interrupt
 * \param abortInt if TRUE: clear ABORT interrupt
 * \return None
 */
IFX_EXTERN void IfxPcieDma_clearChannelInterrupts(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, boolean doneInt, boolean abortInt);

/** \brief Get Pending Interrupt Type from a channel
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return type of interrupt occurred (None, Done, Abort)
 */
IFX_EXTERN IfxPcieDma_InterruptType IfxPcieDma_getChannelPendingInterrupt(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Get Current Error Status from Channel
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \return type of Error
 */
IFX_EXTERN IfxPcieDma_Error IfxPcieDma_getChannelError(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType);

/** \brief Set Transfer List Error Interrupt
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param localErrInt if TRUE: Local Error Interrupt is enabled
 * \param remoteErrInt if TRUE: Remote Error Interrupt is enabled
 * \return None
 */
IFX_EXTERN void IfxPcieDma_enableChannelTxListErrorInt(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, boolean localErrInt, boolean remoteErrInt);

/** \brief Set DMA transfer size for current DMA transaction
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param transferSize Transfer size of the DMa transaction
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelTransferSize(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, uint32 transferSize);

/** \brief Set DMA arbitration weight
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param weight Multi channel arbitration weight
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelArbWeight(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, IfxPcieDma_ChannelArbWeight weight);

/** \brief Set the source address of the DMA operation
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param srcAddr source Address
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelSrcAddr(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, uint64 srcAddr);

/** \brief Set DMA destination address for DMA transaction
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param desAddr destination Address
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelDestAddr(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, uint64 desAddr);

/** \brief Set MSI address to send Abort/Done IMWr TLP to the remote device
 * \param dmaSFR Pointer to DMA capability register
 * \param chType Channel Type
 * \param intType Interrupt type
 * \param msiAddr MSI address
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setMsiAddr(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_ChannelType chType, IfxPcieDma_InterruptType intType, uint64 msiAddr);

/** \brief Set MSI address to send Abort/Done IMWr TLP to the remote device
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param msiData MSI Data
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelMsiData(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, uint16 msiData);

/** \brief Set Linked list pointer
 * \param dmaSFR Pointer to DMA capability register
 * \param channelId Channel ID
 * \param chType Channel Type
 * \param txListPtr Pointer to the Transfer List
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setChannelTxListPtr(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_Channel channelId, IfxPcieDma_ChannelType chType, uint32 *txListPtr);

/** \brief Enable DMA read write logic
 * \param dmaSFR Pointer to DMA capability register
 * \param chType Channel Type
 * \param enable if TRUE: DMA Write Engine Enabled
 * \return None
 */
IFX_EXTERN void IfxPcieDma_setEngineEnable(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_ChannelType chType, boolean enable);

/** \brief Enable DMA read write logic
 * \param dmaSFR Pointer to DMA capability register
 * \param chType Channel Type
 * \return TRUE: Engine is Enabled
 */
IFX_EXTERN boolean IfxPcieDma_isEngineEnabled(Ifx_PCIE_DSP_DMACAP *dmaSFR, IfxPcieDma_ChannelType chType);

/** \brief Init APU config
 * \param config AP config Ptr
 * \return None
 */
IFX_EXTERN void IfxPcieDma_initApConfig(IfxPcieDma_ApConfig *config);

/** \brief Init AP
 * \param pcieSFR Ptr to EP SFR
 * \param config AP config Ptr
 * \return None
 */
IFX_EXTERN void IfxPcieDma_initAp(Ifx_PCIE_DSP *pcieSFR, IfxPcieDma_ApConfig *config);

/** \} */

#endif /* IFXPCIEDMA_H */
