/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "scr_adcomp_sdcc.h"
#include "scr_io_sdcc.h"
#include "scr_irq_sdcc.h"
#include "scr_rtc_sdcc.h"
#include "scr_scu_sdcc.h"
#include "scr_sfr_sdcc.h"
#include "scr_wdt_sdcc.h"
#include "scr_common.h"
#include "../AppBsp_Conf.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define RTC_INTERVAL_1S             FALSE

#define ADC_MAX_CONVERSIONS         11u     /* 1 dummy sample + 10 measurements for evaluation */
#define ADC_WAKE_THRESHOLD          66u     /* ~1500 mV ( VIN=[LSB*(ADCRES-1)] / LSB = 23.077 mV */
#define ADC_THRESHOLD_WAKE_UP       TRUE
#define ADC_MONITOR_ACTIVE_TIME     TRUE

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* XRAM memory for TriCore <-> SCR data exchange.
 * - Size and structure need to be aligned with section '.xdata' in scr.ld
 *
 * ATTENTION: The compiler does not reserve any space for variables declared in this way (they are implemented with
 *            an equate in the assembler). Thus it is left to the programmer to make sure there are no overlaps with
 *            other variables that are declared without the absolute address!
 */
__xdata volatile uint8 __at (XRAM_EXCHANGE_OFFSET) g_exchangeBytes[4];

/* Place global helper variables in internal data memory */
__data volatile uint8 g_debugCounter;
__data volatile uint8 g_newADCresult;           /* Global variable to store the last ADC measurement */
__data volatile uint8 g_adcAverage;             /* Global variable to store the filtered ADC measurement */
__data volatile uint8 g_numberOfConversions;    /* Global variable to count number of conversions */

/* Place flags which need fast access (like from ISR) in the bit-addressable internal data memory (16 bytes of RAM
 * that occupy addresses from 20h to 2Fh).
 */
__bit g_disabledHF;     /* Global HF mode flag (TRUE = HF disabled, FALSE = HF enabled) */
__bit g_newADCtrigger;  /* Start next ADC conversion flag */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void rtcIsrHandler(void) __interrupt (XINTR13);
void adcIsrHandler(void) __interrupt (XINTR7);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void main(void)
{
    /* Enable access to non-mapped (standard) special function register area */
    SCR_SYSCON0 = 0;
    /* Disable watchdog timer, to ensure it will not disrupt the idle mode */
    SCR_WDT_CON = 0;

    /* Initialize the dummy counter for debug purpose */
    g_debugCounter = 0;
    /* Set HF mode flag to enabled (default after reset) */
    g_disabledHF = FALSE;
    /* Initialize ADC status flag, conversion counter and current measured value */
    g_newADCtrigger = FALSE;
    g_numberOfConversions = 0;
    g_newADCresult = 0;

    /* Initialize the TC shared memory locations for the RTC overflow.
     * May be overwritten from the TriCore(TM) for change of the RTC period */
#if RTC_INTERVAL_1S
    /* Counter setting for 1s@70kHz */
    g_exchangeBytes[3] = 0x00;
    g_exchangeBytes[2] = 0x01;
    g_exchangeBytes[1] = 0x11;
    g_exchangeBytes[0] = 0x70;
#else
    /* Counter setting for 0.2s@70kHz */
    g_exchangeBytes[3] = 0x00;
    g_exchangeBytes[2] = 0x00;
    g_exchangeBytes[1] = 0x36;
    g_exchangeBytes[0] = 0xB0;
#endif /* RTC_INTERVAL_1S */

#if USE_KIT_A2G_TC375_LITE
    /* Enable available pins
       P33.0 - P33.6, P33.9 - P33.13 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.1 to P01.5 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 );

    SCR_SET_IO_PAGE(MOD_PAGE_0);
#if ADC_MONITOR_ACTIVE_TIME
    /* Initialize P00.1 (P33.1) and P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = (ScrIoPin1 | ScrIoPin4);
#else
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;
#endif /* ADC_MONITOR_ACTIVE_TIME */

    SCR_SET_IO_PAGE(MOD_PAGE_1);
#if ADC_MONITOR_ACTIVE_TIME
    /* Set P00.1 / P33.1 as output, push-pull (external LED) */
    SCR_IO_P00_IOCR1 = ScrPortMode_outputPushPullGeneral;
#endif /* ADC_MONITOR_ACTIVE_TIME */
    /* Set P00.4 (P33.4) as output, push-pull */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (connect to button 1) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;

    /* Errata SCR_TC.021
     * - RTC not counting after reset if P33.10 is high.
     * - Device: TC37xEXT
     * - Marking/Step: (E)ES-AA)
     * 
     * Clear P01.2 (P33.10) to ensure a low level at the beginning, otherwise
     * it is possible that the RTC will not start.
     */
    SCR_SET_IO_PAGE(MOD_PAGE_0);
    SCR_IO_P01_OUT &= (~ScrIoPin2);
    /* Set P01.2 (P33.10) as output, push-pull */
    SCR_SET_IO_PAGE(MOD_PAGE_1);
    SCR_IO_P01_IOCR2 = ScrPortMode_outputPushPullGeneral;
    /* ~Errata SCR_TC.021 */
#endif /* USE_KIT_A2G_TC375_LITE */

#if USE_KIT_A2G_TC397_5V_TFT
    /* Enable available pins
       P33.0 - P33.6, P33.10 - P33.12 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.2 to P01.4 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin2 | ScrIoPin3 | ScrIoPin4);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
#if ADC_MONITOR_ACTIVE_TIME
    /* Initialize P00.1 (P33.1) and P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = (ScrIoPin1 | ScrIoPin4);
#else
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;
#endif /* ADC_MONITOR_ACTIVE_TIME */

    SCR_SET_IO_PAGE(MOD_PAGE_1);
#if ADC_MONITOR_ACTIVE_TIME
    /* Set P00.1 / P33.1 as output, push-pull (external LED) */
    SCR_IO_P00_IOCR1 = ScrPortMode_outputPushPullGeneral;
#endif /* ADC_MONITOR_ACTIVE_TIME */
    /* Set P00.4 (P33.4) as output, push-pull */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, pull up (external switch) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputPullUp;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_A2G_TC397_5V_TFT */

#if USE_KIT_TC397_TRB
    /* Enable available pins 
       P33.0 - P33.7, P34.1, P33.11 - P33.15 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);
    /* Enable P01.0, P01.3 to P01.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin0 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
#if ADC_MONITOR_ACTIVE_TIME
    /* Initialize P00.1 (P33.1) and P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = (ScrIoPin1 | ScrIoPin4);
#else
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;
#endif /* ADC_MONITOR_ACTIVE_TIME */

    SCR_SET_IO_PAGE(MOD_PAGE_1);
#if ADC_MONITOR_ACTIVE_TIME
    /* Set P00.1 / P33.1 as output, push-pull (external LED) */
    SCR_IO_P00_IOCR1 = ScrPortMode_outputPushPullGeneral;
#endif /* ADC_MONITOR_ACTIVE_TIME */
    /* Set P00.4 / P33.4 as output, push-pull (LED D302) */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (S202) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_TC397_TRB */

    /* Enable 20MHz clock to SCR */
    Scr_set_fsys(DIV5);

    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    while(!Scr_is_in_standby()); /* Wait until TC enters standby mode */

    /*** Initialize interrupts ***/
    SCR_SET_SCU_PAGE(MOD_PAGE_1);
    /* Disable request: all except RTC and OCDS */
    SCR_SCU_PMCON1 = (LIN_DIS_MASK | WDT_DIS_MASK | WCAN_DIS_MASK | T2CCU_DIS_MASK | SSC_DIS_MASK);
    /* Clear all NMI service request flags. I.e. FNMIWKP */
    SCR_SCU_NMISR = 0x0;

    /* Reset all interrupts */
    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    SCR_SCU_IRCON0 = 0;
    SCR_SCU_IRCON1 = 0;
    SCR_SCU_IRCON2 = 0;

    /* Interrupt enable register 1:
     *  XINTR13 - interrupt node enable (RTC interrupt).
     *  XINTR7  - interrupt node enable (SSC/ADC interrupt).
     */
    SCR_IEN1 = 0x82;
    /* Interrupt enable register 0:
     *  EA - Global Interrupt Mask set.
     */
    SCR_IEN0_EA = 1;
    /*** ~Initialize interrupts ***/

    /*** Initialize RTC ***/
    Scr_set_count_registers(0);
    /* Set RTC overflow setting with the shared data from the TC */
    SCR_RTC_CR3 = g_exchangeBytes[3];
    SCR_RTC_CR2 = g_exchangeBytes[2];
    SCR_RTC_CR1 = g_exchangeBytes[1];
    SCR_RTC_CR0 = g_exchangeBytes[0];
    /*** ~Initialize RTC ***/

    /* Switch to LF mode */
    Scr_set_fsys_70kHz();
    /* Set HF mode flag to disabled */
    g_disabledHF = TRUE;
    /* Enable Real-Time clock compare interrupt, 9-bit prescaler is bypassed, 70 kHz clock is selected */
    SCR_RTC_CON = (ECRTC_MASK | RTPBYP_MASK);
    /* Start Real-Time clock operation */
    Scr_start_rtc();

    while(1)
    {
        /* Check if HF clock is enabled in the application */
        if(!g_disabledHF)
        {
            /*** Do all tasks if HFclock is ready ***/
            SCR_SET_SCU_PAGE(MOD_PAGE_0);

            /* Check if ADCOMP is already enabled */
            if(Scr_is_adc_enabled())
            {
                /* Check if a conversion phase is completed */
                if(g_newADCtrigger)
                {
                    g_newADCtrigger = FALSE;

                    /* Check if more samples should be taken */
                    if(g_numberOfConversions < ADC_MAX_CONVERSIONS)
                    {
                        /* Check if ADC result is ready */
                        if(Scr_is_adc_result_valid())
                        {
                            /* Read latest conversion result */
                            g_newADCresult = Scr_get_adc_result();
                        }

                        /* Trigger next conversion */
                        Scr_trigger_adc();
                        /* In this example only channel 1 is acquired */
                        Scr_set_adc_channel(1);

                        if(0u == g_numberOfConversions)
                        {
                            /* Discard first dummy measurement and reset average */
                            g_adcAverage = 0;
                        }
                        else 
                        {
                            /* Apply moving average filter */
                            g_adcAverage >>= 1;
                            g_adcAverage += (g_newADCresult >>= 1);
                        }

                        /* Increment conversion counter */
                        g_numberOfConversions++;

                    #if ADC_MONITOR_ACTIVE_TIME
                        /* Set P00.1 (LED on) */
                        SCR_SET_IO_PAGE(MOD_PAGE_0);
                        SCR_IO_P00_OMTR = ScrIoPin1;
                    #endif /* ADC_MONITOR_ACTIVE_TIME */
                    }
                    else
                    {
                        /* Disable ADC */
                        Scr_deinit_adc();
                        /* Apply final measurement to moving average */
                        g_adcAverage >>= 1;
                        g_adcAverage += (g_newADCresult >>= 1);
                        /* Reset conversion counter */
                        g_numberOfConversions = 0;

                        /*** Disable HF clock when all tasks are complete ***/

                        /* Trigger LF mode */
                        Scr_set_fsys_70kHz();
                        /* Set HF mode flag to disabled */
                        g_disabledHF = TRUE;

                        /* Start Real-Time clock operation */
                        Scr_start_rtc();

                #if ADC_THRESHOLD_WAKE_UP
                        /* Check if measured value is above the limit */
                        if(g_adcAverage >= ADC_WAKE_THRESHOLD)
                        {
                            /* Software Wake-Up from Standby Mode */
                            SCR_SET_SCU_PAGE(MOD_PAGE_1);
                            SCR_SCU_STDBYWKP = SCRWKP_MASK;
                            while(Scr_is_in_standby());    /* Wait until TC leaves standby mode */
                        }
                #endif /* ADC_THRESHOLD_WAKE_UP */
                    }
                }
            }
            else
            {
                /* Periodic update of RTC overflow setting with the shared data from the TC */
                SCR_RTC_CR3 = g_exchangeBytes[3];
                SCR_RTC_CR2 = g_exchangeBytes[2];
                SCR_RTC_CR1 = g_exchangeBytes[1];
                SCR_RTC_CR0 = g_exchangeBytes[0];

            #if ADC_MONITOR_ACTIVE_TIME
                /* Set P00.1 (LED on) */
                SCR_SET_IO_PAGE(MOD_PAGE_0);
                SCR_IO_P00_OMCR = ScrIoPin1;
            #endif /* ADC_MONITOR_ACTIVE_TIME */

                /* Start ADCOMP */
                Scr_init_adc();
                while(!(SCR_SCU_ADCOMP_CON & EOCSAMPLE_MASK))
                {}
                /* Trigger dummy conversion */
                Scr_trigger_adc();
                /* Update channel for next sampling phase */
                Scr_set_adc_channel(1);
            }
        }
    }
}

/* RTC Interrupt Service Routine (using SCR Interrupt Node 13)  */
void rtcIsrHandler(void) __interrupt (XINTR13)
{
    SCR_SET_SCU_PAGE_STNR1(MOD_PAGE_0); /* Store current SCU page and switch to page 0 */
    SCR_SET_IO_PAGE_STNR1(MOD_PAGE_0);  /* Store current IO page and switch to page 0 */
    /* Clear compare match flag set by hardware */
    SCR_RTC_CON &= (~CFRTC_MASK);

    /* Share the dummy counter with TC via SCRINTEXCHG, counter for debug purpose */
    g_debugCounter = SCR_SCU_SCRINTEXCHG;
    g_debugCounter += 1;
    SCR_SCU_SCRINTEXCHG = g_debugCounter;

    /* Toggle P00.4 (LED) */
    SCR_IO_P00_OMTR = ScrIoPin4;

    /* Check if TC is in standby and the HF clock is disabled in the application */
    if(Scr_is_in_standby() && g_disabledHF)
    {
        /* Stop Real-Time clock operation
         * Not necessary, but depends on the application */
        Scr_stop_rtc();

        /* Enable 20MHz clock to SCR */
        Scr_set_fsys(DIV5);

        /* Set HF mode flag to enabled */
        g_disabledHF = FALSE;
    }

    SCR_RESTORE_IO_PAGE_STNR1();    /* Restore previous IO page */
    SCR_RESTORE_SCU_PAGE_STNR1();   /* Restore previous SCU page */
}

/* ADC Interrupt Service Routine (using SCR Interrupt Node 7) */
void adcIsrHandler(void) __interrupt (XINTR7)
{
    SCR_SET_SCU_PAGE_STNR2(MOD_PAGE_0); /* Store current SCU page and switch to page 0 */
    /* Clear ADC interrupt flag */
    SCR_SCU_IRCON1 &= (~(0x10));
    /* Signal conversion complete */
    g_newADCtrigger = TRUE;

#if ADC_MONITOR_ACTIVE_TIME
    SCR_SET_IO_PAGE_STNR2(MOD_PAGE_0);  /* Store current IO page and switch to page 0 */
    /* Toggle P00.1 */
    SCR_IO_P00_OMTR = ScrIoPin1;
    SCR_RESTORE_IO_PAGE_STNR2();    /* Restore previous IO page */
#endif /* ADC_MONITOR_ACTIVE_TIME */

    SCR_RESTORE_SCU_PAGE_STNR2();   /* Restore previous SCU page */
}
