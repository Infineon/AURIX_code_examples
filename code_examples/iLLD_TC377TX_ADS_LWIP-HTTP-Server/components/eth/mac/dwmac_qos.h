/**
 * \file  dwmac_qos.h
 * \brief
 *
 * \version ASDK_0_6_0
 * \copyright Copyright (c) 2019-2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or 
 * the company in which ordinary course of business you are acting and (ii) 
 * Infineon Technologies AG or its licensees. If and as long as no such 
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or 
 * organization obtaining a copy of the software and accompanying 
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the 
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE 
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 */

#ifndef DWMAC_QOS_H
#define DWMAC_QOS_H

#include "Cpu/Std/Ifx_Types.h"
#include "Geth/Eth/IfxGeth_Eth.h"
#include "IfxGeth_reg.h"
#include "IfxGeth_bf.h"

/**********************************************************************************************************************
 * MACROS
 *********************************************************************************************************************/

#define ETH_HEADER_LENGTH       18
#define ROUND_UP(N, S) ((((N) + (S) - 1) / (S)) * (S))
#define ETH_DMA_BUFFER_SIZE(size) ROUND_UP(size + ETH_HEADER_LENGTH, 8) /* bytes */

#define ETH_MAC_TX_QUEUE_CNT 4
#define ETH_MAC_RX_QUEUE_CNT 4
#define ETH_MAC_TX_DMA_CH_CNT 4
#define ETH_MAC_RX_DMA_CH_CNT 4

#define ETH_MAC_ADDR_LEN     6

#define ETH_MAC_DESC_IDX_INC(x, size)	((x + 1) & (size - 1))

#define GENMASK(h, l) \
	(((0xFFFFFFFF) - (1 << (l)) + 1) & \
	 (0xFFFFFFFF >> (BITS_PER_LONG - 1 - (h))))

#define BITMASK(field)           (field ## _MSK << field ## _OFF) 

#define BIT(n) ((1) << (n))

#define VAL2FLD(field, value)    (((uint32)(value) << field ## _OFF) & (field ## _MSK << field ## _OFF))
#define FLD2VAL(field, value)    (((uint32)(value) & (field ## _MSK << field ## _OFF)) >> field ## _OFF)

/**********************************************************************************************************************
 * ENUMS
 *********************************************************************************************************************/

/**
 * 
 */
typedef enum
{
  IfxGeth_RxQueueMode_disabled = 0,
  IfxGeth_RxQueueMode_avb = 1,
  IfxGeth_RxQueueMode_generic  = 2
} IfxGeth_RxQueueMode;

/**
 * 
 */
typedef enum
{
  IfxGeth_RxQueueVlanPrio_0 = 0x01,
  IfxGeth_RxQueueVlanPrio_1 = 0x02,
  IfxGeth_RxQueueVlanPrio_2 = 0x04,
  IfxGeth_RxQueueVlanPrio_3 = 0x08,
  IfxGeth_RxQueueVlanPrio_4 = 0x10,
  IfxGeth_RxQueueVlanPrio_5 = 0x20,
  IfxGeth_RxQueueVlanPrio_6 = 0x40,
  IfxGeth_RxQueueVlanPrio_7 = 0x80,
} IfxGeth_RxQueueVlanPrio;

/**
 * 
 */
typedef enum
{
  IfxGeth_RxQueueThreshold_32bytes = 0,
  IfxGeth_RxQueueThreshold_64bytes = 1,
  IfxGeth_RxQueueThreshold_96bytes = 2,
  IfxGeth_RxQueueThreshold_128bytes = 3,
} IfxGeth_RxQueueThreshold;

/**
 * 
 */
typedef enum
{
  IfxGeth_AvPacketRxQueueControl_disable = 0,
  IfxGeth_AvPacketRxQueueControl_enable = 1
} IfxGeth_AvPacketRxQueueControl;

/**
 * 
 */
typedef enum
{
  IfxGeth_PtpPacketRxQueueControl_disable = 0,
  IfxGeth_PtpPacketRxQueueControl_enable = 1,
  IfxGeth_PtpPacketRxQueueControl_enable_only_av = 2,
} IfxGeth_PtpPacketRxQueueControl;

/**
 * 
 */
typedef enum
{
  IfxGeth_TxQueueMode_disabled = 0,
  IfxGeth_TxQueueMode_avb = 1,
  IfxGeth_TxQueueMode_generic  = 2
} IfxGeth_TxQueueMode;

/**
 * 
 */
typedef enum
{
  IfxGeth_TxQueueThreshold_32bytes = 0,
  IfxGeth_TxQueueThreshold_64bytes = 1,
  IfxGeth_TxQueueThreshold_96bytes = 2,
  IfxGeth_TxQueueThreshold_128bytes = 3,
  IfxGeth_TxQueueThreshold_192bytes = 4,
  IfxGeth_TxQueueThreshold_256bytes = 5,
  IfxGeth_TxQueueThreshold_384bytes = 6,
  IfxGeth_TxQueueThreshold_512bytes = 7,
} IfxGeth_TxQueueThreshold;

/**
 * 
 */
typedef enum ETH_MAC_PORT_CTRL_MODE
{
  ETH_MAC_PORT_CTRL_MODE_MII = 0,
  ETH_MAC_PORT_CTRL_MODE_RMII = 4,
  ETH_MAC_PORT_CTRL_MODE_RGMII = 1
} ETH_MAC_PORT_CTRL_MODE_t;

/**
 * ETH link status
 */
typedef enum ETH_MAC_LINK_STATUS
{
  ETH_MAC_LINK_STATUS_DOWN, /**< Link status down */
  ETH_MAC_LINK_STATUS_UP    /**< Link status up */
} ETH_MAC_LINK_STATUS_t;

/**
 * ETH link speed
 */
typedef enum ETH_MAC_LINK_SPEED
{
  ETH_MAC_LINK_SPEED_10M    = 2UL, /**< Link speed: 10M */
  ETH_MAC_LINK_SPEED_100M   = 3UL, /**< Link speed: 100M */
  ETH_MAC_LINK_SPEED_1000M  = 0UL, /**< Link speed: 1000M */
} ETH_MAC_LINK_SPEED_t;

/**
 * ETH duplex settings (full/half?)
 */
typedef enum ETH_MAC_LINK_MODE
{
  ETH_MAC_LINK_MODE_HALF_DUPLEX = 0UL, /**< Half duplex */
  ETH_MAC_LINK_MODE_FULL_DUPLEX = 1UL  /**< Full duplex */
} ETH_MAC_LINK_MODE_t;

/**
 * ETH MAC event
 */
typedef enum ETH_DMA_EVENT
{
  ETH_DMA_EVENT_CONTEXT_DESC_ERROR = 0x2000,              /**< Context Descriptor error */
  ETH_DMA_EVENT_BUS_ERROR = 0x1000,                       /**< Bus error */
  ETH_DMA_EVENT_EARLY_RECEIVE = 0x0800,                   /**< Early receive */
  ETH_DMA_EVENT_EARLY_TRANSMIT = 0x0400,                  /**< Early transmit */
  ETH_DMA_EVENT_RECEIVE_WATCHDOG_TIMEOUT = 0x0200,        /**< Receive watchdog time-out */
  ETH_DMA_EVENT_RECEIVE_PROCESS_STOPPED = 0x0100,         /**< Receive process stopped */
  ETH_DMA_EVENT_RECEIVE_BUFFER_UNAVAILABLE = 0x0080,        /**< Receive buffer unavailable */
  ETH_DMA_EVENT_RECEIVE = 0x0040,                           /**< Receive event */
  ETH_DMA_EVENT_TRANSMIT_BUFFER_UNAVAILABLE = 0x0004,       /**< Transmit buffer unavailable */
  ETH_DMA_EVENT_TRANSMIT_PROCESS_STOPPED = 0x0002,        /**< Transmit process stopped */
  ETH_DMA_EVENT_TRANSMIT = 0x0001                           /**< Transmit event */
} ETH_DMA_EVENT_t;

/* MMC control register */

typedef enum ETH_MAC_MMC_CONTROL
{
  ETH_MAC_MMC_CONTROL_COUNTER_RESET = 0x01,
  ETH_MAC_MMC_CONTROL_COUNTER_STOP_ROLLOVER = 0x02,
  ETH_MAC_MMC_CONTROL_RESET_ON_READ = 0x04,
  ETH_MAC_MMC_CONTROL_COUNTER_FREEZER = 0x08,
  ETH_MAC_MMC_CONTROL_PRESET = 0x10,
  ETH_MAC_MMC_CONTROL_FULL_HALF_PRESET = 0x20
} ETH_MAC_MMC_CONTROL_t;

typedef enum ETH_PPS_CMD
{
  ETH_PPS_CMD_NOP,
  ETH_PPS_CMD_START_SINGLE_PULSE,
  ETH_PPS_CMD_START_PULSE_TRAIN,
  ETH_PPS_CMD_CANCEL_START,
  ETH_PPS_CMD_STOP_PULSE_TRAIN_AT_TIME,
  ETH_PPS_CMD_STOP_PULSE_TRAIN_NOW,
  ETH_PPS_CMD_CANCEL_PULSE_TRAIN,
} ETH_PPS_CMD_t;

/**********************************************************************************************************************
 * DATA STRUCTURES
 *********************************************************************************************************************/

/* Anonymous structure/union guard start */
#if defined (__TASKING__)
#pragma warning 586
#endif

/**
 * 
 */
typedef union ETH_MAC_TIMESTAMP_CONFIG
{
  struct
  {
    unsigned int enable_timestamp : 1;
    unsigned int enable_fine_update : 1;
    unsigned int : 6;
    unsigned int enable_timestamp_all_packets : 1;
    unsigned int enable_digital_rollover : 1;
    unsigned int enable_ptpv2_processing : 1;
    unsigned int enable_ptp_over_ethernet_processing : 1;
    unsigned int enable_ptp_over_udp_ipv6_processing : 1;
    unsigned int enable_ptp_over_udp_ipv4_processing : 1;
    unsigned int enable_timestamp_only_for_event_messages : 1;
    unsigned int enable_timestamp_only_for_master_messages : 1;
    unsigned int snapshot_type : 2;
    unsigned int enable_mac_addr_for_ptp_filtering: 1;
    unsigned int enable_checksum_correction: 1;      
    unsigned int : 8;      
    unsigned int enable_av_802_1as_mode: 1;      
    unsigned int : 3;      
  };

  uint32 raw;
} ETH_MAC_TIMESTAMP_CONFIG_t;

/**
 * 
 */
typedef union ETH_MAC_CONFIG
{
  struct
  {
    unsigned int tx_skewctrl : 4;
    unsigned int rx_skewctrl : 4;
    unsigned int : 24;
  };

  uint32 raw;
} ETH_MAC_CONFIG_t;

/**
 * 
 */
typedef struct ETH_MAC_ADDR_FILTER
{
  uint8 mac_addr[ETH_MAC_ADDR_LEN];
  
  union
  {
    struct
    {
      unsigned int dma_channel_select : 2;
      unsigned int : 6;
      unsigned int mask_byte_control : 6;
      unsigned int source_address : 1;
      unsigned int enable : 1;
    };
    uint16 config;
  };
} ETH_MAC_ADDR_FILTER_t;

/**
 * 
 */
typedef union ETH_MAC_VLANTAG_FILTER
{
  struct 
  {
    unsigned int vid : 16;
    unsigned int enable : 1;
    unsigned int enable_comp_12_bit : 1;
    unsigned int disable_vlan_type_comp : 1;
    unsigned int enable_outter_vlan_match: 1;
    unsigned int enable_inner_vlan_match : 1; /* closest to payload */
    unsigned int : 3;
    unsigned int dma_channel_enable : 1;
    unsigned int dma_channel_select : 2;
    unsigned int : 5;
  };
  uint32 raw;

} ETH_MAC_VLANTAG_FILTER_t;

/**
 * 
 */
typedef union ETH_MTL_CONFIG
{
  struct
  {
    unsigned int tx_sched : 2; /**< IfxGeth_TxSchedulingAlgorithm */
    unsigned int rx_sched : 2; /**< IfxGeth_RxArbitrationAlgorithm */
    unsigned int : 24;
  };

  uint32 raw;
} ETH_MTL_CONFIG_t;

/**
 * 
 */
typedef union ETH_MTL_RXQ_DMA_MAPPING
{
  struct
  {
    unsigned int static_dma_channel : 2;
    unsigned int : 2;
    unsigned int enable_dynamic_mapping: 1;
    unsigned int : 28;
  };
  
  uint32 raw;
} ETH_MTL_RXQ_DMA_MAPPING_t;

/**
 * 
 */
typedef union ETH_MTL_RXQ_ROUTING
{
  struct 
  {
    unsigned int av_packets_queue: 2;
    unsigned int : 2;
    unsigned int ptp_packets_queue: 2;      
    unsigned int : 6;
    unsigned int untagged_packets_queue: 2;      
    unsigned int : 2;
    unsigned int multi_broad_packets_queue: 2;
    unsigned int : 2;
    unsigned int enable_multi_broad_packets_routing: 1;
    unsigned int enable_av_tagged_packets_routing: 1;
    unsigned int enable_ptp_tagged_packets_control: 2;
    unsigned int : 8;
  };
  
  uint32 raw;
} ETH_MTL_RXQ_ROUTING_t;

/**
 * 
 */
typedef union ETH_MTL_RXQ_ROUTING_FAIL
{
  struct 
  {
    unsigned int enable_unicast_filter_fail_routing: 1;
    unsigned int unicast_filter_fail_queue: 2;
    unsigned int : 5;
    unsigned int enable_multicast_filter_fail_routing: 1;
    unsigned int multicast_filter_fail_queue: 2;
    unsigned int : 5;
    unsigned int enable_vlan_tag_filter_fail_routing: 1;
    unsigned int vlan_tag_filter_fail_queue: 2;
    unsigned int : 13;
  };
  
  uint32 raw;
} ETH_MTL_RXQ_ROUTING_FAIL_t;

/**
 * 
 */
typedef union ETH_MTL_RXQ_OPERATION_MODE
{
  struct
  {
    unsigned int threshold_control: 2;        /**< IfxGeth_RxQueueThreshold */
    unsigned int :1;
    unsigned int forward_undersize_good_packets: 1;
    unsigned int forward_error_packets: 1;
    unsigned int enable_store_and_foward: 1;  /**< Enable store and foward mode, otherwise cut through */    
    unsigned int :14;
    unsigned int size: 5;                     /**< IfxGeth_QueueSize */
    unsigned int :7;
  };

  uint32 raw;
} ETH_MTL_RXQ_OPERATION_MODE_t;

/**
 * 
 */
typedef union ETH_MTL_TXQ_OPERATION_MODE
{
  struct
  {
    unsigned int: 1;
    unsigned int enable_store_and_foward: 1;  /**< Enable store and foward mode, otherwise cut through */
    unsigned int mode: 2;                     /**< IfxGeth_TxQueueMode */
    unsigned int threshold_control: 3;        /**< IfxGeth_TxQueueThreshold */
    unsigned int : 9;
    unsigned int size: 4;                     /**< IfxGeth_QueueSize */
    unsigned int : 12;
  };
  uint32 raw;
} ETH_MTL_TXQ_OPERATION_MODE_t;

typedef union ETH_MTL_TXQ_ETS_CONTROL
{
  struct
  {
    unsigned int: 2;
    unsigned int enable_cbs: 1;               /**< indicates credit based shaper algorithm(CBS) is selected for Queue 1 traffic, otherwise strict priority */
    unsigned int credit_control: 1;           /**<  */
    unsigned int slot_count: 3;               /**<  */
    unsigned int : 24;
  };
  uint32 raw;
} ETH_MTL_TXQ_ETS_CONTROL_t;

/**
 * ETH MAC port control
 */
typedef union ETH_MAC_PORT_CTRL
{
  struct
  {
    unsigned int mdio : 2;                   /**< Bidirectional, push-pull management data I/O line */
    unsigned int clk_rx : 2;                 /**< RGMII: Receive clock 
                                                  RMII: Continuous 50 MHz reference clock.
    	  	  	  	  	  	  	  	  	  	  	  	MII: Receive clock, 25 MHz for 100Mbit/s, 2.5 MHz for 10Mbit/s
    	  	  	  	  	  	  	  	  	  	  	  	(::XMC_ETH_MAC_PORT_CTRL_CLK_RMII_t) */
    unsigned int crs: 2;                     /**< Carrier sense for only MII (::XMC_ETH_MAC_PORT_CTRL_CRS_t) */
    unsigned int col: 2;                     /**< Collision Detect for only MII (::XMC_ETH_MAC_PORT_CTRL_COL_t) */
    unsigned int crsdv: 2;                   /**< RMII: carrier sense/RX_Data valid. MII: RX_Data valid (::XMC_ETH_MAC_PORT_CTRL_CRS_DV_t) */
    unsigned int rxer: 2;                    /**< Receive error (::XMC_ETH_MAC_PORT_CTRL_RXER_t) */
    unsigned int rxd0: 2;                    /**< Receive data bit 0 (::XMC_ETH_MAC_PORT_CTRL_RXD0_t) */
    unsigned int rxd1: 2;                    /**< Receive data bit 1 (::XMC_ETH_MAC_PORT_CTRL_RXD1_t) */
    unsigned int rxd2: 2;                    /**< Receive data bit 2 (only MII) (::XMC_ETH_MAC_PORT_CTRL_RXD2_t) */
    unsigned int rxd3: 2;                    /**< Receive data bit 3 (only MII) (::XMC_ETH_MAC_PORT_CTRL_RXD3_t) */
    unsigned int clk_tx: 2;                  /**< Transmit clock (only MII), 25 MHz for 100Mbit/s, 2.5 MHz for 10Mbit/s (::XMC_ETH_MAC_PORT_CTRL_CLK_TX_t) */
    unsigned int mode : 3;                   /**< \brief [24:24] External Phy Interface RMMI Mode Bit (rw) */
    unsigned int : 7;                        /**< \brief \internal Reserved */
  };

  uint32 raw;
} ETH_MAC_PORT_CTRL_t;

/* Anonymous structure/union guard end */
#if defined (__TASKING__)
#pragma warning restore
#endif

/**
 *
 */
typedef struct ETH_MAC_MMC 
{
  uint32 tx_octetcount_gb;
  uint32 tx_framecount_gb;
  uint32 tx_broadcastframe_g;
  uint32 tx_multicastframe_g;
  uint32 tx_64_octets_gb;
  uint32 tx_65_to_127_octets_gb;
  uint32 tx_128_to_255_octets_gb;
  uint32 tx_256_to_511_octets_gb;
  uint32 tx_512_to_1023_octets_gb;
  uint32 tx_1024_to_max_octets_gb;
  uint32 tx_unicast_gb;
  uint32 tx_multicast_gb;
  uint32 tx_broadcast_gb;
  uint32 tx_underflow_error;
  uint32 tx_singlecol_g;
  uint32 tx_multicol_g;
  uint32 tx_deferred;
  uint32 tx_latecol;
  uint32 tx_exesscol;
  uint32 tx_carrier_error;
  uint32 tx_octetcount_g;
  uint32 tx_framecount_g;
  uint32 tx_excessdef;
  uint32 tx_pause_frame;
  uint32 tx_vlan_frame_g;
  uint32 tx_oversize_frames_g;

  /* MMC RX counter registers */
  uint32 rx_framecount_gb;
  uint32 rx_octetcount_gb;
  uint32 rx_octetcount_g;
  uint32 rx_broadcastframe_g;
  uint32 rx_multicastframe_g;
  uint32 rx_crc_error;
  uint32 rx_align_error;
  uint32 rx_run_error;
  uint32 rx_jabber_error;
  uint32 rx_undersize_g;
  uint32 rx_oversize_g;
  uint32 rx_64_octets_gb;
  uint32 rx_65_to_127_octets_gb;
  uint32 rx_128_to_255_octets_gb;
  uint32 rx_256_to_511_octets_gb;
  uint32 rx_512_to_1023_octets_gb;
  uint32 rx_1024_to_max_octets_gb;
  uint32 rx_unicast_g;
  uint32 rx_length_error;
  uint32 rx_autofrangetype;
  uint32 rx_pause_frames;
  uint32 rx_fifo_overflow;
  uint32 rx_vlan_frames_gb;
  uint32 rx_watchdog_error;
  uint32 rx_receive_frames_error;
  uint32 rx_control_frames_g;

  /* IPv4 */
  uint32 rx_ipv4_gd;
  uint32 rx_ipv4_hderr;
  uint32 rx_ipv4_nopay;
  uint32 rx_ipv4_frag;
  uint32 rx_ipv4_udsbl;

  uint32 rx_ipv4_gd_octets;
  uint32 rx_ipv4_hderr_octets;
  uint32 rx_ipv4_nopay_octets;
  uint32 rx_ipv4_frag_octets;
  uint32 rx_ipv4_udsbl_octets;

  /* IPV6 */
  uint32 rx_ipv6_gd_octets;
  uint32 rx_ipv6_hderr_octets;
  uint32 rx_ipv6_nopay_octets;

  uint32 rx_ipv6_gd;
  uint32 rx_ipv6_hderr;
  uint32 rx_ipv6_nopay;

  /* Protocols */
  uint32 rx_udp_gd;
  uint32 rx_udp_err;
  uint32 rx_tcp_gd;
  uint32 rx_tcp_err;
  uint32 rx_icmp_gd;
  uint32 rx_icmp_err;

  uint32 rx_udp_gd_octets;
  uint32 rx_udp_err_octets;
  uint32 rx_tcp_gd_octets;
  uint32 rx_tcp_err_octets;
  uint32 rx_icmp_gd_octets;
  uint32 rx_icmp_err_octets;
} ETH_MAC_MMC_t;

/**
 * ETH MAC DMA descriptor
 */
typedef struct ETH_DMA_DESC
{
  volatile uint32 des0;
  volatile uint32 des1;
  volatile uint32 des2;
  volatile uint32 des3;
} ETH_DMA_DESC_t;

/**
 *
 */
typedef struct ETH_DMA_CHANNEL
{
  uint32 desc_cnt;               /**< How many descriptors? */
  ETH_DMA_DESC_t *descs;         /**< DMA descriptors */
  uint8 *bufs;                   /**< buffers associated to descriptors */
  void **pbufs;                  /**< a pbuf per descriptor */
  void *sem_handler;             /**< a pbuf per descriptor */
  uint32 buf_size;               /**< Size of buffers */
  uint32 desc_idx;               /**< current descriptor index */
  uint32 dirty_desc_idx;
  uint32 config;                 /**< DMA channel config */
} ETH_DMA_CHANNEL_t;

/**
 * 
 */
typedef struct ETH_MTL_RX_QUEUE
{
  IfxGeth_RxQueueMode mode;
  ETH_MTL_RXQ_OPERATION_MODE_t operation_mode;
  ETH_MTL_RXQ_DMA_MAPPING_t dma_mappping;
  sint8 routing_vlan_prio;                   /**< IfxGeth_RxQueueVlanPrio */
} ETH_MTL_RX_QUEUE_t;

/**
 * 
 */
typedef struct ETH_MTL_TX_QUEUE
{
  ETH_MTL_TXQ_OPERATION_MODE_t operation_mode;
  ETH_MTL_TXQ_ETS_CONTROL_t ets_control;
  union {
    uint32 avb_idle_slope;
    uint32 weight;
  };
  uint32 avb_send_slope;
  uint32 avb_high_credit;
  uint32 avb_low_credit;
} ETH_MTL_TX_QUEUE_t;

/**
 *
 */
typedef struct ETH_MAC
{
  Ifx_GETH *regs;                             /**< HW regs */  

  const ETH_MAC_ADDR_FILTER_t *mac_addr;

  ETH_MAC_CONFIG_t mac_config;
  ETH_MTL_CONFIG_t mtl_config;                /**< queues common config */
  
  ETH_MTL_RXQ_ROUTING_t routing;
  ETH_MTL_RXQ_ROUTING_FAIL_t routing_fail;
  
  ETH_MTL_RX_QUEUE_t *rx_queue[ETH_MAC_RX_QUEUE_CNT];
  ETH_DMA_CHANNEL_t *rx_dma_channel[ETH_MAC_RX_DMA_CH_CNT];
  ETH_MTL_TX_QUEUE_t *tx_queue[ETH_MAC_TX_QUEUE_CNT];
  ETH_DMA_CHANNEL_t *tx_dma_channel[ETH_MAC_TX_DMA_CH_CNT];

  const ETH_MAC_ADDR_FILTER_t *filter_table;
  uint8 filter_table_size; 

} ETH_MAC_t;

/**
 * GETH MAC time
 */
typedef struct ETH_MAC_TIME
{
  uint32 seconds;                 /**< Seconds */
  sint32 nanoseconds;              /**< Nanoseconds */
} ETH_MAC_TIME_t;

/**
 * 
 */
typedef struct ETH_FLEX_PPS_CFG 
{
  uint32 cmd;
	ETH_MAC_TIME_t start;
	uint64 interval;
	uint64 width;
} ETH_FLEX_PPS_CFG_t;

/**********************************************************************************************************************
 * API PROTOTYPES
 *********************************************************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

IFX_INLINE Ifx_GETH_MTL_TXQ_DEBUG IfxGeth_mtl_getTransmitQueueDebugStatus(Ifx_GETH *const gethSFR, IfxGeth_TxMtlQueue queueId)
{
  Ifx_GETH_MTL_TXQ_DEBUG retval = {0};

  switch (queueId)
  {
    case IfxGeth_TxMtlQueue_0:
      retval.U = gethSFR->MTL_TXQ0.DEBUG.U;
      break;

    case IfxGeth_TxMtlQueue_1:
      retval.U = gethSFR->MTL_TXQ1.DEBUG.U;
      break;

    case IfxGeth_TxMtlQueue_2:
      retval.U = gethSFR->MTL_TXQ2.DEBUG.U;
      break;

    case IfxGeth_TxMtlQueue_3:
      retval.U = gethSFR->MTL_TXQ3.DEBUG.U;
      break;
  }

  return retval;
}

IFX_INLINE Ifx_GETH_MTL_RXQ_DEBUG IfxGeth_mtl_getReceiveQueueDebugStatus(Ifx_GETH *const gethSFR, IfxGeth_RxMtlQueue queueId)
{
  Ifx_GETH_MTL_RXQ_DEBUG retval = {0};
  
  switch (queueId)
  {
    case IfxGeth_RxMtlQueue_0:
      retval.U = gethSFR->MTL_RXQ0.DEBUG.U;
      break;

    case IfxGeth_RxMtlQueue_1:
      retval.U = gethSFR->MTL_RXQ1.DEBUG.U;
      break;

    case IfxGeth_RxMtlQueue_2:
      retval.U = gethSFR->MTL_RXQ2.DEBUG.U;
      break;

    case IfxGeth_RxMtlQueue_3:
      retval.U = gethSFR->MTL_RXQ3.DEBUG.U;
      break;
  }

  return retval;
}

/**
 *
 */
sint32 ETH_MAC_Init(ETH_MAC_t *const mac);

/**
 *
 */
void ETH_MAC_Reset(ETH_MAC_t *const mac);

/**
 *
 */
void ETH_MAC_Disable(ETH_MAC_t *const mac);

/**
 *
 */
void ETH_MAC_Enable(ETH_MAC_t *const mac);

/**
 *
 */
void ETH_MAC_SetPortControl(ETH_MAC_t *const mac, const ETH_MAC_PORT_CTRL_t port_ctrl);

/**
 *
 */
uint32 ETH_MAC_GetPortControl(ETH_MAC_t *const mac);

/**
 *
 */
void ETH_MAC_SetAddress(ETH_MAC_t *const mac, const ETH_MAC_ADDR_FILTER_t *const addr);

/**
 *
 */
void ETH_MAC_SetRGMIITxDelay(ETH_MAC_t *const mac, uint32 delay);

/**
 *
 */
void ETH_MAC_SetRGMIIRxDelay(ETH_MAC_t *const mac, uint32 delay);

/**
 *
 */
void ETH_MAC_SetLink(ETH_MAC_t *const mac, ETH_MAC_LINK_SPEED_t speed, ETH_MAC_LINK_MODE_t mode);

/**
 *
 */
void ETH_MAC_ResetDma(ETH_MAC_t *const mac);

/**
 *
 */
void ETH_MAC_Start(ETH_MAC_t *const mac, ETH_MAC_LINK_SPEED_t speed, ETH_MAC_LINK_MODE_t mode);

/**
 *
 */
void ETH_MAC_Stop(ETH_MAC_t *const mac);

/**
 *
 */
sint32 ETH_MAC_SetManagmentClockDivider(ETH_MAC_t *const mac);

/**
 *
 */
sint32 ETH_MDIO_Read(ETH_MAC_t *const mac, uint8 addr, uint32 regnum, uint16 *const regval, uint32 timeout);

/**
 *
 */
sint32 ETH_MDIO_Write(ETH_MAC_t *const mac, uint8 addr, uint32 regnum, uint16 regval, uint32 timeout);

/**
 *
 */
IFX_INLINE void ETH_MAC_EnableTx(ETH_MAC_t *const mac)
{
  IfxGeth_mac_enableTransmitter(mac->regs);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_EnableTxDma(ETH_MAC_t *const mac, uint8 channel)
{
  IfxGeth_dma_startTransmitter(mac->regs, channel);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_EnableRx(ETH_MAC_t *const mac)
{
  IfxGeth_mac_enableReceiver(mac->regs);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_EnableRxDma(ETH_MAC_t *const mac, uint8 channel)
{
  IfxGeth_dma_startReceiver(mac->regs, channel);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_DisableTx(ETH_MAC_t *const mac)
{
  IfxGeth_mac_disableTransmitter(mac->regs);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_DisableTxDma(ETH_MAC_t *const mac, uint8 channel)
{
  IfxGeth_dma_stopTransmitter(mac->regs, channel);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_DisableRx(ETH_MAC_t *const mac)
{
  IfxGeth_mac_disableReceiver(mac->regs);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_DisableRxDma(ETH_MAC_t *const mac, uint8 channel)
{
  mac->regs->DMA_CH[channel].RX_CONTROL.B.SR = FALSE;
}

/**
 *
 */
void ETH_MAC_EnableDmaEvent(ETH_MAC_t *const mac, uint8 channel, uint32 event);

/**
 *
 */
void ETH_MAC_DisableDmaEvent(ETH_MAC_t *const mac, uint8 channel, uint32 event);

/**
 *
 */
void ETH_MAC_ClearDmaEventStatus(ETH_MAC_t *const mac, uint8 channel, uint32 event);

/**
 *
 */
IFX_INLINE uint32 ETH_MAC_GetDmaEventStatus(ETH_MAC_t *const mac, uint8 channel)
{
  Ifx_GETH *const regs = mac->regs;

  return regs->DMA_CH[channel].STATUS.U;
}

/**
 *
 */
IFX_INLINE ETH_DMA_DESC_t *ETH_MAC_GetCurrentRxDescriptor(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->rx_dma_channel[channel];
  return (&(dma_channel->descs[dma_channel->desc_idx]));
}

/**
 *
 */
IFX_INLINE ETH_DMA_DESC_t *ETH_MAC_GetCurrentTxDescriptor(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];
  return (&(dma_channel->descs[dma_channel->desc_idx]));
}

IFX_INLINE void ETH_MAC_SetTxPbuf(ETH_MAC_t *const mac, uint8 channel, void *p)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];
  dma_channel->pbufs[dma_channel->desc_idx] = p;
}

IFX_INLINE void *ETH_MAC_GetTxPbuf(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];
  return dma_channel->pbufs[dma_channel->dirty_desc_idx];
}

/**
 *
 */
IFX_INLINE boolean ETH_MAC_IsRxDescriptorOwnedByDma(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->rx_dma_channel[channel];
  return (((volatile IfxGeth_RxDescr *const)dma_channel->descs)[dma_channel->desc_idx].RDES3.R.OWN != 0U);
}

/**
 *
 */
IFX_INLINE boolean ETH_MAC_IsTxDescriptorOwnedByDma(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];
  return (((volatile IfxGeth_TxDescr *const)dma_channel->descs)[dma_channel->desc_idx].TDES3.R.OWN != 0U);
}

/**
 *
 */
IFX_INLINE void ETH_MAC_ResumeRxDma(ETH_MAC_t *const mac, uint8 channel)
{
  Ifx_GETH *const regs = mac->regs;
  ETH_DMA_CHANNEL_t *const dma_channel = mac->rx_dma_channel[channel];
  
  regs->DMA_CH[channel].RXDESC_TAIL_POINTER.U = (uint32)&dma_channel->descs[dma_channel->desc_cnt];
}

/**
 *
 */
IFX_INLINE void ETH_MAC_ResumeTxDma(ETH_MAC_t *const mac, uint8 channel)
{
  Ifx_GETH *const regs = mac->regs;
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];

  regs->DMA_CH[channel].TXDESC_TAIL_POINTER.U = (uint32)&dma_channel->descs[dma_channel->desc_idx];
}

/**
 *
 */
void ETH_MAC_Transmit(ETH_MAC_t *const mac, uint32 len);

/**
 *
 */
IFX_INLINE uint8 *ETH_MAC_GetRxDmaBuffer(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->rx_dma_channel[channel];
  return (uint8 *)&(dma_channel->bufs[dma_channel->desc_idx * dma_channel->buf_size]);
}

/**
 *
 */
IFX_INLINE uint8 *ETH_MAC_GetTxDmaBuffer(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];
  return (uint8 *)&(dma_channel->bufs[dma_channel->desc_idx * dma_channel->buf_size]);
}

/**
 *
 */
void ETH_MAC_SetTxDmaBufferSize(ETH_MAC_t *const mac, uint8 channel, uint32 size);

/**
 *
 * uint8_t packet[1514];
 * 
 * IfxGeth_TxDescr tx_descr;
 * memset(&tx_descr, 0, sizeof(tx_descr));
 * tx_descr.TDES0.R.BUF1AP = (uint32)&packet;
 * tx_descr.TDES2.R.B1L = 1514;
 * tx_descr.TDES3.R.FL_TPL = 1514;
 * tx_descr.TDES3.R.CIC_TPL = 0;    // Disable TX COE
 * tx_descr.TDES3.R.CPC = 2;        // Disable insertion of FCS
 * tx_descr.TDES3.R.FD = 1;
 * tx_descr.TDES3.R.LD = 1;
 *
 *
 * ETH_MAC_SetTxDmaDescriptor(&ETH_0, 0, &tx_descr);
 * ETH_MAC_ReturnTxDmaDescriptor(&ETH_0, 0);
 * ETH_MAC_ResumeTxDma(&ETH_0, 0);
 */
/**
 *
 */

void ETH_MAC_SetTxDmaDualBufferSize(ETH_MAC_t *const eth_mac, uint8 channel, uint32 *b1, uint32 b1size,uint32 *b2, uint32 b2size);
/**
 *
 */

void ETH_MAC_SetTxDmaDescriptor(ETH_MAC_t *const eth_mac, uint8 channel, IfxGeth_TxDescr *const descr);

/**
 *
 */
void ETH_MAC_EnableTxDmaTimeStamp(ETH_MAC_t *const mac, uint8 channel);

/**
 * 
 */
void ETH_MAC_EnableTxDmaInterrupt(ETH_MAC_t *const eth_mac, uint8 channel);

/**
 *
 */
sint32 ETH_MAC_GetRxDmaFrameSize(ETH_MAC_t *const mac, uint8 channel);

/**
 *
 */
uint32 ETH_MAC_GetRxDmaBufferSize(ETH_MAC_t *const mac, uint8 channel);

/**
 *
 */
uint32 ETH_MAC_GetTxDmaBufferSize(ETH_MAC_t *const mac, uint8 channel);

/**
 *
 */
void ETH_MAC_ReturnRxDmaDescriptor(ETH_MAC_t *const mac, uint8 channel);

/**
 *
 */
void ETH_MAC_ReturnTxDmaDescriptor(ETH_MAC_t *const mac, uint8 channel);

/**
 *
 */
void ETH_MAC_InitTxQueue(ETH_MAC_t *const mac, uint8 queue);

/**
 *
 */
void ETH_MAC_InitTxDmaChannel(ETH_MAC_t *const eth_mac, uint8 channel);

/**
 *
 */
void ETH_MAC_InitRxQueue(ETH_MAC_t *const mac, uint8 queue);

/**
 *
 */
void ETH_MAC_InitRxDmaChannel(ETH_MAC_t *const eth_mac, uint8 channel);

/**
 *
 */
void ETH_MAC_InitPTP(ETH_MAC_t *const mac, const ETH_MAC_TIMESTAMP_CONFIG_t config, const ETH_MAC_TIME_t *const time);

/**
 *
 */
void ETH_MAC_GetPTPTime(ETH_MAC_t *const mac, ETH_MAC_TIME_t *const time);

/**
 *
 */
void ETH_MAC_SetPTPTime(ETH_MAC_t *const mac, const ETH_MAC_TIME_t *const time);

/**
 *
 */
sint32 ETH_MAC_GetTxTimeStamp(ETH_MAC_t *const mac, uint8 tx_dma_ch_num, ETH_MAC_TIME_t *const time);

/**
 *
 */
sint32 ETH_MAC_GetRxTimeStamp(ETH_MAC_t *const mac, uint8 rx_dma_ch_num, ETH_MAC_TIME_t *const time);

/**
 *
 */
void ETH_MAC_AdjustAddend(ETH_MAC_t *const mac, sint32 correction);


/**
 *
 */
void ETH_MAC_AdjustTime(ETH_MAC_t *const mac, ETH_MAC_TIME_t *const time, uint32 add_sub);


/**
 * 
 */
sint32 ETH_MAC_PPSConfig(ETH_MAC_t *const eth_mac, uint8 idx, uint32 freq_ctrl);

/**
 * 
 */
sint32 ETH_MAC_FlexPPSConfig(ETH_MAC_t *const eth_mac, uint8 idx, const ETH_FLEX_PPS_CFG_t *const config);

/**
 *
 */
void ETH_MAC_MMC_Control(ETH_MAC_t *const mac, sint32 mode);

/**
 *
 */
void ETH_MAC_MMC_Read(ETH_MAC_t *const mac, ETH_MAC_MMC_t *mmc);

/**
 *
 */
void ETH_MAC_EnableGlobalServiceRequest(ETH_MAC_t *const eth_mac, IfxSrc_Tos typOfService, Ifx_Priority priority);

/**
 *
 */
void ETH_MAC_EnablePpsServiceRequest(ETH_MAC_t *const eth_mac, IfxSrc_Tos typOfService, Ifx_Priority priority);

/**
 *
 */
void ETH_MAC_EnableRxDmaServiceRequest(ETH_MAC_t *const mac, uint8 channel, IfxSrc_Tos typOfService, Ifx_Priority priority);

/**
 *
 */
void ETH_MAC_EnableTxDmaServiceRequest(ETH_MAC_t *const eth_mac, uint8 channel, IfxSrc_Tos typOfService, Ifx_Priority priority);

/**
 *
 */
void ETH_MAC_UpdateAddressFilterTable(ETH_MAC_t *const mac, const ETH_MAC_ADDR_FILTER_t *const filter_table, uint32 size);

/**
 *
 **/
void ETH_MAC_UpdateVlanTagFilterTable(ETH_MAC_t *const mac, const ETH_MAC_VLANTAG_FILTER_t *const filter_table, uint32 size);


IFX_INLINE void *ETH_MAC_GetTxDmaSemaphoreHandler(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];
  return dma_channel->sem_handler;
}

IFX_INLINE void *ETH_MAC_GetRxDmaSemaphoreHandler(ETH_MAC_t *const mac, uint8 channel)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->rx_dma_channel[channel];
  return dma_channel->sem_handler;
}

IFX_INLINE boolean ETH_MAC_IsTxDescriptorOwnedByDmaEx(ETH_MAC_t *const mac, uint8 channel, uint32 idx)
{
  ETH_DMA_CHANNEL_t *const dma_channel = mac->tx_dma_channel[channel];
  return (((volatile IfxGeth_TxDescr *const)dma_channel->descs)[idx].TDES3.R.OWN != 0U);
}

IFX_INLINE void ETH_MAC_EnableEvent(ETH_MAC_t *const mac, uint32 event)
{
  Ifx_GETH *const regs = mac->regs;
  regs->MAC_INTERRUPT_ENABLE.U |= event;
}

IFX_INLINE void ETH_MAC_DisableEvent(ETH_MAC_t *const mac, uint32 event)
{
  Ifx_GETH *const regs = mac->regs;
  regs->MAC_INTERRUPT_ENABLE.U &= (uint32)~event;
}

IFX_INLINE uint32 ETH_MAC_GetEventStatus(ETH_MAC_t *const mac)
{
  Ifx_GETH *const regs = mac->regs;
  return regs->MAC_INTERRUPT_STATUS.U;
}

IFX_INLINE void ETH_MAC_ClearEventStatus(ETH_MAC_t *const mac, uint32 status)
{
  Ifx_GETH *const regs = mac->regs;
  regs->MAC_INTERRUPT_STATUS.U |= status;
}

#ifdef __cplusplus
}
#endif

#endif
