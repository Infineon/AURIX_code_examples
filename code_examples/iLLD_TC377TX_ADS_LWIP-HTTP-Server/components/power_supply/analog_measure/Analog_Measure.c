/**********************************************************************************************************************
 * \file Analog_Measure.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include "Analog_Measure.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/


/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
Board_Analog_Measure_t Board_Analog_Measure;
EVADC_GRP_t evadc_grp;
/******************************************************************************/
/*-----------------------------static functions------------------------------*/
/******************************************************************************/
static void EVADC_initGrp(uint32 groupId)
{
    /*create configuration */
    IfxEvadc_Adc_Config adcConfig;
    IfxEvadc_Adc_initModuleConfig(&adcConfig,&MODULE_EVADC);

    /*initialize module */
    IfxEvadc_Adc_initModule(&evadc_grp.evadc,&adcConfig);

    /*group config */
    IfxEvadc_Adc_GroupConfig adcGroupConfig;
    IfxEvadc_Adc_initGroupConfig(&adcGroupConfig,&evadc_grp.evadc);

    /*choose adc in primary group */
    adcGroupConfig.groupId=(IfxEvadc_GroupId)groupId;
    adcGroupConfig.master=adcGroupConfig.groupId;


    /*enable all request source from arbiter */
    adcGroupConfig.arbiter.requestSlotQueue0Enabled=TRUE;
    adcGroupConfig.arbiter.requestSlotQueue1Enabled=TRUE;
    adcGroupConfig.arbiter.requestSlotQueue2Enabled=TRUE;

    /*enable all gate in always mode (no edge detection) */
    adcGroupConfig.queueRequest[0].triggerConfig.gatingMode=IfxEvadc_GatingMode_always;
    adcGroupConfig.queueRequest[1].triggerConfig.gatingMode=IfxEvadc_GatingMode_always;
    adcGroupConfig.queueRequest[2].triggerConfig.gatingMode=IfxEvadc_GatingMode_always;

    /*initialize the group */
    IfxEvadc_Adc_initGroup(&evadc_grp.adcGroup[groupId],&adcGroupConfig);
}




Ifx_EVADC_G_RES resultTrace[10];
static float EVADC_conversion(uint32 groupId,uint32 channel)
{
    float conversion=0.0f;

    IfxEvadc_RequestSource requestSource = IfxEvadc_RequestSource_queue0;
    IfxEvadc_GatingMode savedGate =  IfxEvadc_getQueueSlotGatingMode(evadc_grp.adcGroup[groupId].group,requestSource);
    IfxEvadc_GatingSource gatingSource = IfxEvadc_getQueueSlotGatingSource(evadc_grp.adcGroup[groupId].group, requestSource );

    /* create channel config */
    IfxEvadc_Adc_ChannelConfig adcChannelConfig;
    IfxEvadc_Adc_Channel       adcChannel;


    IfxEvadc_Adc_initChannelConfig(&adcChannelConfig, &evadc_grp.adcGroup[groupId]);

    adcChannelConfig.channelId      = (IfxEvadc_ChannelId)(channel);
    adcChannelConfig.resultRegister = IfxEvadc_ChannelResult_1; /* use result register #1 for all channels */

    /* initialize the channel */
    IfxEvadc_Adc_initChannel(&adcChannel, &adcChannelConfig);

    /* Add channel to queue with refill enabled */
    IfxEvadc_Adc_addToQueue(&adcChannel, requestSource,IFXEVADC_QUEUE_REFILL);


    /* restore previous gate config */
    IfxEvadc_setQueueSlotGatingConfig(evadc_grp.adcGroup[groupId].group, gatingSource, savedGate, requestSource );

    /* start the Queue */
    IfxEvadc_Adc_startQueue(&evadc_grp.adcGroup[groupId],requestSource); /* the queue has already been started in previous test */

    /* get 10 results */
    /*Ifx_EVADC_G_RES resultTrace[10]; */

    uint32       i;

    for (i = 0; i <10; ++i)
    {

        /* wait for valid result */
        Ifx_EVADC_G_RES conversionResult;

        do
        {
            conversionResult = IfxEvadc_Adc_getResult(&adcChannel);
        } while (!conversionResult.B.VF);

        /* store result */
        resultTrace[i] = conversionResult;
    }

    /* stop the queue */
    IfxEvadc_Adc_clearQueue(&evadc_grp.adcGroup[groupId],requestSource);

    /* check for correct channel */
    i = 0;
    while(resultTrace[i].B.CHNR != channel) i++;



    conversion=(((float)resultTrace[i].B.RESULT*3.3)/4095);
    return conversion;


}


/*
 *  Init's the analog measurement
 */
sint32 Init_Analog_Measurment (void)
{
    EVADC_initGrp(0);
    EVADC_initGrp(1);

    return(0);
}

/*
 *  measures the analog values
 */
void Analog_Measurment (void)
{

    /* (Resistance R1/R2 * Measured Voltage ADC) / Target Voltage */
    Board_Analog_Measure.Voltage_12V   = roundf((EVADC_conversion(0,0)/0.24)* 100) / 100; /*AN0 */
    Board_Analog_Measure.Voltage_5V    = roundf((EVADC_conversion(0,1)/0.6)* 100) / 100;  /*AN1 */
    Board_Analog_Measure.Voltage_3_3V  = roundf((EVADC_conversion(0,2)/0.47)* 100) / 100;  /*AN2 */
    Board_Analog_Measure.Voltage_2V5   = roundf(EVADC_conversion(0,3)* 100) / 100; /*AN3 */
    Board_Analog_Measure.Voltage_1V8   = roundf(EVADC_conversion(0,4)* 100) / 100; /*AN4 */
    Board_Analog_Measure.Voltage_1V25  = roundf(EVADC_conversion(0,5)* 100) / 100; /*AN5 */
    Board_Analog_Measure.Voltage_1V    = roundf(EVADC_conversion(0,6)* 100) / 100; /*AN6 */
    Board_Analog_Measure.Voltage_0V9   = roundf(EVADC_conversion(0,7)* 100) / 100; /*AN7 */
    Board_Analog_Measure.Current_12V   = (EVADC_conversion(1,0) * 1.2)/3; /*AN8 */
    Board_Analog_Measure.Current_5V    = (EVADC_conversion(1,1) * 1.2)/3; /*AN9 */



}
