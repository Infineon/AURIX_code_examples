/**********************************************************************************************************************
 * \file IfxSpu_cfg9_aCFAR.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "IfxRadar_cfg.h"
#include "IfxSpu_Init.h"
#include "IfxEmem_cfg.h"
#include "IfxSpu_cfg.h"

/*This SPU config performs CFAR on power spectrum along angle dimension */

IfxSpu_ConfigSlot *IfxSpu_cfg9_aCFAR(IfxSpu_SlotConfig *cfg, uint32 slotNr, Ifx_SPU *spu)
{
    IfxSpu_ConfigSlot* slot = IfxSpu_getConfigSlot(spu, slotNr);

    /** ------------ GLOBAL ------------ */
    /* PASS MODE */
    IfxSpu_setPassMode(slot, IfxSpu_PassMode_single);

    /* INPUT SOURCE */
    uint32 bin_size_bytes = sizeof(sint32);
    cfg->input.dataSource             = IfxSpu_DataSource_emem;
    cfg->input.rm.baseAddress         = IFX_OFFSETOF(SPU_Rmem_Map_t, PS[0]);
    cfg->input.rm.dataFormat         =  IfxSpu_RM_InputDataFormat_power32Bit;

    cfg->input.rm.antennaMapping     = IfxSpu_RM_AntennaMapping_outerLoopRepeat; /*antenna idx updated after each full inner loop*/
    cfg->input.rm.addressingMode     = IfxSpu_RM_AddressingMode_linear;
    cfg->input.rm.processingMode     =  IfxSpu_RM_ProcessingMode_default;
    cfg->input.rm.numBlocks         = 0;


    cfg->input.rm.binLoopRepeat       = RADAR_NUM_DTHETA;
    cfg->input.rm.innerLoopRepeat     = RADAR_NUM_SAMPLES/2;
    cfg->input.rm.outerLoopRepeat     = 1;

    cfg->input.rm.binLoopOffset       = bin_size_bytes;
    cfg->input.rm.innerLoopOffset     = bin_size_bytes*RADAR_NUM_DTHETA;
    cfg->input.rm.outerLoopOffset     = IFXEMEM_SIZE;
    IfxSpu_setupInput(slot, &cfg->input);

    /* LOCAL MAX */
   IfxSpu_setupLocalMax(slot, NULL_PTR); /* disabled with passing NULL_PTR */

    /* BIN REJECTION */
    IfxSpu_setupBinRejection(slot, NULL_PTR);

    /* NCI WEIGHTS */
    IfxSpu_setupNciWeights(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* MAGNITUDE */
    IfxSpu_setupMagnitude(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /** ------------ PASS 0 ------------ */
    {
        IfxSpu_PassId passId         = IfxSpu_PassId_0;
        IfxSpu_PassConfig* pcfg0     = &cfg->pass[passId];

        /* MATH1 */
        pcfg0->math1.loaderExponent         = 0; /*alignment when reformatting input data to 32bit*/
        pcfg0->math1.numDropFirstSamples     = 0;
        pcfg0->math1.numDropLastSamples     = 0;
        pcfg0->math1.numPadFrontSamples     = 0;
        pcfg0->math1.window.enabled         = FALSE;
        pcfg0->math1.window.baseAddress      = IFX_OFFSETOF(SPU_Cmem0_Map_t, rWndw);
        pcfg0->math1.window.dataFormat         = IfxSpu_WindowDataFormat_real16;
        pcfg0->math1.phaseShift             = IfxSpu_PhaseShift_0;
        for(uint32 antNr=0; antNr<RADAR_NUM_VRX; antNr++)
        {

              pcfg0->math1.window.antennaOffsets[antNr] =0;
        }
        IfxSpu_setupMath1(slot, passId, &pcfg0->math1);

        /* FFT */
        pcfg0->fft.enabled         = FALSE;
        pcfg0->fft.inversed     = FALSE;
        pcfg0->fft.size         = IfxSpu_getSizeCode(RADAR_NUM_DTHETA);
        pcfg0->fft.dataFormat     = IfxSpu_FftDataFormat_complex32Bit;
        pcfg0->fft.exponent     = 0;
        pcfg0->fft.forceToReal     = FALSE;
        IfxSpu_setupFft(slot, passId, &pcfg0->fft);

        /* FFT OUTPUT */
        pcfg0->fftOut.enabled         = FALSE;
        pcfg0->fftOut.baseAddress     = IFX_OFFSETOF(SPU_Rmem_Map_t, PS[0]);
        pcfg0->fftOut.format         = IfxSpu_ODP_Format_complex16Bit;
        pcfg0->fftOut.exponent         = 0;
        pcfg0->fftOut.inPlace         = FALSE;
        IfxSpu_setupFftOutput(slot, passId, &pcfg0->fftOut);

        /* MATH2 */
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);

        pcfg0->cfar.mode= IfxSpu_CFAR_Mode_offline;
        pcfg0->cfar.baseAddress = IFX_OFFSETOF(SPU_Rmem_Map_t, CFARAMap[0]);
        pcfg0->cfar.caCfarEnabled = TRUE;
        pcfg0->cfar.gosCfarEnabled = FALSE;
        pcfg0->cfar.spectrumExtension = IfxSpu_CFAR_SpectrumExtension_off;
        pcfg0->cfar.spectrumExtensionSize = 0;
        IfxSpu_setupCfar(slot, passId, &pcfg0->cfar);

        pcfg0->cfarCA.algorithm = IfxSpu_CFAR_CA_Algorithm_ca; /* Standard CA-CFAR*/
        pcfg0->cfarCA.guardCells = 2; /* three guard cells on either side of the CUT*/
        pcfg0->cfarCA.windowCellsExponent =3; /* corresponds to 2^1=2 cells*/
        pcfg0->cfarCA.beta = 0x0200;/*corresponding to a threshold in log2 domain of 1.0*/
        pcfg0->cfarCA.cashSubWindowExponent = 3; /* must be set to the same value as windowCellsExponent for CA CFAR*/
        IfxSpu_setupCfarCA(slot, &pcfg0->cfarCA);


        /* CFAR (CA/GOS) */
        IfxSpu_setupCfarGOS(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupNci(slot, passId, NULL_PTR);
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR);
        IfxSpu_setupSummation(slot, passId, NULL_PTR);

    }

    /** ------------ PASS 1 ------------ */
    {
        IfxSpu_PassId passId = IfxSpu_PassId_1;

        /* Due to mirrored registers, the alternate pass uses same configuration as main pass */
        IfxSpu_setupMath1(slot, passId, &cfg->pass[0].math1);
        IfxSpu_setupFft(slot, passId, &cfg->pass[0].fft);

        IfxSpu_setupFftOutput(slot, passId, NULL_PTR);
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupNci(slot, passId, NULL_PTR);                /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupCfar(slot, passId, NULL_PTR);               /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    }

    return slot;
}
