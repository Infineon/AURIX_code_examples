/**********************************************************************************************************************
 * \file IfxSpu_cfg1_sortadc.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include "IfxSpu_init.h"
#include "IfxEmem_cfg.h"
#include "IfxSpu_cfg.h"

/* This SPU configuration receives RADAR_NUM_SAMPLES samples from the MMIC/RIF and writes them into the adc_raw buffer in EMEM without further processing */

IfxSpu_ConfigSlot *IfxSpu_cfg1_sortadc(IfxSpu_SlotConfig *cfg, uint32 slotNr, Ifx_SPU *spu)
{
    uint32             antNr;
    IfxSpu_ConfigSlot *slot = IfxSpu_getConfigSlot(spu, slotNr);

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, &(rspu_cmem_map->slots[slotNr - 1]) == slot);

    /* GLOBAL */
    {
    /* PASS SETTINGS */
    IfxSpu_setPassMode(slot, IfxSpu_PassMode_single);

    /* INPUT SOURCE */
    cfg->input.dataSource      = IfxSpu_DataSource_rifBoth;
    cfg->input.rif.numAntennae = RADAR_NUM_RX;


    cfg->input.rif.dataFormat  = IfxSpu_InputDataFormat_real;
    cfg->input.rif.dataType    = IfxSpu_InputDataType_unsigned;
    cfg->input.rif.sampleCount = RADAR_NUM_SAMPLES;
    cfg->input.rif.numRamps    = 1;  /* Just 1 Ramp processed at a time*/

    /* Bypass mode used for reading back 16-bit real samples*/
    cfg->input.rif.bypassModeEnabled   = TRUE;
    cfg->input.rif.bypassReloadEnabled = TRUE;
    cfg->input.rif.bypassAddress       = IFX_OFFSETOF(SPU_Rmem_Map_t, adc_raw);

    cfg->input.rif.preAcquisitionCounterEnabled = FALSE;
    cfg->input.rif.preAcquisitionCounterLimit   = 0;
    cfg->input.rif.preAcquisitionCounterReset   = TRUE;
    cfg->input.rif.preAcquisitionCounterTrigger = FALSE;
    cfg->input.rif.preAcquisitionCounterError   = FALSE;
    cfg->input.rif.preAcquisitionCounterAttention = FALSE;

    IfxSpu_setupInput(slot, &cfg->input);

    /* CA CFAR */
    IfxSpu_setupCfarCA(slot, NULL_PTR);   /* set to default (disabled) by passing NULL_PTR */

    /* GOS CFAR */
    IfxSpu_setupCfarGOS(slot, NULL_PTR);  /* set to default (disabled) by passing NULL_PTR */

    /* LOCAL MAX */
    IfxSpu_setupLocalMax(slot, NULL_PTR); /* disabled with passing NULL_PTR */

    /* BIN-REJECTION */
    cfg->binrej.mode             = IfxSpu_BinRejection_Mode_reject;
    cfg->binrej.numAllowedBins   = RADAR_NUM_SAMPLES;
    cfg->binrej.thresholdEnabled = FALSE;
    cfg->binrej.thresholdValue   = 0xFFFFu;
    IfxSpu_setupBinRejection(slot, &cfg->binrej);

    /* NCI weights */
    IfxSpu_setupNciWeights(slot, NULL_PTR); /* set to default (ONEs) by passing NULL_PTR */

    /* Magnitude approx. */
    IfxSpu_setupMagnitude(slot, NULL_PTR);  /* set to default (disabled) by passing NULL_PTR */
    }

    /* FIRST PASS */
    {
        IfxSpu_PassId      passId = IfxSpu_PassId_0;
        IfxSpu_PassConfig *pcfg   = &cfg->pass[passId];

        /* MATH 1 */
        pcfg->math1.loaderExponent      = 16;
        pcfg->math1.numDropFirstSamples = 0;
        pcfg->math1.numDropLastSamples  = 0;
        pcfg->math1.numPadFrontSamples  = 0;
        pcfg->math1.window.enabled      = FALSE;
        pcfg->math1.window.dataFormat   = IfxSpu_WindowDataFormat_real16;
        pcfg->math1.window.baseAddress  = 0;
        for (antNr = 0; antNr < RADAR_NUM_RX/2; antNr++)
        {
            pcfg->math1.window.antennaOffsets[antNr] = 0;
        }

        pcfg->math1.phaseShift = IfxSpu_PhaseShift_0;
        IfxSpu_setupMath1(slot, passId, &pcfg->math1);

        /* FFT ENGINE UNLOADER */
        pcfg->fft.enabled     = FALSE;
        pcfg->fft.inversed    = FALSE;
        pcfg->fft.size        = IfxSpu_getSizeCode(RADAR_NUM_SAMPLES);
        pcfg->fft.dataFormat  = IfxSpu_FftDataFormat_complex32Bit;
        pcfg->fft.exponent    = 0;
        pcfg->fft.forceToReal = FALSE;
        IfxSpu_setupFft(slot, passId, &pcfg->fft);

        /* FFT OUTPUT */
        pcfg->fftOut.enabled       = TRUE;
        pcfg->fftOut.baseAddress   = IFX_OFFSETOF(SPU_Rmem_Map_t, adc_sort);
        pcfg->fftOut.format        = IfxSpu_ODP_Format_real16Bit;
        pcfg->fftOut.exponent      = 16;
        pcfg->fftOut.inPlace       = FALSE;
        IfxSpu_setupFftOutput(slot, passId, &pcfg->fftOut);

        /* HISTOGRAM */
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */

        /* NON-COHERENT INTEGRATION */
        IfxSpu_setupNci(slot, passId, NULL_PTR);                /* set to default (disabled) by passing NULL_PTR */

        /* SUMMATION */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */

        /* LOG2 POWER */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */

        /* CFAR */
        IfxSpu_setupCfar(slot, passId, NULL_PTR);               /* set to default (disabled) by passing NULL_PTR */

         IfxSpu_setupSidebandStatistics(slot, passId, &pcfg->statistics); /* set to default (disabled) by passing NULL_PTR */
    }

    /* SECOND PASS */
    {
       IfxSpu_PassId      passId = IfxSpu_PassId_1;

       /* Due to mirrored registers, the alternate pass uses same configuration as main pass */
        IfxSpu_setupMath1(slot, passId, &cfg->pass[0].math1);
        IfxSpu_setupFft(slot, passId, &cfg->pass[0].fft);

        /* FFT OUTPUT */
        IfxSpu_setupFftOutput(slot, passId, NULL_PTR);

        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupNci(slot, passId, NULL_PTR);                /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupCfar(slot, passId, NULL_PTR);               /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    }

    return slot;
}
