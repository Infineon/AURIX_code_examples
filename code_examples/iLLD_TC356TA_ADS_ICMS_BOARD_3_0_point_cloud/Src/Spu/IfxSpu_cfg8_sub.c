/**********************************************************************************************************************
 * \file IfxSpu_cfg8_sub.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
#include <IfxRadar_cfg.h>
#include <IfxSpu_Init.h>
#include "IfxEmem_cfg.h"
#include "IfxSpu_cfg.h"

/*This SPU config subtracts the average across ramps from the micro doppler frame (static target removal)*/

IfxSpu_ConfigSlot *IfxSpu_cfg8_sub(IfxSpu_SlotConfig *cfg, uint32 slotNr, Ifx_SPU *spu)
{
    IfxSpu_ConfigSlot* slot = IfxSpu_getConfigSlot(spu, slotNr);

    /** ------------ GLOBAL ------------ */
    /*PASS MODE*/
    IfxSpu_setPassMode(slot, IfxSpu_PassMode_single);

    /*INPUT SOURCE*/
    uint32 bin_size_bytes = sizeof(csint16);
    cfg->input.dataSource             = IfxSpu_DataSource_emem;
    cfg->input.rm.baseAddress         = IFX_OFFSETOF(SPU_Rmem_Map_t, microDoppler[0]);
    cfg->input.rm.dataFormat         = IfxSpu_RM_InputDataFormat_complex16Bit;

    cfg->input.rm.antennaMapping     = IfxSpu_RM_AntennaMapping_innerLoopRepeat;
    cfg->input.rm.addressingMode     = IfxSpu_RM_AddressingMode_linear;
    cfg->input.rm.processingMode     = IfxSpu_RM_ProcessingMode_default;

    cfg->input.rm.numBlocks         = (uint8)(IFXEMEM_BUS_SIZE / bin_size_bytes);

    cfg->input.rm.binLoopRepeat       = RADAR_NUM_VRX * RADAR_NUM_RANGE_GATES;
    cfg->input.rm.innerLoopRepeat     = 2;
    cfg->input.rm.outerLoopRepeat     = RADAR_NUM_MICRO_DOPPLER;

    cfg->input.rm.binLoopOffset       = bin_size_bytes;
    cfg->input.rm.innerLoopOffset     = bin_size_bytes * RADAR_NUM_VRX * RADAR_NUM_RANGE_GATES * RADAR_NUM_MICRO_DOPPLER; /*offset corresponding to rmap size*/
    cfg->input.rm.outerLoopOffset     = bin_size_bytes * RADAR_NUM_VRX * RADAR_NUM_RANGE_GATES;
    IfxSpu_setupInput(slot, &cfg->input);

    /*LOCAL MAX*/
    IfxSpu_setupLocalMax(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /*BIN REJECTION*/
    IfxSpu_setupBinRejection(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* NCI WEIGHTS */
    IfxSpu_setupNciWeights(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* MAGNITUDE */
    IfxSpu_setupMagnitude(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* CFAR (CA/GOS) */
    IfxSpu_setupCfarCA(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    IfxSpu_setupCfarGOS(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */


    /** ------------ PASS 0 ------------ */
    {
        IfxSpu_PassId passId         = IfxSpu_PassId_0;
        IfxSpu_PassConfig* pcfg0     = &cfg->pass[passId];

        /*MATH1*/
        pcfg0->math1.loaderExponent         = 16;
        pcfg0->math1.numDropFirstSamples     = 0;
        pcfg0->math1.numDropLastSamples     = 0;
        pcfg0->math1.numPadFrontSamples     = 0;
        pcfg0->math1.window.enabled         = FALSE;
        pcfg0->math1.window.baseAddress      = 0;
        pcfg0->math1.window.dataFormat         = IfxSpu_WindowDataFormat_real16;
        pcfg0->math1.phaseShift             = IfxSpu_PhaseShift_0;
        for(uint32 antNr=0; antNr<RADAR_NUM_RX; antNr++)
        {
            pcfg0->math1.window.antennaOffsets[antNr] = 0;
        }

        IfxSpu_setupMath1(slot, passId, &pcfg0->math1);

        pcfg0->fft.enabled      = FALSE;
        pcfg0->fft.inversed     = FALSE;
        pcfg0->fft.size         = IfxSpu_FftSize_8;
        pcfg0->fft.dataFormat   = IfxSpu_FftDataFormat_complex32Bit;
        pcfg0->fft.exponent     = 0;
        pcfg0->fft.forceToReal  = FALSE;
        IfxSpu_setupFft(slot, passId, &pcfg0->fft);

        pcfg0->fftOut.enabled       = FALSE;
        pcfg0->fftOut.baseAddress   = 0;
        pcfg0->fftOut.format        = IfxSpu_ODP_Format_complex32Bit;
        pcfg0->fftOut.exponent      = 0;
        pcfg0->fftOut.inPlace       = FALSE;
        IfxSpu_setupFftOutput(slot, passId, &pcfg0->fftOut);
        IfxSpu_setupFftOutput(slot, passId, NULL_PTR);

        /*MATH2*/
        /*final summation for clutter removal*/
        pcfg0->csum.baseAddress   = IFX_OFFSETOF(SPU_Rmem_Map_t, microDopplerclutterremoved[0]); /*can alternatively be set to overwrite original Range map*/
        pcfg0->csum.mode          = IfxSpu_Summation_Mode_sumAnt;
        pcfg0->csum.dataFormat    = IfxSpu_Summation_DataFormat_complex;
        pcfg0->csum.antennaeToUse = 0x03;
        pcfg0->csum.shift         = IfxSpu_Summation_Scale_off;
        pcfg0->csum.precision     = IfxSpu_Summation_Precision_16bit;
        IfxSpu_setupSummation(slot, passId, &pcfg0->csum);

        pcfg0->nci.enabled            = FALSE;
        pcfg0->nci.baseAddress        = 0;
        pcfg0->nci.outputFormat       = 0;
        pcfg0->nci.scalingFactor      = 0;
        IfxSpu_setupNci(slot, passId, &pcfg0->nci);

        pcfg0->cfar.mode              = IfxSpu_CFAR_Mode_off;
        pcfg0->cfar.baseAddress       = 0;
        IfxSpu_setupCfar(slot, passId, &pcfg0->cfar);

        pcfg0->histogram.enabled      = FALSE;
        pcfg0->histogram.baseAddress  = 0;
        IfxSpu_setupHistogram(slot, passId, &pcfg0->histogram);

        IfxSpu_setupLog2PowerSummation(slot, passId, NULL_PTR);

        pcfg0->power.enabled          = FALSE;
        pcfg0->power.baseAddress      = 0;
        IfxSpu_setupPowerChannel(slot, passId, &pcfg0->power);

        pcfg0->statistics.enabled     = FALSE;
        pcfg0->statistics.baseAddress = 0;
        IfxSpu_setupSidebandStatistics(slot, passId, &pcfg0->statistics);
    }

    /** ------------ PASS 1 ------------ */
    {
        IfxSpu_PassId passId = IfxSpu_PassId_1;

        /* Due to mirrored registers, the alternate pass uses same configuration as main pass */
        IfxSpu_setupMath1(slot, passId, &cfg->pass[0].math1);
        IfxSpu_setupFft(slot, passId, &cfg->pass[0].fft);

        IfxSpu_setupFftOutput(slot, passId, NULL_PTR);
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupNci(slot, passId, NULL_PTR);                /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupCfar(slot, passId, NULL_PTR);               /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    }

    return slot;
}
