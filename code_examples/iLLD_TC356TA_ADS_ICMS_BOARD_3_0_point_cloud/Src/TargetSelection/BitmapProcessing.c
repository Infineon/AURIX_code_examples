/**********************************************************************************************************************
 * \file BitmapProcessing.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include <TargetSelection/BitmapProcessing.h>

#include "IfxSpu_init.h"
#include "IfxRadar_cfg.h"
#include <math.h>
#include <stdio.h>
#include <stdint.h>
#include "IfxTargets.h"
#include <Range-Azimuth-using-Capon/RangeHeatmap.h>


/***************************************/

/*
******************************************************************************
* Brief:   The routine void IfxDetectionMapCombine(uint32* detMap1,
*                          uint32* detMap2, uint32 *detMapDest,
                           uint16 linBins, uint16 trnspsBins, IfxDetMapCmb cmb)
* Details: This routine logically combines linearly 2 detection maps
******************************************************************************
*/
void IfxDetectionMapCombine(uint32* detMap1, uint32* detMap2, uint32 *detMapDest,
                           uint16 linBins, uint16 trnspsBins, IfxDetMapCmb cmb)
{
   uint16 ix, iy;
   for (iy=0;iy<trnspsBins;iy++){
       for (ix=0;ix<linBins/32;ix++){
           switch (cmb){
           case DetMap_Or:
               *detMapDest++ = *detMap1++ | *detMap2++;
               break;
           case DetMap_And:
               *detMapDest++ = *detMap1++ & *detMap2++;
               break;
           case DetMap_Xor:
               *detMapDest++ = *detMap1++ ^ *detMap2++;
               break;
           default:
               *detMapDest++  = 0xAAAAAAAA; /* error Pattern*/
               break;
           }
       }
   }
}

/*
 ******************************************************************************
 * Brief:   The routine void IfxDetectionMapTranspose(uint32* detMap1,
 *                          uint32 *detMapDest, uint16 linBins, uint16 trnspsBins)
 * Details: This routine logically transposes a bit map
 ******************************************************************************
 */
void IfxDetectionMapTranspose(uint32* detMap1, uint32 *detMapDest,
                              uint16 linBins, uint16 trnspsBins)
{

    /* Index:*/
    /* iLw: Linear 32-bit Word*/
    /* iLb: Linear Bin in 1 Linear Word*/
    /* iTw: Transpose 32-bit Word*/
    /* iTb: Transpose Bin in 1 Transpose Word*/
    uint16 iLw, iLb, iTw, iTb;
    uint32 rWord, mask;
    uint32 *ptr_in, *ptr_out;

    /* Doppler Dimension coarse*/
    for (iLw=0;iLw<linBins/32;iLw++){
        /* Doppler Dimension fine*/
        for (iLb=0;iLb<32;iLb++){
            /* Range Dimension coarse*/
            for (iTb=0;iTb<trnspsBins/32;iTb++){
                rWord = 0;
                /* Range Dimension fine*/
                for (iTw=0;iTw<32;iTw++){
                    ptr_in = detMap1+(iTw+(iTb*32))*(linBins/32)+iLw;
                    mask = (1<<iLb);
                    rWord |= (((*ptr_in & mask) >> iLb) << iTw);
                }
                ptr_out = detMapDest +(iLb+(iLw*32))*(trnspsBins/32)+iTb;
                *ptr_out = rWord;
            }
        }
    }
}


/*
 ******************************************************************************
 * Brief:   The routine void IfxAnalyze_Bitmap(uint32* detMap1, TargetGroup* det_Targets)
 * Details: This routine checks the bitmap for targets and writes result to targets variable
 ******************************************************************************
 */
void IfxAnalyze_Bitmap (uint32* detMap1, uint16 linBins, uint16 trnspsBins){
    float start = -90.0;
    float end = 90.0;
    /* Calculate the step size*/
    float step = (end - start) / (RADAR_NUM_DTHETA - 1);

    uint32 iAb, iRb, leading_zeros, mask;
    uint16 nr_of_targets;
    Radar *rdr = &g_rdr;
    nr_of_targets = 0;
    rdr->det_targets.count=0;

    /*set target data to 0*/
    for (int itarget=0;itarget<DEMO_MAX_TARGETS;itarget++){
        rdr->det_targets.targets[itarget].coord.rangebin=0;
        rdr->det_targets.targets[itarget].coord.anglebin=0;
        rdr->det_targets.targets[itarget].coord.angle=0;
        rdr->det_targets.targets[itarget].coord.distance=0;
    }

    for (iRb=0;iRb<trnspsBins;iRb++){
        for (iAb=0;iAb<(linBins/32);iAb++){
            /* calculate with pointers like examples above*/
            mask = *detMap1;
            leading_zeros = 0;
            while (leading_zeros!=32){
                leading_zeros = __clz(mask);
                if (leading_zeros !=32 && nr_of_targets<DEMO_MAX_TARGETS){
                    rdr->det_targets.count= nr_of_targets+1;
                    rdr->det_targets.targets[nr_of_targets].coord.rangebin=iRb;
                    rdr->det_targets.targets[nr_of_targets].coord.anglebin = (31-leading_zeros)+32*iAb;
                    rdr->det_targets.targets[nr_of_targets].coord.angle = start + (rdr->det_targets.targets[nr_of_targets].coord.anglebin * step);
                    rdr->det_targets.targets[nr_of_targets].coord.distance =  iRb*RANGE_RESOLUTION;
                    mask &= ~(1 << (31-leading_zeros));
                    nr_of_targets++;
                    if (nr_of_targets >= DEMO_MAX_TARGETS) {
                        return; /* Return to main function when max_targets is reached*/
                }
            }
            }
            detMap1++;
        }
    }

}
