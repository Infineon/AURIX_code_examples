/**********************************************************************************************************************
 * \file IfxBgt60ATR24E_init.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


#include <IfxBgt60ATR24E_init.h>

uint32 g_MmicProgSequenceLength = 50;
uint32 MmicProgSequence[55];


/* Time constants assuming f_STM0 = 50MHz */
#define STM0_TICKS_BACKUPCLK_1us    (   50)
#define STM0_TICKS_BACKUPCLK_10us   (  500)
#define STM0_TICKS_BACKUPCLK_20us   ( 1000)
#define STM0_TICKS_BACKUPCLK_100us  ( 5000)
#define STM0_TICKS_BACKUPCLK_300us  (15000)
#define STM0_TICKS_BACKUPCLK_1ms    (50000)
#define STM0_TICKS_BACKUPCLK_10ms  (500000)


/* This function performs a hardware reset of the BGT60 */
void Mmic_reset(void)
{
    /* Init BGT60 reset pin */
    IfxPort_setPinModeOutput(BGT60_RST_PIN, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinPadDriver(BGT60_RST_PIN, IfxPort_PadDriver_ttl3v3Speed1);


    /* toggle reset pin 1-0-1 (min. 100ns each) while CSN is HIGH */
    IfxPort_setPinHigh(BGT60_RST_PIN);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_1us);

    IfxPort_setPinLow(BGT60_RST_PIN);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_1us);

    IfxPort_setPinHigh(BGT60_RST_PIN);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_1us);

    /* then wait some more time for reset to happen */
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_10ms);
}

/* This function configures the 40MHz clock output on the BGT60 */
void Mmic_enable40MHzClock(void)
{
    /****** BGT60 XOSC start-up sequence ******/
    uint32 spiCmd[7];

    /*Enable XOSC LDO (XOSC_LDO_EN = 1) and XOSC bandgap reference (XOSC_BG_EN = 1) */
    spiCmd[0]  = (0x5F<<25)| (WRITE_MMIC << 24) | 0xB04400;
    Qspi_exchange32(spiCmd[0]);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_20us);

    /*Set resistor value of bandgap filter to 1 Mâ„¦ (XOSC_BG_RFILT_SEL = 1) */
    spiCmd[1]  = (0x5F<<25)| (WRITE_MMIC << 24) | 0xF04400;
    Qspi_exchange32(spiCmd[1]);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_10us);

    /*Enable XOSC core (XOSC_CORE_EN = 1)*/
    spiCmd[2]  = (0x5F<<25)| (WRITE_MMIC << 24) | 0xF44400;
    Qspi_exchange32(spiCmd[2]);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_300us);

    /*Enable XOSC output clock buffer (XOSC_BUF_EN = 1) and high performance*/
    /* mode of XOSC output clock buffer (XOSC_HP_MODE_EN = 1)*/
    spiCmd[3]  = (0x5F<<25)| (WRITE_MMIC << 24) | 0xF6C400;
    Qspi_exchange32(spiCmd[3]);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_20us);

    /*Enable XOSC noise filter (XOSC_FILT_EN = 1)*/
    spiCmd[4]  = (0x5F<<25)| (WRITE_MMIC << 24) | 0xF7C400;
    Qspi_exchange32(spiCmd[4]);
    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_20us);

    /****** XOSC configuration with 40 MHz XTAL ******/
    spiCmd[5]  = (0x5F<<25)| (WRITE_MMIC << 24) | 0xE78402;
    Qspi_exchange32(spiCmd[5]);
    spiCmd[6]  = (0x5F<<25)| (WRITE_MMIC << 24) | 0xE7A402;
    Qspi_exchange32(spiCmd[6]);

    IfxStm_waitTicks(&MODULE_STM0, STM0_TICKS_BACKUPCLK_1ms);
}

/* This function generates the configuration (register values) for the BGT60 */
void Mmic_fill_config(void)
{
    /* -> 2TX in TDM mode, 8 ramps each (total 16 ramps), 4RX, 256samp/ramp
     * -> f=58.0-62.0022GHz, f_s=2.66667MHz
     * -> prepare 40MHz clock generation by BGT60 and output to clock pin enabled
    */

    /* Calculate how many FIFO elements have to be fetched per ramp.
     * One FIFO location (24bit) stores two 12-bit samples. Max FIFO
     * size is 8192, buffering more samples creates a FIFO overflow.
     */
    uint32 fifoLocationsPerRamp = (RADAR_NUM_SAMPLES*RADAR_NUM_RX)/2;
    if(fifoLocationsPerRamp>8192)
    {
        __debug();
    }

    MmicProgSequence[0 ] = (0x00<<25) | (WRITE_MMIC<<24) | 0x1c0e20;
    MmicProgSequence[1 ] = (0x01<<25) | (WRITE_MMIC<<24) | 0x090210;
    MmicProgSequence[2 ] = (0x04<<25) | (WRITE_MMIC<<24) | 0xe967fd;
    MmicProgSequence[3 ] = (0x05<<25) | (WRITE_MMIC<<24) | 0x4805b4;
    MmicProgSequence[4 ] = (0x06<<25) | (WRITE_MMIC<<24) | 0x786000  | (fifoLocationsPerRamp-1);
    MmicProgSequence[5 ] = (0x07<<25) | (WRITE_MMIC<<24) | 0x010fc0;
    MmicProgSequence[6 ] = (0x08<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[7 ] = (0x09<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[8 ] = (0x0a<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[9 ] = (0x0b<<25) | (WRITE_MMIC<<24) | 0xd0dbe0;
    MmicProgSequence[10] = (0x0c<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[11] = (0x0d<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[12] = (0x0e<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[13] = (0x0f<<25) | (WRITE_MMIC<<24) | 0x000b60;
    MmicProgSequence[14] = (0x10<<25) | (WRITE_MMIC<<24) | 0x1ffc71;
    MmicProgSequence[15] = (0x11<<25) | (WRITE_MMIC<<24) | 0xf3c01f;
    MmicProgSequence[16] = (0x12<<25) | (WRITE_MMIC<<24) | 0x2cb2cb;
    MmicProgSequence[17] = (0x16<<25) | (WRITE_MMIC<<24) | 0x000490;
    MmicProgSequence[18] = (0x17<<25) | (WRITE_MMIC<<24) | 0x1ffc74;
    MmicProgSequence[19] = (0x18<<25) | (WRITE_MMIC<<24) | 0xf3c3e0;
    MmicProgSequence[20] = (0x19<<25) | (WRITE_MMIC<<24) | 0x2cb2cb;
    MmicProgSequence[21] = (0x1d<<25) | (WRITE_MMIC<<24) | 0x000490;
    MmicProgSequence[22] = (0x24<<25) | (WRITE_MMIC<<24) | 0x000480;
    MmicProgSequence[23] = (0x2b<<25) | (WRITE_MMIC<<24) | 0x000480;
    MmicProgSequence[24] = (0x2c<<25) | (WRITE_MMIC<<24) | 0x11bc0e;
    MmicProgSequence[25] = (0x2d<<25) | (WRITE_MMIC<<24) | 0x690c0a;
    MmicProgSequence[26] = (0x2e<<25) | (WRITE_MMIC<<24) | 0x000001 | ((RADAR_NUM_RAMPS-1)<<12);
    MmicProgSequence[27] = (0x2f<<25) | (WRITE_MMIC<<24) | 0xbf3e1e;
    MmicProgSequence[28] = (0x30<<25) | (WRITE_MMIC<<24) | 0xa869f2;
    MmicProgSequence[29] = (0x31<<25) | (WRITE_MMIC<<24) | 0x0002b5;
    MmicProgSequence[30] = (0x32<<25) | (WRITE_MMIC<<24) | 0x0004b2;
    MmicProgSequence[31] = (0x33<<25) | (WRITE_MMIC<<24) | 0x000100;
    MmicProgSequence[32] = (0x34<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[33] = (0x35<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[34] = (0x36<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[35] = (0x37<<25) | (WRITE_MMIC<<24) | 0x000110;
    MmicProgSequence[36] = (0x38<<25) | (WRITE_MMIC<<24) | 0xa869f2;
    MmicProgSequence[37] = (0x39<<25) | (WRITE_MMIC<<24) | 0x0002b5;
    MmicProgSequence[38] = (0x3a<<25) | (WRITE_MMIC<<24) | 0x0004b2;
    MmicProgSequence[39] = (0x3b<<25) | (WRITE_MMIC<<24) | 0x000100;
    MmicProgSequence[40] = (0x3c<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[41] = (0x3d<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[42] = (0x3e<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[43] = (0x3f<<25) | (WRITE_MMIC<<24) | 0x269b10;
    MmicProgSequence[44] = (0x47<<25) | (WRITE_MMIC<<24) | 0x393b00;
    MmicProgSequence[45] = (0x4f<<25) | (WRITE_MMIC<<24) | 0x393b00;
    MmicProgSequence[46] = (0x56<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[47] = (0x5b<<25) | (WRITE_MMIC<<24) | 0x000000;
    MmicProgSequence[48] = (0x5f<<25) | (WRITE_MMIC<<24) | 0xe7A402;   /*OSC_OUT enabled! */
    MmicProgSequence[49] = (0x60<<25) | (WRITE_MMIC<<24) | 0x000827;

    g_MmicProgSequenceLength = 50;
}


/* This function uploads the configuration to the BGT60 */
void Mmic_write_config(void)
{
    uint32 i = 0;
    for(i=0; i<g_MmicProgSequenceLength; i++)
    {
        Qspi_exchange32(MmicProgSequence[i]);
    }
}

/* This function reads the ChipID register and compares it to the
 * expected value (0x090F). In case of a mismatch, the program is stopped.
 */
void Mmic_verifyChipID(void)
{
    uint32 chipid = Qspi_exchange32(0x04000000) & 0xFFFF;

    if (chipid != 0x090F)
    {
        __debug(); /*stop if chip id does not match expected value*/
    }
}

/* This function disables the SPI HighSpeed mode on the BGT60 (-> fSPI<=25MHz).
 * The max SPI speed for TC35 in the used configuration is 20MHz. */
void Mmic_disableSpiHighspeedMode(void)
{
    uint32 sfctl = Qspi_exchange32((0x06<<25) | (READ_MMIC<<24));
    sfctl &= ~(1<<16); /*clear bit16 (SFCTL.MISO_HS_READ) to disable HS mode*/
    sfctl &= 0xFFFFFF;
    Qspi_exchange32((0x06<<25) | (WRITE_MMIC<<24) | sfctl);
}

/* This function starts a ramp sequence by first resetting the frame state machine
 * and then setting the 'start frame' bit.
 */
void Mmic_startOperation(void)
{
    Qspi_exchange32(MmicProgSequence[0] | (0x1<<2) );     /*reset MMIC state machine*/
    Qspi_exchange32(MmicProgSequence[0] | 0x1 );          /*start frame*/
    Qspi_Mode(Spi_Burst);                               /*configure SPI for burst mode (->interrupt served by DMA) */
}

/* This function performs a FIFO reset to recover from a FIFO overflow/underflow */
void Mmic_fifoReset(void)
{
    uint32 mainReg = Qspi_exchange32((0x00<<25) | (READ_MMIC<<24));
    mainReg = (mainReg&0xFFFFFF) | (1<<3); /*set bit3 (MAIN.FIFO_RESET) to perform FIFO reset */
    Qspi_exchange32((0x00<<25) | (WRITE_MMIC<<24) | mainReg);
}
