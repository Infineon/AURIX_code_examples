/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
 /*\title iLLD_TC356TA_ADS_ICMS_BOARD_3_0_point_cloud
 * \abstract This software project for the ICMS board v3.0 (AURIX TC356 and BGT60 ATR24AIP) demonstrates the main radar signal processing steps to generate point cloud data from raw data recorded by the MMIC.
 * \description This software project is intended as a starting point for the application of in cabin monitoring (ICMS) on the ICMS board v3.0. It demonstrates the main processing steps that need to be performed on AURIX TC356 signal processing unit (SPU) and Tricore CPUs to generate point cloud data from raw data recorded by the BGT60 ATR24AIP MMIC.
 *              
 *              Basic understanding of FMCW radar range-doppler signal processing is presumed to follow this code example.
 *
 * \name iLLD_TC356TA_ADS_ICMS_BOARD_3_0_point_cloud
 * \version V1.0.0
 * \board ICMS board v3.0, ICMS board v3.0, TC35xTA_A-Step
 * \keywords ICMS, RADAR, POINT CLOUD
 * \documents see README.md
 * \lastUpdated 2025-07-11
 *********************************************************************************************************************/
#include <Clock/IfxClock_init.h>
#include <IfxBgt60ATR24E_init.h>
#include <IfxPort_init.h>
#include <IfxQspi_init.h>
#include <IfxRadar_cfg.h>
#include "IfxStm_init.h"
#include "IfxRmem_init.h"
#include "IfxDma_Init.h"
#include "IfxSpu_init.h"
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "IfxScuCcu.h"
#include "IfxCbs_reg.h"
#include "RangeHeatmap.h"
#include "BitmapProcessing.h"
#include "SCME.h"
#include "math.h"

IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;

IfxCpu_Perf g_perfCounts;
IFX_INLINE void IfxRadarStateMachine(void);

void core0_main(void)
{

    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    IfxScuWdt_disableCpuWatchdog(IfxScuWdt_getCpuWatchdogPassword());
    IfxScuWdt_disableSafetyWatchdog(IfxScuWdt_getSafetyWatchdogPassword());
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);


    IfxMtu_Init();                  /* Init MTU */
    IfxPort_Init();                 /* Init pins for LDO, MMIC Reset, Data IRQ, ... */
    Qspi_Init(100e6);               /* Init QSPI module using backup clock */
    Mmic_reset();                   /* Hard-reset BGT60 */
    Mmic_disableSpiHighspeedMode(); /* set BGT60 SPI to HS mode (change clock edge) */
    Mmic_enable40MHzClock();        /* activate BGT60 40MHz clock output */
    IfxClock_switchTo40MHzClock();  /* Switch to 40MHz clock provided by BGT60 */
    Qspi_Init(200e6);               /* re-init QSPI with new clock settings */
    IfxStm_Init();                  /* Init STM (for 1ms tasks) */
    IfxRmem_Init();                 /* Init RMEM (for radar data storage) */
    IfxDma_Init();                  /* Init DMA (for radar data transfer from MMIC FIFO buffer to EMEM via QSPI) */

    while(1)
    {
      /*dynamic*/
     IfxRadarStateMachine();
    }
}

void TaskCpu0_1ms(void)
{
    Radar *rdr = &g_rdr;

    if (Core0_Stm_1ms %RADAR_CYCLE_MS  == 0)
    {
        if (rdr->rState==Radar_State_ready)
        {         /* trigger MMIC if ready for next ramp scenario*/
            rdr->rState=Radar_State_operation;
        }
        else if (rdr->rState != Radar_State_init &&  /* error if ramp scenario wasn't finished in time*/
                 rdr->rState != Radar_State_config )
        {
            rdr->rState=Radar_State_error;
        }
    }

}


IFX_INLINE void IfxRadarStateMachine()
{
    Radar *rdr = &g_rdr;
    switch (rdr->rState)
    {
        case Radar_State_init:
            rdr->rmpCnt = 0;
            rdr->frameCnt = 0;
            rdr->rState = Radar_State_config;
            break;
        case Radar_State_config:
            /* CONFIG MMIC */
            Mmic_fill_config();
            Mmic_write_config();
            /* INIT SPUs */
            IfxSpu_Init();
            IfxCpu_resetAndStartCounters(IfxCpu_CounterMode_normal);
            rdr->rState = Radar_State_ready;
            break;
        case Radar_State_ready:
             break;
        case Radar_State_operation:
            /* HOOK to kick off MMIC*/
            Mmic_startOperation(); /* MMIC ramp generation */
            rdr->rState = Radar_State_acquisition;
            break;
        case Radar_State_acquisition :

            break;
        case Radar_State_data :
            /* Update SPU config to write adc data to position of corresponding ramp */
            odp_conf.B.BASE = (IFX_OFFSETOF(SPU_Rmem_Map_t, adc_sort[rdr->rmpCnt]))/32; /* set radar memory base address (converted from byte address) */
            rdr->cmem0->slots[0].BE[0].ODP_CONF.U = odp_conf.U;

            /* CHIRP PROCESSING */
            IfxSpu_reloadConfig(rdr->spu0, 1);
            /* wait until reload has finished */
            while (rdr->spu0->CTRL.B.MODE == IfxSpu_TriggerMode_reload);
            if (rdr->rmpCnt==RADAR_NUM_RAMPS-1)
             {   /* jump to loop when last ramp of radar frame has been recorded */
                rdr->rmpCnt=0;                       /*reset ramp count*/
                while(rdr->spuOk < RADAR_NUM_RAMPS); /* wait for SPU to finish sorting of last ramp of the current radar frame */
                rdr->spuOk=0;                       /*reset spuOk*/
                g_perfCounts = IfxCpu_stopCounters();
                rdr->clockcountsICMS.frameacquisition = g_perfCounts.clock.counter;
                rdr->rState = Radar_State_processing; /* Frame Acquisition completed -> move to processing step for frame processing*/
            }
            else
            {
                rdr->rmpCnt++;
                rdr->rState = Radar_State_acquisition;
            }
            break;
        case Radar_State_processing:
            /* FRAME PROCESSING */
            /*perform range FFT, antenna calibration and complex sum across ramps on SPU, write micro doppler frame*/
            IfxCpu_resetAndStartCounters(IfxCpu_CounterMode_normal);
            IfxSpu_reloadConfig(rdr->spu0, 2);
            IfxSpu_waitReload(rdr->spu0);

            while(rdr->spuOk < 1);  /* wait for SPU to finish processing */
            rdr->spuOk=0;           /*reset spuOk*/
            g_perfCounts = IfxCpu_stopCounters();
            rdr->clockcountsICMS.frameproc = g_perfCounts.clock.counter;

            rdr->frameCnt++;  /* current frame has been processed --> increase frame count */

            /* MICRO DOPPLER PROCESSING */
            /*perform clutter removal, direction of arrival (capon beamforming) and detection*/
            if (rdr->frameCnt>RADAR_NUM_MICRO_DOPPLER)
            { /* jump to loop when last frame of micro doppler frame has been recorded */

                /*perform clutter removal on micro doppler frame*/
                IfxCpu_resetAndStartCounters(IfxCpu_CounterMode_normal);
                IfxSpu_reloadConfig(rdr->spu0, 6);
                IfxSpu_waitReload(rdr->spu0);
                while(rdr->spuOk < 1); /* wait for SPU to finish processing */
                rdr->spuOk=0;           /*reset spuOk*/
                g_perfCounts = IfxCpu_stopCounters();
                rdr->clockcountsICMS.microdopplerproc = g_perfCounts.clock.counter;


                /* PERFORM CAPON BEAMFORMING ON MICODOPPLER FRAME */
                /*use 4 virtual antenna in aziumth*/

                /*Spatial Covariance Matrix Estimation (SCME)*/
                IfxCpu_resetAndStartCounters(IfxCpu_CounterMode_normal);
                SCM_Generator(RADAR_NUM_SAMPLES/2);
                ComplexMatrixInversion(RADAR_NUM_SAMPLES/2, RADAR_NUM_VRX_AZIMUTH-1);

                /*Range-Azimuth power spectrum (Capon)*/
                ASM_Generator();
                Power_Spectrum();  /*note that beamforming weights are commented out*/
                g_perfCounts = IfxCpu_stopCounters();
                rdr->clockcountsICMS.capon = g_perfCounts.clock.counter;

                /*SPU CFAR, local maximum and absolute threshold detection on power spectrum in two dimensions*/
                IfxCpu_resetAndStartCounters(IfxCpu_CounterMode_normal);
                IfxSpu_reloadConfig(rdr->spu0, 10);
                while(rdr->spuOk < 1); /* wait for SPU to finish processing */
                rdr->spuOk=0;           /*reset spuOk*/

                /*process detection bitmaps*/
                IfxDetectionMapCombine(rdr->rmem->CFARAMap[0], rdr->rmem->CFARLMAMap[0], rdr->rmem->AMap_combined[0], RADAR_NUM_DTHETA, RADAR_NUM_SAMPLES/2, DetMap_And);
                IfxDetectionMapCombine(rdr->rmem->CFARRMap[0], rdr->rmem->CFARLMRMap[0], rdr->rmem->RMap_combined[0], RADAR_NUM_SAMPLES/2, RADAR_NUM_DTHETA, DetMap_And);
                IfxDetectionMapTranspose(rdr->rmem->RMap_combined[0], rdr->rmem->RMap_combined_transpose[0], RADAR_NUM_SAMPLES/2, RADAR_NUM_DTHETA);
                IfxDetectionMapCombine(rdr->rmem->RMap_combined_transpose[0], rdr->rmem->AMap_combined[0], rdr->rmem->DetMap[0], RADAR_NUM_DTHETA, RADAR_NUM_SAMPLES/2, DetMap_And);

                /*write detections to target list*/
                IfxAnalyze_Bitmap (rdr->rmem->DetMap[0], RADAR_NUM_DTHETA, RADAR_NUM_SAMPLES/2);
                g_perfCounts = IfxCpu_stopCounters();
                rdr->clockcountsICMS.detections = g_perfCounts.clock.counter;

                __debug();
            }
            rdr->rState = Radar_State_ready;
            break;
        case Radar_State_error:
            __debug();
            break;
        default:
            break;
    }
}
