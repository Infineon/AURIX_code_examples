/**
 * \file AsclinShellInterface.c
 * \brief Source file of ASCLIN Shell interface demo
 *
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Software_Config.h"
#if  (defined(__ghs__) && ((CPU_WHICH_SERVICE_ASC_SHELL == 4) || (CPU_WHICH_SERVICE_ASC_SHELL == 5)))
#pragma ghs callmode=far
#endif
#include "Pin_Config.h"
#include "Bsp/assert.h"
#include "AsclinShellInterface.h"

#include "SysSe/Time/Ifx_DateTime.h"
/*#include "LinCmds.h" */
#include "TLF4D985Cmds.h"
/*#include "GpioCmds.h" */
#include "TmadcCmds.h"
/*#include "IfxEray_cfg.h" */
#ifdef IFXERAY_NUM_MODULES
/*#include "ErayCmds.h" */
#endif
/*#include "CanCmds.h" */
/*#include "IfxGeth_cfg.h" */
#ifdef IFXGETH_NUM_MODULES
/*#include "EthernetCmds.h" */
#endif
#include "Measurement.h"
#include "assert.h"
/*#include "Cpu_Main.h" */

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/*#define SHELL_HELP_DESCRIPTION_TEXT                                 \
    "       : Display command list."ENDL                              \
    "             A command followed by a question mark '?' will"ENDL \
    "             show the command syntax"*/

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

boolean AppShell_status(pchar args, void *data, IfxStdIf_DPipe *io);

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if CPU_WHICH_SERVICE_ASC_SHELL == 0
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu0" bss=".bss_cpu0" data=".data_cpu0" rodata=".rodata_cpu0"
    #else
    #pragma section ".text_cpu0" ax
    #pragma section ".bss_cpu0" awc0
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu0"
    #pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
    #pragma section CONST ".rodata_cpu0"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu0"
    #pragma ghs section bss= ".bss_cpu0"
    #pragma ghs section data=".data_cpu0"
    #pragma ghs section rodata=".rodata_cpu0"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 1) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu1" bss=".bss_cpu1" data=".data_cpu1" rodata=".rodata_cpu1"
    #else
    #pragma section ".text_cpu1" ax
    #pragma section ".bss_cpu1" awc1
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu1"
    #pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
    #pragma section CONST ".rodata_cpu1"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu1"
    #pragma ghs section bss= ".bss_cpu1"
    #pragma ghs section data=".data_cpu1"
    #pragma ghs section rodata=".rodata_cpu1"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 2) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu2" bss=".bss_cpu2" data=".data_cpu2" rodata=".rodata_cpu2"
    #else
    #pragma section ".text_cpu2" ax
    #pragma section ".bss_cpu2" awc2
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu2"
    #pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
    #pragma section CONST ".rodata_cpu2"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu2"
    #pragma ghs section bss= ".bss_cpu2"
    #pragma ghs section data=".data_cpu2"
    #pragma ghs section rodata=".rodata_cpu2"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 3) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu3" bss=".bss_cpu3" data=".data_cpu3" rodata=".rodata_cpu3"
    #else
    #pragma section ".text_cpu3" ax
    #pragma section ".bss_cpu3" awc3
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu3"
    #pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
    #pragma section CONST ".rodata_cpu3"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu3"
    #pragma ghs section bss= ".bss_cpu3"
    #pragma ghs section data=".data_cpu3"
    #pragma ghs section rodata=".rodata_cpu3"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 4) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu4" bss=".bss_cpu4" data=".data_cpu4" rodata=".rodata_cpu4"
    #else
    #pragma section ".text_cpu4" ax
    #pragma section ".bss_cpu4" awc4
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu4"
    #pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
    #pragma section CONST ".rodata_cpu4"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu4"
    #pragma ghs section bss= ".bss_cpu4"
    #pragma ghs section data=".data_cpu4"
    #pragma ghs section rodata=".rodata_cpu4"
    #endif
#elif ((CPU_WHICH_SERVICE_ASC_SHELL == 5) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu5" bss=".bss_cpu5" data=".data_cpu5" rodata=".rodata_cpu5"
    #else
    #pragma section ".text_cpu5" ax
    #pragma section ".bss_cpu5" awc5
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu5"
    #pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
    #pragma section CONST ".rodata_cpu5"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu5"
    #pragma ghs section bss= ".bss_cpu5"
    #pragma ghs section data=".data_cpu5"
    #pragma ghs section rodata=".rodata_cpu5"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_ASC_SHELL to a valid value!"
#endif

App_AsclinShellInterface g_AsclinShellInterface; /**< \brief Demo information */
volatile boolean AsclinShell_InitDone=FALSE;

#if IFXCPU_NUM_MODULES > 5
extern volatile float32 cpu5_load;
#endif

#if IFXCPU_NUM_MODULES > 4
extern volatile float32 cpu4_load;
#endif

#if IFXCPU_NUM_MODULES > 3
extern volatile float32 cpu3_load;
#endif

#if IFXCPU_NUM_MODULES > 2
extern volatile float32 cpu2_load;
#endif

#if IFXCPU_NUM_MODULES > 1
extern volatile float32 cpu1_load;
#endif

extern volatile float32 cpu0_load;

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

#if defined(__HIGHTEC__) && !defined(__clang__)
#pragma section /* end bss section */
#if CPU_WHICH_SERVICE_ASC_SHELL == 0
#pragma section ".rodata_cpu0" ac0
#endif
#if ((CPU_WHICH_SERVICE_ASC_SHELL == 1) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu1" ac1
#endif
#if ((CPU_WHICH_SERVICE_ASC_SHELL == 2) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu2" ac2
#endif
#if ((CPU_WHICH_SERVICE_ASC_SHELL == 3) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu3" ac3
#endif
#if ((CPU_WHICH_SERVICE_ASC_SHELL == 4) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu4" ac4
#endif
#if ((CPU_WHICH_SERVICE_ASC_SHELL == 5) && (CPU_WHICH_SERVICE_ASC_SHELL < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu5" ac5
#endif
#endif

/** \brief Application shell command list */
const Ifx_Shell_Command AppShell_commands[] = {
    {"status", "     : Show the application status", &g_AsclinShellInterface,       &AppShell_status,    },
    {"help  ",   SHELL_HELP_DESCRIPTION_TEXT,        &g_AsclinShellInterface.shell, &Ifx_Shell_showHelp, },
    IFX_SHELL_COMMAND_LIST_END
};

#if defined(__HIGHTEC__) && !defined(__clang__)
#pragma section /* end rodata section, now text section selected */
#endif
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Demo_AsclinShellInterface_SrcDoc_Main_Interrupt
 * \{ */

/** \name Interrupts for Serial interface
 * \{ */

/** \} */

/** \} */

/** \brief Handle Asc0 Rx interrupt
 *
 * \isrProvider \ref ISR_PROVIDER_ASC_0
 * \isrPriority \ref ISR_PRIORITY_ASC_SHELL_RX
 *
 * - Configuration of this interrupt is done by Asc_If_init()
 * - This interrupt is raised each time a data have been received on the serial interface.
 *   and Asc_If_receiveIrq() will be called
 */
IFX_INTERRUPT(ISR_Asc_Shell_rx, CPU_WHICH_SERVICE_ASC_SHELL, ISR_PRIORITY_ASC_SHELL_RX)
{
	IfxCpu_enableInterrupts();
    IfxStdIf_DPipe_onReceive(&g_AsclinShellInterface.stdIf.asc);
}


/** \brief Handle Asc0 Tx interrupt
 *
 * \isrProvider \ref ISR_PROVIDER_ASC_0
 * \isrPriority \ref ISR_PRIORITY_ASC_SHELL_TX
 *
 * - Configuration of this interrupt is done by Asc_If_init()
 * - This interrupt is raised each time the serial interface transmit buffer get empty
 *   and Asc_If_transmitIrq() will be called
 */
IFX_INTERRUPT(ISR_Asc_Shell_tx, CPU_WHICH_SERVICE_ASC_SHELL, ISR_PRIORITY_ASC_SHELL_TX)
{
    IfxCpu_enableInterrupts();
    IfxStdIf_DPipe_onTransmit(&g_AsclinShellInterface.stdIf.asc);
}


/** \brief Handle Asc0 Ex interrupt.
 *
 * \isrProvider \ref CPU_WHICH_SERVICE_ASC_SHELL
 * \isrPriority \ref ISR_PRIORITY_ASC_SHELL_EX
 *
 * - Configuration of this interrupt is done by Asc_If_init()
 * - This interrupt is raised each time an error occurs on the serial interface and
 *   Asc_If_errorIrq() will be called.
 */
IFX_INTERRUPT(ISR_Asc_Shell_ex, CPU_WHICH_SERVICE_ASC_SHELL, ISR_PRIORITY_ASC_SHELL_EX)
{
    IfxCpu_enableInterrupts();
    IfxStdIf_DPipe_onError(&g_AsclinShellInterface.stdIf.asc);
}


/** \brief Handle the 'status' command
 *
 * \par Syntax
 *  - status : Show the application internal state
 */
boolean AppShell_status(pchar args, void *data, IfxStdIf_DPipe *io)
{
    if (Ifx_Shell_matchToken(&args, "?") != FALSE)
    {
        IfxStdIf_DPipe_print(io, "Syntax     : status"ENDL);
        IfxStdIf_DPipe_print(io, "           > Show the application internal state"ENDL);
    }
    else
    {
        Ifx_DateTime rt;
        DateTime_get(&rt);
        IfxStdIf_DPipe_print(io, "Alive: %02d:%02d:%02d"ENDL, rt.hours, rt.minutes, rt.seconds);
        IfxStdIf_DPipe_print(io, "DIE Temperature : %.1f C (min: %.1f C  max: %.1f C)"ENDL, (float) die_temp, die_lowest, die_highest);
        IfxStdIf_DPipe_print(io, "VDDEVRSB  Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddevrsb, Vddevrsb_min, Vddevrsb_max);
        IfxStdIf_DPipe_print(io, "VDDEXT    Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddext, Vddext_min, Vddext_max);
        IfxStdIf_DPipe_print(io, "VDDM      Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddm, Vddm_min, Vddm_max);
        IfxStdIf_DPipe_print(io, "VDDPHPHY0 Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddphphy0, Vddphphy0_min, Vddphphy0_max);
        IfxStdIf_DPipe_print(io, "VDDPHY0   Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddphy0, Vddphy0_min, Vddphy0_max);
        IfxStdIf_DPipe_print(io, "VDDPHPHY1 Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddphphy1, Vddphphy1_min, Vddphphy1_max);
        IfxStdIf_DPipe_print(io, "VDDPHY1   Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddphy1, Vddphy1_min, Vddphy1_max);
        IfxStdIf_DPipe_print(io, "VDDHSIF   Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) Vddhsif, Vddhsif_min, Vddhsif_max);
        IfxStdIf_DPipe_print(io, "VDD       Voltage : %.2f V (min: %.2f V  max: %.2f V)"ENDL, (float) core_voltage, core_volt_min, core_volt_max);
    }
    return TRUE;
}

/** Initialise the serial interafce
 *
 */
void initSerialInterface(void)
{
    {   /** - Serial interface */
        IfxAsclin_Asc_Config config;
        IfxAsclin_Asc_initModuleConfig(&config, ASC_SHELL_TX_PIN.module);
        config.baudrate.baudrate             = CFG_ASC_SHELL_BAUDRATE;
        config.baudrate.oversampling         = IfxAsclin_OversamplingFactor_16;
        config.bitTiming.medianFilter        = IfxAsclin_SamplesPerBit_three;
        config.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;
        config.interrupt.rxPriority          = ISR_PRIORITY_ASC_SHELL_RX;
        config.interrupt.txPriority          = ISR_PRIORITY_ASC_SHELL_TX;
        config.interrupt.erPriority          = ISR_PRIORITY_ASC_SHELL_EX;
        config.interrupt.typeOfService       = (IfxSrc_Tos)CPU_WHICH_SERVICE_ASC_SHELL;

        IfxAsclin_Asc_Pins ascPins = {
            .cts       = NULL_PTR,
            .ctsMode   = IfxPort_InputMode_noPullDevice,
            .rx        = &ASC_SHELL_RX_PIN,
            .rxMode    = IfxPort_InputMode_noPullDevice,
            .rts       = NULL_PTR,
            .rtsMode   = IfxPort_OutputMode_pushPull,
            .tx        = &ASC_SHELL_TX_PIN,
            .txMode    = IfxPort_OutputMode_pushPull,
            .pinDriver = IfxPort_PadDriver_cmosAutomotiveSpeed1
        };
        config.pins         = &ascPins;
        config.rxBuffer     = g_AsclinShellInterface.ascBuffer.rx;
        config.txBuffer     = g_AsclinShellInterface.ascBuffer.tx;
        config.txBufferSize = CFG_ASC_TX_BUFFER_SIZE;
        config.rxBufferSize = CFG_ASC_RX_BUFFER_SIZE;
        IfxAsclin_Asc_initModule(&g_AsclinShellInterface.drivers.asc, &config);

        /* Connect the standard asc interface to the device driver*/
        IfxAsclin_Asc_stdIfDPipeInit(&g_AsclinShellInterface.stdIf.asc, &g_AsclinShellInterface.drivers.asc);
    }

    /* Ifx_Console initialisation */
    Ifx_Console_init(&g_AsclinShellInterface.stdIf.asc);

    /* Assert initialisation */
    Ifx_Assert_setStandardIo(&g_AsclinShellInterface.stdIf.asc);
}


void AsclinShellInterface_init(void)
{
    /** - Initialise the time constants */
    initTime();

    /** - Initialise the serial interface and the console */
    initSerialInterface();

    /** - Enable the global interrupts of this CPU */
    restoreInterrupts(TRUE);

    Ifx_Console_print(ENDL);

    /* output welcome and board */
    IfxStdIf_DPipe_print(&g_AsclinShellInterface.stdIf.asc, "Hello World"ENDL);
    IfxStdIf_DPipe_print(&g_AsclinShellInterface.stdIf.asc, "I am the %s with %s..."ENDL, BOARD_TEXT, SW_VERSION_TEXT);

    Ifx_Console_print(ENDL "Enter 'help' to see the available commands"ENDL);

	/** - Initialize the shell interface  */
    {
        Ifx_Shell_Config config;
        Ifx_Shell_initConfig(&config);
        config.standardIo     = &g_AsclinShellInterface.stdIf.asc;
        config.commandList[0] = &AppShell_commands[0];

        Ifx_Shell_init(&g_AsclinShellInterface.shell, &config);
    }

    AsclinShell_InitDone = TRUE;
}


void AsclinShellInterface_run(void)
{
    /** Handle the shell interface */
    Ifx_Shell_process(&g_AsclinShellInterface.shell);

}

#if defined(__HIGHTEC__)
#if defined(__clang__)
#pragma clang section text="" bss="" data="" rodata=""
#else
#pragma section /* end text section */
#endif
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#pragma section CONST
#endif
#if defined(__ghs__)
#pragma ghs callmode=default
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#pragma ghs section rodata=default
#endif
