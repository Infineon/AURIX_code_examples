/**
 * \file TLF4D985.c
 * \brief Source file of TLF4D985 communication and initialization
 *
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Software_Config.h"
#if  (defined(__ghs__) && ((CPU_WHICH_SERVICE_TLF == 4) || (CPU_WHICH_SERVICE_TLF == 5)))
#pragma ghs callmode=far
#endif
#include "Pin_Config.h"
#include "TLF4D985.h"
#include "IfxQspi_SpiMaster.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/
#define TLF_BUFFER_SIZE 1   /**< \brief Tx/Rx Buffer size */

#define IFX_PMIC_DISABLE_PROTECTION  (0x0D02B5CAU) /** \brief Disable write protection  */
#define IFX_PMIC_ENABLE_PROTECTION   (0x5502D396U) /** \brief Enable write protection  */
#define IFX_PMIC_DUMMY_FRAME         (0x35FF0000U) /** \brief Dummy frame  */


/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/
typedef struct
{
    uint32 spiTxBuffer[TLF_BUFFER_SIZE];                               /**< \brief Qspi Transmit buffer */
    uint32 spiRxBuffer[TLF_BUFFER_SIZE];                               /**< \brief Qspi receive buffer */
} AppQspi_TLF_Buffer;

/** \brief QspiCpu global data */
typedef struct
{
    AppQspi_TLF_Buffer qspiBuffer;                       /**< \brief Qspi buffer */
    struct
    {
        IfxQspi_SpiMaster         spiMaster;             /**< \brief Spi Master handle */
        IfxQspi_SpiMaster_Channel spiMasterChannel;      /**< \brief Spi Master Channel handle */
    }drivers;
}  App_Qspi_TLF_Cpu;

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if CPU_WHICH_SERVICE_TLF == 0
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu0" bss=".bss_cpu0" data=".data_cpu0" rodata=".rodata_cpu0"
    #else
    #pragma section ".text_cpu0" ax
    #pragma section ".bss_cpu0" awc0
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu0"
    #pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
    #pragma section CONST ".rodata_cpu0"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu0"
    #pragma ghs section bss= ".bss_cpu0"
    #pragma ghs section data=".data_cpu0"
    #pragma ghs section rodata=".rodata_cpu0"
    #endif
#elif ((CPU_WHICH_SERVICE_TLF == 1) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu1" bss=".bss_cpu1" data=".data_cpu1" rodata=".rodata_cpu1"
    #else
    #pragma section ".text_cpu1" ax
    #pragma section ".bss_cpu1" awc1
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu1"
    #pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
    #pragma section CONST ".rodata_cpu1"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu1"
    #pragma ghs section bss= ".bss_cpu1"
    #pragma ghs section data=".data_cpu1"
    #pragma ghs section rodata=".rodata_cpu1"
    #endif
#elif ((CPU_WHICH_SERVICE_TLF == 2) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu2" bss=".bss_cpu2" data=".data_cpu2" rodata=".rodata_cpu2"
    #else
    #pragma section ".text_cpu2" ax
    #pragma section ".bss_cpu2" awc2
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu2"
    #pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
    #pragma section CONST ".rodata_cpu2"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu2"
    #pragma ghs section bss= ".bss_cpu2"
    #pragma ghs section data=".data_cpu2"
    #pragma ghs section rodata=".rodata_cpu2"
    #endif
#elif ((CPU_WHICH_SERVICE_TLF == 3) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu3" bss=".bss_cpu3" data=".data_cpu3" rodata=".rodata_cpu3"
    #else
    #pragma section ".text_cpu3" ax
    #pragma section ".bss_cpu3" awc3
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu3"
    #pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
    #pragma section CONST ".rodata_cpu3"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu3"
    #pragma ghs section bss= ".bss_cpu3"
    #pragma ghs section data=".data_cpu3"
    #pragma ghs section rodata=".rodata_cpu3"
    #endif
#elif ((CPU_WHICH_SERVICE_TLF == 4) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu4" bss=".bss_cpu4" data=".data_cpu4" rodata=".rodata_cpu4"
    #else
    #pragma section ".text_cpu4" ax
    #pragma section ".bss_cpu4" awc4
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu4"
    #pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
    #pragma section CONST ".rodata_cpu4"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu4"
    #pragma ghs section bss= ".bss_cpu4"
    #pragma ghs section data=".data_cpu4"
    #pragma ghs section rodata=".rodata_cpu4"
    #endif
#elif ((CPU_WHICH_SERVICE_TLF == 5) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu5" bss=".bss_cpu5" data=".data_cpu5" rodata=".rodata_cpu5"
    #else
    #pragma section ".text_cpu5" ax
    #pragma section ".bss_cpu5" awc5
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu5"
    #pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
    #pragma section CONST ".rodata_cpu5"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu5"
    #pragma ghs section bss= ".bss_cpu5"
    #pragma ghs section data=".data_cpu5"
    #pragma ghs section rodata=".rodata_cpu5"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_TLF to a valid value!"
#endif

App_Qspi_TLF_Cpu g_Qspi_TLF_Cpu;

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

#if defined(__HIGHTEC__) && !defined(__clang__)
#pragma section /* end bss section */
#if CPU_WHICH_SERVICE_TLF == 0
#pragma section ".rodata_cpu0" ac0
#endif
#if ((CPU_WHICH_SERVICE_TLF == 1) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu1" ac1
#endif
#if ((CPU_WHICH_SERVICE_TLF == 2) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu2" ac2
#endif
#if ((CPU_WHICH_SERVICE_TLF == 3) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu3" ac3
#endif
#if ((CPU_WHICH_SERVICE_TLF == 4) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu4" ac4
#endif
#if ((CPU_WHICH_SERVICE_TLF == 5) && (CPU_WHICH_SERVICE_TLF < IFXCPU_NUM_MODULES))
#pragma section ".rodata_cpu5" ac5
#endif
#endif

/* Pins on TriBoards */
const IfxQspi_SpiMaster_Pins tlf_qspi_pins = {&TLF_SCLK_PIN, IfxPort_OutputMode_pushPull,  /* SCLK */
                                              &TLF_MTSR_PIN,  IfxPort_OutputMode_pushPull, /* MTSR */
                                              &TLF_MRST_PIN,  IfxPort_InputMode_pullDown,  /* MRST */
                                              IfxPort_PadDriver_ttlSpeed1                   /* pad driver mode */
};

const IfxQspi_SpiMaster_Output tlf_slsOutput = {&TLF_CS_PIN,
                                                IfxPort_OutputMode_pushPull,
                                                IfxPort_PadDriver_cmosAutomotiveSpeed1};

#if defined(__HIGHTEC__) && !defined(__clang__)
#pragma section /* end rodata section, now text section selected */
#endif
/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
/** \brief Handle tlf_qspi_Tx interrupt.
 *
 * \isrProvider \ref CPU_WHICH_SERVICE_TLF
 * \isrPriority \ref ISR_PRIORITY_TLF_QSPI
 *
 */
IFX_INTERRUPT(ISR_tlf_qspi_Tx, CPU_WHICH_SERVICE_TLF, ISR_PRIORITY_TLF_QSPI_TX)
{
    IfxCpu_enableInterrupts();
#ifdef TLF_USE_DMA
    IfxQspi_SpiMaster_isrDmaTransmit(&(g_Qspi_TLF_Cpu.drivers.spiMaster));
#else
    IfxQspi_SpiMaster_isrTransmit(&(g_Qspi_TLF_Cpu.drivers.spiMaster));
#endif

}


/** \brief Handle tlf_qspi_Rx interrupt.
 *
 * \isrProvider \ref CPU_WHICH_SERVICE_TLF
 * \isrPriority \ref ISR_PRIORITY_TLF_QSPI
 *
 */
IFX_INTERRUPT(ISR_tlf_qspi_Rx, CPU_WHICH_SERVICE_TLF, ISR_PRIORITY_TLF_QSPI_RX)
{
    IfxCpu_enableInterrupts();
#ifdef TLF_USE_DMA
    IfxQspi_SpiMaster_isrDmaReceive(&(g_Qspi_TLF_Cpu.drivers.spiMaster));
#else
    IfxQspi_SpiMaster_isrReceive(&(g_Qspi_TLF_Cpu.drivers.spiMaster));
#endif
}

/** \brief Handle tlf_qspi_Er interrupt.
 *
 * \isrProvider \ref CPU_WHICH_SERVICE_TLF
 * \isrPriority \ref ISR_PRIORITY_TLF_QSPI
 *
 */
IFX_INTERRUPT(ISR_tlf_qspi_Er, CPU_WHICH_SERVICE_TLF, ISR_PRIORITY_TLF_QSPI_ER)
{
    IfxCpu_enableInterrupts();
    IfxQspi_SpiMaster_isrError(&(g_Qspi_TLF_Cpu.drivers.spiMaster));
}

/** \brief TLF (QSPI) initialization
 *
 * This function initializes Qspix in master mode.
 */
void IfxTLF4D985_init(void)
{
    /* disable interrupts */
    boolean interruptState = IfxCpu_disableInterrupts();

    IfxQspi_SpiMaster_Config        spiMasterConfig;

    /* create module config */
    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, TLF_SCLK_PIN.module);

    /* set the maximum baudrate */
    spiMasterConfig.maximumBaudrate = TLF_QSPI_MAX_BAUDRATE;

    /* ISR priorities and interrupt target */
    spiMasterConfig.txPriority  = ISR_PRIORITY_TLF_QSPI_TX;
    spiMasterConfig.rxPriority  = ISR_PRIORITY_TLF_QSPI_RX;
    spiMasterConfig.erPriority  = ISR_PRIORITY_TLF_QSPI_ER;
    spiMasterConfig.isrProvider = (IfxSrc_Tos)CPU_WHICH_SERVICE_TLF;

#ifdef TLF_QSPI_USE_DMA
        /* DMA configuration */
        spiMasterConfig.dma.txDmaChannelId = DMA_CH_TLF_QSPI_TX;
        spiMasterConfig.dma.rxDmaChannelId = DMA_CH_TLF_QSPI_RX;
        spiMasterConfig.dma.useDma = 1;
#endif

    spiMasterConfig.pins = &tlf_qspi_pins;

    /* initialize module */
    IfxQspi_SpiMaster_initModule(&(g_Qspi_TLF_Cpu.drivers.spiMaster), &spiMasterConfig);
    /* set the MRST_input also to the selected pad driver mode if needed */
    IfxPort_setPinPadDriver(spiMasterConfig.pins->mrst->pin.port, spiMasterConfig.pins->mrst->pin.pinIndex, spiMasterConfig.pins->pinDriver);

    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;

    {
        /* create channel config */
        IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &(g_Qspi_TLF_Cpu.drivers.spiMaster));

        /* set the baudrate for this channel */
        spiMasterChannelConfig.ch.baudrate = 5000000;

        /* set the transfer data width */
        spiMasterChannelConfig.ch.mode.dataWidth = 32;

        spiMasterChannelConfig.ch.mode.csLeadDelay = 7;
        spiMasterChannelConfig.ch.mode.csTrailDelay = 0;
        spiMasterChannelConfig.ch.mode.csInactiveDelay = 7;
        spiMasterChannelConfig.ch.mode.clockPolarity = IfxQspi_ClockPolarity_idleLow;

        spiMasterChannelConfig.ch.mode.shiftClock = IfxQspi_ShiftClock_shiftTransmitDataOnLeadingEdge;

        spiMasterChannelConfig.sls.output.pin    = tlf_slsOutput.pin;
        spiMasterChannelConfig.sls.output.mode   = tlf_slsOutput.mode;
        spiMasterChannelConfig.sls.output.driver = tlf_slsOutput.driver;

        /* initialize channel */
        IfxQspi_SpiMaster_initChannel(&g_Qspi_TLF_Cpu.drivers.spiMasterChannel,
            &spiMasterChannelConfig);
    }

    /* init tx buffer area */
    g_Qspi_TLF_Cpu.qspiBuffer.spiTxBuffer[0] = 0;
    g_Qspi_TLF_Cpu.qspiBuffer.spiRxBuffer[0] = 0;

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);
    /* Send a dummy read frame as TLF answers the 'BAD' frame directly after boot */
    IfxTLF4D985_read_write(IFX_PMIC_DUMMY_FRAME);
}

void IfxTLF4D985_disable_window_watchdog(void)
{
    /* Disable window watchdog */
	uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0038);              /* Read WD1_RS_CFG0 */
    /* only when window watchdog is enabled we disable it */
    if (readValue & 0x8)
    {
    	readValue &= ~0x8;                                      /* disable window watchdog */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x37, (uint16)readValue);    /* Write new value into WD1_PW_CFG0 */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_enable_window_watchdog(void)
{
    /* Enable window watchdog */
	uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0038);              /* Read WD1_RS_CFG0 */
    /* only when window watchdog is disabled we enable it */
    if (!(readValue & 0x8))
    {
    	readValue |= 0x8;                                       /* enable window watchdog */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x37, (uint16)readValue);    /* Write new value into WD1_PW_CFG0 */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_disable_functional_watchdog(void)
{
    /* Disable functional watchdog */
	uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0038);              /* Read WD1_RS_CFG0 */
    /* only when functional watchdog is enabled we disable it */
    if (readValue & 0x4)
    {
    	readValue &= ~0x4;                                      /* disable functional watchdog */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x37, (uint16)readValue);    /* Write new value into WD1_PW_CFG0 */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_enable_functional_watchdog(void)
{
    /* Enable functional watchdog */
	uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0038);              /* Read WD1_RS_CFG0 */
    /* only when functional watchdog is disabled we enable it */
    if (!(readValue & 0x4))
    {
    	readValue |= 0x4;                                       /* enable functional watchdog */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x37, (uint16)readValue);    /* Write new value into WD1_PW_CFG0 */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_disable_err0_pin_monitor(void)
{
    /* Disable Error 0 pin monitor */
	uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0020);              /* Read ERR0_RS_CFG */
    /* only when ERR pin monitor is requested we disable it */
    if (readValue & 0x8)
    {
    	readValue &= ~0x8;                                      /* disable ERR0 pin monitor */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x1F, (uint16)readValue);    /* Write new value into ERR0_PW_CFG */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_enable_err0_pin_monitor(void)
{
    /* Enable Error 0 pin monitor */
    uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0020);              /* Read ERR0_RS_CFG */
    /* only when ERR0 pin monitor is not requested we enable it */
    if (!(readValue & 0x8))
    {
        readValue |= 0x8;                                       /* enable ERR0 pin monitor */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x1F, (uint16)readValue);    /* Write new value into ERR0_PW_CFG */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_disable_err1_pin_monitor(void)
{
    /* Disable Error 1 pin monitor */
	uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0022);              /* Read ERR1_RS_CFG */
    /* only when ERR1 pin monitor is requested we disable it */
    if (readValue & 0x8)
    {
    	readValue &= ~0x8;                                    /* disable ERR1 pin monitor */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x21, (uint16)readValue);    /* Write new value into ERR1_PW_CFG */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_enable_err1_pin_monitor(void)
{
    /* Enable Error 1 pin monitor */
    uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0022);              /* Read ERR1_RS_CFG */
    /* only when ERR1 pin monitor is not requested we enable it */
    if (!(readValue & 0x8))
    {
        readValue |= 0x8;                                       /* enable ERR1 pin monitor */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x21, (uint16)readValue);    /* Write new value into ERR1_PW_CFG */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_disable_err2_pin_monitor(void)
{
    /* Disable Error 2 pin monitor */
	uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0024);              /* Read ERR2_RS_CFG */
    /* only when ERR1 pin monitor is requested we disable it */
    if (readValue & 0x8)
    {
    	readValue &= ~0x8;                                      /* disable ERR2 pin monitor */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x23, (uint16)readValue);    /* Write new value into ERR2_PW_CFG */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_enable_err2_pin_monitor(void)
{
    /* Enable Error 2 pin monitor */
    uint32 readValue;
    /* first read the value */
    readValue = IfxTLF4D985_read_register(0x0024);              /* Read ERR2_RS_CFG */
    /* only when ERR2 pin monitor is not requested we enable it */
    if (!(readValue & 0x8))
    {
        readValue |= 0x8;                                       /* enable ERR2 pin monitor */
        IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value*/
        IfxTLF4D985_write_register(0x23, (uint16)readValue);    /* Write new value into ERR2_PW_CFG */
        IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
    }
}

void IfxTLF4D985_goto_standby_sleep_state(void)
{
    uint32 readValue;
    /* A11 step is not able to wake up from standby by ENA or WAKE, therefore we use the sleep mode instead of standby */
	/* check for device step */
    readValue = IfxTLF4D985_read_register(0x01F1);              /* Read CHREV */
    /* Goto standby state */
    IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value */
    if ((readValue & 0xF) == 0x1)
    	/* this is an A11 step we go to sleep instead of standby */
        IfxTLF4D985_write_register(0x36, 0x0003);               /* Write DEV_PW_CFG3 : 0000 0000 0000 0011b (0x0003) to move to SLEEP and disable all voltages */
    else
    	/* this is not an A11 step, go to standby should be usable */
        IfxTLF4D985_write_register(0x36, 0x0004);               /* Write DEV_PW_CFG3 : 0000 0000 0000 0100b (0x0004) to move to STANDBY and disable all voltages */
    IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
}

void IfxTLF4D985_goto_normal_state(void)
{
    /* Goto Normal state */
    IfxTLF4D985_read_write(IFX_PMIC_DISABLE_PROTECTION);    /* Write PROTCFG : Unlock value */
    IfxTLF4D985_write_register(0x36, 0x03FA);               /* Write DEV_PW_CFG3 : 0000 0011 1111 1010b (0x01FA) to move to NORMAL and enable QVR, QCO, QUC, BuckCore, BuckIF, Boost and VM1 (VM2 not used) */
    IfxTLF4D985_read_write(IFX_PMIC_ENABLE_PROTECTION);     /* Write PROTCFG : lock value */
}

uint32 IfxTLF4D985_read_write(uint32 send_data)
{
    g_Qspi_TLF_Cpu.qspiBuffer.spiTxBuffer[0] = send_data;

    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLF_Cpu.drivers.spiMasterChannel) == IfxQspi_Status_busy)  {};

    IfxQspi_SpiMaster_exchange(&g_Qspi_TLF_Cpu.drivers.spiMasterChannel, &g_Qspi_TLF_Cpu.qspiBuffer.spiTxBuffer[0],
        &g_Qspi_TLF_Cpu.qspiBuffer.spiRxBuffer[0], TLF_BUFFER_SIZE);

    /* we wait until our values are read from Qspi */
    while (IfxQspi_SpiMaster_getStatus(&g_Qspi_TLF_Cpu.drivers.spiMasterChannel) == IfxQspi_Status_busy)  {};

    return (g_Qspi_TLF_Cpu.qspiBuffer.spiRxBuffer[0]);

}

uint32 IfxTLF4D985_read_register(uint16 regAddr)
{
    uint32 sendValue;
    uint8  ucCrc, ucSendArray[4];

    /* Address field: The value of the address field must be FFH, which defines a read service */
    /* Data field: The data field contains the address of the register which shall be read */
    ucSendArray[0] = regAddr & 0xFF;
    ucSendArray[1] = (regAddr>>8) & 0xFF;
    ucSendArray[2] = 0xFF;
    ucSendArray[3] = 0x00;

    /* we calculate the CRC */
    ucCrc = (uint8) Ifx__calculateCrcN(&ucSendArray[0], 0x00FF, 3, 0x001D7007);

    sendValue = ~ucCrc<<24;
    sendValue |= ucSendArray[2]<<16;
    sendValue |= ucSendArray[1]<<8;
    sendValue |= ucSendArray[0];

    IfxTLF4D985_read_write(sendValue);  /* read register from address */
    return IfxTLF4D985_read_write(0x35FF0000U);  /* send dummy frame to get content of register */
}

void IfxTLF4D985_write_register(uint8 regAddr, uint16 regValue)
{
    uint32 sendValue;
    uint8  ucCrc, ucSendArray[4];

    /* Data field: The data field contains the value of the register which shall be written */
    ucSendArray[0] = regValue & 0xFF;
    ucSendArray[1] = (regValue>>8) & 0xFF;
    ucSendArray[2] = regAddr & 0xFF;
    ucSendArray[3] = 0x00;

    /* we calculate the CRC */
    ucCrc = (uint8) Ifx__calculateCrcN(&ucSendArray[0], 0x00FF, 3, 0x001D7007);

    sendValue = ~ucCrc<<24;
    sendValue |= ucSendArray[2]<<16;
    sendValue |= ucSendArray[1]<<8;
    sendValue |= ucSendArray[0];

    IfxTLF4D985_read_write(sendValue);  /* write value to register */
}

#if defined(__HIGHTEC__)
#if defined(__clang__)
#pragma clang section text="" bss="" data="" rodata=""
#else
#pragma section /* end text section */
#endif
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#pragma section CONST
#endif
#if defined(__ghs__)
#pragma ghs callmode=default
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#pragma ghs section rodata=default
#endif
