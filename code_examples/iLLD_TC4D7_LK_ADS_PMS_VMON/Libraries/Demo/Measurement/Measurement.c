/**
 * \file Measurement.c
 * \brief Source file for periodically temperature and voltage measurement, Lifehold LED
 *
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:


 * Boost Software License - Version 1.0 - August 17th, 2003

 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:

 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.

 *
 */

#include "Software_Config.h"
#if  (defined(__ghs__) && ((CPU_WHICH_SERVICE_MEASUREMENT == 4) || (CPU_WHICH_SERVICE_MEASUREMENT == 5)))
#pragma ghs callmode=far
#endif
#include "Pin_Config.h"
#include "IfxPort_PinMap.h"
#include "IfxPmsPm.h"
#include "IfxEgtm_Tom_Timer.h"
#include "Measurement.h"

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/
#if CPU_WHICH_SERVICE_MEASUREMENT == 0
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu0" bss=".bss_cpu0" data=".data_cpu0" rodata=".rodata_cpu0"
    #else
    #pragma section ".text_cpu0" ax
    #pragma section ".bss_cpu0" awc0
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu0"
    #pragma section farbss  "bss_cpu0"
    #pragma section fardata "data_cpu0"
    #pragma section farrom  "rodata_cpu0"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu0"
    #pragma section DATA ".data_cpu0" ".bss_cpu0" far-absolute RW
    #pragma section CONST ".rodata_cpu0"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu0"
    #pragma ghs section bss= ".bss_cpu0"
    #pragma ghs section data=".data_cpu0"
    #pragma ghs section rodata=".rodata_cpu0"
    #endif
#elif ((CPU_WHICH_SERVICE_MEASUREMENT == 1) && (CPU_WHICH_SERVICE_MEASUREMENT < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu1" bss=".bss_cpu1" data=".data_cpu1" rodata=".rodata_cpu1"
    #else
    #pragma section ".text_cpu1" ax
    #pragma section ".bss_cpu1" awc1
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu1"
    #pragma section farbss  "bss_cpu1"
    #pragma section fardata "data_cpu1"
    #pragma section farrom  "rodata_cpu1"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu1"
    #pragma section DATA ".data_cpu1" ".bss_cpu1" far-absolute RW
    #pragma section CONST ".rodata_cpu1"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu1"
    #pragma ghs section bss= ".bss_cpu1"
    #pragma ghs section data=".data_cpu1"
    #pragma ghs section rodata=".rodata_cpu1"
    #endif
#elif ((CPU_WHICH_SERVICE_MEASUREMENT == 2) && (CPU_WHICH_SERVICE_MEASUREMENT < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu2" bss=".bss_cpu2" data=".data_cpu2" rodata=".rodata_cpu2"
    #else
    #pragma section ".text_cpu2" ax
    #pragma section ".bss_cpu2" awc2
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu2"
    #pragma section farbss  "bss_cpu2"
    #pragma section fardata "data_cpu2"
    #pragma section farrom  "rodata_cpu2"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu2"
    #pragma section DATA ".data_cpu2" ".bss_cpu2" far-absolute RW
    #pragma section CONST ".rodata_cpu2"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu2"
    #pragma ghs section bss= ".bss_cpu2"
    #pragma ghs section data=".data_cpu2"
    #pragma ghs section rodata=".rodata_cpu2"
    #endif
#elif ((CPU_WHICH_SERVICE_MEASUREMENT == 3) && (CPU_WHICH_SERVICE_MEASUREMENT < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu3" bss=".bss_cpu3" data=".data_cpu3" rodata=".rodata_cpu3"
    #else
    #pragma section ".text_cpu3" ax
    #pragma section ".bss_cpu3" awc3
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu3"
    #pragma section farbss  "bss_cpu3"
    #pragma section fardata "data_cpu3"
    #pragma section farrom  "rodata_cpu3"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu3"
    #pragma section DATA ".data_cpu3" ".bss_cpu3" far-absolute RW
    #pragma section CONST ".rodata_cpu3"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu3"
    #pragma ghs section bss= ".bss_cpu3"
    #pragma ghs section data=".data_cpu3"
    #pragma ghs section rodata=".rodata_cpu3"
    #endif
#elif ((CPU_WHICH_SERVICE_MEASUREMENT == 4) && (CPU_WHICH_SERVICE_MEASUREMENT < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu4" bss=".bss_cpu4" data=".data_cpu4" rodata=".rodata_cpu4"
    #else
    #pragma section ".text_cpu4" ax
    #pragma section ".bss_cpu4" awc4
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu4"
    #pragma section farbss  "bss_cpu4"
    #pragma section fardata "data_cpu4"
    #pragma section farrom  "rodata_cpu4"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu4"
    #pragma section DATA ".data_cpu4" ".bss_cpu4" far-absolute RW
    #pragma section CONST ".rodata_cpu4"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu4"
    #pragma ghs section bss= ".bss_cpu4"
    #pragma ghs section data=".data_cpu4"
    #pragma ghs section rodata=".rodata_cpu4"
    #endif
#elif ((CPU_WHICH_SERVICE_MEASUREMENT == 5) && (CPU_WHICH_SERVICE_MEASUREMENT < IFXCPU_NUM_MODULES))
    #if defined(__HIGHTEC__)
    #if defined(__clang__)
    #pragma clang section text=".text_cpu5" bss=".bss_cpu5" data=".data_cpu5" rodata=".rodata_cpu5"
    #else
    #pragma section ".text_cpu5" ax
    #pragma section ".bss_cpu5" awc5
    #endif
    #endif
    #if defined(__TASKING__)
    #pragma section code    "text_cpu5"
    #pragma section farbss  "bss_cpu5"
    #pragma section fardata "data_cpu5"
    #pragma section farrom  "rodata_cpu5"
    #endif
    #if defined(__DCC__)
    #pragma section CODE ".text_cpu5"
    #pragma section DATA ".data_cpu5" ".bss_cpu5" far-absolute RW
    #pragma section CONST ".rodata_cpu5"
    #endif
    #if defined(__ghs__)
    #pragma ghs section text=".text_cpu5"
    #pragma ghs section bss= ".bss_cpu5"
    #pragma ghs section data=".data_cpu5"
    #pragma ghs section rodata=".rodata_cpu5"
    #endif
#else
#error "Set CPU_WHICH_SERVICE_MEASUREMENT to a valid value!"
#endif

uint8 toggle_counter;

float32 core_voltage;
float32 core_volt_min;
float32 core_volt_max;

float32 Vddext;
float32 Vddext_min;
float32 Vddext_max;

float32 Vddevrsb;
float32 Vddevrsb_min;
float32 Vddevrsb_max;

float32 Vddm;
float32 Vddm_min;
float32 Vddm_max;

float32 Vddphphy0;
float32 Vddphphy0_min;
float32 Vddphphy0_max;

float32 Vddphy0;
float32 Vddphy0_min;
float32 Vddphy0_max;

float32 Vddphphy1;
float32 Vddphphy1_min;
float32 Vddphphy1_max;

float32 Vddphy1;
float32 Vddphy1_min;
float32 Vddphy1_max;

float32 Vddhsif;
float32 Vddhsif_min;
float32 Vddhsif_max;

float32 die_temp;
float32 die_highest;
float32 die_lowest;

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/

#if defined(__HIGHTEC__) && !defined(__clang__)
#pragma section /* end bss section, now text section selected */
#endif
/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/
/**********************************************************************************/
void measurement_init(void)
{
    /* set the start values */
    toggle_counter = 0u;
    core_volt_min = 2.0f;
    core_volt_max = 0.0f;
    Vddext_min = 6.0f;
    Vddext_max = 0.0f;
    Vddevrsb_min = 6.0f;
    Vddevrsb_max = 0.0f;
    Vddm_min = 6.0f;
    Vddm_max = 0.0f;
    Vddphphy0_min = 2.5f;
    Vddphphy0_max = 0.0f;
    Vddphy0_min = 1.5f;
    Vddphy0_max = 0.0f;
    Vddphphy1_min = 2.5f;
    Vddphphy1_max = 0.0f;
    Vddphy1_min = 1.5f;
    Vddphy1_max = 0.0f;
    Vddhsif_min = 2.5f;
    Vddhsif_max = 0.0f;
    die_highest = -60.0f;
    die_lowest = 196.0f;
    /* Set the configuration */
    IfxPmsPm_DtsConfig dtsConfig;
    dtsConfig.adcConversion = IfxPmsPm_DtsAdcConversion_start;
    dtsConfig.dtsenable = IfxPmsPm_Dts_enable;
    dtsConfig.lower = NULL_PTR;
    dtsConfig.peakTemp = IfxPmsPm_DtsPeakTemp_reset;
    dtsConfig.tsd = NULL_PTR;
    dtsConfig.upper = NULL_PTR;
    dtsConfig.warning = IfxPmsPm_DtsWarning_disable;
    /* Module initialization  */
    IfxPmsPm_configureDts(&MODULE_PMS, &dtsConfig);
    /* switch on VDDPHPHY0, VDDPHY0, VDDPHPHY1, VDDPHY1, VDDPHPHY2, VDDPHY2 and VDDHSIF measurement  */
    IfxPmsEvr_enableVoltageRail(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0);
    IfxPmsEvr_enableVoltageRail(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0);
    IfxPmsEvr_enableVoltageRail(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1);
    IfxPmsEvr_enableVoltageRail(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1);
    IfxPmsEvr_enableVoltageRail(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif);

    /* first general init of EGTM */
    IfxEgtm_enable(&MODULE_EGTM);
    /* we set the global clock to 100MHz */
    IfxEgtm_Cmu_setGclkFrequency(&MODULE_EGTM, 100000000.0f);
    /* enable FX clock */
    IfxEgtm_Cmu_enableClocks(&MODULE_EGTM, IFXEGTM_CMU_CLKEN_FXCLK);

    /* EGTM is available, we use the EGTM */
    IfxEgtm_Tom_Timer driverMeasurementMeasure;
    IfxEgtm_Tom_Timer_Config driverConfig;

    IfxEgtm_Tom_Timer_initConfig(&driverConfig, &MODULE_EGTM);
    driverConfig.cluster = (IfxEgtm_Cluster)MEASUREMENT_MEASURE.tom;
    driverConfig.timerChannel = MEASUREMENT_MEASURE.channel;
    driverConfig.interrupt.irqMode   = IfxEgtm_IrqMode_pulse;
    driverConfig.clock = IfxEgtm_Tom_Ch_ClkSrc_cmuFxclk2; /* used clock is 100MHz/256 */
    driverConfig.frequency = 1/(0.001f*REFRESH_MEASUREMENT); /* we have 20Hz (50ms default) */
    driverConfig.minResolution = 0;
    driverConfig.interrupt.isrPriority = ISR_PRIORITY_MEASUREMENT;
    driverConfig.interrupt.isrProvider = (IfxSrc_Tos)CPU_WHICH_SERVICE_MEASUREMENT;
    IfxEgtm_Tom_Timer_init (&driverMeasurementMeasure, &driverConfig);
    IfxEgtm_Tom_Timer_run(&driverMeasurementMeasure);

    IfxPort_setPinModeOutput(LIFEHOLD_LED.port, LIFEHOLD_LED.pinIndex, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
}

IFX_INTERRUPT(ISR_measurement_call, CPU_WHICH_SERVICE_MEASUREMENT, ISR_PRIORITY_MEASUREMENT)
{
    uint16    voltage;
    if(toggle_counter == 1000u/REFRESH_MEASUREMENT)
    {
        IfxPort_togglePin(LIFEHOLD_LED.port, LIFEHOLD_LED.pinIndex); /* Toggle LED  */

        toggle_counter = 0u;
    }
    toggle_counter++;

    /* we get the voltage result */
    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vdd);
    core_voltage = (float)voltage*0.00283f;
    if(core_voltage > core_volt_max)
        core_volt_max = core_voltage;
    if(core_voltage < core_volt_min)
        core_volt_min = core_voltage;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddext);
    Vddext = (float)voltage*0.01132f;
    if(Vddext > Vddext_max)
        Vddext_max = Vddext;
    if(Vddext < Vddext_min)
        Vddext_min = Vddext;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddevrsb);
    Vddevrsb = (float)voltage*0.00283f;
    if(Vddevrsb > Vddevrsb_max)
        Vddevrsb_max = Vddevrsb;
    if(Vddevrsb < Vddevrsb_min)
        Vddevrsb_min = Vddevrsb;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddm);
    Vddm = (float)voltage*0.00283f;
    if(    Vddm > Vddm_max)
        Vddm_max = Vddm;
    if(    Vddm < Vddm_min)
        Vddm_min = Vddm;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy0);
    Vddphphy0 = (float)voltage*0.00283f;
    if(    Vddphphy0 > Vddphphy0_max)
        Vddphphy0_max =    Vddphphy0;
    if(    Vddphphy0 < Vddphphy0_min)
        Vddphphy0_min = Vddphphy0;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy0);
    Vddphy0 = (float)voltage*0.000577f;
    if(    Vddphy0 > Vddphy0_max)
        Vddphy0_max =    Vddphy0;
    if(    Vddphy0 < Vddphy0_min)
        Vddphy0_min = Vddphy0;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphphy1);
    Vddphphy1 = (float)voltage*0.00283f;
    if(    Vddphphy1 > Vddphphy1_max)
        Vddphphy1_max =    Vddphphy1;
    if(    Vddphphy1 < Vddphphy1_min)
        Vddphphy1_min = Vddphphy1;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddphy1);
    Vddphy1 = (float)voltage*0.000577f;
    if(    Vddphy1 > Vddphy1_max)
        Vddphy1_max =    Vddphy1;
    if(    Vddphy1 < Vddphy1_min)
        Vddphy1_min = Vddphy1;

    voltage = IfxPmsEvr_getPrimaryMonitorResult(&MODULE_PMS, IfxPmsEvr_PrimaryMonitorVoltageSource_vddhsif);
    Vddhsif = (float)voltage*0.00283f;
    if(    Vddhsif > Vddhsif_max)
        Vddhsif_max =    Vddhsif;
    if(    Vddhsif < Vddhsif_min)
        Vddhsif_min = Vddhsif;

    /* die temperature measurement */
    /* die_temp is in Kelvin, we change to �C */
    die_temp =  IfxPmsPm_getDtsTemperatureResultKv(&MODULE_PMS) - 273.15f;
    /*limit checking for highest */
    if(die_temp > die_highest)
        die_highest = die_temp;

    /* limit checking for lowest value, all values under -60 �C are not valid -> ignore first conversion for self-calibration */
    if((die_temp < die_lowest)||(die_lowest < -60.0f))
        die_lowest = die_temp;
}

#if defined(__HIGHTEC__)
#if defined(__clang__)
#pragma clang section text="" bss="" data="" rodata=""
#else
#pragma section /* end text section */
#endif
#endif
#if defined(__TASKING__)
#pragma section code restore
#pragma section fardata restore
#pragma section farbss restore
#pragma section farrom restore
#endif
#if defined(__DCC__)
#pragma section CODE
#pragma section DATA RW
#pragma section CONST
#endif
#if defined(__ghs__)
#pragma ghs callmode=default
#pragma ghs section text=default
#pragma ghs section data=default
#pragma ghs section bss=default
#pragma ghs section rodata=default
#endif
