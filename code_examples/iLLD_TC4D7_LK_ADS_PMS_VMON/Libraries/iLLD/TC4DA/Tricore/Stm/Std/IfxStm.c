/**
 * \file IfxStm.c
 * \brief STM  basic functionality
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxStm.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxStm_clearCompareFlag(Ifx_CPU *cpu, IfxStm_Comparator comparator)
{
#if (IFX_CFG_STM_MORPHING_ENABLE)
    Ifx_CPU_STM_ISCR *iscr = (Ifx_CPU_STM_ISCR *)((uint32)cpu + (uint32)(IFXSTM_ISCR_OFFSET));
#else
    uint32            vmId = (uint32)IfxCpu_getVirtualMachine();
    Ifx_CPU_STM_ISCR *iscr = (Ifx_CPU_STM_ISCR *)(&cpu->STMHV.VM[vmId].ISCR);
#endif

    if (comparator == IfxStm_Comparator_0)
    {
        iscr->B.CMP0IRR = 1U;
    }
    else if (comparator == IfxStm_Comparator_1)
    {
        iscr->B.CMP1IRR = 1U;
    }
}


void IfxStm_disableComparatorInterrupt(Ifx_CPU *cpu, IfxStm_Comparator comparator)
{
#if (IFX_CFG_STM_MORPHING_ENABLE)
    Ifx_CPU_STM_ICR *icr  = (Ifx_CPU_STM_ICR *)((uint32)cpu + (uint32)(IFXSTM_ICR_OFFSET));
#else
    uint32           vmId = (uint32)IfxCpu_getVirtualMachine();
    Ifx_CPU_STM_ICR *icr  = (Ifx_CPU_STM_ICR *)(&cpu->STMHV.VM[vmId].STM_ICR);
#endif

    if (comparator == IfxStm_Comparator_0)
    {
        icr->B.CMP0EN = 0U;
    }
    else // if (comparator == IfxStm_Comparator_1)
    {
        icr->B.CMP1EN = 0U;
    }
}


void IfxStm_disableModule(Ifx_CPU *cpu)
{
    /* TODO  : Update with PROT */
    cpu->STM.CLC.B.DISR = 1;
}


void IfxStm_enableComparatorInterrupt(Ifx_CPU *cpu, IfxStm_Comparator comparator)
{
#if (IFX_CFG_STM_MORPHING_ENABLE)
    Ifx_CPU_STM_ICR *icr  = (Ifx_CPU_STM_ICR *)((uint32)cpu + (uint32)(IFXSTM_ICR_OFFSET));
#else
    uint32           vmId = (uint32)IfxCpu_getVirtualMachine();
    Ifx_CPU_STM_ICR *icr  = (Ifx_CPU_STM_ICR *)(&cpu->STMHV.VM[vmId].STM_ICR);
#endif

    if (comparator == IfxStm_Comparator_0)
    {
        icr->B.CMP0EN = 1U;
    }
    else if (comparator == IfxStm_Comparator_1)
    {
        icr->B.CMP1EN = 1U;
    }
}


void IfxStm_enableOcdsSuspend(Ifx_CPU *cpu)
{
    Ifx_CPU_STM_OCS *stmOcs = (Ifx_CPU_STM_OCS *)((uint32)cpu + (uint32)(IFXSTM_OCS_OFFSET));
    /* TODO  : Update with PROT */
    Ifx_CPU_STM_OCS  ocs;
    ocs.U           = stmOcs->U;

    ocs.B.SUS_P     = 1;
    ocs.B.SUS       = 2;
    stmOcs->U       = ocs.U;
    stmOcs->B.SUS_P = 0;
}


Ifx_CPU *IfxStm_getAddress(IfxStm_Index stm)
{
    Ifx_CPU *module;

    if (stm == IfxStm_Index_6)
    {
        module = &MODULE_CPUCS;
    }
    else if (stm < IFXSTM_NUM_MODULES)
    {
        module = (Ifx_CPU *)IfxStm_cfg_indexMap[stm].module;
    }
    else
    {
        module = NULL_PTR;
    }

    return module;
}


IfxStm_Index IfxStm_getIndex(Ifx_CPU *cpu)
{
    uint32       index;
    IfxStm_Index result;

    result = IfxStm_Index_none;

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
    {
        if (IfxStm_cfg_indexMap[index].module == cpu)
        {
            result = (IfxStm_Index)IfxStm_cfg_indexMap[index].index;
            break;
        }
    }

    return result;
}


volatile Ifx_SRC_SRCR *IfxStm_getSrcPointer(IfxStm_Index index, IfxStm_ComparatorInterrupt comparator)
{
    IfxCpu_vmId vmId = IfxCpu_getVirtualMachine();

    switch (vmId)
    {
    case IfxCpu_vmId_0:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[0] : &MODULE_SRC.STMCPU[index].SR[1];
    }
    case IfxCpu_vmId_1:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[2] : &MODULE_SRC.STMCPU[index].SR[3];
    }
    case IfxCpu_vmId_2:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[4] : &MODULE_SRC.STMCPU[index].SR[5];
    }
    case IfxCpu_vmId_3:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[6] : &MODULE_SRC.STMCPU[index].SR[7];
    }
    case IfxCpu_vmId_4:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[8] : &MODULE_SRC.STMCPU[index].SR[9];
    }
    case IfxCpu_vmId_5:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[10] : &MODULE_SRC.STMCPU[index].SR[11];
    }
    case IfxCpu_vmId_6:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[12] : &MODULE_SRC.STMCPU[index].SR[13];
    }
    case IfxCpu_vmId_7:
    {
        return comparator == IfxStm_ComparatorInterrupt_ir0 ? &MODULE_SRC.STMCPU[index].SR[14] : &MODULE_SRC.STMCPU[index].SR[15];
    }
    default:
        return NULL_PTR;
    }
}


boolean IfxStm_initCompare(Ifx_CPU *cpu, const IfxStm_CompareConfig *config)
{
    sint32             index;
    boolean            result;
    Ifx_CPU_STM_CMCON  comconTemp;
    Ifx_CPU_STM_ICR    icrTemp;
#if (IFX_CFG_STM_MORPHING_ENABLE)
    Ifx_CPU_STM_CMCON *comcon = (Ifx_CPU_STM_CMCON *)((uint32)cpu + (uint32)(IFXSTM_CMCON_OFFSET));
    Ifx_CPU_STM_ICR   *icr    = (Ifx_CPU_STM_ICR *)((uint32)cpu + (uint32)(IFXSTM_ICR_OFFSET));
    Ifx_CPU_STM_CMP   *cmp0   = (Ifx_CPU_STM_CMP *)((uint32)cpu + (uint32)(IFXSTM_CMP0_OFFSET));
    Ifx_CPU_STM_CMP   *cmp1   = (Ifx_CPU_STM_CMP *)((uint32)cpu + (uint32)(IFXSTM_CMP1_OFFSET));
#else
    uint32             vmId   = (uint32)IfxCpu_getVirtualMachine();
    Ifx_CPU_STM_CMCON *comcon = (Ifx_CPU_STM_CMCON *)(&cpu->STMHV.VM[vmId].CMCON);
    Ifx_CPU_STM_ICR   *icr    = (Ifx_CPU_STM_ICR *)(&cpu->STMHV.VM[vmId].STM_ICR);
    Ifx_CPU_STM_CMP   *cmp0   = (Ifx_CPU_STM_CMP *)(&cpu->STMHV.VM[vmId].CMP[0]);
    Ifx_CPU_STM_CMP   *cmp1   = (Ifx_CPU_STM_CMP *)(&cpu->STMHV.VM[vmId].CMP[1]);
#endif

    comconTemp.U = comcon->U;
    icrTemp.U    = icr->U;

    if (config->comparator == IfxStm_Comparator_0)
    {
        comconTemp.B.MSIZE0   = config->compareSize;
        comconTemp.B.MSTART0  = config->compareOffset;
        comconTemp.B.RELCOMP0 = config->comparison;
        icrTemp.B.CMP0OS      = config->comparatorInterrupt;
        result                = TRUE;
    }
    else if (config->comparator == IfxStm_Comparator_1)
    {
        comconTemp.B.MSIZE1   = config->compareSize;
        comconTemp.B.MSTART1  = config->compareOffset;
        comconTemp.B.RELCOMP1 = config->comparison;
        icrTemp.B.CMP1OS      = config->comparatorInterrupt;
        result                = TRUE;
    }
    else
    {
        /*Invalid value */
        result = FALSE;
    }

    icr->U    = icrTemp.U;
    comcon->U = comconTemp.U;

    /* configure interrupt */
    index = IfxCpu_getCoreId();

    if (config->triggerPriority > 0)
    {
        volatile Ifx_SRC_SRCR *srcr = IfxStm_getSrcPointer((IfxStm_Index)index, config->comparatorInterrupt);

        IfxSrc_init(srcr, config->typeOfService, config->triggerPriority, config->vmId);
        IfxSrc_enable(srcr);
    }

    /*Configure the comparator ticks to current value to avoid any wrong triggering*/
    if (config->comparator == IfxStm_Comparator_0)
    {
        cmp0->U = (uint32)IfxStm_getOffsetTimer(cpu, (uint8)config->compareOffset);
    }
    else if (config->comparator == IfxStm_Comparator_1)
    {
        cmp1->U = (uint32)IfxStm_getOffsetTimer(cpu, (uint8)config->compareOffset);
    }
    else
    {
        /*Invalid value */
        result = FALSE;
    }

    /* clear the interrupt flag of the selected comparator before enabling the interrupt */
    /* this is to avaoid the unneccesary interrupt for the compare match of reset values of the registers */
    IfxStm_clearCompareFlag(cpu, config->comparator);
    /* enable the interrupt for the selected comparator */
    IfxStm_enableComparatorInterrupt(cpu, config->comparator);

    /*Configure the comparator ticks */
    if (config->comparator == IfxStm_Comparator_0)
    {
        cmp0->U = (uint32)IfxStm_getOffsetTimer(cpu, (uint8)config->compareOffset) + config->ticks;
    }
    else if (config->comparator == IfxStm_Comparator_1)
    {
        cmp1->U = (uint32)IfxStm_getOffsetTimer(cpu, (uint8)config->compareOffset) + config->ticks;
    }
    else
    {
        /*Invalid value */
        result = FALSE;
    }

    return result;
}


void IfxStm_initCompareConfig(IfxStm_CompareConfig *config)
{
    config->comparator          = IfxStm_Comparator_0;
    config->compareOffset       = IfxStm_ComparatorOffset_0;
    config->compareSize         = IfxStm_ComparatorSize_32Bits;
    config->comparison          = IfxStm_ComparatorComparison_absolute;
    config->comparatorInterrupt = IfxStm_ComparatorInterrupt_ir0;     /*User must select the interrupt output */
    config->ticks               = 0xFFFFFFFF;
    config->triggerPriority     = 0;
    config->typeOfService       = IfxSrc_Tos_cpu0;
    config->vmId                = IfxSrc_VmId_0;
}


boolean IfxStm_isCompareFlagSet(Ifx_CPU *cpu, IfxStm_Comparator comparator)
{
#if (IFX_CFG_STM_MORPHING_ENABLE)
    Ifx_CPU_STM_ISR *isr  = (Ifx_CPU_STM_ISR *)((uint32)cpu + (uint32)(IFXSTM_ISR_OFFSET));
#else
    uint32           vmId = (uint32)IfxCpu_getVirtualMachine();
    Ifx_CPU_STM_ISR *isr  = (Ifx_CPU_STM_ISR *)(&cpu->STMHV.VM[vmId].ISR);
#endif

    if (comparator == IfxStm_Comparator_0)
    {
        return isr->B.CMP0IR;
    }
    else // if (comparator == IfxStm_Comparator_1)
    {
        return isr->B.CMP1IR;
    }
}


void IfxStm_setCompareControl(Ifx_CPU *cpu, IfxStm_Comparator comparator, IfxStm_ComparatorOffset offset, IfxStm_ComparatorSize size, IfxStm_ComparatorInterrupt interrupt)
{
    Ifx_CPU_STM_CMCON  comconTemp;
    Ifx_CPU_STM_ICR    icrTemp;

#if (IFX_CFG_STM_MORPHING_ENABLE)
    Ifx_CPU_STM_CMCON *comcon = (Ifx_CPU_STM_CMCON *)((uint32)cpu + (uint32)(IFXSTM_CMCON_OFFSET));
    Ifx_CPU_STM_ICR   *icr    = (Ifx_CPU_STM_ICR *)((uint32)cpu + (uint32)(IFXSTM_ICR_OFFSET));
#else
    uint32             vmId   = (uint32)IfxCpu_getVirtualMachine();
    Ifx_CPU_STM_CMCON *comcon = (Ifx_CPU_STM_CMCON *)(&cpu->STMHV.VM[vmId].CMCON);
    Ifx_CPU_STM_ICR   *icr    = (Ifx_CPU_STM_ICR *)(&cpu->STMHV.VM[vmId].STM_ICR);
#endif

    comconTemp.U = comcon->U;
    icrTemp.U    = icr->U;

    if (comparator == 0)
    {
        comconTemp.B.MSIZE0  = size;
        comconTemp.B.MSTART0 = offset;
        icrTemp.B.CMP0OS     = interrupt;
    }
    else // if (comparator == 1)
    {
        comconTemp.B.MSIZE1  = size;
        comconTemp.B.MSTART1 = offset;
        icrTemp.B.CMP1OS     = interrupt;
    }

    comcon->U = comconTemp.U;
    icr->U    = icrTemp.U;
}


void IfxStm_configureAccessToStms(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    for (index = 0; index < IFXSTM_NUM_MODULES; index++)
    {
        Ifx_CPU *cpu = IfxCpu_cfg_indexMap[index].module;
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&cpu->ACCENSTMCFG, apConfig);
    }
}
