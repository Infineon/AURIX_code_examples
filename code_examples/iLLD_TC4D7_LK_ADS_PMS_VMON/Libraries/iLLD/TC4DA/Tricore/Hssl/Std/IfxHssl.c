/**
 * \file IfxHssl.c
 * \brief HSSL  basic functionality
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxHssl.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxHssl_disableHsctModule(Ifx_HSCT *hsct)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTE, IfxApProt_State_config);
#endif

    hsct->CLC.B.DISR = 1; /* disables the module */

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTE, IfxApProt_State_run);
#endif
}


void IfxHssl_disableHsslModule(Ifx_HSSL *hssl)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTE, IfxApProt_State_config);
#endif

    hssl->CLC.B.DISR = 1; /* disables the module */

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTE, IfxApProt_State_run);

#endif
}


void IfxHssl_enableHsctModule(Ifx_HSCT *hsct)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTE, IfxApProt_State_config);
#endif

    hsct->CLC.B.DISR = 0; /* enables the module */

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTE, IfxApProt_State_run);
#endif
}


void IfxHssl_enableHsslModule(Ifx_HSSL *hssl)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTE, IfxApProt_State_config);
#endif

    hssl->CLC.B.DISR = 0; /* enables the module */

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTE, IfxApProt_State_run);
#endif
}


Ifx_HSCT *IfxHssl_getHsctAddress(IfxHssl_hsctIndex hsct)
{
    Ifx_HSCT *module;

    if (hsct < IFXHSSL_NUM_MODULES)
    {
        module = (Ifx_HSCT *)IfxHssl_cfg_hsctIndexMap[hsct].module;
    }
    else
    {
        module = NULL_PTR;
    }

    return module;
}


IfxHssl_hsctIndex IfxHssl_getHsctIndex(Ifx_HSCT *hsct)
{
    uint32            index;
    IfxHssl_hsctIndex result;

    result = IfxHssl_hsctIndex_none;

    for (index = 0; index < IFXHSSL_NUM_MODULES; index++)
    {
        if (IfxHssl_cfg_hsctIndexMap[index].module == hsct)
        {
            result = (IfxHssl_hsctIndex)IfxHssl_cfg_hsctIndexMap[index].index;
            break;
        }
    }

    return result;
}


volatile Ifx_SRC_SRCR *IfxHssl_getHsctSrcPointer(Ifx_HSCT *hsct)
{
    if (hsct == &MODULE_HSCT0)
    {
        return &MODULE_SRC.HSCT[0].SR;
    }
    else
    {
        return &MODULE_SRC.HSCT[1].SR;
    }
}


Ifx_HSSL *IfxHssl_getHsslAddress(IfxHssl_hsslIndex hssl)
{
    Ifx_HSSL *module;

    if (hssl < IFXHSSL_NUM_MODULES)
    {
        module = (Ifx_HSSL *)IfxHssl_cfg_hsslIndexMap[hssl].module;
    }
    else
    {
        module = NULL_PTR;
    }

    return module;
}


volatile Ifx_SRC_SRCR *IfxHssl_getHsslCOKSrcPointer(Ifx_HSSL *hssl, IfxHssl_ChannelId channelId)
{
    if (hssl == &MODULE_HSSL0)
    {
        return &MODULE_SRC.HSSL[0].CH[(uint32)channelId].COK;
    }
    else
    {
        return &MODULE_SRC.HSSL[1].CH[(uint32)channelId].COK;
    }
}


volatile Ifx_SRC_SRCR *IfxHssl_getHsslERRSrcPointer(Ifx_HSSL *hssl, IfxHssl_ChannelId channelId)
{
    if (hssl == &MODULE_HSSL0)
    {
        return &MODULE_SRC.HSSL[0].CH[(uint32)channelId].ERR;
    }
    else
    {
        return &MODULE_SRC.HSSL[1].CH[(uint32)channelId].ERR;
    }
}


volatile Ifx_SRC_SRCR *IfxHssl_getHsslEXISrcPointer(Ifx_HSSL *hssl)
{
    if (hssl == &MODULE_HSSL0)
    {
        return &MODULE_SRC.HSSL[0].EXI;
    }
    else
    {
        return &MODULE_SRC.HSSL[1].EXI;
    }
}


IfxHssl_hsslIndex IfxHssl_getHsslIndex(Ifx_HSSL *hssl)
{
    uint32            index;
    IfxHssl_hsslIndex result;

    result = IfxHssl_hsslIndex_none;

    for (index = 0; index < IFXHSSL_NUM_MODULES; index++)
    {
        if (IfxHssl_cfg_hsslIndexMap[index].module == hssl)
        {
            result = (IfxHssl_hsslIndex)IfxHssl_cfg_hsslIndexMap[index].index;
            break;
        }
    }

    return result;
}


volatile Ifx_SRC_SRCR *IfxHssl_getHsslRDISrcPointer(Ifx_HSSL *hssl, IfxHssl_ChannelId channelId)
{
    if (hssl == &MODULE_HSSL0)
    {
        return &MODULE_SRC.HSSL[0].CH[(uint32)channelId].RDI;
    }
    else
    {
        return &MODULE_SRC.HSSL[1].CH[(uint32)channelId].RDI;
    }
}


volatile Ifx_SRC_SRCR *IfxHssl_getHsslTRGSrcPointer(Ifx_HSSL *hssl, IfxHssl_ChannelId channelId)
{
    if (hssl == &MODULE_HSSL0)
    {
        return &MODULE_SRC.HSSL[0].CH[(uint32)channelId].TRG;
    }
    else
    {
        return &MODULE_SRC.HSSL[1].CH[(uint32)channelId].TRG;
    }
}


void IfxHssl_resetHsctKernel(Ifx_HSCT *hsct)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTE, IfxApProt_State_config);
#endif
    hsct->RST.CTRLA.B.KRST = 1;        /* Only if both Kernel reset bits are set a reset is executed */
    hsct->RST.CTRLB.B.KRST = 1;

    while (hsct->RST.STAT.B.KRST == 0) /* Wait until reset is executed */

    {}

    hsct->RST.CTRLB.B.STATCLR = 1;       /* Clear Kernel reset status bit */

    while (hsct->RST.STAT.B.KRST == 1)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTE, IfxApProt_State_run);
#endif
}


void IfxHssl_resetHsslKernel(Ifx_HSSL *hssl)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTE, IfxApProt_State_config);
#endif

    hssl->RST.CTRLA.B.KRST = 1;         /* Only if both Kernel reset bits are set a reset is executed */
    hssl->RST.CTRLB.B.KRST = 1;

    while (hssl->RST.STAT.B.KRST == 0)  /* Wait until reset is executed */

    {}

    hssl->RST.CTRLB.B.STATCLR = 1;       /* Clear Kernel reset status bit */

    while (hssl->RST.STAT.B.KRST == 1)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTE, IfxApProt_State_run);
#endif
}


void IfxHssl_initHsslApConfig(IfxHssl_hsslApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);

    IfxApProt_initConfig(&config->protseConfig);

    IfxApApu_initConfig(&config->apuConfig);
}


void IfxHssl_initHsslAp(Ifx_HSSL *hssl, IfxHssl_hsslApConfig *config)
{
    /* Initialize the PROTs */

    IfxApProt_init((Ifx_PROT_PROT *)&hssl->PROTE, &config->proteConfig);

    IfxApProt_init((Ifx_PROT_PROT *)&hssl->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */

    /* Initialize the APU */

    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTSE, IfxApProt_State_config);

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&hssl->ACCEN, &config->apuConfig);

    IfxApProt_setState((Ifx_PROT_PROT *)&hssl->PROTSE, IfxApProt_State_run);
}


void IfxHssl_initHsctApConfig(IfxHssl_hsctApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);

    IfxApProt_initConfig(&config->protseConfig);

    IfxApApu_initConfig(&config->apuConfig);
}


void IfxHssl_initHsctAp(Ifx_HSCT *hsct, IfxHssl_hsctApConfig *config)
{
    /* Initialize the PROTs */

    IfxApProt_init((Ifx_PROT_PROT *)&hsct->PROTE, &config->proteConfig);

    IfxApProt_init((Ifx_PROT_PROT *)&hsct->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */

    /* Initialize the APU */

    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTSE, IfxApProt_State_config);

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&hsct->ACCEN, &config->apuConfig);

    IfxApProt_setState((Ifx_PROT_PROT *)&hsct->PROTSE, IfxApProt_State_run);
}


void IfxHssl_configureAccessToHssls(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    for (index = 0; index < IFXHSSL_NUM_MODULES; index++)
    {
        /* Loop through all the instance */
        Ifx_HSSL *hssl = (Ifx_HSSL *)(((uint32)&MODULE_HSSL0) + index * ((uint32)&MODULE_HSSL1 - (uint32)&MODULE_HSSL0));

        IfxApApu_init((Ifx_ACCEN_ACCEN *)&hssl->ACCEN, apConfig);
    }
}


void IfxHssl_configureAccessToHscts(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    for (index = 0; index < IFXHSSL_NUM_MODULES; index++)
    {
        /* Loop through all the instance */
        Ifx_HSCT *hsct = (Ifx_HSCT *)(((uint32)&MODULE_HSCT0) + index * ((uint32)&MODULE_HSCT1 - (uint32)&MODULE_HSCT0));

        IfxApApu_init((Ifx_ACCEN_ACCEN *)&hsct->ACCEN, apConfig);
    }
}


IfxHssl_BaudrateStatus IfxHssl_getBaudrate(Ifx_HSCT *hsctSFR, IfxHssl_BaudrateAndFrequencies *configStatus)
{
    uint8 txDiv, rxDiv, fSysOutDiv;

    /*Gather pre-requisite values for High speed and SysClkOut*/
    switch (hsctSFR->INIT.B.TXHD)
    {
    case 0:
    {
        txDiv = 1;
        break;
    }
    case 1:
    {
        txDiv = 2;
        break;
    }
    case 2:
    {
        txDiv = 4;
        break;
    }
    case 3:
    {
        txDiv = 8;
        break;
    }
    case 4:
    {
        txDiv = 16;
        break;
    }
    default:
    {
        return IfxHssl_BaudrateStatus_errorTxhd;
    }
    }

    switch (hsctSFR->INIT.B.RXHD)
    {
    case 0:
    {
        rxDiv = 1;
        break;
    }
    case 1:
    {
        rxDiv = 2;
        break;
    }
    case 2:
    {
        rxDiv = 4;
        break;
    }
    case 3:
    {
        rxDiv = 8;
        break;
    }
    case 4:
    {
        rxDiv = 16;
        break;
    }
    default:
    {
        return IfxHssl_BaudrateStatus_errorRxhd;
    }
    }

    switch (hsctSFR->INIT.B.SSCF)
    {
    case 0:
    {
        fSysOutDiv = 1;
        break;
    }
    case 1:
    {
        fSysOutDiv = 2;
        break;
    }
    case 2:
    {
        fSysOutDiv = 4;
        break;
    }
    default:
    {
        return IfxHssl_BaudrateStatus_errorSscf;
    }
    }

    /*Get oscillator frequency from CLOCK*/
    uint32 fSource = IfxClock_getOscFrequency(); //To do Test: Return values to be investigated in unit testing
    configStatus->sourceFrequency = fSource;

    /*Check validity of clock frequency for HSSL*/
    if (!((fSource == 10000000) || (fSource == 20000000) || (fSource == 25000000) || (fSource == 40000000) || (fSource == 50000000)))
    {
        return IfxHssl_BaudrateStatus_unSupportedSourceFrequency;
    }

    /*Get PHY Clock */

    /*Calculate fHSCT from peripheral PLL*/
    /*To do Test: Check values of fHSCT*/
    uint32 fHSCT = fSource * (CLOCK_PERPLLCON0.B.NDIV + 1) / (CLOCK_PERPLLCON0.B.PDIV + 1); /*Assumption: fSource, PDIV and NDIV are valid for HSSL. Expectation is 800M*/

    if ((hsctSFR->IFCTRL.B.MTXSPEED == IfxHssl_MasterModeTxSpeed_highSpeed) || (hsctSFR->IFCTRL.B.MRXSPEED == IfxHssl_MasterModeRxSpeed_highSpeed))
    {
        if (fHSCT != 800000000)
        {
            return IfxHssl_BaudrateStatus_unSupportedPll;
        }
    }

    switch (hsctSFR->IFCTRL.B.MTXSPEED)
    {
    case IfxHssl_MasterModeTxSpeed_lowSpeed:
    {
        if ((fSource == 10000000) || (fSource == 20000000) || (fSource == 40000000))
        {
            configStatus->txMaxBaudrate = 5000000;
        }
        else     //25M & 50M
        {
            configStatus->txMaxBaudrate = 6250000;
        }

        configStatus->txBaudrate = configStatus->txMaxBaudrate;
        break;
    }
    case IfxHssl_MasterModeTxSpeed_highSpeed:
    {
        //configStatus->txMax = fSource * 16 ; /*Alternatively, it can be derived from fPLL, which gives a more practical value*/

        configStatus->txMaxBaudrate = fHSCT / 2.5;                         /*Expectation is 320M*/
        configStatus->txBaudrate    = configStatus->txMaxBaudrate / txDiv; /*Divider to be used to reduce max baudrate in case of multiple slaves*/
        break;
    }
    default:
    {
        return IfxHssl_BaudrateStatus_errorMtxspeed;
    }
    }

    switch (hsctSFR->IFCTRL.B.MRXSPEED)
    {
    case IfxHssl_MasterModeRxSpeed_lowSpeed:
    {
        if ((fSource == 10000000) || (fSource == 20000000) || (fSource == 40000000))
        {
            configStatus->rxMaxBaudrate = 5000000;
        }
        else     //25M & 50M
        {
            configStatus->rxMaxBaudrate = 6250000;
        }

        configStatus->rxBaudrate = configStatus->rxMaxBaudrate;
        break;
    }
    case IfxHssl_MasterModeRxSpeed_mediumSpeed:
    {
        configStatus->rxMaxBaudrate = fSource;

        if ((fSource == 20000000) || (fSource == 40000000))
        {
            configStatus->rxMaxBaudrate = 20000000;
        }
        else
        {
            return IfxHssl_BaudrateStatus_unSupportedRxMediumSpeed;
        }

        configStatus->rxBaudrate = configStatus->rxMaxBaudrate;
        break;
    }
    case IfxHssl_MasterModeRxSpeed_highSpeed:
    {
        //configStatus->rxMax = fSource * 16; //Theoretical value, better to derive from PLL dividers
        configStatus->rxMaxBaudrate = fHSCT / 2.5;                         /*Expectation is 320M*/
        configStatus->rxBaudrate    = configStatus->rxMaxBaudrate / rxDiv; /*Divider to be used to reduce max baudrate in case of multiple slaves*/
        break;
    }
    default:
    {
        return IfxHssl_BaudrateStatus_errorMrxspeed;
    }
    }

    configStatus->fSysClkOut = fSource / fSysOutDiv;

    if (!((configStatus->fSysClkOut == 10000000) || (fSource == 20000000) || (fSource == 25000000)))
    {
        return IfxHssl_BaudrateStatus_unSupportedFSysClkOut;
    }

    return IfxHssl_BaudrateStatus_valid;
}
