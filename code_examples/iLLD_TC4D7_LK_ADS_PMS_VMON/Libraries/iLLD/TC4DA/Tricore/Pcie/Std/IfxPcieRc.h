/**
 * \file IfxPcieRc.h
 * \brief PCIE  basic functionality
 * \ingroup IfxLld_Pcie
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pcie_Std_Rc Rc Basic Functionality
 * \ingroup IfxLld_Pcie_Std
 * \defgroup IfxLld_Pcie_Std_Rc_Enumerations Enumerations
 * \ingroup IfxLld_Pcie_Std_Rc
 * \defgroup IfxLld_Pcie_Std_Rc_Functions Functions
 * \ingroup IfxLld_Pcie_Std_Rc
 */

#ifndef IFXPCIERC_H
#define IFXPCIERC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Pcie/Std/IfxPcie.h"
#include "_Impl/IfxPcie_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "IfxPcie_dsp_bf.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief ECAM Mask
 */
#define IFXPCIERC_ECAM_MASK      ((uint32)(0x0FFFFFFF))

/** \brief ECAM Shift needed as BDF of translated address is at 31:16
 */
#define IFXPCIERC_ECAM_SHIFT     ((uint32)(0x4))

/** \brief Bus Number Mask
 */
#define IFXPCIERC_ECAM_BUS_MASK  ((uint32)(0x0FF00000))

/** \brief Device Number Mask
 */
#define IFXPCIERC_ECAM_DEV_MASK  ((uint32)(0x000F8000))

/** \brief Function Number Mask
 */
#define IFXPCIERC_ECAM_FUN_MASK  ((uint32)(0x00007000))

/** \brief Register Number Mask
 */
#define IFXPCIERC_ECAM_REG_MASK  ((uint32)(0x00000FFC))

/** \brief Byte Address Mask
 */
#define IFXPCIERC_ECAM_BYT_MASK  ((uint32)(0x00000003))

/** \brief Bus Number Shift Value
 */
#define IFXPCIERC_ECAM_BUS_SHIFT ((uint32)(20))

/** \brief Device Number Shift Value
 */
#define IFXPCIERC_ECAM_DEV_SHIFT ((uint32)(15))

/** \brief Function Number Shift Value
 */
#define IFXPCIERC_ECAM_FUN_SHIFT ((uint32)(12))

/** \brief Register Number Shift Value
 */
#define IFXPCIERC_ECAM_REG_SHIFT ((uint32)(2))

/** \brief Byte Offset Shift Value
 */
#define IFXPCIERC_ECAM_BYT_SHIFT ((uint32)(0))

/** \brief Get the bridge memory base
 */
#define IFXPCIERC_GET_BRIDGE_MEMORYBASE(x)                                   ((uint16)(((uint16)((x) >> 16u)) & (uint16)0xFFF0))

/** \brief Get the bridge prefetch memory base
 */
#define IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYBASE(x)                          ((uint16)(((uint16)((x) >> 16u)) & (uint16)0xFFF0) | (uint16)1)

/** \brief Get the bridge prefetch memory base upper
 */
#define IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYBASEUPPER(x)                     ((uint32)((x) >> 32u))

/** \brief Get the bridge memory limit
 */
#define IFXPCIERC_GET_BRIDGE_MEMORYLIMIT(wireBase, bridgeBase)               ((wireBase > bridgeBase) ? (IFXPCIERC_GET_BRIDGE_MEMORYBASE(wireBase - 1u)) : 0u)

/** \brief Get the bridge memory prefetch limit
 */
#define IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYLIMIT(wireBase, bridgeBase)      ((wireBase > bridgeBase) ? (IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYBASE(wireBase - 1u)) : 0u)

/** \brief Get the bridge memory prefetch limit Upper
 */
#define IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYLIMITUPPER(wireBase, bridgeBase) ((wireBase > bridgeBase) ? (IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYBASEUPPER(wireBase - 1u)) : 0u)

/** \brief Get the MSI Base Data from Interrupt Vector
 */
#define IFXPCIERC_GET_MSI_BASEDATA_FROM_VECTOR(vector)                       ((uint16)((uint16)vector << 5u))

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Std_Rc_Enumerations
 * \{ */
/** \brief Number of lanes in the link
 */
typedef enum
{
    IfxPcieRc_LaneWidth_x1  = 0x01, /**< \brief Lane width 1 */
    IfxPcieRc_LaneWidth_x2  = 0x03, /**< \brief lanewidth_x2 */
    IfxPcieRc_LaneWidth_x4  = 0x07, /**< \brief lanewidth_x4 */
    IfxPcieRc_LaneWidth_x8  = 0x0f, /**< \brief lanewidth_x8 */
    IfxPcieRc_LaneWidth_x16 = 0x1f  /**< \brief lanewidth_x16 */
} IfxPcieRc_LaneWidth;

/** \brief Pcie Link speed
 */
typedef enum
{
    IfxPcieRc_linkSpeed_2_5GTS = 1,  /**< \brief Link speed 2.5GTS */
    IfxPcieRc_linkSpeed_5_0GTS = 2,  /**< \brief Link speed 5.0 GTS */
    IfxPcieRc_linkSpeed_8_0GTS = 3   /**< \brief Link speed 8.0GTS */
} IfxPcieRc_linkSpeed;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Rc_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Set bus parameters of the RC device
 * \param pcie Pointer to PCIe RC register
 * \param primaryBus primary bus number
 * \param secBus secondary bus number
 * \param subBus subordinate bus number
 * \return None
 */
IFX_INLINE void IfxPcieRc_setBusParameters(Ifx_PCIE_DSP *pcie, uint8 primaryBus, uint8 secBus, uint8 subBus);

/** \brief Set memory base and limit parameters
 * \param pcie Pointer to PCIe RC register
 * \param wireMemBase memory base address of PCIE topology
 * \param wireMemLimit memory end address of PCIE topology
 * \param prefetchBase memory start address of prefetch memory in PCIE topology
 * \param prefetchLimit memory end address of prefetch memory in PCIE topology
 * \return None
 */
IFX_INLINE void IfxPcieRc_setMemoryBaseLimit(Ifx_PCIE_DSP *pcie, uint32 wireMemBase, uint32 wireMemLimit, uint64 prefetchBase, uint64 prefetchLimit);

/** \brief Set MSI enable for RC
 * \param pcieSFR Pointer to PCIe RC register
 * \return None
 */
IFX_INLINE void IfxPcieRc_enableMsi(Ifx_PCIE_DSP *pcieSFR);

/** \brief Set MSIx enable for RC
 * \param pcieSFR Pointer to PCIe RC register
 * \return None
 */
IFX_INLINE void IfxPcieRc_enableMsix(Ifx_PCIE_DSP *pcieSFR);

/** \brief Enable the DRS reception by RC
 * \param pcieSFR Pointer to PCIe RC register
 * \return None
 */
IFX_INLINE void IfxPcieRc_enableDRS(Ifx_PCIE_DSP *pcieSFR);

/** \brief Get the DRS status
 * \param pcieSFR Pointer to PCIe RC register
 * \return TRUE: DRS message received
 * FALSE: no DRS message / DRS not applicable.
 */
IFX_INLINE boolean IfxPcieRc_getDRSstatus(Ifx_PCIE_DSP *pcieSFR);

/** \brief Enable Remote Interrupts from vector
 * \param pcieSFR Pointer to PCIe RC register
 * \param intVector Remote Interrupt Vector
 * \return None
 */
IFX_INLINE void IfxPcieRc_enableRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector);

/** \brief Disable Remote Interrupts from vector
 * \param pcieSFR Pointer to PCIe RC register
 * \param intVector Remote Interrupt Vector
 * \return None
 */
IFX_INLINE void IfxPcieRc_disableRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector);

/** \brief Set Interrupt Masks.
 * NOTE: Use this function to clear the mask as well
 * \param pcieSFR Pointer to PCIe RC register
 * \param intVector Remote Interrupt Vector
 * \param mask mask ( 1 << "POS" implies interrupt #"POS" is masked
 * \return None
 */
IFX_INLINE void IfxPcieRc_setRemoteInterruptMask(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector, uint32 mask);

/** \brief Get Pending Interrupt STatus.
 * NOTE: Use this function to clear the mask as well
 * \param pcieSFR Pointer to PCIe RC register
 * \param intVector Remote Interrupt Vector
 * \param mask mask ( 1 << "POS" implies interrupt #"POS" is masked
 * \return interrupt pending bits
 */
IFX_INLINE uint32 IfxPcieRc_getPendingRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector, uint32 mask);

/** \brief Clear Pending Interrupts
 * NOTE: Use this function to clear the mask as well
 * \param pcieSFR Pointer to PCIe RC register
 * \param intVector Remote Interrupt Vector
 * \param clearMask ( 1 << "POS" implies interrupt #"POS" is cleared
 * \return None
 */
IFX_INLINE void IfxPcieRc_clearPendingRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector, uint32 clearMask);

/** \brief Clear Pending Interrupts
 * NOTE: Use this function to clear the mask as well
 * \param pcieSFR Pointer to PCIe RC register
 * \param msiAddress MSI address
 * \return None
 */
IFX_INLINE void IfxPcieRc_writeMsiAddress(Ifx_PCIE_DSP *pcieSFR, uint64 msiAddress);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Compose ECAM address
 * \param Bus Bus Number
 * \param Device DEvice Number
 * \param Function Function Number
 * \param Offset Offset
 * \return ECAM Address
 */
IFX_EXTERN uint32 IfxPcieRc_ComposeExternalConfigAddress(uint8 Bus, uint8 Device, uint8 Function, uint16 Offset);

/** \brief This functions reads the number of lanes and sets the required number of lanes
 * \param PcieDspReg Pointer to PCIe config registers
 * \param laneWidth Number of lanes
 * \return None
 */
IFX_EXTERN void IfxPcieRc_setNumOfLanes(Ifx_PCIE_DSP *PcieDspReg, IfxPcieRc_LaneWidth laneWidth);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxPcieRc_setBusParameters(Ifx_PCIE_DSP *pcie, uint8 primaryBus, uint8 secBus, uint8 subBus)
{
    Ifx_PCIE_DSP_TYPE1HDR_SEC_LAT_TIMER_SUB_BUS_SEC_BUS_PRI_BUS_REG busReg;

    busReg.U                                                   = pcie->TYPE1HDR.SEC_LAT_TIMER_SUB_BUS_SEC_BUS_PRI_BUS_REG.U;

    busReg.B.PRIM_BUS                                          = primaryBus;
    busReg.B.SEC_BUS                                           = secBus;
    busReg.B.SUB_BUS                                           = subBus;

    pcie->TYPE1HDR.SEC_LAT_TIMER_SUB_BUS_SEC_BUS_PRI_BUS_REG.U = busReg.U;
}


IFX_INLINE void IfxPcieRc_setMemoryBaseLimit(Ifx_PCIE_DSP *pcie, uint32 wireMemBase, uint32 wireMemLimit, uint64 prefetchBase, uint64 prefetchLimit)
{
    Ifx_PCIE_DSP_TYPE1HDR_MEM_LIMIT_MEM_BASE_REG           memReg;
    Ifx_PCIE_DSP_TYPE1HDR_PREF_MEM_LIMIT_PREF_MEM_BASE_REG prefetchMemReg;
    Ifx_PCIE_DSP_TYPE1HDR_PREF_BASE_UPPER_REG              prefetchMemBaseUpper;
    Ifx_PCIE_DSP_TYPE1HDR_PREF_LIMIT_UPPER_REG             prefetchMemLimitUpper;

    memReg.U                                          = pcie->TYPE1HDR.MEM_LIMIT_MEM_BASE_REG.U;
    prefetchMemReg.U                                  = pcie->TYPE1HDR.PREF_MEM_LIMIT_PREF_MEM_BASE_REG.U;
    prefetchMemBaseUpper.U                            = pcie->TYPE1HDR.PREF_BASE_UPPER_REG.U;
    prefetchMemLimitUpper.U                           = pcie->TYPE1HDR.PREF_LIMIT_UPPER_REG.U;

    memReg.B.MEM_BASE                                 = (uint32)(wireMemBase >> 20u);
    memReg.B.MEM_LIMIT                                = (uint32)(wireMemLimit >> 20u);
    prefetchMemReg.B.PREF_MEM_BASE                    = (uint32)(prefetchBase) >> 20u;
    prefetchMemReg.B.PREF_MEM_LIMIT                   = (uint32)(prefetchLimit) >> 20u;
    prefetchMemBaseUpper.B.PREF_MEM_BASE_UPPER        = (uint32)(prefetchBase >> 32u);
    prefetchMemLimitUpper.B.PREF_MEM_LIMIT_UPPER      = (uint32)(prefetchLimit >> 32u);

    pcie->TYPE1HDR.MEM_LIMIT_MEM_BASE_REG.U           = memReg.U;
    pcie->TYPE1HDR.PREF_MEM_LIMIT_PREF_MEM_BASE_REG.U = prefetchMemReg.U;
    pcie->TYPE1HDR.PREF_BASE_UPPER_REG.U              = prefetchMemBaseUpper.U;
    pcie->TYPE1HDR.PREF_LIMIT_UPPER_REG.U             = prefetchMemLimitUpper.U;
}


IFX_INLINE void IfxPcieRc_enableMsi(Ifx_PCIE_DSP *pcieSFR)
{
    Ifx_PCIE_DSP_MSICAP_PCI_MSI_CAP_ID_NEXT_CTRL_REG msiCapCtrl;
    msiCapCtrl.U                                   = pcieSFR->MSICAP.PCI_MSI_CAP_ID_NEXT_CTRL_REG.U;

    msiCapCtrl.B.PCI_MSI_ENABLE                    = 1u;

    pcieSFR->MSICAP.PCI_MSI_CAP_ID_NEXT_CTRL_REG.U = msiCapCtrl.U;
}


IFX_INLINE void IfxPcieRc_enableMsix(Ifx_PCIE_DSP *pcieSFR)
{
    Ifx_PCIE_DSP_MSIXCAP_PCI_MSIX_CAP_ID_NEXT_CTRL_REG msixCapCtrl;
    msixCapCtrl.U                                    = pcieSFR->MSIXCAP.PCI_MSIX_CAP_ID_NEXT_CTRL_REG.U;

    msixCapCtrl.B.PCI_MSIX_ENABLE                    = 1u;

    pcieSFR->MSIXCAP.PCI_MSIX_CAP_ID_NEXT_CTRL_REG.U = msixCapCtrl.U;
}


IFX_INLINE void IfxPcieRc_enableDRS(Ifx_PCIE_DSP *pcieSFR)
{
    Ifx_PCIE_DSP_PCIECAP_LINK_CONTROL_LINK_STATUS_REG lnkCtrlReg;
    lnkCtrlReg.U                                    = pcieSFR->PCIECAP.LINK_CONTROL_LINK_STATUS_REG.U;

    lnkCtrlReg.B.PCIE_CAP_DRS_SIGNALING_CONTROL     = 0x1u;

    pcieSFR->PCIECAP.LINK_CONTROL_LINK_STATUS_REG.U = lnkCtrlReg.U;
}


IFX_INLINE boolean IfxPcieRc_getDRSstatus(Ifx_PCIE_DSP *pcieSFR)
{
    volatile Ifx_PCIE_DSP_MSG_INFO *msgInfo = &(pcieSFR->MSG.INFO);
    boolean                         drs     = FALSE;

    if (msgInfo->B.DRSSTAT == 1u)
    {
        drs               = TRUE;
        msgInfo->B.DRSCLR = 1u; /* clear the status */
    }

    return drs;
}


IFX_INLINE void IfxPcieRc_enableRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector)
{
    if (intVector <= IfxPcie_IntVector_remote7MsiIntD)
    {
        volatile Ifx_PCIE_DSP_PORTLOGIC_MSI_CTRL_INT_EN *msiIntReg = &(pcieSFR->PORTLOGIC.MSI.CTRL.INT[intVector].EN);
        msiIntReg->U = 0xFFFFFFFFu;                 /* Enable all interrupts from this vector */
    }
}


IFX_INLINE void IfxPcieRc_disableRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector)
{
    if (intVector <= IfxPcie_IntVector_remote7MsiIntD)
    {
        volatile Ifx_PCIE_DSP_PORTLOGIC_MSI_CTRL_INT_EN *msiIntReg = &(pcieSFR->PORTLOGIC.MSI.CTRL.INT[intVector].EN);
        msiIntReg->U = 0x0u;                        /* Disable all interrupts from this vector */
    }
}


IFX_INLINE void IfxPcieRc_setRemoteInterruptMask(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector, uint32 mask)
{
    if (intVector <= IfxPcie_IntVector_remote7MsiIntD)
    {
        volatile Ifx_PCIE_DSP_PORTLOGIC_MSI_CTRL_INT_MASK *msiMskReg = &(pcieSFR->PORTLOGIC.MSI.CTRL.INT[intVector].MASK);
        msiMskReg->U = (uint32)mask;                        /* Set the mask  */
    }
}


IFX_INLINE uint32 IfxPcieRc_getPendingRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector, uint32 mask)
{
    uint32 pendingBits = 0u;

    if (intVector <= IfxPcie_IntVector_remote7MsiIntD)
    {
        volatile Ifx_PCIE_DSP_PORTLOGIC_MSI_CTRL_INT_STATUS *msiPendingReg = &(pcieSFR->PORTLOGIC.MSI.CTRL.INT[intVector].STATUS);
        pendingBits = msiPendingReg->U & ~(mask);
    }

    return pendingBits;
}


IFX_INLINE void IfxPcieRc_clearPendingRemoteInterrupts(Ifx_PCIE_DSP *pcieSFR, IfxPcie_IntVector intVector, uint32 clearMask)
{
    if (intVector <= IfxPcie_IntVector_remote7MsiIntD)
    {
        volatile Ifx_PCIE_DSP_PORTLOGIC_MSI_CTRL_INT_STATUS *msiPendingReg = &(pcieSFR->PORTLOGIC.MSI.CTRL.INT[intVector].STATUS);
        msiPendingReg->U = clearMask;   /* Writing 1 clears the interrupt */
    }
}


IFX_INLINE void IfxPcieRc_writeMsiAddress(Ifx_PCIE_DSP *pcieSFR, uint64 msiAddress)
{
    pcieSFR->PORTLOGIC.MSI.CTRL.MSI_CTRL_ADDR_OFF.U       = (uint32)msiAddress;
    pcieSFR->PORTLOGIC.MSI.CTRL.MSI_CTRL_UPPER_ADDR_OFF.U = (uint32)(msiAddress >> 32u);
}


#endif /* IFXPCIERC_H */
