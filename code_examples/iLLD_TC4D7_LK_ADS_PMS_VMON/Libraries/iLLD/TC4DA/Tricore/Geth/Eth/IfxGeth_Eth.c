/**
 * \file IfxGeth_Eth.c
 * \brief GETH ETH details
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxGeth_Eth.h"

/******************************************************************************/
/*-----------------------Exported Variables/Constants-------------------------*/
/******************************************************************************/

IFX_ALIGN(8) IfxGeth_RxDescrList IfxGeth_Eth_rxDescrList[IFXGETH_NUM_MODULES][IFXGETH_NUM_RX_CHANNELS];

IFX_ALIGN(8) IfxGeth_TxDescrList IfxGeth_Eth_txDescrList[IFXGETH_NUM_MODULES][IFXGETH_NUM_TX_CHANNELS];

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxGeth_Eth_configureMacCore(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MacConfig *macConfig)
{
    Ifx_GETH *gethSFR = geth->gethSFR;

    /*Only MACADDRESS0 will be enabled by default*/
    /*Optional: Use IfxGeth_Eth_initMacAddressFilter to configure MACADDRESS1 to MACADDRESS31*/
    gethSFR->PORT[portIndex].CORE.MACADDRESS0.HIGH.B.ADDRHI = ((macConfig->macAddress[5]) << 8) + (macConfig->macAddress[4]) + 0x80000000;
    gethSFR->PORT[portIndex].CORE.MACADDRESS0.HIGH.B.DCS    = macConfig->channelSelectMacAddress0; /*Dma Channel Select 0-7*/
    gethSFR->PORT[portIndex].CORE.MACADDRESS0.LOW.U         = ((macConfig->macAddress[3]) << 24) + ((macConfig->macAddress[2]) << 16) + ((macConfig->macAddress[1]) << 8) + (macConfig->macAddress[0]);

    /*Default Filter Settings*/
    /*Optional: Use IfxGeth_Eth_initMacPacketFilter API to change filter configurations after calling IfxGeth_Eth_initModule API.*/
    Ifx_GETH_PORT_CORE_MAC_PACKET_FILTER lvPacketFilter;
    lvPacketFilter.U                                  = 0;

    lvPacketFilter.B.RA                               = 1;
    lvPacketFilter.B.IPFE                             = 0;
    lvPacketFilter.B.PCF                              = 2;
    lvPacketFilter.B.PR                               = 1;
    lvPacketFilter.B.SAF                              = 1;
    lvPacketFilter.B.PM                               = 1;

    gethSFR->PORT[portIndex].CORE.MAC_PACKET_FILTER.U = lvPacketFilter.U;

    /*TX Config*/
    /*Phy config is already done*/

    /*RX Config*/
    gethSFR->PORT[portIndex].CORE.MAC_RX_CONFIGURATION.B.LM       = macConfig->loopbackMode;

    gethSFR->PORT[portIndex].CORE.MAC_RX_CONFIGURATION.B.GPSLCE   = 1;

    gethSFR->PORT[portIndex].CORE.MAC_RX_CONFIGURATION.B.GPSL     = macConfig->giantPacketSize; /*Minimum and default value is 1518*/

    gethSFR->PORT[portIndex].CORE.MAC_RX_CONFIGURATION.B.DCRCC    = macConfig->disableCrcCheck;

    gethSFR->PORT[portIndex].CORE.MAC_EXTENDED_CONFIGURATION.B.HD = macConfig->duplexMode;
}


void IfxGeth_Eth_configureMTL(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MtlConfig *mtlConfig)
{
    Ifx_GETH *gethSFR = geth->gethSFR;

    /*MTL Core*/
    gethSFR->PORT[portIndex].MTL.OPERATION_MODE.B.RAA = mtlConfig->rxArbitrationAlgorithm;

    /*Currently ETSALG has no impact as TSA is fixed to Strict priority*/
    gethSFR->PORT[portIndex].MTL.OPERATION_MODE.B.ETSALG = 0;     /*WRR algorithm*/
    gethSFR->PORT[portIndex].MTL.OPERATION_MODE.B.FRPE   = 0;     /*Flexible Receive Parser Disabled*/

    /*Clear Interrupts. Compulsory Write of 1 needed to clear bit.*/
    gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_STATUS.U = 0x10003;
    gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_STATUS.U = 0x10003;
    gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_STATUS.U = 0x10003;
    gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_STATUS.U = 0x10003;
    gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_STATUS.U = 0x10003;
    gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_STATUS.U = 0x10003;
    gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_STATUS.U = 0x10003;
    gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_STATUS.U = 0x10003;

    /*Rx Queue(8) to DMA Channel(8) mappings
     * Default configuration is Static Mapping*/
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q0DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_0].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q0MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q0MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_0].rxDmaChannelMap;            /* Static mapping of RXC0 to DMA Channel */

    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q1DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_1].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q1MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q1MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_1].rxDmaChannelMap;            /* Static mapping of RXC1 to DMA Channel */

    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q2DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_2].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q2MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q2MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_2].rxDmaChannelMap;            /* Static mapping of RXC2 to DMA Channel */

    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q3DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_3].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q3MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP0.B.Q3MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_3].rxDmaChannelMap;            /* Static mapping of RXC3 to DMA Channel */

    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q4DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_4].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q4MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q4MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_4].rxDmaChannelMap;            /* Static mapping of RXC4 to DMA Channel */

    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q5DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_5].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q5MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q5MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_5].rxDmaChannelMap;            /* Static mapping of RXC5 to DMA Channel */

    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q6DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_6].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q6MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q6MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_6].rxDmaChannelMap;            /* Static mapping of RXC6 to DMA Channel */

    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q7DDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_7].enableDynamicDmaChannelMap; /* In Static mode, Channel is as per Q7MDMACH */
    gethSFR->PORT[portIndex].MTL.RXQ_DMA_MAP1.B.Q7MDMACH = mtlConfig->rxQueue[IfxGeth_RxMtlQueue_7].rxDmaChannelMap;            /* Static mapping of RXC7 to DMA Channel */

    /*In Strict priority, TC7 has highest priority and TC0 has lowest*/
    gethSFR->PORT[portIndex].MTL.TCQ0.TC0_ETS_CONTROL.B.TSA = 0;                                                                /*Strict priority */

    /* MTL TX
     * All TX Queues are mapped to Traffic Class 0 by default.
     * Application can modify using mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap.
     * Use IfxGeth_Eth_initTxTrafficClass API to configure additional Traffic Classes if needed. */

    /*TXQ 0*/
    IfxGeth_TxMtlQueue txQueueIndex = IfxGeth_TxMtlQueue_0;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ0.TXQ0_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ0.TXQ0_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ0.TXQ0_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ0.TXQ0_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ0.TXQ0_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ0.TXQ0_OPERATION_MODE.B.TXQEN = 2;                                          /* Queue is enabled in default mode. */
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ0.TXQ0_OPERATION_MODE.B.TXQEN = 1;                                          /* Queue is enabled in AVB mode. */
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*TXQ 1*/
    txQueueIndex = IfxGeth_TxMtlQueue_1;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ1.TXQ1_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ1.TXQ1_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ1.TXQ1_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ1.TXQ1_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ1.TXQ1_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ1.TXQ1_OPERATION_MODE.B.TXQEN = 2;                                          /*Queue is enabled in default mode.*/
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ1.TXQ1_OPERATION_MODE.B.TXQEN = 1;                                          /*Queue is enabled in AVB mode.*/
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*TXQ 2*/
    txQueueIndex = IfxGeth_TxMtlQueue_2;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ2.TXQ2_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ2.TXQ2_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ2.TXQ2_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ2.TXQ2_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ2.TXQ2_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ2.TXQ2_OPERATION_MODE.B.TXQEN = 2;                                          /*Queue is enabled in default mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ2.TXQ2_OPERATION_MODE.B.TXQEN = 1;                                          /*Queue is enabled in AVB mode*/
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*TXQ 3*/
    txQueueIndex = IfxGeth_TxMtlQueue_3;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ3.TXQ3_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ3.TXQ3_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ3.TXQ3_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ3.TXQ3_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ3.TXQ3_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ3.TXQ3_OPERATION_MODE.B.TXQEN = 2;                                          /*Queue is enabled in default mode.*/
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ3.TXQ3_OPERATION_MODE.B.TXQEN = 1;                                          /*Queue is enabled in AVB mode.*/
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*TXQ 4*/
    txQueueIndex = IfxGeth_TxMtlQueue_4;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ4.TXQ4_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ4.TXQ4_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ4.TXQ4_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ4.TXQ4_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ4.TXQ4_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ4.TXQ4_OPERATION_MODE.B.TXQEN = 2;                                          /*Queue is enabled in default mode.*/
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ4.TXQ4_OPERATION_MODE.B.TXQEN = 1;                                          /*Queue is enabled in AVB mode.*/
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*TXQ 5*/
    txQueueIndex = IfxGeth_TxMtlQueue_5;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ5.TXQ5_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ5.TXQ5_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ5.TXQ5_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ5.TXQ5_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ5.TXQ5_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ5.TXQ5_OPERATION_MODE.B.TXQEN = 2;                                          /*Queue is enabled in default mode.*/
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ5.TXQ5_OPERATION_MODE.B.TXQEN = 1;                                          /*Queue is enabled in AVB mode.*/
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*TXQ 6*/
    txQueueIndex = IfxGeth_TxMtlQueue_6;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ6.TXQ6_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ6.TXQ6_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ6.TXQ6_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ6.TXQ6_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ6.TXQ6_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ6.TXQ6_OPERATION_MODE.B.TXQEN = 2;                                          /*Queue is enabled in default mode.*/
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ6.TXQ6_OPERATION_MODE.B.TXQEN = 1;                                          /*Queue is enabled in AVB mode.*/
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*TXQ 7*/
    txQueueIndex = IfxGeth_TxMtlQueue_7;

    if (mtlConfig->txQueue[txQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ7.TXQ7_OPERATION_MODE.B.TSF = mtlConfig->txQueue[txQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ7.TXQ7_OPERATION_MODE.B.TSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ7.TXQ7_OPERATION_MODE.B.TTC = mtlConfig->txQueue[txQueueIndex].thresholdSize;
        }

        gethSFR->PORT[portIndex].MTL.TCQ7.TXQ7_OPERATION_MODE.B.Q2TCMAP = mtlConfig->txQueue[txQueueIndex].queueToTrafficClassMap;
        gethSFR->PORT[portIndex].MTL.TCQ7.TXQ7_OPERATION_MODE.B.TQS     = mtlConfig->txQueue[txQueueIndex].txQueueSize;

        if (mtlConfig->txQueue[txQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ7.TXQ7_OPERATION_MODE.B.TXQEN = 2;                                          /*Queue is enabled in default mode.*/
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ7.TXQ7_OPERATION_MODE.B.TXQEN = 1;                                          /*Queue is enabled in AVB mode.*/
        }

        if (mtlConfig->txQueue[txQueueIndex].txQueueUnderflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_ENABLE.B.TXUIE = 1;
        }
    }

    /*MTL RX*/

    /*RXQ 0*/
    IfxGeth_RxMtlQueue rxQueueIndex = IfxGeth_RxMtlQueue_0;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ0.RXQ0_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ0EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ0EN = 1; /*AVB Mode*/
        }
    }

    /*RXQ 1*/
    rxQueueIndex = IfxGeth_RxMtlQueue_1;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled.*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ1.RXQ1_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ1EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ1EN = 1; /*AVB Mode*/
        }
    }

    /*RXQ 2*/
    rxQueueIndex = IfxGeth_RxMtlQueue_2;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled.*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ2.RXQ2_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ2EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ2EN = 1; /*AVB Mode*/
        }
    }

    /*RXQ 3*/
    rxQueueIndex = IfxGeth_RxMtlQueue_3;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled.*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ3.RXQ3_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ3EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ3EN = 1; /*AVB Mode*/
        }
    }

    /*RXQ 4*/
    rxQueueIndex = IfxGeth_RxMtlQueue_4;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled.*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ4.RXQ4_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ4EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ4EN = 1; /*AVB Mode*/
        }
    }

    /*RXQ 5*/
    rxQueueIndex = IfxGeth_RxMtlQueue_5;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled.*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ5.RXQ5_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ5EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ5EN = 1; /*AVB Mode*/
        }
    }

    /*RXQ 6*/
    rxQueueIndex = IfxGeth_RxMtlQueue_6;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled.*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ6.RXQ6_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ6EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ6EN = 1; /*AVB Mode*/
        }
    }

    /*RXQ 7*/
    rxQueueIndex = IfxGeth_RxMtlQueue_7;

    if (mtlConfig->rxQueue[rxQueueIndex].enable == 1)
    {
        gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_OPERATION_MODE.B.RSF = mtlConfig->rxQueue[rxQueueIndex].storeAndForward;

        if (gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_OPERATION_MODE.B.RSF == 0)
        {
            gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_OPERATION_MODE.B.RTC = mtlConfig->rxQueue[rxQueueIndex].thresholdSize;
        }
        else
        {
            gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_OPERATION_MODE.B.DIS_TCP_EF = 1;                                                 /*Dropping packets disabled.*/
        }

        gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_OPERATION_MODE.B.FUF    = mtlConfig->rxQueue[rxQueueIndex].forwardUndersizedGoodPacket;
        gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_OPERATION_MODE.B.FEF    = mtlConfig->rxQueue[rxQueueIndex].forwardErrorPacket;
        gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_OPERATION_MODE.B.RQS    = mtlConfig->rxQueue[rxQueueIndex].rxQueueSize;

        gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_CONTROL.B.RXQ_WEGT      = mtlConfig->rxQueue[rxQueueIndex].wsp_weight;
        gethSFR->PORT[portIndex].MTL.TCQ7.RXQ7_CONTROL.B.RXQ_PKT_ARBIT = mtlConfig->rxQueue[rxQueueIndex].packetArbitrationControl;

        if (mtlConfig->rxQueue[rxQueueIndex].rxQueueOverflowInterruptEnabled)
        {
            gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_ENABLE.B.RXOIE = 1;
        }

        if (mtlConfig->rxQueue[rxQueueIndex].enableAudioVideoBridge == 0)
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ7EN = 2; /*Generic Mode*/
        }
        else
        {
            gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL0.B.RXQ7EN = 1; /*AVB Mode*/
        }
    }

    if (mtlConfig->interrupt.priority > 0)
    {
        IfxGeth_ServiceRequest mtlServiceRequestIndex = IfxGeth_ServiceRequest_INTR;

        volatile Ifx_SRC_SRCR *srcSFR;
        srcSFR = IfxGeth_getSrcPointer(mtlServiceRequestIndex);
        IfxSrc_init(srcSFR, mtlConfig->interrupt.provider, mtlConfig->interrupt.priority, mtlConfig->interrupt.vmId);
        IfxSrc_enable(srcSFR);
    }
}


void IfxGeth_Eth_initBridge(IfxGeth_Eth *geth, IfxGeth_Eth_BridgeConfig *config)
{
    IfxGeth_Port       portIndex    = IfxGeth_Port_0;
    IfxGeth_TxMtlQueue txQueueIndex = IfxGeth_TxMtlQueue_0;
    IfxGeth_RxMtlQueue rxQueueIndex = IfxGeth_RxMtlQueue_0;
    Ifx_GETH          *gethSFR      = geth->gethSFR;

    /* Application should make sure to choose valid set of configurations for all following set of registers*/

    /*Single Port or Multi Port Selection and Queue to Channel Mapping Enable*/
    IfxGeth_Bridge_setPortMode(gethSFR, config->mode);

    /*Loop back config for both the ports*/
    IfxGeth_Bridge_setLoopbackMode(gethSFR, config->portsLoopbackConfig);

    /* Dma channels allocation to Ports 0 and 1 */
    IfxGeth_Bridge_setDmaPortSelection(gethSFR, config->dmaPortMap);

    for (portIndex = IfxGeth_Port_0; portIndex < IFXGETH_NUM_PORTS; portIndex++)
    {
        /*Loop is executed once per Port*/

        /*Flush Rx Queues of a port*/
        IfxGeth_Bridge_flushAllPortRxQueues(geth->gethSFR, portIndex);

        if (gethSFR->BRIDGE.FORWARD_CONTROL.B.Q_CH_MAPPING_EN) /* As per HWA, following registers are configured only for two port mode */
        {
            for (txQueueIndex = IfxGeth_TxMtlQueue_0; txQueueIndex < IFXGETH_NUM_TX_QUEUES; txQueueIndex++)
            {
                /*Map a particular Tx Queue to DMA Tx Channel or Forward Port RXC*/
                IfxGeth_Bridge_mapTxQueue(gethSFR, portIndex, txQueueIndex, config->portConfig[portIndex].txMap[txQueueIndex]);
            }

            for (rxQueueIndex = IfxGeth_RxMtlQueue_0; rxQueueIndex < IFXGETH_NUM_RX_QUEUES; rxQueueIndex++)
            {
                /*Map a particular Rx Channel to DMA Rx Channel or Forward Port Tx Queue*/
                IfxGeth_Bridge_mapRxChannel(gethSFR, portIndex, rxQueueIndex, config->portConfig[portIndex].rxMap[rxQueueIndex]);
            }
        }
    }

    /*PORT_0_CONTROL and PORT_1_CONTROL must be configured after TXQ_MAP_PORT_0, TXQ_MAP_PORT_1, RXC_MAP_PORT_0 and RXC_MAP_PORT_1 is configured.*/
    if (gethSFR->BRIDGE.FORWARD_CONTROL.B.Q_CH_MAPPING_EN) /* As per HWA, following registers are configured only for two port mode */
    {
        /*Loop is executed once per Port*/
        for (portIndex = IfxGeth_Port_0; portIndex < IFXGETH_NUM_PORTS; portIndex++)
        {
            /*Enable/Disable the 8 Tx Queues and 8 Rx Channels of a Port individually based on application needs. */
            /*Optional: Additionally Enable/Disable the forward paths for the 8 Tx Queues. */
            IfxGeth_Bridge_enablePortTxQueuesAndRxChannels(geth->gethSFR, portIndex, config->portConfig[portIndex].configTxQueuesAndRxChannels);
        }
    }
}


void IfxGeth_Eth_initBridgeConfig(IfxGeth_Eth_BridgeConfig *config)
{
    const IfxGeth_Eth_BridgeConfig defaultConfig = {
        .mode                     = IfxGeth_BridgePortMode_singlePort0,
        .portsLoopbackConfig      = IfxGeth_BridgeLoopbackMode_disabled,
        .dmaPortMap.dmaPortMapAll = 0,
        .portConfig               = {
            {
                .configTxQueuesAndRxChannels.enableAll.txQueues          = 1,
                .configTxQueuesAndRxChannels.enableAll.rxChannels        = 1,
                .configTxQueuesAndRxChannels.enableAll.txForwardingPaths = 0,
                .txMap                                                   = {
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0
                },
                .rxMap                                                   ={
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0
                },
            },
            {
                .configTxQueuesAndRxChannels.enableAll.txQueues          = 0,
                .configTxQueuesAndRxChannels.enableAll.rxChannels        = 0,
                .configTxQueuesAndRxChannels.enableAll.txForwardingPaths = 0,
                .txMap                                                   = {
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0,
                    IfxGeth_BridgeTxQueueMap_TxDma0
                },
                .rxMap                                                   ={
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0,
                    IfxGeth_BridgeRxCMap_RxDma0
                },
            },
        },
    };
    /* Default Configuration */
    *config = defaultConfig;
}


void *IfxGeth_Eth_getReceiveBuffer(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    void                     *result = 0;
    volatile IfxGeth_RxDescr *descr1, *descr2;

    if (IfxGeth_Eth_isRxDataAvailable(geth, channelId))
    {
        /*OWN = 0, Descriptor is owned by Application*/
        geth->rxChannel[channelId].rxCount++;
        descr1 = IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);
        descr2 = IfxGeth_Eth_getActualRxDescriptor(geth, channelId);
        uint32 descrIndex = (descr2 - descr1);
        result = (void *)(uint32)((uint32)(geth->rxChannel[channelId].bufferSize * descrIndex) + geth->rxChannel[channelId].buffer1Address);
    }

    return result;
}


void *IfxGeth_Eth_getTransmitBuffer(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
    void                     *buffer = NULL_PTR;
    volatile IfxGeth_TxDescr *descr1, *descr2;

    descr2 = IfxGeth_Eth_getActualTxDescriptor(geth, channelId);

    /* check if descriptor / buffer is free. */
    if (descr2->TDES3.R.OWN == 0)
    {
        descr1 = IfxGeth_Eth_getBaseTxDescriptor(geth, channelId);
        uint32 descrIndex = (descr2 - descr1);
        buffer = ((void *)(uint32)((uint32)(geth->txChannel[channelId].txBuf1Size * descrIndex) + geth->txChannel[channelId].buffer1Address));
    }

    return buffer;
}


void IfxGeth_Eth_initModule(IfxGeth_Eth *geth, IfxGeth_Eth_Config *config)
{
    Ifx_GETH *gethSFR = config->gethSFR;

    geth->gethSFR = gethSFR;

    /* Enable Module */
    IfxGeth_enableModule(gethSFR);

    /* reset the Module */
    if (!config->bypassKernelReset)
    {
        IfxGeth_resetModule(gethSFR); /*For proper Reset all required clock signals must be available to MAC (Differs with each interface type)*/
    }

    /* enable MAC(s) */
    switch (config->bridge.mode)
    {
    case IfxGeth_BridgePortMode_singlePort0:
    {
        gethSFR->MACEN.U = 1;     /* MAC0 is enabled */
        break;
    }
    case IfxGeth_BridgePortMode_singlePort1:
    {
        gethSFR->MACEN.U = 2;     /* MAC1 is enabled */
        break;
    }
    case IfxGeth_BridgePortMode_multiPort:
    {
        gethSFR->MACEN.U = 3;     /* Both MAC0 and MAC1 are enabled */
        break;
    }
    default:
    {
        /* keep MACs disabled - will result into bus error during IfxGeth_Eth_configureDMA call! */
    }
    }

    /* Configure DMA */
    IfxGeth_Eth_configureDMA(geth, &config->dma);
    /* Configure Bridge */
    IfxGeth_Eth_initBridge(geth, &config->bridge);
    IfxGeth_BridgePortMode mode      = config->bridge.mode;

    IfxGeth_PortIndex      portIndex = IfxGeth_PortIndex_0;

    for (portIndex = IfxGeth_PortIndex_0; portIndex < IFXGETH_NUM_PORTS; portIndex++)
    {
        boolean portConfigEnable;

        if ((mode == IfxGeth_BridgePortMode_singlePort0) && (portIndex == IfxGeth_PortIndex_0))
        {
            portConfigEnable = TRUE;
        }

        else if ((mode == IfxGeth_BridgePortMode_singlePort1) && (portIndex == IfxGeth_PortIndex_1))
        {
            portConfigEnable = TRUE;
        }

        else if (mode == IfxGeth_BridgePortMode_multiPort)
        {
            portConfigEnable = TRUE;
        }

        else
        {
            portConfigEnable = FALSE;
        }

        if (portConfigEnable)
        {
            /* select the Phy Interface Mode */
            /*MAC Phy Config*/

            switch (config->port[portIndex].phyInterfaceMode)
            {
            case IfxGeth_PhyInterfaceMode_mii_10:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 7;
                break;
            }
            case IfxGeth_PhyInterfaceMode_mii_100:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 4;
                break;
            }
            case IfxGeth_PhyInterfaceMode_rmii_10:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 7;
                break;
            }
            case IfxGeth_PhyInterfaceMode_rmii_100:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 4;
                break;
            }
            case IfxGeth_PhyInterfaceMode_gmii_1000:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 3;
                break;
            }
            case IfxGeth_PhyInterfaceMode_gmii_2500:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 2;
                break;
            }
            case IfxGeth_PhyInterfaceMode_rgmii_10:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 7;
                break;
            }
            case IfxGeth_PhyInterfaceMode_rgmii_100:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 4;
                break;
            }
            case IfxGeth_PhyInterfaceMode_rgmii_1000:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 3;
                break;
            }
            case IfxGeth_PhyInterfaceMode_xgmii_2500:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 6;
                break;
            }
            case IfxGeth_PhyInterfaceMode_xgmii_5000:
            {
                gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.SS = 5;
                break;
            }
            }

            /*Specified interrupt bits are cleared on write of 1*/
            IfxGeth_enableMacRegisterClearOnWrite(gethSFR, (IfxGeth_Port)portIndex, TRUE);

            /* Configure MAC Core */
            IfxGeth_Eth_configureMacCore(geth, portIndex, &config->port[portIndex].mac);

            /* Configure MTL */
            IfxGeth_Eth_configureMTL(geth, portIndex, &config->port[portIndex].mtl);
        }
    }
}


void IfxGeth_Eth_initModuleConfig(IfxGeth_Eth_Config *config, Ifx_GETH *gethSFR)
{
    const IfxGeth_Eth_Config defaultConfig = {
        .gethSFR = NULL_PTR,
        .port    = {
            {
                .phyInterfaceMode = IfxGeth_PhyInterfaceMode_mii_10,
                .mac              = {
                    .duplexMode               = IfxGeth_DuplexMode_fullDuplex,
                    .loopbackMode             = IfxGeth_LoopbackMode_disable,
                    .disableCrcCheck          = TRUE,
                    .giantPacketSize          = 1518,
                    .macAddress               = {0,                           0,0,                                                      0,     0,    0         },
                    .channelSelectMacAddress0 = IfxGeth_RxDmaChannel_0
                },
                .mtl                                          ={
                    .rxArbitrationAlgorithm = IfxGeth_RxArbitrationAlgorithm_sp,

                    .txQueue                = {
                        {
                            .enable                           = TRUE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },
                    },

                    .rxQueue                                  ={
                        {
                            .enable                          = TRUE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },
                    },
                    .interrupt                                ={
                        .priority = 0,
                        .provider = IfxSrc_Tos_cpu0,
                        .vmId     = IfxSrc_VmId_0
                    }
                }
            },

            {
                .phyInterfaceMode = IfxGeth_PhyInterfaceMode_xgmii_2500,

                .mac              = {
                    .duplexMode               = IfxGeth_DuplexMode_fullDuplex,
                    .loopbackMode             = IfxGeth_LoopbackMode_disable,
                    .disableCrcCheck          = TRUE,
                    .giantPacketSize          = 1518,
                    .macAddress               = {0,                           0,0,                                                      0,     0,    0         },
                    .channelSelectMacAddress0 = IfxGeth_RxDmaChannel_0
                },
                .mtl                                          ={
                    .rxArbitrationAlgorithm = IfxGeth_RxArbitrationAlgorithm_sp,

                    .txQueue                = {
                        {
                            .enable                           = TRUE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },

                        {
                            .enable                           = FALSE,
                            .storeAndForward                  = TRUE,
                            .txQueueSize                      = 0x7F,
                            .txQueueUnderflowInterruptEnabled = FALSE,
                            .queueToTrafficClassMap           = IfxGeth_TxTrafficClass_0,
                            .enableAudioVideoBridge           = FALSE,
                            .thresholdSize                    = IfxGeth_MtlTransmitThreshold_512,
                        },
                    },

                    .rxQueue                                  ={
                        {
                            .enable                          = TRUE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },

                        {
                            .enable                          = FALSE,
                            .storeAndForward                 = TRUE,
                            .rxQueueSize                     = 0x7F,
                            .forwardErrorPacket              = FALSE,
                            .forwardUndersizedGoodPacket     = TRUE,
                            .rxDmaChannelMap                 = IfxGeth_RxDmaChannel_0,
                            .enableDynamicDmaChannelMap      = FALSE,
                            .rxQueueOverflowInterruptEnabled = FALSE,
                            .enableAudioVideoBridge          = FALSE,
                            .wsp_weight                      = 0,
                            .packetArbitrationControl        = 0,
                        },
                    },
                    .interrupt                                ={
                        .priority = 0,
                        .provider = IfxSrc_Tos_cpu0,
                        .vmId     = IfxSrc_VmId_0
                    }
                }
            }
        },
        .dma                                                  = {
            .addressAlignedBeatsEnabled = FALSE,

            .txChannel                  = {
                {
                    .channelEnable         = TRUE,
                    .channelId             = IfxGeth_TxDmaChannel_0,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][0],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_TxDmaChannel_1,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][1],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_TxDmaChannel_2,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][2],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_TxDmaChannel_3,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][3],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_TxDmaChannel_4,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][4],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_TxDmaChannel_5,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][5],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_TxDmaChannel_6,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][6],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_TxDmaChannel_7,
                    .maxBurstLength        = IfxGeth_TxBurstLength_2,
                    .txDescrList           = &IfxGeth_Eth_txDescrList[0][7],
                    .txBuffer1StartAddress = NULL_PTR,
                    .txBuffer1Size         = 256,
                    .vlanTagControl        = IfxGeth_VlanTagInclusionControl_none,
                    .timeStampEnable       = FALSE,
                    .avbSlotNumber         = 0,
                    .checksumControl       = IfxGeth_ChecksumControl_headerAndPayloadWithPseudoHeader,
                    .sourceAddressControl  = IfxGeth_SourceAddressControl_notIncluded,
                    .crcControl            = IfxGeth_CrcControl_insertCrcAndPad,
                },
            },

            .rxChannel                                        = {
                {
                    .channelEnable         = TRUE,
                    .channelId             = IfxGeth_RxDmaChannel_0,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][0],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_RxDmaChannel_1,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][1],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_RxDmaChannel_2,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][2],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_RxDmaChannel_3,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][3],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_RxDmaChannel_4,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][4],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_RxDmaChannel_5,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][5],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_RxDmaChannel_6,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][6],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },

                {
                    .channelEnable         = FALSE,
                    .channelId             = IfxGeth_RxDmaChannel_7,
                    .maxBurstLength        = IfxGeth_RxBurstLength_2,
                    .rxDescrList           = &IfxGeth_Eth_rxDescrList[0][7],
                    .rxBuffer1StartAddress = NULL_PTR,
                    .rxBuffer1Size         = 256,
                },
            },

            .txInterrupt                                      = {
                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },
            },

            .rxInterrupt                                      = {
                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },

                {
                    .priority = 0,
                    .provider = IfxSrc_Tos_cpu0,
                    .vmId     = IfxSrc_VmId_0,
                },
            },

            .burstLength                 = IfxGeth_DmaBurstLength_16,
            .undefinedBurstLength        = TRUE,
            .burstLengthMultiplierEnable = {TRUE,                                                   TRUE, TRUE,  TRUE, TRUE, TRUE, TRUE, TRUE},
        },
        .bypassKernelReset                                    = FALSE
    };

    /* Default Configuration */
    *config = defaultConfig;
    /* Bridge Configuration */
    IfxGeth_Eth_initBridgeConfig(&config->bridge);
    /* take over module pointer */
    config->gethSFR = gethSFR;
}


void IfxGeth_Eth_writeHeader(uint8 *txBuffer, uint8 *destinationAddress, uint8 *sourceAddress, uint32 payloadLength)
{
    uint32 i;

    /* Destination Address */
    for (i = 0; i < 6; i++)
    {
        *txBuffer++ = *destinationAddress++;
    }

    /* Source Address */
    for (i = 0; i < 6; i++)
    {
        *txBuffer++ = *sourceAddress++;
    }

    /* packet size */
    *txBuffer++ = (uint8)(payloadLength / 256);
    *txBuffer   = (uint8)(payloadLength % 256);
}


void IfxGeth_Eth_configureDMA(IfxGeth_Eth *geth, IfxGeth_Eth_DmaConfig *dmaConfig)
{
    Ifx_GETH *gethSFR = geth->gethSFR;

    /*S/w Reset done by setting bit DMA_Mode.SWR*/
    IfxGeth_Dma_applySoftwareReset(gethSFR);

    /*Poll again and wait until it becomes 0*/
    while (gethSFR->DMA.MODE.B.SWR == 1)
    {}

    /*Config system bus mode*/
    gethSFR->DMA.SYSBUS_MODE.B.AAL = dmaConfig->addressAlignedBeatsEnabled;   /*Address Aligned Burst Transfer*/
    gethSFR->DMA.SYSBUS_MODE.B.UBL = dmaConfig->undefinedBurstLength;

    if (dmaConfig->burstLength != IfxGeth_DmaBurstLength_unset)
    {
        switch (dmaConfig->burstLength)
        {
        /*UNDEF = 0, and all BLEN<x> are 0*/
        case IfxGeth_DmaBurstLength_1:
        {
            gethSFR->DMA.SYSBUS_MODE.B.UBL = 0;
            break;
        }

        /*Set one of the 7 bits for different burst lengths*/
        case IfxGeth_DmaBurstLength_4:
        {
            gethSFR->DMA.SYSBUS_MODE.B.BLEN4 = 1;
            break;
        }

        case IfxGeth_DmaBurstLength_8:
        {
            gethSFR->DMA.SYSBUS_MODE.B.BLEN8 = 1;
            break;
        }

        case IfxGeth_DmaBurstLength_16:
        {
            gethSFR->DMA.SYSBUS_MODE.B.BLEN16 = 1;
            break;
        }

        case IfxGeth_DmaBurstLength_32:
        {
            gethSFR->DMA.SYSBUS_MODE.B.BLEN32 = 1;
            break;
        }

        case IfxGeth_DmaBurstLength_64:
        {
            gethSFR->DMA.SYSBUS_MODE.B.BLEN64 = 1;
            break;
        }

        case IfxGeth_DmaBurstLength_128:
        {
            gethSFR->DMA.SYSBUS_MODE.B.BLEN128 = 1;
            break;
        }

        case IfxGeth_DmaBurstLength_256:
        {
            gethSFR->DMA.SYSBUS_MODE.B.BLEN256 = 1;
            break;
        }

        default:
        {}
        }
    }

    /*8 Channels supported*/
    uint8 channelIndex = 0;

    /*Descriptors initialization*/
    for (channelIndex = 0; channelIndex < IFXGETH_NUM_DMA_CHANNELS; channelIndex++)
    {
        if (dmaConfig->txChannel[channelIndex].channelEnable)
        {
            IfxGeth_Eth_initTransmitDescriptors(geth, &dmaConfig->txChannel[channelIndex]);
        }

        if (dmaConfig->rxChannel[channelIndex].channelEnable)
        {
            IfxGeth_Eth_initReceiveDescriptors(geth, &dmaConfig->rxChannel[channelIndex]);
        }
    }

    /*Channels Initialization*/
    for (channelIndex = 0; channelIndex < IFXGETH_NUM_DMA_CHANNELS; channelIndex++)
    {
        if (dmaConfig->burstLengthMultiplierEnable[channelIndex])
        {
            gethSFR->DMA.CH[channelIndex].CONTROL.B.PBLX8 = 1;
        }

        /* initialize the interrupts */

        /* Transmit configuration */
        if (dmaConfig->txChannel[channelIndex].channelEnable)
        {
            gethSFR->DMA.CH[channelIndex].TX_CONTROL.B.TXPBL = dmaConfig->txChannel[channelIndex].maxBurstLength;

            /* Transmit interrupts*/
            if ((dmaConfig->txInterrupt[channelIndex].priority > 0) || (dmaConfig->txInterrupt[channelIndex].provider == IfxSrc_Tos_dma0) || (dmaConfig->txInterrupt[channelIndex].provider == IfxSrc_Tos_dma1))
            {
                gethSFR->DMA.CH[channelIndex].INTERRUPT_ENABLE.B.TIE = 1;
                gethSFR->DMA.CH[channelIndex].INTERRUPT_ENABLE.B.NIE = 1;                                              /*Group of TIE (TIE is part of NIE) must also be enabled*/

                volatile Ifx_SRC_SRCR *srcSFR;
                srcSFR = IfxGeth_getSrcPointer((IfxGeth_ServiceRequest)(IfxGeth_ServiceRequest_DMA_0 + channelIndex)); /*TX Channels start at DMA0*/
                IfxSrc_init(srcSFR, dmaConfig->txInterrupt[channelIndex].provider, dmaConfig->txInterrupt[channelIndex].priority, dmaConfig->txInterrupt[channelIndex].vmId);
                IfxSrc_enable(srcSFR);
            }
        }

        /* Receive configuration */
        if (dmaConfig->rxChannel[channelIndex].channelEnable)
        {
            gethSFR->DMA.CH[channelIndex].RX_CONTROL.B.RXPBL = dmaConfig->rxChannel[channelIndex].maxBurstLength;

            /* Receive interrupts */
            if ((dmaConfig->rxInterrupt[channelIndex].priority > 0) || (dmaConfig->rxInterrupt[channelIndex].provider == IfxSrc_Tos_dma0) || (dmaConfig->rxInterrupt[channelIndex].provider == IfxSrc_Tos_dma1))
            {
                gethSFR->DMA.CH[channelIndex].INTERRUPT_ENABLE.B.RIE = 1;
                gethSFR->DMA.CH[channelIndex].INTERRUPT_ENABLE.B.NIE = 1;

                volatile Ifx_SRC_SRCR *srcSFR;
                srcSFR = IfxGeth_getSrcPointer((IfxGeth_ServiceRequest)(IfxGeth_ServiceRequest_DMA_8 + channelIndex));  /*RX channels start after TX channels in SRC.GETH.DMA*/
                IfxSrc_init(srcSFR, dmaConfig->rxInterrupt[channelIndex].provider, dmaConfig->rxInterrupt[channelIndex].priority, dmaConfig->rxInterrupt[channelIndex].vmId);
                IfxSrc_enable(srcSFR);
            }
        }
    }
}


void IfxGeth_Eth_initReceiveDescriptors(IfxGeth_Eth *geth, IfxGeth_Eth_RxChannelConfig *config)
{
    int                  i;
    uint32               buffer1StartAddress = (uint32)config->rxBuffer1StartAddress;

    IfxGeth_RxDmaChannel channelId           = config->channelId;

    geth->rxChannel[channelId].channelId      = channelId;
    geth->rxChannel[channelId].rxDescrList    = config->rxDescrList;
    geth->rxChannel[channelId].buffer1Address = buffer1StartAddress;
    geth->rxChannel[channelId].bufferSize     = (uint32)(config->rxBuffer1Size);

    volatile IfxGeth_RxDescr *descr = IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);

    volatile IfxGeth_RxDescr *tail  = &descr[IFXGETH_MAX_RX_DESCRIPTORS - 1]; /* Point to last descriptor in the ring */

    /* Initialize descriptors in ring mode */
    for (i = 0; i < IFXGETH_MAX_RX_DESCRIPTORS; i++)
    {
        descr->RDES0.U     = (uint32)(config->rxBuffer1Size * i) + buffer1StartAddress;
        descr->RDES2.U     = 0;   /* buffer2 not used */
        descr->RDES3.R.IOC = 1;   /* interrupt enabled */
        descr->RDES3.R.OWN = 1;   /* owned by DMA */

        descr              = &descr[1];
    }

    /* rest the current pointer to base pointer in the handle */
    geth->rxChannel[channelId].rxDescrPtr = IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);

    /* set the buffer size */
    geth->gethSFR->DMA.CH[channelId].RX_CONTROL.B.RBSZ      = config->rxBuffer1Size;
    geth->gethSFR->DMA.CH[channelId].RXDESC_LIST_LADDRESS.U = (uint32)IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);
    geth->gethSFR->DMA.CH[channelId].RXDESC_TAIL_LPOINTER.U = (uint32)tail;
    geth->gethSFR->DMA.CH[channelId].RX_CONTROL2.B.RDRL     = (IFXGETH_MAX_RX_DESCRIPTORS - 1);
}


void IfxGeth_Eth_initTransmitDescriptors(IfxGeth_Eth *geth, IfxGeth_Eth_TxChannelConfig *config)
{
    int                  i;
    uint32               buffer1StartAddress = (uint32)config->txBuffer1StartAddress;

    IfxGeth_TxDmaChannel channelId           = config->channelId;

    /*Store parameters in geth handle*/
    geth->txChannel[channelId].channelId            = channelId;
    geth->txChannel[channelId].txDescrList          = config->txDescrList;
    geth->txChannel[channelId].txBuf1Size           = (uint16)config->txBuffer1Size;
    geth->txChannel[channelId].buffer1Address       = buffer1StartAddress;

    geth->txChannel[channelId].checksumControl      = config->checksumControl;
    geth->txChannel[channelId].sourceAddressControl = config->sourceAddressControl;
    geth->txChannel[channelId].crcControl           = config->crcControl;

    /*Optional Features*/
    geth->txChannel[channelId].vlanTagControl  = config->vlanTagControl;
    geth->txChannel[channelId].timeStampEnable = config->timeStampEnable;
    geth->txChannel[channelId].avbSlotNumber   = config->avbSlotNumber;

    volatile IfxGeth_TxDescr *descr = IfxGeth_Eth_getBaseTxDescriptor(geth, channelId);

    geth->txChannel[channelId].txDescrPtr = descr;

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (config->txBuffer1Size) % 4 == 0);

    /* Initialize descriptors in ring mode */
    for (i = 0; i < IFXGETH_MAX_TX_DESCRIPTORS; i++)
    {
        descr->TDES0.U      = (uint32)(config->txBuffer1Size * i) + buffer1StartAddress;
        descr->TDES1.U      = 0;                       /* buffer2 not used */

        descr->TDES2.R.B1L  = config->txBuffer1Size;
        descr->TDES2.R.VTIR = config->vlanTagControl;  /* optional feature: Vlan Tag Deletion, Insertion and Replacement */
        descr->TDES2.R.B2L  = 0;                       /* buffer2 not used */
        descr->TDES2.R.TTSE = config->timeStampEnable; /* optional feature: time-stamping of tx packets */
        descr->TDES2.R.IOC  = 0;                       /* interrupt disabled */

        /* TDES3 will be configured while transmitting each packet */

        descr = &descr[1];
    }

    geth->gethSFR->DMA.CH[channelId].TXDESC_LIST_LADDRESS.U = (uint32)IfxGeth_Eth_getBaseTxDescriptor(geth, channelId);

    geth->gethSFR->DMA.CH[channelId].TX_CONTROL2.B.TDRL     = (IFXGETH_MAX_TX_DESCRIPTORS - 1); /*0 = Ring Length of 1*/
}


void IfxGeth_Eth_sendFrame(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FrameConfig *config)
{
    IfxGeth_Eth_sendTransmitBuffer(geth, portIndex, config->packetLength, config->channelId);
}


void IfxGeth_Eth_sendTransmitBuffer(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint32 packetLength, IfxGeth_TxDmaChannel channelId)
{
    uint32                    i;
    volatile IfxGeth_TxDescr *firstDescr       = IfxGeth_Eth_getActualTxDescriptor(geth, channelId);
    volatile IfxGeth_TxDescr *descr            = firstDescr;
    volatile IfxGeth_TxDescr *nextDescr        = &firstDescr[1];
    uint32                    bufferLength     = geth->txChannel[channelId].txBuf1Size; /* get the configured buffer length */
    /* calculate the number of descriptors needed for the frame based on buffer length */
    uint32                    numOfDescriptors = packetLength / bufferLength;

    if (packetLength % bufferLength)
    {
        numOfDescriptors += 1;
    }

    /* configure the first descriptor */
    firstDescr->TDES3.R.FL   = packetLength;                                    /* total length of the packet */

    firstDescr->TDES3.R.SAIC = geth->txChannel[channelId].sourceAddressControl; /* Source Address Insertion control. Only valid for first descriptor. Default: IfxGeth_SourceAddressControl_notIncluded */
    firstDescr->TDES3.R.CPC  = geth->txChannel[channelId].crcControl;           /* CRC and PAD Insertion control. Only valid for first descriptor. Default: IfxGeth_CrcControl_insertCrcAndPad */

    /* configure every other descriptor including first descriptor for the frame transmission */
    for (i = 0; i < numOfDescriptors; i++)
    {
        if (i == (numOfDescriptors - 1))
        {
            descr->TDES3.R.LD  = 1;                                              /* last descriptor of the frame */
            descr->TDES2.R.IOC = 1;                                              /* last descriptor of the frame set IOC */
            descr->TDES3.R.FD  = 0;
            descr->TDES2.R.B1L = packetLength;
        }
        else
        {
            descr->TDES3.R.LD  = 0;
            descr->TDES3.R.FD  = 0;
            descr->TDES2.R.IOC = 0;                                          /* Clear the IOC bits for intermediate buffers */
            descr->TDES2.R.B1L = geth->txChannel[channelId].txBuf1Size;
            packetLength      -= bufferLength;
        }

        descr->TDES2.R.VTIR    = geth->txChannel[channelId].vlanTagControl;
        descr->TDES2.R.B2L     = 0; /* buffer2 not used */
        descr->TDES2.R.TTSE    = geth->txChannel[channelId].timeStampEnable;

        descr->TDES3.R.CIC     = geth->txChannel[channelId].checksumControl;
        descr->TDES3.R.SLOTNUM = geth->txChannel[channelId].avbSlotNumber;       /* AVB Slot number */
        descr->TDES3.R.CTXT    = 0U;                                             /* Normal Descriptor */

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, descr->TDES3.R.OWN != 1U);           /* Assert if buffers are not available for transfer */
        descr->TDES3.R.OWN = 1U;                                                 /* release to DMA */
        IfxGeth_Eth_shuffleTxDescriptor(geth, channelId);                        /* Point to next descriptor in ring*/
        descr              = IfxGeth_Eth_getActualTxDescriptor(geth, channelId); /* update the descr pointer */
        nextDescr          = descr;
    }

    firstDescr->TDES3.R.FD                                  = 1;                 /* first descriptor of the frame */
    geth->txChannel[channelId].txDescrPtr                   = firstDescr;

    geth->gethSFR->DMA.CH[channelId].TXDESC_TAIL_LPOINTER.U = (uint32)nextDescr; /*last descriptor based on packet size*/

    IfxGeth_Eth_wakeupTransmitter(geth, portIndex, channelId);                   /* initiate the transfer */
    geth->txChannel[channelId].txDescrPtr = nextDescr;                           /* update the handle pointer to next descriptor */

    geth->txChannel[channelId].txCount++;
}


void IfxGeth_Eth_shuffleRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    volatile IfxGeth_RxDescr *currentDescr = geth->rxChannel[channelId].rxDescrPtr;
    volatile IfxGeth_RxDescr *lastDescr    = &geth->rxChannel[channelId].rxDescrList->descr[IFXGETH_MAX_RX_DESCRIPTORS - 1];

    /*Re-initialise Rx Descriptor of the channel*/
    uint32                    descrIndex         = ((unsigned)currentDescr - (unsigned)geth->rxChannel[channelId].rxDescrList) / sizeof(IfxGeth_RxDescr);

    uint32                    nextTailDescrIndex = descrIndex; /* Move tail (last available rx descriptor in ring) after update of descriptor. Next tail will be same as one being released by application*/

    {
        currentDescr->RDES0.U     = (uint32)(geth->rxChannel[channelId].bufferSize * descrIndex) + geth->rxChannel[channelId].buffer1Address;
        currentDescr->RDES2.U     = 0; /* buffer2 not used */

        currentDescr->RDES3.U     = 0;
        currentDescr->RDES3.R.IOC = 1; /* interrupt enabled */
        currentDescr->RDES3.R.OWN = 1; /* owned by DMA */
    }

    if (currentDescr == lastDescr)
    {
        volatile IfxGeth_RxDescr *descr = IfxGeth_Eth_getBaseRxDescriptor(geth, channelId);

        /* wrap around the descriptors */
        geth->rxChannel[channelId].rxDescrPtr = descr;
    }
    else
    {
        /* point to the next descriptor */
        geth->rxChannel[channelId].rxDescrPtr = &geth->rxChannel[channelId].rxDescrPtr[1];
    }

    geth->gethSFR->DMA.CH[channelId].RXDESC_TAIL_LPOINTER.U = (uint32)&geth->rxChannel[channelId].rxDescrList->descr[nextTailDescrIndex];  /* Update tail and it also triggers sync of descriptor memory to H/w */
}


void IfxGeth_Eth_shuffleTxDescriptor(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
    volatile IfxGeth_TxDescr *currentDescr = geth->txChannel[channelId].txDescrPtr;
    volatile IfxGeth_TxDescr *lastDescr    = &geth->txChannel[channelId].txDescrList->descr[IFXGETH_MAX_TX_DESCRIPTORS - 1];

    /* re-Initialize descriptor */
    {
        uint32 descrIndex = ((unsigned)currentDescr - (unsigned)geth->txChannel[channelId].txDescrList) / sizeof(IfxGeth_TxDescr);
        currentDescr->TDES0.U = (uint32)(geth->txChannel[channelId].txBuf1Size * descrIndex) + geth->txChannel[channelId].buffer1Address;
        currentDescr->TDES1.U = 0;           /* buffer2 not used */
    }

    if (currentDescr == lastDescr)
    {
        volatile IfxGeth_TxDescr *descr = IfxGeth_Eth_getBaseTxDescriptor(geth, channelId);

        /* wrap around the descriptors */
        geth->txChannel[channelId].txDescrPtr = descr;
    }
    else
    {
        /* point to the next descriptor */
        geth->txChannel[channelId].txDescrPtr = &geth->txChannel[channelId].txDescrPtr[1];
    }
}


void IfxGeth_Eth_startReceiver(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_RxDmaChannel channelId)
{
    geth->gethSFR->PORT[portIndex].CORE.MAC_RX_CONFIGURATION.B.RE = 1;
    geth->gethSFR->DMA.CH[channelId].RX_CONTROL.B.SR              = 1;
}


void IfxGeth_Eth_startTransmitter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_TxDmaChannel channelId)
{
    geth->gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.TE = 1;
    geth->gethSFR->DMA.CH[channelId].TX_CONTROL.B.ST              = 1;
}


void IfxGeth_Eth_wakeupReceiver(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_RxDmaChannel channelId)
{
    /* check if receiver suspended */
    if (geth->gethSFR->DMA.CH[channelId].STATUS.B.RPS)
    {
        /* check if receive buffer unavailable */
        if (geth->gethSFR->DMA.CH[channelId].STATUS.B.RBU)
        {
            geth->gethSFR->DMA.CH[channelId].STATUS.B.RBU = 1; /*Clear the bit*/
        }

        IfxGeth_Eth_startReceiver(geth, portIndex, channelId);
    }
}


void IfxGeth_Eth_wakeupTransmitter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_TxDmaChannel channelId)
{
    /* check if transmitter suspended */
    /*if (IfxGeth_dma_isInterruptFlagSet(geth->gethSFR, (IfxGeth_DmaChannel)channelId, IfxGeth_DmaInterruptFlag_transmitStopped))
     */
    if (geth->gethSFR->DMA.CH[channelId].STATUS.B.TPS)
    {
        /* check if transmit buffer unavailable*/
        if (geth->gethSFR->DMA.CH[channelId].STATUS.B.TBU)
        {
            geth->gethSFR->DMA.CH[channelId].STATUS.B.TBU = 1;  /*Clear the bit*/
        }

        /*check MTL underflow flag*/
        if (channelId == IfxGeth_TxDmaChannel_0)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ0.Q0_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        if (channelId == IfxGeth_TxDmaChannel_1)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ1.Q1_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        if (channelId == IfxGeth_TxDmaChannel_2)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ2.Q2_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        if (channelId == IfxGeth_TxDmaChannel_3)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ3.Q3_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        if (channelId == IfxGeth_TxDmaChannel_4)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ4.Q4_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        if (channelId == IfxGeth_TxDmaChannel_5)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ5.Q5_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        if (channelId == IfxGeth_TxDmaChannel_6)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ6.Q6_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        if (channelId == IfxGeth_TxDmaChannel_7)
        {
            if (geth->gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_STATUS.B.TXUNFIS)
            {
                geth->gethSFR->PORT[portIndex].MTL.TCQ7.Q7_INTERRUPT_STATUS.B.TXUNFIS = 1; /*Clear the bit*/
            }
        }

        IfxGeth_Eth_startTransmitter(geth, portIndex, channelId);
    }
}


void IfxGeth_Eth_stopTransmitter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_TxDmaChannel channelId)
{
    geth->gethSFR->PORT[portIndex].CORE.MAC_TX_CONFIGURATION.B.TE = 0;
    geth->gethSFR->DMA.CH[channelId].TX_CONTROL.B.ST              = 0;
}


void IfxGeth_Eth_stopReceiver(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_RxDmaChannel channelId)
{
    geth->gethSFR->PORT[portIndex].CORE.MAC_RX_CONFIGURATION.B.RE = 0;
    geth->gethSFR->DMA.CH[channelId].RX_CONTROL.B.SR              = 0;
}


void IfxGeth_Eth_freeReceiveBuffer(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    IfxGeth_Eth_shuffleRxDescriptor(geth, channelId);
}


#ifdef IFXGETH_ADVANCED
void IfxGeth_Eth_initMacAddressFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MacAddressFilterConfig *config)
{
    Ifx_GETH_PORT_CORE_MACADDRESS1 *macAddressRegPairPtr = (Ifx_GETH_PORT_CORE_MACADDRESS1 *)&(geth->gethSFR->PORT[portIndex].CORE.MACADDRESS1);  /*Base address of MACADDRESS1*/

    uint8                           i;

    for (i = 1; i < config->index; i++)
    {
        macAddressRegPairPtr++;
    }

    macAddressRegPairPtr->LOW.U = ((config->macAddress[3]) << 24) + ((config->macAddress[2]) << 16) + ((config->macAddress[1]) << 8) + (config->macAddress[0]);

    Ifx_GETH_PORT_CORE_MACADDRESS1_HIGH lvHighReg;

    lvHighReg.U                  = 0;
    lvHighReg.B.ADDRHI           = ((config->macAddress[5]) << 8) + (config->macAddress[4]);
    lvHighReg.B.DCS              = config->dmachannel; /*Dma Channel Select 0-7*/
    lvHighReg.B.MBC              = config->mask;
    lvHighReg.B.SA               = config->referenceAddress;
    lvHighReg.B.AE               = config->enable;

    macAddressRegPairPtr->HIGH.U = lvHighReg.U;
}


void IfxGeth_Eth_initMacPacketFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MacPacketFilterConfig *config)
{
    Ifx_GETH_PORT_CORE_MAC_PACKET_FILTER lvPacketFilter;
    lvPacketFilter.U                                        = 0;
    lvPacketFilter.B.PR                                     = config->enablePromiscuousMode;
    lvPacketFilter.B.DAIF                                   = config->enableDAInverseFiltering;
    lvPacketFilter.B.PM                                     = config->enablePassAllMulticast;
    lvPacketFilter.B.DBF                                    = config->enableDisableBroadcastPackets;
    lvPacketFilter.B.PCF                                    = config->controlPacketFilterType;
    lvPacketFilter.B.SAIF                                   = config->enableSAInverseFiltering;
    lvPacketFilter.B.SAF                                    = config->enableSourceAddressFilter;
    lvPacketFilter.B.VTFE                                   = config->enableVLanTagFilter;
    lvPacketFilter.B.IPFE                                   = config->enableL3L4Filter;
    lvPacketFilter.B.DNTU                                   = config->enableNonTcpUpdDropFilter;
    lvPacketFilter.B.RA                                     = config->enableReceiveAllPackets;

    geth->gethSFR->PORT[portIndex].CORE.MAC_PACKET_FILTER.U = lvPacketFilter.U;
}


void IfxGeth_Eth_initMacRxEthTypeFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint16 ethernetType)
{
    geth->gethSFR->PORT[portIndex].CORE.MAC_RX_ETH_TYPE_MATCH.U = ethernetType;
}


void IfxGeth_Eth_initVLanTagFilterControl(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanTagCtrlConfig *config)
{
    Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL vLanTagCtrl;
    vLanTagCtrl.U        = 0;

    vLanTagCtrl.B.ETV    = config->vLanTagSize;    /*Size of Tag used for VLAN Hash Filter*/
    vLanTagCtrl.B.VTIM   = config->enableInverseMatch;
    vLanTagCtrl.B.ESVL   = config->enableSVLan;
    vLanTagCtrl.B.ERSVLM = config->rxMatchFilterType;
    vLanTagCtrl.B.DOVLTC = config->disableTypeCheck;
    vLanTagCtrl.B.EVLS   = config->outerTagStripType;
    vLanTagCtrl.B.EVLRXS = config->enableOuterTagInRxStatus;

    if (config->enableVLanHashFilter)
    {
        vLanTagCtrl.B.VTHM                                             = TRUE;
        geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_HASH_TABLE.B.VLHT = config->hashTableValue;
    }

    vLanTagCtrl.B.EDVLP = config->enableDoubleVLan;

    if (config->enableDoubleVLan && config->doubleVLanTagPosition)
    {
        vLanTagCtrl.B.ERIVLT = TRUE;
    }

    vLanTagCtrl.B.EIVLS   = config->innerTagStripType;
    vLanTagCtrl.B.EIVLRXS = config->enableInnerTagInRxStatus;

    boolean retry    = 0;
    boolean firstTry = 1;

    while (firstTry | retry) /*Retry if Busy*/
    {
        if (geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.B.OB == 0)
        {
            geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.U = vLanTagCtrl.U;
            retry                                                   = 0;
        }
        else
        {
            retry = 1;

            __nop();
            __nop();
        }

        firstTry = 0;
    }
}


void IfxGeth_Eth_writeVLanFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanFilterConfig *config)
{
    Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_DATA filter;
    filter.U        = 0;

    filter.B.VID    = config->rxVLanTag;
    filter.B.VEN    = config->enableVLanFilter;
    filter.B.ETV    = config->vLanTagSize;
    filter.B.DOVLTC = config->disableTypeCheck;
    filter.B.ERSVLM = config->rxMatchFilterType;
    filter.B.ERIVLT = config->doubleVLanTagPosition;

    if (config->enableDmaRouting)
    {
        filter.B.DMACHEN = TRUE;
        filter.B.DMACHN  = config->rxDmaChannel;
    }

    boolean retry    = 0;
    boolean firstTry = 1;

    while (firstTry | retry) /*Retry if Busy*/
    {
        if (geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.B.OB == 0)
        {
            geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_DATA.U = filter.U;

            Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL vLanTagCtrl;
            vLanTagCtrl.U                                            = geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.U;
            vLanTagCtrl.B.CT                                         = 0;                    /*Filter Write Operation*/
            vLanTagCtrl.B.OFS                                        = config->filterOffset; /*Filter Select*/
            geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.U  = vLanTagCtrl.U;

            geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.U += 1;                    /*Initiate the indirect write to Vlan Filter Register by setting OB bitfield*/

            retry                                                    = 0;
        }
        else
        {
            retry = 1;

            __nop();
            __nop();
        }

        firstTry = 0;
    }
}


uint32 IfxGeth_Eth_readVLanFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 filterOffset)
{
    uint32  filter   = 0;

    boolean retry    = 0;
    boolean firstTry = 1;

    while (firstTry | retry) /*Retry if Busy*/
    {
        if (geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.B.OB == 0)
        {
            Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL vLanTagCtrl;
            vLanTagCtrl.U                                            = geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.U;
            vLanTagCtrl.B.CT                                         = 1;            /*Filter Read Operation*/
            vLanTagCtrl.B.OFS                                        = filterOffset; /*Filter Select*/
            geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.U  = vLanTagCtrl.U;

            geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.U += 1;            /*Initiate the indirect read of Vlan Filter Register by setting OB bitfield*/

            while (geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_CTRL.B.OB)       /*Wait till Filter data is fetched*/
            {}

            filter = geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_TAG_DATA.U;
            retry  = 0;
        }
        else
        {
            retry = 1;

            __nop();
            __nop();
        }

        firstTry = 0;
    }

    return filter;
}


void IfxGeth_Eth_rxFilterFailPacketRouting(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FailPacketRoutingConfig *config)
{
    Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL4 routingControl;
    routingControl.U = 0;

    if (config->unicastFailPacketRoutingEnable)
    {
        routingControl.B.UFFQE = 1;
        routingControl.B.UFFQ  = config->uincastFailPacketDestination;
    }

    if (config->multicastFailPacketRoutingEnable)
    {
        routingControl.B.MFFQE = 1;
        routingControl.B.MFFQ  = config->multicastFailPacketDestination;
    }

    if (config->vlanFailPacketRoutingEnable)
    {
        routingControl.B.VFFQE = 1;
        routingControl.B.VFFQ  = config->vlanFailPacketDestination;
    }

    geth->gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL4.U = routingControl.U;
}


void IfxGeth_Eth_txVlanTagInclusionControl(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanInclusionConfig *config)
{
    if (config->outerTag.enableOuterVlanModification)
    {
        Ifx_GETH_PORT_CORE_MAC_VLAN_INCL outerIncl;
        outerIncl.U      = 0;

        outerIncl.B.VLTI = config->outerTag.tagSource;

        if (outerIncl.B.VLTI)
        {
            outerIncl.B.VLT = config->outerTag.txVlanTag;
        }

        /*else: Tag value taken from Tx Descriptor. Use IfxGeth_Eth_initTxContextDescriptor to update Tag values */

        outerIncl.B.VLP = config->outerTag.priority;

        if (outerIncl.B.VLP)
        {
            outerIncl.B.VLC = config->outerTag.control;
        }

        /*else: mti_vlan_ctrl_i control input is used and VLC is ignored*/

        outerIncl.B.CSVL = config->outerTag.vlanType;

        outerIncl.B.CBTI = config->outerTag.enableChannelSpecificConfig;

        /*Indirect Addressing activated on write to Byte 3*/
        if (outerIncl.B.CBTI)
        {
            outerIncl.B.ADDR = config->outerTag.addressOffset;
            outerIncl.B.RDWR = 1; /*Write*/
        }

        while (geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_INCL.B.BUSY)
        {}

        geth->gethSFR->PORT[portIndex].CORE.MAC_VLAN_INCL.U = outerIncl.U;
    }

    if (config->innerTag.enableInnerVlanModification)
    {
        Ifx_GETH_PORT_CORE_MAC_INNER_VLAN_INCL innerIncl;
        innerIncl.U      = 0;

        innerIncl.B.VLTI = config->innerTag.tagSource;

        if (innerIncl.B.VLTI)
        {
            innerIncl.B.VLT = config->innerTag.txVlanTag;
        }

        /*else: Tag value taken from Tx Descriptor. Use IfxGeth_Eth_initTxContextDescriptor to update Tag values */

        innerIncl.B.VLP = config->innerTag.priority;

        if (innerIncl.B.VLP)
        {
            innerIncl.B.VLC = config->innerTag.control;
        }

        /*else: mti_vlan_ctrl_i control input is used and VLC is ignored*/

        innerIncl.B.CSVL                                          = config->innerTag.vlanType;

        geth->gethSFR->PORT[portIndex].CORE.MAC_INNER_VLAN_INCL.U = innerIncl.U;
    }
}


void IfxGeth_Eth_flexibleHeaderInit(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FlexHeaderConfig *config)
{
    Ifx_GETH_PORT_CORE_MAC_FLEX_HDR_CFG flexHdrCfg;

    flexHdrCfg.U      = 0;
    flexHdrCfg.B.FHL  = config->length;
    flexHdrCfg.B.FHSP = config->startPosition;

    if (config->txEnable && config->pauseHeaderEnable)
    {
        geth->gethSFR->PORT[portIndex].CORE.MAC_FLEX_HDR_LOW.U  = (uint32)(config->staticHeader & 0x00000000FFFFFFFF);
        geth->gethSFR->PORT[portIndex].CORE.MAC_FLEX_HDR_HIGH.U = (uint32)(config->staticHeader >> 32);
    }

    flexHdrCfg.B.EFLL                                      = config->pauseHeaderEnable;
    flexHdrCfg.B.FHRX                                      = config->rxEnable;
    flexHdrCfg.B.FHTX                                      = config->txEnable;

    geth->gethSFR->PORT[portIndex].CORE.MAC_FLEX_HDR_CFG.U = flexHdrCfg.U;
}


void IfxGeth_Eth_rxVlanPacket2QueueMap(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanRxRoutingConfig *config)
{
    Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL2 queueMap0to3;
    queueMap0to3.U                                      = 0;

    queueMap0to3.B.PSRQ0                                = config->rxQueuePriorityMap[0].F;
    queueMap0to3.B.PSRQ1                                = config->rxQueuePriorityMap[1].F;
    queueMap0to3.B.PSRQ2                                = config->rxQueuePriorityMap[2].F;
    queueMap0to3.B.PSRQ3                                = config->rxQueuePriorityMap[3].F;

    geth->gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL2.U = queueMap0to3.U;

    Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL3 queueMap4to7;
    queueMap4to7.U                                            = 0;

    queueMap4to7.B.PSRQ4                                      = config->rxQueuePriorityMap[4].F;
    queueMap4to7.B.PSRQ5                                      = config->rxQueuePriorityMap[5].F;
    queueMap4to7.B.PSRQ6                                      = config->rxQueuePriorityMap[6].F;
    queueMap4to7.B.PSRQ7                                      = config->rxQueuePriorityMap[7].F;

    geth->gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL3.U       = queueMap4to7.U;

    geth->gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL5.B.PRQSO = config->offset;
}


void IfxGeth_Eth_rxPacket2QueueMap(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_RxRoutingConfig *config)
{
    Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL1 queueControl;
    queueControl.U     = 0;

    queueControl.B.UPQ = config->untaggedPacketQueue;

    if (config->residualPacketQueue != 0) /* IfxGeth_RxMtlQueue_0 is default for express frames. Must not be allocated to residual frames*/
    {
        queueControl.B.RQ = config->residualPacketQueue;
    }

    if (config->multicastOrBroadcastRoutingEnable)
    {
        queueControl.B.MCBCQ                                       = config->multicastOrBroadcastPacketQueue;
        geth->gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL4.B.PMCBCQ = config->preemptiveMulticastOrBroadcastPacketQueue;
        queueControl.B.MCBCQEN                                     = 1;
    }
    else
    {
        geth->gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL4.B.PMCBCQ = 0;
    }

    queueControl.B.OMCBCQ                               = config->overrideMulticastOrBroadcastRouting; /*Priority of MCBC packet over other type of packets*/

    queueControl.B.TPQC                                 = config->ptpQueueSelect;
    queueControl.B.PTPQ                                 = config->ptpPacketQueue;

    queueControl.B.TACPQE                               = config->taggedAVQueueDestinationSelection; /* Queue Select for Tagged AV Control Packets */
    queueControl.B.AVCPQ                                = config->avPacketQueue;                     /* Default for untagged AV Control packets. For tagged, this queue is used if TACPQE = 1 */

    geth->gethSFR->PORT[portIndex].CORE.MAC_RXQ_CTRL1.U = queueControl.U;
}


boolean IfxGeth_Eth_mdioSingleWrite(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioSingleWriteConfig *config)
{
    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS mdioSingleCmdAddr;
    mdioSingleCmdAddr.U                                                          = 0;
    mdioSingleCmdAddr.B.DA                                                       = config->mdioSingleCmdDeviceAddr;
    mdioSingleCmdAddr.B.PA                                                       = config->mdioSingleCmdPortAddr;
    mdioSingleCmdAddr.B.RA                                                       = config->mdioSingleCmdRegAddr;
    geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U            = mdioSingleCmdAddr.U;
    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA mdioSingleCmdCtrlData;
    mdioSingleCmdCtrlData.U                                                      = geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U;
    mdioSingleCmdCtrlData.B.SDATA                                                = config->mdioSingleWriteData;
    mdioSingleCmdCtrlData.B.CMD                                                  = 1;
    geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U       = mdioSingleCmdCtrlData.U;
    geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY = 1;
    uint32  timeoutCycleCount = IFXGETH_MDIO_MAX_TIMEOUT;
    boolean timeOutError      = FALSE;

    while (geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY == 1)
    {
        IFXGETH_MDIO_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return timeOutError;
}


boolean IfxGeth_Eth_mdioSingleRead(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioSingleReadConfig *config)
{
    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS mdioSingleCmdAddr;
    mdioSingleCmdAddr.U                                               = 0;
    mdioSingleCmdAddr.B.DA                                            = config->mdioSingleCmdDeviceAddr;
    mdioSingleCmdAddr.B.PA                                            = config->mdioSingleCmdPortAddr;
    mdioSingleCmdAddr.B.RA                                            = config->mdioSingleCmdRegAddr;
    geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U = mdioSingleCmdAddr.U;

    Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA mdioSingleCmdCtrlData;
    mdioSingleCmdCtrlData.U                                                      = geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U;
    mdioSingleCmdCtrlData.B.CMD                                                  = 3;
    geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U       = mdioSingleCmdCtrlData.U;
    geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY = 1;

    uint32  timeoutCycleCount = IFXGETH_MDIO_MAX_TIMEOUT;
    boolean timeOutError      = FALSE;

    while (geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY == 1)
    {
        IFXGETH_MDIO_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == 0)
    {
        Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA mdioSingleCmdCtrlData;
        mdioSingleCmdCtrlData.U       = 0;
        mdioSingleCmdCtrlData.U       = geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U;
        *(config->mdioSingleReadData) = mdioSingleCmdCtrlData.B.SDATA;
    }

    return timeOutError;
}


void IfxGeth_Eth_mdioContinuousStartScan(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioContinuousStartScanConfig *config)
{
    geth->gethSFR->PORT[portIndex].CORE.MDIO.CONTINUOUS_SCAN_PORT_ENABLE.U = config->mdioContinuousScanPortEnable.mdioContinuousScanPortEnableAll;
    geth->gethSFR->PORT[portIndex].CORE.MDIO.INTERRUPT_ENABLE.U            = config->mdioContinuousInterruptEnable.mdioContinuousInterruptEnableAll;
}


boolean IfxGeth_Eth_mdioContinuousWrite(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioContinuousWriteConfig *config)
{
    uint8   index             = 0;
    uint32  timeoutCycleCount = IFXGETH_MDIO_MAX_TIMEOUT;
    boolean timeOutError      = FALSE;

    while (index != config->mdioContinuousWriteOperCount)
    {
        timeoutCycleCount                                                = IFXGETH_MDIO_MAX_TIMEOUT;
        Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_WRITE_DATA mdioContinuousWriteData;
        mdioContinuousWriteData.U                                        = 0;
        mdioContinuousWriteData.B.CDATA                                  = config->mdioContinuousWriteAddrData[index].mdioContinuousWriteData;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.CONTINUOUS_WRITE_DATA.U = mdioContinuousWriteData.U;

        Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_WRITE_ADDRESS mdioContinuousWriteAddr;
        mdioContinuousWriteAddr.U                                                 = 0;
        mdioContinuousWriteAddr.B.CADDR                                           = config->mdioContinuousWriteAddrData[index].mdioContinuousPortDeviceAddr;
        mdioContinuousWriteAddr.B.CPRT                                            = config->mdioContinuousWriteAddrData[index].mdioContinuousPortAddrEnable;
        mdioContinuousWriteAddr.B.CREGADDR                                        = config->mdioContinuousWriteAddrData[index].mdioContinuousWriteRegAddr;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.CONTINUOUS_WRITE_ADDRESS.U       = mdioContinuousWriteAddr.U;

        geth->gethSFR->PORT[portIndex].CORE.MDIO.CONTINUOUS_WRITE_ADDRESS.B.CBUSY = 1;

        while (geth->gethSFR->PORT[portIndex].CORE.MDIO.CONTINUOUS_WRITE_ADDRESS.B.CBUSY == 1)
        {
            IFXGETH_MDIO_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        index++;
    }

    return timeOutError;
}


void IfxGeth_Eth_initMdio(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_MdioModeSelectionType mdioModeSelectionType, void *config)
{
    if (mdioModeSelectionType == IfxGeth_MdioModeSelectionType_singleTransfer)
    {
        IfxGeth_Eth_MdioSingleConfig                       *config1 = config;
        Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA mdioSingleCmdCtrlData;
        mdioSingleCmdCtrlData.U                                                = 0;
        mdioSingleCmdCtrlData.B.CMD                                            = config1->mdioControlCommandType;
        mdioSingleCmdCtrlData.B.SAADR                                          = config1->mdioSkipAddrFrameEnable;
        mdioSingleCmdCtrlData.B.CR                                             = config1->mdioAppClockRangeSel;
        mdioSingleCmdCtrlData.B.PSE                                            = config1->mdioPreambleSuppressionEnable;
        mdioSingleCmdCtrlData.B.CRS                                            = config1->mdioClkRangeEnable;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = mdioSingleCmdCtrlData.U;

        geth->gethSFR->PORT[portIndex].CORE.MDIO.CLAUSE_22_PORT.U              = config1->mdioClause22.mdioClause22All;

        Ifx_GETH_PORT_CORE_MDIO_PORT_NX4_INDIRECT_CONTROL mdioIndirectCtrl;
        mdioIndirectCtrl.U                                                   = 0;
        mdioIndirectCtrl.B.PRS                                               = config1->mdioPortRangeSel;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.PORT_NX4_INDIRECT_CONTROL.U = mdioIndirectCtrl.U;
    }
    else
    {
        IfxGeth_Eth_MdioContinuousConfig                 *config1 = config;

        geth->gethSFR->PORT[portIndex].CORE.MDIO.CLAUSE_22_PORT.U = config1->mdioClause22.mdioClause22All;

        Ifx_GETH_PORT_CORE_MDIO_PORT_NX4_INDIRECT_CONTROL mdioIndirectCtrl;
        mdioIndirectCtrl.U                                                   = 0;
        mdioIndirectCtrl.B.PRS                                               = config1->mdioPortRangeSel;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.PORT_NX4_INDIRECT_CONTROL.U = mdioIndirectCtrl.U;

        geth->gethSFR->PORT[portIndex].CORE.MDIO.PORTNX4P0_DEVICE_IN_USE.U   = config1->mdioDeviceInUse_NX4P[0].mdioDeviceInUseAll;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.PORTNX4P1_DEVICE_IN_USE.U   = config1->mdioDeviceInUse_NX4P[1].mdioDeviceInUseAll;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.PORTNX4P2_DEVICE_IN_USE.U   = config1->mdioDeviceInUse_NX4P[2].mdioDeviceInUseAll;
        geth->gethSFR->PORT[portIndex].CORE.MDIO.PORTNX4P3_DEVICE_IN_USE.U   = config1->mdioDeviceInUse_NX4P[3].mdioDeviceInUseAll;
    }
}


void IfxGeth_Eth_mdioContinuousStopScan(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioContinuousStopScanConfig *config)
{
    geth->gethSFR->PORT[portIndex].CORE.MDIO.CONTINUOUS_SCAN_PORT_ENABLE.U = config->mdioContinuousScanPortEnable.mdioContinuousScanPortEnableAll;
}


void IfxGeth_Eth_initMmc(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MmcConfig *mmcConfig)
{
    Ifx_GETH_PORT_CORE_MMC_CONTROL mmcControl;
    mmcControl.U                                                        = 0;
    mmcControl.B.CNTRST                                                 = mmcConfig->controlConfig.counterReset;
    mmcControl.B.CNTSTOPRO                                              = mmcConfig->controlConfig.counterStopRollover;
    mmcControl.B.RSTONRD                                                = mmcConfig->controlConfig.counterResetOnRead;
    mmcControl.B.CNTPRST                                                = mmcConfig->controlConfig.counterPreset;
    mmcControl.B.MCT                                                    = mmcConfig->controlConfig.counterThreshold;
    geth->gethSFR->PORT[portIndex].CORE.MMC_CONTROL.U                   = mmcControl.U;

    geth->gethSFR->PORT[portIndex].CORE.MMC_TRANSMIT_INTERRUPT_ENABLE.U = mmcConfig->interruptConfig.txInterruptEnable.U;
    geth->gethSFR->PORT[portIndex].CORE.MMC_RECEIVE_INTERRUPT_ENABLE.U  = mmcConfig->interruptConfig.rxInterruptEnable.U;

    geth->gethSFR->PORT[portIndex].CORE.MMC_FPE_TX_INTERRUPT_MASK.U     = mmcConfig->interruptConfig.txFpeInterruptMask.U;
    geth->gethSFR->PORT[portIndex].CORE.MMC_FPE_RX_INTERRUPT_MASK.U     = mmcConfig->interruptConfig.rxFpeInterruptMask.U;
    geth->gethSFR->PORT[portIndex].CORE.MMC_IPC_RX_INTERRUPT_MASK.U     = mmcConfig->interruptConfig.rxIpcInterruptMask.U;
}


void IfxGeth_Eth_readMmcCounterReg(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MmcCounters *mmcCounters)
{
    mmcCounters->txOctetCountGoodBad64               = (uint64)(geth->gethSFR->PORT[portIndex].CORE.TX_OCTET_COUNT_GOOD_BAD_LOW.U);
    mmcCounters->txOctetCountGoodBad64              |= (((uint64)(geth->gethSFR->PORT[portIndex].CORE.TX_OCTET_COUNT_GOOD_BAD_HIGH.U)) << 32);
    mmcCounters->txPacketCountGoodBadLow             = geth->gethSFR->PORT[portIndex].CORE.TX_PACKET_COUNT_GOOD_BAD_LOW.U;
    mmcCounters->txBroadcastPacketsGoodLow           = geth->gethSFR->PORT[portIndex].CORE.TX_BROADCAST_PACKETS_GOOD_LOW.U;
    mmcCounters->txMulticastPacketsGoodLow           = geth->gethSFR->PORT[portIndex].CORE.TX_MULTICAST_PACKETS_GOOD_LOW.U;
    mmcCounters->tx64OctetsPacketsGoodBadLow         = geth->gethSFR->PORT[portIndex].CORE.TX_64OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->tx65to127OctetsPacketsGoodBadLow    = geth->gethSFR->PORT[portIndex].CORE.TX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->tx128to255OctetsPacketsGoodBadLow   = geth->gethSFR->PORT[portIndex].CORE.TX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->tx256to511OctetsPacketsGoodBadLow   = geth->gethSFR->PORT[portIndex].CORE.TX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->tx512to1023OctetsPacketsGoodBadLow  = geth->gethSFR->PORT[portIndex].CORE.TX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->tx1024toMaxOctetsPacketsGoodBadLow  = geth->gethSFR->PORT[portIndex].CORE.TX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->txUnicastPacketsGoodBadLow          = geth->gethSFR->PORT[portIndex].CORE.TX_UNICAST_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->txMulticastPacketsGoodBadLow        = geth->gethSFR->PORT[portIndex].CORE.TX_MULTICAST_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->txBroadcastPacketsGoodBadLow        = geth->gethSFR->PORT[portIndex].CORE.TX_BROADCAST_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->txUnderflowErrorPacketsLow          = geth->gethSFR->PORT[portIndex].CORE.TX_UNDERFLOW_ERROR_PACKETS_LOW.U;
    mmcCounters->txOctetCountGood64                  = (uint64)(geth->gethSFR->PORT[portIndex].CORE.TX_OCTET_COUNT_GOOD_LOW.U);
    mmcCounters->txOctetCountGood64                 |= (((uint64)(geth->gethSFR->PORT[portIndex].CORE.TX_OCTET_COUNT_GOOD_HIGH.U)) << 32);
    mmcCounters->txPacketCountGoodLow                = geth->gethSFR->PORT[portIndex].CORE.TX_PACKET_COUNT_GOOD_LOW.U;
    mmcCounters->txPausePacketsLow                   = geth->gethSFR->PORT[portIndex].CORE.TX_PAUSE_PACKETS_LOW.U;
    mmcCounters->txVlanPacketsGoodLow                = geth->gethSFR->PORT[portIndex].CORE.TX_VLAN_PACKETS_GOOD_LOW.U;
    mmcCounters->txLpiUsecCntr                       = geth->gethSFR->PORT[portIndex].CORE.TX_LPI_USEC_CNTR.U;
    mmcCounters->txLpiTranCntr                       = geth->gethSFR->PORT[portIndex].CORE.TX_LPI_TRAN_CNTR.U;
    mmcCounters->rxPacketCountGoodBadLow             = geth->gethSFR->PORT[portIndex].CORE.RX_PACKET_COUNT_GOOD_BAD_LOW.U;
    mmcCounters->rxOctetCountGoodBad64               = (uint64)(geth->gethSFR->PORT[portIndex].CORE.RX_OCTET_COUNT_GOOD_BAD_LOW.U);
    mmcCounters->rxOctetCountGoodBad64              |= (((uint64)(geth->gethSFR->PORT[portIndex].CORE.RX_OCTET_COUNT_GOOD_BAD_HIGH.U)) << 32);
    mmcCounters->rxOctetCountGood64                  = (uint64)(geth->gethSFR->PORT[portIndex].CORE.RX_OCTET_COUNT_GOOD_LOW.U);
    mmcCounters->rxOctetCountGood64                 |= (((uint64)(geth->gethSFR->PORT[portIndex].CORE.RX_OCTET_COUNT_GOOD_HIGH.U)) << 32);
    mmcCounters->rxBroadcastPacketsGoodLow           = geth->gethSFR->PORT[portIndex].CORE.RX_BROADCAST_PACKETS_GOOD_LOW.U;
    mmcCounters->rxMulticastPacketsGoodLow           = geth->gethSFR->PORT[portIndex].CORE.RX_MULTICAST_PACKETS_GOOD_LOW.U;
    mmcCounters->rxCrcErrorPacketsLow                = geth->gethSFR->PORT[portIndex].CORE.RX_CRC_ERROR_PACKETS_LOW.U;
    mmcCounters->rxRuntErrorPackets                  = geth->gethSFR->PORT[portIndex].CORE.RX_RUNT_ERROR_PACKETS.U;
    mmcCounters->rxJabberErrorPackets                = geth->gethSFR->PORT[portIndex].CORE.RX_JABBER_ERROR_PACKETS.U;
    mmcCounters->rxUndersizePacketsGood              = geth->gethSFR->PORT[portIndex].CORE.RX_UNDERSIZE_PACKETS_GOOD.U;
    mmcCounters->rxOversizePacketsGood               = geth->gethSFR->PORT[portIndex].CORE.RX_OVERSIZE_PACKETS_GOOD.U;
    mmcCounters->rx64OctetsPacketsGoodBadLow         = geth->gethSFR->PORT[portIndex].CORE.RX_64OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rx65to127OctetsPacketsGoodBadLow    = geth->gethSFR->PORT[portIndex].CORE.RX_65TO127OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rx128to255OctetsPacketsGoodBadLow   = geth->gethSFR->PORT[portIndex].CORE.RX_128TO255OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rx256to511OctetsPacketsGoodBadLow   = geth->gethSFR->PORT[portIndex].CORE.RX_256TO511OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rx512to1023OctetsPacketsGoodBadLow  = geth->gethSFR->PORT[portIndex].CORE.RX_512TO1023OCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rx1024toMaxOctetsGoodBadLow         = geth->gethSFR->PORT[portIndex].CORE.RX_1024TOMAXOCTETS_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rxUnicastPacketsGoodLow             = geth->gethSFR->PORT[portIndex].CORE.RX_UNICAST_PACKETS_GOOD_LOW.U;
    mmcCounters->rxLengthErrorPacketsLow             = geth->gethSFR->PORT[portIndex].CORE.RX_LENGTH_ERROR_PACKETS_LOW.U;
    mmcCounters->rxOutOfRangePacketsLow              = geth->gethSFR->PORT[portIndex].CORE.RX_OUTOFRANGE_PACKETS_LOW.U;
    mmcCounters->rxPausePacketsLow                   = geth->gethSFR->PORT[portIndex].CORE.RX_PAUSE_PACKETS_LOW.U;
    mmcCounters->rxFifoOverflowPacketsLow            = geth->gethSFR->PORT[portIndex].CORE.RX_FIFOOVERFLOW_PACKETS_LOW.U;
    mmcCounters->rxVlanPacketsGoodBadLow             = geth->gethSFR->PORT[portIndex].CORE.RX_VLAN_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rxWatchdogErrorPackets              = geth->gethSFR->PORT[portIndex].CORE.RX_WATCHDOG_ERROR_PACKETS.U;
    mmcCounters->rxLpiUsecCntr                       = geth->gethSFR->PORT[portIndex].CORE.RX_LPI_USEC_CNTR.U;
    mmcCounters->rxLpiTranCntr                       = geth->gethSFR->PORT[portIndex].CORE.RX_LPI_TRAN_CNTR.U;
    mmcCounters->rxDiscardPacketsGoodBadLow          = geth->gethSFR->PORT[portIndex].CORE.RX_DISCARD_PACKETS_GOOD_BAD_LOW.U;
    mmcCounters->rxDiscardOctetsGoodBad64            = (uint64)(geth->gethSFR->PORT[portIndex].CORE.RX_DISCARD_OCTETS_GOOD_BAD_LOW.U);
    mmcCounters->rxDiscardOctetsGoodBad64           |= (((uint64)(geth->gethSFR->PORT[portIndex].CORE.RX_DISCARD_OCTETS_GOOD_BAD_HIGH.U)) << 32);
    mmcCounters->rxAligmentErrorPackets              = geth->gethSFR->PORT[portIndex].CORE.RX_ALIGNMENT_ERROR_PACKETS.U;
    mmcCounters->sgfPassPktCnt                       = geth->gethSFR->PORT[portIndex].CORE.SGF_PASS_PKTCNT.U;
    mmcCounters->sgfFailPktCnt                       = geth->gethSFR->PORT[portIndex].CORE.SGF_FAIL_PKTCNT.U;
    mmcCounters->mmcTxFpeFragmentCntr                = geth->gethSFR->PORT[portIndex].CORE.MMC_TX_FPE_FRAGMENT_CNTR.U;
    mmcCounters->mmcTxHoldReqCntr                    = geth->gethSFR->PORT[portIndex].CORE.MMC_TX_HOLD_REQ_CNTR.U;
    mmcCounters->mmcRxPacketsAssemblyErrCntr         = geth->gethSFR->PORT[portIndex].CORE.MMC_RX_PACKET_ASSEMBLY_ERR_CNTR.U;
    mmcCounters->mmcRxPacketsSmdErrCntr              = geth->gethSFR->PORT[portIndex].CORE.MMC_RX_PACKET_SMD_ERR_CNTR.U;
    mmcCounters->mmcRxPacketsAssemblyOkCntr          = geth->gethSFR->PORT[portIndex].CORE.MMC_RX_PACKET_ASSEMBLY_OK_CNTR.U;
    mmcCounters->mmcRxFpeFragmentCntr                = geth->gethSFR->PORT[portIndex].CORE.MMC_RX_FPE_FRAGMENT_CNTR.U;
    mmcCounters->txSingleCollisionGoodPackets        = geth->gethSFR->PORT[portIndex].CORE.TX_SINGLE_COLLISION_GOOD_PACKETS.U;
    mmcCounters->txMultipleCollisionGoodPackets      = geth->gethSFR->PORT[portIndex].CORE.TX_MULTIPLE_COLLISION_GOOD_PACKETS.U;
    mmcCounters->txDeferredPackets                   = geth->gethSFR->PORT[portIndex].CORE.TX_DEFERRED_PACKETS.U;
    mmcCounters->txLateCollisionPackets              = geth->gethSFR->PORT[portIndex].CORE.TX_LATE_COLLISION_PACKETS.U;
    mmcCounters->txExcessiveCollisionPackets         = geth->gethSFR->PORT[portIndex].CORE.TX_EXCESSIVE_COLLISION_PACKETS.U;
    mmcCounters->txCarrierErrorPackets               = geth->gethSFR->PORT[portIndex].CORE.TX_CARRIER_ERROR_PACKETS.U;
    mmcCounters->txExcessiveDeferralError            = geth->gethSFR->PORT[portIndex].CORE.TX_EXCESSIVE_DEFERRAL_ERROR.U;
    mmcCounters->rxIpV4GoodPacketsLow                = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_GOOD_PACKETS_LOW.U,
    mmcCounters->rxIpV4HeaderErrorPacketsLow         = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_HEADER_ERROR_PACKETS_LOW.U;
    mmcCounters->rxIpV4NoPayloadPacketsLow           = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_NO_PAYLOAD_PACKETS_LOW.U;
    mmcCounters->rxIpV4FragmentedPacketsLow          = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_FRAGMENTED_PACKETS_LOW.U;
    mmcCounters->rxIpV4UdpChecksumDisabledPacketsLow = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_UDP_CHECKSUM_DISABLED_PACKETS_LOW.U;
    mmcCounters->rxIpV6GoodPacketsLow                = geth->gethSFR->PORT[portIndex].CORE.RXIPV6_GOOD_PACKETS_LOW.U;
    mmcCounters->rxIpV6HeaderErrorPacketsLow         = geth->gethSFR->PORT[portIndex].CORE.RXIPV6_HEADER_ERROR_PACKETS_LOW.U;
    mmcCounters->rxIpV6NoPayloadPacketsLow           = geth->gethSFR->PORT[portIndex].CORE.RXIPV6_NO_PAYLOAD_PACKETS_LOW.U;
    mmcCounters->rxUdpRxUdpGoodPacketsLow            = geth->gethSFR->PORT[portIndex].CORE.RXUDP_GOOD_PACKETS_LOW.U;
    mmcCounters->rxUdpErrorPacketsLow                = geth->gethSFR->PORT[portIndex].CORE.RXUDP_ERROR_PACKETS_LOW.U;
    mmcCounters->rxTcpGoodPacketsLow                 = geth->gethSFR->PORT[portIndex].CORE.RXTCP_GOOD_PACKETS_LOW.U;
    mmcCounters->rxTcpErrorPacketsLow                = geth->gethSFR->PORT[portIndex].CORE.RXTCP_ERROR_PACKETS_LOW.U;
    mmcCounters->rxIcmpGoodPacketsLow                = geth->gethSFR->PORT[portIndex].CORE.RXICMP_GOOD_PACKETS_LOW.U;
    mmcCounters->rxIcmpErrorPacketsLow               = geth->gethSFR->PORT[portIndex].CORE.RXICMP_ERROR_PACKETS_LOW.U;
    mmcCounters->rxIpV4GoodOctetsLow                 = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_GOOD_OCTETS_LOW.U;
    mmcCounters->rxIpV4HeaderErrorOctetsLow          = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_HEADER_ERROR_OCTETS_LOW.U;
    mmcCounters->rxIpV4NoPayloadOctetsLow            = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_NO_PAYLOAD_OCTETS_LOW.U;
    mmcCounters->rxIpV4FragmentedOctetsLow           = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_FRAGMENTED_OCTETS_LOW.U;
    mmcCounters->rxIpV4UdpChecksumDisableOctetsLow   = geth->gethSFR->PORT[portIndex].CORE.RXIPV4_UDP_CHECKSUM_DISABLE_OCTETS_LOW.U;
    mmcCounters->rxIpV6GoodOctetsLow                 = geth->gethSFR->PORT[portIndex].CORE.RXIPV6_GOOD_OCTETS_LOW.U;
    mmcCounters->rxIpV6HeaderErrorOctetsLow          = geth->gethSFR->PORT[portIndex].CORE.RXIPV6_HEADER_ERROR_OCTETS_LOW.U;
    mmcCounters->rxIpV6NopayloadOctetsLow            = geth->gethSFR->PORT[portIndex].CORE.RXIPV6_NO_PAYLOAD_OCTETS_LOW.U;
    mmcCounters->rxUdpGoodOctetsLow                  = geth->gethSFR->PORT[portIndex].CORE.RXUDP_GOOD_OCTETS_LOW.U;
    mmcCounters->rxUdpErrorOctetsLow                 = geth->gethSFR->PORT[portIndex].CORE.RXUDP_ERROR_OCTETS_LOW.U;
    mmcCounters->rxTcpGoodOctetsLow                  = geth->gethSFR->PORT[portIndex].CORE.RXTCP_GOOD_OCTETS_LOW.U;
    mmcCounters->rxTcpErrorOctetsLow                 = geth->gethSFR->PORT[portIndex].CORE.RXTCP_ERROR_OCTETS_LOW.U;
    mmcCounters->rxIcmpGoodOctetsLow                 = geth->gethSFR->PORT[portIndex].CORE.RXICMP_GOOD_OCTETS_LOW.U;
    mmcCounters->rxIcmpErrorOctetsLow                = geth->gethSFR->PORT[portIndex].CORE.RXICMP_ERROR_OCTETS_LOW.U;
}


boolean IfxGeth_Eth_initTxContextDescriptor(IfxGeth_Eth *geth, IfxGeth_Eth_TxChannelConfig *config)
{
    boolean                   status    = FALSE;

    IfxGeth_TxDmaChannel      channelId = config->channelId;

    volatile IfxGeth_TxDescr *descr     = IfxGeth_Eth_getActualTxDescriptor(geth, channelId);

    if (descr->TDES3.C.OWN == 1)
    {
        return status; /*Descriptor is not owned by application to modify it*/
    }

    /*Reset descriptor*/
    descr->TDES0.U = 0;
    descr->TDES1.U = 0;
    descr->TDES2.U = 0;
    descr->TDES3.U = 0;

    /*Configure the new context*/
    if (config->contextDescriptorConfig.oneStepTimeStampEnable)                              /*one step timestamp correction*/
    {
        /*Timestamp*/
        descr->TDES0.C.TTSL = (uint32)config->contextDescriptorConfig.timeStamp64;           /* Lower 32 bits */
        descr->TDES1.C.TTSH = (uint32)((config->contextDescriptorConfig.timeStamp64) >> 32); /* Higher 32 bits */

        /*Control Bits*/
        descr->TDES3.C.OSTC   = 1;
        descr->TDES3.C.TCMSSV = 1;
    }

    else if (config->contextDescriptorConfig.twoStepTimeStampEnable) /*two step timestamp*/
    {
        /*10 bit Packet ID in TTSL*/
        descr->TDES0.C.TTSL = config->contextDescriptorConfig.twoStepTimeStampPacketID;

        /*Control Bits*/
        descr->TDES3.C.PIDV = 1;
    }

    if (config->contextDescriptorConfig.innerVlanTagEnable)
    {
        descr->TDES2.C.IVT   = config->contextDescriptorConfig.innerVlanTag;
        descr->TDES3.C.IVLTV = 1;
        descr->TDES3.C.IVTIR = config->contextDescriptorConfig.innerVlanTagControl;
    }

    if (config->contextDescriptorConfig.vlanTagEnable)
    {
        descr->TDES3.C.VT   = config->contextDescriptorConfig.vlanTag; /*Note: Context will be saved internally but to use this vlan tag, VLTI bit of the MAC_VLAN_Incl register must also be set.*/
        descr->TDES3.C.VLTV = 1;
    }

    descr->TDES3.C.CTXT = 1;
    descr->TDES3.C.OWN  = 1;

    while (descr->TDES3.C.OWN) /*Wait till DMA reads and writes back the descriptor*/
    {}

    if (descr->TDES3.C.CDE == FALSE)
    {
        status = TRUE; /* DMA successfully accepted the new context */
    }

    if (status)
    {
        IfxGeth_Eth_shuffleTxDescriptor(geth, channelId);

        geth->gethSFR->DMA.CH[channelId].TXDESC_TAIL_LPOINTER.U = (uint32)geth->txChannel[channelId].txDescrPtr; /*this will sync the GETH cache and release descriptor*/

        /*Save the newly accepted context for reference during next modification of context, if some of the sub features have to be kept same as previously configured*/
        /*One Step Timestamp*/
        geth->txChannel[channelId].contextDescriptorConfig.oneStepTimeStampEnable   = config->contextDescriptorConfig.oneStepTimeStampEnable;
        geth->txChannel[channelId].contextDescriptorConfig.timeStamp64              = config->contextDescriptorConfig.timeStamp64;
        /*Two Step Timestamp*/
        geth->txChannel[channelId].contextDescriptorConfig.twoStepTimeStampEnable   = config->contextDescriptorConfig.twoStepTimeStampEnable;
        geth->txChannel[channelId].contextDescriptorConfig.twoStepTimeStampPacketID = config->contextDescriptorConfig.twoStepTimeStampPacketID;
        /*Vlan Tag*/
        geth->txChannel[channelId].contextDescriptorConfig.vlanTag                  = config->contextDescriptorConfig.vlanTag;
        geth->txChannel[channelId].contextDescriptorConfig.vlanTagEnable            = config->contextDescriptorConfig.vlanTagEnable;
        /*Inner Vlan Tag*/
        geth->txChannel[channelId].contextDescriptorConfig.innerVlanTagControl      = config->contextDescriptorConfig.innerVlanTagControl;
        geth->txChannel[channelId].contextDescriptorConfig.innerVlanTag             = config->contextDescriptorConfig.innerVlanTag;
        geth->txChannel[channelId].contextDescriptorConfig.innerVlanTagEnable       = config->contextDescriptorConfig.innerVlanTagEnable;
    }

    return status;
}


void IfxGeth_Eth_initTxTrafficClass(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_TxTrafficClassConfig *config)
{
    IfxGeth_TxTrafficClassType   trafficClassType               = IfxGeth_cfg_trafficClassMap[portIndex][config->tcIndex].type;

    uint32                      *baseAddressOfTrafficClassGroup = (uint32 *)IfxGeth_cfg_trafficClassMap[portIndex][config->tcIndex].trafficClassAddress;

    IfxGeth_PortMtlTcEtsControl *tcEtsControl                   = (IfxGeth_PortMtlTcEtsControl *)(baseAddressOfTrafficClassGroup + 0x10);

    tcEtsControl->U     = 0;
    tcEtsControl->B.TSA = config->algorithm;

    if (trafficClassType == IfxGeth_TxTrafficClassType_1)
    {   /*Bitfields configured are available in SFR if trafficClassType == IfxGeth_TxTrafficClassType_1 */
        if (config->algorithm == IfxGeth_TxTransmissionSelectionAlgorithm_cbs)
        {
            tcEtsControl->B.CC  = config->creditControl;
            tcEtsControl->B.SLC = config->slotCount; /*Applies to AVB*/
        }
    }

    if (config->algorithm == IfxGeth_TxTransmissionSelectionAlgorithm_ets)
    {
        geth->gethSFR->PORT[portIndex].MTL.OPERATION_MODE.B.ETSALG = 0; /*Only ETSALG = 0 (WRR Algorithm) is supported by H/w. Remaining values are reserved.*/
    }

    IfxGeth_PortMtlTcQuantumWeight *tcQuantumWeight = (IfxGeth_PortMtlTcQuantumWeight *)(baseAddressOfTrafficClassGroup + 0x18);

    tcQuantumWeight->U = 0;

    if (config->algorithm == IfxGeth_TxTransmissionSelectionAlgorithm_ets)
    {
        if (config->wrrWeight <= 100)
        {
            tcQuantumWeight->B.QW = (uint32)config->wrrWeight;  /* Applies for ETSALG = 0 (WRR Algorithm). Max Value = 100 (0x64) */
        }
    }

    else if (config->algorithm == IfxGeth_TxTransmissionSelectionAlgorithm_cbs)
    {
        if (config->tcIndex != IfxGeth_TxTrafficClass_0) /* Bit is not applicable to TC0, TC0 does not support CBS */
        {
            tcQuantumWeight->B.QW = (uint32)config->cbsIdleSlopeCredit;
        }
    }

    if (trafficClassType == IfxGeth_TxTrafficClassType_1)
    {   /*Registers configured in this section are available in SFR if trafficClassType == IfxGeth_TxTrafficClassType_1 */
        IfxGeth_PortMtlTcSendSlopeCredit *tcSendSlopeCredit = (IfxGeth_PortMtlTcSendSlopeCredit *)(baseAddressOfTrafficClassGroup + 0x1C);
        IfxGeth_PortMtlTcHiCredit        *tcHiCredit        = (IfxGeth_PortMtlTcHiCredit *)(baseAddressOfTrafficClassGroup + 0x20);
        IfxGeth_PortMtlTcLoCredit        *tcLoCredit        = (IfxGeth_PortMtlTcLoCredit *)(baseAddressOfTrafficClassGroup + 0x24);

        tcSendSlopeCredit->U     = 0;
        tcHiCredit->U            = 0;
        tcLoCredit->U            = 0;

        tcSendSlopeCredit->B.SSC = config->cbsSendSlopeCredit;
        tcHiCredit->B.HC         = config->cbsHiCredit;
        tcLoCredit->B.LC         = config->cbsLoCredit;
    }
}


void IfxGeth_Eth_initTimeStamp(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_TimeStampConfig *config)
{
    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSENA     = 1;

    geth->gethSFR->PORT[portIndex].CORE.MAC_SUB_SECOND_INCREMENT.B.SSINC  = config->subSecondIncrementValue;
    geth->gethSFR->PORT[portIndex].CORE.MAC_SUB_SECOND_INCREMENT.B.SNSINC = config->subNanoSecondIncrementValue;

    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSCFUPDT  = config->updateMethod;

    while (geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSINIT) /*Wait till H/w resets the bit*/
    {}

    geth->gethSFR->PORT[portIndex].CORE.MAC_SYSTEM_TIME_SECONDS_UPDATE.U            = config->seconds;
    geth->gethSFR->PORT[portIndex].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.TSSS   = config->subSeconds;
    geth->gethSFR->PORT[portIndex].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.ADDSUB = 0; /* Bit is irrelevant for init (used only for update mode), configuring reset value. */
    geth->gethSFR->PORT[portIndex].CORE.MAC_SYSTEM_TIME_HIGHER_WORD_SECONDS.B.TSHWR = config->highWordSeconds;

    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSINIT              = 1;

    while (geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSINIT) /*Wait till H/w resets the bit and initialization is complete*/
    {}

    /*One Step TimeStamp Config*/
    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_INGRESS_ASYM_CORR.B.OSTIAC = config->ingressAsymCorrection;
    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_EGRESS_ASYM_CORR.B.OSTEAC  = config->egressAsymCorrection;

    Ifx_GETH_PORT_CORE_MAC_TIMESTAMP_CONTROL timestampControl;
    timestampControl.U                                                                     = geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.U;

    timestampControl.B.TSENALL                                                             = config->enableForAllPackets;
    timestampControl.B.TSCTRLSSR                                                           = config->rolloverControl;
    timestampControl.B.TSVER2ENA                                                           = config->ptpVersion;

    timestampControl.B.TSIPENA                                                             = config->enablePtpOverEthernet;
    timestampControl.B.TSIPV6ENA                                                           = config->enablePtpOverIpv6Udp;
    timestampControl.B.TSIPV4ENA                                                           = config->enablePtpOverIpv4Udp;

    timestampControl.B.TSEVNTENA                                                           = config->snapshotMessageControl;
    timestampControl.B.TSMSTRENA                                                           = config->snapshotNodeControl;
    timestampControl.B.SNAPTYPSEL                                                          = config->snapshotType;

    timestampControl.B.TSENMACADDR                                                         = config->enableMacAddressFilter;
    timestampControl.B.CSC                                                                 = config->enableOstChecksumCorrection;

    timestampControl.B.ESTI                                                                = config->systemTimeSource;
    timestampControl.B.TXTSSTSM                                                            = config->txTimeStampUpdateMode;
    timestampControl.B.AV8021ASMEN                                                         = config->enableAvIeee8021AsMode;

    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.U                            = timestampControl.U;

    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_INGRESS_CORR_NANOSECOND.B.TSIC       = config->ingressCorrectionNanoSeconds;
    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_INGRESS_CORR_SUBNANOSECOND.B.TSICSNS = config->ingressCorrectionSubNanoSeconds;
    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_EGRESS_CORR_NANOSECOND.B.TSEC        = config->egressCorrectionNanoSeconds;
    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_EGRESS_CORR_SUBNANOSECOND.B.TSECSNS  = config->egressCorrectionSubNanoSeconds;
    geth->gethSFR->BRIDGE.PORT_FLUSH_AND_LOOPBACK_CONTROL.B.PTP_PORT_NUM                   = portIndex;
}


void IfxGeth_Eth_updateSystemTime(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_UpdateSystemTimeConfig *config)
{
    while (geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSUPDT) /*Wait till H/w resets the bit*/
    {}

    geth->gethSFR->PORT[portIndex].CORE.MAC_SYSTEM_TIME_SECONDS_UPDATE.U            = config->seconds;
    geth->gethSFR->PORT[portIndex].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.TSSS   = config->subSeconds;
    geth->gethSFR->PORT[portIndex].CORE.MAC_SYSTEM_TIME_NANOSECONDS_UPDATE.B.ADDSUB = config->addSubControl;

    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSUPDT              = 1;

    while (geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSUPDT) /*Wait till H/w resets the bit and coarse update is complete */
    {}
}


void IfxGeth_Eth_updateTimeStampAddend(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint32 value)
{
    while (geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSADDREG)  /*Wait till H/w resets the bit*/
    {}

    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_ADDEND.B.TSAR      = value; /* Applies to Fine Update Method only*/

    geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSADDREG = 1;

    while (geth->gethSFR->PORT[portIndex].CORE.MAC_TIMESTAMP_CONTROL.B.TSADDREG) /*Wait till H/w resets the bit */
    {}
}


void IfxGeth_Eth_initPPS(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_PPSConfig *config)
{
    if (config->modePPS0 == 0)                                                                          /*Fixed Mode*/
    {
        geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.PPSCTRL0_PPSCMD0 = config->frequencyPPS0; /*Frequency config*/
    }

    geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.TRGTMODSEL0 = config->targetTimeModePPS0;
    geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.TRGTMODSEL1 = config->targetTimeModePPS1;

    geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.PPSEN0      = config->modePPS0;
    geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.PPSEN1      = config->modePPS1;

    if (portIndex == IfxGeth_PortIndex_0)
    {
        if (config->interruptConfigPPS0.priority > 0)
        {
            volatile Ifx_SRC_SRCR *srcSFR;
            srcSFR = IfxGeth_getSrcPointer(IfxGeth_ServiceRequest_PPS_0); /* Port 0 PPS Line 0 */
            IfxSrc_init(srcSFR, config->interruptConfigPPS0.provider, config->interruptConfigPPS0.priority, config->interruptConfigPPS0.vmId);
            IfxSrc_enable(srcSFR);
        }

        if (config->interruptConfigPPS1.priority > 0)
        {
            volatile Ifx_SRC_SRCR *srcSFR;
            srcSFR = IfxGeth_getSrcPointer(IfxGeth_ServiceRequest_PPS_1);  /* Port 0 PPS Line 1 */
            IfxSrc_init(srcSFR, config->interruptConfigPPS1.provider, config->interruptConfigPPS1.priority, config->interruptConfigPPS1.vmId);
            IfxSrc_enable(srcSFR);
        }
    }
    else if (portIndex == IfxGeth_PortIndex_1)
    {
        if (config->interruptConfigPPS0.priority > 0)
        {
            volatile Ifx_SRC_SRCR *srcSFR;
            srcSFR = IfxGeth_getSrcPointer(IfxGeth_ServiceRequest_PPS_2); /* Port 1 PPS Line 0 */
            IfxSrc_init(srcSFR, config->interruptConfigPPS0.provider, config->interruptConfigPPS0.priority, config->interruptConfigPPS0.vmId);
            IfxSrc_enable(srcSFR);
        }

        if (config->interruptConfigPPS1.priority > 0)
        {
            volatile Ifx_SRC_SRCR *srcSFR;
            srcSFR = IfxGeth_getSrcPointer(IfxGeth_ServiceRequest_PPS_3); /* Port 1 PPS Line 1 */
            IfxSrc_init(srcSFR, config->interruptConfigPPS1.provider, config->interruptConfigPPS1.priority, config->interruptConfigPPS1.vmId);
            IfxSrc_enable(srcSFR);
        }
    }
}


void IfxGeth_Eth_flexiblePPSControl(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FlexiblePPSConfig *config)
{
    if (config->configurePPS0)
    {
        if ((config->controlPPS0 == IfxGeth_FlexiblePPSControl_startSinglePulse) || (config->controlPPS0 == IfxGeth_FlexiblePPSControl_startPulseTrain) || (config->controlPPS0 == IfxGeth_FlexiblePPSControl_timedStopPulseTrain))
        {
            while (geth->gethSFR->PORT[portIndex].CORE.MAC_PPS0_TARGET_TIME_NANOSECONDS.B.TTSL0) /*Wait for previous time synchronization to complete*/
            {}

            geth->gethSFR->PORT[portIndex].CORE.MAC_PPS0_TARGET_TIME_SECONDS.U           = config->targetTimeSecondsPPS0;
            geth->gethSFR->PORT[portIndex].CORE.MAC_PPS0_TARGET_TIME_NANOSECONDS.B.TTSL0 = config->targetTimeNanoSecondsPPS0;

            if ((config->controlPPS0 == IfxGeth_FlexiblePPSControl_startSinglePulse) || (config->controlPPS0 == IfxGeth_FlexiblePPSControl_startPulseTrain))
            {
                geth->gethSFR->PORT[portIndex].CORE.MAC_PPS0_WIDTH.U = config->pulseWidthPPS0;

                if (config->controlPPS0 == IfxGeth_FlexiblePPSControl_startPulseTrain)
                {
                    geth->gethSFR->PORT[portIndex].CORE.MAC_PPS0_INTERVAL.U = config->pulseIntervalPPS0;
                }
            }
        }

        /*Wait until H/w clears the bitfield*/
        while (geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.PPSCTRL0_PPSCMD0 != 0)
        {}

        geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.PPSCTRL0_PPSCMD0 = config->controlPPS0; /* Non-zero value initiates an event */
    }

    if (config->configurePPS1)
    {
        if ((config->controlPPS1 == IfxGeth_FlexiblePPSControl_startSinglePulse) || (config->controlPPS1 == IfxGeth_FlexiblePPSControl_startPulseTrain) || (config->controlPPS1 == IfxGeth_FlexiblePPSControl_timedStopPulseTrain))
        {
            while (geth->gethSFR->PORT[portIndex].CORE.MAC_PPS1_TARGET_TIME_NANOSECONDS.B.TTSL1) /*Wait for previous time synchronization to complete*/
            {}

            geth->gethSFR->PORT[portIndex].CORE.MAC_PPS1_TARGET_TIME_SECONDS.U           = config->targetTimeSecondsPPS1;
            geth->gethSFR->PORT[portIndex].CORE.MAC_PPS1_TARGET_TIME_NANOSECONDS.B.TTSL1 = config->targetTimeNanoSecondsPPS1;

            if ((config->controlPPS1 == IfxGeth_FlexiblePPSControl_startSinglePulse) || (config->controlPPS1 == IfxGeth_FlexiblePPSControl_startPulseTrain))
            {
                geth->gethSFR->PORT[portIndex].CORE.MAC_PPS1_WIDTH.U = config->pulseWidthPPS1;

                if (config->controlPPS1 == IfxGeth_FlexiblePPSControl_startPulseTrain)
                {
                    geth->gethSFR->PORT[portIndex].CORE.MAC_PPS1_INTERVAL.U = config->pulseIntervalPPS1;
                }
            }
        }

        /*Wait until H/w clears the bitfield*/
        while (geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.PPSCMD1 != 0)
        {}

        geth->gethSFR->PORT[portIndex].CORE.MAC_PPS_CONTROL.B.PPSCMD1 = config->controlPPS1; /* Non-zero value initiates an event */
    }
}


boolean IfxGeth_Eth_getTxDescriptorStatus(IfxGeth_Eth *geth, IfxGeth_TxDescr *txDescrPtr, IfxGeth_Eth_TxDescStatus *status)
{
    boolean statusAvailable = FALSE;

    if (txDescrPtr->TDES3.W.OWN == 0) /*DMA has processed and closed the descriptor*/
    {
        status->own                 = 0;
        status->error               = txDescrPtr->TDES3.W.DERR;
        status->isLastDescriptor    = txDescrPtr->TDES3.W.LD;
        status->isFirstDescriptor   = txDescrPtr->TDES3.W.FD;
        status->isContextDescriptor = txDescrPtr->TDES3.W.CTXT;

        statusAvailable             = TRUE; /* status is available only after DMA processes and closes the descriptor and assigns it back to application */
    }
    else
    {
        status->own = 1; /* Still owned by descriptor */
    }

    return statusAvailable;
}


boolean IfxGeth_Eth_getRxDescriptorStatus(IfxGeth_Eth *geth, IfxGeth_RxDescr *rxDescrPtr, IfxGeth_Eth_RxDescStatus *status)
{
    boolean statusAvailable = FALSE;

    if (rxDescrPtr->RDES3.W.OWN == 0)      /*DMA has processed and closed the descriptor*/
    {
        if (rxDescrPtr->RDES3.W.CTXT == 0) /*Normal descriptor*/
        {
            status->normal.OWN    = 0;

            status->normal.OVT    = rxDescrPtr->RDES0.W.OVT;
            status->normal.IVT    = rxDescrPtr->RDES0.W.IVT;

            status->normal.FRPLI  = rxDescrPtr->RDES1.W.FRPLI;

            status->normal.AVTCP  = rxDescrPtr->RDES2.W.AVTCP;
            status->normal.AVTDP  = rxDescrPtr->RDES2.W.AVTDP;

            status->normal.HL     = rxDescrPtr->RDES2.W.HL;

            status->normal.FRPSM  = rxDescrPtr->RDES2.W.FRPSM;

            status->normal.VF     = rxDescrPtr->RDES2.W.VF;
            status->normal.SAF    = rxDescrPtr->RDES2.W.SAF;
            status->normal.DAF    = rxDescrPtr->RDES2.W.DAF;
            status->normal.MADRM  = rxDescrPtr->RDES2.W.MADRM;
            status->normal.L3FM   = rxDescrPtr->RDES2.W.L3FM;
            status->normal.L4FM   = rxDescrPtr->RDES2.W.L4FM;
            status->normal.L3L4FM = rxDescrPtr->RDES2.W.L3L4FM;

            status->normal.PL     = rxDescrPtr->RDES3.W.PL;
            status->normal.FRPSL  = rxDescrPtr->RDES3.W.FRPSL;
            status->normal.ES     = rxDescrPtr->RDES3.W.ES;
            status->normal.ET_LT  = rxDescrPtr->RDES3.W.ET_LT;
            status->normal.L34T   = rxDescrPtr->RDES3.W.L34T;
            status->normal.ETM    = rxDescrPtr->RDES3.W.ETM;
            status->normal.CDA    = rxDescrPtr->RDES3.W.CDA;
            status->normal.LD     = rxDescrPtr->RDES3.W.LD;
            status->normal.FD     = rxDescrPtr->RDES3.W.FD;
            status->normal.CTXT   = rxDescrPtr->RDES3.W.CTXT;
        }
        else
        {
            status->context.OWN  = 0;

            status->context.RTSL = rxDescrPtr->RDES0.C.RTSL;
            status->context.RTSH = rxDescrPtr->RDES1.C.RTSH;

            status->context.PMT  = rxDescrPtr->RDES3.C.PMT;
            status->context.TSA  = rxDescrPtr->RDES3.C.TSA;
            status->context.TSD  = rxDescrPtr->RDES3.C.TSD;
            status->context.CTXT = rxDescrPtr->RDES3.C.CTXT;
        }

        statusAvailable = TRUE; /* status is available only after DMA processes and closes the descriptor and assigns it back to application */
    }

    return statusAvailable;
}


void IfxGeth_Eth_dmaAvbChannelSlotFunctionInit(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId, boolean enable, boolean advanceSlotCheckEnable)
{
    /* Optional Advanced AVB Feature: AVB Slot-number based Transmit. */
    geth->gethSFR->DMA.CH[channelId].SLOT_FUNCTION_CONTROL_STATUS.B.ESC = enable;

    if (enable)
    {
        geth->gethSFR->DMA.CH[channelId].SLOT_FUNCTION_CONTROL_STATUS.B.ASC = advanceSlotCheckEnable;
    }
}


IfxGeth_L3L4FilterStatus IfxGeth_Eth_initLayer4Filtering(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_L4FilterConfig *config)
{
    boolean                                status = TRUE;
    Ifx_GETH_PORT_CORE_MAC_L3_L4_CONTROL0  filterCtrlReg;
    Ifx_GETH_PORT_CORE_MAC_LAYER4_ADDRESS0 filterAddr;

    if ((config->filterSrcPortMatch == IfxGeth_L4FilterSrcPortMatch_enable) || (config->filterDstPortMatch == IfxGeth_L4FilterDstPortMatch_enable))
    {
        status = IfxGeth_L3L4FilterStatus_invalidConfig;
    }

    filterAddr.U           = 0;
    filterCtrlReg.U        = 0;
    filterCtrlReg.B.L4PEN0 = config->filterProtocolEnable;

    if (config->filterSrcPortMatch == IfxGeth_L4FilterSrcPortMatch_enable)
    {
        filterCtrlReg.B.L4SPM0  = config->filterSrcPortMatch;
        filterCtrlReg.B.L4SPIM0 = config->filterSrcPortInvMatch;
        filterAddr.B.L4SP0      = config->filterSrcPortNum;
    }

    if (config->filterDstPortMatch == IfxGeth_L4FilterDstPortMatch_enable)
    {
        filterCtrlReg.B.L4DPM0  = config->filterDstPortMatch;
        filterCtrlReg.B.L4DPIM0 = config->filterDstPortInvMatch;
        filterAddr.B.L4DP0      = config->filterDstPortNum;
    }

    filterCtrlReg.B.DMCHEN = config->filterChannelSel;

    if (config->filterChannelSel == IfxGeth_L3L4FilterChannelSel_enable)
    {
        filterCtrlReg.B.DMCHN = config->filterChannel;
    }

    if ((config->filterSrcPortMatch == IfxGeth_L4FilterSrcPortMatch_enable) || (config->filterDstPortMatch == IfxGeth_L4FilterDstPortMatch_enable))
    {
        /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_L3_L4_CONTROL#(i)*/
        IfxGeth_ReadWriteL3L4RegConfig regWriteCtrlConfig;
        regWriteCtrlConfig.filterNum        = config->filterNum;
        regWriteCtrlConfig.filterRegType    = IfxGeth_L3L4FilterRegType_controlReg;
        regWriteCtrlConfig.regReadWriteData = filterCtrlReg.U;
        regWriteCtrlConfig.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

        status                              = IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteCtrlConfig);

        /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_LAYER4_ADDRESS#(i)*/
        IfxGeth_ReadWriteL3L4RegConfig regWriteAddrConfig;
        regWriteAddrConfig.filterNum        = config->filterNum;
        regWriteAddrConfig.filterRegType    = IfxGeth_L3L4FilterRegType_l4AddrReg;
        regWriteAddrConfig.regReadWriteData = filterAddr.U;
        regWriteAddrConfig.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

        status                              = status || IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteAddrConfig);
    }

    return (status) ? IfxGeth_L3L4FilterStatus_timeoutError : IfxGeth_L3L4FilterStatus_success;
}


IfxGeth_L3L4FilterStatus IfxGeth_Eth_initL3FilteringIPv6(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_L3FilterIPv6Config *config)
{
    boolean                                  status;
    Ifx_GETH_PORT_CORE_MAC_L3_L4_CONTROL0    filterCtrlReg;
    Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR0_REG0 filterAddr0;
    Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR1_REG0 filterAddr1;
    Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR2_REG0 filterAddr2;
    Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR3_REG0 filterAddr3;

    filterAddr0.U          = 0;
    filterAddr1.U          = 0;
    filterAddr2.U          = 0;
    filterAddr3.U          = 0;

    filterCtrlReg.U        = 0;
    filterCtrlReg.B.L3PEN0 = IfxGeth_L3FilterProtocolEnable_ipV6;

    /* For Layer3 filtering for IPv6 frame format either of Source Addr or Destination Addr filtering should be enable*/
    if ((config->filterSrcAddrMatch == IfxGeth_L3FilterSrcAddrMatch_enable) && (config->filterDstAddrMatch == IfxGeth_L3FilterDstAddrMatch_disable))
    {
        filterCtrlReg.B.L3SAM0  = config->filterSrcAddrMatch;
        filterCtrlReg.B.L3SAIM0 = config->filterSrcAddrInvMatch;
    }
    else if ((config->filterDstAddrMatch == IfxGeth_L3FilterDstAddrMatch_enable) && (config->filterSrcAddrMatch == IfxGeth_L3FilterSrcAddrMatch_disable))
    {
        filterCtrlReg.B.L3DAM0  = config->filterDstAddrMatch;
        filterCtrlReg.B.L3DAIM0 = config->filterDstAddrInvMatch;
    }
    else
    {
        return IfxGeth_L3L4FilterStatus_invalidConfig;
    }

    filterCtrlReg.B.L3HSBM0 = (31 & (config->filterSrcDstAddrMask));
    filterCtrlReg.B.L3HDBM0 = (3 & ((config->filterSrcDstAddrMask) >> 5));
    filterCtrlReg.B.DMCHEN  = config->filterChannelSel;

    if (config->filterChannelSel == IfxGeth_L3L4FilterChannelSel_enable)
    {
        filterCtrlReg.B.DMCHN = config->filterChannel;
    }

    filterAddr0.U = config->filterSrcDstAddr0;
    filterAddr1.U = config->filterSrcDstAddr1;
    filterAddr2.U = config->filterSrcDstAddr2;
    filterAddr3.U = config->filterSrcDstAddr3;

    /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_L3_L4_CONTROL#(i)*/
    IfxGeth_ReadWriteL3L4RegConfig regWriteCtrlConfig;
    regWriteCtrlConfig.filterNum        = config->filterNum;
    regWriteCtrlConfig.filterRegType    = IfxGeth_L3L4FilterRegType_controlReg;
    regWriteCtrlConfig.regReadWriteData = filterCtrlReg.U;
    regWriteCtrlConfig.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

    status                              = IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteCtrlConfig);

    /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR0_REG#(i)*/
    IfxGeth_ReadWriteL3L4RegConfig regWriteAddr0Config;
    regWriteAddr0Config.filterNum        = config->filterNum;
    regWriteAddr0Config.filterRegType    = IfxGeth_L3L4FilterRegType_l3Addr0Reg;
    regWriteAddr0Config.regReadWriteData = filterAddr0.U;
    regWriteAddr0Config.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

    status                               = status || IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteAddr0Config);

    /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR1_REG#(i)*/
    IfxGeth_ReadWriteL3L4RegConfig regWriteAddr1Config;
    regWriteAddr1Config.filterNum        = config->filterNum;
    regWriteAddr1Config.filterRegType    = IfxGeth_L3L4FilterRegType_l3Addr1Reg;
    regWriteAddr1Config.regReadWriteData = filterAddr1.U;
    regWriteAddr1Config.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

    status                               = status || IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteAddr1Config);

    /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR2_REG#(i)*/
    IfxGeth_ReadWriteL3L4RegConfig regWriteAddr2Config;
    regWriteAddr2Config.filterNum        = config->filterNum;
    regWriteAddr2Config.filterRegType    = IfxGeth_L3L4FilterRegType_l3Addr2Reg;
    regWriteAddr2Config.regReadWriteData = filterAddr2.U;
    regWriteAddr2Config.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

    status                               = status || IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteAddr2Config);

    /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR3_REG#(i)*/
    IfxGeth_ReadWriteL3L4RegConfig regWriteAddr3Config;
    regWriteAddr3Config.filterNum        = config->filterNum;
    regWriteAddr3Config.filterRegType    = IfxGeth_L3L4FilterRegType_l3Addr3Reg;
    regWriteAddr3Config.regReadWriteData = filterAddr3.U;
    regWriteAddr3Config.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

    status                               = status || IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteAddr3Config);

    return (status) ? IfxGeth_L3L4FilterStatus_timeoutError : IfxGeth_L3L4FilterStatus_success;
}


boolean IfxGeth_Eth_initL3FilteringIPv4(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_L3FilterIPv4Config *config)
{
    boolean                                  status;
    Ifx_GETH_PORT_CORE_MAC_L3_L4_CONTROL0    filterCtrlReg;
    Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR0_REG0 filterSrcAddr;
    Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR1_REG0 filterDstAddr;
    filterCtrlReg.U        = 0;
    filterSrcAddr.U        = 0;
    filterDstAddr.U        = 0;

    filterCtrlReg.B.L3PEN0 = IfxGeth_L3FilterProtocolEnable_ipV4;
    filterCtrlReg.B.L3SAM0 = config->filterSrcAddrMatch;
    filterCtrlReg.B.L3DAM0 = config->filterDstAddrMatch;

    if (config->filterSrcAddrMatch == IfxGeth_L3FilterSrcAddrMatch_enable)
    {
        filterCtrlReg.B.L3SAIM0 = config->filterSrcAddrInvMatch;
        filterCtrlReg.B.L3HSBM0 = config->filterSrcAddrMask;
        filterSrcAddr.U         = config->filterSrcAddr;
    }

    if (config->filterDstAddrMatch == IfxGeth_L3FilterDstAddrMatch_enable)
    {
        filterCtrlReg.B.L3DAIM0 = config->filterDstAddrInvMatch;
        filterCtrlReg.B.L3HDBM0 = config->filterDstAddrMask;
        filterDstAddr.U         = config->filterDstAddr;
    }

    filterCtrlReg.B.DMCHEN = config->filterChannelSel;

    if (config->filterChannelSel == IfxGeth_L3L4FilterChannelSel_enable)
    {
        filterCtrlReg.B.DMCHN = config->filterChannel;
    }

    /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_L3_L4_CONTROL#(i)*/
    IfxGeth_ReadWriteL3L4RegConfig regWriteCtrlConfig;
    regWriteCtrlConfig.filterNum        = config->filterNum;
    regWriteCtrlConfig.filterRegType    = IfxGeth_L3L4FilterRegType_controlReg;
    regWriteCtrlConfig.regReadWriteData = filterCtrlReg.U;
    regWriteCtrlConfig.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;

    status                              = IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteCtrlConfig);

    if (config->filterSrcAddrMatch == IfxGeth_L3FilterSrcAddrMatch_enable)
    {
        /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR0_REG#(i)*/
        IfxGeth_ReadWriteL3L4RegConfig regWriteAddr0Config;
        regWriteAddr0Config.filterNum        = config->filterNum;
        regWriteAddr0Config.filterRegType    = IfxGeth_L3L4FilterRegType_l3Addr0Reg;
        regWriteAddr0Config.regReadWriteData = filterSrcAddr.U;
        regWriteAddr0Config.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;
        status                               = status || IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteAddr0Config);
    }

    if (config->filterDstAddrMatch == IfxGeth_L3FilterDstAddrMatch_enable)
    {
        /*To access indirect register write to Ifx_GETH_PORT_CORE_MAC_LAYER3_ADDR1_REG#(i)*/
        IfxGeth_ReadWriteL3L4RegConfig regWriteAddr1Config;
        regWriteAddr1Config.filterNum        = config->filterNum;
        regWriteAddr1Config.filterRegType    = IfxGeth_L3L4FilterRegType_l3Addr1Reg;
        regWriteAddr1Config.regReadWriteData = filterDstAddr.U;
        regWriteAddr1Config.transferType     = IfxGeth_L3L4FilterCtrlTransferType_write;
        status                               = status || IfxGeth_indirectReadWriteL3L4FilterReg(geth->gethSFR, portIndex, &regWriteAddr1Config);
    }

    return status;
}


IfxGeth_RwkConfigStatus IfxGeth_Eth_initRwkMode(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_RemoteWakeUpConfig *config)
{
    IfxGeth_RwkConfigStatus                   globalStatus = IfxGeth_RwkConfigStatus_success;
    uint8                                     index        = 0;
    Ifx_GETH_PORT_CORE_MAC_PMT_CONTROL_STATUS regPmtCtrl;
    regPmtCtrl.U = 0;

    /*To clear the PMTIS status bit*/
    if (geth->gethSFR->PORT[portIndex].CORE.MAC_CSR_SW_CTRL.B.RCWE == 1)
    {
        geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.U = IFXGETH_PMT_STATUS_CLEAR;
    }
    else
    {
        regPmtCtrl.U = geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.U;
        regPmtCtrl.U = 0;
    }

    geth->gethSFR->PORT[portIndex].CORE.MAC_INTERRUPT_ENABLE.B.PMTIE = config->rwkInterruptEnable;

    regPmtCtrl.B.MGKPKTEN                                            = config->magicPktEnable;
    regPmtCtrl.B.GLBLUCAST                                           = config->unicastPktEnable;
    regPmtCtrl.B.RWKPKTEN                                            = config->rwkPktEnable;
    regPmtCtrl.B.RWKPFE                                              = config->rwkPktFwdEnable;

    /* Before enabling PWRDWN bit either of Magic Packet Enable, Global Unicast, or Remote Wake-Up Packet Enable bit should be set high*/
    if (config->powerDownEnable == FALSE)
    {
        regPmtCtrl.B.PWRDWN                                          = config->powerDownEnable;
        geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.U = regPmtCtrl.U;
    }
    else if ((config->magicPktEnable == TRUE) || (config->rwkPktEnable == TRUE) || (config->unicastPktEnable == TRUE))
    {
        regPmtCtrl.B.PWRDWN = config->powerDownEnable;

        /*To reset the remote wake-up filter pointer to NULL*/
        IfxGeth_resetRwkFilterPtr(geth->gethSFR, portIndex);
        boolean status = FALSE;

        for (index = 0; index < IFXGETH_NUM_RWKUP_FILTER_BLOCK; index++)
        {
            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_crc0_1))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER0_1_CRC crcRwkFilterReg01;
                crcRwkFilterReg01.U             = 0;
                crcRwkFilterReg01.B.FILTER0_CRC = config->rwkFilterConfig[index]->crcHashValue[0];
                crcRwkFilterReg01.B.FILTER1_CRC = config->rwkFilterConfig[index]->crcHashValue[1];
                status                         |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_crc0_1, crcRwkFilterReg01.U);
            }

            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_cmd0_3))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER0_3_COMMAND cmdRwkFilterReg03;
                cmdRwkFilterReg03.U                 = 0;
                cmdRwkFilterReg03.B.FILTER0_COMMAND = (uint32)((config->rwkFilterConfig[index]->cmdControlFilter[0].rwkUpFilterEnable) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[0].previousAndEnable)) << 1) | \
                                                               (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[0].crcInverseModeSelect)) << 2) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[0].dstAddrTypeSelect)) << 3));
                cmdRwkFilterReg03.B.FILTER1_COMMAND = (uint32)((config->rwkFilterConfig[index]->cmdControlFilter[1].rwkUpFilterEnable) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[1].previousAndEnable)) << 1) | \
                                                               (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[1].crcInverseModeSelect)) << 2) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[1].dstAddrTypeSelect)) << 3));
                cmdRwkFilterReg03.B.FILTER2_COMMAND = (uint32)((config->rwkFilterConfig[index]->cmdControlFilter[2].rwkUpFilterEnable) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[2].previousAndEnable)) << 1) | \
                                                               (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[2].crcInverseModeSelect)) << 2) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[2].dstAddrTypeSelect)) << 3));
                cmdRwkFilterReg03.B.FILTER3_COMMAND = (uint32)((config->rwkFilterConfig[index]->cmdControlFilter[3].rwkUpFilterEnable) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[3].previousAndEnable)) << 1) | \
                                                               (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[3].crcInverseModeSelect)) << 2) | (((uint32)(config->rwkFilterConfig[index]->cmdControlFilter[3].dstAddrTypeSelect)) << 3));
                status                             |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_cmd0_3, cmdRwkFilterReg03.U);
            }

            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_offset0_3))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER0_3_OFFSET offsetRwkFilterReg03;
                offsetRwkFilterReg03.U                = 0;
                offsetRwkFilterReg03.B.FILTER0_OFFSET = config->rwkFilterConfig[index]->offsetIndex[0];
                offsetRwkFilterReg03.B.FILTER1_OFFSET = config->rwkFilterConfig[index]->offsetIndex[1];
                offsetRwkFilterReg03.B.FILTER2_OFFSET = config->rwkFilterConfig[index]->offsetIndex[2];
                offsetRwkFilterReg03.B.FILTER3_OFFSET = config->rwkFilterConfig[index]->offsetIndex[3];

                status                               |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_offset0_3, offsetRwkFilterReg03.U);
            }

            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_mask0))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER0_BYTE_MASK maskRwkFilterReg0;
                maskRwkFilterReg0.U                   = 0;
                maskRwkFilterReg0.B.FILTER0_BYTE_MASK = config->rwkFilterConfig[index]->maskByteIndex[0];
                status                               |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_mask0, maskRwkFilterReg0.U);
            }

            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_mask1))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER1_BYTE_MASK maskRwkFilterReg1;
                maskRwkFilterReg1.U                   = 0;
                maskRwkFilterReg1.B.FILTER1_BYTE_MASK = config->rwkFilterConfig[index]->maskByteIndex[1];
                status                               |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_mask1, maskRwkFilterReg1.U);
            }

            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_crc2_3))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER2_3_CRC crcRwkFilterReg23;
                crcRwkFilterReg23.U             = 0;
                crcRwkFilterReg23.B.FILTER2_CRC = config->rwkFilterConfig[index]->crcHashValue[2];
                crcRwkFilterReg23.B.FILTER3_CRC = config->rwkFilterConfig[index]->crcHashValue[3];
                status                         |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_crc2_3, crcRwkFilterReg23.U);
            }

            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_mask2))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER2_BYTE_MASK maskRwkFilterReg2;
                maskRwkFilterReg2.U                   = 0;
                maskRwkFilterReg2.B.FILTER2_BYTE_MASK = config->rwkFilterConfig[index]->maskByteIndex[2];
                status                               |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_mask2, maskRwkFilterReg2.U);
            }

            if ((status == FALSE) && (geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.B.RWKPTR == IfxGeth_RwkFilterRegType_mask3))
            {
                Ifx_GETH_PORT_CORE_RWK_FILTER3_BYTE_MASK maskRwkFilterReg3;
                maskRwkFilterReg3.U                   = 0;
                maskRwkFilterReg3.B.FILTER3_BYTE_MASK = config->rwkFilterConfig[index]->maskByteIndex[3];
                status                               |= IfxGeth_macRwkFilterWrite(geth->gethSFR, portIndex, IfxGeth_RwkFilterRegType_mask3, maskRwkFilterReg3.U);
            }

            if (status == TRUE)
            {
                break;
            }
        }

        if (status == TRUE)
        {
            globalStatus = IfxGeth_RwkConfigStatus_timeoutError;
        }
        else
        {
            geth->gethSFR->PORT[portIndex].CORE.MAC_PMT_CONTROL_STATUS.U = regPmtCtrl.U;
            globalStatus                                                 = IfxGeth_RwkConfigStatus_success;
        }
    }
    else
    {
        globalStatus = IfxGeth_RwkConfigStatus_invalidConfigError;
    }

    return globalStatus;
}


boolean IfxGeth_Eth_mdio_write_clause22(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint16 regAddress, uint16 data)
{
    IfxGeth_Eth_MdioSingleWriteConfig writeConfig;
    writeConfig.mdioSingleCmdDeviceAddr = 0x0;
    writeConfig.mdioSingleCmdPortAddr   = phyAddress;
    writeConfig.mdioSingleCmdRegAddr    = regAddress;
    writeConfig.mdioSingleWriteData     = data;
    return IfxGeth_Eth_mdioSingleWrite(geth, portIndex, &writeConfig);
}


boolean IfxGeth_Eth_mdio_read_clause22(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint16 regAddress, uint16 *data)
{
    IfxGeth_Eth_MdioSingleReadConfig readConfig;
    readConfig.mdioSingleCmdDeviceAddr = 0x0;
    readConfig.mdioSingleCmdPortAddr   = phyAddress;
    readConfig.mdioSingleCmdRegAddr    = regAddress;
    readConfig.mdioSingleReadData      = data;
    return IfxGeth_Eth_mdioSingleRead(geth, portIndex, &readConfig);
}


boolean IfxGeth_Eth_mdio_write_clause45(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 data)
{
    IfxGeth_Eth_MdioSingleWriteConfig writeConfig;
    writeConfig.mdioSingleCmdDeviceAddr = devAddress;
    writeConfig.mdioSingleCmdPortAddr   = phyAddress;
    writeConfig.mdioSingleCmdRegAddr    = regAddress;
    writeConfig.mdioSingleWriteData     = data;
    return IfxGeth_Eth_mdioSingleWrite(geth, portIndex, &writeConfig);
}


boolean IfxGeth_Eth_mdio_read_clause45(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 *data)
{
    IfxGeth_Eth_MdioSingleReadConfig readConfig;
    readConfig.mdioSingleCmdDeviceAddr = devAddress;
    readConfig.mdioSingleCmdPortAddr   = phyAddress;
    readConfig.mdioSingleCmdRegAddr    = regAddress;
    readConfig.mdioSingleReadData      = data;
    return IfxGeth_Eth_mdioSingleRead(geth, portIndex, &readConfig);
}


#endif
