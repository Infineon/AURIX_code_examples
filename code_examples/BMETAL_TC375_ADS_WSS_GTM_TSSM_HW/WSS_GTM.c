/**********************************************************************************************************************
 * \file WSS_GTM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/

#include "IfxGtm.h"
#include "IfxGtm_PinMap.h"
#include "WSS_Configurations.h"
#include "WSS_GTM.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/* Macros for shift and mask operation to extract the AK frame */

#if(USE_FCADC == TRUE)
#define DATA_MSK            0x7FFFFF
#define FRAME_LENGTH        11              
#define FRAME_SHIFT         (25 - bits)
#else
#define DATA_MSK            0xFFFFFF
#define FRAME_LENGTH        12              
#define FRAME_SHIFT         (26 - bits)
#endif

/* Macros for using FCADC outputs */
#ifdef USE_FCADC
#define  FC0BFLOUT          &MODULE_P33, 4  /* GPIO corresponding to FC0 boundary flag */
#define  FC3BFLOUT          &MODULE_P33, 2  /* GPIO corresponding to FC3 boundary flag */
#endif

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

uint32 g_arrayIndex = 0;                    /* array index to store the speed and the decoded data */
float32 g_speedPeriod[100] = {0};           /* array index to store the speed in RPM */
uint32 g_decodedData[100] = {0};            /* array index to store the decoded data */

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/

void enableGTM (void);
void pinningGTM (void);
void configTDU1_1 (void);
void configTDU1_0 (void);
void configTIM1_0 (void);
void configTIM1_1 (void);
void configTIM1_2 (void);
void configTIM1_3 (void);
void configTIM1_4 (void);
void configTIM (void);
void startTIM (void);

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

/* This is the interrupt handler for the TIM1_CH3 NEWVAL interrupt
 * - Captures the time between the speed pulse from TIM1_CH3
 * - Decode the AK data based on the value captured in TIM1_CH2 and TIM1_CH4
 * - Enables the ATOM1_CH0 when emulation is enabled
 * */
IFX_INTERRUPT(speedPulseHandler, 0, 7)
{
    uint32 AKdata = 0;
    uint32 bits = 0;
    uint32 speedpulsewidth = 0;

    /* Clear NEW_VAL irq notification */
    MODULE_GTM.TIM[1].CH3.IRQ.NOTIFY.U = 0x1;

    /* Reset the array index if it is out of bound */
    if (g_arrayIndex == 100)
    {
        g_arrayIndex = 0;
    }
    /* Calculate the speed in RPM based on clock resolution */
    speedpulsewidth = MODULE_GTM.TIM[1].CH3.GPR1.B.GPR1;
    g_speedPeriod[g_arrayIndex] = 60/(speedpulsewidth * TIM_RESOLUTION * NUM_OF_POLES);

    /* Find the number of bits transmitted and decode the corresponding data */
    bits = MODULE_GTM.TIM[1].CH4.GPR1.B.GPR1;
    AKdata = MODULE_GTM.TIM[1].CH2.GPR1.B.GPR1;
    AKdata = (AKdata & DATA_MSK) >> FRAME_SHIFT;
    g_decodedData[g_arrayIndex]  = AKdata;

    /* Increment the array index */
    g_arrayIndex++;

#ifdef WSS_EMULATION
    /* Start PWM generation */
    MODULE_GTM.ATOM[1].AGC.ENDIS_STAT.U = 0x2;          /* enable ATOM1_CH0 which emulates AK signal */
#endif
}

/* This function initializes the GTM-CMU:
 * - enables clock for GTM module
 * - disables cluster protections
 * - sets GTM-CLS0,1 clock without divider (200MHz)
 * - enables CMU_CLK0-3
 * */
void enableGTM (void)
{
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());
    MODULE_GTM.CLC.B.DISR = 0x0;                 /* enable clock for GTM module */
    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    MODULE_GTM.CTRL.B.RF_PROT = 0x0u;                   /* SW RST, FORCEINT and SW RAM enabled */
    MODULE_GTM.CCM[1].PROT.B.CLS_PROT = 0x0;            /* Enable write access to cluster 1 configuration register */
    MODULE_GTM.CLS_CLK_CFG.B.CLS0_CLK_DIV = 0x1;        /* cluster 0 is enabled without clock divider --> CLS0 = 200MHz */
    MODULE_GTM.CLS_CLK_CFG.B.CLS1_CLK_DIV = 0x1;        /* cluster 1 is enabled without clock divider --> CLS0 = 200MHz */
    MODULE_GTM.CMU.CLK[3].CTRL.B.CLK_CNT = 0x32;        /* CMU_CLK3 = 200/50 MHz to be used for TDU0_1*/
    MODULE_GTM.CMU.CLK[2].CTRL.B.CLK_CNT = 0x78;        /* CMU_CLK2 = 200/120 MHz to be used for DTM*/
    MODULE_GTM.CMU.CLK_EN.U = 0xAA;                     /* enable CMU_CLK0-3 */

    GTM_OCS.U = 0x12000000;
}

/* This function uses iLLD to configure Aurix pins depending on if FCADC is used
 * - when USE_FCADC is TRUE :
 * - use FC0BFL, CBFLOUT2 and FC3BFL as inputs for TIM1_CH0, TIM1_CH2 and TIM1_CH3
 * - configure P33.4 and P33.2 to monitor FC0BFL and FC3BFL
 *   when USE_FCADC is FALSE :
 * - configure P22.1 as input for TIM1_CH0
 * - configure P21.4 as input for TIM1_CH2
 * - configure P00.12 as input for TIM1_CH3
 * */
void pinningGTM (void)
{
#if(USE_FCADC == TRUE)
    /* TIM1_CH0 input as FC0BFL */
    GTM_TIM1INSEL.B.CH0SEL              = 0x0;
    /* TIM1_CH2 input as CBFLOUT2 */
    GTM_TIM1INSEL.B.CH2SEL              = 0xE;
    /* TIM1_CH3 input as FC3BFL */
    GTM_TIM1INSEL.B.CH3SEL              = 0x0;
    /* Output FC0BFL, FC3BFL to output pins for monitoring */
    IfxPort_setPinMode(FC0BFLOUT, IfxPort_Mode_outputPushPullAlt6);
    IfxPort_setPinMode(FC3BFLOUT, IfxPort_Mode_outputPushPullAlt6);
#else
    /* TIM1_CH0, P22.1 */
    IfxGtm_PinMap_setTimTin(&IfxGtm_TIM1_0_P22_1_IN, IfxPort_InputMode_noPullDevice);
    /* TIM1_CH2, P21.4 */
    IfxGtm_PinMap_setTimTin(&IfxGtm_TIM1_2_P21_4_IN, IfxPort_InputMode_noPullDevice);
    /* TIM1_CH3, P0.12 */
    IfxGtm_PinMap_setTimTin(&IfxGtm_TIM1_3_P00_12_IN, IfxPort_InputMode_noPullDevice);

#endif

}

/* This function configures TDU to generate delay required for the sampling
 * event, TDU_WORD_EVT event is used for this which generates the TODET for
 * external capture of TIM1_CH0
 * */
void configTDU1_1 (void)
{
    /*  TDU configuration TO_CNT >= TOV generates tdu_word_evt
     *  TO_CNT2: TCS selected
     TO_CNT: TCS selected with TCS_USE_SAMPLE_EVT=0
     TO_CNT1: TCS selected with TDU_SAME_CNT_CLK=1  */

    /* 3x 8 bit  */
    MODULE_GTM.TIM[1].CH1.TDUV.B.SLICING = 0x2;
    MODULE_GTM.TIM[1].CH1.TDUV.B.TCS_USE_SAMPLE_EVT = 0x0;
    MODULE_GTM.TIM[1].CH1.TDUV.B.TDU_SAME_CNT_CLK = 0x0;

    /* 4MHz generates sampling point with 3/4 bit period delay*/
    MODULE_GTM.TIM[1].CH1.TDUV.B.TCS = 0x3;
    MODULE_GTM.TIM[1].CH1.TDUV.B.TOV = TDU_COUNTER;

    /* reset counters TO_CNT on tdu_word_evt */
    MODULE_GTM.TIM[1].CH1.ECTRL.B.TDU_RESYNC = 0x8;

    /* starts and stops the TDU based on  tdu_start_000_event and tdu_toctrl_0_event */
    MODULE_GTM.TIM[1].CH1.ECTRL.B.TDU_START = 0x4;      /* Start/restart with occurrence of external capture event */
    MODULE_GTM.TIM[1].CH1.ECTRL.B.TDU_STOP = 0x1;       /* Stop counting of TDU on tdu_word_evt or on tdu_toctrl_0_event */
}

/* This function configures TDU to generate two tdu_sync_evt; these event
 * is used as shift clock for the TSSM mode
 * */
void configTDU1_0 (void)
{
    /*  TDU configuration TO_CNT >= TOV generates tdu_word_evt
     *  TO_CNT2: TCS selected
     TO_CNT: TCS selected with TCS_USE_SAMPLE_EVT=0
     TO_CNT1: TCS selected with TDU_SAME_CNT_CLK=1  */

    /* 3x 8 bit  */
    MODULE_GTM.TIM[1].CH0.TDUV.B.SLICING = 0x2;
    MODULE_GTM.TIM[1].CH0.TDUV.B.TCS_USE_SAMPLE_EVT = 0x0;
    MODULE_GTM.TIM[1].CH0.TDUV.B.TDU_SAME_CNT_CLK = 0x0;
    
    /* 4MHz/100 generates sampling point for the AK signal matching the tP*/
    MODULE_GTM.TIM[1].CH0.TDUV.B.TCS = 0x0;
    MODULE_GTM.TIM[1].CH0.TDUV.B.TOV2 = 0x0;
    MODULE_GTM.TIM[1].CH0.TDUV.B.TOV = 0x1;

    /* reset counters TO_CNT on tdu_word_evt */
    MODULE_GTM.TIM[1].CH0.ECTRL.B.TDU_RESYNC = 0x8;
    
    /* starts and stops the TDU based on  tdu_start_000_event and tdu_toctrl_0_event */
    MODULE_GTM.TIM[1].CH0.ECTRL.B.TDU_START = 0x4;      /* Start/restart with occurrence of external capture event */
    MODULE_GTM.TIM[1].CH0.ECTRL.B.TDU_STOP = 0x1;       /* Stop counting of TDU on tdu_word_evt or on tdu_toctrl_0_event */
}

/* This function configures TIM1_CH0 is used to generate the sample and hold signal from the AK data signal
 * */
void configTIM1_0 (void)
{
    MODULE_GTM.TIM[1].CH0.ECTRL.B.EXT_CAP_SRC = 0x5;    /* EXT_CAPTURE(0) = TODET_IRQ(1) */
    
    /* Configure TDU of TIM1_CH0 */
    configTDU1_0();
    
    MODULE_GTM.TIM[1].CH0.ECTRL.B.ECLK_SEL = 1;         /* use TDU_SAMPLE_EVT as shift clock */

    /* Configure TIM1 CH0 in TSSM mode to output TSSM_OUT as sample and hold signal*/
    MODULE_GTM.TIM[1].CH0.CTRL.B.TIM_MODE = 0x6;        /* TSSM mode */
    MODULE_GTM.TIM[1].CH0.CTRL.B.GPR1_SEL = 0x3;        /* Use CNT as input */
    MODULE_GTM.TIM[1].CH0.CTRL.B.DSL = 0x0;             /* TSSM_OUTx stored in CNT[0], rest is left-shifted */
    MODULE_GTM.TIM[1].CH0.CTRL.B.ISL = 0x1;             /* ECNT_RESET is used as TSSM_IN */

    /* CNTS(22)  = 1 : to reset CNT with 0 (GPR0)
     CNTS(21:20) = 3 : Shift output
     CNTS(17:16) = 0 : TDU_SAMPLE_EVT as shift clock
     CNTS(7:0)   = 1 : AK protocol frame length    */
    MODULE_GTM.TIM[1].CH0.CNTS.B.CNTS = (0x700001);
    MODULE_GTM.TIM[1].CH0.GPR1.B.GPR1 = (0x700001);
    MODULE_GTM.TIM[1].CH0.GPR0.B.GPR0 = 0x200000;       /* CNT is reset with 0x200000 */
}

/* This function configures TIM1_CH1 is used to delay the sampling event at 3/4 of period using TDU
 * and also inverts the sample and hold signal using it's LUT
 * */
void configTIM1_1 (void)
{
    /* Configure TIM1 CH0 in TPWM mode to detect the speed pulse edge and also measure period */
    MODULE_GTM.TIM[1].CH1.ECTRL.B.EXT_CAP_SRC = 0xa;    /* EXT_CAPTURE(1) = FEDGE_DET(2) */
    MODULE_GTM.CCM[1].CMU_CLK_CFG.B.CLK1_SRC = 0x2;     /* CMU_CLK1 = TIM1_EXT_CAPTURE(1) */

    MODULE_GTM.TIM[1].CH1.ECTRL.B.USE_LUT = 0x2;        /* Enable LUT, LUT_IN2(1) = F_OUT_PREV(x) */
    MODULE_GTM.TIM[1].CH1.TDUC.B.TO_CNT2 = 0x0f;        /* LUT combination: F_IN(x)= NOT F_OUT_PREV(x) */

    /* Configure TDU of TIM1_CH1 */
    configTDU1_1();
}

/* This function configures TIM1_CH2 is used to decode the AK data using the TSSM mode
 * */
void configTIM1_2 (void)
{
    /* TIM[0]_AUX_IN2 = ATOM0_CH2 */
    MODULE_GTM.CCM[1].TIM_AUX_IN_SRC.B.SRC_CH2 = 0x1;
    MODULE_GTM.CCM[1].TIM_AUX_IN_SRC.B.SEL_OUT_N_CH2 = 0x0;

    MODULE_GTM.TIM[1].CH2.ECTRL.B.USE_LUT = 0x2;        /* Enable LUT, F_IN(2) = LUT output ; LUT_IN2(2) = F_OUT_PREV(x) */
    MODULE_GTM.TIM[1].CH2.TDUC.B.TO_CNT2 = 0x58;        /* F_IN(2) = LUT_IN2 XOR TIM_IN */

    MODULE_GTM.TIM[1].CH2.ECTRL.B.EXT_CAP_SRC = 0x9;    /* EXT_CAPTURE(2) = REDGE_DET(3) */
    MODULE_GTM.TIM[1].CH2.ECTRL.B.USE_PREV_CH_IN = 1;   /* use previous FOUT as input for TSSM */

    /* Use CMU_CLK1 as shift clock */
    MODULE_GTM.TIM[1].CH2.CTRL.B.CLK_SEL = 0x1;
    MODULE_GTM.TIM[1].CH2.ECTRL.B.ECLK_SEL = 0;

    /* Configure TIM1 CH0 in TSSM mode to output TSSM_OUT */
    MODULE_GTM.TIM[1].CH2.CTRL.B.TIM_MODE = 0x6;        /* TSSM mode */
    MODULE_GTM.TIM[1].CH2.CTRL.B.GPR1_SEL = 0x3;        /* Use CNT as input */
    MODULE_GTM.TIM[1].CH2.CTRL.B.GPR0_SEL = 0x3;        /* Use CNTS as input */
    MODULE_GTM.TIM[1].CH2.CTRL.B.DSL = 0x1;             /* TSSM_OUTx stored in CNT[23], rest is right-shifted */
    MODULE_GTM.TIM[1].CH2.CTRL.B.ISL = 0x0;             /* F_OUT is used as TSSM_IN */
    MODULE_GTM.TIM[1].CH2.CTRL.B.EXT_CAP_EN = 0x1;      /* Enable external capture to generate NEWVAL_IRQ */
    MODULE_GTM.TIM[1].CH2.GPR0.B.GPR0 = 0x0;            /* CNT is reset with 0 */

    /* CNTS(22)    = 1 : to reset CNT with 0 (GPR0)
     CNTS(17:16) = 0 : CLK1 as shift clock
     CNTS(7:0)   = 10 : AK protocol frame length    */
    MODULE_GTM.TIM[1].CH2.CNTS.B.CNTS = (0x400000 | FRAME_LENGTH);
}

/* This function configures TIM1_CH3 is used to measure the period of the speed pulse signal
 * */
void configTIM1_3 (void)
{
    /* Configure TIM1 CH3 in TPWM mode to detect the speed pulse edge and also measure period */
    MODULE_GTM.TIM[1].CH3.CTRL.B.TIM_MODE = 0x0;        /* TPWM mode */
    MODULE_GTM.TIM[1].CH3.CTRL.B.GPR1_SEL = 0x3;        /* Use CNT as input */
    MODULE_GTM.TIM[1].CH3.CTRL.B.GPR0_SEL = 0x3;        /* Use CNTS as input */
    MODULE_GTM.TIM[1].CH3.CTRL.B.DSL = 0x1;             /* Interrupt on rising edge */
    MODULE_GTM.TIM[1].CH3.CTRL.B.ECNT_RESET = 0x0;      /* CNT doesn't reset */
    MODULE_GTM.TIM[1].CH3.ECTRL.B.IMM_START = 0x0;      /* starts when the channel is enabled */

    /* Enable NEW_VAL irq*/
    MODULE_GTM.TIM[1].CH3.IRQ.MODE.B.IRQ_MODE = 0x2;
    MODULE_GTM.TIM[1].CH3.IRQ.EN.B.NEWVAL_IRQ_EN = 0x1;
    /* Enable Interrupt  */
    MODULE_SRC.GTM_TIM[1][3].B.TOS = 0x0;
    MODULE_SRC.GTM_TIM[1][3].B.SRE = 0x1;
    MODULE_SRC.GTM_TIM[1][3].B.SRPN = 0x7;
}

/* This function configures TIM1_CH4 is used to find the numbers of bits transmitted in the AK frame
 * */
void configTIM1_4(void)
{
    /* Configure TIM1 CH4 in TPWM mode which counts with  CMU_CLK1 between the rising edges of speed pulse */
    MODULE_GTM.TIM[1].CH4.CTRL.B.TIM_MODE = 0x0;        /* TPWM mode */
    MODULE_GTM.TIM[1].CH4.CTRL.B.GPR1_SEL = 0x3;        /* Use CNT as input */
    MODULE_GTM.TIM[1].CH4.CTRL.B.GPR0_SEL = 0x3;        /* Use CNTS as input */
    MODULE_GTM.TIM[1].CH4.CTRL.B.DSL = 0x1;             /* Interrupt on rising edge */
    MODULE_GTM.TIM[1].CH4.CTRL.B.ECNT_RESET = 0x0;      /* CNT doesn't reset */
    MODULE_GTM.TIM[1].CH4.ECTRL.B.IMM_START = 0x0;      /* starts when the channel on rising edge */
    MODULE_GTM.TIM[1].CH4.CTRL.B.CLK_SEL = 0x1;         /* CMU_CLK1 is used as clock */
    MODULE_GTM.TIM[1].CH4.ECTRL.B.USE_PREV_CH_IN = 1;   /* use previous FOUT as input */
}

/* This function configures TIM1_CH0- TIM1_CH3 channels for decoding the AK protocol
 * - TIM1_CH0 is used to generate the sample and hold signal from the AK data signal
 * - TIM1_CH1 is used to delay the sampling event at 3/4 of period using TDU
 * - TIM1_CH2 is used to decode the AK data using the TSSM mode
 * - TIM1_CH3 is used to measure the period of the speed pulse signal
 * - TIM1_CH4 is used to determine the number of bits transmitted
 * */
void configTIM (void)
{
    configTIM1_0();
    configTIM1_1();
    configTIM1_2();
    configTIM1_3();
    configTIM1_4();
}

void configATOM (void)
{
    /* ATOM0_CH3 used in OSM */
    MODULE_GTM.ATOM[1].CH2.CTRL.B.MODE = 0x2;           /* SOMP mode */
    MODULE_GTM.ATOM[1].CH2.CTRL.B.CLK_SRC_SR = 0x0;     /* use CMU_CLK0 as clock */
    MODULE_GTM.ATOM[1].CH2.CTRL.B.SL = 0x1;
    MODULE_GTM.ATOM[1].CH2.CN0.U = 0;
    MODULE_GTM.ATOM[1].CH2.CTRL.B.OSM = 1;              /* one shot mode enabled*/
    MODULE_GTM.ATOM[1].CH2.CTRL.B.OSM_TRIG = 1;         /* one shot trigger enabled */
    MODULE_GTM.ATOM[1].CH2.CTRL.B.EXT_TRIG = 1;         /* use TIM_EXT_CAPTURE(x) as trigger  */

    /* Configure DTM in special mode to generate pulse  */
    MODULE_GTM.CDTM[1].DTM[4].CTRL.B.CLK_SEL = 3;
    MODULE_GTM.CDTM[1].DTM[4].CH_CTRL1.B.O1SEL_2 = 1;
    MODULE_GTM.CDTM[1].DTM[4].CH_CTRL1.B.O1F_2 = 0;
    MODULE_GTM.CDTM[1].DTM[4].CH[2].DTV.B.RELRISE = 900;
    MODULE_GTM.CDTM[1].DTM[4].CH[2].DTV.B.RELFALL = 1000;
    MODULE_GTM.CDTM[1].DTM[4].CH_CTRL2.B.DT1_2 = 1;
    MODULE_GTM.CDTM[1].DTM[4].CH_CTRL1.B.SWAP_2 = 1;

    /* OSM Up down mode */
    MODULE_GTM.ATOM[1].CH2.CTRL.B.UDMODE = 1;            /* enable up-down mode */
    MODULE_GTM.ATOM[1].CH2.SR1.U = 1;                    /* no initial delay */
    MODULE_GTM.ATOM[1].CH2.SR0.U = 1000;                 /* pulse width */
    MODULE_GTM.ATOM[1].AGC.FUPD_CTRL.U = 0x20;           /* Enable force update mechanism */
    MODULE_GTM.ATOM[1].AGC.GLB_CTRL.U = 0x200001;        /* Enable update channel and send SW trigger to update all CMx and SRCx */
    MODULE_GTM.ATOM[1].AGC.OUTEN_STAT.U = 0x20;          /* enable output [1] of ATOM[1] */
    MODULE_GTM.ATOM[1].AGC.ENDIS_STAT.U = 0x20;          /* enable channel [1] of ATOM[1] */
}

/* This function start the decoding by enabling the TIM1_CH0- TIM1_CH4 channels
 * */
void startTIM (void)
{
    MODULE_GTM.TIM[1].CH0.CTRL.B.TIM_EN = 0x1;          /* Enable TIM1_CH0 */
    MODULE_GTM.TIM[1].CH1.CTRL.B.TIM_EN = 0x1;          /* Enable TIM1_CH1 */
    MODULE_GTM.TIM[1].CH2.CTRL.B.TIM_EN = 0x1;          /* Enable TIM1_CH2 */
    MODULE_GTM.TIM[1].CH3.CTRL.B.TIM_EN = 0x1;          /* Enable TIM1_CH3 */
    MODULE_GTM.TIM[1].CH4.CTRL.B.TIM_EN = 0x1;          /* Enable TIM1_CH4 */
}

/* This function configures and enables the required GTM modules for decoding the AK protocol
 * */
void configureGTM (void)
{
    enableGTM();
    pinningGTM();
    configTIM();
    configATOM();
    startTIM();
}
