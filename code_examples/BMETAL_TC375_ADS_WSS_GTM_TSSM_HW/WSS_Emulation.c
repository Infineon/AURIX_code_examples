/**********************************************************************************************************************
 * \file WSS_Emulation.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/


#include "Ifx_Types.h"
#include "IfxGtm_reg.h"
#include "IfxGtm_PinMap.h"
#include "WSS_GTM.h"
#include "WSS_Configurations.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/* FIRST_BIT_VAL need to changed to FIRST_BIT_VAL0/1 if the first bit is 0/1;
 * - For the test case 2 and 3, the first bit is 1, for others it is 0       */
#define FIRST_BIT_VAL0  g_lutATOMPeriod[g_indexLUT] + BIT_1_T
#define FIRST_BIT_VAL1  g_lutATOMPeriod[g_indexLUT] - BIT_2_T
#define FIRST_BIT_VAL   FIRST_BIT_VAL0

/* Macros for the three emulation data supported; to be configured in WSS_Configurations.h */
#define EMULATION_DATA1 0x5C
#define EMULATION_DATA2 0x1A8
#define EMULATION_DATA3 0x73

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* index for the LUT */
uint8 g_indexLUT = 0;

/* flag to manage state machine */
boolean g_lastdata = FALSE;

/* The LUT data for the ATOM shadow register for the subsequent data; only one have to be uncommented */

/* test case 1 ; Data = 0x5C */
#if(EMULATION_DATA == EMULATION_DATA1)
uint32 g_lutATOMDuty[8]   = {BIT_2_T,    BIT_1_T,    BIT_1_T,    BIT_1_T,    BIT_1_T,    BIT_2_T,    BIT_2_T,    BIT_1_T};
uint32 g_lutATOMPeriod[8] = {BIT_3_T,    BIT_2_T,    BIT_3_T,    BIT_2_T,    BIT_2_T,    BIT_4_T,    BIT_3_T,    BIT_2_T};
#endif

 /* test case 2 ; Data = 0x1A8 */
#if(EMULATION_DATA == EMULATION_DATA2)
uint32 g_lutATOMDuty[8]   = { BIT_2_T,   BIT_1_T,    BIT_1_T,    BIT_1_T,    BIT_2_T,    BIT_2_T,    BIT_1_T,    BIT_1_T};
uint32 g_lutATOMPeriod[8] = { BIT_3_T,   BIT_2_T,    BIT_2_T,    BIT_3_T,    BIT_4_T,    BIT_4_T,    BIT_2_T,    BIT_2_T};
#endif

 /* test case 3 ; Data = 0x73 */
#if(EMULATION_DATA == EMULATION_DATA3)
uint32 g_lutATOMDuty[8]   = { BIT_2_T,   BIT_1_T,    BIT_2_T,    BIT_1_T,    BIT_1_T,    BIT_1_T,    BIT_2_T,    BIT_1_T};
uint32 g_lutATOMPeriod[8] = { BIT_4_T,   BIT_2_T,    BIT_3_T,    BIT_3_T,    BIT_2_T,    BIT_2_T,    BIT_3_T,    BIT_2_T};
#endif
/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/

void pinningEmulation (void);
void configEmulationTIM (void);
void configEmulationATOM (void);

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/

/* This is the interrupt handler for the ATOM1_CH0
 * - used to emulate the AK data based on the LUT of the duty cycle and period
 * */
IFX_INTERRUPT(ATOMIntHandler, 0, 5)
{
    /* clear NEW_VAL irq notification */
    MODULE_GTM.ATOM[1].CH0.IRQ.NOTIFY.U = 0x1;

    if (g_lastdata)
    {
        g_lastdata = FALSE;
        MODULE_GTM.ATOM[1].CH0.CN0.U = FIRST_BIT_VAL;
        MODULE_GTM.ATOM[1].AGC.ENDIS_CTRL.U = 0x2;
    }
    else
    {
        if (g_indexLUT == 7)
        {
            g_indexLUT = 0;
            g_lastdata = TRUE;
            MODULE_GTM.ATOM[1].AGC.ENDIS_CTRL.U = 0x1;
        }
        else
        {
            /* Update ATOM1_CH0 duty cycle and the period for the next cycle*/
            g_indexLUT++;
        }
        MODULE_GTM.ATOM[1].CH0.SR0.U = g_lutATOMPeriod[g_indexLUT];
        MODULE_GTM.ATOM[1].CH0.SR1.U = g_lutATOMDuty[g_indexLUT];
    }
}

/* This function uses iLLD to configure ATOM output MUX (TOUTSEL)
 * - configure P00.0 to be driven by ATOM1_CH0 
 * - configure P20.1 to be driven by ATOM1_CH3
 * */
void pinningEmulation (void)
{
    /* ATOM1_CH0, P0.0 */
    IfxGtm_PinMap_setAtomTout(&IfxGtm_ATOM1_0_TOUT9_P00_0_OUT, IfxPort_OutputMode_pushPull, IfxPort_PadDriver_cmosAutomotiveSpeed1);
    /* ATOM1_CH3, P20.1 */
    IfxGtm_PinMap_setAtomTout(&IfxGtm_ATOM1_3_TOUT60_P20_1_OUT, IfxPort_OutputMode_pushPull, IfxPort_PadDriver_cmosAutomotiveSpeed1);
}

/* This function connects the ATOM channel outputs to the AUX inputs of the corresponding TIM channels  when emulation is used
 * - TIM1_CH0 is used to sample the AK data based on this AUX input
 * - TIM1_CH3 is used to measure the period of the speed pulse signal
 * */
void configEmulationTIM (void)
{    
    /* TIM1_CH0 <-- ATOM1_CH0*/
    MODULE_GTM.CCM[1].TIM_AUX_IN_SRC.B.SRC_CH0 = 0x1;
    MODULE_GTM.CCM[1].TIM_AUX_IN_SRC.B.SEL_OUT_N_CH0 = 0x0;
    MODULE_GTM.TIM[1].IN_SRC.B.MODE_0 = 0x1;
    MODULE_GTM.TIM[1].IN_SRC.B.VAL_0 = 0x2;

    /* TIM1_CH3 <-- ATOM1_CH3*/
    MODULE_GTM.CCM[1].TIM_AUX_IN_SRC.B.SRC_CH3 = 0x1;
    MODULE_GTM.CCM[1].TIM_AUX_IN_SRC.B.SEL_OUT_N_CH3 = 0x0;
    MODULE_GTM.TIM[1].IN_SRC.B.MODE_3 = 0x1;
    MODULE_GTM.TIM[1].IN_SRC.B.VAL_3 = 0x2;
}

/* This function configures and starts ATOM1 module to generate PWM signals. 
 * - configures ATOM1_CH0 for emulating AK data
 * - configures ATOM1_CH3 for emulating speed pulse
 * */
void configEmulationATOM (void)
{
    /* ATOM1_3 */
    MODULE_GTM.ATOM[1].CH3.CTRL.B.MODE = 0x2;       /* SOMP mode */
    MODULE_GTM.ATOM[1].CH3.CTRL.B.CLK_SRC_SR = 0x0; /* use CMU_CLK0 as clock for ATOM1_CH3 */
    MODULE_GTM.ATOM[1].CH3.CTRL.B.SL = 0x1;
    MODULE_GTM.ATOM[1].CH3.SR0.U = SPEED_PERIOD;
    MODULE_GTM.ATOM[1].CH3.SR1.U = BIT_2_T;
    MODULE_GTM.ATOM[1].CH3.CN0.U = SPEED_PERIOD;

    /* ATOM1_0 */
    MODULE_GTM.ATOM[1].CH0.CTRL.B.MODE = 0x2;       /* SOMP mode */
    MODULE_GTM.ATOM[1].CH0.CTRL.B.CLK_SRC_SR = 0x0; /* use CMU_CLK0 as clock for ATOM1_CH0 */
    MODULE_GTM.ATOM[1].CH0.CTRL.B.SL = 0x1;
    MODULE_GTM.ATOM[1].CH0.CN0.U = FIRST_BIT_VAL;
    MODULE_GTM.ATOM[1].CH0.SR0.U = g_lutATOMPeriod[g_indexLUT];
    MODULE_GTM.ATOM[1].CH0.SR1.U = g_lutATOMDuty[g_indexLUT];
    MODULE_GTM.ATOM[1].CH0.CTRL.B.TRIGOUT = 0x1;

    /* Start PWM generation */
    MODULE_GTM.ATOM[1].AGC.FUPD_CTRL.U = 0x82;     /* Enable force update mechanism */
    MODULE_GTM.ATOM[1].AGC.GLB_CTRL.U = 0x820001;  /* Enable update CH0 and CH1, Send SW trigger to update all CMx and SRCx */
    MODULE_GTM.ATOM[1].AGC.OUTEN_STAT.U = 0x82;    /* enable outputs[0][1] of ATOM[1] */
    MODULE_GTM.ATOM[1].AGC.ENDIS_STAT.U = 0x80;    /* enable channels[1] of ATOM[1] */
    MODULE_GTM.ATOM[1].AGC.INT_TRIG.U = 0x2;       /* use internal trigger from channel[0] of ATOM[1] */

    /* Enable CCU0 event irq */
    MODULE_GTM.ATOM[1].CH0.IRQ.MODE.B.IRQ_MODE = 0x2;
    MODULE_GTM.ATOM[1].CH0.IRQ.EN.B.CCU0TC_IRQ_EN = 0x1;
    /* Enable Interrupt  */
    MODULE_SRC.GTM_ATOM[1][0].B.TOS = 0x0;
    MODULE_SRC.GTM_ATOM[1][0].B.SRE = 0x1;
    MODULE_SRC.GTM_ATOM[1][0].B.SRPN = 0x5;
}

/* This function configures and enables the required GTM modules for emulating the AK protocol
 * */
void configureEmulation (void)
{
    pinningEmulation();
    configEmulationTIM();
    configEmulationATOM();
}
