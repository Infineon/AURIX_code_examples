/**********************************************************************************************************************
 * \file EVADC_Master_Slave.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxConverter_reg.h"
#include "IfxEvadc_Adc.h"
#include "IfxStm_reg.h"
/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/* This function initializes Convert Control module:
 * - Enable the CONVCTRL module
 * - Set up 40MHz clock
 */
static void init_CONVCTRL( void )
{
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword ());
    CONVCTRL_CLC.U = 0x00000000;        /* Enable module CONVCTRL */

    while(CONVCTRL_CLC.B.DISS == 0x1)   /* Wait until module clock is enabled   */
    {;}

    CONVCTRL_CCCTRL.U = 0xB0000000;     /* Unlock converter control registers   */
    CONVCTRL_PHSCFG.U = 0x00008003;     /* fADC=160MHz, fPHSYNC=160MHz/4=40MHz  */
    CONVCTRL_CCCTRL.U = 0x00000000;     /* Lock converter control registers     */

    IfxScuWdt_setCpuEndinit (IfxScuWdt_getCpuWatchdogPassword ());
}

/* Function to wait until specified us has elapsed */
static void wait_micro_second(unsigned int ticks_in_us)
{
    /* fSTM = 100MHz by default */
    unsigned int stmCount = 100 * ticks_in_us;

    unsigned int   stmCountBegin = STM0_TIM0.U;

    while ((unsigned int)(STM0_TIM0.U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }

}

void enable_EVADC( void )
{
    init_CONVCTRL();        /* Enable CONVCTRL module*/

    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    EVADC_CLC.U = 0x0;      /* Enable clock for the EVADC module*/

    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Wait until Module clock is enabled (DISS == 0) */
    while( EVADC_CLC.B.DISS == 0x1 );

    /* Configure Channel Settings */

    /* Configure sample time of 425ns = 16 x F_adci(40MHz), 2 + (STCS - 15) Ã— 16
    * GxICLASSi - Input Class Register i, (i=0-1)
        * STCS[0:4]     - 0x0F  --> Sample Time Control for Standard Conversions
        * AIPS[6:7]     - 0x00  --> Analog Input Precharge Control for Standard Conversions
        * CMS[8:9]      - 0x00  --> Conversion Mode for Standard Conversions
        * SESPS[10]     - 0x00  --> Spread Early Sample Point for Standard Conversions
        * STCE[16:20]   - 0x00  --> Sample Time Control for EMUX Conversions
        * AIPE[22:23]   - 0x00  --> Analog Input Precharge Control for EMUX Conversions
        * CME[24:25]    - 0x00  --> Conversion Mode for EMUX Conversions
        * SESPE[26]     - 0x00  --> Spread Early Sample Point for EMUX Conversions
    * */
    /* Note, the clock and timing settings of master and slave channels MUST BE THE SAME */
    EVADC_G0ICLASS0.B.STCS  = 0x1F;
    EVADC_G1ICLASS0.B.STCS  = 0x1F;
    EVADC_G2ICLASS0.B.STCS  = 0x1F;
    EVADC_G3ICLASS0.B.STCS  = 0x1F;

    /*
     * GxCHCTRy - Channel Control Register
        * ICLSEL [0:1]  - 0x00  --> Input Class Select
        * BNDSELL[4:5]  - 0x00  --> Lower Boundary Select
        * BNDSELU[6:7]  - 0x00  --> Upper Boundary Select
        * CHEVMODE[8:9] - 0x00  --> Channel Event Mode
        * SYNC[10]      - 0x00  --> Synchronization Request
        * REFSEL[11]    - 0x00  --> Reference Input Selection
        * BNDSELX[12:15]- 0x00  --> BoundaryExtensions
        * RESREG[16:19] - 0x00  --> Result Register
        * RESTGT[20]    - 0x00  --> Result Target
        * RESPOS[21]    - 0x00  --> Result Position
        * BWDCH[28:29]  - 0x00  --> Broken Wire Detection Channel
        * BWDEN[30]     - 0x00  --> Broken Wire Detection Enable
    * */
    EVADC_G0CHCTR0.B.RESREG = 0x0;  /* Store result from group 0 channel 0 to result register 0 */
    EVADC_G0CHCTR4.B.RESREG = 0x4;  /* Store result from group 0 channel 4 to result register 4 */
    EVADC_G0CHCTR1.B.RESREG = 0x1;  /* Store result from group 0 channel 1 to result register 1 */

    EVADC_G1CHCTR0.B.RESREG = 0x0;  /* Store result from group 1 channel 0 to result register 0 */
    EVADC_G1CHCTR4.B.RESREG = 0x4;  /* Store result from group 1 channel 4 to result register 4 */
    EVADC_G1CHCTR1.B.RESREG = 0x1;  /* Store result from group 1 channel 1 to result register 1 */

    EVADC_G2CHCTR0.B.RESREG = 0x0;  /* Store result from group 2 channel 0 to result register 0 */
    EVADC_G2CHCTR4.B.RESREG = 0x4;  /* Store result from group 2 channel 4 to result register 4 */
    EVADC_G2CHCTR1.B.RESREG = 0x1;  /* Store result from group 2 channel 1 to result register 1 */

    EVADC_G3CHCTR0.B.RESREG = 0x0;  /* Store result from group 3 channel 0 to result register 0 */
    EVADC_G3CHCTR4.B.RESREG = 0x4;  /* Store result from group 3 channel 4 to result register 4 */
    /* G3CH1 redirected to G3CH5 using ALIAS feature */
    EVADC_G3CHCTR1.B.RESREG = 0x5;  /* Store result from group 3 channel 5 to result register 5 */

    /* Enable arbitration slot x accordingly
     * In this example, QINR1 is used.
    * GxARBPR - Arbitration Priority Register i, i=0-2
        * PRIOi[4*i+1:4*i]  - 0x0  --> Priority of Request Source i
        * CSMi[4*i+3]       - 0x0   --> Conversion Start Mode of Request Source i
        * ASENi[i+24]       - 0x1   --> Arbitration Source Input i Enable
    * */
    EVADC_G0ARBPR.B.ASEN1 = 0;
    EVADC_G1ARBPR.B.ASEN1 = 0;
    EVADC_G2ARBPR.B.ASEN1 = 1;
    EVADC_G3ARBPR.B.ASEN1 = 0;
    /* Setup Module clock
     * ANCFG - Analog Fct. Config. Register,
         * IPE[0]       - 0x0   --> Idle Precharge
         * BE[1]        - 0x0   --> Input Buffer
         * RPE[2]       - 0x1   --> Reference Precharge
         * RPC[3]       - 0x0   --> Reference Precharge Control
         * CALSTC[4:5]  - 0x0   --> Calibration Sample Time Control
         * DPCAL[6]     - 0x1   --> Disable Post-Calibration
         * ACSD[16:18]  - 0x00  --> Analog Clock Synchronization Delay
         * SSE[19]      - 0x1   --> Sample Synchronization
         * DIVA[20:24]  - 0x03  --> Divider Factor for the Analog Internal Clock (F_adci), 0x03 = 40MHz
         * DCMSB[25]    - 0x0   --> Double Clock for the MSB Conversion
     * */

    EVADC_G0ANCFG.U = ( 0x1 << 2 ) | ( 0x1 << 6 ) | ( 0x1 << 19) | ( 0x3 << 20 );
    EVADC_G1ANCFG.U = ( 0x1 << 2 ) | ( 0x1 << 6 ) | ( 0x1 << 19) | ( 0x3 << 20 );
    EVADC_G2ANCFG.U = ( 0x1 << 2 ) | ( 0x1 << 6 ) | ( 0x1 << 19) | ( 0x3 << 20 );
    EVADC_G3ANCFG.U = ( 0x1 << 2 ) | ( 0x1 << 6 ) | ( 0x1 << 19) | ( 0x3 << 20 );

    /* Configure Group 2 as the master. See README.md */
    EVADC_G2SYNCTR.B.STSEL = 0;
    EVADC_G2SYNCTR.B.EVALR1 = 1;
    EVADC_G2SYNCTR.B.EVALR2 = 1;
    EVADC_G2SYNCTR.B.EVALR3 = 1;

    /* Configure Group 0 as one of the three slaves. See README.md */
    EVADC_G0SYNCTR.B.STSEL = 2;
    EVADC_G0SYNCTR.B.EVALR1 = 1;
    EVADC_G0SYNCTR.B.EVALR2 = 1;
    EVADC_G0SYNCTR.B.EVALR3 = 1;

    /* Configure Group 1 as one of the three slaves. See README.md */
    EVADC_G1SYNCTR.B.STSEL = 2;
    EVADC_G1SYNCTR.B.EVALR1 = 1;
    EVADC_G1SYNCTR.B.EVALR2 = 1;
    EVADC_G1SYNCTR.B.EVALR3 = 1;

    /* Configure Group 3 as one of the three slaves. See README.md */
    EVADC_G3SYNCTR.B.STSEL = 3;
    EVADC_G3SYNCTR.B.EVALR1 = 1;
    EVADC_G3SYNCTR.B.EVALR2 = 1;
    EVADC_G3SYNCTR.B.EVALR3 = 1;

    /* Only for master: the same channels on slaves should also be triggered synchronously */
    EVADC_G2CHCTR0.B.SYNC = 1;
    EVADC_G2CHCTR1.B.SYNC = 1;
    EVADC_G2CHCTR4.B.SYNC = 1;

    /* Enable Module Operation
    * GxARBCFG - Arbitration Config. Register
       * ANONC[0:1]     - 0x03 --> Analog Converter Control, 0x03 = Normal Operation
       * ANONs[16:17]   - rh --> Analog Converter Control Status
       * CHNR[20:24]    - rh --> Channel Number
       * SYNRUN[25]     - rh --> Synchronous Conversion Running
       * CAL[28]        - rh --> Start-Up Calibration Active Indication
       * BUSY[30]       - rh --> Converter Busy Flag
       * SAMPLE[31]     - rh --> Sample Phase Flag
    * */

    /* EVADC_GxSYNCTR shall be programmed when the master and slaves are ALL OFF */
    /* Otherwise ADC behavior becomes unpredictable: conversion could be missed! */
    /* Switch on the master and slaves will be on automatically */
    EVADC_G2ARBCFG.B.ANONC = 0x3;

    /* Wait at least 3us to settle analog part */
    wait_micro_second(3);

    /* Request startup calibration
    * EVADC_GLOBCFG - Global Configuration Register
        * USC[12]       - 0x0   --> Unsynchronized Clock Generation
        * SUPLEV[13:14] - 0x00  --> Supply Voltage Level, Automatic control
        * CPWC[15]      - 0x1   --> Write Control
        * SUCAL[31]     - 0x1   --> Start-Up Calibration
    * */
    EVADC_GLOBCFG.U = (1 << 31 ); /* Enable startup calibration */

    /* Wait until calibration is done */
    while((EVADC_G0ARBCFG.B.CAL == 0x1) || (EVADC_G2ARBCFG.B.CAL == 0x1) || (EVADC_G2ARBCFG.B.CAL == 0x1) || (EVADC_G3ARBCFG.B.CAL == 0x1));

    /* It's only necessary to configure the master group. Slaves will react automatically */
    /* Configure Source Control Trigger & Gate
    * GxQCTRLi (i=0-2;x=0-11) - Queue i Source Contr. Register, Group x
        * SRCRESREG[0:3]    - 0x00  --> Source-specific Result Register
        * TRSEL[7:6]        - 0x00  --> Trigger Source Selection
        * XTSEL[8:11]       - 0x00  --> External Trigger Input Selection
        * XTLVL[12]         - 0x00  --> External Trigger Level
        * XTMODE[13:14]     - 0x00  --> Trigger Operating Mode
        * XTWC[15]          - 0x00  --> Control for Trigger Configuration
        * GTSEL[16:19]      - 0x00  --> Gate Input Selection
        * GTLVL[20]         - 0x00  --> Gate Input Level
        * GTWC[23]          - 0x00  --> Write Control for Gate Configuration
        * TMEN[28]          - 0x00  --> Timer Mode Enable
        * TMWC[31]          - 0x00  --> Write Control for Timer Mode
    * */

    EVADC_G2QCTRL1.U = 0;

    /* Enable Trigger & Gate for Request Source 0
    * GxQMRi (i=0-2;x=0-11) - Queue i Mode Register, Group x
        * ENGT[0:1]    - 0x01  --> Enable Gate
        * ENTR[2]      - 0x1   --> Enable External Trigger
        * CLRV[8]      - 0x0   --> Clear Valid Bit
        * TREV[9]      - 0x0   --> Trigger Event
        * FLUSH[10]    - 0x0   --> Flush Queue
        * CEV[11]      - 0x0   --> Clear Event Flag
        * PTDIS[16]    - 0x0   --> Repeat Disable
    * */
    EVADC_G2QMR1.B.ENGT = 0x1;  /* Enable Gate */

    /* Add Channels 0 and 3 to Group 2 Queue Source 0 and enable External Trigger */
    /* GxQINRi (i=0-2) - Queue i Input Register, Group x
        * REQCHNR[0:4]  - 0x00  --> Request Channel Number
        * RF[5]         - 0x00  --> Refill
        * ENSI[6]       - 0x00  --> Enable Source Interrupt
        * EXTR[7]       - 0x0x  --> External Trigger
        * PDD[9]        - 0x00  --> Pull-Down Diagnostics Enable
        * MDPD[10]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable
        * MDPU[11]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable - MDPD,MDPU
        * CDEN[12]      - 0x00  --> Converter Diagnostics Enable
        * CDSEL[13:14]  - 0x00  --> Converter Diagnostics Pull-Devices Select
    * */

    /* Expected conversion sequence:
     * GxCH0->GxCH4->GxCH1 (x = 0, 1, 2, 3)
     * In this example, QINR1 is used (any queue 0 or 1 or 2 can be used)
     * It is only necessary to trigger the master, and slaves will start conversion at the same time automatically
     * Note, as Alias feature re-directs G3CH1 to G3CH5, G3CH5 will be converted instead of G3CH1
     */
    EVADC_G3ALIAS.B.ALIAS1 = 5;

    EVADC_G2QINR1.U = ( 0x0 << 0 ) | ( 0x1 << 7 );
    EVADC_G2QINR1.U = ( 0x4 << 0 ) | ( 0x0 << 7 );
    EVADC_G2QINR1.U = ( 0x1 << 0 ) | ( 0x0 << 7 );


    EVADC_G2QMR1.B.TREV = 1; /* Trigger the conversion sequence in the Queue */

    return;

}
