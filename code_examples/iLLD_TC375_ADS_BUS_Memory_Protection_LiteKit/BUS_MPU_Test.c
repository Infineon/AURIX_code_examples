/**********************************************************************************************************************
 * \file BUS_MPU_Test.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "BUS_MPU_Test.h"
#include "BUS_MPU.h"

/*********************************************************************************************************************/
/**----------------------------------------------------variables--------------------------------------------------- **/
/*********************************************************************************************************************/
/* Define an array of integers  */
/* Forcing this vector to place in particular memory (DLMU) */
uint8 DLMU_Array[ALL_REGION_SIZE] __at(0xB0000000);

/* Forcing this vector to place in particular memory (SPR) */
uint8 SPR_Array[ALL_REGION_SIZE] __at(0x70000000);

/* Forcing this vector to place in particular memory (PFlash) */
/* The 0x00 in PFlash are often used for erased or un-programmed memory cell */
const uint8 PFlash_Array[32] __at(0xA0002000) = {
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
        17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,
};
volatile uint8  Test_Number = 0;                             /* To choose Test1, Test2 and Test3(Overlap/NonOverlap) */
volatile uint8  Test_Section = 0;                                                  /* 0: DLMU, 1: SPR, 2: Flash      */
volatile uint32 DLMU_Error_Count = 0;          /* Counting errors when non-protected element in DLMU0 has been read  */
volatile uint32 SPR_Error_Count = 0;            /* Counting errors when non-protected element in SPR0 has been read  */
volatile uint32 PFlash_Error_Count = 0;       /* Counting errors when non-protected element in PFlash0 has been read */

/*********************************************************************************************************************/
/*-------------------------------------------------------Macros------------------------------------------------------*/
/*********************************************************************************************************************/
/* LEDs */
#define ledOn(LED)   IfxPort_setPinLow(LED)
#define ledOff(LED)   IfxPort_setPinHigh(LED)

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the port pins that drive the LEDs */
void initLED(void)
{
    /* Initialization of the LED port pins */
    IfxPort_setPinModeOutput(LED_ERROR, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinModeOutput(LED_SUCCESS, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Switch OFF the LED (low-level active) */
    IfxPort_setPinHigh(LED_ERROR);
    IfxPort_setPinHigh(LED_SUCCESS);
}
/* Initialization of the LED for test core configuration */
void Test_LED_init(void)
{
    initLED();
    ledOff(LED_ERROR);
    ledOff(LED_SUCCESS);
}

/**
 * Test Example
 *
 * Test 1 : Full Access
 * Test 2 : Non-Overlap Regions: CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1
 * Test 3 : Overlap Regions: CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 *
 * "Configuration" and "Execute" has been done for all Tests on each local memories (DLMU,SPR,PFlash).
 *
 * If try to read/write access to the non-protected element:
 * TEST_1_DLMU              1 -> Write: Silently ignored    Read: No Trap
 * TEST_1_SPR               2 -> Write: Silently ignored    Read: No Trap
 * TEST_1_PFLASH            3 -> Write: Silently ignored    Read: No Trap
 * TEST_2_DLMU              4 -> Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_2_SPR               5 -> Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_2_PFLASH            6 -> Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_3_DLMU_NON_OVERLAP  7 -> Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_3_SPR_NON_OVERLAP   8 -> Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_3_PFLASH            9 -> Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_3_DLMU_OVERLAP      10 -> Write: Silently ignored   Read: No Trap
 * TEST_3_SPR_OVERLAP       11 -> Write: Silently ignored   Read: No Trap
 */
/* Test1 Configuration for DLMU0 */
void Test1_DLMU_configuration(void)
{
    Test_Number = TEST_1_DLMU;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* Configure BUS memory protection for DLMU0
     * 8 read and write protected regions of DLMU0 with enables for reads and writes on a per bus master basis.
     * Rules for BUS memory protection range configuration for DLMU0:
     * Protection ranges of DLMU0 are defined by the Lower address of the region, and the Upper address of the region.
     * After enabling the BUS Memory Protection, access to an address 'x' will be allowed only if:
     * lowerBoundAddress <= x < upperBoundAddress and the master tag of the access is enabled.
     * If any of these conditions are not satisfied, the access is seen as invalid.
     */
    /* Define the Protection Range 0: from 0xB0000000 up to 0xB000001F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 0],
            (uint32) &DLMU_Array[REGION_SIZE * 1], BUS_PROTECTION_RANGE_0);

    /* Define the Protection Range 1: from 0xB0000020 up to 0xB000003F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 1],
            (uint32) &DLMU_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_1);

    /* Define the Protection Range 2: from 0xB0000040 up to 0xB000005F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 2],
            (uint32) &DLMU_Array[REGION_SIZE * 3], BUS_PROTECTION_RANGE_2);

    /* Define the Protection Range 3: from 0xB0000060 up to 0xB000007F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 3],
            (uint32) &DLMU_Array[REGION_SIZE * 4], BUS_PROTECTION_RANGE_3);

    /* Define the Protection Range 4: from 0xB0000080 up to 0xB000009F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 4],
            (uint32) &DLMU_Array[REGION_SIZE * 5], BUS_PROTECTION_RANGE_4);

    /* Define the Protection Range 5: from 0xB00000A0 up to 0xB00000BF */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 5],
            (uint32) &DLMU_Array[REGION_SIZE * 6], BUS_PROTECTION_RANGE_5);

    /* Define the Protection Range 6: from 0xB00000C0 up to 0xB00000DF */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 6],
            (uint32) &DLMU_Array[REGION_SIZE * 7], BUS_PROTECTION_RANGE_6);

    /* Define the Protection Range 7: from 0xB00000E0 up to the end of DLMU0 local memory */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 7],
            (uint32) 0xB000FFFF, BUS_PROTECTION_RANGE_7);

    /* Enable read and write access of Core0 and Core1 to the
      Protection Range 0 and Range 1 in the DLMU0 Local Memory.
     */
    /* Enable read access of Core0 to the protection range 0, and protection range 1. */
    enable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /* Enable read access of Core1 to the protection range 0, and protection range 1. */
    enable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    enable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Enable write access of Core0 to the protection range 0, and protection range 1. */
    enable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /* Enable write access of Core1 to the protection range 0, and protection range 1. */
    enable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    enable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test1 Execute for DLMU0 */
void Test1_DLMU_execute(void)
{
    Test_Number = TEST_1_DLMU;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        DLMU_Array[i] = (uint8) i;
    }
    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    DLMU_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 0;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read. */
        if (DLMU_Array[i] != (uint8) i)
        {
            DLMU_Error_Count++;
        }
    }
    if (DLMU_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (DLMU_Error_Count)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test1 Configuration for DSPR0/PSPR0 */
void Test1_SPR_configuration(void)
{
    Test_Number = TEST_1_SPR;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* Configure BUS memory protection for SPR0 (DSPR0/PSPR0.
     * 8 read and write protected regions of scratch pad memory (PSPR0, DSPR0).
     * Rules for BUS memory protection range configuration for DSPR0/PSPR0:
     * Protection ranges of DSPR0/PSPR0 are defined by the Lower address of the region,
       and the Upper address of the region.
     * After enabling the BUS Memory Protection, access to an address 'x' will be allowed only if:
       lowerBoundAddress <= x < upperBoundAddress and the master tag of the access is enabled.
     * If any of these conditions are not satisfied, the access is seen as invalid.
     */
    /* Define the Protection Range 0: from 0x70000000 up to 0x7000001F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 0],
            (uint32) &SPR_Array[REGION_SIZE * 1], BUS_PROTECTION_RANGE_0);

    /* Define the Protection Range 1: from 0x70000020 up to 0x7000003F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 1],
            (uint32) &SPR_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_1);

    /* Define the Protection Range 2: from 0x70000040 up to 0x7000005F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 2],
            (uint32) &SPR_Array[REGION_SIZE * 3], BUS_PROTECTION_RANGE_2);

    /* Define the Protection Range 3: from 0x70000060 up to 0x7000007F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 3],
            (uint32) &SPR_Array[REGION_SIZE * 4], BUS_PROTECTION_RANGE_3);

    /* Define the Protection Range 4: from 0x70000080 up to 0x7000009F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 4],
            (uint32) &SPR_Array[REGION_SIZE * 5], BUS_PROTECTION_RANGE_4);

    /* Define the Protection Range 5: from 0x700000A0 up to 0x700000BF */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 5],
            (uint32) &SPR_Array[REGION_SIZE * 6], BUS_PROTECTION_RANGE_5);

    /* Define the Protection Range 6: from 0x700000C0 up to 0x700000DF */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 6],
            (uint32) &SPR_Array[REGION_SIZE * 7], BUS_PROTECTION_RANGE_6);

    /* Define the Protection Range 7: from 0x700000E0 up to the end of DSPR0/PSPR0 local memory */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 7],
            (uint32) 0x7000FFFF, BUS_PROTECTION_RANGE_7);

    /* Enable read and write access of Core0 and Core1 to the
       Protection Range 0 and Range 1 in the SPR0 (DSPR0/PSPR0) local memory.
     */
    /* Enable read access of Core0 to the protection range 0, and protection range 1. */
    enable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /* Enable read access of Core1 to the protection range 0, and protection range 1. */
    enable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    enable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Enable write access of Core0 to the protection range 0, and protection range 1. */
    enable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /* Enable write access of Core1 to the protection range 0, and protection range 1. */
    enable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    enable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test1 Execute for SPR0 (DSPR0/PSPR0) */
void Test1_SPR_execute(void)
{
    Test_Number = TEST_1_SPR;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        SPR_Array[i] = (uint8) i;
    }
    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    SPR_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 1;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read (CHECK ERROR). */
        if (SPR_Array[i] != (uint8) i)
        {
            SPR_Error_Count++;
        }
    }
    if (SPR_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (SPR_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test1 Configuration for PFlah0 */
void Test1_PFlash_configuration(void)
{
    Test_Number = TEST_1_PFLASH;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* For PFlash0, no registers are used for defining the protection range.
     * Entire local PFlash is defined for the region.
     * Enable read access of Core0 and Core1 for entire PFlash0 local memory is considered.
     */

    /*---Enable read access of Core0 and Core1 to the the local PFlash Bank (LPB0)----*/
    enable_LPB0_read_bus_protection_range(CORE_0);
    enable_LPB0_read_bus_protection_range(CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test1 Execute for PFlash0 */
void Test1_PFlash_execute(void)
{
    Test_Number = TEST_1_PFLASH;

    /* Test for the PFlash is performed just for the (Read) module. */

    PFlash_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 2;

    /* Make a read access to entire local PFlash. */
    for (uint32 i = 0; i < sizeof(PFlash_Array); i++)
    {
      /* The 0x00 and 0xFF value in PFlash are often used for erased or un-programmed memory cell (CHECK ERROR). */
        if (PFlash_Array[i] == 0 || PFlash_Array[i] == 0xFF)
        {
            PFlash_Error_Count++;
        }
    }
    if (PFlash_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (PFlash_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test2 Configuration for DLMU0 */
/* Test2 : Non-Overlap Region => CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1 */
void Test2_DLMU_configuration(void)
{
    Test_Number = TEST_2_DLMU;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* Configure BUS memory protection for DLMU0.
     * 8 read and write protected regions of DLMU0.
     * Rules for BUS memory protection range configuration for DLMU0:
     * Protection ranges of DLMU0 are defined by the Lower address of the region,
       and the Upper address of the region.
     * After enabling the BUS Memory Protection, access to an address 'x' will be allowed only if:
       lowerBoundAddress <= x < upperBoundAddress and the master tag of the access is enabled.
     * If any of these conditions are not satisfied, the access is seen as invalid.
     */
    /* Define the Protection Range 0: from 0xB0000000 up to 0xB000001F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 0],
            (uint32) &DLMU_Array[REGION_SIZE * 1], BUS_PROTECTION_RANGE_0);

    /* Define the Protection Range 1: from 0xB0000020 up to 0xB000003F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 1],
            (uint32) &DLMU_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_1);

    /* Define the Protection Range 2: from 0xB0000040 up to 0xB000005F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 2],
            (uint32) &DLMU_Array[REGION_SIZE * 3], BUS_PROTECTION_RANGE_2);

    /* Define the Protection Range 3: from 0xB0000060 up to 0xB000007F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 3],
            (uint32) &DLMU_Array[REGION_SIZE * 4], BUS_PROTECTION_RANGE_3);

    /* Define the Protection Range 4: from 0xB0000080 up to 0xB000009F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 4],
            (uint32) &DLMU_Array[REGION_SIZE * 5], BUS_PROTECTION_RANGE_4);

    /* Define the Protection Range 5: from 0xB00000A0 up to 0xB00000BF */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 5],
            (uint32) &DLMU_Array[REGION_SIZE * 6], BUS_PROTECTION_RANGE_5);

    /* Define the Protection Range 6: from 0xB00000C0 up to 0xB00000DF */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 6],
            (uint32) &DLMU_Array[REGION_SIZE * 7], BUS_PROTECTION_RANGE_6);

    /* Define the Protection Range 7: from 0xB00000E0 up to the end of DLMU0 memory*/
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 7],
            (uint32) 0xB000FFFF, BUS_PROTECTION_RANGE_7);

    /*---Enable read and write access of Core0 to Range 0 of DLMU0 ----*/
    enable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);

    /*---Not read and write access of Core0 to Range 1 of DLMU0 ----*/
    disable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);
    disable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /*---Not read and write access of Core1 to Range 0 of DLMU0 ----*/
    disable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    disable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);

    /*---Not read and write access of Core1 to Range 1 of DLMU0 ----*/
    disable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);
    disable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test2 Execute for DLMU0 */
/* Test2 : Non-Overlap Region => CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1
 * Access to the non-protected element: Write: Silently ignored    Read: Expect to Trap
 */
void Test2_DLMU_execute(void)
{
    Test_Number = TEST_2_DLMU;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        DLMU_Array[i] = (uint8) (i + 5);
    }

    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    DLMU_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 0;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read (CHECK ERROR). */
        /* Trap is triggered. */
        if (DLMU_Array[i] == (uint8) (i + 5))
        {
            DLMU_Error_Count++;
        }
    }
    if (DLMU_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (DLMU_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test2 Configuration for SPR0 (DSPR0/PSPR0) */
/* Test 2 : Non-Overlap Region => CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1 */
void Test2_SPR_configuration(void)
{
    Test_Number = TEST_2_SPR;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* Configure BUS memory protection for SPR0 (DSPR0/PSPR0.
     * 8 read and write protected regions of scratch pad memory (PSPR0, DSPR0.
     * Rules for BUS memory protection range configuration for DSPR0/PSPR0:
     * Protection ranges of DSPR0/PSPR0 are defined by the Lower address of the region,
       and the Upper address of the region.
     * After enabling the BUS Memory Protection, access to an address 'x' will be allowed only if:
     * lowerBoundAddress <= x < upperBoundAddress and the master tag of the access is enabled.
     * If any of these conditions are not satisfied, the access is seen as invalid.
     */
    /* Define the Protection Range 0: from 0x70000000 up to 0x7000001F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 0],
            (uint32) &SPR_Array[REGION_SIZE * 1], BUS_PROTECTION_RANGE_0);

    /* Define the Protection Range 1: from 0x70000020 up to 0x7000003F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 1],
            (uint32) &SPR_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_1);

    /* Define the Protection Range 2: from 0x70000040 up to 0x7000005F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 2],
            (uint32) &SPR_Array[REGION_SIZE * 3], BUS_PROTECTION_RANGE_2);

    /* Define the Protection Range 3: from 0x70000060 up to 0x7000007F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 3],
            (uint32) &SPR_Array[REGION_SIZE * 4], BUS_PROTECTION_RANGE_3);

    /* Define the Protection Range 4: from 0x70000080 up to 0x7000009F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 4],
            (uint32) &SPR_Array[REGION_SIZE * 5], BUS_PROTECTION_RANGE_4);

    /* Define the Protection Range 5: from 0x700000A0 up to 0x700000BF */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 5],
            (uint32) &SPR_Array[REGION_SIZE * 6], BUS_PROTECTION_RANGE_5);

    /* Define the Protection Range 6: from 0x700000C0 up to 0x700000DF */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 6],
            (uint32) &SPR_Array[REGION_SIZE * 7], BUS_PROTECTION_RANGE_6);

    /* Define the Protection Range 7: from 0x700000E0 up to the end of DSPR0/PSPR0 memory */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 7],
            (uint32) 0x7000FFFF, BUS_PROTECTION_RANGE_7);

    /*---Enable read and write access of Core0 to Range 0 of SPR0 ----*/
    enable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);

    /*---Not read and write access of Core0 to Range 1 of SPR0 ----*/
    disable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);
    disable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /*---Not read and write access of Core1 to Range 0 of SPR0 ----*/
    disable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    disable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);

    /*---Not read and write access of Core1 to Range 1 of SPR0 ----*/
    disable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);
    disable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test2 Execute for SPR0
 * Test 2 : Non-Overlap Region => CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1
 * Access to the non-protected element: Write: Silently ignored    Read: Expect to Trap
 */
void Test2_SPR_execute(void)
{
    Test_Number = TEST_2_SPR;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
       /* Initialize data with incrementing values. It is useful for testing. */
        SPR_Array[i] = (uint8) (i + 5);
    }

    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    SPR_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 1;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read (CHECK ERROR). */
        /* Trap is triggered. */
        if (SPR_Array[i] == (uint8) (i + 5))
        {
            SPR_Error_Count++;
        }
    }
    if (SPR_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (SPR_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test2 Configuration for PFlah0 */
void Test2_PFlash_configuration(void)
{
    Test_Number = TEST_2_PFLASH;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* For local PFlash0, no registers are used for defining the protection range.
     * Entire local PFlash is defined for the region.
     */
    /*--Read access of Core0 to LPB0, and NOT Read access of Core1 to LPB0----*/
    enable_LPB0_read_bus_protection_range(CORE_0);
    disable_LPB0_read_bus_protection_range(CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test2 Execute for PFlash0 */
void Test2_PFlash_execute(void)
{
    Test_Number = TEST_2_PFLASH;

    /* Test for the PFlash is performed just for the (Read) module. */

    PFlash_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 2;

    /* Make a read access to entire local PFlash. */
    for (uint32 i = 0; i < sizeof(PFlash_Array); i++)
    {
        /* The 0x00 and 0xFF value in PFlash are often used for erased or un-programmed memory cell (CHECK ERROR) */
        /* Trap is triggered. */
        if (PFlash_Array[i] != 0 || PFlash_Array[i] != 0xFF)
        {
            PFlash_Error_Count++;
        }
    }
    if (PFlash_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (PFlash_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test3 Configuration for DLMU0 */
/* Test3 : Overlap Regions: CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1 */
void Test3_DLMU_configuration(void)
{
    Test_Number = TEST_3_DLMU_NON_OVERLAP;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* Configure BUS memory protection for DLMU0.
     * 8 read and write protected regions of DLMU0 with enables for reads and writes on a per bus master basis.
     * Rules for BUS memory protection range configuration for DLMU0:
     * Protection ranges of DLMU0 are defined by the Lower address of the region, and the Upper address of the region.
     * After enabling the BUS Memory Protection, access to an address 'x' will be allowed only if:
     * lowerBoundAddress <= x < upperBoundAddress and the master tag of the access is enabled.
     * If any of these conditions are not satisfied, the access is seen as invalid.
     */
    /* NOTE: In Test3 configuration range 0 and range 1 are overlapped.
     * All other ranges (2..8), configured as Non-overlap ranges.
     * Test3 "execution" has been done for both overlap, and Non-overlap regions.
     */
    /* Define the Protection Range 0: from 0xB0000000 up to 0xB000003F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 0],
            (uint32) &DLMU_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_0);

    /* Define the Protection Range 1: from 0xB0000020 up to 0xB000003F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 1],
            (uint32) &DLMU_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_1);

    /* Define the Protection Range 2: from 0xB0000040 up to 0xB000005F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 2],
            (uint32) &DLMU_Array[REGION_SIZE * 3], BUS_PROTECTION_RANGE_2);

    /* Define the Protection Range 3: from 0xB0000060 up to 0xB000007F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 3],
            (uint32) &DLMU_Array[REGION_SIZE * 4], BUS_PROTECTION_RANGE_3);

    /* Define the Protection Range 4: from 0xB0000080 up to 0xB000009F */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 4],
            (uint32) &DLMU_Array[REGION_SIZE * 5], BUS_PROTECTION_RANGE_4);

    /* Define the Protection Range 5: from 0xB00000A0 up to 0xB00000BF */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 5],
            (uint32) &DLMU_Array[REGION_SIZE * 6], BUS_PROTECTION_RANGE_5);

    /* Define the Protection Range 6: from 0xB00000C0 up to 0xB00000DF */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 6],
            (uint32) &DLMU_Array[REGION_SIZE * 7], BUS_PROTECTION_RANGE_6);

    /* Define the Protection Range 7: from 0xB00000E0 up to the end of DLMU0 local memory */
    define_DLMU0_bus_protection_range((uint32) &DLMU_Array[REGION_SIZE * 7],
            (uint32) 0xB000FFFF, BUS_PROTECTION_RANGE_7);

    /*---Enable read and write access of Core0 to Range 0 of DLMU0 ----*/
    enable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);

    /*---Not read and write access of Core0 to Range 1 of DLMU0 ----*/
    disable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);
    disable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /*---Not read and write access of Core1 to Range 0 of DLMU0 ----*/
    disable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    disable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);

    /*---Enable Read and write access of Core1 to Range 1 of DLMU0 ----*/
    enable_DLMU0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);
    enable_DLMU0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test 3 Execute for DLMU0-Non-overlap
 * Test 3 : Non-Overlap Region => CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 * Access to the non-protected element: Write: Silently ignored    Read: Expect to Trap
 */
void Test3_DLMU_NonOverlap_execute(void)
{
    Test_Number = TEST_3_DLMU_NON_OVERLAP;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 1; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        DLMU_Array[i] = (uint8) (i + 7);
    }

    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    DLMU_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 0;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 1; i++)
    {
        /* Check whether the protected element has been read (CHECK ERROR). */
        /* Trap is triggered. */
        if (DLMU_Array[i] == (uint8) (i + 7))
        {
            DLMU_Error_Count++;
        }
    }
    if (DLMU_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (DLMU_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test 3 Execute for DLMU0-overlap
 * Test 3 : Overlap Region:  CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 * Access to the non-protected element: Write: Silently ignored   Read: No Trap
 * In case of conflict or overlap, if an access for a region is enabled, it is "allowed".
 */
void Test3_DLMU_Overlap_execute(void)
{
    Test_Number = TEST_3_DLMU_OVERLAP;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = REGION_SIZE; i < REGION_SIZE * 2; i++)
    {
        DLMU_Array[i] = (uint8) (i + 7);   /* Initialize data with incrementing values. It is useful for testing. */
    }

    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    DLMU_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 0;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = REGION_SIZE; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read (CHECK ERROR). */
        if (DLMU_Array[i] != (uint8) (i + 7))
        {
            DLMU_Error_Count++;
        }
    }
    if (DLMU_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (DLMU_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test 3 Configuration for SPR0. */
/* Test 3 : Overlap Region: CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1 */
void Test3_SPR_configuration(void)
{
    Test_Number = TEST_3_SPR_NON_OVERLAP;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* Configure BUS memory protection for SPR0 (DSPR0/PSPR0.
     * 8 read and write protected regions of scratch pad memory (PSPR0, DSPR0).
     * Rules for BUS memory protection range configuration for DSPR0/PSPR0:
     * Protection ranges of DSPR0/PSPR0 are defined by the Lower address of the region,
       and the Upper address of the region.
     * After enabling the BUS Memory Protection, access to an address 'x' will be allowed only if:
     * lowerBoundAddress <= x < upperBoundAddress and the master tag of the access is enabled.
     * If any of these conditions are not satisfied, the access is seen as invalid.
     */
    /* NOTE: In Test3 configuration range 0 and range 1 are overlapped.
     * All other ranges (2..8), configured as Non-overlap ranges.
     * Configuration for Test3 SPR0 Overlap/non-overlap are the same.
     */
    /* Define the Protection Range 0: from 0x70000000 up to 0x7000003F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 0],
            (uint32) &SPR_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_0);

    /* Define the Protection Range 1: from 0x70000020 up to 0x7000003F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 1],
            (uint32) &SPR_Array[REGION_SIZE * 2], BUS_PROTECTION_RANGE_1);

    /* Define the Protection Range 2: from 0x70000040 up to 0x7000005F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 2],
            (uint32) &SPR_Array[REGION_SIZE * 3], BUS_PROTECTION_RANGE_2);

    /* Define the Protection Range 3: from 0x70000060 up to 0x7000007F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 3],
            (uint32) &SPR_Array[REGION_SIZE * 4], BUS_PROTECTION_RANGE_3);

    /* Define the Protection Range 4: from 0x70000080 up to 0x7000009F */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 4],
            (uint32) &SPR_Array[REGION_SIZE * 5], BUS_PROTECTION_RANGE_4);

    /* Define the Protection Range 5: from 0x700000A0 up to 0x700000BF */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 5],
            (uint32) &SPR_Array[REGION_SIZE * 6], BUS_PROTECTION_RANGE_5);

    /* Define the Protection Range 6: from 0x700000C0 up to 0x700000DF */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 6],
            (uint32) &SPR_Array[REGION_SIZE * 7], BUS_PROTECTION_RANGE_6);

    /* Define the Protection Range 7: from 0x700000E0 up to the end of SPR0 local memory */
    define_SPR0_bus_protection_range((uint32) &SPR_Array[REGION_SIZE * 7],
            (uint32) 0x7000FFFF, BUS_PROTECTION_RANGE_7);

    /*---Enable read and write access of Core0 to Range 0 of SPR0 ----*/
    enable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);
    enable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_0);

    /*---Not read and write access of Core0 to Range 1 of SPR0 ----*/
    disable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);
    disable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_0);

    /*---Not read and write access of Core1 to Range 0 of SPR0 ----*/
    disable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);
    disable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_0, CORE_1);

    /*---Enable read and write access of Core1 to Range 1 of SPR0 ----*/
    enable_SPR0_read_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);
    enable_SPR0_write_bus_protection_range(BUS_PROTECTION_RANGE_1, CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

/* Test 3 Execute for SPR0-Non-overlap
 * Test 3 : Overlap Region:  CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 * Access to the non-protected element: Write: Silently ignored   Read: Expect to Trap.
 */
void Test3_SPR_NonOverlap_execute(void)
{
    Test_Number = TEST_3_SPR_NON_OVERLAP;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 1; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        SPR_Array[i] = (uint8) (i + 7);
    }

    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    SPR_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 1;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 1; i++)
    {
        /* Check whether the non-protected element has been read (CHECK ERROR). */
        /* Trap is triggered. */
        if (SPR_Array[i] == (uint8) (i + 7))
        {
            SPR_Error_Count++;
        }
    }
    if (SPR_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (SPR_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}

/* Test 3 Execute for SPR0-overlap
 * Test 3 : Overlap Region:  CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 * Access to the non-protected element: Write: Silently ignored   Read: No Trap
 * In case of conflict or overlap, if an access for a region is enabled, it is "allowed".
 */
void Test3_SPR_Overlap_execute(void)
{
    Test_Number = TEST_3_SPR_OVERLAP;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = REGION_SIZE; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        SPR_Array[i] = (uint8) (i + 7);
    }

    /* Read range 0 and range 1 and compare with the write pattern (read & verify). */
    SPR_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    Test_Section = 1;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = REGION_SIZE; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read (CHECK ERROR). */
        if (SPR_Array[i] != (uint8) (i + 7))
        {
            SPR_Error_Count++;
        }
    }
    if (SPR_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (SPR_Error_Count != 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }
}
/* Test3 Configuration for PFlah0 */
void Test3_PFlash_configuration(void)
{
    Test_Number = TEST_3_PFLASH;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* For local PFlash0, no registers are used for defining the protection range.
     * Entire local PFlash is defined for the ranges.
     */

    /*--Read access of Core0 to LPB0, and NOT Read access of Core1 to LPB0----*/
    enable_LPB0_read_bus_protection_range(CORE_0);
    disable_LPB0_read_bus_protection_range(CORE_1);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);
}

void Test3_PFlash_execute(void)
{
    Test_Number = TEST_3_PFLASH;

    /* Test for the PFlash is performed just for the (Read) module. */

    PFlash_Error_Count = 0;

    /* Test the memory protection.
     * 0: DLMU, 1: SPR, 2: Flash.
     */
    for (uint32 i = 0; i < sizeof(PFlash_Array); i++)
    {
        /* The 0x00 and 0xFF value in PFlash are often used for erased or un-programmed memory cell (CHECK ERROR)*/
        /* Trap is triggered. */
        if (PFlash_Array[i] != 0 || PFlash_Array[i] != 0xFF)
        {
            PFlash_Error_Count++;
        }
    }
    if (PFlash_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
        ledOff(LED_ERROR);
    }
    else if (PFlash_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
        ledOn(LED_ERROR);
    }

}
