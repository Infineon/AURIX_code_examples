/**
 * \file IfxScrUart.h
 * \brief SCR UART basic functionality
 * \ingroup IfxLld_ScrUart
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_ScrUart_Std_Enumerations Enum
 * \ingroup IfxLld_ScrUart_Std
 * \defgroup IfxLld_ScrUart_Std_DataStructures Data structures
 * \ingroup IfxLld_ScrUart_Std
 * \defgroup IfxLld_ScrUart_Std_TxFunctionality Tx Functionality
 * \ingroup IfxLld_ScrUart_Std
 * \defgroup IfxLld_ScrUart_Std_RxFunctionality Rx Functionality
 * \ingroup IfxLld_ScrUart_Std
 * \defgroup IfxLld_ScrUart_Std_init UART Initialization Functionality
 * \ingroup IfxLld_ScrUart_Std
 * \defgroup IfxLld_ScrUart_Std_LinFunctionality Lin Functionality
 * \ingroup IfxLld_ScrUart_Std
 */

#ifndef IFXSCRUART_H
#define IFXSCRUART_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxScrUart_cfg.h"
#include "_Reg/IfxScr_bf.h"
#include "_Reg/IfxScr_reg.h"

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrUart_Std_Enumerations
 * \{ */
/** \brief Uart operating Mode
 *
 */
typedef enum
{
    IfxScrUart_Mode_0 = 0, /**< \brief Mode 0 - 8 bit shift register */
    IfxScrUart_Mode_1 = 1, /**< \brief Mode 1 - 8 bit serial port */
    IfxScrUart_Mode_2 = 2, /**< \brief Mode 2 - 9 bit serial port with fixed baudrate */
    IfxScrUart_Mode_3 = 3  /**< \brief Mode 3 - 9 bit serial port with variable baudrate */
}IfxScrUart_Mode;

/** \brief Prescaler for baudrate generator
 *
 */
typedef enum
{
    IfxScrUart_BaudratePrescaler_none = 0,         /**< \brief Fdiv = Fpclk */
    IfxScrUart_BaudratePrescaler_2    = 1,         /**< \brief Fdiv = Fpclk/2 */
    IfxScrUart_BaudratePrescaler_4    = 2,         /**< \brief Fdiv = Fpclk/4 */
    IfxScrUart_BaudratePrescaler_8    = 3,         /**< \brief Fdiv = Fpclk/8 */
    IfxScrUart_BaudratePrescaler_16   = 4,         /**< \brief Fdiv = Fpclk/16 */
    IfxScrUart_BaudratePrescaler_32   = 5          /**< \brief Fdiv = Fpclk/32 */
}IfxScrUart_BaudratePrescaler;

/** \brief Fractional divider for baudrate generator
 *
 */
typedef enum
{
    IfxScrUart_BaudrateFractionalDivider_none = 0,               /**< \brief Fractional divider none */
    IfxScrUart_BaudrateFractionalDivider_1,                      /**< \brief Fractional divider 1/32 */
    IfxScrUart_BaudrateFractionalDivider_2,                      /**< \brief Fractional divider 2/32 */
    IfxScrUart_BaudrateFractionalDivider_3,                      /**< \brief Fractional divider 3/32 */
    IfxScrUart_BaudrateFractionalDivider_4,                      /**< \brief Fractional divider 4/32 */
    IfxScrUart_BaudrateFractionalDivider_5,                      /**< \brief Fractional divider 5/32 */
    IfxScrUart_BaudrateFractionalDivider_6,                      /**< \brief Fractional divider 6/32 */
    IfxScrUart_BaudrateFractionalDivider_7,                      /**< \brief Fractional divider 7/32 */
    IfxScrUart_BaudrateFractionalDivider_8,                      /**< \brief Fractional divider 8/32 */
    IfxScrUart_BaudrateFractionalDivider_9,                      /**< \brief Fractional divider 9/32 */
    IfxScrUart_BaudrateFractionalDivider_10,                     /**< \brief Fractional divider 10/32 */
    IfxScrUart_BaudrateFractionalDivider_11,                     /**< \brief Fractional divider 11/32 */
    IfxScrUart_BaudrateFractionalDivider_12,                     /**< \brief Fractional divider 12/32 */
    IfxScrUart_BaudrateFractionalDivider_13,                     /**< \brief Fractional divider 13/32 */
    IfxScrUart_BaudrateFractionalDivider_14,                     /**< \brief Fractional divider 14/32 */
    IfxScrUart_BaudrateFractionalDivider_15,                     /**< \brief Fractional divider 15/32 */
    IfxScrUart_BaudrateFractionalDivider_16,                     /**< \brief Fractional divider 16/32 */
    IfxScrUart_BaudrateFractionalDivider_17,                     /**< \brief Fractional divider 17/32 */
    IfxScrUart_BaudrateFractionalDivider_18,                     /**< \brief Fractional divider 18/32 */
    IfxScrUart_BaudrateFractionalDivider_19,                     /**< \brief Fractional divider 19/32 */
    IfxScrUart_BaudrateFractionalDivider_20,                     /**< \brief Fractional divider 20/32 */
    IfxScrUart_BaudrateFractionalDivider_21,                     /**< \brief Fractional divider 21/32 */
    IfxScrUart_BaudrateFractionalDivider_22,                     /**< \brief Fractional divider 22/32 */
    IfxScrUart_BaudrateFractionalDivider_23,                     /**< \brief Fractional divider 23/32 */
    IfxScrUart_BaudrateFractionalDivider_24,                     /**< \brief Fractional divider 24/32 */
    IfxScrUart_BaudrateFractionalDivider_25,                     /**< \brief Fractional divider 25/32 */
    IfxScrUart_BaudrateFractionalDivider_26,                     /**< \brief Fractional divider 26/32 */
    IfxScrUart_BaudrateFractionalDivider_27,                     /**< \brief Fractional divider 27/32 */
    IfxScrUart_BaudrateFractionalDivider_28,                     /**< \brief Fractional divider 28/32 */
    IfxScrUart_BaudrateFractionalDivider_29,                     /**< \brief Fractional divider 29/32 */
    IfxScrUart_BaudrateFractionalDivider_30,                     /**< \brief Fractional divider 30/32 */
    IfxScrUart_BaudrateFractionalDivider_31                      /**< \brief Fractional divider 31/32 */
}IfxScrUart_BaudrateFractionalDivider;                           /**< \brief Fractional divider 32/32 */

/** \brief Pin options for UART RXD
 *
 */
typedef enum
{
    IfxScrUart_ReceiverInput_a = 0,  /**< \brief UART Receiver Input RXDA is selected */
    IfxScrUart_ReceiverInput_b = 1,  /**< \brief UART Receiver Input RXDB is selected */
    IfxScrUart_ReceiverInput_c = 2,  /**< \brief UART Receiver Input RXDC is selected */
    IfxScrUart_ReceiverInput_d = 3,  /**< \brief UART Receiver Input RXDD is selected */
    IfxScrUart_ReceiverInput_e = 4,  /**< \brief UART Receiver Input RXDE is selected */
    IfxScrUart_ReceiverInput_f = 5,  /**< \brief UART Receiver Input RXDF is selected */
    IfxScrUart_ReceiverInput_g = 6,  /**< \brief UART Receiver Input RXDG is selected */
    IfxScrUart_ReceiverInput_h = 7,  /**< \brief UART Receiver Input RXDH is selected */
    IfxScrUart_ReceiverInput_i = 8,  /**< \brief UART Receiver Input RXDI is selected */
    IfxScrUart_ReceiverInput_j = 9,  /**< \brief UART Receiver Input RXDJ is selected */
    IfxScrUart_ReceiverInput_k = 10, /**< \brief UART Receiver Input RXDK is selected */
    IfxScrUart_ReceiverInput_l = 11  /**< \brief UART Receiver Input RXDL is selected */
}IfxScrUart_ReceiverInput;

/** \brief LIN data size in bytes
 *
 */
typedef enum
{
    IfxScrUart_LinDataSize_2 = 2, /**< \brief Lin data size is 2 bytes */
    IfxScrUart_LinDataSize_4 = 4, /**< \brief Lin data size is 4 bytes */
    IfxScrUart_LinDataSize_8 = 8  /**< \brief Lin data size is 8 bytes */
}IfxScrUart_LinDataSize;

/** \brief Array index enum for selecting the baudrate from IfxScrUart_UartBaudrateConfig presetBaudrateConfig[];
 */
typedef enum
{
    IfxScrUart_UartPresetBaudrateConfig_115200 = 0,
    IfxScrUart_UartPresetBaudrateConfig_20000  = 1,
    IfxScrUart_UartPresetBaudrateConfig_19200  = 2,
    IfxScrUart_UartPresetBaudrateConfig_9600   = 3,
    IfxScrUart_UartPresetBaudrateConfig_4800   = 4,
    IfxScrUart_UartPresetBaudrateConfig_2400   = 5
}IfxScrUart_UartPresetBaudrateConfig;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_ScrUart_Std_DataStructures
 * \{ */
/** \brief Baudrate configuration structure
 * Baudrate is given by Baudrate = (f_pclk/16 * ((2^prescalar)*(reloadValue + (fracDiv/32))))
 */

typedef struct
{
    IfxScrUart_BaudratePrescaler         prescaler;                  /**< \brief Prescaler value fro baudrate generation */
    uint16                               reloadValue;                /**< \brief Reload value for baudrate generation */
    IfxScrUart_BaudrateFractionalDivider fracDiv;                    /**< \brief Fractional divider value for baudrate generation */
}IfxScrUart_UartBaudrateConfig;

/** \brief Baudrate configuration structure
 * Baudrate is given by Baudrate = (f_pclk/((2^prescalar)*(reloadValue+ (fracDiv/32))))
 */

typedef struct
{
    IfxScrUart_Mode                     mode;                       /**< \brief UART operating mode */
    IfxScrUart_UartBaudrateConfig       baudrateConfig;             /**< \brief Baud rate configuration */
    IfxScrUart_UartPresetBaudrateConfig presetBaudrate;             /**< \brief Preset Baud rate configuration */
    boolean                             usePresetBaudrateConfig;    /**< \brief True --> Enable Preset baud rate configuration */
    boolean                             enableDoubleMode2Frequency; /**< \brief True --> Module 2 baud rate doubling enabled(f_pclk/32)  or f_pclk/64 */
    IfxScrUart_ReceiverInput            rxd;                        /**< \brief Receiver input */
}IfxScrUart_UartConfig;

/** \brief LIN frame fields
 */

typedef struct
{
    uint8                  linId;           /**< \brief LIN Frame ID field */
    uint8                 *linDataPtr;      /**< \brief Pointer to the the data to be transmitted over LIN */
    IfxScrUart_LinDataSize dataSizeinBytes; /**< \brief Size of the data to be transmitted */
    uint8                  checksum;        /**< \brief LIN Frame checksum field. */
}IfxScrUart_LinMasterMessage;

/** \} */

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

IFX_EXTERN IFX_CONST IfxScrUart_UartBaudrateConfig presetBaudrateConfig[];

/** \addtogroup IfxLld_ScrUart_Std_TxFunctionality
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Sets the UART operating mode
 * \param mode UART mode to be selected
 * \return None.
 */

IFX_INLINE void IfxScrUart_setUartMode(IfxScrUart_Mode mode);

/** \brief Sets the Prescalar value for baudrate generator
 * \param prescaler Prescalar value
 * \return None.
 */

IFX_INLINE void IfxScrUart_setBaudratePrescaler(IfxScrUart_BaudratePrescaler prescaler);

/** \brief Sets the Fractional divider value for baudrate generator
 * \param divider Fractional divider value
 * \return None.
 */

IFX_INLINE void IfxScrUart_setBaudrateFractionalDivider(IfxScrUart_BaudrateFractionalDivider divider);

/** \brief Sets the reload value for baudrate generator
 * \param reloadValue Reload value for baudrate generate generator driver
 * \return None.
 */

IFX_INLINE void IfxScrUart_setReloadValue(uint16 reloadValue);

/** \brief UART mode 2 has 2 options for baudrate - f_pclk/64 and f_pclk/32.
 * This will enable or disable the doubling of baudrate
 * \param enable enable or disable the double baudrate in UART mode 2
 * \return None.
 */

IFX_INLINE void IfxScrUart_doubleMode2Baudrate(Ifx_Functionality enable);

/** \brief Enable or disable the baudrate generator.All baudrate settings must be done with this disabled and enabled after the settings are done..
 * \param enable enable or disable the double baudrate in UART mode 2
 * \return None.
 */

IFX_INLINE void IfxScrUart_enableDisableBaudrateGenerator(Ifx_Functionality enable);

/** \brief Send data byte through UART in the specified mode
 * \param data Data to be sent
 * \return None.
 */

IFX_INLINE void IfxScrUart_sendData(uint16 data);

/** \brief Returns status of UART transmission.
 * \return None
 */
IFX_INLINE boolean IfxScrUart_isTxDone(void);

/** \brief Clearing SCON.TI flag
 * \return None
 */
IFX_INLINE void IfxScrUart_clearTxFlag(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to send block of data
 * \param memptr Pointer to uart data.
 * \param size Size of data
 * \return None
 */
IFX_EXTERN void IfxScrUart_UartWrite(uint16 *const memptr, const uint16 size);

/** \} */

/** \addtogroup IfxLld_ScrUart_Std_RxFunctionality
 * \{ */
/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable or disable data reception
 * \param enable Option to enable or disable.For enabling pass Ifx_Functionality_enable and for disabling pass Ifx_Functionality_disable
 * \param mode UART operating mode
 * \return None.
 */

IFX_INLINE void IfxScrUart_enableDisableDataReception(Ifx_Functionality enable);

/** \brief Wait for reception and read data from UART buffer
 * \param mode UART operating mode
 * \return Returns the received data
 */

IFX_INLINE uint16 IfxScrUart_receiveData(void);

/** \brief Select the input for UART RXD
 * \param rxd Receiver input
 * \return None
 */

IFX_INLINE void IfxScrUart_selectReceiverInput(IfxScrUart_ReceiverInput rxd);

/** \brief Queries status of UART reception
 * \return None
 */
IFX_INLINE boolean IfxScrUart_isRxDone(void);

/** \brief Clearing SCON.RI flag
 * \return None
 */
IFX_INLINE void IfxScrUart_clearRxFlag(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to read block of data
 * \param memptr Pointer to uart data.
 * \param size Size of data
 * \return None
 */
IFX_EXTERN void IfxScrUart_UartRead(uint16 *const memptr, const uint16 size);

/** \} */

/** \addtogroup IfxLld_ScrUart_Std_LinFunctionality
 * \{ */
/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Transmits the LIN Sync Byte(0x55) over UART
 * This is to be used after UART is already set up in proper mode(Mode 1) for lin communication.
 * And Break field has sent.Break field is generated using Timers.
 * \return None
 */

IFX_INLINE void IfxScrUart_sendLinSyncField(void);

/** \brief Transmits the LIN ID field for slave identification over UART
 * This is to be used after UART is already set up in proper mode(Mode 1) for lin communication.
 * And Break field and sync field has been sent.Break field is generated using Timers.
 * \return None
 */

IFX_INLINE void IfxScrUart_sendLinIdField(IfxScrUart_LinMasterMessage *linMessage);

/** \brief Send over UART the LIN data from the LIN message structure
 * \param linMessage LIN message struct
 * \return None
 */

IFX_INLINE void IfxScrUart_sendMasterModeLinData(IfxScrUart_LinMasterMessage *linMessage);

/** \brief Send over UART the LIN checksum field from the LIN message structure
 * \param linMessage LIN message struct
 * \return None
 */

IFX_INLINE void IfxScrUart_sendLinChecksumField(IfxScrUart_LinMasterMessage *linMessage);

/** \brief Check if the Break field is detected in LIN slave mode
 * \return Status if Break field is detected in LIN slave mode
 */

IFX_INLINE boolean IfxScrUart_isLinBreakFieldDetected(void);

/** \brief Check if the Sync Byte is detected in LIN slave mode
 * \return Status if Sync Byte is detected in LIN slave mode
 */

IFX_INLINE boolean IfxScrUart_isLinSyncByteDetected(void);

/** \brief Check if there's any error in Sync Byte detection in LIN slave mode
 * \return Status if there's any error in Sync Byte detection in LIN slave mode
 */

IFX_INLINE boolean IfxScrUart_isSyncByteErrorDetected(void);

/** \brief Clear LIN Break Field detection flag
 * \return None
 */

IFX_INLINE void IfxScrUart_clearLinBreakDetectedFlag(void);

/** \brief Clear LIN Sync Byte detection flag
 * \return None
 */

IFX_INLINE void IfxScrUart_clearLinSyncDetectedFlag(void);

/** \brief Enable or disable interrupts on error in Sync Byte detection
 * \return None
 */

IFX_INLINE void IfxScrUart_enableDisableSyncByteErrorInterrupts(Ifx_Functionality enable);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to send master mode lin frame (sync + ID + Data + Checksum)
 * Break field is generated using Timers. Break field should be sent before calling this function.
 * \param linMessage Pointer to lin message configuration.
 * \return None
 */
IFX_EXTERN void IfxScrUart_sendLinFrame(IfxScrUart_LinMasterMessage *linMessage);

/** \} */

/** \addtogroup IfxLld_ScrUart_Std_init
 * \{ */
/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to configure Uart structure
 * \param uartConfig Pointer to uart configuration structure.
 * \return None
 */
IFX_EXTERN void IfxScrUart_UartInitModuleConfig(IfxScrUart_UartConfig *uartConfig);

/** \brief Function to initialize module
 * \param uartConfig Pointer to uart configuration structure.
 * \return None
 */
IFX_EXTERN void IfxScrUart_UartInitModule(IfxScrUart_UartConfig *uartConfig);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScrUart_setUartMode(IfxScrUart_Mode mode)
{
    SCR_UART_SCON.U = ((SCR_UART_SCON.U & ~(3u << IFX_SCR_UART_SCON_SM01_OFF)) | mode << IFX_SCR_UART_SCON_SM01_OFF);
}


IFX_INLINE IfxScrUart_Mode IfxScrUart_getUartMode(void)
{
    return (SCR_UART_SCON.U & (3u << IFX_SCR_UART_SCON_SM01_OFF)) >> IFX_SCR_UART_SCON_SM01_OFF;
}


IFX_INLINE void IfxScrUart_setBaudratePrescaler(IfxScrUart_BaudratePrescaler prescaler)
{
    SCR_LIN_BCON.U = ((SCR_LIN_BCON.U & ~(IFX_SCR_LIN_BCON_BRPRE_MSK << IFX_SCR_LIN_BCON_BRPRE_OFF)) | (prescaler << IFX_SCR_LIN_BCON_BRPRE_OFF));
}


IFX_INLINE void IfxScrUart_setBaudrateFractionalDivider(IfxScrUart_BaudrateFractionalDivider divider)
{
    SCR_LIN_BGL.U = ((SCR_LIN_BGL.U & ~(IFX_SCR_LIN_BGL_FD_SEL_MSK << IFX_SCR_LIN_BGL_FD_SEL_OFF)) | divider);
}


IFX_INLINE void IfxScrUart_setReloadValue(uint16 reloadValue)
{
    SCR_LIN_BGH.U = (uint8)(reloadValue >> 3u);
    SCR_LIN_BGL.U = ((SCR_LIN_BGL.U & ~(IFX_SCR_LIN_BGL_BR_VALUE_MSK << IFX_SCR_LIN_BGL_BR_VALUE_OFF)) | ((reloadValue & IFX_SCR_LIN_BGL_BR_VALUE_MSK) << IFX_SCR_LIN_BGL_BR_VALUE_OFF));
}


IFX_INLINE void IfxScrUart_doubleMode2Baudrate(Ifx_Functionality enable)
{
    SCR_PCON.U = ((SCR_PCON.U & ~(IFX_SCR_PCON_SMOD_MSK << IFX_SCR_PCON_SMOD_OFF)) | (enable << IFX_SCR_PCON_SMOD_OFF));
}


IFX_INLINE void IfxScrUart_enableDisableBaudrateGenerator(Ifx_Functionality enable)
{
    SCR_LIN_BCON.U = (SCR_LIN_BCON.U & ~(IFX_SCR_LIN_BCON_R_MSK << IFX_SCR_LIN_BCON_R_OFF)) | enable;
}


IFX_INLINE void IfxScrUart_sendData(uint16 data)
{
    IfxScrUart_Mode mode;
    /*Clear SCON.TI*/
    SCR_UART_SCON.U = (SCR_UART_SCON.U & ~(IFX_SCR_UART_SCON_TI_MSK << IFX_SCR_UART_SCON_TI_OFF));
    mode            = IfxScrUart_getUartMode();

    if ((mode == IfxScrUart_Mode_2) || (mode == IfxScrUart_Mode_3))
    {
        SCR_UART_SCON.U = (SCR_UART_SCON.U & ~(IFX_SCR_UART_SCON_TB8_MSK << IFX_SCR_UART_SCON_TB8_OFF)) | ((data & (0x100)) >> 5); //extracting the 9th bit(shifting it right by 5 to put it at bit no. 3(position of TB8 in SCON))
    }

    SCR_UART_SBUF.U = (uint8)(data & (0xFF));

    while (!((SCR_UART_SCON.U & (IFX_SCR_UART_SCON_TI_MSK << IFX_SCR_UART_SCON_TI_OFF)) >> IFX_SCR_UART_SCON_TI_OFF)) // wait till transmission is completed(Setting of SCON.TI bit)
    {}
}


IFX_INLINE void IfxScrUart_enableDisableDataReception(Ifx_Functionality enable)
{
    /*Write to SCON.REN*/
    SCR_UART_SCON.U = ((SCR_UART_SCON.U & ~(1u << IFX_SCR_UART_SCON_REN_OFF)) | enable << IFX_SCR_UART_SCON_REN_OFF);
}


IFX_INLINE uint16 IfxScrUart_receiveData(void)
{
    uint16          rxData = 0;
    IfxScrUart_Mode mode;
    mode = IfxScrUart_getUartMode();

    /* On reception, SCON.RI = 1 by hardware.So wait till byte is received */
    while (SCR_UART_SCON.B.RI == 0)
    {}

    if ((mode == IfxScrUart_Mode_2) || (mode == IfxScrUart_Mode_3))
    {
        rxData = rxData | ((SCR_UART_SCON.U & (1u << IFX_SCR_UART_SCON_RB8_OFF)) << 6u); //extracting the RB8 bit(bit no. 2) and shifting it left by 6 places so that it's at position 8(9th bit)
    }

    rxData             = rxData | SCR_UART_SBUF.U;
    /*Clearing SCON.RI to enable next byte reception*/
    SCR_UART_SCON.B.RI = 0;
    return rxData;
}


IFX_INLINE void IfxScrUart_selectReceiverInput(IfxScrUart_ReceiverInput rxd)
{
    /*SCU_PAGE = 2*/
    SCR_SCU_PAGE.U      = ((SCR_SCU_PAGE.U & (uint8)(0xF8)) | (uint8)(0x2));
    while(!(SCR_SCU_PAGE.B.PAGE == 0x2))
    {}
    SCR_SCU_MODPISEL0.U = ((SCR_SCU_MODPISEL0.U & ~(IFX_SCR_SCU_MODPISEL0_URRIS_MSK << IFX_SCR_SCU_MODPISEL0_URRIS_OFF)) | rxd);
}


IFX_INLINE boolean IfxScrUart_isTxDone(void)
{
    return (boolean)((SCR_UART_SCON.U & (IFX_SCR_UART_SCON_TI_MSK << IFX_SCR_UART_SCON_TI_OFF)) >> IFX_SCR_UART_SCON_TI_OFF);
}


IFX_INLINE boolean IfxScrUart_isRxDone(void)
{
    return (boolean)(SCR_UART_SCON.U & IFX_SCR_UART_SCON_RI_MSK);
}


IFX_INLINE void IfxScrUart_clearTxFlag(void)
{
    SCR_UART_SCON.U = (SCR_UART_SCON.U & ~(IFX_SCR_UART_SCON_TI_MSK << IFX_SCR_UART_SCON_TI_OFF));
}


IFX_INLINE void IfxScrUart_clearRxFlag(void)
{
    SCR_UART_SCON.U = (SCR_UART_SCON.U & ~(IFX_SCR_UART_SCON_RI_MSK << IFX_SCR_UART_SCON_RI_OFF));
}


/**************************************LIN*****************************************************************/

IFX_INLINE void IfxScrUart_sendLinSyncField(void)
{
    IfxScrUart_sendData(0x55);
}


IFX_INLINE void IfxScrUart_sendLinIdField(IfxScrUart_LinMasterMessage *linMessage)
{
    /*Send Lin ID*/
    IfxScrUart_sendData(linMessage->linId);
}


IFX_INLINE void IfxScrUart_sendMasterModeLinData(IfxScrUart_LinMasterMessage *linMessage)
{
    uint8  i       = 0;
    uint8 *dataPtr = linMessage->linDataPtr;

    for (i = 0; i < linMessage->dataSizeinBytes; i++)
    {
        IfxScrUart_sendData(*dataPtr);
        dataPtr++;
    }
}


IFX_INLINE void IfxScrUart_sendLinChecksumField(IfxScrUart_LinMasterMessage *linMessage)
{
    /*Send Lin frame checksum*/
    IfxScrUart_sendData(linMessage->checksum);
}


IFX_INLINE boolean IfxScrUart_isLinBreakFieldDetected(void)
{
    return (boolean)((SCR_LIN_STAT.U & (1u << IFX_SCR_LIN_STAT_BRK_OFF)) >> IFX_SCR_LIN_STAT_BRK_OFF);
}


IFX_INLINE boolean IfxScrUart_isLinSyncByteDetected(void)
{
    return (boolean)((SCR_LIN_STAT.U & (1u << IFX_SCR_LIN_STAT_EOFSYN_OFF)) >> IFX_SCR_LIN_STAT_EOFSYN_OFF);
}


IFX_INLINE boolean IfxScrUart_isSyncByteErrorDetected(void)
{
    return (boolean)((SCR_LIN_STAT.U & (1u << IFX_SCR_LIN_STAT_ERRSYN_OFF)) >> IFX_SCR_LIN_STAT_ERRSYN_OFF);
}


IFX_INLINE void IfxScrUart_clearLinBreakDetectedFlag(void)
{
    SCR_LIN_STAT.U = (SCR_LIN_STAT.U & ~(1u << IFX_SCR_LIN_STAT_BRK_OFF));
}


IFX_INLINE void IfxScrUart_clearLinSyncDetectedFlag(void)
{
    SCR_LIN_STAT.U = (SCR_LIN_STAT.U & ~(1u << IFX_SCR_LIN_STAT_EOFSYN_OFF));
}


IFX_INLINE void IfxScrUart_enableDisableSyncByteErrorInterrupts(Ifx_Functionality enable)
{
    SCR_LIN_STAT.U = ((SCR_LIN_STAT.U & ~(1u << IFX_SCR_LIN_STAT_SYNEN_OFF)) | enable << IFX_SCR_LIN_STAT_SYNEN_OFF);
}


#endif /* IFXSCRUART_H */
