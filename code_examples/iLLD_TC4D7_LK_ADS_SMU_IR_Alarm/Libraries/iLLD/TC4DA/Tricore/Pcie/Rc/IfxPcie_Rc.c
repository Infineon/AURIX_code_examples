/**
 * \file IfxPcie_Rc.c
 * \brief PCIE RC details
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxPcie_Rc.h"
#if (IFX_PROT_ENABLED == 1U)
#include "Ap/Std/IfxApProt.h"
#endif

/******************************************************************************/
/*----------------------------------Macros------------------------------------*/
/******************************************************************************/

#define IFXPCIE_RC_CHECK_INCREMENT(value, reference, index) \
    if ((value) == (reference))                             \
    {                                                       \
        (index)++;                                          \
    }                                                       \
    else                                                    \
    {                                                       \
        break;                                              \
    }

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxPcie_Rc_initConfig(Ifx_PCIE_DSP *pcieSFR, IfxPcie_Rc_Config *config)
{
    const IfxPcie_Rc_Config defaultConfig = {
        .pcieSFR  = NULL_PTR,
        .hsphySFR = NULL_PTR,
        .index    = (IfxPcie_Index)0,
        {
            .wireMemPrefetchBase  = IFXPCIE_CFG_PREFETCH_WIRE_MEM_BASE,
            .wireMemPrefetchLimit = IFXPCIE_CFG_PREFETCH_WIRE_MEM_LIMIT,
            .wireMemBase          = IFXPCIE_CFG_WIRE_MEM_BASE,
            .wireMemLimit         = IFXPCIE_CFG_WIRE_MEM_LIMIT,
            .localConfigBase      = IfxPcie_cfg_memoryMap[0].memoryBase,
            .localMemBase         = IfxPcie_cfg_memoryMap[0].memoryBase + IFXPCIE_CFG_FUNCTION_CFG_SPACE,
            .localMemLimit        = IfxPcie_cfg_memoryMap[0].memoryLimit
        },
        {
            .primaryBus     = IFXPCIE_CFG_RC_PRIMARY_BUS,
            .subordinateBus = IFXPCIE_CFG_RC_MAX_SUBORDINATE_BUS,
            .vendorId       = 0x0000u,
            .deviceId       = 0x0004u,
            .pmeEnable      = TRUE
        },
        .endPointCfg = NULL_PTR,
        .bridgeCfg   = NULL_PTR,
        {
            .remoteIntType        = IfxPcie_InterruptType_none,
            {
                .U                = 0x0u
            },
            {
                .U                = 0x0u
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                   /**< \brief CPU0 by default */
                .priority      = 0x0u,                              /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                     /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_genError         /**< \brief General Errors vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                   /**< \brief CPU0 by default */
                .priority      = 0x0u,                              /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                     /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_aerError         /**< \brief AER Errors vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                   /**< \brief CPU0 by default */
                .priority      = 0x0u,                              /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                     /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_pmRequest        /**< \brief PM Errors Vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                   /**< \brief CPU0 by default */
                .priority      = 0x0u,                              /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                     /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_link             /**< \brief Link Errors vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                   /**< \brief CPU0 by default */
                .priority      = 0x0u,                              /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                     /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_message          /**< \brief Message Interrupt Vector */
            },
            {
                .typeOfService = IfxSrc_Tos_cpu0,                   /**< \brief CPU0 by default */
                .priority      = 0x0u,                              /**< \brief 0 : Don't interrupt CPU */
                .vmNumber      = IfxSrc_VmId_0,                     /**< \brief VM ID 0 */
                .intVector     = IfxPcie_IntVector_misc             /**< \brief Misc Interrupt Vector */
            }
        },
        .numEndPoints = 1u,
        .numBridges   = 0u,
        .drsSupport   = TRUE,
        .LaneWidth    = IfxPcieRc_LaneWidth_x1,
    };

    *config         = defaultConfig; /* Default Configuration */

    config->pcieSFR = pcieSFR;       /* take over module pointer */
}


IfxPcie_Status IfxPcie_Rc_init(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(config->pcieSFR->PROTE), IfxApProt_State_config);
#endif
    IfxPcie_Status status = IfxPcie_Status_success;

    status |= IfxPcie_Rc_initModule(rcHandle, config);              /* Initialize the RC module */

    if (status == IfxPcie_Status_success)
    {
#if IFXPCIE_CFG_RTL_VIP == (0)
        IfxPcie_Rc_initLink(rcHandle, config);                          /* Initialize the link */

        while (IfxPcie_isLinkUp((IfxPcie *)rcHandle->pcieSFR) == FALSE) /* check if Link is up */
        {}

#endif
        status |= IfxPcie_Rc_initTopology(rcHandle, config);        /* Initialize the topology */
    }

    if (status == IfxPcie_Status_success)
    {
        IfxPcie_Rc_enableEndPoints(rcHandle);                          /* Enable all End Points memories, bus masters */
        rcHandle->state = IfxPcie_Rc_State_enumerated;

        status          = IfxPcie_Rc_initInterrupts(rcHandle, config); /* Now, Initialize the Interrupts from EP , RC */
    }

    IfxPcieLib_Device_freeAtuRegion((IfxPcie *)(rcHandle->pcieSFR), &(rcHandle->atu.outboundRegion[IFXPCIE_CFG_ECAM_ATU_INDEX]));

    if (status == IfxPcie_Status_failure)
    {
        rcHandle->state = IfxPcie_Rc_State_error;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(config->pcieSFR->PROTE), IfxApProt_State_run);
#endif

    return status;
}


IfxPcie_Status IfxPcie_Rc_initModule(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config)
{
    IfxPcie_Status                    initStatus = IfxPcie_Status_failure;
    rcHandle->pcieSFR = config->pcieSFR;
    rcHandle->index   = config->index;

    Ifx_PCIE_DSP                     *pcie     = rcHandle->pcieSFR;
    IfxPcieLib_Device_RootComplexCfg *rcCfg    = &(config->rootComplex);
    IfxPcieLib_Device_RootComplex    *rcDevice = &(rcHandle->rootComplex);
    IfxPcieDevice_Type1CfgHdr        *cfgHdr   = (IfxPcieDevice_Type1CfgHdr *)&(pcie->TYPE1HDR);
    rcDevice->cfgHeader = cfgHdr;

    /* STEP 1: Enable the Module */
    IfxPcie_enableModule((IfxPcie *)pcie);

    /* STEP 2: Set device type to RC */
    IfxPcie_setDeviceMode((IfxPcie *)pcie, IfxPcie_DeviceMode_rc);

    /* STEP 3: Reset the Module */
    IfxPcie_resetModule((IfxPcie *)pcie);

    /* STEP 4: Wait for HSPHY */
    if (config->hsphySFR != NULL_PTR)
    {
        rcHandle->hsphySFR = config->hsphySFR;

        /* Wait for HSPHY to give the clock */
#if IFXPCIE_CFG_ENABLE_PHY == 1
        IfxHsphy_PhyIndex phyIndex = IFXPCIE_GET_PHY_INDEX(rcHandle->index);
        IfxPcie_waitForHsphy(rcHandle->hsphySFR, phyIndex);
#endif

        /* Enable Link Training */
#if IFXPCIE_CFG_RTL_VIP == (1)
        IfxPcie_enableLtssm((IfxPcie *)pcie);

        while (IfxPcie_isLinkUp((IfxPcie *)pcie) == FALSE)          /* check if Link is up */
        {
            /* TODO: Disable warning, this is needed */
        }

#endif

        initStatus = IfxPcie_Status_success;
    }

    if (initStatus == IfxPcie_Status_success)
    {
        /* STEP 5: Enable DBI access */
        IfxPcie_setDbiRoAccess((IfxPcie *)pcie, TRUE);

        rcHandle->state = IfxPcie_Rc_State_enabled;

        /* STEP 6: Set the Configuration Header Parameters */
        {
            /* 6.1 Write the Bus parameters */
            IfxPcieRc_setBusParameters(pcie, rcCfg->primaryBus, rcCfg->primaryBus + 1u, rcCfg->subordinateBus);
            rcDevice->primaryBus     = rcCfg->primaryBus;
            rcDevice->secondaryBus   = rcCfg->primaryBus + 1;
            rcDevice->subordinateBus = rcCfg->subordinateBus;

            /* 6.2 Write the device ID, vendor ID */
            IfxPcieDevice_setDeviceId((IfxPcieDevice_CfgHdr *)rcDevice->cfgHeader, rcCfg->deviceId);
            IfxPcieDevice_setVendorId((IfxPcieDevice_CfgHdr *)rcDevice->cfgHeader, rcCfg->vendorId);
            rcDevice->deviceId = rcCfg->deviceId;
            rcDevice->vendorId = rcCfg->vendorId;

            /* 6.3 Write the Command Header registers */
            IfxPcieDevice_CfgHdrCommand cmdReg;
            cmdReg.U          = cfgHdr->command.U;
            cmdReg.B.ioEnable = FALSE;   /* IO space is disabled by default */
            cfgHdr->command.U = cmdReg.U;
        }

        /* STEP 7: Configure the memory Limits, ECAM ATU */
        {
            /* 7.1: Memory base, limit Configuration */
            IfxPcie_Rc_AddressSpaceCfg *addrCfg = &(config->addressSpace);
            initStatus |= IfxPcie_Rc_configureMemoryLimits(rcHandle, addrCfg);

            /* 7.2 Enable Memory Space for RC */
            IfxPcieDevice_enableMemorySpace((IfxPcieDevice_CfgHdr *)(rcDevice->cfgHeader));                     /* Memory Space Enable */
        }

        /* STEP 8: Initialize Capabilities  */
        {
            IfxPcieLib_Cap_probeCapabilities(&(rcDevice->capabilities), (IfxPcieDevice_CfgHdr *)rcDevice->cfgHeader);

            if (rcDevice->capabilities.pmc.capPtr != NULL_PTR)
            {
                IfxPcieCap_setPmeActive(rcDevice->capabilities.pmc.capPtr, config->rootComplex.pmeEnable);
            }
        }

        /* STEP 9: Enable MSI/X/INTx for initial receptions */
        {
            IfxPcie_Rc_enableInterrupts(rcHandle, config);
        }
    }

    /* STEP 10: Disable DBI Access */
    IfxPcie_setDbiRoAccess((IfxPcie *)pcie, FALSE);

    return initStatus;
}


void IfxPcie_Rc_initLink(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config)
{
    Ifx_PCIE_DSP *pcie = rcHandle->pcieSFR;

    /* STEP 2: Set Lane/Link parameters */
    /* set the number of lanes */
    IfxPcieRc_setNumOfLanes(pcie, config->LaneWidth);

    /* STEP 3: Enable Link Training */
    IfxPcie_enableLtssm((IfxPcie *)pcie);
}


IfxPcie_Status IfxPcie_Rc_initTopology(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config)
{
    IfxPcie_Status                      status = IfxPcie_Status_success;

    uint8                               busNum, tempSubBus, deviceNum, funcNum;
    uint8                               epIndex          = 0u;
    uint8                               bridgeIndex      = 0u;
    boolean                             bridgeDiscovered = FALSE;
    boolean                             deviceDiscovered = FALSE;
    IfxPcie_Rc_TopologyInfo             topologyInfo[IFXPCIE_CFG_MAX_NUM_OF_BUS];
    IfxPcie_Rc_TopologyInfo            *bridgeInfoPtr;
    volatile IfxPcieDevice_Type0CfgHdr *configHdr0 = (IfxPcieDevice_Type0CfgHdr *)rcHandle->addressSpace.localConfigBase;
    volatile IfxPcieDevice_Type1CfgHdr *configHdr1 = (IfxPcieDevice_Type1CfgHdr *)rcHandle->addressSpace.localConfigBase;

    IfxPcieDevice_enableMemorySpace((IfxPcieDevice_CfgHdr *)(rcHandle->rootComplex.cfgHeader));                 /* Enable memory access for RC */
    IfxPcieDevice_enableBusMaster((IfxPcieDevice_CfgHdr *)(rcHandle->rootComplex.cfgHeader));                   /* Enable Bus Master for RC */

    /* Start Enumeration */
    busNum                   = rcHandle->rootComplex.secondaryBus;                                              /* Start from secondary bus of RC */
    tempSubBus               = rcHandle->rootComplex.secondaryBus;                                              /* Update temporary subordinate bus to starting bus */
    deviceNum                = 0u;
    funcNum                  = 0u;
    bridgeInfoPtr            = &(topologyInfo[0]);                                                              /* Currently we are pointing to the first Bridge (RC) */
    bridgeInfoPtr->bridgePtr = NULL_PTR;                                                                        /* NULL : RC is the first bridge */
    bridgeDiscovered         = FALSE;                                                                           /* No bridge Discovered */
    rcHandle->numBridges     = bridgeIndex;                                                                     /* number of bridges    */
    rcHandle->numEndPoints   = epIndex;                                                                         /* number of End Points */

    while (busNum <= rcHandle->rootComplex.subordinateBus)                                                      /* Perform enumeration until subordinate bus */
    {
        tempSubBus                    = (tempSubBus > busNum) ? tempSubBus : busNum;                            /* Update temp Subordinate bus value */
        bridgeInfoPtr->busUnderBridge = busNum;                                                                 /* Update Topology Info */
        bridgeInfoPtr->subordinateBus = tempSubBus;                                                             /* Update Topology Info */

        while (deviceNum < IFXPCIE_CFG_MAX_NUM_OF_DEV)                                                          /* For all devices in this bus */
        {
            bridgeInfoPtr->deviceUnderBus = deviceNum;                                                          /* Update Topology Info */

            while (funcNum < IFXPCIE_CFG_MAX_NUM_OF_FUN)                                                        /* For all functions in this device */
            {
                bridgeInfoPtr->functionUnderDevice = funcNum;                                                   /* Update Topology Info */
                IfxPcie_Rc_configureEcamAtu(rcHandle, busNum, deviceNum, funcNum, IfxPcieDevice_Type_endpoint); /* Configure ECAM ATU for this device config */

                if ((busNum == rcHandle->rootComplex.secondaryBus)
                    && ((deviceNum | funcNum) == 0u))
                {
                    while (((*(volatile uint32 *)configHdr0) & (uint32)0xFFFFu) == (uint32)0xFFFFu)
                    {
                        /* TODO: Implement Timeout, DRS messaging */
                    }
                }

                if (configHdr0->vendorId != 0xFFFFu)                                            /* Device is valid */
                {
                    if (configHdr0->headerType.B.type == (uint8)IfxPcieDevice_Type_endpoint)    /* It is an End Point */
                    {
                        status                                        = IfxPcie_Rc_addEndPoint(rcHandle, epIndex, config->endPointCfg, config->numEndPoints, bridgeInfoPtr);
                        rcHandle->endPoint[epIndex].upStreamBridgePtr = bridgeInfoPtr->bridgePtr;
                        IFXPCIE_RC_CHECK_INCREMENT(status, IfxPcie_Status_success, epIndex);
                        deviceDiscovered                              = TRUE;
                    }
                    else if (configHdr1->headerType.B.type == (uint8)IfxPcieDevice_Type_bridge) /* It is a bridge */
                    {
                        status                   = IfxPcie_Rc_addBridge(rcHandle, bridgeIndex, config->bridgeCfg, config->numBridges, bridgeInfoPtr);
                        bridgeInfoPtr++;
                        bridgeInfoPtr->bridgePtr = &(rcHandle->bridge[bridgeIndex]);
                        IFXPCIE_RC_CHECK_INCREMENT(status, IfxPcie_Status_success, bridgeIndex);
                        bridgeDiscovered         = TRUE;
                    }
                    else
                    {
                        status = IfxPcie_Status_failure;                                        /* Unknown Device */
                    }
                }

                IFXPCIE_RC_CHECK_INCREMENT(configHdr0->headerType.B.multiFuncEn, 1u, funcNum);
            }

            funcNum = 0u;                                                                       /* Set function number back to 0 if loop exceeded */

            if (deviceDiscovered == TRUE)                                                       /* If device is discovered, then only look for 1 device */
            {
                deviceNum        = IFXPCIE_CFG_MAX_NUM_OF_DEV;
                deviceDiscovered = FALSE;
            }
            else
            {
                IFXPCIE_RC_CHECK_INCREMENT(status, IfxPcie_Status_success, deviceNum);
            }
        }

        if ((status == IfxPcie_Status_failure)
            || (bridgeInfoPtr->busUnderBridge == rcHandle->rootComplex.secondaryBus))           /* We are Done */
        {
            break;
        }
        else if (bridgeDiscovered == TRUE)                                                      /* We found a bridge - Go to next Bus */
        {
            busNum           = tempSubBus + 1;
            deviceNum        = 0u;
            funcNum          = 0u;
            bridgeDiscovered = FALSE;
        }
        else                                                                                    /* We were under a bridge */
        {
            IfxPcie_Rc_updateUpstreamBridge(rcHandle, bridgeInfoPtr, tempSubBus);

            bridgeInfoPtr--;                                                                    /* Go back one level in topology */
            busNum    = bridgeInfoPtr->busUnderBridge;                                          /* Go to bus under Upstream Bridge */
            deviceNum = bridgeInfoPtr->deviceUnderBus;                                          /* Go to device under Upstream Bridge */
            funcNum   = bridgeInfoPtr->functionUnderDevice + 1u;                                /* Go to next logical Function */
        }
    }

    if (epIndex == 0u)
    {
        status = IfxPcie_Status_failure;                                                        /* no EP devices found -- failure */
    }

    return status;
}


IfxPcie_Status IfxPcie_Rc_initInterrupts(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config)
{
    uint8                       devIndex    = 0U;
    uint8                       numDevices  = 0U;
    uint8                       numVectors  = 0U;
    uint8                       vectorIndex = 0U;
    IfxPcie_Rc_EndPoint        *epDevice;
    IfxPcie_Rc_Bridge          *bridge;
    IfxPcie_Rc_RemoteIntVector *intVect;
    IfxPcie_Rc_FunctionIntCfg  *functionIntCfg;
    IfxPcie_Status              status = IfxPcie_Status_success;

    numDevices = rcHandle->numEndPoints;

    if (config->endPointCfg != NULL_PTR)
    {
        for (devIndex = 0; devIndex < numDevices; devIndex++)
        {
            epDevice = &(rcHandle->endPoint[devIndex]);
            IfxPcie_Rc_configureEcamAtu(rcHandle, epDevice->epFunction.bus, epDevice->epFunction.device, epDevice->epFunction.function, IfxPcieDevice_Type_endpoint);

            if (epDevice->configIndex != IFXPCIE_RC_NULL_CFG_INDEX)
            {
                functionIntCfg = &(config->endPointCfg[epDevice->configIndex].interrupt);
                status         = IfxPcie_Rc_initFunctionInterrupt(rcHandle, devIndex, functionIntCfg, IfxPcieDevice_Type_endpoint); /* Initialize End Point Interrupts */

                if (status == IfxPcie_Status_success)
                {
                    numVectors = epDevice->interrupt.numVectors;

                    for (vectorIndex = 0u; vectorIndex < numVectors; vectorIndex++)
                    {
                        intVect = &(epDevice->interrupt.intVector[vectorIndex]);
                        IfxPcieRc_enableRemoteInterrupts(rcHandle->pcieSFR, intVect->intVector);                                /* Enable the interrupts */
                    }
                }
            }
        }
    }

    numDevices = rcHandle->numBridges;

    if (config->bridgeCfg != NULL_PTR)
    {
        for (devIndex = 0; devIndex < numDevices; devIndex++)
        {
            bridge = &(rcHandle->bridge[devIndex]);
            IfxPcie_Rc_configureEcamAtu(rcHandle, bridge->bridgeFunction.primaryBus, bridge->bridgeFunction.device, bridge->bridgeFunction.function, IfxPcieDevice_Type_bridge);

            if (bridge->configIndex != IFXPCIE_RC_NULL_CFG_INDEX)
            {
                functionIntCfg = &(config->bridgeCfg[bridge->configIndex].interrupt);
                status         = IfxPcie_Rc_initFunctionInterrupt(rcHandle, devIndex, functionIntCfg, IfxPcieDevice_Type_bridge); /* Initialize Bridge Interrupts */

                if (status == IfxPcie_Status_success)
                {
                    numVectors = bridge->interrupt.numVectors;

                    for (vectorIndex = 0u; vectorIndex < numVectors; vectorIndex++)
                    {
                        intVect = &(bridge->interrupt.intVector[vectorIndex]);
                        IfxPcieRc_enableRemoteInterrupts(rcHandle->pcieSFR, intVect->intVector);                                /* Enable the interrupts */
                    }
                }
            }
        }
    }

    return status;
}


void IfxPcie_Rc_enableInterrupts(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config)
{
    IfxPcie_Rc_InterruptCfg *intCfg = &(config->interrupt);

    /* STEP 1: Enable the remote interrupts */
    /* NOTE: Interrupt Initialization happens for each end point separately */
    switch (intCfg->remoteIntType)
    {
    case (IfxPcie_InterruptType_msi):
        IfxPcieRc_writeMsiAddress(rcHandle->pcieSFR, IFXPCIE_CFG_MSI_RECEPTION_ADDRESS);
        IfxPcieRc_enableMsi(rcHandle->pcieSFR);
        break;
    case (IfxPcie_InterruptType_msix):
        IfxPcieRc_writeMsiAddress(rcHandle->pcieSFR, IFXPCIE_CFG_MSI_RECEPTION_ADDRESS);
        IfxPcieRc_enableMsix(rcHandle->pcieSFR);
        break;
    default:
        break;
    }

    /* STEP 2: Enable / initialize the other interrupts */
    /* NOTE: DMA Interrupts are taken care separately */

    IfxPcieLib_Device_IntNodeCfg *nodeCfg        = &(intCfg->errorIntnode);
    uint8                         interruptIndex = (uint8)IfxPcie_IntVector_genError;

    while (interruptIndex < (uint8)IfxPcie_IntVector_count)
    {
        if (nodeCfg->priority > 0u)
        {
            IfxPcieLib_Device_initSrcNode((IfxPcie *)rcHandle->pcieSFR, rcHandle->index, nodeCfg);
        }

        nodeCfg++;
        interruptIndex++;
    }

    /* Enable Specific Masks */
    if (intCfg->pmeIntEnable.U != 0x0u)
    {
        IfxPcie_enablePmeInterrupts((IfxPcie *)rcHandle->pcieSFR, intCfg->pmeIntEnable.U);
    }

    if (intCfg->errorIntEnable.U != 0x0u)
    {
        IfxPcie_enableErrorInterrupts((IfxPcie *)rcHandle->pcieSFR, intCfg->errorIntEnable.U);
    }

    rcHandle->interruptType = intCfg->remoteIntType;
}


IfxPcie_Status IfxPcie_Rc_configureMemoryLimits(IfxPcie_Rc *rcHandle, IfxPcie_Rc_AddressSpaceCfg *addrCfg)
{
    IfxPcie_Status status = IfxPcie_Status_failure;

    /* Limit Addresses for local memory */
    uint32         lowerLimit  = IfxPcie_cfg_memoryMap[rcHandle->index].memoryBase;
    uint32         upperLimit  = IfxPcie_cfg_memoryMap[rcHandle->index].memoryLimit;
    uint32         wireMemSize = addrCfg->wireMemLimit - addrCfg->wireMemBase;

    /* local config, memory base and limit */
    uint32         localConfigBase  = addrCfg->localConfigBase;
    uint32         localMemBase     = addrCfg->localMemBase;
    uint32         localMemLimit    = addrCfg->localMemLimit;
    uint32         localConfigLimit = localConfigBase + (IFXPCIE_CFG_FUNCTION_CFG_SPACE - 1u);

    /* Wire memory base */
    uint32         wireMemBase = addrCfg->wireMemBase;

    /* Checks to be done for memory limits */
    /* Check 1: Sanity (limit) check for local Configuration base Address */
    if (((localConfigBase >= lowerLimit) && (localConfigLimit <= upperLimit))
        && ((localConfigBase & ~(IFXPCIE_CFG_FUNCTION_CFG_SPACE - 1u)) != 0u)       /* Config memory base must span entire config region */
        && ((localConfigBase & (IFXPCIE_CFG_FUNCTION_CFG_SPACE - 1u)) == 0u))       /* Config memory must accommodate entire config limit */
    {
        /* Check 2: Sanity (limit) Check for local memory base addresses */
        if ((localMemBase >= lowerLimit) && (localMemLimit <= upperLimit))
        {
            /* Check 3: Overlap check for local config, memory base addresses */
            if (((localConfigBase < localMemBase) && (localMemBase > localConfigLimit))
                || (localConfigBase > localMemLimit))
            {
                /* Check 4: check if Size of wire memory is at least 1MB */
                if (wireMemSize >= ((uint32)((uint32)1U << 20U)))
                {
                    /* Check 6: prefetch memory in wire is above 2GB mark */
                    if (addrCfg->wireMemPrefetchBase >= (uint64)((uint64)1u << 32u))
                    {
                        status = IfxPcie_Status_success;
                    }
                }
            }
        }
    }

    if (status == IfxPcie_Status_success)
    {
        /* Set the Wire memory base and limit parameters */
        IfxPcieRc_setMemoryBaseLimit(rcHandle->pcieSFR, addrCfg->wireMemBase, addrCfg->wireMemLimit, addrCfg->wireMemPrefetchBase, addrCfg->wireMemPrefetchLimit);

        /* update handle */
        IfxPcie_Rc_AddressSpace *addressSpacePtr = &(rcHandle->addressSpace);
        addressSpacePtr->localConfigBase      = localConfigBase;
        addressSpacePtr->localConfigLimit     = localConfigLimit;
        addressSpacePtr->localMemBase         = IFXPCIE_GET_NEXT_4KB_BOUNDARY(localMemBase);    /* ATU always needs 4KB boundaries */
        addressSpacePtr->localMemLimit        = localMemLimit;
        addressSpacePtr->wireMemBase          = wireMemBase;
        addressSpacePtr->wireMemLimit         = addrCfg->wireMemLimit;
        addressSpacePtr->wireMemPrefetchBase  = addrCfg->wireMemPrefetchBase;
        addressSpacePtr->wireMemPrefetchLimit = addrCfg->wireMemPrefetchLimit;
    }
    else
    {
        rcHandle->state = IfxPcie_Rc_State_error;
    }

    return status;
}


IfxPcie_Status IfxPcie_Rc_addBridge(IfxPcie_Rc *rcHandle, uint8 bridgeIndex, IfxPcie_Rc_BridgeCfg *bridgeCfgPtr, uint8 numBridges, IfxPcie_Rc_TopologyInfo *bridgeInfoPtr)
{
    IfxPcieLib_Device_Bridge  *bridge        = &(rcHandle->bridge[bridgeIndex].bridgeFunction);
    IfxPcie_Status             status        = IfxPcie_Status_success;
    boolean                    bridgeUserCfg = (bridgeCfgPtr == NULL_PTR) ? FALSE : TRUE;
    IfxPcie_Rc_BridgeCfg      *bridgeCfg     = NULL_PTR;
    IfxPcie_Rc_MemCfg         *memCfg        = NULL_PTR;
    IfxPcieDevice_Type1CfgHdr *configHdr1    = (IfxPcieDevice_Type1CfgHdr *)(rcHandle->addressSpace.localConfigBase);

    if (bridgeInfoPtr->subordinateBus <= rcHandle->rootComplex.subordinateBus)
    {
        IfxPcieDevice_Type1CfgHdr *configHdr1 = (IfxPcieDevice_Type1CfgHdr *)(rcHandle->addressSpace.localConfigBase);
        bridge->primaryBus                         = bridgeInfoPtr->busUnderBridge;
        bridge->secondaryBus                       = (bridgeInfoPtr->subordinateBus) + 1u;
        bridge->subordinateBus                     = 255u;
        bridge->device                             = (bridgeInfoPtr->deviceUnderBus);
        bridge->function                           = (bridgeInfoPtr->functionUnderDevice);
        bridge->cfgHeader                          = configHdr1;

        configHdr1->primaryBus                     = bridge->primaryBus;
        configHdr1->secondaryBus                   = bridge->secondaryBus;
        configHdr1->subordinateBus                 = bridge->subordinateBus;

        rcHandle->addressSpace.wireMemBase         = IFXPCIE_GET_NEXT_1MB_BOUNDARY(rcHandle->addressSpace.wireMemBase);             /* 1 MB Boundary for base address */
        rcHandle->addressSpace.wireMemPrefetchBase = IFXPCIE_GET_NEXT_1MB_BOUNDARY(rcHandle->addressSpace.wireMemPrefetchBase);

        bridge->wireMemBase                        = rcHandle->addressSpace.wireMemBase;                                            /* Update the bridge handle */
        bridge->wireMemPrefetchBase                = rcHandle->addressSpace.wireMemPrefetchBase;

        configHdr1->memBase                        = IFXPCIERC_GET_BRIDGE_MEMORYBASE(rcHandle->addressSpace.wireMemBase);           /* Write config header with base, limit addr */
        configHdr1->prefetchBase                   = IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYBASE(rcHandle->addressSpace.wireMemPrefetchBase);
        configHdr1->prefetchBaseUpper              = IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYBASEUPPER(rcHandle->addressSpace.wireMemPrefetchBase);

        if (bridgeUserCfg == TRUE)
        {
            uint8   bridgeCfgIndex = 0u;
            uint8   chosenIndex    = 0u;
            boolean matchFound     = FALSE;

            for (bridgeCfgIndex = 0; bridgeCfgIndex < numBridges; bridgeCfgIndex++)
            {
                bridgeCfg = &(bridgeCfgPtr[bridgeCfgIndex]);

                if ((bridgeCfg->bridgeFunction.deviceId == configHdr1->deviceId)                                /* Find a match */
                    && (bridgeCfg->bridgeFunction.vendorId == configHdr1->vendorId))
                {
                    if (matchFound == FALSE)
                    {
                        matchFound  = TRUE;
                        chosenIndex = bridgeCfgIndex;
                    }
                    else
                    {
                        status = IfxPcie_Status_failure;                                                        /* Duplicate entries */
                        break;
                    }
                }
            }

            if ((matchFound == TRUE)
                && (status == IfxPcie_Status_success))
            {
                bridgeCfg                                 = &(bridgeCfgPtr[chosenIndex]);
                rcHandle->bridge[bridgeIndex].configIndex = chosenIndex;                                        /* Indicate to user the configured EP */
                memCfg                                    = &(bridgeCfg->barRegion[0]);
            }
            else
            {
                rcHandle->bridge[bridgeIndex].configIndex = IFXPCIE_RC_NULL_CFG_INDEX;                          /* No index chosen */
                bridgeCfg                                 = NULL_PTR;                                           /* No valid configurations */
            }
        }
    }
    else
    {
        status = IfxPcie_Status_failure;
    }

    if (status == IfxPcie_Status_success)
    {
        status = IfxPcie_Rc_allocateBarMemories(rcHandle, bridgeIndex, memCfg, IfxPcieDevice_Type_bridge);      /* Allocate Memories */
    }

    if (status == IfxPcie_Status_success)
    {
        IfxPcieLib_Cap_probeCapabilities(&(bridge->capabilities), (IfxPcieDevice_CfgHdr *)configHdr1);          /* Probe Capabilities */

        if ((bridge->capabilities.pmc.capPtr != NULL_PTR)
            && (bridgeCfg != NULL_PTR))
        {
            IfxPcieCap_setPmeActive(bridge->capabilities.pmc.capPtr, bridgeCfg->bridgeFunction.pmeEnable);
        }

        bridge->enabled = FALSE;                                                                                /* Enable after enumeration */
        rcHandle->numBridges++;
    }

    return status;
}


void IfxPcie_Rc_updateUpstreamBridge(IfxPcie_Rc *rcHandle, IfxPcie_Rc_TopologyInfo *bridgeInfoPtr, uint8 tempSubBus)
{
    uint8                      bridgeIndex         = (bridgeInfoPtr->busUnderBridge - 1u);
    IfxPcieLib_Device_Bridge  *bridge              = &(rcHandle->bridge[bridgeIndex].bridgeFunction);
    IfxPcieDevice_Type1CfgHdr *configHdr1          = bridge->cfgHeader;
    uint32                     wireMemBase         = rcHandle->addressSpace.wireMemBase;
    uint64                     wireMemPrefetchBase = rcHandle->addressSpace.wireMemPrefetchBase;

    bridge->subordinateBus = tempSubBus;

    IfxPcie_Rc_configureEcamAtu(rcHandle, bridge->primaryBus, bridge->device, bridge->function, IfxPcieDevice_Type_bridge); /* Configure ECAM ATU previous bridge */
    configHdr1->subordinateBus     = tempSubBus;                                                                            /* Update Subordinate Bus */

    bridge->wireMemLimit           = wireMemBase - 1u;
    bridge->wireMemPrefetchLimit   = wireMemPrefetchBase - 1u;

    configHdr1->memLimit           = IFXPCIERC_GET_BRIDGE_MEMORYLIMIT(wireMemBase, bridge->wireMemBase);
    configHdr1->prefetchLimit      = IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYLIMIT(wireMemPrefetchBase, bridge->wireMemPrefetchBase);
    configHdr1->prefetchLimitUpper = IFXPCIERC_GET_BRIDGE_PREFETCH_MEMORYLIMITUPPER(wireMemPrefetchBase, bridge->wireMemPrefetchBase);
}


IfxPcie_Status IfxPcie_Rc_addEndPoint(IfxPcie_Rc *rcHandle, uint8 epIndex, IfxPcie_Rc_EndPointCfg *epCfgPtr, uint8 numEndPoints, IfxPcie_Rc_TopologyInfo *bridgeInfoPtr)
{
    IfxPcie_Status              status       = IfxPcie_Status_success;
    IfxPcieLib_Device_EndPoint *epDevice     = &(rcHandle->endPoint[epIndex].epFunction);                                       /* EP Device Pointer */
    boolean                     epUserConfig = (epCfgPtr == NULL_PTR) ? FALSE : TRUE;
    IfxPcie_Rc_EndPointCfg     *epCfg        = NULL_PTR;
    IfxPcie_Rc_MemCfg          *memCfg       = NULL_PTR;
    IfxPcieDevice_Type0CfgHdr  *configHdr0   = (IfxPcieDevice_Type0CfgHdr *)(rcHandle->addressSpace.localConfigBase);

    epDevice->bus       = bridgeInfoPtr->busUnderBridge;
    epDevice->device    = (bridgeInfoPtr->deviceUnderBus);
    epDevice->function  = (bridgeInfoPtr->functionUnderDevice);
    epDevice->vendorId  = configHdr0->vendorId;
    epDevice->deviceId  = configHdr0->deviceId;
    epDevice->cfgHeader = configHdr0;

    if (epUserConfig == TRUE)
    {
        uint8   epCfgIndex  = 0u;
        uint8   chosenIndex = 0u;
        boolean matchFound  = FALSE;

        for (epCfgIndex = 0; epCfgIndex < numEndPoints; epCfgIndex++)
        {
            epCfg = &(epCfgPtr[epCfgIndex]);

            if ((epCfg->epFunction.deviceId == configHdr0->deviceId)                                            /* Find a match */
                && (epCfg->epFunction.vendorId == configHdr0->vendorId))
            {
                if (matchFound == FALSE)
                {
                    matchFound  = TRUE;
                    chosenIndex = epCfgIndex;
                }
                else
                {
                    status = IfxPcie_Status_failure;                                                            /* Duplicate entries */
                    break;
                }
            }
        }

        if ((matchFound == TRUE)
            && (status == IfxPcie_Status_success))
        {
            epCfg                                   = &(epCfgPtr[chosenIndex]);
            rcHandle->endPoint[epIndex].configIndex = chosenIndex;                                              /* Indicate to user the configured EP */
            memCfg                                  = &(epCfg->barRegion[0]);
        }
        else
        {
            rcHandle->endPoint[epIndex].configIndex = IFXPCIE_RC_NULL_CFG_INDEX;                                /* No index chosen */
            epCfg                                   = NULL_PTR;                                                 /* No valid configurations */
        }
    }

    if (status == IfxPcie_Status_success)
    {
        rcHandle->numEndPoints++;
        status = IfxPcie_Rc_allocateBarMemories(rcHandle, epIndex, memCfg, IfxPcieDevice_Type_endpoint);        /* Allocate Memories */
    }

    if (status == IfxPcie_Status_success)
    {
        IfxPcieLib_Cap_probeCapabilities(&(epDevice->capabilities), (IfxPcieDevice_CfgHdr *)configHdr0);        /* Probe Capabilities */

        if ((epDevice->capabilities.pmc.capPtr != NULL_PTR)
            && (epCfg != NULL_PTR))
        {
            IfxPcieCap_setPmeActive(epDevice->capabilities.pmc.capPtr, epCfg->epFunction.pmeEnable);
        }
    }

    epDevice->enabled = FALSE;

    return status;
}


IfxPcie_Status IfxPcie_Rc_allocateBarMemories(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_MemCfg *memCfgPtr, IfxPcieDevice_Type devType)
{
    IfxPcie_Status                    status                  = IfxPcie_Status_success;                     /* Initialize Status to success */
    IfxPcie_Rc_Mem                   *memHandlePtr            = NULL_PTR;
    IfxPcie_Rc_EndPoint              *epDevice                = NULL_PTR;
    IfxPcie_Rc_Bridge                *bridge                  = NULL_PTR;
    IfxPcieDevice_Type0CfgHdr        *cfgHdr                  = NULL_PTR;
    volatile IfxPcieDevice_CfgHdrBar *barReg, *barRegUpper;
    IfxPcie_Rc_MemCfg                *memCfg                  = NULL_PTR;
    boolean                           doubleWordAddr;
    uint8                             barIndex                = 0u;
    uint8                             memIndex                = 0u;
    uint8                             numBars                 = 0u;
    uint64                            barMemSize              = 0u;
    boolean                           userConfig              = (memCfgPtr == NULL_PTR) ? FALSE : TRUE;
    uint32                            wireMemBase             = rcHandle->addressSpace.wireMemBase;
    uint32                            wireMemLimit            = rcHandle->addressSpace.wireMemLimit;
    uint64                            prefetchWireMemBase     = rcHandle->addressSpace.wireMemPrefetchBase;
    uint64                            prefetchWireMemLimit    = rcHandle->addressSpace.wireMemPrefetchLimit;
    uint64                            freeWirePrefetchMemSize = prefetchWireMemLimit - prefetchWireMemBase;
    uint32                            freeWireMemSize         = wireMemLimit - wireMemBase;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        epDevice                = &(rcHandle->endPoint[devIndex]);
        epDevice->numMemRegions = memIndex;                                                                 /* Start with 0 */
        memHandlePtr            = &(epDevice->memRegion[memIndex]);
        numBars                 = IFXPCIE_CFG_MAX_NUM_EP_BARS;
        cfgHdr                  = epDevice->epFunction.cfgHeader;
    }
    else
    {
        bridge                = &(rcHandle->bridge[devIndex]);
        bridge->numMemRegions = memIndex;                                                                   /* Start with 0 */
        memHandlePtr          = &(bridge->memRegion[memIndex]);
        numBars               = IFXPCIE_CFG_MAX_NUM_BRIDGE_BARS;
        cfgHdr                = (IfxPcieDevice_Type0CfgHdr *)bridge->bridgeFunction.cfgHeader;
    }

    while (barIndex < numBars)
    {
        barReg         = &(cfgHdr->bar[barIndex]);
        barRegUpper    = &(cfgHdr->bar[barIndex + 1]);
        memCfg         = (userConfig == TRUE) ? (memCfgPtr + barIndex) : NULL_PTR;

        doubleWordAddr = (barReg->B.barType == IfxPcie_AddressWidth_64) ? TRUE : FALSE;

        barMemSize     = IfxPcie_getBarMemSize((uint32 *)barReg, doubleWordAddr);                           /* Read back Size */

        if (barMemSize > 0u)                                                                                /* Device has requested some memory */
        {
            if (barReg->B.memIo == 1u)                                                                      /* Memory is IO */
            {
                status |= IfxPcie_Status_failure;                                                           /* IO not supported */
                break;
            }

            if (barReg->B.prefetch == 0u)                                                                   /* Memory is not pre-fetchable */
            {
                if (barMemSize <= (uint64)freeWireMemSize)                                                  /* Free memory available */
                {
                    wireMemBase = (uint32)(IFXPCIE_GET_WIREADDR_FROMBAR(wireMemBase, barMemSize));          /* Ensure that wire memory is now aligned */

                    barReg->U   = wireMemBase;                                                              /* Write the memory base address */

                    IFXPCIE_CONFIGWRITE_DELAY(IFXPCIE_CFG_CONFIGWRITE_DELAYCOUNT);

                    if (doubleWordAddr == TRUE)
                    {
                        barRegUpper->U = 0u;                                                                /* Non-prefetch is always 32 bit */
                        IFXPCIE_CONFIGWRITE_DELAY(IFXPCIE_CFG_CONFIGWRITE_DELAYCOUNT);
                    }

                    memHandlePtr->functionMem.wireMemBase  = (uint64)wireMemBase;                           /* Update Handle with wire base address */
                    memHandlePtr->functionMem.size         = barMemSize;                                    /* Update handle with size of memory allocated */
                    memHandlePtr->functionMem.addressWidth = (IfxPcie_AddressWidth)barReg->B.barType;       /* Update handle with address width */
                    memHandlePtr->functionMem.barIndex     = (IfxPcie_BarNum)barIndex;                      /* Update handle with BAR index */
                    wireMemBase                            = wireMemBase + (uint32)barMemSize;              /* Update wire memory base */
                    freeWireMemSize                        = wireMemLimit - wireMemBase;                    /* Update free memory size */
                }
                else
                {
                    status |= IfxPcie_Status_failure;                                                       /* Memory limit breached */
                    break;
                }
            }
            else                                                                                            /* memory is prefetch */
            {
                if (barMemSize <= freeWirePrefetchMemSize)                                                  /* Free memory available */
                {
                    prefetchWireMemBase = IFXPCIE_GET_WIREADDR_FROMBAR(prefetchWireMemBase, barMemSize);    /* Ensure that wire memory is now aligned */
                    barReg->U           = (uint32)prefetchWireMemBase;                                      /* Write the memory base address */
                    IFXPCIE_CONFIGWRITE_DELAY(IFXPCIE_CFG_CONFIGWRITE_DELAYCOUNT);

                    if (doubleWordAddr)
                    {
                        barRegUpper->U = (uint32)(prefetchWireMemBase >> 32u);                              /* Upper Base address */
                        IFXPCIE_CONFIGWRITE_DELAY(IFXPCIE_CFG_CONFIGWRITE_DELAYCOUNT);
                    }

                    memHandlePtr->functionMem.wireMemBase  = prefetchWireMemBase;                           /* Update Handle with wire base address */
                    memHandlePtr->functionMem.size         = barMemSize;                                    /* Update handle with size of memory allocated */
                    memHandlePtr->functionMem.addressWidth = (IfxPcie_AddressWidth)barReg->B.barType;       /* Update handle with address width */
                    memHandlePtr->functionMem.barIndex     = (IfxPcie_BarNum)barIndex;                      /* Update handle with BAR index */
                    prefetchWireMemBase                    = prefetchWireMemBase + barMemSize;              /* Update prefetch wire memory base */
                    freeWirePrefetchMemSize                = prefetchWireMemLimit - prefetchWireMemBase;    /* Update prefetch free memory size */
                }
                else
                {
                    status |= IfxPcie_Status_failure;                                                       /* Memory limit breached */
                    break;
                }
            }

            if (devType == IfxPcieDevice_Type_endpoint)
            {
                epDevice->numMemRegions++;                                                                  /* Update number of mem Regions */
            }
            else
            {
                bridge->numMemRegions++;                                                                    /* Update number of mem Regions */
            }

            if (userConfig == TRUE)                                                                         /* User config exists */
            {
                if (memCfg->mapToLocal == TRUE)
                {
                    status = IfxPcie_Rc_mapLocalMemory(rcHandle, devIndex, memIndex, memCfg->atuRegion, devType);
                }
                else
                {
                    memHandlePtr->localMemBase = 0x0u;
                }
            }
            else
            {
                memHandlePtr->localMemBase = 0x0u;
            }

            memHandlePtr++;
            memIndex++;
        }

        if (status == IfxPcie_Status_failure)
        {
            break;
        }

        barIndex = (doubleWordAddr == TRUE) ? barIndex + 2 : barIndex + 1;
    }

    rcHandle->addressSpace.wireMemBase         = wireMemBase;
    rcHandle->addressSpace.wireMemPrefetchBase = prefetchWireMemBase;

    return status;
}


void IfxPcie_Rc_configureEcamAtu(IfxPcie_Rc *rcHandle, uint8 busNum, uint8 deviceNum, uint8 funcNum, IfxPcieDevice_Type devType)
{
    IfxPcieLib_Device_AtuRegionCfg atu0Cfg;
    IfxPcieLib_Device_AtuRegion   *atuRegion = &(rcHandle->atu.outboundRegion[IFXPCIE_CFG_ECAM_ATU_INDEX]);
    IfxPcie_Rc_AddressSpace       *addrSpace = &(rcHandle->addressSpace);

    atu0Cfg.regionIndex                = (IfxPcie_AtuRegion)(IFXPCIE_CFG_ECAM_ATU_INDEX);
    atu0Cfg.direction                  = IfxPcie_AtuDirection_outBound;
    atu0Cfg.barMapped                  = FALSE;
    atu0Cfg.localMemBase               = addrSpace->localConfigBase;
    atu0Cfg.wireMemBase                = (uint64)(IfxPcieRc_ComposeExternalConfigAddress(busNum, deviceNum, funcNum, 0u) << IFXPCIERC_ECAM_SHIFT);
    atu0Cfg.memSize                    = IFXPCIE_CFG_FUNCTION_CFG_SPACE;
    atu0Cfg.outboundTlp.dmaBypass      = FALSE;
    atu0Cfg.outboundTlp.tlpHeader.type = IfxPcie_TlpType_configType0;
    atu0Cfg.enable                     = TRUE;

    IfxPcieLib_Device_initAtuRegion((IfxPcie *)(rcHandle->pcieSFR), atuRegion, &atu0Cfg);
}


IfxPcie_Status IfxPcie_Rc_configureMemAtu(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcie_AtuRegion region, IfxPcieDevice_Type devType)
{
    IfxPcie_Status                 status     = IfxPcie_Status_failure;
    IfxPcieLib_Device_AtuRegionCfg atuRegionCfg;
    IfxPcie_Rc_Mem                *memHandle  = NULL_PTR;
    IfxPcieLib_Device_AtuRegion   *atuRegion  = &(rcHandle->atu.outboundRegion[region]);
    uint8                          numDevices = 0u;
    uint8                          numMem     = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        numDevices = rcHandle->numEndPoints;
        numMem     = rcHandle->endPoint[devIndex].numMemRegions;
    }
    else
    {
        numDevices = rcHandle->numBridges;
        numMem     = rcHandle->bridge[devIndex].numMemRegions;
    }

    if (devIndex < numDevices)
    {
        if (memIndex < numMem)
        {
            if ((region != (IfxPcie_AtuRegion)(IFXPCIE_CFG_ECAM_ATU_INDEX))         /* Not blocked for configuration */
                && (region != IfxPcie_AtuRegion_none)                               /* Valid Region */
                && (atuRegion->enabled == FALSE))                                   /* Region is not already initialized */
            {
                if (devType == IfxPcieDevice_Type_endpoint)
                {
                    memHandle = &(rcHandle->endPoint[devIndex].memRegion[memIndex]);
                }
                else
                {
                    memHandle = &(rcHandle->bridge[devIndex].memRegion[memIndex]);
                }

                atuRegionCfg.regionIndex                        = region;
                atuRegionCfg.direction                          = IfxPcie_AtuDirection_outBound;
                atuRegionCfg.barMapped                          = FALSE;
                atuRegionCfg.localMemBase                       = memHandle->localMemBase;
                atuRegionCfg.wireMemBase                        = memHandle->functionMem.wireMemBase;
                atuRegionCfg.memSize                            = (uint32)(memHandle->functionMem.size);
                atuRegionCfg.outboundTlp.dmaBypass              = FALSE;
                atuRegionCfg.outboundTlp.tlpHeader.type         = IfxPcie_TlpType_memRequest;
                atuRegionCfg.outboundTlp.tlpHeader.trafficClass = IfxPcie_TlpTrafficClass_0;
                atuRegionCfg.outboundTlp.tlpHeader.tag          = 0u;
                atuRegionCfg.outboundTlp.tlpHeader.orderingAttr = IfxPcie_TlpOrdering_default;
                atuRegionCfg.enable                             = TRUE;

                IfxPcieLib_Device_initAtuRegion((IfxPcie *)(rcHandle->pcieSFR), atuRegion, &atuRegionCfg);  /* Initialize the Region */
                memHandle->atuRegion = region;
                status               = IfxPcie_Status_success;
            }
        }
    }

    return status;
}


IfxPcie_Status IfxPcie_Rc_mapLocalMemory(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcie_AtuRegion region, IfxPcieDevice_Type devType)
{
    IfxPcie_Status  status           = IfxPcie_Status_success;
    IfxPcie_Rc_Mem *memHandle        = NULL_PTR;
    uint32          localMemBase     = rcHandle->addressSpace.localMemBase;
    uint32          localMemLimit    = rcHandle->addressSpace.localMemLimit;
    uint32          freeLocalMemSize = localMemLimit - localMemBase;
    uint64          barMemSize       = 0U;
    uint8           numDevices       = 0u;
    uint8           numMem           = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        numDevices = rcHandle->numEndPoints;
        numMem     = rcHandle->endPoint[devIndex].numMemRegions;
    }
    else
    {
        numDevices = rcHandle->numBridges;
        numMem     = rcHandle->bridge[devIndex].numMemRegions;
    }

    if (devIndex < numDevices)
    {
        if (memIndex < numMem)
        {
            if (devType == IfxPcieDevice_Type_endpoint)
            {
                memHandle = &(rcHandle->endPoint[devIndex].memRegion[memIndex]);
            }
            else
            {
                memHandle = &(rcHandle->bridge[devIndex].memRegion[memIndex]);
            }
        }
    }

    if (memHandle != NULL_PTR)                                              /* Valid memory region */
    {
        barMemSize = memHandle->functionMem.size;

        if ((barMemSize > 0)                                                       /* Memory size is not 0 */
            && (barMemSize <= (uint64)freeLocalMemSize))                           /* Free Local memory available */
        {
            memHandle->localMemBase = localMemBase;                                /* Update handle with local base address */
            localMemBase           += (uint32)barMemSize;                          /* Update local memory base */
            localMemBase            = IFXPCIE_GET_NEXT_4KB_BOUNDARY(localMemBase); /* Get 4KB boundary needed for ATU */

            if (region > IfxPcie_AtuRegion_none)
            {
                status = IfxPcie_Rc_configureMemAtu(rcHandle, devIndex, memIndex, region, devType);
            }

            rcHandle->addressSpace.localMemBase = localMemBase;             /* Update back to handle */
        }
    }
    else
    {
        status = IfxPcie_Status_failure;                                    /* failed, local memory overrun */
    }

    return status;
}


IfxPcie_Status IfxPcie_Rc_initFunctionInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_FunctionIntCfg *intCfg, IfxPcieDevice_Type devType)
{
    IfxPcie_Status                 status        = IfxPcie_Status_success;
    IfxPcie_InterruptType          interruptType = rcHandle->interruptType;
    IfxPcie_Rc_RemoteIntVectorCfg *intVectCfg;
    uint8                          numVectors;
    uint8                          vectorIndex;

    if (intCfg != NULL_PTR)
    {
        numVectors = intCfg->numVectors;

        switch (interruptType)
        {
        case IfxPcie_InterruptType_msi:

            if (numVectors == 1u)
            {
                intVectCfg = &(intCfg->intVector[0]);
                status     = IfxPcie_Rc_initMsiInterrupt(rcHandle, devIndex, intVectCfg, devType);
            }
            else
            {
                status = IfxPcie_Status_failure;    /* Only one interrupt vector allowed for MSI */
            }

            break;
        case IfxPcie_InterruptType_msix:
            status = IfxPcie_Rc_initMsixInterrupt(rcHandle, devIndex, intCfg, devType);
            break;
        case IfxPcie_InterruptType_legacy:

            if (numVectors == 1u)
            {
                intVectCfg = &(intCfg->intVector[0]);
                IfxPcie_Rc_initLegacyInterrupt(rcHandle, devIndex, intVectCfg, devType);
            }
            else
            {
                status = IfxPcie_Status_failure;    /* Only one interrupt vector allowed for INTX */
            }

            break;
        default:
            break;
        }

        if (status == IfxPcie_Status_success)
        {
            for (vectorIndex = 0u; vectorIndex < numVectors; vectorIndex++)
            {
                intVectCfg = &(intCfg->intVector[vectorIndex]);
                IfxPcieRc_disableRemoteInterrupts(rcHandle->pcieSFR, intVectCfg->node.intVector);                         /* Disable now, enable later */
                IfxPcieRc_setRemoteInterruptMask(rcHandle->pcieSFR, intVectCfg->node.intVector, intVectCfg->initialMask); /* Set the initial mask */
                IfxPcieRc_clearPendingRemoteInterrupts(rcHandle->pcieSFR, intVectCfg->node.intVector, 0xFFFFFFFFu);       /* Clear all Pending interrupts */
            }
        }
    }
    else
    {
        if (devType == IfxPcieDevice_Type_endpoint)
        {
            rcHandle->endPoint[devIndex].interrupt.numVectors = 0u;             /* No interrupts configured */
        }
        else
        {
            rcHandle->bridge[devIndex].interrupt.numVectors = 0u;               /* No interrupts configured */
        }
    }

    if (status == IfxPcie_Status_failure)
    {
        rcHandle->state = IfxPcie_Rc_State_configError; /* Fail : configuration Error */
    }

    return status;
}


IfxPcie_Status IfxPcie_Rc_initMsiInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_RemoteIntVectorCfg *intVectCfg, IfxPcieDevice_Type devType)
{
    IfxPcie_Status          status = IfxPcie_Status_failure;
    IfxPcie_Rc_EndPoint    *epDevice;
    IfxPcie_Rc_Bridge      *bridge;
    IfxPcie_IntVector       intVector;
    IfxPcie_Rc_FunctionInt *funcInterrupt;
    IfxPcieLib_Cap_MsiCfg   msiCfg;
    IfxPcieLib_Cap_Msi     *msiCapPtr = NULL_PTR;
    boolean                 atuLocked = FALSE;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        epDevice      = &(rcHandle->endPoint[devIndex]);
        msiCapPtr     = &(epDevice->epFunction.capabilities.msi);
        funcInterrupt = &(epDevice->interrupt);
    }
    else
    {
        bridge        = &(rcHandle->bridge[devIndex]);
        msiCapPtr     = &(bridge->bridgeFunction.capabilities.msi);
        funcInterrupt = &(bridge->interrupt);
    }

    if (IfxPcie_Rc_isConfigAccessEnabled(rcHandle, devIndex, devType) == FALSE)                         /* Configure Config Access, if not enabled */
    {
        (void)IfxPcie_Rc_getConfigAccess(rcHandle, devIndex, devType);
        atuLocked = TRUE;
    }

    if (intVectCfg != NULL_PTR)
    {
        intVector = intVectCfg->node.intVector;

        if ((intVector > IfxPcie_IntVector_none)
            && (intVector <= IfxPcie_IntVector_remote7MsiIntD))
        {
            /* Initialize MSI Capabilities */
            msiCfg.dataPattern   = IFXPCIERC_GET_MSI_BASEDATA_FROM_VECTOR(intVectCfg->node.intVector);
            msiCfg.address       = IFXPCIE_CFG_MSI_RECEPTION_ADDRESS;
            msiCfg.numInterrupts = intVectCfg->numInterrupts;
            msiCfg.initialMask   = intVectCfg->initialMask;
            msiCfg.capPtr        = msiCapPtr->capPtr;                                                   /* In this case, we already have cap Ptr in handle */

            status               = IfxPcieLib_Cap_configureMsiCap(msiCapPtr, &msiCfg);
        }

        if (status == IfxPcie_Status_success)
        {
            IfxPcieLib_Device_initSrcNode((IfxPcie *)rcHandle->pcieSFR, rcHandle->index, &(intVectCfg->node));
            funcInterrupt->numVectors                 = 1u;                                             /* Always 1 vector for MSI */
            funcInterrupt->intVector[0].intVector     = intVectCfg->node.intVector;
            funcInterrupt->intVector[0].mask          = intVectCfg->initialMask;
            funcInterrupt->intVector[0].pendingBits   = 0u;
            funcInterrupt->intVector[0].numInterrupts = IFXPCIE_GET_NUM_MSI_INTERRUPTS(intVectCfg->numInterrupts);

            IfxPcieCap_enableMsi(msiCapPtr->capPtr);
        }
    }

    if (atuLocked == TRUE)
    {
        (void)IfxPcie_Rc_freeConfigAccess(rcHandle, devIndex, devType);
    }

    return status;
}


IfxPcie_Status IfxPcie_Rc_initMsixInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_FunctionIntCfg *intCfg, IfxPcieDevice_Type devType)
{
    IfxPcie_Status                 status = IfxPcie_Status_failure;
    IfxPcie_Rc_EndPoint           *epDevice;
    IfxPcie_Rc_Bridge             *bridge;
    IfxPcie_Rc_FunctionInt        *funcInterrupt;
    IfxPcie_Rc_RemoteIntVectorCfg *intVectCfg;
    IfxPcieLib_Cap_MsixCfg         msixCfg;
    IfxPcieLib_Cap_Msix           *msixCap;
    IfxPcie_IntVector              intVector;
    uint8                          vectorIndex, numVectors, msixBarIndex;
    uint32                         tableOffset;
    uint32                        *localAddr;
    boolean                        atuLocked = FALSE;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        epDevice      = &(rcHandle->endPoint[devIndex]);
        msixCap       = &(epDevice->epFunction.capabilities.msix);
        funcInterrupt = &(epDevice->interrupt);
    }
    else
    {
        bridge        = &(rcHandle->bridge[devIndex]);
        msixCap       = &(bridge->bridgeFunction.capabilities.msix);
        funcInterrupt = &(bridge->interrupt);
    }

    if (IfxPcie_Rc_isConfigAccessEnabled(rcHandle, devIndex, devType) == FALSE)
    {
        (void)IfxPcie_Rc_getConfigAccess(rcHandle, devIndex, devType);
        atuLocked = TRUE;
    }

    if (intCfg != NULL_PTR)
    {
        numVectors = intCfg->numVectors;

        if ((numVectors > 0) && (numVectors <= IFXPCIE_CFG_MAX_NUM_EP_INTVECTORS))
        {
            /* Initialize MSIx Capabilities */
            msixCfg.capPtr = msixCap->capPtr;                                                                       /* In this case, we already have cap Ptr in handle */

            IfxPcieCap_getMsixTableBaseOffset(msixCfg.capPtr, &tableOffset, &msixBarIndex);                         /* Get the offset and BAR index of MSIX Table */
            localAddr = IfxPcie_Rc_getBarLocalAddress(rcHandle, devIndex, msixBarIndex, devType);

            if (localAddr != NULL_PTR)
            {
                msixCfg.tableAddr = (IfxPcieCap_MsixTableEntry *)((uint32)localAddr + tableOffset);
            }

            for (vectorIndex = 0u; vectorIndex < numVectors; vectorIndex++)
            {
                intVectCfg = &(intCfg->intVector[vectorIndex]);
                intVector  = intVectCfg->node.intVector;

                if ((intVector > IfxPcie_IntVector_none)
                    && (intVector <= IfxPcie_IntVector_remote7MsiIntD)
                    && (localAddr != NULL_PTR))
                {
                    msixCfg.dataPattern   = IFXPCIERC_GET_MSI_BASEDATA_FROM_VECTOR(intVectCfg->node.intVector);
                    msixCfg.address       = IFXPCIE_CFG_MSI_RECEPTION_ADDRESS;
                    msixCfg.numInterrupts = IFXPCIE_GET_NUM_MSI_INTERRUPTS(intVectCfg->numInterrupts);

                    status                = IfxPcieLib_Cap_configureMsixCap(msixCap, &msixCfg);

                    if (status == IfxPcie_Status_success)
                    {
                        IfxPcieLib_Device_initSrcNode((IfxPcie *)rcHandle->pcieSFR, rcHandle->index, &(intVectCfg->node));
                        funcInterrupt->numVectors                           = vectorIndex + 1u;
                        funcInterrupt->intVector[vectorIndex].intVector     = intVectCfg->node.intVector;
                        funcInterrupt->intVector[vectorIndex].mask          = intVectCfg->initialMask;
                        funcInterrupt->intVector[vectorIndex].pendingBits   = 0u;
                        funcInterrupt->intVector[vectorIndex].numInterrupts = IFXPCIE_GET_NUM_MSI_INTERRUPTS(intVectCfg->numInterrupts);
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    status = IfxPcie_Status_failure;
                    break;
                }
            }

            if (status == IfxPcie_Status_success)
            {
                IfxPcieCap_enableMsix(msixCap->capPtr);
            }
        }
    }

    if (atuLocked == TRUE)
    {
        (void)IfxPcie_Rc_freeConfigAccess(rcHandle, devIndex, devType);
    }

    return status;
}


void IfxPcie_Rc_initLegacyInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_RemoteIntVectorCfg *intVectCfg, IfxPcieDevice_Type devType)
{
    IfxPcie_Rc_EndPoint    *epDevice;
    IfxPcie_Rc_Bridge      *bridge;
    IfxPcie_Rc_FunctionInt *funcInterrupt;
    IfxPcie_IntVector       intVector;
    boolean                 atuLocked = FALSE;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        epDevice      = &(rcHandle->endPoint[devIndex]);
        funcInterrupt = &(epDevice->interrupt);
    }
    else
    {
        bridge        = &(rcHandle->bridge[devIndex]);
        funcInterrupt = &(bridge->interrupt);
    }

    if (IfxPcie_Rc_isConfigAccessEnabled(rcHandle, devIndex, devType) == FALSE)                     /* Configure Config Access, if not enabled */
    {
        (void)IfxPcie_Rc_getConfigAccess(rcHandle, devIndex, devType);
        atuLocked = TRUE;
    }

    if (intVectCfg != NULL_PTR)
    {
        intVector = intVectCfg->node.intVector;

        if ((intVector >= IfxPcie_IntVector_remote4MsiIntA)
            && (intVector <= IfxPcie_IntVector_remote7MsiIntD))
        {
            IfxPcieLib_Device_initSrcNode((IfxPcie *)rcHandle->pcieSFR, rcHandle->index, &(intVectCfg->node));

            funcInterrupt->numVectors                 = 1u;                                             /* Always 1 vector for MSI */
            funcInterrupt->intVector[0].intVector     = intVectCfg->node.intVector;
            funcInterrupt->intVector[0].mask          = 0u;
            funcInterrupt->intVector[0].pendingBits   = 0u;
            funcInterrupt->intVector[0].numInterrupts = 1u;
        }
    }

    if (atuLocked == TRUE)
    {
        (void)IfxPcie_Rc_freeConfigAccess(rcHandle, devIndex, devType);
    }
}


IfxPcie_Status IfxPcie_Rc_generateAurixEpTrigger(IfxPcie_Rc *rcHandle, uint8 epIndex, uint8 triggerIndex)
{
    IfxPcie_Status status     = IfxPcie_Status_failure;
    uint32        *barAddress = IfxPcie_Rc_getBarLocalAddress(rcHandle, epIndex, 0u, IfxPcieDevice_Type_endpoint);
    uint32        *intReqTrigPtr;

    if (barAddress != NULL_PTR)
    {
        intReqTrigPtr = barAddress + IFXPCIE_INTREQTRIG_BAR0_WORD_OFFSET;

        if (triggerIndex < IFXPCIE_CFG_MAX_EP_INTTRIGGERS)
        {
            *intReqTrigPtr = (uint32)(triggerIndex);
            status         = IfxPcie_Status_success;
        }
    }

    return status;
}


boolean IfxPcie_Rc_getAurixEpTriggerStatus(IfxPcie_Rc *rcHandle, uint8 epIndex, uint8 triggerIndex)
{
    boolean intStatus  = FALSE;
    uint32 *barAddress = IfxPcie_Rc_getBarLocalAddress(rcHandle, epIndex, 0u, IfxPcieDevice_Type_endpoint);
    uint32 *intReqTrigStatusPtr;

    if (barAddress != NULL_PTR)
    {
        intReqTrigStatusPtr = barAddress + IFXPCIE_INTREQSTATUS_BAR0_WORD_OFFSET;

        if (triggerIndex < IFXPCIE_CFG_MAX_EP_INTTRIGGERS)
        {
            if ((*intReqTrigStatusPtr & ((uint32)1u << triggerIndex)) != 0u)
            {
                intStatus = TRUE;
            }
        }
    }

    return intStatus;
}


void IfxPcie_Rc_enableEndPoints(IfxPcie_Rc *rcHandle)
{
    uint8                     bridgeIndex, epIndex;
    IfxPcie_Rc_EndPoint      *epDevice;
    IfxPcieLib_Device_Bridge *bridgeDevice;
    uint8                     numEp     = rcHandle->numEndPoints;
    uint8                     numBridge = rcHandle->numBridges;

    for (bridgeIndex = 0; bridgeIndex < numBridge; bridgeIndex++)
    {
        bridgeDevice = &(rcHandle->bridge[bridgeIndex].bridgeFunction);
        IfxPcie_Rc_configureEcamAtu(rcHandle, bridgeDevice->primaryBus, bridgeDevice->device, bridgeDevice->function, IfxPcieDevice_Type_bridge);
        IfxPcieDevice_enableBusMaster((IfxPcieDevice_CfgHdr *)(bridgeDevice->cfgHeader));                       /* Set Bus Master Enable */
        IfxPcieDevice_enableMemorySpace((IfxPcieDevice_CfgHdr *)(bridgeDevice->cfgHeader));                     /* Memory Space Enable */
        bridgeDevice->enabled = TRUE;
    }

    for (epIndex = 0; epIndex < numEp; epIndex++)
    {
        epDevice = &(rcHandle->endPoint[epIndex]);
        IfxPcie_Rc_configureEcamAtu(rcHandle, epDevice->epFunction.bus, epDevice->epFunction.device, epDevice->epFunction.function, IfxPcieDevice_Type_endpoint);
        IfxPcieDevice_enableBusMaster((IfxPcieDevice_CfgHdr *)(epDevice->epFunction.cfgHeader));                /* Set Bus Master Enable */
        IfxPcieDevice_enableMemorySpace((IfxPcieDevice_CfgHdr *)(epDevice->epFunction.cfgHeader));              /* Memory Space Enable */
        epDevice->epFunction.enabled = TRUE;
    }
}


boolean IfxPcie_Rc_isConfigAccessEnabled(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type type)
{
    boolean                     configMap = FALSE;
    IfxPcieLib_Device_EndPoint *epDevice;
    IfxPcieLib_Device_Bridge   *bridgeDevice;
    uint64                      wireMemBase = 0U;

    if (type == IfxPcieDevice_Type_endpoint)
    {
        epDevice    = &(rcHandle->endPoint[devIndex].epFunction);
        wireMemBase = (uint64)(IfxPcieRc_ComposeExternalConfigAddress(epDevice->bus, epDevice->device, epDevice->function, 0u) << IFXPCIERC_ECAM_SHIFT);
    }
    else if (type == IfxPcieDevice_Type_bridge)
    {
        bridgeDevice = &(rcHandle->bridge[devIndex].bridgeFunction);
        wireMemBase  = (uint64)(IfxPcieRc_ComposeExternalConfigAddress(bridgeDevice->primaryBus, bridgeDevice->device, bridgeDevice->function, 0u) << IFXPCIERC_ECAM_SHIFT);
    }

    if ((wireMemBase == rcHandle->atu.outboundRegion[IFXPCIE_CFG_ECAM_ATU_INDEX].wireMemBase)
        && (rcHandle->atu.outboundRegion[IFXPCIE_CFG_ECAM_ATU_INDEX].lockStatus == IfxPcie_AtuLock_locked))
    {
        configMap = TRUE;
    }

    return configMap;
}


uint32 *IfxPcie_Rc_getConfigAccess(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type type)
{
    uint32                     *configAddress = NULL_PTR;
    IfxPcieLib_Device_EndPoint *epDevice;
    IfxPcieLib_Device_Bridge   *bridgeDevice;

    if (IfxPcie_Rc_isConfigAccessEnabled(rcHandle, devIndex, type) == FALSE)
    {
        if (IfxPcieLib_Device_isAtuRegionLocked(&(rcHandle->atu.outboundRegion[IFXPCIE_CFG_ECAM_ATU_INDEX])) == FALSE)
        {
            if (type == IfxPcieDevice_Type_endpoint)
            {
                epDevice      = &(rcHandle->endPoint[devIndex].epFunction);
                IfxPcie_Rc_configureEcamAtu(rcHandle, epDevice->bus, epDevice->device, epDevice->function, IfxPcieDevice_Type_endpoint);
                configAddress = (uint32 *)(epDevice->cfgHeader);
            }
            else if (type == IfxPcieDevice_Type_bridge)
            {
                bridgeDevice  = &(rcHandle->bridge[devIndex].bridgeFunction);
                IfxPcie_Rc_configureEcamAtu(rcHandle, bridgeDevice->primaryBus, bridgeDevice->device, bridgeDevice->function, IfxPcieDevice_Type_bridge);
                configAddress = (uint32 *)(bridgeDevice->cfgHeader);
            }
        }
    }
    else
    {
        if (type == IfxPcieDevice_Type_endpoint)
        {
            epDevice      = &(rcHandle->endPoint[devIndex].epFunction);
            configAddress = (uint32 *)(epDevice->cfgHeader);
        }
        else if (type == IfxPcieDevice_Type_bridge)
        {
            bridgeDevice  = &(rcHandle->bridge[devIndex].bridgeFunction);
            configAddress = (uint32 *)(bridgeDevice->cfgHeader);
        }
    }

    return configAddress;
}


boolean IfxPcie_Rc_freeConfigAccess(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type type)
{
    boolean freeStatus = FALSE;

    if (IfxPcieLib_Device_isAtuRegionLocked(&(rcHandle->atu.outboundRegion[IFXPCIE_CFG_ECAM_ATU_INDEX])) == TRUE)
    {
        if (IfxPcie_Rc_isConfigAccessEnabled(rcHandle, devIndex, type) == TRUE)
        {
            IfxPcieLib_Device_freeAtuRegion((IfxPcie *)(rcHandle->pcieSFR), &(rcHandle->atu.outboundRegion[IFXPCIE_CFG_ECAM_ATU_INDEX]));
            freeStatus = TRUE;
        }
    }
    else
    {
        freeStatus = TRUE;  /* ATU is already free */
    }

    return freeStatus;
}


uint32 *IfxPcie_Rc_getLocalAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcieDevice_Type devType)
{
    uint32         *localAddressPtr = NULL_PTR;
    IfxPcie_Rc_Mem *memHandle       = NULL_PTR;
    uint8           numDevices      = 0u;
    uint8           numMem          = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        numDevices = rcHandle->numEndPoints;
        numMem     = rcHandle->endPoint[devIndex].numMemRegions;
    }
    else
    {
        numDevices = rcHandle->numBridges;
        numMem     = rcHandle->bridge[devIndex].numMemRegions;
    }

    if (devIndex < numDevices)
    {
        if (memIndex < numMem)
        {
            if (devType == IfxPcieDevice_Type_endpoint)
            {
                memHandle = &(rcHandle->endPoint[devIndex].memRegion[memIndex]);
            }
            else
            {
                memHandle = &(rcHandle->bridge[devIndex].memRegion[memIndex]);
            }
        }
    }

    if ((memHandle != NULL_PTR)
        && (memHandle->localMemBase != 0u))
    {
        localAddressPtr = (uint32 *)(memHandle->localMemBase);
    }

    return localAddressPtr;
}


uint32 *IfxPcie_Rc_getBarLocalAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 barIndex, IfxPcieDevice_Type devType)
{
    uint32         *localAddr   = NULL_PTR;
    IfxPcie_Rc_Mem *memHandle   = NULL_PTR;
    uint8           numMem      = 0u;
    uint8           regionIndex = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        memHandle = &(rcHandle->endPoint[devIndex].memRegion[0]);
        numMem    = rcHandle->endPoint[devIndex].numMemRegions;
    }
    else
    {
        memHandle = &(rcHandle->bridge[devIndex].memRegion[0]);
        numMem    = rcHandle->bridge[devIndex].numMemRegions;
    }

    for (regionIndex = 0; regionIndex < numMem; regionIndex++)
    {
        if (memHandle->functionMem.barIndex == barIndex)
        {
            if (memHandle->localMemBase != 0u)
            {
                localAddr = (uint32 *)(memHandle->localMemBase);
            }

            break;
        }

        memHandle++;
    }

    return localAddr;
}


uint64 IfxPcie_Rc_getWireAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcieDevice_Type devType)
{
    uint64          wireAddress = 0x0u;
    IfxPcie_Rc_Mem *memHandle   = NULL_PTR;
    uint8           numDevices  = 0u;
    uint8           numMem      = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        numDevices = rcHandle->numEndPoints;
        numMem     = rcHandle->endPoint[devIndex].numMemRegions;
    }
    else
    {
        numDevices = rcHandle->numBridges;
        numMem     = rcHandle->bridge[devIndex].numMemRegions;
    }

    if (devIndex < numDevices)
    {
        if (memIndex < numMem)
        {
            if (devType == IfxPcieDevice_Type_endpoint)
            {
                memHandle = &(rcHandle->endPoint[devIndex].memRegion[memIndex]);
            }
            else
            {
                memHandle = &(rcHandle->bridge[devIndex].memRegion[memIndex]);
            }
        }
    }

    if ((memHandle != NULL_PTR)
        && (memHandle->functionMem.size != 0u))
    {
        wireAddress = (memHandle->functionMem.wireMemBase);
    }

    return wireAddress;
}


uint64 IfxPcie_Rc_getBarWireAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 barIndex, IfxPcieDevice_Type devType)
{
    uint64          wireAddress = 0x0u;
    IfxPcie_Rc_Mem *memHandle   = NULL_PTR;
    uint8           numMem      = 0u;
    uint8           regionIndex = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        memHandle = &(rcHandle->endPoint[devIndex].memRegion[0]);
        numMem    = rcHandle->endPoint[devIndex].numMemRegions;
    }
    else
    {
        memHandle = &(rcHandle->bridge[devIndex].memRegion[0]);
        numMem    = rcHandle->bridge[devIndex].numMemRegions;
    }

    for (regionIndex = 0; regionIndex < numMem; regionIndex++)
    {
        if (memHandle->functionMem.barIndex == barIndex)
        {
            if (memHandle->functionMem.size != 0u)
            {
                wireAddress = (memHandle->functionMem.wireMemBase);
            }

            break;
        }

        memHandle++;
    }

    return wireAddress;
}


uint8 IfxPcie_Rc_getEnumeratedDeviceIndex(IfxPcie_Rc *rcHandle, uint16 deviceId, uint16 vendorId, IfxPcieDevice_Type devType)
{
    uint8                 deviceIndex = 0u;
    uint8                 chosenIndex = 0xFFu;
    boolean               matchFound  = FALSE;
    IfxPcieDevice_CfgHdr *cfgHdr      = NULL_PTR;
    uint8                 numDevices  = 0x0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        numDevices = rcHandle->numEndPoints;
    }
    else if (devType == IfxPcieDevice_Type_bridge)
    {
        numDevices = rcHandle->numBridges;
    }

    for (deviceIndex = 0; deviceIndex < numDevices; deviceIndex++)
    {
        if (devType == IfxPcieDevice_Type_endpoint)
        {
            cfgHdr = (IfxPcieDevice_CfgHdr *)(rcHandle->endPoint[deviceIndex].epFunction.cfgHeader);
        }
        else if (devType == IfxPcieDevice_Type_bridge)
        {
            cfgHdr = (IfxPcieDevice_CfgHdr *)(rcHandle->bridge[deviceIndex].bridgeFunction.cfgHeader);
        }

        if ((cfgHdr->type0.deviceId == deviceId)                                            /* Find a match */
            && (cfgHdr->type0.vendorId == vendorId))
        {
            if (matchFound == FALSE)
            {
                matchFound  = TRUE;
                chosenIndex = deviceIndex;
            }
            else
            {
                chosenIndex = 0xFFu;                                                        /* Duplicate entries */
                break;
            }
        }
    }

    return chosenIndex;
}


uint8 IfxPcie_Rc_getNumMemRegions(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type devType)
{
    uint8 numMemReg = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        if (devIndex < rcHandle->numEndPoints)
        {
            numMemReg = rcHandle->endPoint[devIndex].numMemRegions;
        }
    }
    else
    {
        if (devIndex < rcHandle->numBridges)
        {
            numMemReg = rcHandle->bridge[devIndex].numMemRegions;
        }
    }

    return numMemReg;
}


uint64 IfxPcie_Rc_getMemRegionSize(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcieDevice_Type devType)
{
    uint64                 memSize = 0u;
    IfxPcieLib_Device_Mem *memHandle;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        if (memIndex < rcHandle->endPoint[devIndex].numMemRegions)
        {
            memHandle = &(rcHandle->endPoint[devIndex].memRegion[memIndex].functionMem);
            memSize   = (memHandle->size);
        }
    }
    else
    {
        if (memIndex < rcHandle->bridge[devIndex].numMemRegions)
        {
            memHandle = &(rcHandle->bridge[devIndex].memRegion[memIndex].functionMem);
            memSize   = (memHandle->size);
        }
    }

    return memSize;
}


uint64 IfxPcie_Rc_getBarMemRegionSize(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 barIndex, IfxPcieDevice_Type devType)
{
    uint64          memSize     = 0x0u;
    IfxPcie_Rc_Mem *memHandle   = NULL_PTR;
    uint8           numMem      = 0u;
    uint8           regionIndex = 0u;

    if (devType == IfxPcieDevice_Type_endpoint)
    {
        memHandle = &(rcHandle->endPoint[devIndex].memRegion[0]);
        numMem    = rcHandle->endPoint[devIndex].numMemRegions;
    }
    else
    {
        memHandle = &(rcHandle->bridge[devIndex].memRegion[0]);
        numMem    = rcHandle->bridge[devIndex].numMemRegions;
    }

    for (regionIndex = 0; regionIndex < numMem; regionIndex++)
    {
        if (memHandle->functionMem.barIndex == barIndex)
        {
            memSize = (memHandle->functionMem.size);
            break;
        }

        memHandle++;
    }

    return memSize;
}


IfxPcie_Status IfxPcie_Rc_configureInBoundAtu(IfxPcie_Rc *rcHandle, uint64 wireMemBase, uint32 localMemBase, uint32 size, IfxPcie_AtuRegion region)
{
    IfxPcie_Status                 status    = IfxPcie_Status_failure;
    IfxPcieLib_Device_AtuRegionCfg atuRegionCfg;
    IfxPcieLib_Device_AtuRegion   *atuRegion = &(rcHandle->atu.inboundRegion[region]);

    if ((region != IfxPcie_AtuRegion_none)                                                          /* Valid ATU Region */
        && (atuRegion->enabled == FALSE))                                                           /* Region is not already initialized */
    {
        atuRegionCfg.regionIndex               = region;
        atuRegionCfg.direction                 = IfxPcie_AtuDirection_inBound;
        atuRegionCfg.barMapped                 = FALSE;
        atuRegionCfg.localMemBase              = localMemBase;
        atuRegionCfg.wireMemBase               = wireMemBase;
        atuRegionCfg.memSize                   = size;
        atuRegionCfg.inboundTlp.tlpHeader.type = IfxPcie_TlpType_memRequest;
        atuRegionCfg.enable                    = TRUE;

        IfxPcieLib_Device_initAtuRegion((IfxPcie *)(rcHandle->pcieSFR), atuRegion, &atuRegionCfg);  /* Initialize the Region */

        status = IfxPcie_Status_success;
    }

    return status;
}


void *IfxPcie_Rc_getCapabilityPtr(IfxPcie_Rc *rcHandle, uint16 capId, boolean extendedCap)
{
    IfxPcieLib_Cap *capabilitiesPtr = &(rcHandle->rootComplex.capabilities);
    void           *returnPtr       = NULL_PTR;

    if (extendedCap == FALSE)
    {
        switch (capId)
        {
        case IFXPCIECAP_PCI_CAP_ID_MSI:
            returnPtr = (void *)capabilitiesPtr->msi.capPtr;
            break;
        case IFXPCIECAP_PCI_CAP_ID_MSIX:
            returnPtr = (void *)capabilitiesPtr->msix.capPtr;
            break;
        case IFXPCIECAP_PCI_CAP_ID_PCIE:
            returnPtr = (void *)capabilitiesPtr->pcie.capPtr;
            break;
        case IFXPCIECAP_PCI_CAP_ID_PM:
            returnPtr = (void *)capabilitiesPtr->pmc.capPtr;
            break;
        default:
            break;
        }
    }
    else
    {
        switch (capId)
        {
        case IFXPCIECAP_EXTENDED_CAP_ID_AER:
            returnPtr = (void *)capabilitiesPtr->extendedCap.aer.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_PTM:
            returnPtr = (void *)capabilitiesPtr->extendedCap.ptm.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_LTR:
            returnPtr = (void *)capabilitiesPtr->extendedCap.ltr.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_SN:
            returnPtr = (void *)capabilitiesPtr->extendedCap.sn.capPtr;
            break;
        case IFXPCIECAP_EXTENDED_CAP_ID_VSEC:
            returnPtr = (void *)(capabilitiesPtr->extendedCap.vsec[0].capPtr);      /* We can't handle VSEC here - this is specific to each vendor so we return the first */
            break;
        default:
            break;
        }
    }

    return returnPtr;
}


void *IfxPcie_Rc_getDeviceCapabilityPtr(IfxPcie_Rc *rcHandle, uint8 devIndex, uint16 capId, boolean extendedCap, IfxPcieDevice_Type devType)
{
    uint8           numDevices      = (devType == IfxPcieDevice_Type_endpoint) ? rcHandle->numEndPoints : rcHandle->numBridges;
    IfxPcieLib_Cap *capabilitiesPtr = NULL_PTR;
    void           *returnPtr       = NULL_PTR;

    if (devIndex < numDevices)
    {
        if (devType == IfxPcieDevice_Type_endpoint)
        {
            capabilitiesPtr = &(rcHandle->endPoint[devIndex].epFunction.capabilities);
        }
        else if (devType == IfxPcieDevice_Type_bridge)
        {
            capabilitiesPtr = &(rcHandle->bridge[devIndex].bridgeFunction.capabilities);
        }
    }

    if (capabilitiesPtr != NULL_PTR)
    {
        if (extendedCap == FALSE)
        {
            switch (capId)
            {
            case IFXPCIECAP_PCI_CAP_ID_MSI:
                returnPtr = (void *)capabilitiesPtr->msi.capPtr;
                break;
            case IFXPCIECAP_PCI_CAP_ID_MSIX:
                returnPtr = (void *)capabilitiesPtr->msix.capPtr;
                break;
            case IFXPCIECAP_PCI_CAP_ID_PCIE:
                returnPtr = (void *)capabilitiesPtr->pcie.capPtr;
                break;
            case IFXPCIECAP_PCI_CAP_ID_PM:
                returnPtr = (void *)capabilitiesPtr->pmc.capPtr;
                break;
            default:
                break;
            }
        }
        else
        {
            switch (capId)
            {
            case IFXPCIECAP_EXTENDED_CAP_ID_AER:
                returnPtr = (void *)capabilitiesPtr->extendedCap.aer.capPtr;
                break;
            case IFXPCIECAP_EXTENDED_CAP_ID_PTM:
                returnPtr = (void *)capabilitiesPtr->extendedCap.ptm.capPtr;
                break;
            case IFXPCIECAP_EXTENDED_CAP_ID_LTR:
                returnPtr = (void *)capabilitiesPtr->extendedCap.ltr.capPtr;
                break;
            case IFXPCIECAP_EXTENDED_CAP_ID_SN:
                returnPtr = (void *)capabilitiesPtr->extendedCap.sn.capPtr;
                break;
            case IFXPCIECAP_EXTENDED_CAP_ID_VSEC:
                returnPtr = (void *)(capabilitiesPtr->extendedCap.vsec[0].capPtr);      /* We can't handle VSEC here - this is specific to each vendor so we return the first */
                break;
            default:
                break;
            }
        }
    }

    return returnPtr;
}


void IfxPcie_Rc_triggerHotReset(IfxPcie_Rc *rcHandle)
{
    rcHandle->pcieSFR->LNK.CORECTRL.B.HOTRST = 1u;
}


IfxPcieCap_PmPwrState IfxPcie_Rc_getDevicePowerState(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type devType)
{
    IfxPcieCap_PmPwrState pwrState        = IfxPcieCap_PmPwrState_none;
    IfxPcieLib_Cap       *capabilitiesPtr = NULL_PTR;
    uint8                 numDevices      = (devType == IfxPcieDevice_Type_endpoint) ? rcHandle->numEndPoints : rcHandle->numBridges;

    if (devIndex < numDevices)
    {
        if (devType == IfxPcieDevice_Type_endpoint)
        {
            capabilitiesPtr = &(rcHandle->endPoint[devIndex].epFunction.capabilities);
        }
        else if (devType == IfxPcieDevice_Type_bridge)
        {
            capabilitiesPtr = &(rcHandle->bridge[devIndex].bridgeFunction.capabilities);
        }

        if (capabilitiesPtr != NULL_PTR)
        {
            if (capabilitiesPtr->pmc.capPtr != NULL_PTR)
            {
                pwrState = IfxPcieCap_getPwrState(capabilitiesPtr->pmc.capPtr);
            }
        }
    }

    return pwrState;
}


IfxPcie_Status IfxPcie_Rc_setDevicePowerState(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieCap_PmPwrState pwrState, IfxPcieDevice_Type devType)
{
    IfxPcie_Status  status          = IfxPcie_Status_failure;
    boolean         stateSupport    = TRUE;
    uint8           numDevices      = (devType == IfxPcieDevice_Type_endpoint) ? rcHandle->numEndPoints : rcHandle->numBridges;
    IfxPcieLib_Cap *capabilitiesPtr = NULL_PTR;

    if (devIndex < numDevices)
    {
        if (devType == IfxPcieDevice_Type_endpoint)
        {
            capabilitiesPtr = &(rcHandle->endPoint[devIndex].epFunction.capabilities);
        }
        else if (devType == IfxPcieDevice_Type_bridge)
        {
            capabilitiesPtr = &(rcHandle->bridge[devIndex].bridgeFunction.capabilities);
        }

        if (capabilitiesPtr != NULL_PTR)
        {
            if (capabilitiesPtr->pmc.capPtr != NULL_PTR)
            {
                if ((pwrState > IfxPcieCap_PmPwrState_d0)
                    && (pwrState < IfxPcieCap_PmPwrState_d3Hot))        /* Device requested for optional states */
                {
                    stateSupport = IfxPcieCap_isPwrStateSupported(capabilitiesPtr->pmc.capPtr, pwrState);
                }

                if (stateSupport == TRUE)
                {
                    IfxPcieCap_setPwrState(capabilitiesPtr->pmc.capPtr, pwrState);
                    status = IfxPcie_Status_success;
                }
            }
        }
    }

    return status;
}
