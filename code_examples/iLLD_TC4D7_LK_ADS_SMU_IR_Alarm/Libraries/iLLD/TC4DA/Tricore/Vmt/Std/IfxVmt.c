/**
 * \file IfxVmt.c
 * \brief VMT  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxVmt.h"

/******************************************************************************/
/*----------------------------------Macros------------------------------------*/
/******************************************************************************/

#define IFXVMT_CLEAR_SRAM_MCONTROL_CONFIG (0x4000 | (1U << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF))

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxVmt_clearErrorTracking(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc          = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    mc->ECCD.U |= (1 << IFX_VMT_MC_ECCD_TRC_OFF);
}


void IfxVmt_clearSram(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT *dmtuAddress = IfxVmt_getDmtuAddress(mbistSel);

    if (dmtuAddress->CLC.B.DISS == 1)
    {
        IfxVmt_enableModule(dmtuAddress);
    }

    IfxVmt_clearSramStart(mbistSel);

    /* wait for the end of the fill operation */

    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }

    IfxVmt_clearSramContinue(mbistSel);
}


void IfxVmt_clearSramContinue(IfxVmt_MbistSel mbistSel)
{
    /* Before clearing the ECC error flags we've to issue a dummy SRAM access to get a valid memory output */
    IfxVmt_readSramAddress(mbistSel, 0x0000);
    /* Note: a SMU alarm will be flagged HERE if the wrong ECC has been written! */
    IfxVmt_disableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}
}


void IfxVmt_clearSramStart(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* start init operation */
    uint16 mcontrolMask = 0x4000;                                                                                   /* set USERED flag */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF); /* START = SRAM_CLR = 1 */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF);
}


void IfxVmt_enableErrorTracking(IfxVmt_MbistSel mbistSel, boolean enable)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    if (enable == FALSE)
    {
        mc->ECCS.U &= ~(1 << IFX_VMT_MC_ECCS_TRE_OFF);
    }
    else
    {
        mc->ECCS.U |= (1 << IFX_VMT_MC_ECCS_TRE_OFF);
    }
}


uint8 IfxVmt_getTrackedSramAddresses(IfxVmt_MbistSel mbistSel, Ifx_VMT_MC_ETRR *trackedSramAddresses)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    uint8       validFlags          = (mc->ECCD.U >> IFX_VMT_MC_ECCD_VAL_OFF) & IFX_VMT_MC_ECCD_VAL_MSK;
    uint8       numTrackedAddresses = 0;

    if (validFlags)
    {
        trackedSramAddresses[numTrackedAddresses].U = mc->ETRR.U;
        ++numTrackedAddresses;
    }

    return numTrackedAddresses;
}


void IfxVmt_readSramAddress(IfxVmt_MbistSel mbistSel, uint16 sramAddress)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    /* configure MBIST for single read opeation */
    uint16      mcontrolMask = 0x4000;                                                               /* set USERED flag */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);
    mc->CONFIG0.U  = (1 << IFX_VMT_MC_CONFIG0_NUMACCS_OFF) | (1 << IFX_VMT_MC_CONFIG0_ACCSTYPE_OFF); /* 1 read access */
    /* ensure that linear scrambling is used */

    mc->CONFIG1.U = 0;                                                                               /* ensure that linear scrambling is used */

    /* Set the address to be read (RAEN = 0) */
    mc->RANGE.U = sramAddress;

    /* Start operation */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF);
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);

    /* wait for the end of the fill operation */
    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }
}


uint8 IfxVmt_runCheckerBoardTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr, uint32 numberRedundancyLines)
{
    /* Select MBIST Memory Controller:
     * Ifx_MC is a type describing structure of MBIST Memory Controller
     * registers defined in IfxMc_regdef.h file - MC object */
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    uint32      configCheckerBoardSequence[4] = {
        0x00001000, //up /lin/w0
        0x00001001, //up /lin/r0
        0x00011000, //down/lin/w1
        0x00011001  //down/lin/r1
    };

    uint8       retVal = 0U;
    uint8       testStep;

    /* Enable MBIST Memory Controller */
    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* Set the range register */
    mc->RANGE.U = (rangeSel << 15) | (rangeAddrUp << 7) | (rangeAddrLow << 0);

    /* Run the test */
    for (testStep = 0; testStep < 4; ++testStep)
    {
        mc->CONFIG0.U = configCheckerBoardSequence[testStep] & 0x0000FFFF;
        mc->CONFIG1.U = (configCheckerBoardSequence[testStep] & 0xFFFF0000) >> 16;

        if (testStep < 2)
        {
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c9 : 0x00c9; // bit and row toggle
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c8 : 0x00c8; // MCONTROL.B.START will generate a RMW which is too long for small SRAMs!
        }
        else
        {
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c1 : 0x00c1; // bit and row toggle
            mc->MCONTROL.U = numberRedundancyLines ? 0x40c0 : 0x00c0; // MCONTROL.B.START will generate a RMW which is too long for small SRAMs!
        }

        /* wait for the end of the fill operation */

        while (!IfxVmt_isMbistDone(mbistSel))
        {
            __nop();
        }

        /* Check the Fail Status */
        if (mc->MSTATUS.B.FAIL)
        {
            /* Read Error tracking register if FAILDMP is set*/
            if (mc->MCONTROL.B.FAILDMP)
            {
                *errorAddr = (uint16)mc->ETRR.U;
            }

            /* Return as failed */
            retVal = 1U;
            break;
        }
    }

    /* Disable Memory Controller */

    IfxVmt_disableMbistShell(mbistSel);

    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    return retVal;
}


uint8 IfxVmt_runMarchUTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr)
{
    /* Select MBIST Memory Controller:
     * Ifx_MC is a type describing structure of MBIST Memory Controller
     * registers defined in IfxMc_regdef.h file - MC object */
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    uint32      configMarchUSequence[6] = {
        0x08001000, //up /lin/w0
        0x08064005, //up /lin/r0->w1->r1->w0
        0x08022001, //up /lin/r0->w1
        0x00094005, //down/lin/r1->w0->r0->w1
        0x00012001, //down/lin/r1->w0
        0x00001001
    };              //down/lin/r0

    uint8       retVal = 0U;
    uint8       testStep;

    /* Enable MBIST Memory Controller */
    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* Set the range register */
    mc->RANGE.U = (rangeSel << 15) | (rangeAddrUp << 7) | (rangeAddrLow << 0);

    /* Run the test */
    for (testStep = 0; testStep < 6; ++testStep)
    {
        mc->CONFIG0.U        = configMarchUSequence[testStep] & 0x0000FFFF;
        mc->CONFIG1.U        = (configMarchUSequence[testStep] & 0xFFFF0000) >> 16;
        mc->MCONTROL.U       = 0x4209;
        mc->MCONTROL.B.START = 0;

        /* wait for the end of the fill operation */

        while (!IfxVmt_isMbistDone(mbistSel))
        {
            __nop();
        }

        /* Check the Fail Status */
        if (mc->MSTATUS.B.FAIL)
        {
            /* Test has failed, check if any un-correctable error */
            if (mc->ECCD.B.UCERR)
            {
                /* Read Error tracking register and return saying test failed */
                *errorAddr = (uint16)mc->ETRR.U;
                retVal     = 1U;
                break;
            }
        }
    }

    /* Disable Memory Controller */
    IfxVmt_disableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    return retVal;
}


uint8 IfxVmt_runNonDestructiveInversionTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr)
{
    /* Select MBIST Memory Controller:
     * Ifx_MC is a type describing structure of MBIST Memory Controller
     * registers defined in IfxMc_regdef.h file - MC object */
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    uint8       retVal = 0U;

    /* Enable MBIST Memory Controller */
    IfxVmt_enableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    /* Configure Non-destructive Inversion test */
    mc->CONFIG0.U        = 0x5015; //NUMACCS=5, ACCSTYPE=15
    mc->CONFIG1.U        = 0x5018; //AG_MOD=5
    /* Set the range register */
    mc->RANGE.U          = (rangeSel << 15) | (rangeAddrUp << 7) | (rangeAddrLow << 0);
    /* Run the tests */
    mc->MCONTROL.U       = 0x4009;
    mc->MCONTROL.B.START = 0;

    /* wait for the end of the fill operation */

    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }

    /* Check the Fail Status */
    if (IfxVmt_checkErrorFlags(mbistSel))
    {
        /* Read the Error tracking register and return saying test failed */
        *errorAddr = (uint16)mc->ETRR.U;
        retVal     = 1U;
    }

    /* Disable Memory Controller */
    IfxVmt_disableMbistShell(mbistSel);

    /* for auto-init memories: wait for the end of the clear operation */
    while (IfxVmt_isAutoInitRunning(mbistSel))
    {}

    return retVal;
}


void IfxVmt_writeSramAddress(IfxVmt_MbistSel mbistSel, uint16 sramAddress)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    /* configure MBIST for single write opeation */
    uint16      mcontrolMask = 0x4000;                                                               /* set USERED flag */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);
    mc->CONFIG0.U  = (1 << IFX_VMT_MC_CONFIG0_NUMACCS_OFF) | (0 << IFX_VMT_MC_CONFIG0_ACCSTYPE_OFF); /* 1 write access */
    /* ensure that linear scrambling is used */

    mc->CONFIG1.U = 0;                                                                               /* ensure that linear scrambling is used */

    /* Set the address to be written (RAEN = 0) */
    mc->RANGE.U = sramAddress;

    /* Start operation */
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF);
    mc->MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);

    /* Wait for the end of the operation */

    while (!IfxVmt_isMbistDone(mbistSel))
    {
        __nop();
    }
}


void IfxVmt_configureAccessToVmts(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    for (index = 0; index < IFXVMT_NUM_DMTU; index++)
    {
        /* Loop through all the instance */
        Ifx_VMT *vmt = (Ifx_VMT *)(((uint32)&MODULE_VMT0) + index * ((uint32)&MODULE_VMT1 - (uint32)&MODULE_VMT0));
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&vmt->ACCENNOM, apConfig);
    }
}


sint8 IfxVmt_K1Check(IfxVmt_K1CheckFailIdInfo *k1Check)
{
    uint8 i;
    sint8 errorStatus = 0;

#ifdef IFXVMT_DEBUG_FAILID_UCB

    /* Look up the FAILID structure in NVM to find the last entry */
    for (i = 0; i < IFXVMT_DATA_FAILID_ENTRY_NUMBER; i++)
    {
        k1Check->lastentryAddr = IfxFlash_dFlashTableUcbLog[IFXVMT_UCB_LOG_SECTOR].start + (IFXVMT_DATA_FAILID_ENTRY_NUMBER - 1 - i) * IFXVMT_ONE_FAILID_SIZE;
        k1Check->lastentryData = (IfxVmt_FailIdStructure *)k1Check->lastentryAddr;

        if (k1Check->lastentryData->header->vflag == IFXVMT_VALID_FLAG) /* found */
        {
            /* last entry number is IFXVMT_DATA_FAILID_ENTRY_NUMBER - 1 - i */
            k1Check->lastFailIdEntryNr = IFXVMT_DATA_FAILID_ENTRY_NUMBER - 1 - i;
            break;
        }
    }

#endif

    k1Check->lastentryData = (IfxVmt_FailIdStructure *)k1Check->lastentryAddr;
    k1Check->backupData    = (IfxVmt_FailIdStructure *)k1Check->backupAddr;

    /* found last valid entry, check (SAL, VFLAG, num_sbe, num_ble) */

    if (k1Check->lastFailIdEntryNr != 0xFF)
    {
        /* Load data from NVM (UCB0_15), data Length is IFXVMT_NVM_FAILID_WORD_SIZE bytes */

        uint32 *dataFrom = (uint32 *)(k1Check->lastentryAddr);
        uint32 *dataTo   = (uint32 *)(k1Check->backupAddr);

        for (i = 0; i <= IFXVMT_FAILID_WORD_SIZE; i++)
        {
            dataTo[i] = dataFrom[i];
        }

        /* check SAL */

        if (k1Check->backupData->header->sal != k1Check->lastentryAddr)
        {
            return -1; /* user has to configure to safe state */
        }

        /* check CRC */

        if (k1Check->backupData->crc != IfxCpu_calculateCrc32((uint32 *)k1Check->backupAddr, IFXVMT_NUM_WORD_DATA_CRC))
        {
            return -1; /* user has to configure to safe state */
        }

        k1Check->sbeCount = 0;
        k1Check->bleCount = 0;

        for (i = 0; i < IFXVMT_DATA_FAILID_MAX; i++)
        {
            k1Check->bleCount += k1Check->backupData->data[i].numBLE;
            k1Check->sbeCount += k1Check->backupData->data[i].numSBE;
        }

        if ((k1Check->sbeCount > IFXVMT_MSBE) & (k1Check->bleCount > IFXVMT_MBLE))
        {
            return -1; /* user has to configure to safe state */
        }

        else if (k1Check->sbeCount > IFXVMT_MSBE)
        {
            return -1; /* user has to configure to safe state */
        }

        else if (k1Check->bleCount > IFXVMT_MBLE)
        {
            return -1; /* user has to configure to safe state */
        }
    }

    /* no valid entry found */

    else
    {
        /* It should not happen, one FAILID structure should be initialized in NVM */
        errorStatus = 1;
    }

    return errorStatus;
}


sint8 IfxVmt_KxTest(const IfxVmt_SshSelectionConfig *mbistConfig, uint8 numOfSshConfig, uint32 failIdAddr, uint8 *failIdLength, uint8 *ucerrCount)
{
    uint8                      count, ramCount = (*failIdLength);
    sint8                      result = 0;
    Ifx_VMT_MC                *mc;
    IfxVmt_SshSelectionConfig *failId = (IfxVmt_SshSelectionConfig *)failIdAddr;

    for (count = 0; count < numOfSshConfig; count++)
    {
        /*Set MEMTESTx registers for each SSH */
        IfxVmt_enableMbistShell(mbistConfig[count].mc);

        /* for auto-init memories: wait for the end of the clear operation */
        while (IfxVmt_isAutoInitRunning(mbistConfig[count].mc))
        {}

        mc             = IfxVmt_getDmtuMcInstancePtr(mbistConfig[count].mc);

        mc->CONFIG0.U  = 0x400A;
        mc->CONFIG1.U  = 0x0003;

        mc->MCONTROL.U = 0x1;           /* start Test */

        while (mc->MSTATUS.B.DONE != 0) /* check for MSTATUS.DONE == 0 */
        {}

        mc->MCONTROL.U = 0x0;           /* stop Test */
    }

    /* wait for finish of MBIST of all instances */
    for (count = 0; count < numOfSshConfig; count++)
    {
        while (!IfxVmt_isMbistDone(mbistConfig[count].mc))
        {
            __nop();
        }
    }

    /* Loop through all SSHs in G1/G2, check for UCE/CE error */

    for (count = 0; count < numOfSshConfig; count++)
    {
        mc = IfxVmt_getDmtuMcInstancePtr(mbistConfig[count].mc);

        /*If UCE error, first time increment q and redo MTEST. If no UCE error go next step */

        if (mc->ECCD.B.UCERR == 1)
        {
            if (*ucerrCount == 0)
            {
                (*ucerrCount)++;
                return 0;   /* User has to trigger additional cycle with reset */
            }
            else
            {
                return -1; /* trigger transition to safe state */
            }
        }

        /*If CE error, log the VMT and SSH info in FAIL ID  */

        if (mc->ECCD.B.CERR == 1)
        {
            /* store fail id */
            failId[ramCount] = mbistConfig[count];
            ramCount++;
        }

        (*failIdLength) = ramCount;
    }

    return result;
}


void IfxVmt_KxInit(const IfxVmt_SshSelectionConfig *mbistConfig, uint8 numOfSshConfig)
{
    uint8       count = 0;
    Ifx_VMT_MC *mc;

    /* Get the dMTU pointer for the SSH */
    for (count = 0; count < numOfSshConfig; count++)
    {
        mc = IfxVmt_getDmtuMcInstancePtr(mbistConfig[count].mc);

        /* SRAM_CLR and START */
        mc->MCONTROL.U = 0x8001;

        /* check for MSTATUS.DONE == 0 */
        while (mc->MSTATUS.B.DONE != 0)
        {}

        /* clear start bit */
        mc->MCONTROL.U = 0x8000;
    }

    /* wait for finish of MBIST of all instances */
    for (count = 0; count < numOfSshConfig; count++)
    {
        while (!IfxVmt_isMbistDone(mbistConfig[count].mc))
        {
            __nop();
        }
    }

    /* Disable MEMTEST for each SSH */
    for (count = 0; count < numOfSshConfig; count++)
    {
        IfxVmt_disableMbistShell(mbistConfig[count].mc);

        /* for auto-init memories: wait for the end of the clear operation */
        while (IfxVmt_isAutoInitRunning(mbistConfig[count].mc))
        {}
    }
}


uint32 IfxVmt_K3PrepareExtractStore(const IfxVmt_SramInfo **sramInfo, IfxVmt_K3PhaseInputs *k3PhaseInputs)
{
    uint8                      result = 0, count = 0, i = 0, fdaCount = 0, maxFD = IFXVMT_MAXFAILDMPS;
    Ifx_VMT                   *dmtu;
    Ifx_VMT_MC                *dmtuInstance;

    IfxVmt_SshSelectionConfig *failId        = (IfxVmt_SshSelectionConfig *)k3PhaseInputs->failIdAddr;
    IfxVmt_FailIdStructure    *currentWrData = (IfxVmt_FailIdStructure *)k3PhaseInputs->failIdStoreAddr;
    currentWrData->header->sal = k3PhaseInputs->failIdStoreAddr;

    IfxVmt_FailIdData          tmpData;

    uint16                     rdbfl[37];
    uint32                     failPosition[IFXVMT_MAXFAILDMPS];
    uint16                     failMarker[IFXVMT_MAXFAILDMPS];

    uint32                     failPositionTmp;
    uint16                     failMarkerTmp;

    if ((*(k3PhaseInputs->failIdLength)) == 0)
    {
        /*Selected RAMs have no fail - omitting bitmap extraction.*/
        return result;
    }

    /* Enable MBIST controller */

    for (count = 0; count < (*(k3PhaseInputs->failIdLength)); count++)
    {
        if (k3PhaseInputs->excludeIncludeSwitch == 1)       /* all but one single instance */
        {
            if ((failId[count].vmtId == k3PhaseInputs->excludeIncludeInstance.vmtId) && (failId[count].mc == k3PhaseInputs->excludeIncludeInstance.mc))
            {
                continue;
            }
        }

        if (k3PhaseInputs->excludeIncludeSwitch == 2)       /* only one single instance */
        {
            if (!((failId[count].vmtId == k3PhaseInputs->excludeIncludeInstance.vmtId) && (failId[count].mc == k3PhaseInputs->excludeIncludeInstance.mc)))
            {
                continue;
            }
        }

        /* anything besides will run test on all failid instances */

        dmtu = IfxVmt_getDmtuAddress(failId[count].mc);

        if (IfxVmt_isModuleEnabled(dmtu) == 0)
        {
            IfxVmt_enableModule(dmtu);                  /* Enable VMT module */
        }

        /*Set MEMTESTx registers for each SSH cell configured*/
        IfxVmt_enableMbistShell(failId[count].mc);

        /* for auto-init memories: wait for the end of the clear operation */
        while (IfxVmt_isAutoInitRunning(failId[count].mc))
        {}

        /* Clear ECCD and FAULTSTS Registers */
        dmtu->MC->ECCD.U     = 0x10U;
        dmtu->MC->FAULTSTS.U = 0U;
        dmtu->MC->ALMSRCS.U  = 0x0;
    }

    /* Destructive Test */

    for (count = 0; count < (*(k3PhaseInputs->failIdLength)); count++)
    {
        /* all but one single instance */
        if (k3PhaseInputs->excludeIncludeSwitch == 1)
        {
            if ((failId[count].vmtId == k3PhaseInputs->excludeIncludeInstance.vmtId) && (failId[count].mc == k3PhaseInputs->excludeIncludeInstance.mc))
            {
                continue;
            }
        }

        /* only one single instance */
        if (k3PhaseInputs->excludeIncludeSwitch == 2)
        {
            if (!((failId[count].vmtId == k3PhaseInputs->excludeIncludeInstance.vmtId) && (failId[count].mc == k3PhaseInputs->excludeIncludeInstance.mc)))
            {
                continue;
            }
        }

        /* anything besides will run test on all failid instances */

        fdaCount                = 0;
        dmtuInstance            = IfxVmt_getDmtuMcInstancePtr(failId[count].mc);

        dmtuInstance->CONFIG0.U = 0x400A;
        dmtuInstance->CONFIG1.U = 0x0003;

        /* Start Test */
        dmtuInstance->MCONTROL.U       = 0x0201;

        dmtuInstance->ECCD.B.UCERR     = 0;
        dmtuInstance->FAULTSTS.B.OPERR = 0;

        /* stop */
        dmtuInstance->MCONTROL.U = 0x0200;

        do  /* wait for finish */

        {
            if ((dmtuInstance->MSTATUS.B.FDA) == 1)
            {
                /* readout of RDBFL */

                for (i = 0; i < sramInfo[(uint32)(failId[count].vmtId)][(uint32)failId[count].mc].rdbflNum; i++) /* number of rdbfl in rdbfl list */
                {
                    rdbfl[i] = dmtuInstance->RDBFL[i].B.WDATA;
                }

                /* K3 extract during FDA collection */

                /* initialise  fail pos and marker */

                failPositionTmp = 0;
                failMarkerTmp   = 0;

                /* calculate fail_pos and assign fail marker with SBEs on concerned locations */
                IfxVmt_getFailPostion(rdbfl, sramInfo[failId[count].vmtId][failId[count].mc].numOfTower,
                    sramInfo[failId[count].vmtId][failId[count].mc].towerWidth, &failPositionTmp, &failMarkerTmp);

                failPosition[fdaCount] = failPositionTmp;
                failMarker[fdaCount]   = failMarkerTmp;

                fdaCount++;

                if (fdaCount < maxFD)
                {
                    dmtuInstance->MCONTROL.B.RESUME = 0x1;
                }

                else
                {
                    dmtuInstance->MCONTROL.U = 0x0002;
                }
            }
        } while (dmtuInstance->MSTATUS.B.DONE == 0);

        /* K3 extract */
        IfxVmt_SshSelectionConfig sshLocal;
        tmpData.sshConfig        = &sshLocal;
        tmpData.sshConfig->vmtId = failId[count].vmtId;
        tmpData.sshConfig->mc    = failId[count].mc;

        uint16 tower, compare, i, j, count = 0, alreadyIn;

        for (tower = 0; tower < sramInfo[failId[count].vmtId][failId[count].mc].numOfTower; tower++)
        {
            compare = 0;

            for (i = 0; i < fdaCount; i++)
            {
                if (((failPosition[i] >> (8 * tower)) & 0xFF) == 0) /* If no fail skip loop */
                {
                    continue;
                }

                if (compare == ((failPosition[i] >> (8 * tower)) & 0xFF))   /* If compare equals subsequent fail_pos skip loop */
                {
                    continue;
                }

                if (((failMarker[i] >> (2 * tower)) & 0x3) == 2) /* If BLE error was found for this fail skip loop */
                {
                    continue;
                }

                compare = ((failPosition[i] >> (8 * tower)) & 0xFF);
                count   = 0;

                for (j = 0; j < fdaCount; j++)
                {
                    if (j == i)
                    {
                        continue;
                    }

                    if (compare == ((failPosition[i] >> (8 * tower)) & 0xFF))
                    {
                        count++;
                    }
                }

                if (count >= 3)                        /* If more or equal than 3 fails within one bitline oriented position, count those as BLE */
                {
                    failMarker[i] ^= 1 << (2 * tower); /* Delete former SBE */
                    failMarker[i] |= 2 << (2 * tower); /* BLE */

                    for (j = 0; j < fdaCount; j++)
                    {
                        if (j == i)
                        {
                            continue;
                        }

                        if (compare == ((failPosition[j] >> (8 * tower)) & 0xFF))
                        {
                            failMarker[j] ^= 1 << (2 * tower);      /* Delete former SBE */
                            failMarker[j] |= 2 << (2 * tower);      /* BLE */
                        }
                    }
                }
            }
        }

        /* K3 Store */

        tmpData.numSBE = 0;
        tmpData.numBLE = 0;

        for (tower = 0; tower < sramInfo[failId[count].vmtId][failId[count].mc].numOfTower; tower++)
        {
            for (i = 0; i < fdaCount; i++)
            {
                if (((failMarker[i] >> (2 * tower)) & 0x3) == 1)
                {
                    tmpData.numSBE++;
                }
                else if (((failMarker[i] >> (2 * tower)) & 0x3) == 2)
                {
                    alreadyIn = 0;
                    compare   = ((failPosition[i] >> (8 * tower)) & 0xFF);

                    for (j = 0; j < i; j++)
                    {
                        if (compare == ((failPosition[j] >> (8 * tower)) & 0xFF))
                        {
                            alreadyIn = 1;
                            break;
                        }
                    }

                    if ((i == 0) || (alreadyIn != 1))
                    {
                        tmpData.numBLE++;
                    }
                }
            }
        }

        currentWrData->data[*(k3PhaseInputs->currentFailidIndex)].sshConfig->vmtId = tmpData.sshConfig->vmtId;
        currentWrData->data[*(k3PhaseInputs->currentFailidIndex)].sshConfig->mc    = tmpData.sshConfig->mc;
        currentWrData->data[*(k3PhaseInputs->currentFailidIndex)].numSBE           = tmpData.numSBE;
        currentWrData->data[*(k3PhaseInputs->currentFailidIndex)].numBLE           = tmpData.numBLE;
        (*(k3PhaseInputs->currentFailidIndex))++;
    }

    /* disable MBIST controller */
    for (count = 0; count < (*(k3PhaseInputs->failIdLength)); count++)
    {
        /* all but one single instance */
        if (k3PhaseInputs->excludeIncludeSwitch == 1)
        {
            if ((failId[count].vmtId == k3PhaseInputs->excludeIncludeInstance.vmtId) && (failId[count].mc == k3PhaseInputs->excludeIncludeInstance.mc))
            {
                continue;
            }
        }

        /* only one single instance */
        if (k3PhaseInputs->excludeIncludeSwitch == 2)
        {
            if (!((failId[count].vmtId == k3PhaseInputs->excludeIncludeInstance.vmtId) && (failId[count].mc == k3PhaseInputs->excludeIncludeInstance.mc)))
            {
                continue;
            }
        }

        /* Disable MEMTEST for each SSH */
        IfxVmt_disableMbistShell(failId[count].mc);

        /* for auto-init memories: wait for the end of the clear operation */
        while (IfxVmt_isAutoInitRunning(failId[count].mc))
        {}
    }

    return result;
}
