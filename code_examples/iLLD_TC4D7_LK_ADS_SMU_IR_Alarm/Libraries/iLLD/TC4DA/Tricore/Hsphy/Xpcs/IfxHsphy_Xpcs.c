/**
 * \file IfxHsphy_Xpcs.c
 * \brief HSPHY XPCS details
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxHsphy_Xpcs.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxHsphy_Xpcs_sgmiiDataPathInit(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_XpcsIndex xpcsIndex)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;

    //Initialize XPCS data path
    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 0;
    hsphyRegPtr->XPCS[xpcsIndex].PCS.SR_XS_CTRL1.B.LPM                               = 1; //power down the DWC_xpcs

    while (hsphyRegPtr->XPCS[xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerDown)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    hsphyRegPtr->XPCS[xpcsIndex].PCS.SR_XS_CTRL1.U &= (uint32)(~((1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_LPM_OFF) | (1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_RST_OFF)));      //power up the DWC_xpcs

    timeoutCycleCount                               = IFXHSPHY_MAX_TIMEOUT;

    while (hsphyRegPtr->XPCS[xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerGood)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 1;
    return (boolean)timeOutError;
}


boolean IfxHsphy_Xpcs_reset(Ifx_HSPHY *hsphyRegPtr, const IfxHsphy_GethXpcsParams *xpcs)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.DIG_CTRL1.B.VR_RST = 0;

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.DIG_CTRL1.B.VR_RST = 1;

    while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_SRAM.B.INIT_DN != 1)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_SRAM.B.EXT_LD_DN = 1;

    timeoutCycleCount                                                            = IFXHSPHY_MAX_TIMEOUT;

    while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL1.B.RST == 1)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return (boolean)timeOutError;
}


IfxHsphy_Geth_SgmiiSpeedConfigStatus IfxHsphy_Xpcs_setSgmiiSpeedMode(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_TrgtDeviceSpeed trgtSpeed, const IfxHsphy_GethXpcsParams *xpcs)
{
    uint32              timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8               timeOutError      = 0U;
    IfxHsphy_SgmiiSpeed sgmiiSpeed        = IfxHsphy_SgmiiSpeed_1G;
    boolean             relvalCheck;

    relvalCheck = IfxHsphy_sgmiiMpllDisable(hsphyRegPtr, xpcs->xpcsIndex);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    if ((trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G) || (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps) || (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_125mbps))
    {
        /* Set XPCS in 100M mode */
        if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G)
        {
            sgmiiSpeed = IfxHsphy_SgmiiSpeed_0P1G;
        }
        /* SGMII 100M 1.25gbps mode */
        else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps)
        {
            sgmiiSpeed = IfxHsphy_SgmiiSpeed_0P1G_1P25gbps;
        }
        /* SGMII 100M 125mbps mode */
        else
        {
            sgmiiSpeed = IfxHsphy_SgmiiSpeed_0P1G_125mbps;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL                  = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_10GBASE_X);

        if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps)
        {
            hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6  = 0;
            hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13 = 1;
        }

        if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_125mbps)
        {
            hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.DIG_CTRL1.B.EN_100M = 1;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 0;
    }
    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_1G)
    {
        //Set XPCS in 1G mode
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 1;
        sgmiiSpeed                                                                         = IfxHsphy_SgmiiSpeed_1G;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL                  = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_10GBASE_X);
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6                                  = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13                                 = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 0;
    }

    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_2P5G)
    {
        //Set XPCS in 2.5G mode
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 1;
        sgmiiSpeed                                                                         = IfxHsphy_SgmiiSpeed_2P5G;

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL                  = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_10GBASE_X);
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.EN_2_5G_MODE              = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6                                  = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13                                 = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 0;
    }

    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_5G)
    {
        //Set XPCS in 5G mode
        sgmiiSpeed                                                        = IfxHsphy_SgmiiSpeed_5G;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_2P5GBASE_X);
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.SR_CTRL1.B.SS13            = 0;
    }
    else
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_invalidConfigError;
    }

    //config the ref freq selected
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_REF_CLK_CTRL.B.REF_MPLLA_DIV2 = IfxHsphy_Sgmii_refClkConfig[xpcs->xpcsRefClk][IfxHsphy_SgmiiRefClkBits_refMpllaDiv2];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_REF_CLK_CTRL.B.REF_CLK_DIV2   = IfxHsphy_Sgmii_refClkConfig[xpcs->xpcsRefClk][IfxHsphy_SgmiiRefClkBits_refClKDiv2];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_REF_CLK_CTRL.B.REF_RANGE      = IfxHsphy_Sgmii_refClkConfig[xpcs->xpcsRefClk][IfxHsphy_SgmiiRefClkBits_refRange];

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST                           = 1;

    while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST != 0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL0.B.MPLLA_MULTIPLIER        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaMultiplier];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_TX_CLK_DIV        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaTxClkDiv];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_DIV16P5_CLK_EN    = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaDiv16P5ClkEnable];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_PROP                      = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_cpProp];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_INT                       = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_cpInt];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL7.B.CP_PROP_GS                   = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_cpPropGs];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_MPLLA_CTRL1.B.MPLLA_FRACN_CTRL            = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaFrancCtrl];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_VCO_CAL_LD0.B.VCO_LD_VAL_0        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_vcoLdVal_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_VCO_CAL_REF0.B.VCO_REF_LD_0               = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_vcoRefLd_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_MISC_CTRL2.B.SUP_MISC                 = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_supMisc];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_DIV16P5_CLK_EN_0 = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rxDiv16P5ClkEn_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_GENCTRL4.B.RX_125MHZ_CLK_EN_0      = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx125MhzClkEn_0];

    if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G)
    {
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_CDR_CTRL.B.CDR_TRACK_EN_0 = 0;
    }
    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps)
    {
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_CDR_CTRL.B.CDR_TRACK_EN_0 = 1;
    }
    else
    {
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_CDR_CTRL.B.CDR_TRACK_EN_0 = 0;
    }

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_RATE_CTRL.B.TX0_RATE    = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_tx0Rate];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_RATE_CTRL.B.RX0_RATE    = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx0Rate];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_MISC_CTRL0.B.RX0_MISC       = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx0Misc];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX0_WIDTH        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_tx0Width];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_RX_GENCTRL2.B.RX0_WIDTH        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx0Width];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_BOOST_CTRL.B.TX0_IBOOST = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_tx0Iboost];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.VBOOST_EN_0  = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_vBoostEn_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.AFE_EN_0         = 0;
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.DFE_EN_0         = 0;
    relvalCheck                                                                            = IfxHsphy_sgmiiMpllEnable(hsphyRegPtr, xpcs->xpcsIndex);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    relvalCheck = IfxHsphy_sgmiiXpcsDataPathInit(hsphyRegPtr, xpcs->xpcsIndex);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    return IfxHsphy_Geth_SgmiiSpeedConfigStatus_success;
}


boolean IfxHsphy_Xpcs_setUsxgmiiSpeedMode(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_TrgtDeviceSpeed trgtSpeed, const IfxHsphy_GethXpcsParams *xpcs)
{
    uint32                timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8                 timeOutError      = 0U;
    IfxHsphy_UsxgmiiSpeed usxgmiiSpeed      = (IfxHsphy_UsxgmiiSpeed)1;
    boolean               relvalCheck;

    if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_5G)
    {
        relvalCheck = IfxHsphy_sgmiiMpllDisable(hsphyRegPtr, xpcs->xpcsIndex); //need to change the func name specific to serial 100M

        if (relvalCheck == TRUE)
        {
            return TRUE;
        }

        usxgmiiSpeed                                                     = (IfxHsphy_UsxgmiiSpeed)0;

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.USXG_EN = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_KR_CTRL.B.USXG_MODE = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST  = 1;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST != 0)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        if (timeOutError == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL0.B.MPLLA_MULTIPLIER        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaMultiplier];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_TX_CLK_DIV        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaTxClkDiv];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_DIV16P5_CLK_EN    = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaDiv16P5ClkEnable];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_PROP                      = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_cpProp];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_INT                       = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_cpInt];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL7.B.CP_PROP_GS                   = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_cpPropGs];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_MPLLA_CTRL1.B.MPLLA_FRACN_CTRL            = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaFrancCtrl];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_VCO_CAL_LD0.B.VCO_LD_VAL_0        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_vcoLdVal_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_VCO_CAL_REF0.B.VCO_REF_LD_0               = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_vcoRefLd_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_MISC_CTRL2.B.SUP_MISC                 = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_supMisc];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_DIV16P5_CLK_EN_0 = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rxDiv16P5ClkEn_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_GENCTRL4.B.RX_125MHZ_CLK_EN_0      = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx125MhzClkEn_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_RATE_CTRL.B.TX0_RATE           = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_tx0Rate];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_RATE_CTRL.B.RX0_RATE           = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx0Rate];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_MISC_CTRL0.B.RX0_MISC              = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx0Misc];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX0_WIDTH               = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_tx0Width];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_RX_GENCTRL2.B.RX0_WIDTH               = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx0Width];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_BOOST_CTRL.B.TX0_IBOOST        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_tx0Iboost];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.VBOOST_EN_0         = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_vBoostEn_0];

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.AFE_EN_0                = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.DFE_EN_0                = 1;

        relvalCheck                                                                                   = IfxHsphy_sgmiiMpllEnable(hsphyRegPtr, xpcs->xpcsIndex); //need to change the func name specific to serial 100M

        if (relvalCheck == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.INIT = 1;

        timeoutCycleCount                                             = IFXHSPHY_MAX_TIMEOUT;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.INIT == 1)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL1.B.LPM                               = 1; //power down the DWC_xpcs

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerDown)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        if (timeOutError == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL1.U &= (uint32)(~((1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_LPM_OFF) | (1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_RST_OFF)));      //power up the DWC_xpcs

        timeoutCycleCount                                     = IFXHSPHY_MAX_TIMEOUT;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerGood)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        if (timeOutError == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 1;

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS5                                      = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6                                      = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13                                     = 1;

        //delay of 100ns to be added

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.USRA_RST = 1;

        timeoutCycleCount                                                 = IFXHSPHY_MAX_TIMEOUT;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.USRA_RST != 0)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }
    }

    return (boolean)timeOutError;
}
