/**
 * \file IfxGeth_Eth.h
 * \brief GETH ETH details
 * \ingroup IfxLld_Geth
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Geth_Eth ETH
 * \ingroup IfxLld_Geth
 * \defgroup IfxLld_Geth_Eth_DataStructures DataStructures
 * \ingroup IfxLld_Geth_Eth
 * \defgroup IfxLld_Geth_Eth_MAC_Functions MAC Functions
 * \ingroup IfxLld_Geth_Eth
 * \defgroup IfxLld_Geth_Eth_Module_Functions Module Functions
 * \ingroup IfxLld_Geth_Eth
 * \defgroup IfxLld_Geth_Eth_MTL_Functions MTL Functions
 * \ingroup IfxLld_Geth_Eth
 * \defgroup IfxLld_Geth_Eth_DMA_Functions DMA Functions
 * \ingroup IfxLld_Geth_Eth
 * \defgroup IfxLld_Geth_Eth_Variables Variables
 * \ingroup IfxLld_Geth_Eth
 * \defgroup IfxLld_Geth_Eth_Bridge_Functions Bridge Functions
 * \ingroup IfxLld_Geth_Eth
 */

#ifndef IFXGETH_ET_H
#define IFXGETH_ET_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Geth/Std/IfxGeth.h"
#include "_Utilities/Ifx_Assert.h"
#include "IfxPort_reg.h"
#include "IfxPort_bf.h"

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Geth_Eth_DataStructures
 * \{ */
/** \brief Interrupt configuration structure for MTL block
 */
typedef struct
{
    Ifx_Priority priority;       /**< \brief Interrupt service priority */
    IfxSrc_Tos   provider;       /**< \brief Interrupt service provider */
    IfxSrc_VmId  vmId;           /**< \brief Virtual Machine Number */
} IfxGeth_Eth_MtlInterruptConfig;

/** \brief Rx Queue Configuration
 */
typedef struct
{
    boolean                     enable;                                /**< \brief Enable the Rx Queue. Default is Generic mode. Also set enableAudioVideoBridge to TRUE for AVB mode. */
    boolean                     storeAndForward;                       /**< \brief Receive Store and Forward Enable/Disable. True: MAC reads a packet from the Rx queue only after the complete packet has been written to it. False: Rx queue operates in the Threshold (cut-through) mode, subject to the threshold specified by thresholdSize */
    uint8                       rxQueueSize;                           /**< \brief 7 bit Rx Queue size */
    boolean                     forwardErrorPacket;                    /**< \brief Error Packet Forwarding Enable/Disable */
    boolean                     forwardUndersizedGoodPacket;           /**< \brief Undersized Good Packet Forwarding Enable/Disable */
    IfxGeth_RxDmaChannel        rxDmaChannelMap;                       /**< \brief Mapped DMA Channel of Rx Queue */
    boolean                     enableDynamicDmaChannelMap;            /**< \brief Enable DMA Channel Selection. FALSE: Static mapping based on rxDmaChannelMap, TRUE: Dynamic mapping is enabled. */
    boolean                     rxQueueOverflowInterruptEnabled;       /**< \brief Enable/Disable Rx Queue Overflow Interrupt */
    boolean                     enableAudioVideoBridge;                /**< \brief TRUE: Queue is enabled for AVB mode. Pre-requisite: enable must be TRUE. */
    uint8                       wsp_weight;                            /**< \brief 3 bit weight allocated to this Rx Queue. It is the number of continuous PBL requests or contiguous packets allocated to this rx queue in 1 arbitration cycle. */
    boolean                     packetArbitrationControl;              /**< \brief TRUE: packet-level arbitration, FALSE: PBL based arbitration. The value of wsp_weight is used as number of continuous PBL requests or contiguous packets allocated to this rx queue in 1 arbitration cycle. */
    IfxGeth_MtlReceiveThreshold thresholdSize;                         /**< \brief Rx Threshold Size. storeAndForward must be False for this option */
} IfxGeth_Eth_RxQueueConfig;

/** \brief Tx Queue Configuration
 */
typedef struct
{
    boolean                      enable;                                 /**< \brief Enable the Tx Queue. Default is Generic mode. Also set enableAudioVideoBridge to TRUE for AVB mode. */
    boolean                      storeAndForward;                        /**< \brief Transmit Store and Forward Enable/Disable. TRUE:Transmits when there is a full packet available at MTL Tx Queue, FALSE: Transmits when size is greater than thresholdSize parameter */
    uint8                        txQueueSize;                            /**< \brief 7 bit Tx Queue Size */
    boolean                      txQueueUnderflowInterruptEnabled;       /**< \brief Enable/Disable Tx Queue Underflow Interrupt */
    IfxGeth_TxTrafficClass       queueToTrafficClassMap;                 /**< \brief Traffic Class to which the Tx queue is mapped */
    boolean                      enableAudioVideoBridge;                 /**< \brief TRUE: Queue is enabled for AVB mode. Pre-requisite: enable must be TRUE. */
    IfxGeth_MtlTransmitThreshold thresholdSize;                          /**< \brief Tx Threshold Size. storeAndForward must be False for this option */
} IfxGeth_Eth_TxQueueConfig;

/** \} */

/** \addtogroup IfxLld_Geth_Eth_DataStructures
 * \{ */
/** \brief Port Specific Configuration Structure as part of Bridge initialization
 * Contains TxQ and RxC enable configurations and mapping configurations of a Port
 */
typedef struct
{
    IfxGeth_TxQRxCEnableConfigUnion configTxQueuesAndRxChannels;        /**< \brief Port's enable configurations for TxQs, RxCs and Tx as Forward Paths */
    IfxGeth_BridgeTxQueueMap        txMap[IFXGETH_NUM_TX_QUEUES];       /**< \brief Tx Queue Map */
    IfxGeth_BridgeRxCMap            rxMap[IFXGETH_NUM_RX_QUEUES];       /**< \brief RxC Map */
} IfxGeth_Eth_Bridge_PortConfig;

/** \brief Interrupt configuration structure for DMA Channel
 */
typedef struct
{
    Ifx_Priority priority;       /**< \brief Interrupt service priority */
    IfxSrc_Tos   provider;       /**< \brief Interrupt service provider */
    IfxSrc_VmId  vmId;           /**< \brief Virtual Machine Number */
} IfxGeth_Eth_DmaInterruptConfig;

/** \brief Configuration Structure for the MAC initialization
 */
typedef struct
{
    IfxGeth_DuplexMode   duplexMode;                     /**< \brief Duplex Mode */
    IfxGeth_LoopbackMode loopbackMode;                   /**< \brief Loopback mode enable/disable */
    boolean              disableCrcCheck;                /**< \brief 1: Disable CRC Checking for Received Packets, 0: Enable CRC Checking for Received Packets */
    uint8                macAddress[6];                  /**< \brief MAC address for the ethernet, should be unique in the network. Here it configures MAC Address 0 */
    uint16               giantPacketSize;                /**< \brief Maximum size of the ethernet packet */
    IfxGeth_RxDmaChannel channelSelectMacAddress0;       /**< \brief DMA Channel Select for MAC Address 0 */
} IfxGeth_Eth_MacConfig;

/** \brief Configuration Structure for the MTL initialization
 */
typedef struct
{
    IfxGeth_RxArbitrationAlgorithm rxArbitrationAlgorithm;               /**< \brief Rx Arbitration Algorithm for Rx queues when no of queues are more than 1 */
    IfxGeth_Eth_TxQueueConfig      txQueue[IFXGETH_NUM_TX_QUEUES];       /**< \brief Tx queue configurations of selected queues */
    IfxGeth_Eth_RxQueueConfig      rxQueue[IFXGETH_NUM_RX_QUEUES];       /**< \brief Rx queue configurations of selected queues */
    IfxGeth_Eth_MtlInterruptConfig interrupt;                            /**< \brief Interrupt configuration structure for MTL block */
} IfxGeth_Eth_MtlConfig;

/** \brief Control command configuration for Remote wake-up filter's
 *  Definition in MAC_RWK_PACKET_FILTER Register
 */
typedef struct
{
    boolean dstAddrTypeSelect;          /**< \brief Filter detects for TRUE: multicast packets FALSE: unicast packets */
    boolean crcInverseModeSelect;       /**< \brief CRC16 hash function signal is TRUE: inverted  FALSE: non-inverted */
    boolean previousAndEnable;          /**< \brief The filter results of previous lower filter's are logically ANDed TRUE: Enable FALSE: Disabled */
    boolean rwkUpFilterEnable;          /**< \brief Remote wake up filter is TRUE: Enabled FALSE: Disabled */
} IfxGeth_Eth_RwkUpFilterControlConfig;

/** \brief Configuration structure for DMA rx channel
 */
typedef struct
{
    boolean               channelEnable;                /**< \brief Tx DMA channel enable. Set to TRUE to configure the corresponding channel */
    IfxGeth_RxDmaChannel  channelId;                    /**< \brief Rx DMA channel Index */
    IfxGeth_RxDescrList  *rxDescrList;                  /**< \brief Pointer to RX descriptors in RAM. Descriptor must be at 64 bit aligned address. */
    uint32               *rxBuffer1StartAddress;        /**< \brief Start address of Rx Buffer 1 */
    uint16                rxBuffer1Size;                /**< \brief Size of Rx Buffer 1 */
    IfxGeth_RxBurstLength maxBurstLength;               /**< \brief Maximum burst length of the channel */
} IfxGeth_Eth_RxChannelConfig;

/** \brief Configuration structure for DMA tx channel
 */
typedef struct
{
    boolean                           channelEnable;                 /**< \brief Tx DMA channel enable. Set to TRUE to configure the corresponding channel */
    IfxGeth_TxDmaChannel              channelId;                     /**< \brief Tx DMA channel Index */
    IfxGeth_TxDescrList              *txDescrList;                   /**< \brief Pointer to TX descriptors in RAM. Descriptor must be at 64 bit aligned address. */
    uint32                           *txBuffer1StartAddress;         /**< \brief Start address of Tx Buffer 1 */
    uint16                            txBuffer1Size;                 /**< \brief Size of Tx Buffer 1 */
    IfxGeth_TxBurstLength             maxBurstLength;                /**< \brief Maximum burst length of the channel */
    IfxGeth_TxContextDescriptorConfig contextDescriptorConfig;       /**< \brief Context descriptor initialization parameters */
    IfxGeth_VlanTagInclusionControl   vlanTagControl;                /**< \brief Vlan Tag control using descriptor option. Default is None. */
    boolean                           timeStampEnable;               /**< \brief TRUE: Enables the IEEE1588 time stamping for Transmit packet referenced by the descriptor. FALSE: Time-stamping is disabled. */
    uint8                             avbSlotNumber;                 /**< \brief 4 bit Slot number for AVB Channel. DMA.CH[channelId].SLOT_FUNCTION_CONTROL_STATUS.B.ESC must be enabled using IfxGeth_Eth_dmaAvbChannelSlotFunctionInit() */
    IfxGeth_ChecksumControl           checksumControl;               /**< \brief Option for Checksum Insertion Control in Transmit Packets */
    IfxGeth_SourceAddressControl      sourceAddressControl;          /**< \brief Option for Source Address Insertion Control in Transmit Packets */
    IfxGeth_CrcControl                crcControl;                    /**< \brief Option for CRC Pad Control in Transmit Packets */
} IfxGeth_Eth_TxChannelConfig;

/** \} */

/** \addtogroup IfxLld_Geth_Eth_DataStructures
 * \{ */
/** \brief Configuration Structure for the Bridge initialization
 */
typedef struct
{
    IfxGeth_BridgePortMode         mode;                                /**< \brief Bridge Port Mode */
    IfxGeth_BridgeLoopbackMode     portsLoopbackConfig;                 /**< \brief Bridge Loopback Modes */
    IfxGeth_Bridge_DmaPortMapUnion dmaPortMap;                          /**< \brief Mapping config of DMA Channels to one of the Ports(0/1) */
    IfxGeth_Eth_Bridge_PortConfig  portConfig[IFXGETH_NUM_PORTS];       /**< \brief Individual Port Specific Configuration */
} IfxGeth_Eth_BridgeConfig;

/** \brief Configuration Structure for the DMA initialization
 */
typedef struct
{
    boolean                        addressAlignedBeatsEnabled;                                  /**< \brief Enable/Disable Address Aligned Beats */
    IfxGeth_Eth_TxChannelConfig    txChannel[IFXGETH_NUM_TX_CHANNELS];                          /**< \brief Tx Channels configurations of selected Channels */
    IfxGeth_Eth_RxChannelConfig    rxChannel[IFXGETH_NUM_RX_CHANNELS];                          /**< \brief Rx Channels configurations of selected Channels */
    IfxGeth_Eth_DmaInterruptConfig txInterrupt[IFXGETH_NUM_DMA_CHANNELS];                       /**< \brief Transmit Interrupt configuration structure for DMA Channel */
    IfxGeth_Eth_DmaInterruptConfig rxInterrupt[IFXGETH_NUM_DMA_CHANNELS];                       /**< \brief Receive Interrupt configuration structure for DMA Channel */
    IfxGeth_DmaBurstLength         burstLength;                                                 /**< \brief Dma burst length */
    boolean                        undefinedBurstLength;                                        /**< \brief Enable/Disable undefined burst length for flexible max and lower length bursts */
    boolean                        burstLengthMultiplierEnable[IFXGETH_NUM_DMA_CHANNELS];       /**< \brief Enable/Disable multiplier for Tx/Rx Burst length, multiplies maxBurstLength by 8 */
} IfxGeth_Eth_DmaConfig;

/** \brief Configuration for MDIO Continuous Write transfer for Addr / Data
 * Refer to Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_WRITE_DATA and Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_WRITE_ADDRESS SFR's for more info
 */
typedef struct
{
    uint16  mdioContinuousWriteRegAddr;             /**< \brief Configure the MDIO Continuous Write Register Addr */
    uint16  mdioContinuousWriteData;                /**< \brief Configure the MDIO Continuous Write Data Addr */
    uint8   mdioContinuousPortDeviceAddr : 5;       /**< \brief Configure the MDIO Continuous PORT / Device Addr.Configured Value to be less then 32 */
    boolean mdioContinuousPortAddrEnable;           /**< \brief True: mdioContinuousPortDeviceAddr is used as Port Addr   False: mdioContinuousPortDeviceAddr is used as Device Addr */
} IfxGeth_Eth_MdioContinuousWriteAddrData;

/** \brief Configure struct for the MMC counter
 * Refer the Ifx_GETH_PORT_CORE_MMC_CONTROL SFR's for more info
 */
typedef struct
{
    boolean                     counterReset;              /**< \brief Parameter to enable the MMC counter reset */
    boolean                     counterStopRollover;       /**< \brief parameter to enable MMC counter stop roll over */
    boolean                     counterResetOnRead;        /**< \brief parameter MMC counter enable reset on read */
    boolean                     counterPreset;
    IfxGeth_MmcCounterThreshold counterThreshold;          /**< \brief parameter to configure the MMC counter threshold */
} IfxGeth_Eth_MmcControlConfig;

/** \brief Config struct for MMC Interrupt Enable and Mask
 * Refer the MMC_TRANSMIT_INTERRUPT_ENABLE,MMC_RECEIVE_INTERRUPT_ENABLE,MMC_FPE_TX_INTERRUPT_MASK,MMC_FPE_RX_INTERRUPT_MASK for more info
 */
typedef struct
{
    Ifx_GETH_PORT_CORE_MMC_RECEIVE_INTERRUPT_ENABLE  rxInterruptEnable;        /**< \brief Parameter to configure the RX interrupt enable */
    Ifx_GETH_PORT_CORE_MMC_TRANSMIT_INTERRUPT_ENABLE txInterruptEnable;        /**< \brief Parameter to configure the TX interrupt enable */
    Ifx_GETH_PORT_CORE_MMC_FPE_RX_INTERRUPT_MASK     rxFpeInterruptMask;       /**< \brief Parameter to configure the FPE RX interrupt Mask */
    Ifx_GETH_PORT_CORE_MMC_FPE_TX_INTERRUPT_MASK     txFpeInterruptMask;       /**< \brief Parameter to configure the FPE TX interrupt Mask */
    Ifx_GETH_PORT_CORE_MMC_IPC_RX_INTERRUPT_MASK     rxIpcInterruptMask;       /**< \brief Parameter to configure the ICP RX interrupt Mask */
} IfxGeth_Eth_MmcInterruptConfig;

/** \brief Configuration Structure for the Port initialization (1 MAC + 1 MTL per PORT)
 */
typedef struct
{
    IfxGeth_PhyInterfaceMode phyInterfaceMode;       /**< \brief External Phy Interface Mode */
    IfxGeth_Eth_MacConfig    mac;                    /**< \brief Configuration Structure for the the MAC initialization */
    IfxGeth_Eth_MtlConfig    mtl;                    /**< \brief Configuration Structure for the MTL initialization */
} IfxGeth_Eth_PortConfig;

/** \brief Interrupt configuration structure for PPS block
 */
typedef struct
{
    Ifx_Priority priority;       /**< \brief Interrupt service priority */
    IfxSrc_Tos   provider;       /**< \brief Interrupt service provider */
    IfxSrc_VmId  vmId;           /**< \brief Virtual Machine Number */
} IfxGeth_Eth_PpsInterruptConfig;

/** \brief Configuration for Remote wake-up filter's
 *  Definition in MAC_RWK_PACKET_FILTER Register
 */
typedef struct
{
    uint8                                offsetIndex[IFXGETH_NUM_RWKUP_FILTER];            /**< \brief Offset values for byte position in the received frame for filter "i" */
    uint16                               crcHashValue[IFXGETH_NUM_RWKUP_FILTER];           /**< \brief CRC 16bit value determined from the hash polynomial */
    uint32                               maskByteIndex[IFXGETH_NUM_RWKUP_FILTER];          /**< \brief Each set bit represent the byte position to be processed in the received frame w.r.t offsetIndex for filter "i" */
    IfxGeth_Eth_RwkUpFilterControlConfig cmdControlFilter[IFXGETH_NUM_RWKUP_FILTER];       /**< \brief Command Control Configuration for filter "i" */
} IfxGeth_Eth_RwkUpFilterConfig;

/** \brief Handle structure for DMA Rx channel
 */
typedef struct
{
    IfxGeth_RxDmaChannel      channelId;           /**< \brief Rx DMA channel Index */
    IfxGeth_RxDescrList      *rxDescrList;         /**< \brief pointer to Rx descriptors RAM */
    volatile IfxGeth_RxDescr *rxDescrPtr;          /**< \brief Pointer to Rx Descriptor (current descriptor) */
    uint32                    rxCount;             /**< \brief Number of frames received */
    uint32                    buffer1Address;      /**< \brief Rx Buffer 1 Address. Stored during call of IfxGeth_Eth_initReceiveDescriptors */
    uint32                    bufferSize;          /**< \brief Size of Rx Buffer. Stored during call of IfxGeth_Eth_initReceiveDescriptors */
} IfxGeth_Eth_RxChannel;

/** \brief Structure for Rx Context Descriptor Status updated by DMA
 * Refer to Rx Context Descriptor Format
 */
typedef struct
{
    uint32 RTSL : 32;       /**< \brief Receive Packet Timestamp Low */
    uint32 RTSH : 32;       /**< \brief Receive Packet Timestamp High */
    uint32 PMT : 4;         /**< \brief PTP Message Type */
    uint32 TSA : 1;         /**< \brief Timestamp Available */
    uint32 TSD : 1;         /**< \brief Timestamp Dropped */
    uint32 CTXT : 1;        /**< \brief Receive Context Descriptor */
    uint32 OWN : 1;         /**< \brief Own Bit */
} IfxGeth_Eth_RxDescContextStatus;

/** \brief Structure for Rx Normal Descriptor Status updated by DMA
 * Refer to Rx Descriptor Normal Write Back Format
 */
typedef struct
{
    uint32 OVT : 16;         /**< \brief Outer VLAN Tag */
    uint32 IVT : 16;         /**< \brief Inner VLAN Tag */
    uint32 FRPLI : 32;       /**< \brief FRP last instruction. This field contains the FRP Last Instruction number where FRP result is generated. */
    uint32 AVTCP : 1;        /**< \brief AV Tagged Control Packet */
    uint32 AVTDP : 1;        /**< \brief AV Tagged Data Packet */
    uint32 HL : 8;           /**< \brief L3/L4 Header Length */
    uint32 FRPSM : 1;        /**< \brief Flexible Receive Parser Status MSB bit */
    uint32 VF : 1;           /**< \brief VLAN Filter Status */
    uint32 SAF : 1;          /**< \brief SA Address Filter Fail */
    uint32 DAF : 1;          /**< \brief Destination Address Filter Fail */
    uint32 MADRM : 8;        /**< \brief MAC Address Match Value */
    uint32 L3FM : 1;         /**< \brief Layer 3 Filter Match */
    uint32 L4FM : 1;         /**< \brief Layer 4 Filter Match */
    uint32 L3L4FM : 3;       /**< \brief Layer 3 and Layer 4 Filter Number Matched */
    uint32 PL : 14;          /**< \brief Packet Length */
    uint32 FRPSL : 1;        /**< \brief Flexible Receive Parser Status LSB bit */
    uint32 ES : 1;           /**< \brief Error Summary */
    uint32 ET_LT : 4;        /**< \brief Error if ES=1 else Length/Type Field */
    uint32 L34T : 4;         /**< \brief Layer3 or Layer4 packet Type */
    uint32 ETM : 1;          /**< \brief Ether Type Match */
    uint32 CDA : 1;          /**< \brief Context Descriptor Available */
    uint32 LD : 1;           /**< \brief Last Descriptor */
    uint32 FD : 1;           /**< \brief First Descriptor */
    uint32 CTXT : 1;         /**< \brief Receive Context Descriptor */
    uint32 OWN : 1;          /**< \brief Own Bit */
} IfxGeth_Eth_RxDescNormalStatus;

/** \brief handle structure for DMA Tx channel
 */
typedef struct
{
    IfxGeth_TxDmaChannel              channelId;                     /**< \brief Tx DMA channel Index */
    IfxGeth_TxDescrList              *txDescrList;                   /**< \brief pointer to Tx descriptors RAM */
    volatile IfxGeth_TxDescr         *txDescrPtr;                    /**< \brief Pointer to Tx Descriptor (current descriptor) */
    uint32                            txCount;                       /**< \brief Number of frames transmitted */
    uint32                            buffer1Address;                /**< \brief Tx Buffer 1 Address. Stored during call of IfxGeth_Eth_initReceiveDescriptors */
    uint32                            txBuf1Size;                    /**< \brief configured tx buffer 1 size */
    IfxGeth_TxContextDescriptorConfig contextDescriptorConfig;       /**< \brief Configured Context descriptor parameters saved in handle for reference during re-initialization/modification of sub features */
    IfxGeth_VlanTagInclusionControl   vlanTagControl;                /**< \brief Vlan Tag control using descriptor option. Default is None. */
    boolean                           timeStampEnable;               /**< \brief TRUE: Enables the IEEE1588 time stamping for Transmit packet referenced by the descriptor. FALSE: Time-stamping is disabled. */
    uint8                             avbSlotNumber;                 /**< \brief 4 bit Slot number for AVB Channel. DMA.CH[channelId].SLOT_FUNCTION_CONTROL_STATUS.B.ESC must be enabled using IfxGeth_Eth_dmaAvbChannelSlotFunctionInit() */
    IfxGeth_ChecksumControl           checksumControl;               /**< \brief Option for Checksum Insertion Control in Transmit Packets */
    IfxGeth_SourceAddressControl      sourceAddressControl;          /**< \brief Option for Source Address Insertion Control in Transmit Packets */
    IfxGeth_CrcControl                crcControl;                    /**< \brief Option for CRC Pad Control in Transmit Packets */
} IfxGeth_Eth_TxChannel;

/** \brief Configuration Structure for Inner VLAN Tag Inclusion Control Register.
 * Refer to Ifx_GETH_PORT_CORE_MAC_INNER_VLAN_INCL SFR for more info.
 */
typedef struct
{
    boolean                         enableInnerVlanModification;       /**< \brief Enable(if True)/Disable(if False) the Inner VLAN Tag Insertion/Deletion/Replacement Features */
    uint16                          txVlanTag;                         /**< \brief 16 bit VLAN Tag ID for Tx packets (VLT) */
    IfxGeth_VlanTagInclusionControl control;                           /**< \brief VLAN Tag Inclusion Control (VLC) in Transmit Packets. */
    boolean                         priority;                          /**< \brief VLC priority over mti_vlan_ctrl_i control input. TRUE: VLC is used. FALSE: mti_vlan_ctrl_i control input is used. */
    boolean                         vlanType;                          /**< \brief TRUE: S-VLAN type (0x88A8) is inserted, FALSE: C-VLAN type (0x8100) is inserted in 13th and 14th bytes of transmitted packets. */
    boolean                         tagSource;                         /**< \brief Tag source, TRUE: Tx descriptor, FALSE: txVlanTag (VLT) */
} IfxGeth_Eth_VlanInnerInclusionConfig;

/** \brief Configuration Structure for Outer VLAN Tag Inclusion Control Register.
 * Refer to Ifx_GETH_PORT_CORE_MAC_VLAN_INCL SFR for more info.
 */
typedef struct
{
    boolean                         enableOuterVlanModification;       /**< \brief Enable(if True)/Disable(if False) the Outer VLAN Tag Insertion/Deletion/Replacement Features */
    uint16                          txVlanTag;                         /**< \brief 16 bit VLAN Tag ID for Tx packets (VLT) */
    IfxGeth_VlanTagInclusionControl control;                           /**< \brief VLAN Tag Inclusion Control (VLC) in Transmit Packets. */
    boolean                         priority;                          /**< \brief VLC priority (VLP) over mti_vlan_ctrl_i control input. TRUE: VLC is used. FALSE: mti_vlan_ctrl_i control input is used. */
    boolean                         vlanType;                          /**< \brief TRUE: S-VLAN type (0x88A8) is inserted, FALSE: C-VLAN type (0x8100) is inserted in 13th and 14th bytes of transmitted packets. */
    boolean                         tagSource;                         /**< \brief Tag source, TRUE: Tx descriptor, FALSE: txVlanTag (VLT) */
    boolean                         enableChannelSpecificConfig;       /**< \brief TRUE: Insertion control is channel specific through indirect addressing. FALSE: operation is based on the setting of VLTI, VLP, VLC and VLT fields of this register */
    uint8                           addressOffset;                     /**< \brief Address offset for Indirect access of channel specific registers. (Valid range: 0-7) */
} IfxGeth_Eth_VlanOuterInclusionConfig;

/** \} */

/** \addtogroup IfxLld_Geth_Eth_DataStructures
 * \{ */
/** \brief GETH driver Handle
 */
typedef struct
{
    Ifx_GETH             *gethSFR;                                  /**< \brief Pointer to GETH register base address */
    IfxGeth_Eth_TxChannel txChannel[IFXGETH_NUM_TX_CHANNELS];       /**< \brief Tx Channels handle of selected Channels */
    IfxGeth_Eth_RxChannel rxChannel[IFXGETH_NUM_RX_CHANNELS];       /**< \brief Rx Channels handle of selected Channels */
} IfxGeth_Eth;

/** \brief Configuration Structure for the Module initialization
 */
typedef struct
{
    Ifx_GETH                *gethSFR;                       /**< \brief Pointer to GETH register base address */
    IfxGeth_Eth_PortConfig   port[IFXGETH_NUM_PORTS];       /**< \brief Configuration Structure for the Port initialization (1 MAC + 1 MTL per PORT) */
    IfxGeth_Eth_DmaConfig    dma;                           /**< \brief Configuration Structure for the DMA initialization */
    IfxGeth_Eth_BridgeConfig bridge;                        /**< \brief Configuration Structure for the Bridge initialization */
    boolean                  bypassKernelReset;             /**< \brief Switch to bypass parts of init sequence (Kernel Reset as needed). Application to enable module and add external Phy initialisation sequence before IfxGeth_Eth_initModule. Silicon users can bypass reset if needed by configuring this bit as TRUE. Must be FALSE for VP/Simulator (Default value) */
} IfxGeth_Eth_Config;

/** \brief Configuration Structure for MAC RxQ Ctrl4 Register. Routing of filtering failed packets.
 * Refer to Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL4 SFR for more info.
 */
typedef struct
{
    boolean            unicastFailPacketRoutingEnable;         /**< \brief TRUE: Failed unicast packets are routed to destination queue as per uincastFailPacketDestination(UFFQ). Pre-Condition: RA bit of the MAC_Packet_Filter register must be set. FALSE: UFFQ based Routing is not performed. */
    boolean            multicastFailPacketRoutingEnable;       /**< \brief TRUE: Failed multicast packets are routed to destination queue as per multicastFailPacketDestination(MFFQ). Pre-Condition: RA bit of the MAC_Packet_Filter register must be set. FALSE: MFFQ based Routing is not performed. */
    boolean            vlanFailPacketRoutingEnable;            /**< \brief TRUE: Tagged packets which Fail are routed to destination queue as per vlanFailPacketDestination(VFFQ). Pre-Condition: RA bit of the MAC_Packet_Filter register must be set. FALSE: VFFQ based Routing is not performed. */
    IfxGeth_RxMtlQueue uincastFailPacketDestination;           /**< \brief Rx queue number to which Unicast Packets failing the Destination or Source Address filter must be routed. Pre-Condition: This field is valid only when UFFQE bit is set. */
    IfxGeth_RxMtlQueue multicastFailPacketDestination;         /**< \brief Rx queue number to which Multicast Packets failing the Destination or Source Address filter must be routed. Pre-Condition: This field is valid only when MFFQE bit is set. */
    IfxGeth_RxMtlQueue vlanFailPacketDestination;              /**< \brief Rx queue number to which Tagged Packets failing the Destination or Source Address filter must be routed. Pre-Condition: This field is valid only when VFFQE bit is set and UFFQE/MFFQE should not be enabled. */
} IfxGeth_Eth_FailPacketRoutingConfig;

/** \brief Configuration Structure for Flexible Header Feature.
 * Refer to Ifx_GETH_PORT_CORE_MAC_FLEX_HDR_CFG, Ifx_GETH_PORT_CORE_MAC_FLEX_HDR_LOW and Ifx_GETH_PORT_CORE_MAC_FLEX_HDR_HIGH SFRs for more info.
 */
typedef struct
{
    uint64                          staticHeader;            /**< \brief Optional: 8 byte static flexible header for MAC/Offload engine generated packets */
    uint8                           length;                  /**< \brief Actual length of flexible header on the line (Valid range: 0-7, 0 is mapped to 1 byte and 7 is mapped to 8 bytes respectively) */
    IfxGeth_FlexHeaderStartPosition startPosition;           /**< \brief Position where Flex Header is inserted */
    boolean                         txEnable;                /**< \brief Enable(if True)/Disable(if False) Flexible Header for Tx frames */
    boolean                         rxEnable;                /**< \brief Enable(if True)/Disable(if False) Flexible Header for Rx frames */
    boolean                         pauseHeaderEnable;       /**< \brief Enable if True and Disable if False, the insertion Flexible Header for Pause frames. Configure txEnable for Tx and rxEnable for Rx accordingly. */
} IfxGeth_Eth_FlexHeaderConfig;

/** \brief Configuration Structure for Tx Flexible PPS Output.
 * Refer to Ifx_GETH_PORT_CORE_MAC_PPS_CONTROL, Ifx_GETH_PORT_CORE_MAC_PPS<n>_TARGET_TIME_SECONDS, Ifx_GETH_PORT_CORE_MAC_PPS<n>_TARGET_TIME_NANOSECONDS, Ifx_GETH_PORT_CORE_MAC_PPS<n>_INTERVAL and Ifx_GETH_PORT_CORE_MAC_PPS<n>_WIDTH SFRs for more info.
 */
typedef struct
{
    boolean                    configurePPS0;                   /**< \brief S/w control for PPS0. True: PPSCMD of PPS0 is configured. False: No command is initiated for PPS0 */
    boolean                    configurePPS1;                   /**< \brief S/w control for PPS1. True: PPSCMD of PPS1 is configured. False: No command is initiated for PPS1 */
    IfxGeth_FlexiblePPSControl controlPPS0;                     /**< \brief Flexible PPS command for PPS0. */
    IfxGeth_FlexiblePPSControl controlPPS1;                     /**< \brief Flexible PPS command for PPS1. */
    uint32                     targetTimeSecondsPPS0;           /**< \brief Seconds part of Target Time for PPS0. */
    uint32                     targetTimeNanoSecondsPPS0;       /**< \brief Nano seconds part of Target Time for PPS0. */
    uint32                     targetTimeSecondsPPS1;           /**< \brief Seconds part of Target Time for PPS1. */
    uint32                     targetTimeNanoSecondsPPS1;       /**< \brief Nano seconds part of Target Time for PPS1. */
    uint32                     pulseWidthPPS0;                  /**< \brief Width of pulse for PPS0 */
    uint32                     pulseIntervalPPS0;               /**< \brief Interval of pulses in pulse train for PPS0 */
    uint32                     pulseWidthPPS1;                  /**< \brief Width of pulse for PPS1 */
    uint32                     pulseIntervalPPS1;               /**< \brief Interval of pulses in pulse train for PPS1 */
} IfxGeth_Eth_FlexiblePPSConfig;

/** \brief Configuration Structure for Tx Frame
 */
typedef struct
{
    IfxGeth_TxDmaChannel channelId;          /**< \brief Tx DMA channel Index */
    uint32               packetLength;       /**< \brief the length of the packet to be transmitted in bytes */
} IfxGeth_Eth_FrameConfig;

/** \brief configuration for IPv4 layer 3 filter initialization
 * Refer to MAC_L3_L4_CONTROL#(i), MAC_LAYER3_ADDR0_REG#(i), MAC_LAYER3_ADDR1_REG#(i) register's for more info
 */
typedef struct
{
    IfxGeth_L3L4FilterNum           filterNum;                   /**< \brief configure the L3 filter number to be used */
    IfxGeth_L3FilterSrcAddrMatch    filterSrcAddrMatch;          /**< \brief enable/disable the source addr matching */
    IfxGeth_L3FilterSrcAddrInvMatch filterSrcAddrInvMatch;       /**< \brief configure to enable the source addr perfect/inverse matching */
    IfxGeth_L3FilterDstAddrMatch    filterDstAddrMatch;          /**< \brief enable/disable the destination addr matching */
    IfxGeth_L3FilterDstAddrInvMatch filterDstAddrInvMatch;       /**< \brief configure to enable the destination addr perfect/inverse matching */
    IfxGeth_L3FilterSrcDstAddrMask  filterSrcAddrMask;           /**< \brief configure to mask the no's of bits in source addr specified */
    IfxGeth_L3FilterSrcDstAddrMask  filterDstAddrMask;           /**< \brief configure to mask the no's of bits in destination addr specified */
    IfxGeth_L3L4FilterChannelSel    filterChannelSel;            /**< \brief enable/disable the channel selection to transfer the passed frame */
    IfxGeth_L3L4FilterChannel       filterChannel;               /**< \brief configure the channel index to be used for passed frame */
    uint32                          filterSrcAddr;               /**< \brief configure the source addr to match in received IPv4 frame */
    uint32                          filterDstAddr;               /**< \brief configure the destination addr to match in received IPv4 frame */
} IfxGeth_Eth_L3FilterIPv4Config;

/** \brief configuration for IPv6 layer 3 filter initialization
 * Refer to MAC_L3_L4_CONTROL#(i), MAC_LAYER3_ADDR0_REG#(i), MAC_LAYER3_ADDR1_REG#(i), MAC_LAYER3_ADDR2_REG#(i), MAC_LAYER3_ADDR3_REG#(i) register's for more info
 */
typedef struct
{
    IfxGeth_L3L4FilterNum           filterNum;                   /**< \brief configure the L3 filter number to be used */
    IfxGeth_L3FilterSrcAddrMatch    filterSrcAddrMatch;          /**< \brief enable/disable the source addr matching */
    IfxGeth_L3FilterSrcAddrInvMatch filterSrcAddrInvMatch;       /**< \brief configure to enable the source addr perfect/inverse matching */
    IfxGeth_L3FilterDstAddrMatch    filterDstAddrMatch;          /**< \brief enable/disable the destination addr matching */
    IfxGeth_L3FilterDstAddrInvMatch filterDstAddrInvMatch;       /**< \brief configure to enable the destination addr perfect/inverse matching */
    uint8                           filterSrcDstAddrMask;        /**< \brief configure to mask the no's of bits in source/destination addr specified Note: value ranges to be used {0, 127} */
    IfxGeth_L3L4FilterChannelSel    filterChannelSel;            /**< \brief enable/disable the channel selection to transfer the passed frame */
    IfxGeth_L3L4FilterChannel       filterChannel;               /**< \brief configure the channel index to be used for passed frame */
    uint32                          filterSrcDstAddr0;           /**< \brief configure the bits [31:0] of source/destination addr to be match in received IPv6 frame */
    uint32                          filterSrcDstAddr1;           /**< \brief configure the bits [63:32] of source/destination addr to be match in received IPv6 frame */
    uint32                          filterSrcDstAddr2;           /**< \brief configure the bits [95:64] of source/destination addr to be match in received IPv6 frame */
    uint32                          filterSrcDstAddr3;           /**< \brief configure the bits [127:96] of source/destination addr to be match in received IPv6 frame */
} IfxGeth_Eth_L3FilterIPv6Config;

/** \brief configuration for layer 4 filter initialization
 * Refer to MAC_L3_L4_CONTROL#(i), MAC_LAYER3_ADDR0_REG#(i), MAC_LAYER3_ADDR1_REG#(i) register's for more info
 */
typedef struct
{
    IfxGeth_L3L4FilterNum           filterNum;                   /**< \brief configure the L4 filter number to be used */
    IfxGeth_L4FilterProtocolEnable  filterProtocolEnable;        /**< \brief configure the L4 filter selection between TCP/UDP protocol */
    IfxGeth_L4FilterSrcPortMatch    filterSrcPortMatch;          /**< \brief enable/disable the source Port matching */
    IfxGeth_L4FilterSrcPortInvMatch filterSrcPortInvMatch;       /**< \brief configure to enable the source Port perfect/inverse matching */
    IfxGeth_L4FilterDstPortMatch    filterDstPortMatch;          /**< \brief enable/disable the Destination Port matching */
    IfxGeth_L4FilterDstPortInvMatch filterDstPortInvMatch;       /**< \brief configure to enable the destination Port perfect/inverse matching */
    IfxGeth_L3L4FilterChannelSel    filterChannelSel;            /**< \brief enable/disable the channel selection to transfer the passed frame */
    IfxGeth_L3L4FilterChannel       filterChannel;               /**< \brief configure the channel index to be used for passed frame */
    uint16                          filterSrcPortNum;            /**< \brief configure the Source Port Number to matched in received frame */
    uint16                          filterDstPortNum;            /**< \brief configure the destination Port Number to matched in received frame */
} IfxGeth_Eth_L4FilterConfig;

/** \brief Configuration Structure for MAC Address Filters 1-31.
 * Filter 0 of available ports are enabled by default and is configured during init.
 */
typedef struct
{
    uint8                    macAddress[6];          /**< \brief MAC address for the ethernet, should be unique in the network. */
    IfxGeth_RxDmaChannel     dmachannel;             /**< \brief DMA Channel Select */
    uint8                    mask;                   /**< \brief Mask Byte Control */
    IfxGeth_MacAddressSelect referenceAddress;       /**< \brief Source/Destination Address Selection used for comparison */
    boolean                  enable;                 /**< \brief Enable(if True)/Disable(if False) the address for perfect filter */
    IfxGeth_AddressFilter    index;                  /**< \brief number of Address Filter to be configured */
} IfxGeth_Eth_MacAddressFilterConfig;

/** \brief Configuration Structure for MAC Packet Filter.
 * Refer to GETH_PORT_CORE_MAC_PACKET_FILTER SFR for more info.
 */
typedef struct
{
    boolean                            enablePromiscuousMode;               /**< \brief Enable(if True)/Disable(if False) the Promiscuous Mode */
    boolean                            enableDAInverseFiltering;            /**< \brief Enable(if True)/Disable(if False) the DA Inverse Filtering mode */
    boolean                            enablePassAllMulticast;              /**< \brief Enable(if True)/Disable(if False) the Pass All Multicast Mode */
    boolean                            enableDisableBroadcastPackets;       /**< \brief Enable(if True)/Disable(if False) the disabling of Broadcast packets */
    IfxGeth_MacPacketFilterPassControl controlPacketFilterType;             /**< \brief Control packet filtering options */
    boolean                            enableSAInverseFiltering;            /**< \brief Enable(if True)/Disable(if False) the SA Inverse Filtering mode */
    boolean                            enableSourceAddressFilter;           /**< \brief Enable(if True)/Disable(if False) the Source Address Filter. When this bit is set, the MAC compares the SA field of the received packets with the values programmed in the enabled MAC_Address registers. */
    boolean                            enableVLanTagFilter;                 /**< \brief Enable(if True)/Disable(if False) the VLAN Tag Filter */
    boolean                            enableL3L4Filter;                    /**< \brief Enable(if True)/Disable(if False) the IP Layer 3 and Layer 4 Filters */
    boolean                            enableNonTcpUpdDropFilter;           /**< \brief Enable(if True)/Disable(if False) the dropping of Non-TCP/UDP over IP Packets */
    boolean                            enableReceiveAllPackets;             /**< \brief Enable(if True)/Disable(if False) the receiving of all packets irrespective of SA/DA address filter status */
} IfxGeth_Eth_MacPacketFilterConfig;

/** \brief Configuration for MDIO Continuous transfer
 * Refer Ifx_GETH_PORT_CORE_MDIO_CLAUSE_22_PORT, Ifx_GETH_PORT_CORE_MDIO_PORT_NX4_INDIRECT_CONTROL, Ifx_GETH_PORT_CORE_MDIO_PORTNX4P0_DEVICE_IN_USE for more info
 */
typedef struct
{
    IfxGeth_MdioPortRangeSel     mdioPortRangeSel;              /**< \brief Configure the MDIO PORT range Selection */
    IfxGeth_MdioClause22Union    mdioClause22;                  /**< \brief Configure the MDIO PORT Clause 22 Enable Bits */
    IfxGeth_MdioDeviceInUseUnion mdioDeviceInUse_NX4P[4];       /**< \brief Configure the MDIO device in use */
} IfxGeth_Eth_MdioContinuousConfig;

/** \brief Configure the MDIO Continuous Start scan transfer
 * Refer the Ifx_GETH_PORT_CORE_MDIO_INTERRUPT_ENABLE and Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE SFR's for more info
 */
typedef struct
{
    IfxGeth_MdioContinuousScanPortEnableUnion  mdioContinuousScanPortEnable;        /**< \brief Configure the MDIO PORT N to enable for Scan */
    IfxGeth_MdioContinuousInterruptEnableUnion mdioContinuousInterruptEnable;       /**< \brief Configure the MDIO PORT N to enable corresponding Interrupt */
} IfxGeth_Eth_MdioContinuousStartScanConfig;

/** \brief Configuration for MDIO Continuous Scan Stop
 * Refer to Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_SCAN_PORT_ENABLE SFR's for more info
 */
typedef struct
{
    IfxGeth_MdioContinuousScanPortEnableUnion mdioContinuousScanPortEnable;       /**< \brief Configure the MDIO PORT N to disable to stop the Scan */
} IfxGeth_Eth_MdioContinuousStopScanConfig;

/** \brief Configuration for continuous write Transfer
 * Refer to Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_WRITE_DATA and Ifx_GETH_PORT_CORE_MDIO_CONTINUOUS_WRITE_ADDRESS SFR's for more info
 */
typedef struct
{
    uint8                                    mdioContinuousWriteOperCount;      /**< \brief Configure the Number of MDIO Data Transfer to be done */
    IfxGeth_Eth_MdioContinuousWriteAddrData *mdioContinuousWriteAddrData;       /**< \brief Configure this with addr of array type IfxGeth_Eth_MdioContinuousWriteAddrData with size of mdioContinuousWriteOperCount */
} IfxGeth_Eth_MdioContinuousWriteConfig;

/** \brief MDIO Single transfer configure
 * Refer the Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA, Ifx_GETH_PORT_CORE_MDIO_CLAUSE_22_PORT, Ifx_GETH_PORT_CORE_MDIO_PORT_NX4_INDIRECT_CONTROL SFR's for more info
 */
typedef struct
{
    IfxGeth_MdioControlCommandType mdioControlCommandType;              /**< \brief Config the mdio Control Command Type */
    boolean                        mdioSkipAddrFrameEnable;             /**< \brief True: To skip the Addr frame in the transfer   False: SMA Auto transfers the Addr frame */
    boolean                        mdioClkRangeEnable;                  /**< \brief True: To generate the faster MDC clock    False: Uses the Default dividers for the MDC clock generation */
    IfxGeth_MdioAppClockRangeSel   mdioAppClockRangeSel;                /**< \brief configure Mdio clock range selection */
    IfxGeth_MdioClause22Union      mdioClause22;                        /**< \brief Configure MDIO PORTN clause 22 Enable  Bits */
    IfxGeth_MdioPortRangeSel       mdioPortRangeSel;                    /**< \brief Configure the MDIO PORT range selection */
    boolean                        mdioPreambleSuppressionEnable;       /**< \brief Configure the MDIO Preamble Suppression Enable */
} IfxGeth_Eth_MdioSingleConfig;

/** \brief Configuration for MDIO Single Read transfer
 * Refer the Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS and Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA SFR's for more info
 */
typedef struct
{
    uint16  mdioSingleCmdRegAddr;         /**< \brief Configure the MDIO single write Register Addr */
    uint8   mdioSingleCmdPortAddr;        /**< \brief Configure the MDIO Single Write Port Addr */
    uint8   mdioSingleCmdDeviceAddr;      /**< \brief Configure the MDIO Device Addr */
    uint16 *mdioSingleReadData;           /**< \brief Configure the Addr of the data variable to hold the read value */
} IfxGeth_Eth_MdioSingleReadConfig;

/** \brief Configuration for MDIO Single Write transfer
 * Refer the Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS and Ifx_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA SFR's for more info
 */
typedef struct
{
    uint16 mdioSingleCmdRegAddr;          /**< \brief Configure the MDIO single write Register Addr */
    uint8  mdioSingleCmdPortAddr;         /**< \brief Configure the MDIO Single Write Port Addr */
    uint8  mdioSingleCmdDeviceAddr;       /**< \brief Configure the MDIO Device Addr */
    uint16 mdioSingleWriteData;
} IfxGeth_Eth_MdioSingleWriteConfig;

/** \brief MMC configure structure
 * Refer the IfxGeth_Eth_MmcInterruptConfig and IfxGeth_Eth_MmcControlConfig structures for details
 */
typedef struct
{
    IfxGeth_Eth_MmcControlConfig   controlConfig;         /**< \brief Parameter to configure MMC control struct */
    IfxGeth_Eth_MmcInterruptConfig interruptConfig;       /**< \brief parameter to configure the mmc Interrupt struct */
} IfxGeth_Eth_MmcConfig;

/** \brief structure to store the MMC counter register's read value
 * Refer to MMC counter registers in IfxGeth_regdef.h file for more info
 */
typedef struct
{
    uint64 txOctetCountGoodBad64;                     /**< \brief counter value for Tx Octet Count Good Bad Low and High */
    uint32 txPacketCountGoodBadLow;                   /**< \brief counter value for Tx Packet Count Good Bad Low */
    uint32 txBroadcastPacketsGoodLow;                 /**< \brief counter value for Tx Broadcast Packets Good Low */
    uint32 txMulticastPacketsGoodLow;                 /**< \brief counter value for Tx Multicast Packets Good Low */
    uint32 tx64OctetsPacketsGoodBadLow;               /**< \brief counter value for Tx 64Octets Packets Good Bad Low */
    uint32 tx65to127OctetsPacketsGoodBadLow;          /**< \brief counter value for Tx 65To127Octets Packets Good Bad Low */
    uint32 tx128to255OctetsPacketsGoodBadLow;         /**< \brief counter value for Tx 128To255Octets Packets Good Bad Low */
    uint32 tx256to511OctetsPacketsGoodBadLow;         /**< \brief counter value for Tx 256To511Octets Packets Good Bad Low */
    uint32 tx512to1023OctetsPacketsGoodBadLow;        /**< \brief counter value for Tx 512To1023Octets Packets Good Bad Low */
    uint32 tx1024toMaxOctetsPacketsGoodBadLow;        /**< \brief counter value for Tx 1024ToMaxOctets Packets Good Bad Low */
    uint32 txUnicastPacketsGoodBadLow;                /**< \brief counter value for Tx Unicast Packets Good Bad Low */
    uint32 txMulticastPacketsGoodBadLow;              /**< \brief counter value for Tx Multicast Packets Good Bad Low */
    uint32 txBroadcastPacketsGoodBadLow;              /**< \brief counter value for Tx Broadcast Packets Good Bad Low */
    uint32 txUnderflowErrorPacketsLow;                /**< \brief counter value for Tx Underflow Error Packets Low */
    uint64 txOctetCountGood64;                        /**< \brief counter value for Tx Octet Count Good Low and High */
    uint32 txPacketCountGoodLow;                      /**< \brief counter value for Tx Packet Count Good Low */
    uint32 txPausePacketsLow;                         /**< \brief counter value for Tx Pause Packets Low */
    uint32 txVlanPacketsGoodLow;                      /**< \brief counter value for Tx VLAN Packets Good Low */
    uint32 txLpiUsecCntr;                             /**< \brief counter value for Tx LPI USEC Cntr */
    uint32 txLpiTranCntr;                             /**< \brief counter value for Tx LPI Tran Cntr */
    uint32 rxPacketCountGoodBadLow;                   /**< \brief counter value for Rx Packet Count Good Bad Low */
    uint64 rxOctetCountGoodBad64;                     /**< \brief counter value for Rx Octet Count Good Bad Low and High */
    uint64 rxOctetCountGood64;                        /**< \brief counter value for Rx Octet Count Good Low and High */
    uint32 rxBroadcastPacketsGoodLow;                 /**< \brief counter value for Rx Broadcast Packets Good Low */
    uint32 rxMulticastPacketsGoodLow;                 /**< \brief counter value for Rx Multicast Packets Good Low */
    uint32 rxCrcErrorPacketsLow;                      /**< \brief counter value for Rx CRC Error Packets Low */
    uint32 rxRuntErrorPackets;                        /**< \brief counter value for Rx Runt Error Packets */
    uint32 rxJabberErrorPackets;                      /**< \brief counter value for Rx Jabber Error Packets */
    uint32 rxUndersizePacketsGood;                    /**< \brief counter value for Rx Undersize Packets Good */
    uint32 rxOversizePacketsGood;                     /**< \brief counter value for Rx Oversize Packets Good */
    uint32 rx64OctetsPacketsGoodBadLow;               /**< \brief counter value for Rx 64Octets Packets Good Bad Low */
    uint32 rx65to127OctetsPacketsGoodBadLow;          /**< \brief counter value for Rx 65To127Octets Packets Good Bad Low */
    uint32 rx128to255OctetsPacketsGoodBadLow;         /**< \brief counter value for Rx 128To255Octets Packets Good Bad Low */
    uint32 rx256to511OctetsPacketsGoodBadLow;         /**< \brief counter value for Rx 256To511Octets Packets Good Bad Low */
    uint32 rx512to1023OctetsPacketsGoodBadLow;        /**< \brief counter value for Rx 512To1023Octets Packets Good Bad Low */
    uint32 rx1024toMaxOctetsGoodBadLow;               /**< \brief counter value for Rx 1024ToMaxOctets Packets Good Bad Low */
    uint32 rxUnicastPacketsGoodLow;                   /**< \brief counter value for Rx Unicast Packets Good Low */
    uint32 rxLengthErrorPacketsLow;                   /**< \brief counter value for Rx Length Error Packets Low */
    uint32 rxOutOfRangePacketsLow;                    /**< \brief counter value for Rx OutofRange Packets Low */
    uint32 rxPausePacketsLow;                         /**< \brief counter value for Rx Pause Packets Low */
    uint32 rxFifoOverflowPacketsLow;                  /**< \brief counter value for Rx FIFOOverflow Packets Low */
    uint32 rxVlanPacketsGoodBadLow;                   /**< \brief counter value for Rx VLAN Packets Good Bad Low */
    uint32 rxWatchdogErrorPackets;                    /**< \brief counter value for Rx Watchdog Error Packets */
    uint32 rxLpiUsecCntr;                             /**< \brief counter value for Rx LPI USEC Cntr */
    uint32 rxLpiTranCntr;                             /**< \brief counter value for Rx LPI Tran Cntr */
    uint32 rxDiscardPacketsGoodBadLow;                /**< \brief counter value for Rx Discard Packets Good Bad Low */
    uint64 rxDiscardOctetsGoodBad64;                  /**< \brief counter value for Rx Discard Octets Good Bad Low and High */
    uint32 rxAligmentErrorPackets;                    /**< \brief counter value for Rx Alignment Error Packets */
    uint32 sgfPassPktCnt;                             /**< \brief counter value for SGF Pass PktCnt */
    uint32 sgfFailPktCnt;                             /**< \brief counter value for SGF Fail PktCnt */
    uint32 mmcTxFpeFragmentCntr;                      /**< \brief counter value for MMC Tx FPE Fragment Cntr */
    uint32 mmcTxHoldReqCntr;                          /**< \brief counter value for MMC Tx Hold Req Cntr */
    uint32 mmcRxPacketsAssemblyErrCntr;               /**< \brief counter value for MMC Rx Packet Assembly Err Cntr */
    uint32 mmcRxPacketsSmdErrCntr;                    /**< \brief counter value for MMC Rx Packet SMD Err Cntr */
    uint32 mmcRxPacketsAssemblyOkCntr;                /**< \brief counter value for MMC Rx Packet Assembly OK Cntr */
    uint32 mmcRxFpeFragmentCntr;                      /**< \brief counter value for MMC Rx FPE Fragment Cntr */
    uint32 txSingleCollisionGoodPackets;              /**< \brief counter value for Tx Single Collision Good Packets */
    uint32 txMultipleCollisionGoodPackets;            /**< \brief counter value for Tx Multiple Collision Good Packets */
    uint32 txDeferredPackets;                         /**< \brief counter value for Tx Deferred Packets */
    uint32 txLateCollisionPackets;                    /**< \brief counter value for Tx Late Collision Packets */
    uint32 txExcessiveCollisionPackets;               /**< \brief counter value for Tx Excessive Collision Packets */
    uint32 txCarrierErrorPackets;                     /**< \brief counter value for Tx Carrier Error Packets */
    uint32 txExcessiveDeferralError;                  /**< \brief counter value for Tx Excessive Deferral Error */
    uint32 rxIpV4GoodPacketsLow;                      /**< \brief counter value for RxIPv4 Good Packets Low */
    uint32 rxIpV4HeaderErrorPacketsLow;               /**< \brief counter value for RxIPv4 Header Error Packets Low */
    uint32 rxIpV4NoPayloadPacketsLow;                 /**< \brief counter value for RxIPv4 No Payload Packets Low */
    uint32 rxIpV4FragmentedPacketsLow;                /**< \brief counter value for RxIPv4 Fragmented Packets Low */
    uint32 rxIpV4UdpChecksumDisabledPacketsLow;       /**< \brief counter value for RxIPv4 UDP Checksum Disabled Packets Low */
    uint32 rxIpV6GoodPacketsLow;                      /**< \brief counter value for RxIPv6 Good Packets Low */
    uint32 rxIpV6HeaderErrorPacketsLow;               /**< \brief counter value for RxIPv6 Header Error Packets Low */
    uint32 rxIpV6NoPayloadPacketsLow;                 /**< \brief counter value for RxIPv6 No Payload Packets Low */
    uint32 rxUdpRxUdpGoodPacketsLow;                  /**< \brief counter value for RxUDP Good Packets Low */
    uint32 rxUdpErrorPacketsLow;                      /**< \brief counter value for RxUDP Error Packets Low */
    uint32 rxTcpGoodPacketsLow;                       /**< \brief counter value for RxTCP Good Packets Low */
    uint32 rxTcpErrorPacketsLow;                      /**< \brief counter value for RxTCP Error Packets Low */
    uint32 rxIcmpGoodPacketsLow;                      /**< \brief counter value for RxICMP Good Packets Low */
    uint32 rxIcmpErrorPacketsLow;                     /**< \brief counter value for RxICMP Error Packets Low */
    uint32 rxIpV4GoodOctetsLow;                       /**< \brief counter value for RxIPv4 Good Octets Low */
    uint32 rxIpV4HeaderErrorOctetsLow;                /**< \brief counter value for RxIPv4 Header Error Octets Low */
    uint32 rxIpV4NoPayloadOctetsLow;                  /**< \brief counter value for RxIPv4 No Payload Octets Low */
    uint32 rxIpV4FragmentedOctetsLow;                 /**< \brief counter value for RxIPv4 Fragmented Octets Low */
    uint32 rxIpV4UdpChecksumDisableOctetsLow;         /**< \brief counter value for RxIPv4 UDP Checksum Disable Octets Low */
    uint32 rxIpV6GoodOctetsLow;                       /**< \brief counter value for RxIPv6 Good Octets Low */
    uint32 rxIpV6HeaderErrorOctetsLow;                /**< \brief counter value for RxIPv6 Header Error Octets Low */
    uint32 rxIpV6NopayloadOctetsLow;                  /**< \brief counter value for RxIPv6 No Payload Octets Low */
    uint32 rxUdpGoodOctetsLow;                        /**< \brief counter value for RxUDP Good Octets Low */
    uint32 rxUdpErrorOctetsLow;                       /**< \brief counter value for RxUDP Error Octets Low */
    uint32 rxTcpGoodOctetsLow;                        /**< \brief counter value for RxTCP Good Octets Low */
    uint32 rxTcpErrorOctetsLow;                       /**< \brief counter value for RxTCP Error Octets Low */
    uint32 rxIcmpGoodOctetsLow;                       /**< \brief counter value for RxICMP Good Octets Low */
    uint32 rxIcmpErrorOctetsLow;                      /**< \brief counter value for RxICMP Error Octets Low */
} IfxGeth_Eth_MmcCounters;

/** \brief Configuration Structure for Tx PPS Output.
 * Refer to Ifx_GETH_PORT_CORE_MAC_PPS_CONTROL, Ifx_GETH_PORT_CORE_MAC_PPS<n>_TARGET_TIME_SECONDS, Ifx_GETH_PORT_CORE_MAC_PPS<n>_TARGET_TIME_NANOSECONDS, Ifx_GETH_PORT_CORE_MAC_PPS<n>_INTERVAL and Ifx_GETH_PORT_CORE_MAC_PPS<n>_WIDTH SFRs for more info.
 */
typedef struct
{
    boolean                        modePPS0;                  /**< \brief TRUE: Flexible mode is enabled for PPS0, FALSE: Fixed mode for PPS0 */
    boolean                        modePPS1;                  /**< \brief Flexible mode is enabled for PPS1, FALSE: Fixed mode for PPS1 */
    IfxGeth_PPSFrequency           frequencyPPS0;             /**< \brief Fixed mode frequency of PPS0 */
    IfxGeth_PPSTargetTimeMode      targetTimeModePPS0;        /**< \brief PPS0 Target Time Register Mode */
    IfxGeth_PPSTargetTimeMode      targetTimeModePPS1;        /**< \brief PPS1 Target Time Register Mode */
    IfxGeth_Eth_PpsInterruptConfig interruptConfigPPS0;       /**< \brief PPS0 Interrupt Configuration */
    IfxGeth_Eth_PpsInterruptConfig interruptConfigPPS1;       /**< \brief PPS1 Interrupt Configuration */
} IfxGeth_Eth_PPSConfig;

/** \brief Configuration for Remote wake-up
 *  Definition in MAC_PMT_CONTROL_STATUS Register
 */
typedef struct
{
    boolean                        powerDownEnable;                                       /**< \brief TRUE: MAC power down mode is enabled (Note: Before enabling this bit either of Magic Packet Enable, Global Unicast, or Remote Wake-Up Packet Enable bit should be set high) FALSE: MAC is reverted back to default behavior */
    boolean                        magicPktEnable;                                        /**< \brief TRUE: MAC is waked-up  FALSE: MAC TX is in Normal mode */
    boolean                        rwkPktEnable;                                          /**< \brief TRUE: MAC TX has exited the LPI mode  FALSE: MAC TX still in LPI mode */
    boolean                        unicastPktEnable;                                      /**< \brief TRUE: MAC RX has entered the LPI mode FALSE: MAC RX is in Normal mode */
    boolean                        rwkPktFwdEnable;                                       /**< \brief TRUE: MAC RX has exited the LPI mode  FALSE: MAC RX still in LPI mode */
    boolean                        rwkInterruptEnable;                                    /**< \brief TRUE: Enable, FALSE: Disable the interrupt for LPI entry/exit */
    IfxGeth_Eth_RwkUpFilterConfig *rwkFilterConfig[IFXGETH_NUM_RWKUP_FILTER_BLOCK];       /**< \brief reference ptr for filter configuration */
} IfxGeth_Eth_RemoteWakeUpConfig;

/** \brief Structure for Rx Descriptor Status updated by DMA
 */
typedef struct
{
    IfxGeth_Eth_RxDescNormalStatus  normal;        /**< \brief Rx Normal Descriptor Write back status */
    IfxGeth_Eth_RxDescContextStatus context;       /**< \brief Rx Context Descriptor Write back status */
} IfxGeth_Eth_RxDescStatus;

/** \brief Configuration Structure for (non vlan) Rx packets to Queue mapping.
 * Refer to Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL1 and Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL4 SFRs for more info.
 */
typedef struct
{
    IfxGeth_RxMtlQueue            untaggedPacketQueue;                             /**< \brief Destination Rx Queue for untagged packets. */
    IfxGeth_RxMtlQueue            residualPacketQueue;                             /**< \brief Destination Rx Queue for residual packets. Must not be 0 since it is reserved for express frames. */
    IfxGeth_RxMtlQueue            multicastOrBroadcastPacketQueue;                 /**< \brief Destination Rx Queue for multicast or broadcast packets. */
    IfxGeth_RxMtlQueue            preemptiveMulticastOrBroadcastPacketQueue;       /**< \brief Destination Rx Queue to which the preemptive Multicast/Broadcast packets passing the Destination or Source Address filter or the VLAN tag filter must be routed. This field is valid only when the MCBCQEN bit of MAC_RxQ_Ctrl1 register is set through multicastOrBroadcastRoutingEnable. */
    boolean                       multicastOrBroadcastRoutingEnable;               /**< \brief TRUE: packets are routed to rx queue as per multicastOrBroadcastPacketQueue (MCBCQ) setting */
    boolean                       overrideMulticastOrBroadcastRouting;             /**< \brief TRUE: enables over-riding the MCBC Queue priority (MCBC has lower priority in priority list), FALSE: disables over-riding the MCBC Queue priority (MCBC has higher priority in priority list) */
    IfxGeth_TaggedPtpQueueControl ptpQueueSelect;                                  /**< \brief Destination selection for PTP packets. */
    IfxGeth_RxMtlQueue            ptpPacketQueue;                                  /**< \brief Destination Rx Queue for untagged PTP packets. */
    boolean                       taggedAVQueueDestinationSelection;               /**< \brief TRUE: Destination Rx Queue for tagged AV control packets is as per avPacketQueue (Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL1.B.AVCPQ), FALSE: Destination Rx Queue for tagged AV control packets is as per vlan destination queues (PSRQs of Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL2 and Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL3). Note: If the Tagged AV Control packets received are expected to be preempted then TACPQE bit must not be set to enable a separate queue */
    IfxGeth_RxMtlQueue            avPacketQueue;                                   /**< \brief Destination Rx Queue for both tagged and untagged Audio Video Control packets. */
} IfxGeth_Eth_RxRoutingConfig;

/** \brief Configuration Structure for initializing System Time and Timestamp features.
 * Refer to Ifx_GETH_PORT_CORE_MAC_TIMESTAMP_CONTROL.B.TSUPDT, MAC_SYSTEM_TIME_SECONDS_UPDATE, MAC_SYSTEM_TIME_NANOSECONDS_UPDATE, SFRs for more info.
 */
typedef struct
{
    uint32  seconds;                               /**< \brief 32 bits of Seconds[31:0] part of System Time initialization. */
    uint32  subSeconds;                            /**< \brief 31 bit Sub Seconds part of System Time initialization. */
    uint16  highWordSeconds;                       /**< \brief 16 bit Higher word Seconds [48:32] part of System Time initialization. Once initialised, it updates when seconds part of System Time overflows. */
    uint8   subSecondIncrementValue;               /**< \brief 8 bit of Sub Second Increment Value. Refer to User Manual Register Description of SSINC bitfield of MAC_SUB_SECOND_INCREMENT register. */
    uint8   subNanoSecondIncrementValue;           /**< \brief 8 bit of Sub Nano Second Increment Value. Refer to User Manual Register Description of SNSINC bitfield of MAC_SUB_SECOND_INCREMENT register. */
    boolean updateMethod : 1;                      /**< \brief TRUE: Fine Update, FALSE: Coarse Update */
    uint32  ingressAsymCorrection;                 /**< \brief One-Step Timestamp Ingress Asymmetry Correction */
    uint32  egressAsymCorrection;                  /**< \brief One-Step Timestamp Egress Asymmetry Correction */
    boolean enableForAllPackets : 1;               /**< \brief TRUE: Enable Timestamp for All Rx Packets */
    boolean rolloverControl : 1;                   /**< \brief Timestamp Rollover Control. TRUE: Digital Rollover at 1ns (0x3B9A_C9FF) FALSE: Binary Rollover at 0x7FFF_FFFF */
    boolean ptpVersion : 1;                        /**< \brief TRUE: IEEE 1588 version 2 format is used to process the PTP packets, FALSE: IEEE 1588 version 1 format is used. */
    boolean enablePtpOverEthernet : 1;             /**< \brief TRUE: MAC receiver processes the PTP packets encapsulated directly in the Ethernet packets, FALSE: PTP over Ethernet packet is ignored. */
    boolean enablePtpOverIpv6Udp : 1;              /**< \brief TRUE: MAC receiver processes the PTP packets encapsulated in IPv6-UDP packets, FALSE: PTP over IPv6-UDP packet is ignored. */
    boolean enablePtpOverIpv4Udp : 1;              /**< \brief TRUE: MAC receiver processes the PTP packets encapsulated in IPv4-UDP packets, FALSE: PTP over IPv4-UDP packet is ignored. Default-Reset Value is 1. */
    boolean snapshotMessageControl : 1;            /**< \brief Enable Timestamp Snapshot for Event Messages. TRUE: timestamp snapshot is taken only for event messages, FALSE: the snapshot is taken for all messages except Announce, Management, and Signaling. */
    boolean snapshotNodeControl : 1;               /**< \brief Enable Snapshot for Messages Relevant to Master/Slave. TRUE: snapshot is taken only for the messages that are relevant to the master node, FALSE: snapshot is taken for the messages relevant to the slave node. */
    uint8   snapshotType : 2;                      /**< \brief Select PTP packets for Taking Snapshots. This along with snapshotMessageControl and snapshotNodeControl decide the set of PTP packet types for which snapshot needs to be taken. Refer to Table: "MAC Transmit PTP Mode" in UM. */
    boolean enableMacAddressFilter : 1;            /**< \brief TRUE: DA MAC address (that matches any MAC Address register) is used to filter the PTP packets when PTP is directly sent over Ethernet. */
    boolean enableOstChecksumCorrection : 1;       /**< \brief Checksum Update control during One Step TimeStamp Correction. TRUE: Last two bytes of PTP message sent over UDP/IPv4 is updated to keep the UDP checksum correct, for changes made to origin timestamp and/or correction field as part of one step timestamp operation. The application must form the packet with these two dummy bytes. FALSE: No updates are done to keep the UDP checksum correct. The application must form the packet with UDP checksum set to 0. */
    boolean systemTimeSource : 1;                  /**< \brief TRUE: External 64-bit reference System Time is used. (Reference clock from other MAC is used. Applicable only in derivatives with 2 MAC/PORTs).  FALSE: Internal reference System Time is used. */
    boolean txTimeStampUpdateMode : 1;             /**< \brief Transmit Time Stamp Status Update Control. TRUE: MAC overwrites the earlier transmit timestamp status even if it is not read by the software. FALSE: MAC ignores the timestamp status of current packet if the timestamp status of previous packet is not read by the software. */
    boolean enableAvIeee8021AsMode : 1;            /**< \brief TRUE: AV IEEE 802.1AS Mode of operation is enabled. MAC processes only untagged PTP over Ethernet packets for providing PTP status. */
    uint32  ingressCorrectionNanoSeconds;          /**< \brief 32 bit Ingress TimeStamp Correction value (Nanoseconds). Used to compensate the errors due to timestamp synchronization from the PTP clock domain to the MAC Rx clock domain, and the latency incurred between the message timestamp point and the point at which the timestamp snapshot is taken */
    uint32  egressCorrectionNanoSeconds;           /**< \brief 32 bit Egress TimeStamp Correction value (Nanoseconds). Used to compensate the errors due to timestamp synchronization from PTP clock domain to MAC Tx clock domain, and the latency incurred between the point at which the timestamp snapshot is taken and the message timestamp point */
    uint8   ingressCorrectionSubNanoSeconds;       /**< \brief 8 bit Ingress TimeStamp Correction value (SubNanoseconds). Used along with ingressCorrectionNanoSeconds */
    uint8   egressCorrectionSubNanoSeconds;        /**< \brief 8 bit Egress TimeStamp Correction value (SubNanoseconds). Used along with egressCorrectionNanoSeconds */
} IfxGeth_Eth_TimeStampConfig;

/** \brief Structure for Tx Descriptor Status updated by DMA
 * Refer to Tx Descriptor Write Back Format
 */
typedef struct
{
    boolean error : 1;                   /**< \brief True: Descriptor content is incorrect. False: Descriptor content is correct. */
    boolean isLastDescriptor : 1;        /**< \brief True: Indicates Last descriptor of packet. */
    boolean isFirstDescriptor : 1;       /**< \brief True: Indicates First segment of packet. */
    boolean isContextDescriptor : 1;     /**< \brief True: Context Descriptor. False: Normal Descriptor. */
    boolean own : 1;                     /**< \brief True: DMA owns Descriptor. False: Application owns Descriptor. */
} IfxGeth_Eth_TxDescStatus;

/** \brief Configuration Structure for Tx Traffic Class.
 * Refer to Ifx_GETH_PORT_MTL_TCQn_TCn_ETS_CONTROL, Ifx_GETH_PORT_MTL_TCQn_TCn_QUANTUM_WEIGHT, Ifx_GETH_PORT_MTL_TCQn_TCn_SENDSLOPECREDIT, Ifx_GETH_PORT_MTL_TCQn_TCn_HICREDIT and Ifx_GETH_PORT_MTL_TCQn_TCn_LOCREDIT SFRs for more info.
 */
typedef struct
{
    IfxGeth_TxTrafficClass                   tcIndex;                  /**< \brief Traffic Class Instance to be configured */
    IfxGeth_TxTransmissionSelectionAlgorithm algorithm;                /**< \brief Transmission Selection Algorithm (TSA) */
    boolean                                  creditControl;            /**< \brief Credit Accumulation Control. Applies if TSA is CBS (AVB Feature). TRUE: The accumulated credit parameter in the CBS algorithm logic is not reset to zero when there is positive credit and no packet to transmit in TC(#n), FALSE: The accumulated credit parameter in the CBS algorithm logic is set to zero when there is positive credit and no packet to transmit in TC(#n). */
    IfxGeth_TxSlotCount                      slotCount;                /**< \brief Number of Slots to calculate status in MTL_TC(#n)_ETS_Status. Applies if TSA is CBS (AVB Feature). */
    uint8                                    wrrWeight;                /**< \brief Weightage of this Traffic Class. Applies if TSA is ETS and ETSALG is WRR (Weighted Round Robin). Max Value is 0x64. */
    uint16                                   cbsIdleSlopeCredit;       /**< \brief 16 bit Idle Slope Credit Value. Applies if TSA is CBS (AVB Feature) */
    uint16                                   cbsSendSlopeCredit;       /**< \brief 16 bit Send Slope Credit Value. Applies if TSA is CBS (AVB Feature) */
    uint32                                   cbsHiCredit;              /**< \brief 29 bit Hi Credit Value. Applies if TSA is CBS (AVB Feature) */
    uint32                                   cbsLoCredit;              /**< \brief 29 bit Lo Credit Value, it is a negative number in two's complement format. Applies if TSA is CBS (AVB Feature) */
} IfxGeth_Eth_TxTrafficClassConfig;

/** \brief Configuration Structure for updating System Time.
 * Refer to Ifx_GETH_PORT_CORE_MAC_TIMESTAMP_CONTROL.B.TSUPDT, MAC_SYSTEM_TIME_SECONDS_UPDATE and MAC_SYSTEM_TIME_NANOSECONDS_UPDATE SFRs for more info.
 */
typedef struct
{
    boolean addSubControl;       /**< \brief True: Time value is subtracted from System Time. False: Time value is added to System Time. */
    uint32  seconds;             /**< \brief Seconds part of the update. For subtraction, the update value must be in two's complement form. */
    uint32  subSeconds;          /**< \brief 31 bit Sub Seconds part of the update. For subtraction, the update value must be in two's complement form. */
} IfxGeth_Eth_UpdateSystemTimeConfig;

/** \brief Configuration Structure for MAC VLAN Tag Data and Control Registers.
 * Refer to Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_DATA and Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL SFRs for more info.
 */
typedef struct
{
    uint16               rxVLanTag;                   /**< \brief 16 bit VLAN Tag ID for Rx packets */
    boolean              enableVLanFilter;            /**< \brief Enable(if True)/Disable(if False) the VLAN Filter. Filtering takes place only if this is enabled. */
    boolean              vLanTagSize;                 /**< \brief Length of VLAN Tag to be used for comparison. True: 12-bit VLAN identifier is used, False: All 16-bits of the VLAN identifier are used. */
    boolean              disableTypeCheck;            /**< \brief TRUE: MAC does not check whether the VLAN Tag specified by the ERIVLT bit (Inner/Outer Tag) is of type S-VLAN or C-VLAN, FALSE: the MAC filters or matches the VLAN Tag specified by the ERIVLT bit only when VLAN Tag type is similar to the one specified by the ERSVLM bit. */
    boolean              rxMatchFilterType;           /**< \brief VLAN Filter Type for received packets, True: S-VLAN Type packets, False: C-VLAN Type packets. */
    boolean              doubleVLanTagPosition;       /**< \brief Selection of the Tag for VLAN hash filtering. TRUE: Inner VLAN Tag is selected (if present), FALSE: Outer VLAN Tag is selected (if present). */
    boolean              enableDmaRouting;            /**< \brief TRUE: Packet is routed to the DMA Channel configured based on result of VLAN Filter, FALSE: Routing does not occur based on VLAN Filter result and instead routing is based on DA Based DMA Channel Routing. */
    IfxGeth_RxDmaChannel rxDmaChannel;                /**< \brief The DMA Channel number to which the VLAN Tagged Packet is to be routed if it passes this VLAN Tag Filter */
    uint8                filterOffset;                /**< \brief Offset of Vlan Filter to be configured (0-7). Programmed in Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL.OFS */
} IfxGeth_Eth_VlanFilterConfig;

/** \brief Configuration Structure for VLAN Tag Inclusion Control Registers.
 */
typedef struct
{
    IfxGeth_Eth_VlanOuterInclusionConfig outerTag;       /**< \brief Structure for Outer VLAN Tag Inclusion Configuration */
    IfxGeth_Eth_VlanInnerInclusionConfig innerTag;       /**< \brief Structure for Inner VLAN Tag Inclusion Configuration */
} IfxGeth_Eth_VlanInclusionConfig;

/** \brief Configuration Structure for Rx Vlan packet to Queue mapping.
 * More than one Rx Queue cannot be assigned the same VLAN Tag priority.
 * However, more than one VLAN Tag priorities can be assigned to the same Rx Queue.
 * Refer to Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL2, Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL3 and Ifx_GETH_PORT_CORE_MAC_RXQ_CTRL5 SFRs for more info.
 */
typedef struct
{
    IfxGeth_RxMtlQueue          offset;                                          /**< \brief Start offset of the priority queues (PSRQ). Default is 0. Any higher offset will limit configuration of higher PSRQs. Refer to Note in UM:Selection of Tag Priorities Assigned to Tx and Rx Queues */
    IfxGeth_VlanPsrqConfigUnion rxQueuePriorityMap[IFXGETH_NUM_RX_QUEUES];       /**< \brief USP Map of Vlan Tagged packets assigned to corresponding Rx Queue. Same bit should not be enabled for different queues, must be mutually exclusive. */
} IfxGeth_Eth_VlanRxRoutingConfig;

/** \brief Configuration Structure for MAC VLAN Tag Control Register.
 * Refer to Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL and Ifx_GETH_PORT_CORE_MAC_VLAN_HASH_TABLE SFRs for more info.
 */
typedef struct
{
    uint16                   hashTableValue;                 /**< \brief 16 bit Hash Table Value used for matching */
    boolean                  enableVLanHashFilter;           /**< \brief Enable(if True)/Disable(if False) the VLAN Tag Hash Table Match Filter */
    boolean                  vLanTagSize;                    /**< \brief Length of VLAN Tag to be used for comparison during VLAN Hash Filtering. True: 12-bit VLAN identifier is used, False: All 16-bits of the VLAN identifier are used. */
    boolean                  enableInverseMatch;             /**< \brief Enable(if True)/Disable(if False) the Inverse Filtering mode where the result of the match filter is inverted. */
    boolean                  enableSVLan;                    /**< \brief Enable(if True)/Disable(if False) the S-VLAN type packets. When this bit is set, the MAC transmitter and receiver will consider the S-VLAN packets (Type = 0x88A8) as valid VLAN tagged packets. */
    boolean                  rxMatchFilterType;              /**< \brief VLAN Hash Filter Type for received packets, True: S-VLAN Type packets, False: C-VLAN Type packets. */
    boolean                  disableTypeCheck;               /**< \brief TRUE: MAC does not check whether the VLAN Tag specified by the ERIVLT bit (Inner/Outer Tag) is of type S-VLAN or C-VLAN, FALSE: the MAC filters or matches the VLAN Tag specified by the ERIVLT bit only when VLAN Tag type is similar to the one specified by the ERSVLM bit (as configured in rxMatchFilterType). */
    IfxGeth_VlanTagStripType outerTagStripType;              /**< \brief Indicates the stripping operation on the outer VLAN Tag in received packets */
    IfxGeth_VlanTagStripType innerTagStripType;              /**< \brief Indicates the stripping operation on the inner VLAN Tag in received packets */
    boolean                  enableOuterTagInRxStatus;       /**< \brief TRUE: MAC provides the outer VLAN Tag in the Rx status, FALSE: MAC does not provide the outer VLAN Tag in the Rx status */
    boolean                  enableInnerTagInRxStatus;       /**< \brief TRUE: MAC provides the inner VLAN Tag in the Rx status, FALSE: MAC does not provide the inner VLAN Tag in the Rx status */
    boolean                  enableDoubleVLan;               /**< \brief TRUE: Enables processing of up to two VLAN Tags on Tx and Rx (if present), FALSE: Enables processing of up to one VLAN Tag on Tx and Rx (if present). */
    boolean                  doubleVLanTagPosition;          /**< \brief Selection of the Tag for VLAN hash filtering. TRUE: Inner VLAN Tag is selected (if present), FALSE: Outer VLAN Tag is selected (if present). */
} IfxGeth_Eth_VlanTagCtrlConfig;

/** \} */

/** \addtogroup IfxLld_Geth_Eth_DataStructures
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/
#ifdef IFXGETH_ADVANCED
/** \brief API to init Layer3 filtering for IPv4 Frame format
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config configuration for IPv4 layer 3 filter initialization parameter's
 * \return status TRUE : Init failed due to timeoutError FALSE : Init Successful
 */
IFX_EXTERN boolean IfxGeth_Eth_initL3FilteringIPv4(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_L3FilterIPv4Config *config);
#endif

/** \} */

/** \addtogroup IfxLld_Geth_Eth_MAC_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures the MAC core
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param macConfig Configuration Structure for the MAC initialization
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_configureMacCore(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MacConfig *macConfig);

/** \} */

/** \addtogroup IfxLld_Geth_Eth_Module_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Waits for one TX buffer becomes available
 * \param geth GETH driver Handle
 * \param channelId Tx channel Id
 * retval non NULL_PTR TX buffer is available at the address pointed by the returned value
 * retval NULL_PTR TX buffer is busy.
 *
 * \code
 *
 * // get free buffer
 *  uint8 *pTxBuf = (uint8*) IfxGeth_Eth_waitTransmitBuffer(&geth, IfxGeth_TxDmaChannel_0);
 *
 * \endcode
 */
IFX_INLINE void *IfxGeth_Eth_waitTransmitBuffer(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId);

/** \} */

/** \addtogroup IfxLld_Geth_Eth_MTL_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures the MTL
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param mtlConfig Configuration Structure for the MTL initialisation
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_configureMTL(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MtlConfig *mtlConfig);

/** \} */

/** \addtogroup IfxLld_Geth_Eth_DMA_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the pointer to current RX descriptor
 * \param geth GETH driver Handle
 * \param channelId Rx channel Id
 * \return pointer to base RX descriptor in the list
 *
 * \code
 *    // IfxGeth_Eth geth; // assumed to be defined globally
 *
 *    IfxGeth_RxDescr  *descr = IfxGeth_Eth_getActualRxDescriptor(&geth, IfxGeth_RxDmaChannel_0);
 *    \endcode
 */
IFX_INLINE volatile IfxGeth_RxDescr *IfxGeth_Eth_getActualRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId);

/** \brief Returns the pointer to current TX descriptor
 * \param geth GETH driver Handle
 * \param channelId Tx channel Id
 * \return pointer to base TX descriptor in the list
 *
 * \code
 *    // IfxGeth_Eth geth; // assumed to be defined globally
 *
 *    IfxGeth_TxDescr *descr = IfxGeth_Eth_getActualTxDescriptor(&geth, IfxGeth_TxDmaChannel_0);
 *    \endcode
 */
IFX_INLINE volatile IfxGeth_TxDescr *IfxGeth_Eth_getActualTxDescriptor(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId);

/** \brief Checks whether one or more RX data is available
 * \param geth GETH driver Handle
 * \param channelId Rx channel Id
 * \return TRUE : if one or more RX data available
 * FALSE: if Rx data not available
 *
 * \code
 * // IfxGeth_Eth geth; // assumed to be defined globally
 *
 * boolean status = IfxGeth_Eth_isRxDataAvailable(&geth, IfxGeth_RxDmaChannel_0);
 * \endcode
 */
IFX_INLINE boolean IfxGeth_Eth_isRxDataAvailable(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId);

/** \brief Returns the pointer to base TX descriptor in the list
 * \param geth GETH driver Handle
 * \param channelId Tx channel Id
 * \return pointer to base TX descriptor in the list
 *
 * \code
 *    // IfxGeth_Eth geth; // assumed to be defined globally
 *
 *    IfxGeth_TxDescr *descr = IfxGeth_Eth_getBaseTxDescriptor(&geth, IfxGeth_TxDmaChannel_0);
 *    \endcode
 */
IFX_INLINE volatile IfxGeth_TxDescr *IfxGeth_Eth_getBaseTxDescriptor(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId);

/** \brief Returns the pointer to base RX descriptor in the list
 * \param geth GETH driver Handle
 * \param channelId Rx channel Id
 * \return pointer to base RX descriptor in the list
 *
 * \code
 * // IfxGeth_Eth geth; // assumed to be defined globally
 *
 * IfxGeth_RxDescr *descr = IfxGeth_Eth_getBaseRxDescriptor(&geth, IfxGeth_RxDmaChannel_0);
 * \endcode
 */
IFX_INLINE volatile IfxGeth_RxDescr *IfxGeth_Eth_getBaseRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId);

/** \} */

/** \addtogroup IfxLld_Geth_Eth_Bridge_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures the Bridge
 * \param geth GETH driver Handle
 * \param config Configuration Structure for the Bridge initialisation
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initBridge(IfxGeth_Eth *geth, IfxGeth_Eth_BridgeConfig *config);

/** \brief Initialises the bridge configuration structure with default values
 * \param config Configuration Structure for the Bridge initialisation
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initBridgeConfig(IfxGeth_Eth_BridgeConfig *config);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Gets receive buffer\n
 * \param geth GETH driver Handle
 * \param channelId Rx channel Id
 * \return retval NULL_PTR no received frame
 * retval !NULL_PTR a frame has been received
 *
 * \code
 * // IfxGeth_Eth geth; // assumed to be defined globally
 *
 * uint8 *pRxBuf = (uint8*)IfxGeth_Eth_getReceiveBuffer(&geth, IfxGeth_RxDmaChannel_0);
 * \endcode
 * note: IfxGeth_Eth_shuffleRxDescriptor() shall be called after the data from the RX buffer has been processed
 */
IFX_EXTERN void *IfxGeth_Eth_getReceiveBuffer(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId);

/** \brief Get the transmit buffer pointer of current descriptor
 * \param geth GETH driver Handle
 * \param channelId Tx channel Id
 * \return retval NULL_PTR no free transmit buffer is available
 * retval !NULL_PTR a free transmit buffer is available
 */
IFX_EXTERN void *IfxGeth_Eth_getTransmitBuffer(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId);

/** \brief Initialises the Geth Module with given configuration
 * \param geth GETH driver Handle
 * \param config Configuration Structure for the Module initialisation
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initModule(IfxGeth_Eth *geth, IfxGeth_Eth_Config *config);

/** \brief Initialises the config structure with default values
 * \param config Configuration Structure for the Module initialisation
 * \param gethSFR Pointer to GETH register base address
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initModuleConfig(IfxGeth_Eth_Config *config, Ifx_GETH *gethSFR);

/** \brief writes the header format into buffer
 * \param txBuffer pointer to tx buffer
 * \param destinationAddress pointer to destination address
 * \param sourceAddress pointer to source address
 * \param payloadLength size of the payload
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_writeHeader(uint8 *txBuffer, uint8 *destinationAddress, uint8 *sourceAddress, uint32 payloadLength);

/** \brief Configures the DMA
 * \param geth GETH driver Handle
 * \param dmaConfig Configuration Structure for the DMA initialisation
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_configureDMA(IfxGeth_Eth *geth, IfxGeth_Eth_DmaConfig *dmaConfig);

/** \brief Initialises the Rx descriptors of a single channel
 * \param geth GETH driver Handle
 * \param config Rx channel configuration
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initReceiveDescriptors(IfxGeth_Eth *geth, IfxGeth_Eth_RxChannelConfig *config);

/** \brief Initialises the Tx descriptors of a single channel
 * \param geth GETH driver Handle
 * \param config Tx channel configuration
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initTransmitDescriptors(IfxGeth_Eth *geth, IfxGeth_Eth_TxChannelConfig *config);

/** \brief Transmits a frame from a single channel
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Tx Frame configuration
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_sendFrame(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FrameConfig *config);

/** \brief Transmits a frame from a single channel
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param packetLength Length of the packet to be transmitted in bytes
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_sendTransmitBuffer(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint32 packetLength, IfxGeth_TxDmaChannel channelId);

/** \brief Updates the current Rx descriptor pointer in the handle to next Rx descriptor
 * \param geth GETH driver Handle
 * \param channelId Rx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_shuffleRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId);

/** \brief Updates the current Tx descriptor pointer in the handle to next Tx descriptor
 * \param geth GETH driver Handle
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_shuffleTxDescriptor(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId);

/** \brief Start the Receiver functions of MAC and selected channel of DMA
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param channelId Rx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_startReceiver(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_RxDmaChannel channelId);

/** \brief Start the transmitter functions of MAC and selected channel of DMA
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_startTransmitter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_TxDmaChannel channelId);

/** \brief Wakes up the Receiver functions of MAC and selected channel of DMA
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param channelId Rx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_wakeupReceiver(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_RxDmaChannel channelId);

/** \brief Wakes up the transmitter functions of MAC and selected channel of DMA
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_wakeupTransmitter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_TxDmaChannel channelId);

/** \brief Stop the transmitter functions of MAC and selected channel of DMA
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_stopTransmitter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_TxDmaChannel channelId);

/** \brief Stops the Receiver functions of MAC and selected channel of DMA
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param channelId Rx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_stopReceiver(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_RxDmaChannel channelId);

/** \brief Free the receive buffer, enabling it for the further reception
 * \param geth GETH driver Handle
 * \param channelId Rx channel Id
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_freeReceiveBuffer(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId);
#ifdef IFXGETH_ADVANCED
/** \brief Used to Configure the additional MAC Address Filters (Ifx_GETH_PORT<port_index>_CORE_MACADDRESS(1-31)) one at a time, using the particular index (config->index).
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure pointer for MAC Address Filter
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initMacAddressFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MacAddressFilterConfig *config);

/** \brief Configure MAC Packet Filter of the corresponding Port
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure pointer for MAC Packet Filter
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initMacPacketFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MacPacketFilterConfig *config);

/** \brief Configure MAC RX ETH TYPE MATCH Filter of the corresponding Port
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param ethernetType This field holds the Rx Ethernet Type value used for length/type matching, must be programmed with values greater than or equal to 1536, else value is ignored by Hw
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initMacRxEthTypeFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint16 ethernetType);

/** \brief Configure MAC VLAN Tag Filter Control of the corresponding Port
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure pointer for MAC VLAN Tag Filter Control and Hash Table values
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initVLanTagFilterControl(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanTagCtrlConfig *config);

/** \brief Configure MAC VLAN Tag Filters of the corresponding Port
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure pointer for MAC VLAN Tag Filter Data and Filter Offset
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_writeVLanFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanFilterConfig *config);

/** \brief Returns MAC VLAN Tag Filter value of the corresponding Port and Filter
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param filterOffset Offset of the required filter (0-7)
 * \return filter value
 */
IFX_EXTERN uint32 IfxGeth_Eth_readVLanFilter(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 filterOffset);

/** \brief Configures Rx packet Routing for packets failing respective filters
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure for MAC RxQ Ctrl4 Register
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_rxFilterFailPacketRouting(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FailPacketRoutingConfig *config);

/** \brief Configures Inner and Outer Vlan Tag Inclusion features
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for Inner and Outer Vlan Tag Inclusion configuration parameters
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_txVlanTagInclusionControl(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanInclusionConfig *config);

/** \brief Configures the Tx and Rx flexible header features
 * Note: +8 must be mandatorily added by application to the tx and rx packet length irrespective of actual length (1-8) of flexible header on the line
 * Refer to Flexible Header Feature section in Functional Description Chapter of UM for usage and restrictions of this feature.
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for Flexible Header configuration parameters
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_flexibleHeaderInit(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FlexHeaderConfig *config);

/** \brief Configures the routing map of tagged Vlan rx packets with given USP IDs to available Rx Queues in MTL layer.
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for Rx Vlan packet to Queue map
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_rxVlanPacket2QueueMap(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_VlanRxRoutingConfig *config);

/** \brief Configures the destination rx queues for the corresponding received packet type - untagged, residual, MCBC, PTP and AV
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for destination rx queue configuration for the various types of Rx packets
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_rxPacket2QueueMap(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_RxRoutingConfig *config);

/** \brief MDIO API for single write transfer
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Config for MDIO Single write parameter
 * \return MDIO Transfer status TRUE : MDIO Transfer Failed FALSE : MDIO Transfer Success
 */
IFX_EXTERN boolean IfxGeth_Eth_mdioSingleWrite(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioSingleWriteConfig *config);

/** \brief MDIO API for single read transfer
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Config for MDIO Single Read  parameter
 * \return MDIO Transfer status TRUE : MDIO Transfer Failed FALSE : MDIO Transfer Success
 */
IFX_EXTERN boolean IfxGeth_Eth_mdioSingleRead(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioSingleReadConfig *config);

/** \brief MDIO API for Continuous read scan
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Config for MDIO continuous start scan parameter
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_mdioContinuousStartScan(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioContinuousStartScanConfig *config);

/** \brief MDIO API for Continuous Write
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Config for MDIO Continuous Write parameter
 * \return MDIO Transfer status TRUE : MDIO Transfer Failed FALSE : MDIO Transfer Success
 */
IFX_EXTERN boolean IfxGeth_Eth_mdioContinuousWrite(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioContinuousWriteConfig *config);

/** \brief API for MDIO transfer Initialization
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param mdioModeSelectionType Configure the MDIO mode type SINGLE/CONTINUOUS transfer
 * \param config Configure the MDIO Init parameter for single/continuous MDIO transfer
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initMdio(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_MdioModeSelectionType mdioModeSelectionType, void *config);

/** \brief MDIO API for Continuous stop scan
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Configure for MDIO continuous stop scan parameter
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_mdioContinuousStopScan(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MdioContinuousStopScanConfig *config);

/** \brief API for MMC Initialization
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param mmcConfig to configure the MMC control and interrupt register's
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initMmc(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MmcConfig *mmcConfig);

/** \brief API to read the values of all MMC counters. The API will also clear all the MMC interrupt status bits if reset on read MMC_CONTROL.B.RSTONRD = 1 is enabled
 * \param geth GETH driver Handle
 * \param portIndex port index
 * \param mmcCounters pointer reference for counter values
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_readMmcCounterReg(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_MmcCounters *mmcCounters);

/** \brief Initialises the Tx descriptor of a single channel as context descriptor at the current descriptor location in the ring of descriptors.
 * \param geth GETH driver Handle
 * \param config Tx channel configuration
 * \return status of initialization, TRUE: DMA accepts the new context, FALSE: DMA has thrown an error and did not accept the new context values.
 */
IFX_EXTERN boolean IfxGeth_Eth_initTxContextDescriptor(IfxGeth_Eth *geth, IfxGeth_Eth_TxChannelConfig *config);

/** \brief Initialises the features of a particular MTL Tx Traffic Class (selected by config->tcIndex) including Transmission Selection Algorithms (SP, WRR, CBS). Call once per Traffic Class.
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for Tx Traffic Class parameters
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initTxTrafficClass(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_TxTrafficClassConfig *config);

/** \brief Initializes System Time and TimeStamp configuration for PTP and Flexible PPS.
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for Timstamp, PTP and System Time Config parameters
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initTimeStamp(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_TimeStampConfig *config);

/** \brief API to perform coarse update of system time.
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for System Time Update Config parameters
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_updateSystemTime(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_UpdateSystemTimeConfig *config);

/** \brief API to perform fine update of system time using Addend register. Must be tuned and used for limited time until synchronization is achieved.
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param value 32-bit time value to be added to the Accumulator register per PTP clock cycle to achieve time synchronization.
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_updateTimeStampAddend(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint32 value);

/** \brief Initialises PPS Configuration for available PPS channels of a given port and also selects the frequency for Fixed mode of PPS0.
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for PPS Config parameters
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_initPPS(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_PPSConfig *config);

/** \brief Run Time Flexible PPS commands are initiated for selected PPS channels of a given port. Pre-requisite: PPS intialisation to be performed using IfxGeth_Eth_initPPS() and system time initialization using IfxGeth_Eth_initTimeStamp().
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config Structure for Flexible PPS Config parameters
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_flexiblePPSControl(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_FlexiblePPSConfig *config);

/** \brief API to capture Tx Descriptor status written by DMA.
 * \param geth GETH driver Handle
 * \param txDescrPtr Address of Tx Descriptor
 * \param status Structure pointer to capture status values
 * \return Availability of Status TRUE: Status is available and captured. FALSE: DMA has not released the descriptor and status was not captured.
 */
IFX_EXTERN boolean IfxGeth_Eth_getTxDescriptorStatus(IfxGeth_Eth *geth, IfxGeth_TxDescr *txDescrPtr, IfxGeth_Eth_TxDescStatus *status);

/** \brief API to capture Rx Descriptor status written by DMA. Call once per descriptor. If in the normal descriptor status CDA is 1, call the API again after updating the rxDescrPtr to next descriptor address to capture status of context descriptor values.
 * \param geth GETH driver Handle
 * \param rxDescrPtr Address of Rx Descriptor
 * \param status Structure pointer to capture status values
 * \return Availability of Status TRUE: Status is available and captured. FALSE: DMA has not released the descriptor and status was not captured.
 */
IFX_EXTERN boolean IfxGeth_Eth_getRxDescriptorStatus(IfxGeth_Eth *geth, IfxGeth_RxDescr *rxDescrPtr, IfxGeth_Eth_RxDescStatus *status);

/** \brief Slot function initialisation for DMA Channels supporting AVB. The slotnumber for the packet must be programmed in the Tx Descriptor. Pre-requisite: System time initialization using IfxGeth_Eth_initTimeStamp().
 * \param geth GETH driver Handle
 * \param channelId Tx DMA Channel number
 * \param enable TRUE: Enable slot comparison, FALSE: Disable.
 * \param advanceSlotCheckEnable TRUE: TX DMA fetches data from the buffer when the RSN value is equal to or less than the SLOTNUM value programmed in that descriptor by up to 2 slots, FALSE: DMA will start fetching the the data when the RSN value is equal to or less than the SLOTNUM value by one slot.
 * \return None
 */
IFX_EXTERN void IfxGeth_Eth_dmaAvbChannelSlotFunctionInit(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId, boolean enable, boolean advanceSlotCheckEnable);

/** \brief API to init Layer4 filtering for TCP/UDP Protocol
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config configuration for layer 4 filter initialization parameter's
 * \return status 0 : Init Successful  1 : Init failed due to timeoutError 2 : Init failed due to invalid configuration i.e either of Src or Dst port Number matching to should be enabled
 */
IFX_EXTERN IfxGeth_L3L4FilterStatus IfxGeth_Eth_initLayer4Filtering(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_L4FilterConfig *config);

/** \brief API to init Layer3 filtering for IPv6 Frame format
 * \param geth GETH driver Handle
 * \param portIndex Index of Port
 * \param config configuration for IPv6 layer 3 filter initialization parameter's
 * \return status 0 : Init Successful  1 : Init failed due to timeoutError 2 : Init failed due to invalid configuration
 */
IFX_EXTERN IfxGeth_L3L4FilterStatus IfxGeth_Eth_initL3FilteringIPv6(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_L3FilterIPv6Config *config);

/** \brief API to initialize the Remote Wake-Up Mode
 * \param geth GETH driver Handle
 * \param portIndex port index
 * \param config remote wake-up configuration
 * \return status 0 : remote wake-up power down mode entry successful return
 *                1 : timeout error return
 *                2 : Invalid configuration as either of Magic Packet Enable, Global Unicast, or Remote Wake-Up Packet Enable bit should be set high
 */
IFX_EXTERN IfxGeth_RwkConfigStatus IfxGeth_Eth_initRwkMode(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, IfxGeth_Eth_RemoteWakeUpConfig *config);

/** \brief Wrapper API for MDIO Clause22 single write
 * \param geth GETH driver Handle
 * \param portIndex port index
 * \param phyAddress phy address (i.e port addr of phy)
 * \param regAddress register address to write
 * \param data data to be written
 * \return MDIO Transfer status TRUE : MDIO Transfer Failed FALSE : MDIO Transfer Success
 */
IFX_EXTERN boolean IfxGeth_Eth_mdio_write_clause22(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint16 regAddress, uint16 data);

/** \brief Wrapper API for MDIO Clause22 single read
 * \param geth GETH driver Handle
 * \param portIndex port index
 * \param phyAddress phy address (i.e port addr of phy)
 * \param regAddress register address to read
 * \param data pointer to read data
 * \return MDIO Transfer status TRUE : MDIO Transfer Failed FALSE : MDIO Transfer Success
 */
IFX_EXTERN boolean IfxGeth_Eth_mdio_read_clause22(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint16 regAddress, uint16 *data);

/** \brief Wrapper API for MDIO Clause45 single write
 * \param geth GETH driver Handle
 * \param portIndex port index
 * \param phyAddress phy address (i.e port addr of phy)
 * \param devAddress device addr
 * \param regAddress register address to write
 * \param data data to be written
 * \return MDIO Transfer status TRUE : MDIO Transfer Failed FALSE : MDIO Transfer Success
 */
IFX_EXTERN boolean IfxGeth_Eth_mdio_write_clause45(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 data);

/** \brief Wrapper API for MDIO Clause45 single read
 * \param geth GETH driver Handle
 * \param portIndex port index
 * \param phyAddress phy address (i.e port addr of phy)
 * \param devAddress device addr
 * \param regAddress register address to read
 * \param data pointer to read data
 * \return MDIO Transfer status TRUE : MDIO Transfer Failed FALSE : MDIO Transfer Success
 */
IFX_EXTERN boolean IfxGeth_Eth_mdio_read_clause45(IfxGeth_Eth *geth, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 *data);
#endif

/** \addtogroup IfxLld_Geth_Eth_Variables
 * \{ */

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
/** \brief Actual Rx descriptor lists of all available Rx channels
 */
IFX_EXTERN IFX_ALIGN(8) IfxGeth_RxDescrList IfxGeth_Eth_rxDescrList[IFXGETH_NUM_MODULES][IFXGETH_NUM_RX_CHANNELS];

/** \brief Actual Tx descriptor lists of all available Tx channels
 */
IFX_EXTERN IFX_ALIGN(8) IfxGeth_TxDescrList IfxGeth_Eth_txDescrList[IFXGETH_NUM_MODULES][IFXGETH_NUM_TX_CHANNELS];

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void *IfxGeth_Eth_waitTransmitBuffer(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
    void *tx;

    do
    {
        tx = IfxGeth_Eth_getTransmitBuffer(geth, channelId);
    } while (tx == NULL_PTR);

    return tx;
}


IFX_INLINE volatile IfxGeth_RxDescr *IfxGeth_Eth_getActualRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    return geth->rxChannel[channelId].rxDescrPtr;
}


IFX_INLINE volatile IfxGeth_TxDescr *IfxGeth_Eth_getActualTxDescriptor(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
    return geth->txChannel[channelId].txDescrPtr;
}


IFX_INLINE boolean IfxGeth_Eth_isRxDataAvailable(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    return IfxGeth_Eth_getActualRxDescriptor(geth, channelId)->RDES3.R.OWN == 0;
}


IFX_INLINE volatile IfxGeth_TxDescr *IfxGeth_Eth_getBaseTxDescriptor(IfxGeth_Eth *geth, IfxGeth_TxDmaChannel channelId)
{
    return geth->txChannel[channelId].txDescrList->descr;
}


IFX_INLINE volatile IfxGeth_RxDescr *IfxGeth_Eth_getBaseRxDescriptor(IfxGeth_Eth *geth, IfxGeth_RxDmaChannel channelId)
{
    return geth->rxChannel[channelId].rxDescrList->descr;
}


#endif /* IFXGETH_ET_H */
