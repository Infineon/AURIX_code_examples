/**********************************************************************************************************************
 * \file ifx_geth.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include "pdl/ifx_geth.h"

#if defined(IFX_DEVICE_SERIES) && (IFX_DEVICE_SERIES != IFX_DEVICE_SERIES_TC45) && \
                                  (IFX_DEVICE_SERIES != IFX_DEVICE_SERIES_TC49N)

#include "IfxGeth_regdef.h"

/*******************************************************************************
* Macros
*******************************************************************************/
#define MDIO_CMD_READ               VAL2FLD(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD, 3)
#define MDIO_CMD_WRITE              VAL2FLD(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD, 1)
#define MDIO_CMD_BUSY               GENMASK(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SBUSY)

/*******************************************************************************
* Function Prototypes
*******************************************************************************/
static int IfxGeth_vlanFilterUpdate(Ifx_GETH *gethSFR, IfxGeth_PortIndex port, uint8 index, Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_DATA data);


sint32 IfxGeth_Mdio_init(Ifx_GETH *gethSFR, IfxGeth_PortIndex port, const Ifx_GETH_MDIO_Pins *pins, uint32 csr_clk_rate)
{
    gethSFR->MACEN.U |= 1U << port;

    uint32 divider;
    if ((csr_clk_rate >= 40000000) && (csr_clk_rate <= 50000000))
    {
        divider = 5;
    }
    else if (csr_clk_rate >= 350000000)
    {
        divider = 4;
    }
    else if (csr_clk_rate >= 300000000)
    {
        divider = 3;
    }
    else if (csr_clk_rate >= 250000000)
    {
        divider = 2;
    }
    else if (csr_clk_rate >= 150000000)
    {
        divider = 1;
    }
    else if (csr_clk_rate >= 100000000)
    {
        divider = 0;
    }
    else
    {
        return -1;
    }

    if (pins != NULL)
    {
        IfxGeth_Mdc_Out *mdc = pins->mdc;
        IfxGeth_Mdio_InOut *mdio = pins->mdio;

        IfxPort_setPinModeInput(mdio->pin.port, mdio->pin.pinIndex, IfxPort_InputMode_noPullDevice);
        IfxPort_setPinPadDriver(mdio->pin.port, mdio->pin.pinIndex, IfxPort_PadDriver_cmosAutomotiveSpeed3);

        IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, IfxPort_OutputMode_pushPull, mdc->select);
        IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, IfxPort_PadDriver_cmosAutomotiveSpeed3);
    }

    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = VAL2FLD(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CR, divider);

    return 0;
}

static uint16 IfxGeth_Mdio_readClause22(Ifx_GETH *gethSFR, IfxGeth_PortIndex port, uint8 phyaddr, uint16 reg_num)
{
    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);

    /* Set port as Clause 22 */
    gethSFR->PORT[port].CORE.MDIO.CLAUSE_22_PORT.U |= BIT(phyaddr);

    uint32 command_addr = (phyaddr << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_OFF) |
                          ((reg_num & 0x1f) << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_OFF);

    uint32 command_data = gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U &
                          (uint32)~GENMASK(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD);

    command_data |= MDIO_CMD_READ |
                    MDIO_CMD_BUSY;

    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U = command_addr;
    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = command_data;

    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);

    return gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SDATA;
}

static void IfxGeth_Mdio_writeClause22(Ifx_GETH *gethSFR, IfxGeth_PortIndex port, uint8 phyaddr, uint16 reg_num, uint16 reg_data)
{
    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);

    /* Set port as Clause 22 */
    gethSFR->PORT[port].CORE.MDIO.CLAUSE_22_PORT.U |= BIT(phyaddr);

    uint32 command_addr = (phyaddr << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_OFF) |
                          ((reg_num & 0x1f) << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_OFF);

    uint32 command_data = gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U &
                          ((uint32)~GENMASK(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD) &
                           (uint32)~GENMASK(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA));

    command_data |= MDIO_CMD_WRITE |
                    MDIO_CMD_BUSY |
                    reg_data;

    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U = command_addr;
    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = command_data;

    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);
}

static uint16 IfxGeth_Mdio_readClause45(Ifx_GETH *gethSFR, IfxGeth_PortIndex port, uint8 phyaddr, uint8 devad, uint16 reg_num)
{
    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);

    /* Set port as Clause 45 */
    gethSFR->PORT[port].CORE.MDIO.CLAUSE_22_PORT.U &= (uint32)~BIT(phyaddr);

    uint32 command_addr = (phyaddr << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_OFF) |
                          (reg_num  << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_OFF) |
                          (devad << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_OFF);

    uint32 command_data = gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U &
                          (uint32)~GENMASK(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD);

    command_data |= MDIO_CMD_READ |
                    MDIO_CMD_BUSY;

    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U = command_addr;
    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = command_data;

    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);

    return gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SDATA;
}

static void IfxGeth_Mdio_writeClause45(Ifx_GETH *gethSFR, IfxGeth_PortIndex port, uint8 phyaddr, uint8 devad, uint16 reg_num, uint16 reg_data)
{
    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);

    /* Set port as Clause 45 */
    gethSFR->PORT[port].CORE.MDIO.CLAUSE_22_PORT.U &= (uint32)~BIT(phyaddr);

    uint32 command_addr = (phyaddr << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_PA_OFF) |
                          (reg_num << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_RA_OFF) |
                          (devad << IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_ADDRESS_DA_OFF);

    uint32 command_data = gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U &
                          ((uint32)~GENMASK(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_CMD) &
                           (uint32)~GENMASK(IFX_GETH_PORT_CORE_MDIO_SINGLE_COMMAND_CONTROL_DATA_SDATA));

    command_data |= MDIO_CMD_WRITE |
                    MDIO_CMD_BUSY |
                    reg_data;

    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_ADDRESS.U = command_addr;
    gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.U = command_data;

    while (gethSFR->PORT[port].CORE.MDIO.SINGLE_COMMAND_CONTROL_DATA.B.SBUSY);
}

void IfxGeth_Mdio_write(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 data)
{
    if (devAddress != 0)
    {
        IfxGeth_Mdio_writeClause45(gethSFR, portIndex, phyAddress, devAddress, regAddress, data);
    }
    else
    {
        IfxGeth_Mdio_writeClause22(gethSFR, portIndex, phyAddress, (uint8)(regAddress & 0xff), data);
    }
}

uint16 IfxGeth_Mdio_read(Ifx_GETH *gethSFR, IfxGeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress)
{
    uint16 data;
    if (devAddress != 0)
    {
        data = IfxGeth_Mdio_readClause45(gethSFR, portIndex, phyAddress, devAddress, regAddress);
    }
    else
    {
        data = IfxGeth_Mdio_readClause22(gethSFR, portIndex, phyAddress, (uint8)(regAddress & 0xff));
    }

    return data;
}

int IfxGeth_vlanFilterConfig(Ifx_GETH *gethSFR,
                             IfxGeth_PortIndex port,
                             const Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_DATA *entries,
                             uint8 count)
{
    uint32 old_val;
    old_val = gethSFR->PORT[port].CORE.MAC_RX_CONFIGURATION.U;

    IfxGeth_stopRx(gethSFR, port);

    for (uint8 i = 0; i < count; ++i)
    {
        if (IfxGeth_vlanFilterUpdate(gethSFR, port, i, entries[i]) != 0)
        {
            return -1;
        }
    }

    /* Enable VLAN Tag Filter */
    gethSFR->PORT[port].CORE.MAC_PACKET_FILTER.B.VTFE = 1;

    /* Re-enable RX */
    gethSFR->PORT[port].CORE.MAC_RX_CONFIGURATION.U = old_val;

    return 0;
}

static int IfxGeth_vlanFilterUpdate(Ifx_GETH *gethSFR, IfxGeth_PortIndex port, uint8 index, Ifx_GETH_PORT_CORE_MAC_VLAN_TAG_DATA data)
{
    if (index >= 8)
    {
        return -1;
    }

    gethSFR->PORT[port].CORE.MAC_VLAN_TAG_DATA = data;

    uint32 reg_val = gethSFR->PORT[port].CORE.MAC_VLAN_TAG_CTRL.U;
    reg_val &= (uint32)~(GENMASK(IFX_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OB) |
                         GENMASK(IFX_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL_CT) |
                         GENMASK(IFX_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OFS));
    reg_val |= VAL2FLD(IFX_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OFS, index) |
               GENMASK(IFX_GETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OB);

    gethSFR->PORT[port].CORE.MAC_VLAN_TAG_CTRL.U = reg_val;

    while (gethSFR->PORT[port].CORE.MAC_VLAN_TAG_CTRL.B.OB == 1);

    return 0;
}

#endif
