/**********************************************************************************************************************
 * \file ifx_leth.h
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#ifndef IFX_LETH_H
#define IFX_LETH_H

#include "ifx_macro.h"
#include "Leth/Std/IfxLeth.h"

/* addresses for indirect read/write access to 10BASE-T1S PHY internal registers (PMA/PLCA/PCS) */
#define LETH_B10T1S_PLCA_CTRL            0x00
#define LETH_B10T1S_PLCA_NODE_CTRL       0x01
#define LETH_B10T1S_PLCA_STS             0x02
#define LETH_B10T1S_PLCA_TIMER           0x03
#define LETH_B10T1S_PLCA_BUF_DEPTH       0x04
#define LETH_B10T1S_PCS_CTRL             0x0B
#define LETH_B10T1S_PCS_STS              0x0C
#define LETH_B10T1S_PCS_DIAG_1           0x0D
#define LETH_B10T1S_PCS_DIAG_2           0x0E
#define LETH_B10T1S_PCS_JAB_TIMER        0x0F
#define LETH_B10T1S_PMA_EXTND_ABILITY    0x14
#define LETH_B10T1S_PMA_PMD_CTRL         0x15
#define LETH_B10T1S_PMA_CTRL             0x16
#define LETH_B10T1S_PMA_STS              0x17
#define LETH_B10T1S_PMA_TST_MODE_CTRL    0x18
#define LETH_B10T1S_DEBUG_MODE           0x19

#define LETH_B10T1S_XCVR_STATE_NORMAL           0
#define LETH_B10T1S_XCVR_STATE_LOW_POWER        1
#define LETH_B10T1S_XCVR_STATE_LOW_POWER_WAKE   2
#define LETH_B10T1S_XCVR_STATE_TRANSMIT         3
#define LETH_B10T1S_XCVR_STATE_CONFIGURATION    4

#define LETH_PLCA_STATUS_OK              1
#define LETH_PLCA_STATUS_ERROR           0

#define LETH_TDES2_IOC                   BIT(31)
#define LETH_TDES2_TTSE                  BIT(30)
#define LETH_TDES2_TMWD                  BIT(30)
#define LETH_TDES2_B2L                   BITMASK(29, 16)
#define LETH_TDES2_VTIR                  BITMASK(15, 14)
#define LETH_TDES2_HL                    BITMASK(13, 0)
#define LETH_TDES2_B1L                   BITMASK(13, 0)

#define LETH_TDES3_OWN                   BIT(31)
#define LETH_TDES3_CTXT                  BIT(30)
#define LETH_TDES3_FD                    BIT(29)
#define LETH_TDES3_LD                    BIT(28)
#define LETH_TDES3_CPC                   BITMASK(27, 26)
#define LETH_TDES3_SAIC                  BITMASK(25, 23)
#define LETH_TDES3_SLOTNUM               BITMASK(22, 19)
#define LETH_TDES3_THL                   BITMASK(22, 19)
#define LETH_TDES3_TSE                   BIT(18)
#define LETH_TDES3_CIC                   BITMASK(17, 16)
#define LETH_TDES3_TPL                   BITMASK(17, 0)
#define LETH_TDES3_FL                    BITMASK(14, 0)

#define LETH_TDES3_DE                    BIT(23)
#define LETH_TDES3_TTSS                  BIT(17)
#define LETH_TDES3_EUE                   BIT(16)
#define LETH_TDES3_ES                    BIT(15)
#define LETH_TDES3_JT                    BIT(14)
#define LETH_TDES3_FF                    BIT(13)
#define LETH_TDES3_PCE                   BIT(12)
#define LETH_TDES3_LoC                   BIT(11)
#define LETH_TDES3_NC                    BIT(10)
#define LETH_TDES3_LC                    BIT(9)
#define LETH_TDES3_EC                    BIT(8)
#define LETH_TDES3_CC                    BITMASK(7, 4)
#define LETH_TDES3_ED                    BIT(3)
#define LETH_TDES3_UF                    BIT(2)
#define LETH_TDES3_DB                    BIT(1)
#define LETH_TDES3_IHE                   BIT(0)

#define LETH_RDES3_OWN                   BIT(31)
#define LETH_RDES3_IOC                   BIT(30)
#define LETH_RDES3_BUF2V                 BIT(25)
#define LETH_RDES3_BUF1V                 BIT(24)

#define LETH_RDES0_IVT                   BITMASK(31, 16)
#define LETH_RDES0_OVT                   BITMASK(15, 0)

#define LETH_RDES1_OPC                   BITMASK(31, 16)
#define LETH_RDES1_TD                    BIT(15)
#define LETH_RDES1_TSA                   BIT(14)
#define LETH_RDES1_PV                    BIT(13)
#define LETH_RDES1_PFT                   BIT(12)
#define LETH_RDES1_PMT                   BITMASK(11, 8)
#define LETH_RDES1_IPCE                  BIT(7)
#define LETH_RDES1_IPCB                  BIT(6)
#define LETH_RDES1_IPV6                  BIT(5)
#define LETH_RDES1_IPV4                  BIT(4)
#define LETH_RDES1_IPHE                  BIT(3)
#define LETH_RDES1_PT                    BITMASK(2, 0)

#define LETH_RDES2_L3L4FM                BITMASK(31, 29)
#define LETH_RDES2_L4FM                  BIT(28)
#define LETH_RDES2_L3FM                  BIT(27)
#define LETH_RDES2_MADRM                 BITMASK(26, 19)
#define LETH_RDES2_HF                    BIT(18)
#define LETH_RDES2_DAF                   BIT(17)
#define LETH_RDES2_RXPI                  BIT(17)
#define LETH_RDES2_SAF                   BIT(16)
#define LETH_RDES2_RXPD                  BIT(16)
#define LETH_RDES2_OTS                   BIT(15)
#define LETH_RDES2_ITS                   BIT(14)
#define LETH_RDES2_ARPNR                 BIT(10)
#define LETH_RDES2_HL                    BITMASK(9, 0)

#define LETH_RDES3_CTXT                  BIT(30)
#define LETH_RDES3_FD                    BIT(29)
#define LETH_RDES3_LD                    BIT(28)
#define LETH_RDES3_RS2V                  BIT(27)
#define LETH_RDES3_RS1V                  BIT(26)
#define LETH_RDES3_RS0V                  BIT(25)
#define LETH_RDES3_CE                    BIT(24)
#define LETH_RDES3_GP                    BIT(23)
#define LETH_RDES3_RWT                   BIT(22)
#define LETH_RDES3_OE                    BIT(21)
#define LETH_RDES3_RE                    BIT(20)
#define LETH_RDES3_DE                    BIT(19)
#define LETH_RDES3_LT                    BITMASK(18, 16)
#define LETH_RDES3_ES                    BIT(15)
#define LETH_RDES3_PL                    BITMASK(14, 0)

typedef enum
{
    IfxLeth_Speed_1000M = 0,
    IfxLeth_Speed_100M = 3,
    IfxLeth_Speed_10M = 2,
} IfxLeth_Speed;

typedef enum
{
    IfxLeth_DuplexMode_Half,
    IfxLeth_DuplexMode_Full
} IfxLeth_DuplexMode;

typedef enum
{
    IfxLeth_DmaStatus_TI = GENMASK(IFX_LETH_DMA_CH_STATUS_TI),
    IfxLeth_DmaStatus_TPS = GENMASK(IFX_LETH_DMA_CH_STATUS_TPS),
    IfxLeth_DmaStatus_TBU = GENMASK(IFX_LETH_DMA_CH_STATUS_TBU),
    IfxLeth_DmaStatus_RI = GENMASK(IFX_LETH_DMA_CH_STATUS_RI),
    IfxLeth_DmaStatus_RBU = GENMASK(IFX_LETH_DMA_CH_STATUS_RBU),
    IfxLeth_DmaStatus_RPS = GENMASK(IFX_LETH_DMA_CH_STATUS_RPS),
    IfxLeth_DmaStatus_RWT = GENMASK(IFX_LETH_DMA_CH_STATUS_RWT),
    IfxLeth_DmaStatus_ETI = GENMASK(IFX_LETH_DMA_CH_STATUS_ETI),
    IfxLeth_DmaStatus_ERI = GENMASK(IFX_LETH_DMA_CH_STATUS_ERI),
    IfxLeth_DmaStatus_FBE = GENMASK(IFX_LETH_DMA_CH_STATUS_FBE),
    IfxLeth_DmaStatus_CDE = GENMASK(IFX_LETH_DMA_CH_STATUS_CDE),
    IfxLeth_DmaStatus_AIS = GENMASK(IFX_LETH_DMA_CH_STATUS_AIS),
    IfxLeth_DmaStatus_NIS = GENMASK(IFX_LETH_DMA_CH_STATUS_NIS),
    IfxLeth_DmaStatus_TEB = GENMASK(IFX_LETH_DMA_CH_STATUS_TEB),
    IfxLeth_DmaStatus_REB = GENMASK(IFX_LETH_DMA_CH_STATUS_REB)
} IfxLeth_DmaStatus;

typedef struct
{
    IfxLeth_P_Out *mdc;
    IfxLeth_P_InOut *mdio;
} Ifx_LETH_MDIO_Pins;

/* nodeId: the PLCA local node identifier.
 *   Allowed values [0 .. 254]. 255 = node disabled.
 * nodeCnt: the PLCA node count (maximum number of nodes having a TO). Only
 *   meaningful for the coordinator (node_id = 0).
 *   Allowed values [1 .. 255].
 * transmitOpportunityTimer: The value of the PLCA to_timer in bit-times, which determines the
 *   PLCA transmit opportunity window opening. See IEEE802.3 Clause 148 for
 *   more details. The transmitOpportunityTimer shall be set equal over all nodes.
 * maxBurstCount: controls how many additional frames a node is allowed to send in
 *   single transmit opportunity (TO). The default value of 0 means that the
 *   node is allowed exactly one frame per TO. A value of 1 allows two frames
 *   per TO, and so on.
 *   Allowed values [0 .. 255].
 * maxBurstTime: controls how many bit times to wait for the MAC to send a new
 *   frame before interrupting the burst. This value should be set to a value
 *   greater than the MAC inter-packet gap (which is typically 96 bits).
 *   Allowed values [0 .. 255].
 */
typedef struct Ifx_LETH_B10T1S_PLCA_s
{
    uint8 nodeId;
    uint8 nodeCount;
    uint8 transmitOpportunityTimer;
    uint8 maxBurstCount;
    uint8 maxBurstTime;
} Ifx_LETH_B10T1S_PLCA;

typedef struct IFX_PACKED
{
    uint32 match_data;      /*!< bit:   0..31  The 4-byte data */
    uint32 match_en;        /*!< bit:  32..63  The 4-byte mask */
    uint8 af:1;             /*!< bit:      64  Accept Frame */
    uint8 rf:1;             /*!< bit:      65  Reject Frame */
    uint8 im:1;             /*!< bit:      66  Inverse Match */
    uint8 nic:1;            /*!< bit:      67  Next Instruction Control */
    uint8 res1:4;           /*!< bit:  71..68  Reserved */
    uint8 frame_offset:6;   /*!< bit:  77..72  Frame Offset */
    uint8 res2:2;           /*!< bit:  79..78  Reserved */
    uint8 ok_index;         /*!< bit:  87..80  OK Index */
    uint8 dma_ch_no;        /*!< bit:  95..88  DMA channel */
    uint32 res3;            /*!< bit: 127..96  Reserved */
} Ifx_LETH_MAC_RXP_ENTRY;

int IfxLeth_Mdio_init(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, const Ifx_LETH_MDIO_Pins *pins, uint32 csr_clk_rate);
void IfxLeth_Mdio_write(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 data);
uint16 IfxLeth_Mdio_read(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress);

void IfxLeth_Mac_rxpConfig(Ifx_LETH *lethSFR,
                           IfxLeth_PortIndex port,
                           const Ifx_LETH_MAC_RXP_ENTRY *entries,
                           uint32 count);

/* When number of VLAN filter is one (e.g. TC4Dx) Portj_MAC_VLAN_Tag register is used for control of VLAN filter
 * If number of VLAN of filters are more than 1 in device (e.g. TC49x-N, then Portj_MAC_VLAN_Tag_Ctrl register is used for control of VLAN filter.*
 */
#if defined(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OB_OFF)
int IfxLeth_Mac_vlanFilterConfig(Ifx_LETH *lethSFR,
                                 IfxLeth_PortIndex port,
                                 const Ifx_LETH_PORT_CORE_MAC_VLAN_TAG_DATA *entries,
                                 uint8 count);
#endif

IFX_INLINE void IfxLeth_stopRx(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.B.RE = FALSE;
}

IFX_INLINE void IfxLeth_startRx(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.B.RE = TRUE;
}

IFX_INLINE void IfxLeth_stopTx(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.B.TE = FALSE;
}

IFX_INLINE void IfxLeth_startTx(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.B.TE = TRUE;
}

IFX_INLINE void IfxLeth_startMac(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U |= GENMASK(IFX_LETH_PORT_CORE_MAC_CONFIGURATION_RE) |
                                                    GENMASK(IFX_LETH_PORT_CORE_MAC_CONFIGURATION_TE);
}

IFX_INLINE void IfxLeth_stopMac(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U &= (uint32_t)~(GENMASK(IFX_LETH_PORT_CORE_MAC_CONFIGURATION_RE) |
                                                                GENMASK(IFX_LETH_PORT_CORE_MAC_CONFIGURATION_TE));
}


IFX_INLINE void IfxLeth_startRxDma(Ifx_LETH *lethSFR, IfxLeth_RxDmaChannel channelId)
{
    lethSFR->DMA.CH[channelId].RX_CONTROL.B.SR = 1;
}

IFX_INLINE void IfxLeth_startTxDma(Ifx_LETH *lethSFR, IfxLeth_TxDmaChannel channelId)
{
    lethSFR->DMA.CH[channelId].TX_CONTROL.B.ST = 1;
}

IFX_INLINE void IfxLeth_stopRxDma(Ifx_LETH *lethSFR, IfxLeth_RxDmaChannel channelId)
{
    lethSFR->DMA.CH[channelId].RX_CONTROL.B.SR = 0;
}

IFX_INLINE void IfxLeth_stopTxDma(Ifx_LETH *lethSFR, IfxLeth_TxDmaChannel channelId)
{
    lethSFR->DMA.CH[channelId].TX_CONTROL.B.ST = 0;
}

IFX_INLINE uint32 IfxLeth_getDmaStatus(Ifx_LETH *lethSFR, IfxLeth_RxDmaChannel channelId)
{
    return lethSFR->DMA.CH[channelId].STATUS.U;
}

IFX_INLINE void IfxLeth_clearDmaStatus(Ifx_LETH *lethSFR, IfxLeth_RxDmaChannel channelId, uint32_t mask)
{
    lethSFR->DMA.CH[channelId].STATUS.U |= mask;
}

IFX_INLINE void IfxLeth_setSpeed(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, IfxLeth_Speed speed)
{
    uint32 regval = lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U;
    regval &= ~(BITMASK(IFX_LETH_PORT_CORE_MAC_CONFIGURATION_PS_OFF,
                        IFX_LETH_PORT_CORE_MAC_CONFIGURATION_FES_OFF));
    regval |= speed << IFX_LETH_PORT_CORE_MAC_CONFIGURATION_FES_OFF;
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U = regval;
}

IFX_INLINE void IfxLeth_setDuplexMode(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, IfxLeth_DuplexMode mode)
{
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.B.DM = mode;
}

IFX_INLINE void IfxLeth_b10t1s_enable_xcvr_mdio(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, boolean enable)
{
    lethSFR->PORT[port].CORE.MAC_10BT1S_CTRL_STS.B.RAT = enable ? 1 : 0;
}


IFX_INLINE uint32 IfxLeth_b10t1s_get_xcvr_state(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    return lethSFR->PORT[port].CORE.MAC_10BT1S_CTRL_STS.B.TS;
}

void IfxLeth_b10t1s_configure_plca(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, const Ifx_LETH_B10T1S_PLCA *params);
int IfxLeth_b10t1s_get_plca_status(Ifx_LETH *lethSFR, IfxLeth_PortIndex port);

#endif
