/**********************************************************************************************************************
 * \file ifx_leth.c
 * \copyright Copyright (C) Infineon Technologies AG 2023
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include "pdl/ifx_leth.h"

/*******************************************************************************
* Function Prototypes
*******************************************************************************/
static void IfxLeth_rxpUpdateEntry(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, const Ifx_LETH_MAC_RXP_ENTRY *entry, uint32 pos);
static void IfxLeth_rxpEnable(Ifx_LETH *lethSFR, IfxLeth_PortIndex port);
static void IfxLeth_rxpDisable(Ifx_LETH *lethSFR, IfxLeth_PortIndex port);
#if defined(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OB_OFF)
static int IfxLeth_vlanFilterUpdate(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, uint8 index, Ifx_LETH_PORT_CORE_MAC_VLAN_TAG_DATA data);
#endif

int IfxLeth_Mdio_init(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, const Ifx_LETH_MDIO_Pins *pins, uint32 csr_clk_rate)
{
    IfxLeth_enablePortClock(lethSFR, port);

    uint32 divider;
    if ((csr_clk_rate > 20000000) && (csr_clk_rate <= 35000000))
    {
        divider = 2;
    }
    else if (csr_clk_rate <= 60000000)
    {
        divider = 3;
    }
    else if (csr_clk_rate <= 100000000)
    {
        divider = 0;
    }
    else if (csr_clk_rate <= 150000000)
    {
        divider = 1;
    }
    else if (csr_clk_rate <= 250000000)
    {
        divider = 4;
    }
    else
    {
        return -1;
    }


    if (pins != NULL)
    {
        IfxLeth_P_Out *mdc = pins->mdc;
        IfxLeth_P_InOut *mdio = pins->mdio;

        IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, IfxPort_PadDriver_cmosAutomotiveSpeed3);
        IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, IfxPort_OutputMode_pushPull, mdc->select);

        lethSFR->P[port].PORTCTRL1.U &= (uint32)~GENMASK(IFX_LETH_P_PORTCTRL1_MDIO);
        lethSFR->P[port].PORTCTRL1.U |= VAL2FLD(IFX_LETH_P_PORTCTRL1_MDIO, mdio->inSelect) |
                                        GENMASK(IFX_LETH_P_PORTCTRL1_MDIOEN);

        IfxPort_setPinPadDriver(mdio->pin.port, mdio->pin.pinIndex, IfxPort_PadDriver_cmosAutomotiveSpeed3);
        IfxPort_setPinModeInput(mdio->pin.port, mdio->pin.pinIndex, IfxPort_InputMode_noPullDevice);
    }

    lethSFR->PORT[port].CORE.MAC_MDIO_ADDRESS.U = VAL2FLD(IFX_LETH_PORT_CORE_MAC_MDIO_ADDRESS_CR, divider);

    return 0;
}

static void IfxLeth_Mdio_writeClause22(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint16 regAddress, uint16 data)
{
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.C45E = 0;


    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_0 = 1;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_1 = 0;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.PA = phyAddress;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.RDA = regAddress;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_DATA.B.GD = data;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB = 1;
    while (lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB == 1)
    {
    }
}

static void IfxLeth_Mdio_writeClause45(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 data)
{
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.C45E = 1;


    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_0 = 1;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_1 = 0;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.PA = phyAddress;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.RDA = devAddress;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_DATA.B.RA = regAddress;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_DATA.B.GD = data;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB = 1;
    while (lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB == 1)
    {
    }
}

static uint16 IfxLeth_Mdio_readClause22(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint16 regAddress)
{
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.C45E = 0;


    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_0 = 1;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_1 = 1;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.PA = phyAddress;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.RDA = regAddress;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB = 1;
    while (lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB == 1)
    {
    }
    return lethSFR->PORT[portIndex].CORE.MAC_MDIO_DATA.B.GD;
}

static uint16 IfxLeth_Mdio_readClause45(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress)
{
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.C45E = 1;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_0 = 1;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GOC_1 = 1;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.PA = phyAddress;
    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.RDA = devAddress;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_DATA.B.RA = regAddress;

    lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB = 1;
    while (lethSFR->PORT[portIndex].CORE.MAC_MDIO_ADDRESS.B.GB == 1)
    {
    }
    return lethSFR->PORT[portIndex].CORE.MAC_MDIO_DATA.B.GD;
}


void IfxLeth_Mdio_write(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 data)
{
    if (devAddress != 0)
    {
        IfxLeth_Mdio_writeClause45(lethSFR, portIndex, phyAddress, devAddress, regAddress, data);
    }
    else
    {
        IfxLeth_Mdio_writeClause22(lethSFR, portIndex, phyAddress, (uint8)(regAddress & 0xff), data);
    }
}

uint16 IfxLeth_Mdio_read(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress)
{
    uint16 data;
    if (devAddress != 0)
    {
        data = IfxLeth_Mdio_readClause45(lethSFR, portIndex, phyAddress, devAddress, regAddress);
    }
    else
    {
        data = IfxLeth_Mdio_readClause22(lethSFR, portIndex, phyAddress, (uint8)(regAddress & 0xff));
    }

    return data;
}

void IfxLeth_Mac_rxpConfig(Ifx_LETH *lethSFR,
                           IfxLeth_PortIndex port,
                           const Ifx_LETH_MAC_RXP_ENTRY *entries,
                           uint32 count)
{
    uint32 old_val;
    old_val = lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U;

    IfxLeth_stopRx(lethSFR, port);

    /* Disable RX Parser */
    IfxLeth_rxpDisable(lethSFR, port);

    for (sint32 i = 0; i < count; ++i)
    {
        IfxLeth_rxpUpdateEntry(lethSFR, port, &entries[i], i);
    }

    /* Assume n. of parsable entries == n. of valid entries */
    Ifx_LETH_PORT_MTL_MTL_RXP_CONTROL_STATUS rxp_control_status = {0};
    rxp_control_status.B.NVE = count - 1;
    rxp_control_status.B.NPE = count - 1;
    /* Enable Last Instruction in RX Status */
    rxp_control_status.B.ELIRS = 1;

    lethSFR->PORT[port].MTL.MTL_RXP_CONTROL_STATUS.U = rxp_control_status.U;

    /* Enable RX Parser */
    IfxLeth_rxpEnable(lethSFR, port);

    /* Re-enable RX */
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U = old_val;
}

#if defined(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OB_OFF)
int IfxLeth_Mac_vlanFilterConfig(Ifx_LETH *lethSFR,
                                  IfxLeth_PortIndex port,
                                  const Ifx_LETH_PORT_CORE_MAC_VLAN_TAG_DATA *entries,
                                  uint8 count)
{
    uint32 old_val;
    old_val = lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U;

    IfxLeth_stopRx(lethSFR, port);

    for (uint8 i = 0; i < count; ++i)
    {
        if (IfxLeth_vlanFilterUpdate(lethSFR, port, i, entries[i]) != 0)
        {
            return -1;
        }
    }

    /* Enable VLAN Tag Filter */
    lethSFR->PORT[port].CORE.MAC_PACKET_FILTER.B.VTFE = 1;

    /* Re-enable RX */
    lethSFR->PORT[port].CORE.MAC_CONFIGURATION.U = old_val;

    return 0;
}

static int IfxLeth_vlanFilterUpdate(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, uint8 index, Ifx_LETH_PORT_CORE_MAC_VLAN_TAG_DATA data)
{
    if (index >= 8)
    {
        return -1;
    }

    lethSFR->PORT[port].CORE.MAC_VLAN_TAG_DATA = data;

    uint32 reg_val = lethSFR->PORT[port].CORE.MAC_VLAN_TAG_CTRL.U;
    reg_val &= (uint32)~(GENMASK(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OB) |
                         GENMASK(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_CT) |
                         GENMASK(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OFS));
    reg_val |= VAL2FLD(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OFS, index) |
               GENMASK(IFX_LETH_PORT_CORE_MAC_VLAN_TAG_CTRL_OB);

    lethSFR->PORT[port].CORE.MAC_VLAN_TAG_CTRL.U = reg_val;

    while (lethSFR->PORT[port].CORE.MAC_VLAN_TAG_CTRL.B.OB == 1);

    return 0;
}
#endif

static void IfxLeth_rxpEnable(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].MTL.MTL_OPERATION_MODE.B.FRPE = 1;
}

static void IfxLeth_rxpDisable(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    lethSFR->PORT[port].MTL.MTL_OPERATION_MODE.B.FRPE = 0;
    while (lethSFR->PORT[port].MTL.MTL_RXP_CONTROL_STATUS.B.RXPI == 0);
}


static void IfxLeth_rxpUpdateEntry(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, const Ifx_LETH_MAC_RXP_ENTRY *entry, uint32 pos)
{
    Ifx_LETH_PORT_MTL_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS *p_control = (Ifx_LETH_PORT_MTL_MTL_RXP_INDIRECT_ACC_CONTROL_STATUS *)&lethSFR->PORT[port].MTL.MTL_RXP_INDIRECT_ACC_CONTROL_STATUS;
    Ifx_LETH_PORT_MTL_MTL_RXP_INDIRECT_ACC_DATA *p_data = (Ifx_LETH_PORT_MTL_MTL_RXP_INDIRECT_ACC_DATA *)&lethSFR->PORT[port].MTL.MTL_RXP_INDIRECT_ACC_DATA;

    sint32 offset = pos * (sizeof(Ifx_LETH_MAC_RXP_ENTRY) / sizeof(uint32));
    for (sint32 i = 0; i < (sizeof(Ifx_LETH_MAC_RXP_ENTRY) / sizeof(uint32)); ++i)
    {
        /* Wait for ready */
        while (p_control->B.STARTBUSY);

        /* Write data */
        uint32 val = *((uint32 *)entry + i);
        p_data->U = val;

        /* Write pos */
        p_control->B.ADDR = offset + i;

        /* Write OP */
        p_control->B.WRRDN = 1;

        /* Start Write */
        p_control->B.STARTBUSY = 1;

        /* Wait for done */
        while (p_control->B.STARTBUSY);
    }
}
static void IfxLeth_Mdio_modify(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 mask, uint16 set)
{
    uint16 val = IfxLeth_Mdio_read(lethSFR, portIndex, phyAddress, devAddress, regAddress);
    val = (val & (uint16)~mask) | set;
    IfxLeth_Mdio_write(lethSFR, portIndex, phyAddress, devAddress, regAddress, val);
}


void IfxLeth_b10t1s_configure_plca(Ifx_LETH *lethSFR, IfxLeth_PortIndex port, const Ifx_LETH_B10T1S_PLCA *params)
{
    IfxLeth_Mdio_write(lethSFR, port, 0, 0, LETH_B10T1S_PCS_CTRL, GENMASK(IFX_LETH_PORT_CORE_B10T1S_PCS_CTRL_DM));

    IfxLeth_Mdio_modify(lethSFR, port, 0, 0, LETH_B10T1S_PMA_CTRL, GENMASK(IFX_LETH_PORT_CORE_B10T1S_PMA_CTRL_MM),
                                                                   VAL2FLD(IFX_LETH_PORT_CORE_B10T1S_PMA_CTRL_MM, 1));

    IfxLeth_Mdio_write(lethSFR, port, 0, 0, LETH_B10T1S_PLCA_NODE_CTRL, VAL2FLD(IFX_LETH_PORT_CORE_B10T1S_PLCA_NODE_CTRL_LNI, params->nodeId) |
                                                                        VAL2FLD(IFX_LETH_PORT_CORE_B10T1S_PLCA_NODE_CTRL_PNC, params->nodeCount));

    IfxLeth_Mdio_write(lethSFR, port, 0, 0, LETH_B10T1S_PLCA_TIMER, VAL2FLD(IFX_LETH_PORT_CORE_B10T1S_PLCA_TIMER_BT, params->maxBurstTime) |
                                                                    VAL2FLD(IFX_LETH_PORT_CORE_B10T1S_PLCA_TIMER_TOT, params->transmitOpportunityTimer));

    IfxLeth_Mdio_write(lethSFR, port, 0, 0, LETH_B10T1S_PLCA_CTRL, VAL2FLD(IFX_LETH_PORT_CORE_B10T1S_PLCA_CTRL_MAX_BC, params->maxBurstCount));

    IfxLeth_Mdio_modify(lethSFR, port, 0, 0, LETH_B10T1S_PLCA_CTRL, GENMASK(IFX_LETH_PORT_CORE_B10T1S_PLCA_CTRL_PLCA_EN),
                                                                    VAL2FLD(IFX_LETH_PORT_CORE_B10T1S_PLCA_CTRL_PLCA_EN, 1));

}


int IfxLeth_b10t1s_get_plca_status(Ifx_LETH *lethSFR, IfxLeth_PortIndex port)
{
    uint16 regval = IfxLeth_Mdio_read(lethSFR, port, 0, 0, LETH_B10T1S_PLCA_STS);
    return (((regval & GENMASK(IFX_LETH_PORT_CORE_B10T1S_PLCA_STS_PS)) != 0) ? 1 : 0);
}
