/**********************************************************************************************************************
 * \file phy.h
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#ifndef DRIVER_PHY_H
#define DRIVER_PHY_H

#include <stdbool.h>
#include <stdint.h>

#include "pdl/ifx_macro.h"

#ifdef __cplusplus
extern "C" {
#endif

/* The following definitions are based on the contents of:
   https://elixir.bootlin.com/zephyr/v4.1.0/source/include/zephyr/net/mii.h
   https://elixir.bootlin.com/zephyr/v4.1.0/source/include/zephyr/net/mmd.h
   https://elixir.bootlin.com/zephyr/v4.1.0/source/include/zephyr/net/phy.h */

/* MII management registers */
/* Basic Mode Control Register */
#define PHY_MII_BMCR       0x0
/* Basic Mode Status Register */
#define PHY_MII_BMSR       0x1
/* PHY ID 1 Register */
#define PHY_MII_PHYID1R    0x2
/* PHY ID 2 Register */
#define PHY_MII_PHYID2R    0x3
/* Auto-Negotiation Advertisement Register */
#define PHY_MII_ANAR       0x4
/* Auto-Negotiation Link Partner Ability Reg */
#define PHY_MII_ANLPAR     0x5
/* Auto-Negotiation Expansion Register */
#define PHY_MII_ANER       0x6
/* Auto-Negotiation Next Page Transmit Register */
#define PHY_MII_ANNPTR     0x7
/* Auto-Negotiation Link Partner Received Next Page Reg */
#define PHY_MII_ANLPRNPR   0x8
/* 1000BASE-T Control Register */
#define PHY_MII_1KTCR      0x9
/* 1000BASE-T Status Register */
#define PHY_MII_1KSTSR     0xa
/* MMD Access Control Register */
#define PHY_MII_MMD_ACR    0xd
/* MMD Access Address Data Register */
#define PHY_MII_MMD_AADR   0xe
/* Extended Status Register */
#define PHY_MII_ESTAT      0xf

/* MMD Definitions */
/* PMA/PMD Device */
#define PHY_MMD_PMAPMD  0x1
/* WIS Device */
#define PHY_MMD_WIS     0x2
/* PCS Device */
#define PHY_MMD_PCS     0x3
/* PHY XS Device */
#define PHY_MMD_PHYXS   0x4
/* DET XS Device */
#define PHY_MMD_DTEXS   0x5
/* TC Device */
#define PHY_MMD_TC      0x6
/* Auto-Negotiation Device */
#define PHY_MMD_AN      0x7
/* Seperate PMA (1) Device */
#define PHY_MMD_PMA1    0x8
/* Seperate PMA (2) Device */
#define PHY_MMD_PMA2    0x9
/* Seperate PMA (3) Device */
#define PHY_MMD_PMA3    0xA
/* Seperate PMA (4) Device */
#define PHY_MMD_PMA4    0xB
/* OFDM PMA/PMD Device */
#define PHY_MMD_OFDMPMA 0xC
/* Power Unit  Device */
#define PHY_MMD_PU      0xD
/* Clause 22 Extension Device */
#define PHY_MMD_CL22    0x1D
/* Vendor Specific 1 Device */
#define PHY_MMD_VEND1   0x1E
/* Vendor Specific 2 Device */
#define PHY_MMD_VEND2   0x1F

/* 45.2.1.1 PMA/PMD control 1 */
#define PHY_MMD_PMAPMD_CONTROL1                 0x0

/* Auto-negotiation control register */
#define PHY_MMD_AN_CONTROL     0x0
/* Auto-negotiation status register */
#define PHY_MMD_AN_STATUS      0x1

#define PHY_MMD_AN_ADVERTISEMENT    0x10

/* 45.2.7.10 MultiGBASE-T AN control 1 register */
#define PHY_MMD_AN_MULTIG_CONTROL1  0x20

/* Basic Mode Control Register (BMCR) bit definitions */
/* PHY reset */
#define PHY_MII_BMCR_RESET              BIT(15)
/* enable loopback mode */
#define PHY_MII_BMCR_LOOPBACK           BIT(14)
/* 10=1000Mbps 01=100Mbps; 00=10Mbps */
#define PHY_MII_BMCR_SPEED_LSB          BIT(13)
/* Auto-Negotiation enable */
#define PHY_MII_BMCR_AUTONEG_ENABLE     BIT(12)
/* power down mode */
#define PHY_MII_BMCR_POWER_DOWN         BIT(11)
/* isolate electrically PHY from MII */
#define PHY_MII_BMCR_ISOLATE            BIT(10)
/* restart auto-negotiation */
#define PHY_MII_BMCR_AUTONEG_RESTART    BIT(9)
/* full duplex mode */
#define PHY_MII_BMCR_DUPLEX_MODE        BIT(8)
/* 10=1000Mbps 01=100Mbps; 00=10Mbps */
#define PHY_MII_BMCR_SPEED_MSB          BIT(6)
/* Link Speed Field */
#define PHY_MII_BMCR_SPEED_MASK         (BIT(6) | BIT(13))
/* select speed 10 Mb/s */
#define PHY_MII_BMCR_SPEED_10           (0)
/* select speed 100 Mb/s */
#define PHY_MII_BMCR_SPEED_100          BIT(13)
/* select speed 1000 Mb/s */
#define PHY_MII_BMCR_SPEED_1000         BIT(6)

/* Basic Mode Status Register (BMSR) bit definitions */
/* 100BASE-T4 capable */
#define PHY_MII_BMSR_100BASE_T4         BIT(15)
/* 100BASE-X full duplex capable */
#define PHY_MII_BMSR_100BASE_X_FULL     BIT(14)
/* 100BASE-X half duplex capable */
#define PHY_MII_BMSR_100BASE_X_HALF     BIT(13)
/* 10 Mb/s full duplex capable */
#define PHY_MII_BMSR_10_FULL            BIT(12)
/* 10 Mb/s half duplex capable */
#define PHY_MII_BMSR_10_HALF            BIT(11)
/* 100BASE-T2 full duplex capable */
#define PHY_MII_BMSR_100BASE_T2_FULL    BIT(10)
/* 100BASE-T2 half duplex capable */
#define PHY_MII_BMSR_100BASE_T2_HALF    BIT(9)
/* extend status information in reg 15 */
#define PHY_MII_BMSR_EXTEND_STATUS      BIT(8)
/* PHY accepts management frames with preamble suppressed */
#define PHY_MII_BMSR_MF_PREAMB_SUPPR    BIT(6)
/* Auto-negotiation process completed */
#define PHY_MII_BMSR_AUTONEG_COMPLETE   BIT(5)
/* remote fault detected */
#define PHY_MII_BMSR_REMOTE_FAULT       BIT(4)
/* PHY is able to perform Auto-Negotiation */
#define PHY_MII_BMSR_AUTONEG_ABILITY    BIT(3)
/* link is up */
#define PHY_MII_BMSR_LINK_STATUS        BIT(2)
/* jabber condition detected */
#define PHY_MII_BMSR_JABBER_DETECT      BIT(1)
/* extended register capabilities */
#define PHY_MII_BMSR_EXTEND_CAPAB       BIT(0)

/* Auto-negotiation Advertisement Register (ANAR) bit definitions */
/* Auto-negotiation Link Partner Ability Register (ANLPAR) bit definitions */
/* next page */
#define PHY_MII_ADVERTISE_NEXT_PAGE     BIT(15)
/* link partner acknowledge response */
#define PHY_MII_ADVERTISE_LPACK         BIT(14)
/* remote fault */
#define PHY_MII_ADVERTISE_REMOTE_FAULT  BIT(13)
/* try for asymmetric pause */
#define PHY_MII_ADVERTISE_ASYM_PAUSE    BIT(11)
/* try for pause */
#define PHY_MII_ADVERTISE_PAUSE         BIT(10)
/* try for 100BASE-T4 support */
#define PHY_MII_ADVERTISE_100BASE_T4    BIT(9)
/* try for 100BASE-X full duplex support */
#define PHY_MII_ADVERTISE_100_FULL      BIT(8)
/* try for 100BASE-X support */
#define PHY_MII_ADVERTISE_100_HALF      BIT(7)
/* try for 10 Mb/s full duplex support */
#define PHY_MII_ADVERTISE_10_FULL       BIT(6)
/* try for 10 Mb/s half duplex support */
#define PHY_MII_ADVERTISE_10_HALF       BIT(5)
/* Selector Field Mask */
#define PHY_MII_ADVERTISE_SEL_MASK      BITMASK(4,0)
/* Selector Field */
#define PHY_MII_ADVERTISE_SEL_IEEE_802_3   0x01

/* 1000BASE-T Control Register bit definitions */
/* try for 1000BASE-T full duplex support */
#define PHY_MII_ADVERTISE_1000_FULL     BIT(9)
/* try for 1000BASE-T half duplex support */
#define PHY_MII_ADVERTISE_1000_HALF     BIT(8)

/* Advertise all speeds */
#define PHY_MII_ADVERTISE_ALL           (MII_ADVERTISE_10_HALF | MII_ADVERTISE_10_FULL |\
                                         MII_ADVERTISE_100_HALF | MII_ADVERTISE_100_FULL |\
                                         MII_ADVERTISE_SEL_IEEE_802_3)

/* Extended Status Register bit definitions */
/* 1000BASE-X full-duplex capable */
#define PHY_MII_ESTAT_1000BASE_X_FULL   BIT(15)
/* 1000BASE-X half-duplex capable */
#define PHY_MII_ESTAT_1000BASE_X_HALF   BIT(14)
/* 1000BASE-T full-duplex capable */
#define PHY_MII_ESTAT_1000BASE_T_FULL   BIT(13)
/* 1000BASE-T half-duplex capable */
#define PHY_MII_ESTAT_1000BASE_T_HALF   BIT(12)

/* MMD Access Control Register (MII_MMD_ACR) Register bit definitions */
/* DEVAD Mask */
#define PHY_MII_MMD_ACR_DEVAD_MASK      BITMASK(4,0)
/* Address Data bits */
#define PHY_MII_MMD_ACR_ADDR            (0x00 << 14)
#define PHY_MII_MMD_ACR_DATA_NO_POS_INC (0x01 << 14)
#define PHY_MII_MMD_ACR_DATA_RW_POS_INC (0x10 << 14)
#define PHY_MII_MMD_ACR_DATA_W_POS_INC  (0x11 << 14)

#define PHY_MMD_PMAPMD_CONTROL1_RESET           BIT(15)
#define PHY_MMD_PMAPMD_CONTROL1_SPEED_SELECT    (BIT(13) | BITMASK(6, 2))
#define PHY_MMD_PMAPMD_CONTROL1_LOW_POWER       BIT(11)
#define PHY_MMD_PMAPMD_CONTROL1_REMOTE_LOOPBACK BIT(1)
#define PHY_MMD_PMAPMD_CONTROL1_LOCAL_LOOPBACK  BIT(0)

#define PHY_MMD_AN_CONTROL_RESET        BIT(15)
#define PHY_MMD_AN_CONTROL_XPN          BIT(13)
#define PHY_MMD_AN_CONTROL_AN_ENABLE    BIT(12)
#define PHY_MMD_AN_CONTROL_RESTART_AN   BIT(9)

/* Parallel Detection Fault */
#define PHY_MMD_AN_STATUS_PDF           BIT(9)
/* Extended Next Page Status */
#define PHY_MMD_AN_STATUS_XNPS          BIT(7)
/* Auto-Negotiation Complete */
#define PHY_MMD_AN_STATUS_AN_COMPLETE   BIT(5)
/* Remote Fault */
#define PHY_MMD_AN_STATUS_REMOTE_FAULT  BIT(4)
/* Auto-Negotiation Ability */
#define PHY_MMD_AN_STATUS_AN_ABL        BIT(3)
/* Link Status */
#define PHY_MMD_AN_STATUS_LINK_STATUS   BIT(2)
/* Link Partnert Auto-Negotiation Ability */
#define PHY_MMD_AN_STATUS_LP_AN_ABL     BIT(0)

#define PHY_MMD_AN_ADVERTISEMENT_NEXT_PAGE          BIT(15)
#define PHY_MMD_AN_ADVERTISEMENT_XNP                BIT(12)
#define PHY_MMD_AN_ADVERTISEMENT_ASYM_PAUSE         BIT(11)
#define PHY_MMD_AN_ADVERTISEMENT_PAUSE              BIT(10)
#define PHY_MMD_AN_ADVERTISEMENT_100BASE_T4         BIT(9)
#define PHY_MMD_AN_ADVERTISEMENT_100BASE_TX_FULL    BIT(8)
#define PHY_MMD_AN_ADVERTISEMENT_100BASE_TX_HALF    BIT(7)
#define PHY_MMD_AN_ADVERTISEMENT_10BASE_TE_FULL     BIT(6)
#define PHY_MMD_AN_ADVERTISEMENT_10BASE_TE_HALF     BIT(5)

#define PHY_MMD_AN_MULTIG_CONTROL1_MS_MANUAL        BIT(15)
#define PHY_MMD_AN_MULTIG_CONTROL1_MS               BIT(14)
#define PHY_MMD_AN_MULTIG_CONTROL1_PORT_TYPE        BIT(13)
#define PHY_MMD_AN_MULTIG_CONTROL1_10GBASE_T        BIT(12)
#define PHY_MMD_AN_MULTIG_CONTROL1_40GBASE_T        BIT(11)
#define PHY_MMD_AN_MULTIG_CONTROL1_25GBASE_T        BIT(10)
#define PHY_MMD_AN_MULTIG_CONTROL1_25GBASE_T_FR     BIT(9)
#define PHY_MMD_AN_MULTIG_CONTROL1_5GBASE_T         BIT(8)
#define PHY_MMD_AN_MULTIG_CONTROL1_2_5GBASE_T       BIT(7)
#define PHY_MMD_AN_MULTIG_CONTROL1_5GBASE_T_FR      BIT(6)
#define PHY_MMD_AN_MULTIG_CONTROL1_2_5GBASE_T_FR    BIT(5)
#define PHY_MMD_AN_MULTIG_CONTROL1_40GBASE_T_FR     BIT(3)
#define PHY_MMD_AN_MULTIG_CONTROL1_10GBASE_T_LDPTR  BIT(2)
#define PHY_MMD_AN_MULTIG_CONTROL1_10GBASE_T_FR     BIT(1)
#define PHY_MMD_AN_MULTIG_CONTROL1_10GBASE_T_LDLTA  BIT(0)

#define PHY_MII_INVALID_PHY_ID          UINT32_MAX

/* @brief Ethernet link speeds. */
enum phy_link_speed {
    /* 10Base-T Half-Duplex */
    LINK_HALF_10BASE_T      = BIT(0),
    /* 10Base-T Full-Duplex */
    LINK_FULL_10BASE_T      = BIT(1),
    /* 100Base-T Half-Duplex */
    LINK_HALF_100BASE_T     = BIT(2),
    /* 100Base-T Full-Duplex */
    LINK_FULL_100BASE_T     = BIT(3),
    /* 1000Base-T Half-Duplex */
    LINK_HALF_1000BASE_T        = BIT(4),
    /* 1000Base-T Full-Duplex */
    LINK_FULL_1000BASE_T        = BIT(5),
    /* 2.5GBase-T Full-Duplex */
    LINK_FULL_2500BASE_T        = BIT(6),
    /* 5GBase-T Full-Duplex */
    LINK_FULL_5000BASE_T        = BIT(7),
};

/**
 * @brief Check if phy link is full duplex.
 *
 * @param x Link capabilities
 *
 * @return True if link is full duplex, false if not.
 */
#define PHY_LINK_IS_FULL_DUPLEX(x)  (x & (BIT(1) | BIT(3) | BIT(5) | BIT(6) | BIT(7)))

/**
 * @brief Check if phy link speed is 5 Gbit/sec.
 *
 * @param x Link capabilities
 *
 * @return True if link is 5 Gbit/sec, false if not.
 */
#define PHY_LINK_IS_SPEED_5000M(x) (x & BIT(7))

/**
 * @brief Check if phy link speed is 2.5 Gbit/sec.
 *
 * @param x Link capabilities
 *
 * @return True if link is 2.5 Gbit/sec, false if not.
 */
#define PHY_LINK_IS_SPEED_2500M(x) (x & BIT(6))

/**
 * @brief Check if phy link speed is 1 Gbit/sec.
 *
 * @param x Link capabilities
 *
 * @return True if link is 1 Gbit/sec, false if not.
 */
#define PHY_LINK_IS_SPEED_1000M(x) (x & (BIT(4) | BIT(5)))

/**
 * @brief Check if phy link speed is 1 Gbit/sec.
 *
 * @param x Link capabilities
 *
 * @return True if link is 1 Gbit/sec, false if not.
 */
#define PHY_LINK_IS_SPEED_1000M(x)  (x & (BIT(4) | BIT(5)))

/**
 * @brief Check if phy link speed is 100 Mbit/sec.
 *
 * @param x Link capabilities
 *
 * @return True if link is 1 Mbit/sec, false if not.
 */
#define PHY_LINK_IS_SPEED_100M(x)   (x & (BIT(2) | BIT(3)))

/** @brief Link state */
typedef struct phy_link_state {
    /** Link speed */
    enum phy_link_speed speed;
    /** When true the link is active and connected */
    bool is_up;
} phy_link_state_t;

typedef uint16_t (*phy_read_reg_t)(uint8_t phy_addr, uint8_t dev_addr, uint16_t reg_addr);
typedef void (*phy_write_reg_t)(uint8_t phy_addr, uint8_t dev_addr, uint16_t reg_addr, uint16_t reg_val);

typedef struct phy_s
{
    phy_read_reg_t read;
    phy_write_reg_t write;
    phy_link_state_t link_status;
    uint8_t addr;
} phy_t;

int phy_reset(const phy_t *phy, uint32_t hold_time_ms);
int phy_get_id(const phy_t *phy, uint32_t *phy_id);
int phy_restart_aneg(const phy_t *phy);
int phy_update_link(phy_t *phy);
int phy_cfg_link(const phy_t *phy, enum phy_link_speed adv_speeds);
int phy_aneg_is_complete(phy_t *phy);

static inline uint16_t phy_get_speed_selection_bits(enum phy_link_speed speed)
{
    if (speed & LINK_FULL_5000BASE_T) {
        return BIT(13) | BIT(6) | (7 << 2);
    }
    if (speed & LINK_FULL_2500BASE_T) {
        return BIT(13) | BIT(6) | (6 << 2);
    }
    if (speed & (LINK_HALF_1000BASE_T | LINK_FULL_1000BASE_T)) {
        return BIT(6);
    }
    if (speed & (LINK_HALF_100BASE_T | LINK_FULL_100BASE_T)) {
        return BIT(13);
    }
    if (speed & (LINK_HALF_10BASE_T | LINK_FULL_10BASE_T)) {
        return 0;
    }

    return 0;
}

#ifdef __cplusplus
}
#endif

#endif
