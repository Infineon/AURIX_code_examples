/**********************************************************************************************************************
 * \file phy.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include "phy.h"

#include "Stm/Std/IfxStm.h"

/* Offset to align capabilities bits of 1000BASE-T Control and Status regs */
#define PHY_MII_1KSTSR_OFFSET 2

static bool is_gigabit_supported(const phy_t *phy)
{
    uint16_t bmsr_reg = phy->read(phy->addr, 0, PHY_MII_BMSR);

    if (bmsr_reg & PHY_MII_BMSR_EXTEND_STATUS)
    {
        uint16_t estat_reg = phy->read(phy->addr, 0, PHY_MII_ESTAT);

        if (estat_reg & (PHY_MII_ESTAT_1000BASE_T_HALF |
                         PHY_MII_ESTAT_1000BASE_T_FULL))
        {
            return true;
        }
    }

    return false;
}

int phy_reset(const phy_t *phy, uint32_t hold_time_ms)
{
    /* Reset PHY using register */
    phy->write(phy->addr, 0, PHY_MII_BMCR, PHY_MII_BMCR_RESET);

    /* Wait for the minimum reset time specified by datasheet */
    IfxStm_waitTicks(&MODULE_CPU0, IfxStm_getTicksFromMilliseconds(hold_time_ms));

    /* Wait for the reset to be cleared */
    uint32_t reg_val;
    do
    {
        reg_val = phy->read(phy->addr, 0, PHY_MII_BMCR);
    }
    while (reg_val & PHY_MII_BMCR_RESET);

    return 0;
}

int phy_get_id(const phy_t *phy, uint32_t *phy_id)
{
    uint16_t value;

    value = phy->read(phy->addr, 0, PHY_MII_PHYID1R);
    *phy_id = value << 16;
    value = phy->read(phy->addr, 0, PHY_MII_PHYID2R);
    *phy_id |= value;

    return 0;
}

int phy_restart_aneg(const phy_t *phy)
{
    uint32_t bmcr = 0;

    /* Read control register to write back with autonegotiation bit */
    bmcr = phy->read(phy->addr, 0, PHY_MII_BMCR);

    /* (re)start autonegotiation */
    bmcr |= PHY_MII_BMCR_AUTONEG_ENABLE | PHY_MII_BMCR_AUTONEG_RESTART;

    phy->write(phy->addr, 0, PHY_MII_BMCR, bmcr);

    return 0;
}

int phy_update_link(phy_t *phy)
{
    uint16_t bmsr_reg = phy->read(phy->addr, 0, PHY_MII_BMSR);
    bool link_up = bmsr_reg & PHY_MII_BMSR_LINK_STATUS;
    if (link_up == phy->link_status.is_up)
    {
        return 0;
    }

    uint16_t bmcr_reg = phy->read(phy->addr, 0, PHY_MII_BMCR);
    if (bmcr_reg & PHY_MII_BMCR_AUTONEG_ENABLE)
    {
        if (((bmcr_reg & PHY_MII_BMCR_AUTONEG_RESTART) == 0) &&
            ((bmsr_reg & PHY_MII_BMSR_AUTONEG_COMPLETE) != 0))
        {
            uint16_t c1kt_reg = 0;
            uint16_t s1kt_reg = 0;

            if (is_gigabit_supported(phy))
            {
                c1kt_reg = phy->read(phy->addr, 0, PHY_MII_1KTCR);
                s1kt_reg = phy->read(phy->addr, 0, PHY_MII_1KSTSR);
                s1kt_reg = (uint16_t)(s1kt_reg >> PHY_MII_1KSTSR_OFFSET);
            }

            /* Read PHY default advertising parameters */
            uint16 anar_reg = phy->read(phy->addr, 0, PHY_MII_ANAR);

            /* Read peer device capability */
            uint16 anlpar_reg = phy->read(phy->addr, 0, PHY_MII_ANLPAR);

            if ((c1kt_reg & s1kt_reg) & PHY_MII_ADVERTISE_1000_FULL)
            {
                phy->link_status.speed = LINK_FULL_1000BASE_T;
            }
            else if ((c1kt_reg & s1kt_reg) & PHY_MII_ADVERTISE_1000_HALF)
            {
                phy->link_status.speed = LINK_HALF_1000BASE_T;
            }
            else if ((anar_reg & anlpar_reg) & PHY_MII_ADVERTISE_100_FULL)
            {
                phy->link_status.speed = LINK_FULL_100BASE_T;
            }
            else if ((anar_reg & anlpar_reg) & PHY_MII_ADVERTISE_100_HALF)
            {
                phy->link_status.speed = LINK_HALF_100BASE_T;
            }
            else if ((anar_reg & anlpar_reg) & PHY_MII_ADVERTISE_10_FULL)
            {
                phy->link_status.speed = LINK_FULL_10BASE_T;
            }
            else
            {
                phy->link_status.speed = LINK_HALF_10BASE_T;
            }

            phy->link_status.is_up = true;
        }
        else
        {
            phy->link_status.is_up = false;
        }
    }
    else
    {
        bmsr_reg = phy->read(phy->addr, 0, PHY_MII_BMSR);
        phy->link_status.is_up = (bmsr_reg & PHY_MII_BMSR_LINK_STATUS) != 0;
    }


    return 1;
}

int phy_cfg_link(const phy_t *phy, enum phy_link_speed adv_speeds)
{
    uint16 c1kt_reg = 0;
    uint16 anar_reg = phy->read(phy->addr, 0, PHY_MII_ANAR);


    if (adv_speeds & LINK_FULL_10BASE_T)
    {
        anar_reg |= PHY_MII_ADVERTISE_10_FULL;
    }
    else
    {
        anar_reg &= (uint16_t)~PHY_MII_ADVERTISE_10_FULL;
    }

    if (adv_speeds & LINK_HALF_10BASE_T)
    {
        anar_reg |= PHY_MII_ADVERTISE_10_HALF;
    }
    else
    {
        anar_reg &= (uint16_t)~PHY_MII_ADVERTISE_10_HALF;
    }

    if (adv_speeds & LINK_FULL_100BASE_T)
    {
        anar_reg |= PHY_MII_ADVERTISE_100_FULL;
    }
    else
    {
        anar_reg &= (uint16_t)~PHY_MII_ADVERTISE_100_FULL;
    }

    if (adv_speeds & LINK_HALF_100BASE_T)
    {
        anar_reg |= PHY_MII_ADVERTISE_100_HALF;
    }
    else
    {
        anar_reg &= (uint16_t)~PHY_MII_ADVERTISE_100_HALF;
    }

    phy->write(phy->addr, 0, PHY_MII_ANAR, anar_reg);

    if (is_gigabit_supported(phy))
    {
        c1kt_reg = phy->read(phy->addr, 0, PHY_MII_1KTCR);

        if (adv_speeds & LINK_FULL_1000BASE_T)
        {
            c1kt_reg |= PHY_MII_ADVERTISE_1000_FULL;
        }
        else
        {
            c1kt_reg &= (uint16_t)~PHY_MII_ADVERTISE_1000_FULL;
        }

        if (adv_speeds & LINK_HALF_1000BASE_T)
        {
            c1kt_reg |= PHY_MII_ADVERTISE_1000_HALF;
        }
        else
        {
            c1kt_reg &= (uint16_t)~PHY_MII_ADVERTISE_1000_HALF;
        }

        phy->write(phy->addr, 0, PHY_MII_1KTCR, c1kt_reg);
    }

    return 0;
}

int phy_aneg_is_complete(phy_t *phy)
{
    uint16_t an_sts = phy->read(phy->addr, PHY_MMD_AN, PHY_MMD_AN_STATUS);
    if (an_sts & PHY_MMD_AN_STATUS_AN_COMPLETE)
    {
        return 1;
    }
    return 0;
}
