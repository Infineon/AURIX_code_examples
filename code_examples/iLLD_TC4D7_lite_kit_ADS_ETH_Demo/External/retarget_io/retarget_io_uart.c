/**********************************************************************************************************************
 * \file retarget_io.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include "retarget_io/retarget_io.h"

#include "_Utilities/Ifx_Assert.h"
#include "Cpu/Std/IfxCpu.h"
#include "Cpu/Irq/IfxCpu_Irq.h"
#include "Asclin/Asc/IfxAsclin_Asc.h"

#ifndef IFX_INTPRIO_ASCLIN0_TX
#define IFX_INTPRIO_ASCLIN0_TX  11
#endif

#ifndef IFX_INTPRIO_ASCLIN0_RX
#define IFX_INTPRIO_ASCLIN0_RX  12
#endif

#ifndef IFX_INTPRIO_ASCLIN0_ER
#define IFX_INTPRIO_ASCLIN0_ER  13
#endif

#ifndef ASC_TX_BUFFER_SIZE
#define ASC_TX_BUFFER_SIZE 64
#endif

#ifndef ASC_RX_BUFFER_SIZE
#define ASC_RX_BUFFER_SIZE 64
#endif

#if defined ( __GNUC__ )
    #define READ read
    #define WRITE write
#endif
#if defined ( __TASKING__ )
    #define READ _read
    #define WRITE _write
#endif

static IfxAsclin_Asc asc;
static uint8 ascTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
static uint8 ascRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

IFX_INTERRUPT(asclin0TxISR, 0, IFX_INTPRIO_ASCLIN0_TX)
{
    IfxAsclin_Asc_isrTransmit(&asc);
}

IFX_INTERRUPT(asclin0RxISR, 0, IFX_INTPRIO_ASCLIN0_RX)
{
    IfxAsclin_Asc_isrReceive(&asc);
}

IFX_INTERRUPT(asclin0ErISR, 0, IFX_INTPRIO_ASCLIN0_ER)
{
    IfxAsclin_Asc_isrError(&asc);
}

static int _poll_uart(char *chr)
{
    int res = 0;

    if (IfxAsclin_Asc_getReadCount(&asc) != 0)
    {
        *chr = IfxAsclin_Asc_blockingRead(&asc);
        res = 1;
    }

    return res;
}


#ifndef SIMIO_NO_POSIX_READ_WRITE

/* POSIX read function */
/* read characters from file descriptor fd into given buffer, at most count bytes */
/* returns number of characters in buffer */
size_t READ(int fd, void *buffer, size_t count)
{
    size_t index = 0;

    if (fileno(stdin) == fd)
    {
        char *ptr = (char *)buffer;
        do
        {
            if (1 == _poll_uart(ptr))
            {
                ++ptr;
                ++index;
            }
            else
            {
                /* wait at least for 1 character */
                if (index >= 1)
                {
                    break;
                }
            }
        }
        while (index < count);
    }

    return index;
}

/* POSIX write function */
/* write content of buffer to file descriptor fd */
/* returns number of characters that have been written */
size_t WRITE(int fd, const void *buffer, size_t count)
{

    if ((fileno(stdout) == fd) || (fileno(stderr) == fd))
    {
        IfxAsclin_Asc_write(&asc, buffer, (Ifx_SizeT *)&count, TIME_INFINITE);
        while(asc.txInProgress == TRUE);
    }

    return count;
}

#if defined(__HIGHTEC__) && defined(__clang__)

extern int __HEAP_END;

void *sbrk(int incr) 
{
    static unsigned char *heap = NULL;
    unsigned char *prev_heap;

    if (heap == NULL) 
    {
        heap = (unsigned char *)&__HEAP_END;
    }
    prev_heap = heap;

    heap += incr;

    return prev_heap;
}

int close(int file) 
{
    (void)file;
    return -1;
}

int remove(const char *filename) 
{
    (void)filename;
    return -1;
}

void _exit(int status) 
{
    (void)status;
}

#endif

#endif

/*! \brief Get one byte from host-to-target buffer.
 *  \return Data byte
 */
int retarget_io_getc(void)
{
    int c;
    if (_poll_uart((char *)&c) == 0)
    {
        return EOF;
    }
    return c;
}

/*! \brief Send one byte to host.
 */
void retarget_io_putc(char c)
{
    IfxAsclin_Asc_blockingWrite(&asc, c);
}


int32_t retarget_io_init(IfxAsclin_Tx_Out *const tx, 
                         IfxAsclin_Rx_In *const rx, 
                         float32 baudrate)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_FAILURE, tx != NULL);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_FAILURE, rx != NULL);

    if (tx->module != rx->module)
    {
        return RETARGET_IO_MODULE_INVALID;
    }

    if (asc.asclin != NULL)
    {
        IfxAsclin_Asc_disableModule(&asc);
    }

    IfxAsclin_Asc_Config ascConfig;

    IfxAsclin_Asc_initModuleConfig(&ascConfig, tx->module);

    /* set the desired baudrate */
    ascConfig.baudrate.baudrate = baudrate; // FDR values will be calculated in initModule
    ascConfig.baudrate.oversampling = IfxAsclin_OversamplingFactor_16;            /* Set the oversampling factor      */

    /* Configure the sampling mode */
    ascConfig.bitTiming.medianFilter = IfxAsclin_SamplesPerBit_three;             /* Set the number of samples per bit*/
    ascConfig.bitTiming.samplePointPosition = IfxAsclin_SamplePointPosition_8;    /* Set the first sample position    */

    /* ISR priorities and interrupt target */
    ascConfig.interrupt.txPriority = IFX_INTPRIO_ASCLIN0_TX;
    ascConfig.interrupt.rxPriority = IFX_INTPRIO_ASCLIN0_RX;
    ascConfig.interrupt.erPriority = IFX_INTPRIO_ASCLIN0_ER;
    ascConfig.interrupt.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

    /* FIFO configuration */
    ascConfig.txBuffer = &ascTxBuffer;
    ascConfig.txBufferSize = ASC_TX_BUFFER_SIZE;

    ascConfig.rxBuffer = &ascRxBuffer;
    ascConfig.rxBufferSize = ASC_RX_BUFFER_SIZE;

    /* pin configuration */
    const IfxAsclin_Asc_Pins pins = {
        NULL, IfxPort_InputMode_pullUp,     // CTS pin not used
        rx, IfxPort_InputMode_pullUp,       // Rx pin
        NULL, IfxPort_OutputMode_pushPull,  // RTS pin not used
        tx, IfxPort_OutputMode_pushPull,    // Tx pin
        IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConfig.pins = &pins;

    /* initialize module */
    if (IfxAsclin_Asc_initModule(&asc, &ascConfig) == IfxAsclin_Status_noError)
    {
        return RETARGET_IO_OK;
    }
    else
    {
        return RETARGET_IO_INIT_FAILED;
    }
}
