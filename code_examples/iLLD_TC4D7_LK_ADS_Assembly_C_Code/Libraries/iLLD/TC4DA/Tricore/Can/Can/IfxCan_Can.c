/**
 * \file IfxCan_Can.c
 * \brief CAN CAN details
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxCan_Can.h"

/******************************************************************************/
/*-----------------------Exported Variables/Constants-------------------------*/
/******************************************************************************/

IFX_CONST uint8 IfxCan_Can_xtdFrameLengthToNumOfWords[16] = {0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 4, 5, 6, 8, 12, 16};

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxCan_Can_initModule(IfxCan_Can *can, const IfxCan_Can_Config *config)
{
    can->can = config->can;

    // if module is not enabled
    if (IfxCan_isModuleEnabled(can->can) != TRUE)
    {
        // Enable module, disregard Sleep Mode request
        IfxCan_enableModule(can->can);
    }
}


void IfxCan_Can_initModuleConfig(IfxCan_Can_Config *config, Ifx_CAN *can)
{
    const IfxCan_Can_Config defaultConfig = {
        .can = NULL_PTR
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* take over module pointer */
    config->can = can;
}


void IfxCan_Can_initCreConfig(IfxCan_CreConfig *config)
{
    /*
     *    //Example Start Addresses. These values are for an application with compact memory structure and for Maximum allowed size of used features
     *      //Byte Addresses
     *     cre StartAddress = 0x0,//An offset to be added once more clarity is available from CE
     *     std FrameRateTable StartAddress = 262*4, //CRE Start Address + 262 words(70 Fixed for CRE + Max 128 words for Std RT + Max 64 words for Xtd RT)
     *     xtd FrameRateTable StartAddress = (64+262)*4,//Std FT Max 64 words
     *     std TimeStampDatabase StartAddress = (32+64+262)*4,//Xtd FT Max 32 words
     *     xtd TimeStampDatabase StartAddress = (128+32+64+262)*4,//Std TSD Max 128 words
     *
     * Following shows the calculated addresses and the corresponding values assigned to respective SA.
     * .creStartAddress                  = 0, //cre->CONFIGADR.B.SA = 0>>2; Offset address from RAM Base Address. In this example if any offset is added here, same must be added to all following addresses.
     * .stdRoutingTableStartAddress      = (280), //creTableConfig->STD_RT_PARAM.B.SA = 280 >> 2;
     * .xtdRoutingTableStartAddress      = (792), //creTableConfig->XTD_RT_PARAM.B.SA = 792 >> 2;
     * .stdFrameRateTableStartAddress    = (1048), //creTableConfig->STD_FRT_PARAM.B.SA = 1048 >> 2;
     * .xtdFrameRateTableStartAddress    = (1304), //creTableConfig->XTD_FRT_PARAM.B.SA = 1304 >> 2;
     * .stdTimeStampDatabaseStartAddress = (1432), //creTableConfig->STD_TSD_PARAM.B.SA = 1432 >> 2;
     * .xtdTimeStampDatabaseStartAddress = (1944), //creTableConfig->XTD_TSD_PARAM.B.SA = 1944 >> 2;
     */

    const IfxCan_CreConfig defaultConfig = {
        .creStartAddress                  = IFXCAN_CRE_SA,
        .stdRoutingTableStartAddress      = IFXCAN_CRE_STD_RT_SA,
        .xtdRoutingTableStartAddress      = IFXCAN_CRE_XTD_RT_SA,
        .stdFrameRateTableStartAddress    = IFXCAN_CRE_STD_FRT_SA,
        .xtdFrameRateTableStartAddress    = IFXCAN_CRE_XTD_FRT_SA,
        .stdTimeStampDatabaseStartAddress = IFXCAN_CRE_STD_TSD_SA,
        .xtdTimeStampDatabaseStartAddress = IFXCAN_CRE_XTD_TSD_SA,
        .stdRoutingRuleSize               = IfxCan_StdRoutingRuleSize_128,
        .xtdRoutingRuleSize               = IfxCan_XtdRoutingRuleSize_64,
        .stdFrameRateTableSize            = IfxCan_StdFrameRateSize_128,
        .xtdFrameRateTableSize            = IfxCan_XtdFrameRateSize_64,
        .enableCre                        = TRUE,
        .enableCreRouting                 = FALSE,
        .enableIdmu                       = FALSE,
        .rxBuf0CrcEnable                  = 0,
        .rxBuf1CrcEnable                  = 0,
        .txBuf0CrcEnable                  = 0,
        .txBuf1CrcEnable                  = 0,
        .txBuf0CrcGate                    = 0,
        .txBuf1CrcGate                    = 0,
        .rxBuf0LastReadMode               = 0,
        .rxBuf1LastReadMode               = 0,
        .txBuf0LastWriteMode              = 0,
        .txBuf1LastWriteMode              = 0,
        .rxBuf0FixedDataLength            = 0,
        .rxBuf1FixedDataLength            = 0,
        .txBuf0FixedDataLength            = 0,
        .txBuf1FixedDataLength            = 0,
        .rxBuf0DreTriggerEnable           = 0,
        .rxBuf1DreTriggerEnable           = 0,
        .interrupt                        = {
            .rxBuffer0InterruptEnable                       = FALSE,
            .rxBuffer1InterruptEnable                       = FALSE,
            .txBuffer0InterruptEnable                       = FALSE,
            .txBuffer1InterruptEnable                       = FALSE,
            .creErrorInterruptEnable                        = FALSE,
            .IdmuStdFrameRateMeasurementLostInterruptEnable = FALSE,
            .IdmuXtdFrameRateMeasurementLostInterruptEnable = FALSE,
            .rxHBuf0                                        = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .rxHBuf1                                        = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .txHBuf0                                        = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .txHBuf1                                        = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .creError                                       = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .idmu                                           = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            }
        }
    };
    *config = defaultConfig;
}


void IfxCan_Can_initCre(IfxCan_Can_Node *node, IfxCan_CreConfig *config)
{
    Ifx_CAN_N_CRE *cre = (Ifx_CAN_N_CRE *)&(node->node->CRE);

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_config);
#endif

    cre->CONFIGADR.B.SA = (config->creStartAddress >> 2);

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_run);
#endif

    cre->IR.U = IFXCAN_CRE_IR_CLEAR;                                                            /*Interrupt clear on write*/

    uint32       creStartAddress = cre->CONFIGADR.U;
    uint32       ramAddress      = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK); /*Node RAM address may have an offset based on application config. It should be masked to recover module address*/
    Ifx_CAN_CRE *creTableConfig  = (Ifx_CAN_CRE *)(ramAddress + creStartAddress);

    creTableConfig->STD_FRT_PARAM.B.SA   = (config->stdFrameRateTableStartAddress >> 2);
    creTableConfig->STD_FRT_PARAM.B.SIZE = config->stdFrameRateTableSize;

    creTableConfig->XTD_FRT_PARAM.B.SA   = (config->xtdFrameRateTableStartAddress >> 2);
    creTableConfig->XTD_FRT_PARAM.B.SIZE = config->xtdFrameRateTableSize;

    creTableConfig->STD_TSD_PARAM.B.SIZE = config->stdFrameRateTableSize; //Same as size of Std Frame Rate Table
    creTableConfig->STD_TSD_PARAM.B.SA   = (config->stdTimeStampDatabaseStartAddress >> 2);

    creTableConfig->XTD_TSD_PARAM.B.SIZE = config->xtdFrameRateTableSize; //Same as size of Xtd Frame Rate Table
    creTableConfig->XTD_TSD_PARAM.B.SA   = (config->xtdTimeStampDatabaseStartAddress >> 2);

    /*RT Config*/
    creTableConfig->STD_RT_PARAM.B.SA   = (config->stdRoutingTableStartAddress >> 2);
    creTableConfig->STD_RT_PARAM.B.SIZE = config->stdRoutingRuleSize;

    creTableConfig->XTD_RT_PARAM.B.SA   = (config->xtdRoutingTableStartAddress >> 2);
    creTableConfig->XTD_RT_PARAM.B.SIZE = config->xtdRoutingRuleSize;

    /*Timestamp database explicitly initialized to 0*/
    /*Standard TSD*/
    uint8   databaseIndex        = 0;
    uint8   databaseLength       = creTableConfig->STD_TSD_PARAM.B.SIZE;
    uint32 *timeStampDatabasePtr = (uint32 *)(ramAddress + (creTableConfig->STD_TSD_PARAM.B.SA << 2));

    for (databaseIndex = 0; databaseIndex < databaseLength; databaseIndex++)
    {
        *timeStampDatabasePtr++ = 0;
    }

    /*Extended TSD*/
    databaseLength       = creTableConfig->XTD_TSD_PARAM.B.SIZE;
    timeStampDatabasePtr = (uint32 *)(ramAddress + (creTableConfig->XTD_TSD_PARAM.B.SA << 2));

    for (databaseIndex = 0; databaseIndex < databaseLength; databaseIndex++)
    {
        *timeStampDatabasePtr++ = 0;
    }

    cre->CONFIG.B.EN     = config->enableCre;
    cre->CONFIG.B.REN    = config->enableCreRouting;
    cre->CONFIG.B.IDMUEN = config->enableIdmu;
    cre->CONFIG.B.DEN    = config->enableDestinationRouting;
    /*Routing Rule Config*/
    /*Routing Rules to be configured by application using the given 4 Interface APIs*/

    /*Buffer Configurations*/
    /*Receive Buffer 0*/
    cre->HBUF.RX[0].STAT.B.RHREQ = 1; /*Clears the bit*/
    cre->HBUF.RX[0].STAT.B.COUNT = 1; /*Writing nonzero value resets the counter*/

    Ifx_CAN_N_CRE_HBUF_RX_CONFIG rxBuf0;
    rxBuf0.U                 = 0;

    rxBuf0.B.LRM             = config->rxBuf0LastReadMode;
    rxBuf0.B.LEN             = config->rxBuf0FixedDataLength;
    rxBuf0.B.TRIGEN          = config->rxBuf0DreTriggerEnable;
    rxBuf0.B.CRCEN           = config->rxBuf0CrcEnable;
    cre->HBUF.RX[0].CONFIG.U = rxBuf0.U;

    /*Receive Buffer 1*/
    cre->HBUF.RX[1].STAT.B.RHREQ = 1; /*Clears the bit*/
    cre->HBUF.RX[1].STAT.B.COUNT = 1; /*Writing nonzero value resets the counter*/

    Ifx_CAN_N_CRE_HBUF_RX_CONFIG rxBuf1;
    rxBuf1.U                 = 0;

    rxBuf1.B.LRM             = config->rxBuf1LastReadMode;
    rxBuf1.B.LEN             = config->rxBuf1FixedDataLength;
    rxBuf1.B.TRIGEN          = config->rxBuf1DreTriggerEnable;
    rxBuf1.B.CRCEN           = config->rxBuf1CrcEnable;
    cre->HBUF.RX[1].CONFIG.U = rxBuf1.U;

    /*Transmit Buffer 0*/
    cre->HBUF.TX[0].STAT.B.COUNT = 1; /*Writing nonzero value resets the counter*/
    cre->HBUF.TX[0].STAT.B.THREQ = 1; /*Clears the bit*/

    Ifx_CAN_N_CRE_HBUF_TX_CONFIG txBuf0;
    txBuf0.U                 = 0;
    txBuf0.B.LWM             = config->txBuf0LastWriteMode;
    txBuf0.B.LEN             = config->txBuf0FixedDataLength;
    txBuf0.B.CRCEN           = config->txBuf0CrcEnable;
    txBuf0.B.CRCG            = config->txBuf0CrcGate;

    cre->HBUF.TX[0].CONFIG.U = txBuf0.U;

    /*Transmit Buffer 1*/
    cre->HBUF.TX[1].STAT.B.COUNT = 1; /*Writing nonzero value resets the counter*/
    cre->HBUF.TX[1].STAT.B.THREQ = 1; /*Clears the bit*/

    Ifx_CAN_N_CRE_HBUF_TX_CONFIG txBuf1;
    txBuf1.U                 = 0;
    txBuf1.B.LWM             = config->txBuf1LastWriteMode;
    txBuf1.B.LEN             = config->txBuf1FixedDataLength;
    txBuf1.B.CRCEN           = config->txBuf1CrcEnable;
    txBuf1.B.CRCG            = config->txBuf1CrcGate;

    cre->HBUF.TX[1].CONFIG.U = txBuf1.U;
    // interrupt groups configuration
    volatile Ifx_SRC_SRCR *srcPointer;

    if (config->interrupt.rxBuffer0InterruptEnable)
    {
        /*Interrupt Node Init*/
        if ((config->interrupt.rxHBuf0.priority > 0) || (config->interrupt.rxHBuf0.typeOfService == IfxSrc_Tos_dma0) || (config->interrupt.rxHBuf0.typeOfService == IfxSrc_Tos_dma1))
        {
            IfxCan_Node_setGroupInterruptLine(node->node, IfxCan_InterruptGroup_rxHBuf0, config->interrupt.rxHBuf0.interruptLine);
            srcPointer = IfxCan_getSrcPointer(node->can, config->interrupt.rxHBuf0.interruptLine);
            IfxSrc_init(srcPointer, config->interrupt.rxHBuf0.typeOfService, config->interrupt.rxHBuf0.priority, config->interrupt.rxHBuf0.vmId);
            IfxSrc_enable(srcPointer);
        }

        cre->HBUF.RX[0].CONFIG.B.INTEN = TRUE;
    }
    else
    {
        cre->HBUF.RX[0].CONFIG.B.INTEN = FALSE;
    }

    if (config->interrupt.rxBuffer1InterruptEnable)
    {
        /*Interrupt Node Init*/
        if ((config->interrupt.rxHBuf1.priority > 0) || (config->interrupt.rxHBuf1.typeOfService == IfxSrc_Tos_dma0) || (config->interrupt.rxHBuf1.typeOfService == IfxSrc_Tos_dma1))
        {
            IfxCan_Node_setGroupInterruptLine(node->node, IfxCan_InterruptGroup_rxHBuf1, config->interrupt.rxHBuf1.interruptLine);
            srcPointer = IfxCan_getSrcPointer(node->can, config->interrupt.rxHBuf1.interruptLine);
            IfxSrc_init(srcPointer, config->interrupt.rxHBuf1.typeOfService, config->interrupt.rxHBuf1.priority, config->interrupt.rxHBuf1.vmId);
            IfxSrc_enable(srcPointer);
        }

        cre->HBUF.RX[1].CONFIG.B.INTEN = TRUE;
    }
    else
    {
        cre->HBUF.RX[1].CONFIG.B.INTEN = FALSE;
    }

    if (config->interrupt.txBuffer0InterruptEnable)
    {
        /*Interrupt Node Init*/
        if ((config->interrupt.txHBuf0.priority > 0) || (config->interrupt.txHBuf0.typeOfService == IfxSrc_Tos_dma0) || (config->interrupt.txHBuf0.typeOfService == IfxSrc_Tos_dma1))
        {
            IfxCan_Node_setGroupInterruptLine(node->node, IfxCan_InterruptGroup_txHBuf0, config->interrupt.txHBuf0.interruptLine);
            srcPointer = IfxCan_getSrcPointer(node->can, config->interrupt.txHBuf0.interruptLine);
            IfxSrc_init(srcPointer, config->interrupt.txHBuf0.typeOfService, config->interrupt.txHBuf0.priority, config->interrupt.txHBuf0.vmId);
            IfxSrc_enable(srcPointer);
        }

        cre->HBUF.TX[0].CONFIG.B.INTEN = TRUE;
    }
    else
    {
        /*DRE Trigger is enabled*/
        cre->HBUF.TX[0].CONFIG.B.INTEN = FALSE;
    }

    if (config->interrupt.txBuffer1InterruptEnable)
    {
        /*Interrupt Node Init*/
        if ((config->interrupt.txHBuf1.priority > 0) || (config->interrupt.txHBuf1.typeOfService == IfxSrc_Tos_dma0) || (config->interrupt.txHBuf1.typeOfService == IfxSrc_Tos_dma1))
        {
            IfxCan_Node_setGroupInterruptLine(node->node, IfxCan_InterruptGroup_txHBuf1, config->interrupt.txHBuf1.interruptLine);
            srcPointer = IfxCan_getSrcPointer(node->can, config->interrupt.txHBuf1.interruptLine);
            IfxSrc_init(srcPointer, config->interrupt.txHBuf1.typeOfService, config->interrupt.txHBuf1.priority, config->interrupt.txHBuf1.vmId);
            IfxSrc_enable(srcPointer);
        }

        cre->HBUF.TX[1].CONFIG.B.INTEN = TRUE;
    }
    else
    {
        /*DRE Trigger is enabled*/
        cre->HBUF.TX[1].CONFIG.B.INTEN = FALSE;
    }

    if (config->interrupt.IdmuStdFrameRateMeasurementLostInterruptEnable || config->interrupt.IdmuXtdFrameRateMeasurementLostInterruptEnable)
    {
        /*Interrupt Node Init*/
        if ((config->interrupt.idmu.priority > 0) || (config->interrupt.idmu.typeOfService == IfxSrc_Tos_dma0) || (config->interrupt.idmu.typeOfService == IfxSrc_Tos_dma1))
        {
            IfxCan_Node_setGroupInterruptLine(node->node, IfxCan_InterruptGroup_idmu, config->interrupt.idmu.interruptLine);
            srcPointer = IfxCan_getSrcPointer(node->can, config->interrupt.idmu.interruptLine);
            IfxSrc_init(srcPointer, config->interrupt.idmu.typeOfService, config->interrupt.idmu.priority, config->interrupt.idmu.vmId);
            IfxSrc_enable(srcPointer);
        }

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_config);
#endif

        node->node->IDMU.FRTCONFIG.B.INTEN0 = config->interrupt.IdmuStdFrameRateMeasurementLostInterruptEnable;
        node->node->IDMU.FRTCONFIG.B.INTEN1 = config->interrupt.IdmuXtdFrameRateMeasurementLostInterruptEnable;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_run);
#endif
    }
    else
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_config);
#endif

        node->node->IDMU.FRTCONFIG.B.INTEN0 = FALSE;
        node->node->IDMU.FRTCONFIG.B.INTEN1 = FALSE;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_run);
#endif
    }

    /*CRE Error Interrupts*/

    if (config->interrupt.creErrorInterruptEnable)
    {
        /*Interrupt Node Init*/
        if ((config->interrupt.creError.priority > 0) || (config->interrupt.creError.typeOfService == IfxSrc_Tos_dma0) || (config->interrupt.creError.typeOfService == IfxSrc_Tos_dma1))
        {
            IfxCan_Node_setGroupInterruptLine(node->node, IfxCan_InterruptGroup_cre, config->interrupt.creError.interruptLine);
            srcPointer = IfxCan_getSrcPointer(node->can, config->interrupt.creError.interruptLine);
            IfxSrc_init(srcPointer, config->interrupt.creError.typeOfService, config->interrupt.creError.priority, config->interrupt.creError.vmId);
            IfxSrc_enable(srcPointer);
        }
    }
}


void IfxCan_Can_setStandardUnicastRouting(IfxCan_Can_Node *node, IfxCan_StdUnicastRouting *router)
{
    Ifx_CAN_CRE *creTableConfig = (Ifx_CAN_CRE *)((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + node->node->CRE.CONFIGADR.U);
    uint16       startAddress   = (creTableConfig->STD_RT_PARAM.B.SA << 2);

    /* get the standard router element address */
    Ifx_CAN_SRT *stdRoutingElementPtr = IfxCan_Node_getStandardRoutingElementAddress((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), startAddress, router->index);

    Ifx_CAN_SRT  stdRoutingElement;
    stdRoutingElement.UCR.U      = 0;

    stdRoutingElement.UCR.B.MODE = 0;
    stdRoutingElement.UCR.B.DID  = router->destinationId;

    /*CAN Frame Format Modifications*/
    if (router->enableFormatModification)
    {
        stdRoutingElement.UCR.B.FDFM  = 1;
        stdRoutingElement.UCR.B.FDF   = router->frameType;
        stdRoutingElement.UCR.B.IDXOR = router->canIdModifier;
        stdRoutingElement.UCR.B.DLC   = router->lengthModifier;
    }
    else
    {
        stdRoutingElement.UCR.B.FDFM  = 0;
        stdRoutingElement.UCR.B.FDF   = 0;
        stdRoutingElement.UCR.B.IDXOR = 0;
        stdRoutingElement.UCR.B.DLC   = 0;
    }

    stdRoutingElementPtr->UCR.U = stdRoutingElement.UCR.U;
}


void IfxCan_Can_setStandardMulticastRouting(IfxCan_Can_Node *node, IfxCan_StdMulticastRouting *router)
{
    Ifx_CAN_CRE *creTableConfig = (Ifx_CAN_CRE *)((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + node->node->CRE.CONFIGADR.U);
    uint16       startAddress   = (creTableConfig->STD_RT_PARAM.B.SA << 2);

    /* get the standard router element address */
    Ifx_CAN_SRT *stdRoutingElementPtr = IfxCan_Node_getStandardRoutingElementAddress((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), startAddress, router->index);

    Ifx_CAN_SRT  stdRoutingElement;
    stdRoutingElement.MCR.U      = 0;
    stdRoutingElement.MCR.B.MODE = 1;
    stdRoutingElement.MCR.B.DID0 = router->destinationId0;
    stdRoutingElement.MCR.B.DID1 = router->destinationId1;
    stdRoutingElement.MCR.B.DID2 = router->destinationId2;
    stdRoutingElement.MCR.B.DID3 = router->destinationId3;

    stdRoutingElementPtr->MCR.U  = stdRoutingElement.MCR.U;
}


void IfxCan_Can_setExtendedUnicastRouting(IfxCan_Can_Node *node, IfxCan_XtdUnicastRouting *router)
{
    Ifx_CAN_CRE *creTableConfig = (Ifx_CAN_CRE *)((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + node->node->CRE.CONFIGADR.U);
    uint16       startAddress   = (creTableConfig->XTD_RT_PARAM.B.SA << 2);

    /* get the extended router element address */
    Ifx_CAN_XRT *xtdRoutingElementPtr = IfxCan_Node_getExtendedRoutingElementAddress((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), startAddress, router->index);

    Ifx_CAN_XRT  xtdRoutingElement;
    xtdRoutingElement.UCR.U      = 0;

    xtdRoutingElement.UCR.B.MODE = 0;
    xtdRoutingElement.UCR.B.DID  = router->destinationId;

    /*To do based on future requirements
     * CAN Frame Format Modifications*/
    xtdRoutingElement.UCR.B.FDFM    = 0;
    xtdRoutingElement.UCR.B.FDF     = 0;
    xtdRoutingElement.UCR.B.DLC     = 0;
    xtdRoutingElement.UCR.B.IDXOR   = 0;
    xtdRoutingElement.UCR.B.IDSHIFT = 0;

    xtdRoutingElementPtr->UCR.U     = xtdRoutingElement.UCR.U;
}


void IfxCan_Can_setExtendedMulticastRouting(IfxCan_Can_Node *node, IfxCan_XtdMulticastRouting *router)
{
    Ifx_CAN_CRE *creTableConfig = (Ifx_CAN_CRE *)((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + node->node->CRE.CONFIGADR.U);
    uint16       startAddress   = (creTableConfig->XTD_RT_PARAM.B.SA << 2);

    /* get the extended router element address */
    Ifx_CAN_XRT *xtdRoutingElementPtr = IfxCan_Node_getExtendedRoutingElementAddress((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), startAddress, router->index);

    Ifx_CAN_XRT  xtdRoutingElement;
    xtdRoutingElement.MCR.U      = 0;

    xtdRoutingElement.MCR.B.MODE = 1;
    xtdRoutingElement.MCR.B.DID0 = router->destinationId0;
    xtdRoutingElement.MCR.B.DID1 = router->destinationId1;
    xtdRoutingElement.MCR.B.DID2 = router->destinationId2;
    xtdRoutingElement.MCR.B.DID3 = router->destinationId3;

    xtdRoutingElementPtr->MCR.U  = xtdRoutingElement.MCR.U;
}


void IfxCan_Can_Cre_readNewMessageBlock(IfxCan_Can_Node *node, IfxCan_CreRxHostBufferIndex index, IfxCan_CreRxBuffer *buffer)
{
    Ifx_CAN_N_CRE *cre = &(node->node->CRE);

    /*Compute address of required RHBUF based on index*/
    Ifx_CAN_RHBUF *rxBufPtr      = NULL_PTR;
    uint32         rxHBufAddress = 0;
    uint8          i;

    if (index == IfxCan_CreRxHostBufferIndex_1)
    {
        rxHBufAddress = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + cre->CONFIGADR.U + ((IFXCAN_CRE_TABLE_SIZE + IFXCAN_CRE_RXFIFO_SPACING) * 4);
        rxBufPtr      = (Ifx_CAN_RHBUF *)(rxHBufAddress);
    }
    else
    {
        rxHBufAddress = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + cre->CONFIGADR.U + (IFXCAN_CRE_TABLE_SIZE * 4);
        rxBufPtr      = (Ifx_CAN_RHBUF *)(rxHBufAddress);
    }

    buffer->isMessageAvailable  = FALSE;
    buffer->isRoutingValid      = FALSE;
    buffer->isTimeStampCaptured = FALSE;

    {
        /*CRE Fifo Index 0*/
        /*Wait until Valid Message is Available in buffer*/
        //while(cre->HBUF.RX[0].STAT.B.STATE != 2)
        //{}

        while (cre->HBUF.RX[index].STAT.B.RHREQ == 0)
        {}

        buffer->isMessageAvailable = TRUE;

        if (cre->HBUF.RX[index].STAT.B.VRH)
        {
            buffer->isRoutingValid      = TRUE;
            buffer->rxHostBuffer.UCRH.U = rxBufPtr->UCRH.U;
        }

        buffer->rxHostBuffer.THEAD_INTRD.U = rxBufPtr->THEAD_INTRD.U;

        if (rxBufPtr->THEAD_INTRD.B.TSC)
        {
            buffer->isTimeStampCaptured       = TRUE;
            buffer->rxHostBuffer.THEAD_RXTS.U = rxBufPtr->THEAD_RXTS.U;
        }

        /*Copy CRC computed by CRE*/
        buffer->rxHostBuffer.CRC.U = rxBufPtr->CRC.U; /*For valid values, Ifx_CAN_N_CRE_CONFIG.CRCEN must be enabled*/
        /*Copy Message Registers*/
        buffer->rxHostBuffer.R0.U  = rxBufPtr->R0.U;
        buffer->rxHostBuffer.R1.U  = rxBufPtr->R1.U;

        /*Copy Message Data based on length configuration*/

        uint32 *data        = (uint32 *)((uint32)&(rxBufPtr->RHBUF_DB[0]));
        uint32 *buffer_data = (uint32 *)((uint32)&(buffer->rxHostBuffer.RHBUF_DB[0]));

        if (cre->HBUF.RX[index].CONFIG.B.LRM == 0)
        {
            /*Dynamic Data Length*/
            uint8 length = buffer->rxHostBuffer.R1.B.DLC;

            if (length > 0)
            {
                if (buffer->rxHostBuffer.R1.B.FDF == 0)
                {
                    /*Standard Frame Length*/
                    if (length <= 4)
                    {
                        /*Copy 1 word*/
                        *buffer_data = *data;
                    }
                    else
                    {
                        /*Copy 2 words*/
                        *buffer_data++ = *data++;
                        *buffer_data   = *data;
                    }
                }
                else
                {
                    /*Extended Frame Length*/
                    for (i = 0; i < IfxCan_Can_xtdFrameLengthToNumOfWords[length]; i++)
                    {
                        *buffer_data++ = *data++;
                    }
                }
            }
        }
        else
        {
            /*Fixed Data Length*/
            uint8 length = cre->HBUF.RX[index].CONFIG.B.LEN; /*Length of data in words*/

            if (length > 16)
            {
                length = 16;
            }

            if (length > 0)
            {
                for (i = 0; i < length; i++)
                {
                    *buffer_data++ = *data++;
                }
            }
        }
    }
}


void IfxCan_Can_Cre_writeNewMessage(IfxCan_Can_Node *node, IfxCan_CreTxMsgConfig *config, uint32 *data)
{
    Ifx_CAN_N_CRE              *cre = &(node->node->CRE);

    Ifx_CAN_THBUF_T0            t0;
    Ifx_CAN_THBUF_T1            t1;

    IfxCan_CreTxHostBufferIndex index         = config->txBufIndex;

    Ifx_CAN_THBUF              *txBufPtr      = NULL_PTR;
    uint32                      bufferAddress = 0;

    if (index == IfxCan_CreTxHostBufferIndex_1)
    {
        bufferAddress = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + cre->CONFIGADR.U + ((IFXCAN_CRE_TABLE_SIZE + (IFXCAN_CRE_RXFIFO_SPACING * IFXCAN_NUM_CRE_RX_FIFO) + IFXCAN_CRE_THBUF_SIZE) * 4); /* 4 Multiplier: Word length to Byte Conversion*/
    }
    else
    {
        bufferAddress = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + cre->CONFIGADR.U + ((IFXCAN_CRE_TABLE_SIZE + (IFXCAN_CRE_RXFIFO_SPACING * IFXCAN_NUM_CRE_RX_FIFO)) * 4); /* 4 Multiplier: Word length to Byte Conversion*/
    }

    txBufPtr = (Ifx_CAN_THBUF *)(bufferAddress);

    t0.B.RTR = config->remoteTransmitRequest;

    if (config->messageIdLength)
    {
        /*Extended Length*/
        t0.B.ID  = config->messageId;
        t0.B.XTD = IfxCan_MessageIdLength_extended;
    }
    else
    {
        /*Standard Length*/
        t0.B.ID  = (config->messageId) << 18;
        t0.B.XTD = IfxCan_MessageIdLength_standard;
    }

    t0.B.ESI = config->errorStateIndicator;

    t1.B.DLC = config->dataLengthCode;
    t1.B.BRS = config->bitRateSwitching;
    t1.B.FDF = config->frameFormat;
    t1.B.EFC = config->txEventFifoControl;

    /*Compute length of data*/
    uint8 length = 0;

    if (cre->HBUF.TX[index].CONFIG.B.LWM == 0)
    {
        /*Dynamic Length based on DLC*/
        if (t1.B.DLC > 0)
        {
            if (t1.B.FDF == 0)
            {
                /*Std Length*/
                if (t1.B.DLC <= 4)
                {
                    length = 1; /*1 word*/
                }
                else
                {
                    length = 2; /*2 words*/
                }
            }
            else
            {
                /*Xtd Length*/
                length = IfxCan_Can_xtdFrameLengthToNumOfWords[t1.B.DLC];
            }
        }
    }
    else
    {
        /*Fixed Length based on buffer configuration*/
        length = cre->HBUF.TX[index].CONFIG.B.LEN;

        if (length > 16)
        {
            length = 16;
        }
    }

    /*Wait until Tx Host Buffer is free and comes to Wait State*/
    //while(cre->HBUF.TX.STAT.B.STATE != 2)
    //{}
    while (cre->HBUF.TX[index].STAT.B.THREQ == 1) /*Wait until Buffer is free and h/w sets it to 0 when free*/
    {}

    txBufPtr->CRC.U = (uint32)config->crc;        /*To use this feature Ifx_CAN_N_CRE_CONFIG.CRCEN must be enabled*/
    txBufPtr->T0.U  = t0.U;                       /*Copy T0*/
    txBufPtr->T1.U  = t1.U;                       /*Copy T1*/

    uint32 *txdata = (uint32 *)((uint32)&(txBufPtr->DB[0]));

    /*Copy Data*/
    uint8   i;

    for (i = 0; i < length; i++)
    {
        *txdata++ = *data++;
    }
}


void IfxCan_Can_setNodeTimer(IfxCan_Can_Node *node, IfxCan_Can_NodeTimerConfig *config)
{
    Ifx_CAN_N_TIMER    *timerPtr = &(node->node->TIMER);
    Ifx_CAN_N_TIMER_CCR ccr;
    ccr.U           = 0;
    ccr.B.TPSC      = config->prescalar;
    ccr.B.TRIGSRC   = config->triggerSource;
    timerPtr->CCR.U = ccr.U;

    Ifx_CAN_N_TIMER_RXTOUT rxtout;
    rxtout.U                   = 0;
    rxtout.B.RELOAD            = config->rxReloadValue;
    rxtout.B.TEIE              = config->rxInterruptEnable; /*Mapped to G1INTR.RETI. Must be enabled using Node init*/
    timerPtr->RXTOUT.U         = rxtout.U;

    timerPtr->TXTRIG0.B.STRT   = 0;                         /*Timer is Stopped*/
    timerPtr->TXTRIG0.B.RELOAD = config->txTrig0ReloadValue;

    timerPtr->TXTRIG1.B.STRT   = 0;                         /*Timer is Stopped*/
    timerPtr->TXTRIG1.B.RELOAD = config->txTrig1ReloadValue;

    timerPtr->TXTRIG2.B.STRT   = 0;                         /*Timer is Stopped*/
    timerPtr->TXTRIG2.B.RELOAD = config->txTrig2ReloadValue;
}


IfxCan_ReadTxEventStatus IfxCan_Can_readTxEvent(IfxCan_Can_Node *node, IfxCan_Can_TransmitEvent *canTxEventFifoElements)
{
    uint8                    timeStampIndex, txEventFifoIndex;
    IfxCan_ReadTxEventStatus readTxEventStatus = IfxCan_ReadTxEventStatus_elementNotAvailable;

    if (IfxCan_Node_getTxEventFifoFillLevel(node->node) > 0)
    {
        readTxEventStatus = IfxCan_ReadTxEventStatus_readSuccessful;

        txEventFifoIndex  = node->node->TX.EFS.B.EFGI;
        Ifx_CAN_TXEVENT *txEventFifoElement = IfxCan_Node_getTxEventFifoElementAddress(node->messageRAM.baseAddress, node->messageRAM.txEventFifoStartAddress, txEventFifoIndex);

        canTxEventFifoElements->errorStateIndicator       = txEventFifoElement->E0.B.ESI;
        canTxEventFifoElements->extendedID                = txEventFifoElement->E0.B.XTD;
        canTxEventFifoElements->remoteTransmissionRequest = txEventFifoElement->E0.B.RTR;
        canTxEventFifoElements->identifier                = txEventFifoElement->E0.B.ID;
        canTxEventFifoElements->timeStampType             = node->timeStampType;
        canTxEventFifoElements->eventType                 = txEventFifoElement->E1A.B.ET;
        canTxEventFifoElements->frameFormatType           = (IfxCan_FrameFormatType)txEventFifoElement->E1A.B.FDF;
        canTxEventFifoElements->bitRateSwitch             = txEventFifoElement->E1A.B.BRS;
        canTxEventFifoElements->dataLengthCode            = txEventFifoElement->E1A.B.DLC;

        if (canTxEventFifoElements->timeStampType != IfxCan_TimeStamper_none)
        {
            if (node->node->CCCR.B.UTSU == 0)
            {
                if (node->node->CCCR.B.WMM == 0)
                {
                    canTxEventFifoElements->messageMarker = txEventFifoElement->E1A.B.MM;
                    canTxEventFifoElements->timeStamp     = txEventFifoElement->E1A.B.TXTS;
                }
                else
                {
                    canTxEventFifoElements->messageMarker = IfxCan_Node_getWideMMFromTxEventFifo(txEventFifoElement);
                    canTxEventFifoElements->timeStamp     = 0;
                }
            }
            else if (node->node->CCCR.B.UTSU == 1)
            {
                canTxEventFifoElements->messageMarker         = IfxCan_Node_getWideMMFromTxEventFifo(txEventFifoElement);

                canTxEventFifoElements->timeStampCaptureState = (IfxCan_TimeStampState)txEventFifoElement->E1B.B.TSC;

                if (canTxEventFifoElements->timeStampCaptureState == IfxCan_TimeStampState_captured)
                {
                    timeStampIndex                    = IfxCan_Node_getTsuTimeStampPointer(node->node);
                    canTxEventFifoElements->timeStamp = IfxCan_Node_getTsuTimeStamp(node->node, (IfxCan_TsuTimeStampIndex)timeStampIndex);
                }
            }
        }

        IfxCan_Node_setTxEventFifoAcknowledgeIndex(node->node, (IfxCan_TxBufferId)txEventFifoIndex);
    }

    return readTxEventStatus;
}


void IfxCan_Can_initMessage(IfxCan_Message *message)
{
    const IfxCan_Message defaultMessage = {
        .bufferNumber            = 0,
        .messageId               = 0x0,
        .remoteTransmitRequest   = 0,
        .messageIdLength         = IfxCan_MessageIdLength_standard,
        .errorStateIndicator     = 0,
        .dataLengthCode          = IfxCan_DataLengthCode_8,
        .frameMode               = IfxCan_FrameMode_standard,
        .txEventFifoControl      = 0,
        .timeStampType           = IfxCan_TimeStamper_none,
        .rxTimeStamp             = 0,
        .storeInTxFifoQueue      = FALSE,
        .readFromRxFifo0         = FALSE,
        .readFromRxFifo1         = FALSE,
        .txTimeStampEnabled      = FALSE,
        .bypassSwTransmitRequest = FALSE
    };

    /* Default Configuration */
    *message = defaultMessage;
}


void IfxCan_Can_readMessage(IfxCan_Can_Node *node, IfxCan_Message *message, uint32 *data)
{
    IfxCan_RxBufferId bufferId = IfxCan_RxBufferId_0;
    Ifx_CAN_RXMSG    *rxBufferElement;
    uint8             timeStampIndex;

    if ((message->readFromRxFifo0) || (message->readFromRxFifo1))
    {
        if (message->readFromRxFifo0)
        {
            /* get the Tx FIFO 0 ELement address */
            bufferId        = IfxCan_Node_getRxFifo0GetIndex(node->node);
            rxBufferElement = IfxCan_Node_getRxFifo0ElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.rxFifo0StartAddress, bufferId);
        }
        else
        {
            /* get the Tx FIFO 1 ELement address */
            bufferId        = IfxCan_Node_getRxFifo1GetIndex(node->node);
            rxBufferElement = IfxCan_Node_getRxFifo1ElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.rxFifo1StartAddress, bufferId);
        }
    }
    else
    {
        /* get the Rx Bufer ELement address */
        bufferId        = (IfxCan_RxBufferId)message->bufferNumber;
        rxBufferElement = IfxCan_Node_getRxBufferElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.rxBuffersStartAddress, bufferId);
    }

    /*get message ID */
    message->messageId = IfxCan_Node_getMesssageId(rxBufferElement);

    /*get message ID length*/
    message->messageIdLength = (IfxCan_MessageIdLength)rxBufferElement->R0.B.XTD;

    /* get data length code*/
    message->dataLengthCode = (IfxCan_DataLengthCode)IfxCan_Node_getDataLengthCode(rxBufferElement);

    /* get CAN frame mode of operation */
    message->frameMode = IfxCan_Node_getFrameMode(rxBufferElement);

    /*get message bufferNumber*/
    message->bufferNumber = bufferId;

    /* read data */
    IfxCan_Node_readData(rxBufferElement, message->dataLengthCode, data);

    /* write acknowledgement index incase of FIFO */
    if (message->readFromRxFifo0)
    {
        IfxCan_Node_setRxFifo0AcknowledgeIndex(node->node, bufferId);
    }
    else if (message->readFromRxFifo1)
    {
        IfxCan_Node_setRxFifo1AcknowledgeIndex(node->node, bufferId);
    }

    if (node->node->CCCR.B.UTSU == 0)
    {
        message->rxTimeStamp = rxBufferElement->R1A.B.RXTS;
    }
    else if (node->node->CCCR.B.UTSU == 1)
    {
        timeStampIndex       = IfxCan_Node_getTsuTimeStampPointer(node->node);
        message->rxTimeStamp = IfxCan_Node_getTsuTimeStamp(node->node, (IfxCan_TsuTimeStampIndex)timeStampIndex);
    }

    /* clear newdata flag after reading */
    IfxCan_Node_clearRxBufferNewDataFlag(node->node, bufferId);
}


IfxCan_Status IfxCan_Can_sendMessage(IfxCan_Can_Node *node, IfxCan_Message *message, uint32 *data)
{
    IfxCan_Status     status   = IfxCan_Status_ok;

    IfxCan_TxBufferId bufferId = IfxCan_TxBufferId_0;

    if (!message->storeInTxFifoQueue)
    {
        bufferId = (IfxCan_TxBufferId)message->bufferNumber;
    }
    else
    {
        bufferId = IfxCan_Node_getTxFifoQueuePutIndex(node->node);
    }

    if (IfxCan_Can_isTxBufferRequestPending(node, bufferId) == 1)
    {                       /* previous message was not transferred, e.g. due to busy bus, BUS-OFF or others */
        status = IfxCan_Status_notSentBusy;
    }
    else
    {
        /* get the Tx Bufer ELement address */
        Ifx_CAN_TXMSG *txBufferElement = IfxCan_Node_getTxBufferElementAddress(node->node, node->messageRAM.baseAddress, node->messageRAM.txBuffersStartAddress, bufferId);

        /*set message Id (ID and XTD) */
        IfxCan_Node_setMsgId(txBufferElement, message->messageId, message->messageIdLength);

        /* set TX FIFO Event control (EFC) and Message Marker (MM) if Tx Event Fifo is chosen */
        if (message->txEventFifoControl == TRUE)
        {
            IfxCan_Node_setTxEventFifoCtrl(txBufferElement, TRUE);
            IfxCan_Node_setMessageMarker(txBufferElement, bufferId);
        }

        if (message->txTimeStampEnabled == TRUE)
        {
            IfxCan_Node_setTxEventFifoCtrl(txBufferElement, TRUE);
            IfxCan_Node_setTxEventTimeStampCaptureEnable(txBufferElement, TRUE);

            /*
             *  node->node->CCCR.B.UTSU = 0; //Internal Timestamp
             *  txBufferElement->T1.B.TSCE = 1; //Needed for TSU to capture time. Not needed for internal timer.
             */
        }

        /* set Remote Transmit request if selected (RTR)*/
        IfxCan_Node_setRemoteTransmitReq(txBufferElement, message->remoteTransmitRequest);

        /* set Error State Indicator if selected (ESI)*/
        if ((message->frameMode == IfxCan_FrameMode_fdLong) || (message->frameMode == IfxCan_FrameMode_fdLongAndFast))
        {
            IfxCan_Node_setErrStateIndicator(txBufferElement, message->errorStateIndicator);
        }

        /* set data length code (DLC) */
        IfxCan_Node_setDataLength(txBufferElement, message->dataLengthCode);

        /* write data (DBx) */
        IfxCan_Node_writeTxBufData(txBufferElement, message->dataLengthCode, data);

        /* set CAN frame mode request (FDF and BRS) */
        IfxCan_Node_setFrameModeReq(txBufferElement, message->frameMode);

        /*set transmit request */
        if (message->bypassSwTransmitRequest == FALSE)
        {
            /*set transmit request */
            IfxCan_Node_setTxBufferAddRequest(node->node, bufferId);
        }
    }

    return status;
}


void IfxCan_Can_setExtendedFilter(IfxCan_Can_Node *node, IfxCan_Filter *filter)
{
    /* get the Extended filter element address */
    Ifx_CAN_EXTMSG *extendedFilterElement = IfxCan_Node_getExtendedFilterElementAddress(node->messageRAM.baseAddress, node->messageRAM.extendedFilterListStartAddress, filter->number);

    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(node->node);

    if (filter->elementConfiguration != IfxCan_FilterElementConfiguration_storeInRxBuffer)
    {
        IfxCan_Node_setExtendedFilterId2(extendedFilterElement, filter->id2);
    }
    else
    {
        IfxCan_Node_setExtendedFilterRxBufferOffset(extendedFilterElement, filter->rxBufferOffset);
    }

    IfxCan_Node_setExtendedFilterId1(extendedFilterElement, filter->id1);
    IfxCan_Node_setExtendedFilterConfiguration(extendedFilterElement, filter->elementConfiguration);
    IfxCan_Node_setExtendedFilterType(extendedFilterElement, filter->xtdType);

    if (filter->txTimeStampEnabled)
    {
        IfxCan_Node_setExtendedFilterSync(extendedFilterElement, TRUE);
    }

    /* disable configuration change CCCR.CCE = 0, CCCR.INIT = 0 */
    IfxCan_Node_disableConfigurationChange(node->node);
}


void IfxCan_Can_setStandardFilter(IfxCan_Can_Node *node, IfxCan_Filter *filter)
{
    /* get the standard filter element address */
    Ifx_CAN_STDMSG *standardFilterElement = IfxCan_Node_getStandardFilterElementAddress(node->messageRAM.baseAddress, node->messageRAM.standardFilterListStartAddress, filter->number);

    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(node->node);

    if (filter->elementConfiguration != IfxCan_FilterElementConfiguration_storeInRxBuffer)
    {
        IfxCan_Node_setStandardFilterId2(standardFilterElement, filter->id2);
    }
    else
    {
        IfxCan_Node_setStandardFilterRxBufferOffset(standardFilterElement, filter->rxBufferOffset);
    }

    IfxCan_Node_setStandardFilterId1(standardFilterElement, filter->id1);
    IfxCan_Node_setStandardFilterConfiguration(standardFilterElement, filter->elementConfiguration);
    IfxCan_Node_setStandardFilterType(standardFilterElement, filter->stdType);

    if (filter->txTimeStampEnabled)
    {
        IfxCan_Node_setStandardFilterSync(standardFilterElement, TRUE);
    }

    /* disable configuration change CCCR.CCE = 0, CCCR.INIT = 0 */
    IfxCan_Node_disableConfigurationChange(node->node);
}


boolean IfxCan_Can_initNode(IfxCan_Can_Node *node, const IfxCan_Can_NodeConfig *config)
{
    Ifx_CAN   *canSfr  = config->can;
    node->can = canSfr;
    boolean    status  = 0;

    Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr, config->nodeId);
    node->node       = nodeSfr;

    node->messageRAM = config->messageRAM;

    /* initialise the clock for the selected node */
    IfxCan_ClockSelect clockSelect = (IfxCan_ClockSelect)config->nodeId;
    IfxCan_setClockSource(canSfr, clockSelect, config->clockSource);

    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(nodeSfr);

    uint32 moduleFreq = IfxCan_getModuleFrequency();

    /* set baudrate */
    if (config->calculateBitTimingValues)
    {
        IfxCan_Node_setBitTiming(nodeSfr, moduleFreq, config->baudRate.baudrate, config->baudRate.samplePoint, config->baudRate.syncJumpWidth);
    }
    else
    {
        IfxCan_Node_setBitTimingValues(nodeSfr, config->baudRate.syncJumpWidth, config->baudRate.timeSegment2, config->baudRate.timeSegment1, config->baudRate.prescaler);
    }

    /* for CAN FD frames, set fast baudrate */
    if (config->frame.mode != IfxCan_FrameMode_standard)
    {
        if (config->calculateBitTimingValues)
        {
            IfxCan_Node_setFastBitTiming(nodeSfr, moduleFreq, config->fastBaudRate.baudrate, config->fastBaudRate.samplePoint, config->fastBaudRate.syncJumpWidth);
        }
        else
        {
            IfxCan_Node_setFastBitTimingValues(nodeSfr, config->fastBaudRate.syncJumpWidth, config->fastBaudRate.timeSegment2, config->fastBaudRate.timeSegment1, config->fastBaudRate.prescaler);
        }

        /* set transceiver delay compensation offset */
        if (config->fastBaudRate.tranceiverDelayOffset != 0)
        {
            IfxCan_Node_setTransceiverDelayCompensationOffset(nodeSfr, config->fastBaudRate.tranceiverDelayOffset);
        }
    }

    /* transmit frame configuration */

    if ((config->frame.type == IfxCan_FrameType_transmit) ||
        (config->frame.type == IfxCan_FrameType_transmitAndReceive) ||
        (config->frame.type == IfxCan_FrameType_remoteRequest) ||
        (config->frame.type == IfxCan_FrameType_remoteAnswer))
    {
        uint32 id; /* used for enabling transmit interrupts for individual Tx buffers */

        /* set Tx element data field size */
        IfxCan_Node_setTxBufferDataFieldSize(nodeSfr, config->txConfig.txBufferDataFieldSize);

        /* set Tx buffers start address in the Message RAM */
        IfxCan_Node_setTxBuffersStartAddress(nodeSfr, config->messageRAM.txBuffersStartAddress);

        if ((config->txConfig.txMode == IfxCan_TxMode_dedicatedBuffers) ||
            (config->txConfig.txMode == IfxCan_TxMode_sharedFifo) ||
            (config->txConfig.txMode == IfxCan_TxMode_sharedQueue))
        {
            /* dedicated TX buffers operation */
            /* select number of Tx buffers */
            IfxCan_Node_setDedicatedTxBuffersNumber(nodeSfr, config->txConfig.dedicatedTxBuffersNumber);

            /* shared operation */
            if ((config->txConfig.txMode == IfxCan_TxMode_sharedFifo) || (config->txConfig.txMode == IfxCan_TxMode_sharedQueue))
            {
                if (config->txConfig.txMode == IfxCan_TxMode_sharedFifo)
                {
                    /* set Tx FIFO mode */
                    IfxCan_Node_setTransmitFifoQueueMode(nodeSfr, IfxCan_TxMode_fifo);
                }

                if (config->txConfig.txMode == IfxCan_TxMode_sharedQueue)
                {
                    /* set Tx Queue mode */
                    IfxCan_Node_setTransmitFifoQueueMode(nodeSfr, IfxCan_TxMode_queue);
                }

                /* select number of Tx buffers to be used as Tx FIFO/Queue */
                IfxCan_Node_setTransmitFifoQueueSize(nodeSfr, config->txConfig.txFifoQueueSize);
            }

            /* enable transmission interrupt on selected buffers */
            for (id = 0; id < (config->txConfig.dedicatedTxBuffersNumber + config->txConfig.txFifoQueueSize); ++id)
            {
                IfxCan_Node_enableTxBufferTransmissionInterrupt(nodeSfr, (IfxCan_TxBufferId)id);
            }
        }

        /* TX FIFO/Queue operation */
        else if ((config->txConfig.txMode == IfxCan_TxMode_fifo) || (config->txConfig.txMode == IfxCan_TxMode_queue))
        {
            /* set Tx FIFO/Queue mode */
            IfxCan_Node_setTransmitFifoQueueMode(nodeSfr, config->txConfig.txMode);

            /* select number of Tx buffers to be used as Tx FIFO/Queue */
            IfxCan_Node_setTransmitFifoQueueSize(nodeSfr, config->txConfig.txFifoQueueSize);

            /* enable transmission interrupt on selected buffers */
            for (id = 0; id < config->txConfig.txFifoQueueSize; ++id)
            {
                IfxCan_Node_enableTxBufferTransmissionInterrupt(nodeSfr, (IfxCan_TxBufferId)id);
            }
        }
        /* wrong selection */
        else
        {
            IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, 0);
        }

        /* set the Tx event fifo size and start address if selected */
        if ((config->txConfig.txEventFifoSize > 0) && (config->txConfig.txEventFifoSize <= 32))
        {
            IfxCan_Node_setTxEventFifoStartAddress(nodeSfr, config->messageRAM.txEventFifoStartAddress);
            IfxCan_Node_setTxEventFifoSize(nodeSfr, config->txConfig.txEventFifoSize);
        }
        else /* maximum number of configurable Tx Event FIFO elements is 32 */
        {
            IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, config->txConfig.txEventFifoSize <= 32);
        }

        /* enable CAN frame mode of transmission Standard or CAN FD Long or FD Long and Fast frames*/
        IfxCan_Node_setFrameMode(nodeSfr, config->frame.mode);
    }

    /*Enable Time Stamp*/
    if (config->timeStampConfig.timeStamper != IfxCan_TimeStamper_none)
    {
        if ((config->timeStampConfig.timeStamper == IfxCan_TimeStamper_tsuInternal) || (config->timeStampConfig.timeStamper == IfxCan_TimeStamper_tsuExternal))
        {
            IfxCan_Node_enableUseTsu(nodeSfr); /*Needed if TSU is used*/
            IfxCan_TsuConfig tsuConfig;
            tsuConfig.position = config->timeStampConfig.capturePosition;

            if (config->timeStampConfig.timeStamper == IfxCan_TimeStamper_tsuInternal)
            {
                /*Available for all Nodes*/

                tsuConfig.tsuCounterType = IfxCan_TsuCounter_internal;
                tsuConfig.prescalar      = config->timeStampConfig.tsuInternalPrescalar;

                IfxCan_Node_tsuInit(nodeSfr, tsuConfig);
            }
            else
            /*Only available for Nodes 1,2,3. Not available for Node 0.
             * The TSU of Node 1,2,3 connect to TSU Counter of Node 0,
             * configure Node 0 TSU first.*/
            {
                //TSCFG.TSUE = 1;
                //TSCFG.TBCS = 1; /*External TSU Counter*/
                //TSCFG.SCP = 0; /*Capture Time Stamp at End of Frame*/

                tsuConfig.tsuCounterType = IfxCan_TsuCounter_external;

                IfxCan_Node_tsuInit(nodeSfr, tsuConfig);
            }
        }
        /*16 bit Time Stamp. Counter value in TSCV.TSC*/
        else if ((config->timeStampConfig.timeStamper == IfxCan_TimeStamper_canInternal) || (config->timeStampConfig.timeStamper == IfxCan_TimeStamper_external))
        {
            IfxCan_Node_disableUseTsu(nodeSfr); /*Needed if Internal 16 bit Timer is used*/

            if (config->timeStampConfig.timeStamper == IfxCan_TimeStamper_canInternal)
            {
                IfxCan_Node_setInternalTimeStamp(nodeSfr, config->timeStampConfig.intPrescalar);
            }

            else
            {
                /*Select and configure external Timer*/
                IfxCan_Node_setExternalTimeStamp(nodeSfr, config->timeStampConfig.extPrescalar, config->timeStampConfig.triggerSource);

                /* Re-enabling configuration change since it is being disabled in IfxCan_Node_setExternalTimeStamp() */
                IfxCan_Node_enableConfigurationChange(node->node);

                /*Start the timer*/
                IfxCan_Node_forceStartExternalTimer(nodeSfr);
            }
        }
    }

    /* receive frame configuration */

    if ((config->frame.type == IfxCan_FrameType_receive) ||
        (config->frame.type == IfxCan_FrameType_transmitAndReceive) ||
        (config->frame.type == IfxCan_FrameType_remoteAnswer))
    {
        if ((config->rxConfig.rxMode == IfxCan_RxMode_dedicatedBuffers) ||
            (config->rxConfig.rxMode == IfxCan_RxMode_sharedFifo0) ||
            (config->rxConfig.rxMode == IfxCan_RxMode_sharedFifo1) ||
            (config->rxConfig.rxMode == IfxCan_RxMode_sharedAll))
        {
            /* set Rx buffer data length */
            IfxCan_Node_setRxBufferDataFieldSize(nodeSfr, config->rxConfig.rxBufferDataFieldSize);

            /* set Rx buffers start address in the Message RAM */
            IfxCan_Node_setRxBuffersStartAddress(nodeSfr, config->messageRAM.rxBuffersStartAddress);
        }

        if ((config->rxConfig.rxMode == IfxCan_RxMode_fifo0) ||
            (config->rxConfig.rxMode == IfxCan_RxMode_sharedFifo0) ||
            (config->rxConfig.rxMode == IfxCan_RxMode_sharedAll))
        {
            /* set Rx FIFO 0 data length */
            IfxCan_Node_setRxFifo0DataFieldSize(nodeSfr, config->rxConfig.rxFifo0DataFieldSize);

            /* set Rx FIFO 0 start address in the Message RAM */
            IfxCan_Node_setRxFifo0StartAddress(nodeSfr, config->messageRAM.rxFifo0StartAddress);

            /* set Rx FIFO 0 size */
            IfxCan_Node_setRxFifo0Size(nodeSfr, config->rxConfig.rxFifo0Size);

            /* set Rx FIFO 0 operating mode */
            IfxCan_Node_setRxFifo0OperatingMode(nodeSfr, config->rxConfig.rxFifo0OperatingMode);

            /* set Rx FIFO 0 watermark level */
            IfxCan_Node_setRxFifo0WatermarkLevel(nodeSfr, config->rxConfig.rxFifo0WatermarkLevel);
        }

        if ((config->rxConfig.rxMode == IfxCan_RxMode_fifo1) ||
            (config->rxConfig.rxMode == IfxCan_RxMode_sharedFifo1) ||
            (config->rxConfig.rxMode == IfxCan_RxMode_sharedAll))
        {
            /* set Rx FIFO 1 data length */
            IfxCan_Node_setRxFifo1DataFieldSize(nodeSfr, config->rxConfig.rxFifo1DataFieldSize);

            /* set Rx FIFO 1 start address in the Message RAM */
            IfxCan_Node_setRxFifo1StartAddress(nodeSfr, config->messageRAM.rxFifo1StartAddress);

            /* set Rx FIFO 1 size */
            IfxCan_Node_setRxFifo1Size(nodeSfr, config->rxConfig.rxFifo1Size);

            /* set Rx FIFO 1 operating mode */
            IfxCan_Node_setRxFifo1OperatingMode(nodeSfr, config->rxConfig.rxFifo1OperatingMode);

            /* set Rx FIFO 1 watermark level */
            IfxCan_Node_setRxFifo1WatermarkLevel(nodeSfr, config->rxConfig.rxFifo1WatermarkLevel);
        }

        /* enable CAN frame mode of transmission */
        IfxCan_Node_setFrameMode(nodeSfr, config->frame.mode);

        /* filter configuration */

        if ((config->filterConfig.messageIdLength == IfxCan_MessageIdLength_standard) ||
            (config->filterConfig.messageIdLength == IfxCan_MessageIdLength_both))
        {
            IfxCan_Node_setStandardFilterListStartAddress(nodeSfr, config->messageRAM.standardFilterListStartAddress);
            IfxCan_Node_setStandardFilterListSize(nodeSfr, config->filterConfig.standardListSize);
            IfxCan_Node_configureStandardFilterForNonMatchingFrames(nodeSfr, config->filterConfig.standardFilterForNonMatchingFrames);

            if (config->filterConfig.rejectRemoteFramesWithStandardId == 1U)
            {
                IfxCan_Node_rejectRemoteFramesWithStandardId(nodeSfr);
            }
        }

        if ((config->filterConfig.messageIdLength == IfxCan_MessageIdLength_extended) ||
            (config->filterConfig.messageIdLength == IfxCan_MessageIdLength_both))
        {
            IfxCan_Node_setExtendedFilterListStartAddress(nodeSfr, config->messageRAM.extendedFilterListStartAddress);
            IfxCan_Node_setExtendedIdAndMask(nodeSfr, config->filterConfig.extendedIdAndMask);
            IfxCan_Node_setExtendedFilterListSize(nodeSfr, config->filterConfig.extendedListSize);
            IfxCan_Node_configureExtendedFilterForNonMatchingFrames(nodeSfr, config->filterConfig.extendedFilterForNonMatchingFrames);

            if (config->filterConfig.rejectRemoteFramesWithExtendedId == 1U)
            {
                IfxCan_Node_rejectRemoteFramesWithExtendedId(nodeSfr);
            }
        }
    }

    /* pins initialisation */

    if (config->pins != NULL_PTR)
    {
        if (config->pins->txPin != NULL_PTR)
        {
            status |= (IfxCan_Node_initTxPin(config->pins->txPin, config->pins->txPinMode, config->pins->padDriver));
        }

        if (config->pins->rxPin != NULL_PTR)
        {
            status |= (IfxCan_Node_initRxPin(nodeSfr, config->pins->rxPin, config->pins->rxPinMode, config->pins->padDriver));
        }
    }

    /* enable internal virtual CAN bus loopback mode if selected */
    if (config->busLoopbackEnabled)
    {
        IfxCan_Node_enableLoopbackMode(nodeSfr);
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canSfr->PROTE), IfxApProt_State_config);
#endif
    node->node->CRE.CONFIG.B.EN = FALSE; /*CRE is disabled by default*/
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canSfr->PROTE), IfxApProt_State_run);
#endif

    // interrupt groups configuration
    /*Clear Can Interrupts*/
    nodeSfr->IR.U = IFXCAN_IR_CLEAR;
    volatile Ifx_SRC_SRCR *srcPointer;

    if ((config->interruptConfig.tefifo.priority > 0) || (config->interruptConfig.tefifo.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.tefifo.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_tefifo, config->interruptConfig.tefifo.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.tefifo.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.tefifo.typeOfService, config->interruptConfig.tefifo.priority, config->interruptConfig.tefifo.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.hpe.priority > 0) || (config->interruptConfig.hpe.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.hpe.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_hpe, config->interruptConfig.hpe.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.hpe.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.hpe.typeOfService, config->interruptConfig.hpe.priority, config->interruptConfig.hpe.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.wati.priority > 0) || (config->interruptConfig.wati.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.wati.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_wati, config->interruptConfig.wati.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.wati.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.wati.typeOfService, config->interruptConfig.wati.priority, config->interruptConfig.wati.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.alrt.priority > 0) || (config->interruptConfig.alrt.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.alrt.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_alrt, config->interruptConfig.alrt.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.alrt.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.alrt.typeOfService, config->interruptConfig.alrt.priority, config->interruptConfig.alrt.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.moer.priority > 0) || (config->interruptConfig.moer.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.moer.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_moer, config->interruptConfig.moer.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.moer.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.moer.typeOfService, config->interruptConfig.moer.priority, config->interruptConfig.moer.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.safe.priority > 0) || (config->interruptConfig.safe.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.safe.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_safe, config->interruptConfig.safe.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.safe.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.safe.typeOfService, config->interruptConfig.safe.priority, config->interruptConfig.safe.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.boff.priority > 0) || (config->interruptConfig.boff.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.boff.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_boff, config->interruptConfig.boff.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.boff.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.boff.typeOfService, config->interruptConfig.boff.priority, config->interruptConfig.boff.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.loi.priority > 0) || (config->interruptConfig.loi.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.loi.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_loi, config->interruptConfig.loi.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.loi.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.loi.typeOfService, config->interruptConfig.loi.priority, config->interruptConfig.loi.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.reint.priority > 0) || (config->interruptConfig.reint.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.reint.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_reint, config->interruptConfig.reint.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.reint.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.reint.typeOfService, config->interruptConfig.reint.priority, config->interruptConfig.reint.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.rxf1f.priority > 0) || (config->interruptConfig.rxf1f.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.rxf1f.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_rxf1f, config->interruptConfig.rxf1f.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.rxf1f.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.rxf1f.typeOfService, config->interruptConfig.rxf1f.priority, config->interruptConfig.rxf1f.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.rxf0f.priority > 0) || (config->interruptConfig.rxf0f.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.rxf0f.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_rxf0f, config->interruptConfig.rxf0f.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.rxf0f.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.rxf0f.typeOfService, config->interruptConfig.rxf0f.priority, config->interruptConfig.rxf0f.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.rxf1n.priority > 0) || (config->interruptConfig.rxf1f.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.rxf1f.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_rxf1n, config->interruptConfig.rxf1n.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.rxf1n.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.rxf1n.typeOfService, config->interruptConfig.rxf1n.priority, config->interruptConfig.rxf1n.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.rxf0n.priority > 0) || (config->interruptConfig.rxf0n.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.rxf0n.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_rxf0n, config->interruptConfig.rxf0n.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.rxf0n.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.rxf0n.typeOfService, config->interruptConfig.rxf0n.priority, config->interruptConfig.rxf0n.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.reti.priority > 0) || (config->interruptConfig.reti.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.reti.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_reti, config->interruptConfig.reti.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.reti.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.reti.typeOfService, config->interruptConfig.reti.priority, config->interruptConfig.reti.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.traq.priority > 0) || (config->interruptConfig.traq.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.traq.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_traq, config->interruptConfig.traq.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.traq.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.traq.typeOfService, config->interruptConfig.traq.priority, config->interruptConfig.traq.vmId);
        IfxSrc_enable(srcPointer);
    }

    if ((config->interruptConfig.traco.priority > 0) || (config->interruptConfig.traco.typeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.traco.typeOfService == IfxSrc_Tos_dma1))
    {
        IfxCan_Node_setGroupInterruptLine(nodeSfr, IfxCan_InterruptGroup_traco, config->interruptConfig.traco.interruptLine);
        srcPointer = IfxCan_getSrcPointer(config->can, config->interruptConfig.traco.interruptLine);
        IfxSrc_init(srcPointer, config->interruptConfig.traco.typeOfService, config->interruptConfig.traco.priority, config->interruptConfig.traco.vmId);
        IfxSrc_enable(srcPointer);
    }

    /* enable the selected interrupts */
    if (config->interruptConfig.rxFifo0NewMessageEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo0NewMessage);
    }

    if (config->interruptConfig.rxFifo0WatermarkEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo0WatermarkReached);
    }

    if (config->interruptConfig.rxFifo0FullEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo0Full);
    }

    if (config->interruptConfig.rxFifo0MessageLostEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo0MessageLost);
    }

    if (config->interruptConfig.rxFifo1NewMessageEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo1NewMessage);
    }

    if (config->interruptConfig.rxFifo1WatermarkEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo1WatermarkReached);
    }

    if (config->interruptConfig.rxFifo1FullEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo1Full);
    }

    if (config->interruptConfig.rxFifo1MessageLostEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_rxFifo1MessageLost);
    }

    if (config->interruptConfig.highPriorityMessageEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_highPriorityMessage);
    }

    if (config->interruptConfig.transmissionCompletedEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_transmissionCompleted);
    }

    if (config->interruptConfig.transmissionCancellationFinishedEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_transmissionCancellationFinished);
    }

    if (config->interruptConfig.txFifoEmptyEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_txFifoEmpty);
    }

    if (config->interruptConfig.txEventFifoNewEntryEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_txEventFifoNewEntry);
    }

    if (config->interruptConfig.txEventFifoWatermarkEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_txEventFifoWatermarkReached);
    }

    if (config->interruptConfig.txEventFifoFullEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_txEventFifoFull);
    }

    if (config->interruptConfig.txEventFifoEventLostEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_txEventFifoEventLost);
    }

    if (config->interruptConfig.timestampWraparoundEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_timestampWraparound);
    }

    if (config->interruptConfig.messageRAMAccessFailureEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_messageRAMAccessFailure);
    }

    if (config->interruptConfig.timeoutOccurredEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_timeoutOccurred);
    }

    if (config->interruptConfig.messageStoredToDedicatedRxBufferEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);
    }

    if (config->interruptConfig.errorLoggingOverflowEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_errorLoggingOverflow);
    }

    if (config->interruptConfig.errorPassiveEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_errorPassive);
    }

    if (config->interruptConfig.warningStatusEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_warningStatus);
    }

    if (config->interruptConfig.busOffStatusEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_busOffStatus);
    }

    if (config->interruptConfig.watchdogEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_watchdog);
    }

    if (config->interruptConfig.protocolErrorArbitrationEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_protocolErrorArbitration);
    }

    if (config->interruptConfig.protocolErrorDataEnabled)
    {
        IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_protocolErrorData);
    }

    /* disable configuration change CCCR.CCE = 0 */
    IfxCan_Node_disableConfigurationChange(nodeSfr);

    return status;
}


void IfxCan_Can_initNodeConfig(IfxCan_Can_NodeConfig *config, IfxCan_Can *can)
{
    const IfxCan_Can_NodeConfig defaultConfig = {
        .can         = NULL_PTR,
        .nodeId      = IfxCan_NodeId_0,
        .clockSource = IfxCan_ClockSource_both,
        .frame       = {
            .type = IfxCan_FrameType_receive,
            .mode = IfxCan_FrameMode_standard
        },
        .baudRate                                    = {
            .baudrate      = 500000,
            .samplePoint   = 8000,
            .syncJumpWidth = 3,
            .prescaler     = 0,
            .timeSegment1  = 3,
            .timeSegment2  = 10
        },
        .fastBaudRate                                = {
            .baudrate              = 1000000,
            .samplePoint           = 8000,
            .syncJumpWidth         = 3,
            .prescaler             = 1,
            .timeSegment1          = 3,
            .timeSegment2          = 10,
            .tranceiverDelayOffset = 0
        },
        .txConfig                                    = {
            .txMode                   = IfxCan_TxMode_dedicatedBuffers,
            .dedicatedTxBuffersNumber = 2,
            .txFifoQueueSize          = 0,
            .txBufferDataFieldSize    = IfxCan_DataFieldSize_8,
            .txEventFifoSize          = 0
        },
        .filterConfig                                = {
            .messageIdLength                    = IfxCan_MessageIdLength_standard,
            .standardListSize                   = 2,
            .extendedListSize                   = 0,
            .extendedIdAndMask                  = IFXCAN_EIDM_DEFAULT,
            .rejectRemoteFramesWithStandardId   = 0,
            .rejectRemoteFramesWithExtendedId   = 0,
            .standardFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_acceptToRxFifo0,
            .extendedFilterForNonMatchingFrames = IfxCan_NonMatchingFrame_acceptToRxFifo0
        },
        .rxConfig                                    = {
            .rxMode                = IfxCan_RxMode_dedicatedBuffers,
            .rxBufferDataFieldSize = IfxCan_DataFieldSize_8,
            .rxFifo0DataFieldSize  = IfxCan_DataFieldSize_8,
            .rxFifo1DataFieldSize  = IfxCan_DataFieldSize_8,
            .rxFifo0OperatingMode  = IfxCan_RxFifoMode_blocking,
            .rxFifo1OperatingMode  = IfxCan_RxFifoMode_blocking,
            .rxFifo0WatermarkLevel = 0,
            .rxFifo1WatermarkLevel = 0,
            .rxFifo0Size           = 0,
            .rxFifo1Size           = 0
        },
        .messageRAM                                  = {
            .baseAddress                    = (uint32)IfxCan_ramAddress[IfxCan_getIndex(can->can)],
            .standardFilterListStartAddress = 0x0,
            .extendedFilterListStartAddress = 0x80,
            .rxFifo0StartAddress            = 0x100,
            .rxFifo1StartAddress            = 0x200,
            .rxBuffersStartAddress          = 0x300,
            .txEventFifoStartAddress        = 0x400,
            .txBuffersStartAddress          = 0x440
        },
        .interruptConfig                             = {
            .rxFifo0NewMessageEnabled                = FALSE,
            .rxFifo0WatermarkEnabled                 = FALSE,
            .rxFifo0FullEnabled                      = FALSE,
            .rxFifo0MessageLostEnabled               = FALSE,
            .rxFifo1NewMessageEnabled                = FALSE,
            .rxFifo1WatermarkEnabled                 = FALSE,
            .rxFifo1FullEnabled                      = FALSE,
            .rxFifo1MessageLostEnabled               = FALSE,
            .highPriorityMessageEnabled              = FALSE,
            .transmissionCompletedEnabled            = FALSE,
            .transmissionCancellationFinishedEnabled = FALSE,
            .txFifoEmptyEnabled                      = FALSE,
            .txEventFifoNewEntryEnabled              = FALSE,
            .txEventFifoWatermarkEnabled             = FALSE,
            .txEventFifoFullEnabled                  = FALSE,
            .txEventFifoEventLostEnabled             = FALSE,
            .timestampWraparoundEnabled              = FALSE,
            .messageRAMAccessFailureEnabled          = FALSE,
            .timeoutOccurredEnabled                  = FALSE,
            .messageStoredToDedicatedRxBufferEnabled = FALSE,
            .errorLoggingOverflowEnabled             = FALSE,
            .errorPassiveEnabled                     = FALSE,
            .warningStatusEnabled                    = FALSE,
            .busOffStatusEnabled                     = FALSE,
            .watchdogEnabled                         = FALSE,
            .protocolErrorArbitrationEnabled         = FALSE,
            .protocolErrorDataEnabled                = FALSE,
            .tefifo                                  = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .hpe                                     = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .wati                                    = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .alrt                                    = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .moer                                    = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .safe                                    = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .boff                                    = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .loi                                     = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .reint                                   = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .rxf1f                                   = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .rxf0f                                   = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .rxf1n                                   = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .rxf0n                                   = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .reti                                    = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .traq                                    = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .traco                                   = {
                .interruptLine = IfxCan_InterruptLine_0,
                .priority      = 0,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            }
        },
        .pins                     = NULL_PTR,
        .busLoopbackEnabled       = FALSE,
        .calculateBitTimingValues = TRUE,
        .timeStampConfig          = {
            .timeStamper          = IfxCan_TimeStamper_none,
            .extPrescalar         = IfxCan_ExtTimerPrescalar_1,
            .intPrescalar         = IfxCan_IntTimerPrescalar_1,
            .triggerSource        = IfxCan_TimerTrigger_clock,
            .tsuInternalPrescalar = 0,
            .capturePosition      = IfxCan_TsuTimeStampPosition_endOfFrame
        }
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* take over module pointer */
    config->can = can->can;
}


void IfxCan_Can_setNodeRamAddresses(IfxCan_Can_Node *node, uint16 startAddress, uint16 endAddress)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_config);
#endif

    node->node->STARTADR.U = (0x0000FFFC & startAddress);
    node->node->ENDADR.U   = (0x0000FFFC & endAddress);

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_run);
#endif
}


uint16 IfxCan_Can_readThroughput(IfxCan_Can_Node *node)
{
    uint16 throughput = IfxCan_Node_Cre_getThroughput(node->node);

    return throughput;
}


uint32 IfxCan_Can_readInterArrivalMeasure(IfxCan_Can_Node *node, IfxCan_CreRxHostBufferIndex index)
{
    uint32         startAddress = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + node->node->CRE.CONFIGADR.U;  //Rx Fifo 0 Start Address, also start of CRE config address.
    startAddress = startAddress + ((IFXCAN_CRE_TABLE_SIZE + (index * IFXCAN_CRE_RXFIFO_SPACING)) * 4);                        //Jump to required Fifo address
    Ifx_CAN_RHBUF *rxBufPtr     = (Ifx_CAN_RHBUF *)startAddress;

    return IfxCan_Cre_waitAndGetValidIam(rxBufPtr);                                                                           /*Min 2 messages have to be received before IAM is avaialable*/
}


uint16 IfxCan_Can_readStandardGroupFrameRate(IfxCan_Can_Node *node, IfxCan_StdFrameGroupId id, boolean clearEnable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_config);
#endif

    IfxCan_Node_Cre_enableStdFrameRateLock(node->node);  /*Lock and freeze the Frame Rate Counters*/
    uint16 frameRate = IfxCan_Node_Cre_getStdGroupXFrameRate(node->node, id, (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), clearEnable);
    IfxCan_Node_Cre_disableStdFrameRateLock(node->node); /*Unlock the Frame Rate Counters*/

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_run);
#endif

    return frameRate;
}


uint16 IfxCan_Can_readExtendedGroupFrameRate(IfxCan_Can_Node *node, IfxCan_XtdFrameGroupId id, boolean clearEnable)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_config);
#endif

    IfxCan_Node_Cre_enableXtdFrameRateLock(node->node);  /*Lock and freeze the Frame Rate Counters*/
    uint16 frameRate = IfxCan_Node_Cre_getXtdGroupXFrameRate(node->node, id, (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), clearEnable);
    IfxCan_Node_Cre_disableXtdFrameRateLock(node->node); /*Unlock the Frame Rate Counters*/

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(node->can->PROTE), IfxApProt_State_run);
#endif

    return frameRate;
}


void IfxCan_Can_triggerDebugMessageToDre(IfxCan_Can_Node *node, IfxCan_CreRxHostBufferIndex index, Ifx_CAN_RHBUF *rxHostBufferPtr)
{
    Ifx_CAN_N_CRE *cre = &(node->node->CRE);

    /*Compute address of required RX FIFO Buffer based on index*/
    Ifx_CAN_RHBUF *rxBufPtr            = NULL_PTR;
    uint32         rxHostBufferAddress = 0;
    uint8          i, size;

    if (index == IfxCan_CreRxHostBufferIndex_1)
    {
        rxHostBufferAddress = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + cre->CONFIGADR.U + ((IFXCAN_CRE_TABLE_SIZE + IFXCAN_CRE_RXFIFO_SPACING) * 4);
        rxBufPtr            = (Ifx_CAN_RHBUF *)(rxHostBufferAddress);
    }
    else
    {
        rxHostBufferAddress = (node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + cre->CONFIGADR.U + (IFXCAN_CRE_TABLE_SIZE * 4);
        rxBufPtr            = (Ifx_CAN_RHBUF *)(rxHostBufferAddress);
    }

    size = sizeof(Ifx_CAN_RHBUF) / 4;
    uint32 *rxHostBuffer = (uint32 *)((uint32)&(rxBufPtr->UCRH.U));
    uint32 *debugData    = (uint32 *)((uint32)&(rxHostBufferPtr->UCRH.U));

    for (i = 0; i < size; i++)
    {
        *rxHostBuffer++ = *debugData++;
    }

    cre->HBUF.RX[index].STAT.B.SWTRIG = 1;

    while (cre->HBUF.RX[index].STAT.B.SWTRIG)
    {}
}


void IfxCan_Can_setStandardPduRouting(IfxCan_Can_Node *node, IfxCan_StdPduRouting *router)
{
    Ifx_CAN_CRE *creTableConfig = (Ifx_CAN_CRE *)((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + node->node->CRE.CONFIGADR.U);
    uint16       startAddress   = (creTableConfig->STD_RT_PARAM.B.SA << 2);

    /* get the standard router element address */
    Ifx_CAN_SRT *stdRoutingElementPtr = IfxCan_Node_getStandardRoutingElementAddress((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), startAddress, router->index);

    Ifx_CAN_SRT  stdRoutingElement;
    stdRoutingElement.PR.U      = 0;
    stdRoutingElement.PR.B.MODE = 2;
    stdRoutingElement.PR.B.DID  = router->destinationId;
    stdRoutingElement.PR.B.TYP  = router->pduType;
    stdRoutingElement.PR.B.MD   = router->metadata;

    stdRoutingElementPtr->PR.U  = stdRoutingElement.PR.U;
}


void IfxCan_Can_setExtendedPduRouting(IfxCan_Can_Node *node, IfxCan_XtdPduRouting *router)
{
    Ifx_CAN_CRE *creTableConfig = (Ifx_CAN_CRE *)((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK) + node->node->CRE.CONFIGADR.U);
    uint16       startAddress   = (creTableConfig->XTD_RT_PARAM.B.SA << 2);

    /* get the extended router element address */
    Ifx_CAN_XRT *xtdRoutingElementPtr = IfxCan_Node_getExtendedRoutingElementAddress((node->messageRAM.baseAddress & IFXCAN_MODULE_ADDRESS_MASK), startAddress, router->index);

    Ifx_CAN_XRT  xtdRoutingElement;
    xtdRoutingElement.PR.U      = 0;

    xtdRoutingElement.PR.B.MODE = 2;
    xtdRoutingElement.PR.B.DID  = router->destinationId;
    xtdRoutingElement.PR.B.TYP  = router->pduType;
    //xtdRoutingElement.PR.B.MD   = router->metadata; //Removed in MC_ACE_A3G_HSI_MCMCAN/V0.2.1.1.5

    xtdRoutingElementPtr->PR.U = xtdRoutingElement.PR.U;
}
