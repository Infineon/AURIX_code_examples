/**
 * \file IfxCanxl.c
 * \brief CANXL  basic functionality
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxCanxl.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxCanxl_initApConfig(IfxCanxl_ApConfig *config)
{
    /* Initialize PROT configurations */
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);

    /* Initialize APU configurations */
    IfxApApu_initConfig(&config->apuCanxlConfig);
    IfxApApu_initConfig(&config->apuNode0Config);
    IfxApApu_initConfig(&config->apuNode1Config);
    IfxApApu_initConfig(&config->apuNode2Config);
    IfxApApu_initConfig(&config->apuNode3Config);
}


void IfxCanxl_initAp(Ifx_CANXL *canxl, IfxCanxl_ApConfig *config)
{
    /* Initialize the PROTs */
    IfxApProt_init((Ifx_PROT_PROT *)&canxl->PROTE, &config->proteConfig);
    IfxApProt_init((Ifx_PROT_PROT *)&canxl->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN
     * All the APUs are protected by PROTSE
     */
    IfxApProt_setState((Ifx_PROT_PROT *)&canxl->PROTSE, IfxApProt_State_config);

    /* Initialize the APUs */
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&canxl->MODULE.ACCEN, &config->apuCanxlConfig);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&canxl->NODE[0].ACCENNODE, &config->apuNode0Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&canxl->NODE[1].ACCENNODE, &config->apuNode1Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&canxl->NODE[2].ACCENNODE, &config->apuNode2Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&canxl->NODE[3].ACCENNODE, &config->apuNode3Config);

    IfxApProt_setState((Ifx_PROT_PROT *)&canxl->PROTSE, IfxApProt_State_run);
}


void IfxCanxl_nodeBusIdConfig(Ifx_CANXL *canSFR, IfxCanxl_NodeId nodeId, IfxCanxl_nodeApuConfig *nodeApuConfig)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canSFR->PROTSE), IfxApProt_State_config);
#endif

    canSFR->NODE[nodeId].VMPRSCONFIG.B.PRS   = nodeApuConfig->prsId;
    canSFR->NODE[nodeId].VMPRSCONFIG.B.PRSEN = nodeApuConfig->prsEnable;
    canSFR->NODE[nodeId].VMPRSCONFIG.B.VM    = nodeApuConfig->vmId;
    canSFR->NODE[nodeId].VMPRSCONFIG.B.VMEN  = nodeApuConfig->vmEnable;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canSFR->PROTSE), IfxApProt_State_run);
#endif
}


void IfxCanxl_disableModule(Ifx_CANXL *canxl)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_config);
#endif

    /* Disable module */
    canxl->MODULE.CLC.B.DISR = 1U;

    /* Wait until module is disabled */
    while (IfxCanxl_isModuleEnabled(canxl) == TRUE)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_run);
#endif
}


void IfxCanxl_enableModule(Ifx_CANXL *canxl)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_config);
#endif

    /* Enable module, disregard Sleep Mode request */
    canxl->MODULE.CLC.B.DISR = 0U;

    /* Wait until module is enabled */
    while (IfxCanxl_isModuleEnabled(canxl) == FALSE)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_run);
#endif
}


void IfxCanxl_resetModule(Ifx_CANXL *canxl)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_config);
#endif
    /* Only if both Kernel reset bits are set, a reset is executed */
    canxl->MODULE.RST.CTRLA.B.KRST = 1U;
    canxl->MODULE.RST.CTRLB.B.KRST = 1U;

    /* Wait until reset is executed */
    while (canxl->MODULE.RST.STAT.B.KRST == 0U)
    {}

    /* Clear Kernel reset status bit */
    canxl->MODULE.RST.CTRLB.B.STATCLR = 1U;

    while (canxl->MODULE.RST.STAT.B.KRST == 1U)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_run);
#endif
}


void IfxCanxl_resetNode(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_config);
#endif
    /* Get pointer to node registers */
    Ifx_CANXL_NODE *node = &(canxl->NODE[nodeId]);

    /* Only if both Kernel reset bits are set, a reset is executed */
    node->RST.CTRLA.B.KRST = 1U;
    node->RST.CTRLB.B.KRST = 1U;

    /* Wait until reset is executed */
    while (node->RST.STAT.B.KRST == 0U)
    {}

    /* Clear Kernel reset status bit */
    node->RST.CTRLB.B.STATCLR = 1U;

    while (node->RST.STAT.B.KRST == 1U)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_run);
#endif
}


void IfxCanxl_enableNode(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_config);
#endif
    /* Write 1 to enable */
    uint32 mask  = 1u << (uint32)nodeId;
    uint32 value = 1u << (uint32)nodeId;

    Ifx__ldmst(&canxl->CLKEN, mask, value);

    /* Wait while node is disabled */
    while (IfxCanxl_isNodeEnabled(canxl, nodeId) == FALSE)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_run);
#endif
}


void IfxCanxl_disableNode(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_config);
#endif
    /* Write 0 to disable */
    uint32 mask  = IFX_CANXL_CLKEN_N0_CC_MSK << (uint32)nodeId;
    uint32 value = 0u;

    Ifx__ldmst(&canxl->CLKEN, mask, value);

    /* Wait while node is enabled */
    while (IfxCanxl_isNodeEnabled(canxl, nodeId) == TRUE)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(canxl->PROTE), IfxApProt_State_run);
#endif
}


uint32 IfxCanxl_getModuleFrequency(void)
{
    uint32 moduleFreq = 0U;

    moduleFreq = IfxClock_getCanXLFrequency();

    return moduleFreq;
}


void IfxCanxl_Node_initRxPin(Ifx_CANXL_NODE *node, IfxCanxl_Rxd_In *rxd, IfxPort_InputMode mode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeInput(rxd->pin.port, rxd->pin.pinIndex, mode);
    IfxPort_setPinPadDriver(rxd->pin.port, rxd->pin.pinIndex, padDriver);

    /* RXSEL selects one out of 8 possible receive inputs */
    node->PORTCTRL.B.RXSEL = rxd->select;
}


void IfxCanxl_Node_initTxPin(IfxCanxl_Txd_Out *txd, IfxPort_OutputMode mode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(txd->pin.port, txd->pin.pinIndex, mode, txd->select);
    IfxPort_setPinPadDriver(txd->pin.port, txd->pin.pinIndex, padDriver);
}


boolean IfxCanxl_Node_configurePwmEncoder(Ifx_CANXL_N *node, uint8 shortPhase, uint8 longPhase, uint8 offset)
{
    boolean result = FALSE;

    /* PWMO shall always be smaller than the PWM symbol length */
    if ((uint16)offset < IFXCANXL_CALC_PWM_SYMBOL_LENGTH(shortPhase, longPhase))
    {
        Ifx_CANXL_N_PCFG pcfgReg;

        /* Copy values into register variable*/
        pcfgReg.B.PWMS = shortPhase;
        pcfgReg.B.PWML = longPhase;
        pcfgReg.B.PWMO = offset;

        /* Set register value */
        node->PCFG.U = pcfgReg.U;
        result       = TRUE;
    }

    return result;
}


void IfxCanxl_Node_setOperationMode(Ifx_CANXL_N *node, IfxCanxl_Node_OperationMode mode)
{
    Ifx_CANXL_N_MODE modeReg;

    /* 1. Read current value */
    modeReg.U = node->MODE.U;

    /* 2. Set the bitfields according to operation mode */
    switch (mode)
    {
    case IfxCanxl_Node_OperationMode_classical:
    {
        modeReg.B.FDOE = 0u;    /* 0: Node is FD tolerant */
        modeReg.B.XLOE = 0u;    /* 0: No arbitration during FDF bit */
        modeReg.B.XLTR = 0u;    /* 0: XL Transceiver Disconnected */
        modeReg.B.EFDI = 0u;    /* 0: Error Signaling is enabled  */
        break;
    }
    case IfxCanxl_Node_OperationMode_classicalAndFd:
    {
        modeReg.B.FDOE = 1u;    /* 1: Node is FD enabled */
        modeReg.B.XLOE = 0u;    /* 0: No arbitration during FDF bit */
        modeReg.B.XLTR = 0u;    /* 0: XL Transceiver Disconnected */
        modeReg.B.EFDI = 0u;    /* 0: Error Signaling is enabled  */
        break;
    }
    case IfxCanxl_Node_OperationMode_classicalAndFdAndXl:
    {
        modeReg.B.FDOE = 1u;    /* 1: Node is FD enabled */
        modeReg.B.XLOE = 1u;    /* 1: Arbitration during FDF bit and XLF bit */
        modeReg.B.XLTR = 0u;    /* 0: XL Transceiver Disconnected */
        modeReg.B.EFDI = 0u;    /* 0: Error Signaling is enabled  */
        break;
    }
    case IfxCanxl_Node_OperationMode_xl:
    {
        modeReg.B.FDOE = 1u;    /* 1: Node is FD enabled */
        modeReg.B.XLOE = 1u;    /* 1: Arbitration during FDF bit and XLF bit */
        modeReg.B.XLTR = 0u;    /* 0: XL Transceiver Disconnected */
        modeReg.B.EFDI = 1u;    /* 1: Error Signaling is disabled and only CAN XL frames are transmitted  */
        break;
    }
    case IfxCanxl_Node_OperationMode_xlWithTransciever:
    default:
    {
        modeReg.B.FDOE = 1u;    /* 1: Node is FD enabled */
        modeReg.B.XLOE = 1u;    /* 1: Arbitration during FDF bit and XLF bit */
        modeReg.B.XLTR = 1u;    /* 1: XL Transceiver Connected */
        modeReg.B.EFDI = 1u;    /* 1: Error Signaling is disabled and only CAN XL frames are transmitted  */
        break;
    }
    }

    /* 3. Write back to register */
    node->MODE.U = modeReg.U;
}


void IfxCanxl_Node_setNominalBitTimingValues(Ifx_CANXL_N *node, uint8 syncJumpWidth, uint8 timeSegment2, uint16 timeSegment1, uint8 prescaler)
{
    Ifx_CANXL_N_NBTP nbtpReg;

    nbtpReg.B.NSJW   = syncJumpWidth;
    nbtpReg.B.NTSEG1 = timeSegment1;
    nbtpReg.B.NTSEG2 = timeSegment2;
    nbtpReg.B.BRP    = prescaler;

    node->NBTP.U     = nbtpReg.U;
}


void IfxCanxl_Node_setFdDataBitTimingValues(Ifx_CANXL_N *node, uint8 syncJumpWidth, uint8 timeSegment2, uint8 timeSegment1, uint8 delayOffset)
{
    Ifx_CANXL_N_DBTP dbtpReg;

    dbtpReg.B.DSJW   = syncJumpWidth;
    dbtpReg.B.DTSEG1 = timeSegment1;
    dbtpReg.B.DTSEG2 = timeSegment2;
    dbtpReg.B.DTDCO  = delayOffset;

    if (delayOffset > 0u)
    {
        IfxCanxl_Node_enableTransmitterDelayCompensation(node);
    }

    node->DBTP.U = dbtpReg.U;
}


void IfxCanxl_Node_setXlDataBitTimingValues(Ifx_CANXL_N *node, uint8 syncJumpWidth, uint8 timeSegment2, uint8 timeSegment1, uint8 delayOffset)
{
    Ifx_CANXL_N_XBTP xbtpReg;

    xbtpReg.B.XSJW   = syncJumpWidth;
    xbtpReg.B.XTSEG1 = timeSegment1;
    xbtpReg.B.XTSEG2 = timeSegment2;
    xbtpReg.B.XTDCO  = delayOffset;

    if (delayOffset > 0u)
    {
        IfxCanxl_Node_enableTransmitterDelayCompensation(node);
    }

    node->XBTP.U = xbtpReg.U;
}


uint8 IfxCanxl_Node_calculateBitratePrescaler(uint32 moduleFreq, uint32 dataBaudRate, uint32 nominalBaudrate)
{
    float32 clockPeriod    = 1.0f / moduleFreq;
    float32 nominalBitTime = 1.0f / nominalBaudrate;
    float32 timeQuantum;
    uint32  numDataTq, numNominalTq;
    uint8   tempPrescaler;
    uint8   prescaler = 1u;
    boolean result;

    if (dataBaudRate != 0u)
    {
        float32 dataBitTime = 1.0f / (float32)dataBaudRate;

        for (tempPrescaler = 1u; tempPrescaler <= IFX_CANXL_N_NBTP_BRP_MSK + 1u; tempPrescaler++)
        {
            timeQuantum  = tempPrescaler * clockPeriod;     /* Tq = prescaler * mtq */
            numDataTq    = (uint32)(dataBitTime / timeQuantum);
            numNominalTq = (uint32)(nominalBitTime / timeQuantum);

            result       = TRUE;

            if ((numDataTq < 8u) || (numDataTq > 385u)) /* Check number of Tq in range */
            {
                result = FALSE;
            }

            if ((result == TRUE) &&
                (numNominalTq >= 8u) && (numNominalTq <= 641u)) /* Check number of Tq in range */
            {
                /* If different parameter combinations come to the same length of the bit time, the combination
                 * with the shorter tq results in a better synchronization of the nodes. Hence, break at earliest.
                 */
                prescaler = tempPrescaler;
                break;
            }
        }
    }
    else
    {
        for (tempPrescaler = 1u; tempPrescaler <= IFX_CANXL_N_NBTP_BRP_MSK + 1u; tempPrescaler++)
        {
            timeQuantum  = tempPrescaler * clockPeriod;         /* Tq = prescaler * mtq */
            numNominalTq = (uint32)(nominalBitTime / timeQuantum);

            if ((numNominalTq >= 8u) && (numNominalTq <= 641u)) /* Check number of Tq in range */
            {
                /* If different parameter combinations come to the same length of the bit time, the combination
                 * with the shorter tq results in a better synchronization of the nodes. Hence, break at earliest.
                 */
                prescaler = tempPrescaler;
                break;
            }
        }
    }

    return prescaler;
}


void IfxCanxl_Node_configureClassicalBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig)
{
    /* 1. Calculate prescaler */
    uint8   prescaler = IfxCanxl_Node_calculateBitratePrescaler(moduleFreq, 0u, nominalConfig->baudrate);

    /* 2. Set arbitration baud rate */
    float32 clockPeriod, timeQuantum, bitTimeSec;
    uint32  timeSegment1, timeSegment2, bitTimeTq;

    clockPeriod  = 1.0f / moduleFreq;                                                             /* CAN-XL clock period in seconds */
    timeQuantum  = prescaler * clockPeriod;                                                       /* Length of time quantum in seconds */

    bitTimeSec   = 1.0f / nominalConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                            /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)nominalConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                 /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setNominalBitTimingValues(node, nominalConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint16)(timeSegment1 - 1u), prescaler - 1u);
}


void IfxCanxl_Node_configureFdBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig, IfxCanxl_DataBaudrateConfig *fdDataConfig)
{
    /* 1. Calculate prescaler */
    uint8   prescaler = IfxCanxl_Node_calculateBitratePrescaler(moduleFreq, fdDataConfig->baudrate, nominalConfig->baudrate);

    /* 2. Set arbitration baud rate */
    float32 clockPeriod, timeQuantum, bitTimeSec;
    uint32  timeSegment1, timeSegment2, bitTimeTq;

    clockPeriod  = 1.0f / moduleFreq;                                                             /* CAN-XL clock period in seconds */
    timeQuantum  = prescaler * clockPeriod;                                                       /* Length of time quantum in seconds */

    bitTimeSec   = 1.0f / nominalConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                            /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)nominalConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                 /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setNominalBitTimingValues(node, nominalConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint16)(timeSegment1 - 1u), prescaler - 1u);

    /* 3. Set data phase baud rate */
    bitTimeSec   = 1.0f / fdDataConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                           /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)fdDataConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setFdDataBitTimingValues(node, fdDataConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint8)(timeSegment1 - 1u), fdDataConfig->delayOffset);
}


void IfxCanxl_Node_configureXlBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig, IfxCanxl_DataBaudrateConfig *xlDataConfig)
{
    /* 1. Calculate prescaler */
    uint8   prescaler = IfxCanxl_Node_calculateBitratePrescaler(moduleFreq, xlDataConfig->baudrate, nominalConfig->baudrate);

    /* 2. Set arbitration baud rate */
    float32 clockPeriod, timeQuantum, bitTimeSec;
    uint32  timeSegment1, timeSegment2, bitTimeTq;

    clockPeriod  = 1.0f / moduleFreq;                                                             /* CAN-XL clock period in seconds */
    timeQuantum  = prescaler * clockPeriod;                                                       /* Length of time quantum in seconds */

    bitTimeSec   = 1.0f / nominalConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                            /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)nominalConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                 /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setNominalBitTimingValues(node, nominalConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint16)(timeSegment1 - 1u), prescaler - 1u);

    /* 3. Set data phase baud rate */
    bitTimeSec   = 1.0f / xlDataConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                           /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)xlDataConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setXlDataBitTimingValues(node, xlDataConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint8)(timeSegment1 - 1u), xlDataConfig->delayOffset);
}


void IfxCanxl_Node_configureFdXlBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig, IfxCanxl_DataBaudrateConfig *fdDataConfig, IfxCanxl_DataBaudrateConfig *xlDataConfig)
{
    /* 1. Calculate prescaler */
    uint32  maxBaudrate = __max(fdDataConfig->baudrate, xlDataConfig->baudrate);
    uint8   prescaler   = IfxCanxl_Node_calculateBitratePrescaler(moduleFreq, maxBaudrate, nominalConfig->baudrate);

    /* 2. Set arbitration baud rate */
    float32 clockPeriod, timeQuantum, bitTimeSec;
    uint32  timeSegment1, timeSegment2, bitTimeTq;

    clockPeriod  = 1.0f / moduleFreq;                                                             /* CAN-XL clock period in seconds */
    timeQuantum  = prescaler * clockPeriod;                                                       /* Length of time quantum in seconds */

    bitTimeSec   = 1.0f / nominalConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                            /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)nominalConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                 /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setNominalBitTimingValues(node, nominalConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint16)(timeSegment1 - 1u), prescaler - 1u);

    /* 3. Set data phase baud rate */
    bitTimeSec   = 1.0f / fdDataConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                           /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)fdDataConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setFdDataBitTimingValues(node, fdDataConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint8)(timeSegment1 - 1u), fdDataConfig->delayOffset);

    /* 4. Set data phase baud rate */
    bitTimeSec   = 1.0f / xlDataConfig->baudrate;                                                /* Length of one bit in seconds */
    bitTimeTq    = (uint32)(bitTimeSec / timeQuantum);                                           /* Length of one bit in terms of time quantum */
    timeSegment1 = (uint32)((bitTimeTq) * ((float32)xlDataConfig->samplePoint / 10000.0f)) - 1u; /* Time segment 1 is 1Tq to sample point */
    timeSegment2 = bitTimeTq - timeSegment1 - 1u;                                                /* Time segment 2 is from sample point to end of bit time */

    IfxCanxl_Node_setXlDataBitTimingValues(node, xlDataConfig->syncJumpWidth, (uint8)(timeSegment2 - 1u), (uint8)(timeSegment1 - 1u), xlDataConfig->delayOffset);
}


void IfxCanxl_Node_configureProtocolOperation(Ifx_CANXL_N *node, IfxCanxl_ProtocolOperation operation)
{
    switch (operation)
    {
    case IfxCanxl_ProtocolOperation_stop:
    case IfxCanxl_ProtocolOperation_immediateStop:
    {
        /* Perform unlock sequence for STOP/IMMD bitfields and write to control register */
        node->LOCK.U = IFXCANXL_FUNCTIONAL_UNLOCK_KEY1;
        node->LOCK.U = IFXCANXL_FUNCTIONAL_UNLOCK_KEY2;
        node->CTRL.U = (uint32)operation;
        break;
    }
    case IfxCanxl_ProtocolOperation_start:
    case IfxCanxl_ProtocolOperation_softwareReset:
    {
        /* No unlock is required. Write directly to control register. */
        node->CTRL.U = (uint32)operation;
        break;
    }
    case IfxCanxl_ProtocolOperation_test:
    default:
    {
        /* Perform unlock sequence for TEST bitfield and write to control register */
        node->LOCK.U = (uint32)IFXCANXL_TEST_MODE_UNLOCK_KEY1 << IFX_CANXL_N_LOCK_TMK_OFF;
        node->LOCK.U = (uint32)IFXCANXL_TEST_MODE_UNLOCK_KEY2 << IFX_CANXL_N_LOCK_TMK_OFF;
        node->CTRL.U = (uint32)operation;
        break;
    }
    }
}


void IfxCanxl_Node_configureGlobalSettingsRxFilter(Ifx_CANXL_N *node, IfxCanxl_Can_RxFilterGlobalConfig *config)
{
    Ifx_CANXL_N_RX_FILTER_CTRL regRxFilterCtrl;
    regRxFilterCtrl.U           = 0u;

    regRxFilterCtrl.B.ANFF      = config->acceptNonFilterFrames;
    regRxFilterCtrl.B.ANMF      = config->acceptNoMatch;
    regRxFilterCtrl.B.ANMF_FQ   = config->defaultRxQueueNum;
    regRxFilterCtrl.B.NB_FE     = config->numRxFilterElements;
    regRxFilterCtrl.B.THRESHOLD = config->thresholdRxDmaFifolevel;

    /*poll MH_STS.B.BUSY bit before performing write operation to RX filter CTRL registers*/
    while (IfxCanxl_Node_mhBusyStatus(node))
    {}

    node->RX_FILTER_CTRL.U = regRxFilterCtrl.U;
}


void IfxCanxl_configureAccessToCanxls(IfxApApu_ApuConfig *apConfig)
{
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_CANXL0.MODULE.ACCEN, apConfig);

    uint8 idx = 0u;

    for (idx = 0u; idx < IFXCANXL_NUM_NODES; idx++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_CANXL0.NODE[idx].ACCENNODE, apConfig);
    }
}


uint32 IfxCanxl_Node_getNominalBaudRate(Ifx_CANXL_N *node)
{
    uint32           timeSegment1, timeSegment2, prescaler, baudrate, bitTimeTq;
    float32          clockPeriod, timeQuantum, bitTimeSec;
    Ifx_CANXL_N_NBTP nbtpReg;

    /* 1. Read register content */
    nbtpReg.U    = node->NBTP.U;
    timeSegment1 = nbtpReg.B.NTSEG1 + 1u;
    timeSegment2 = nbtpReg.B.NTSEG2 + 1u;
    prescaler    = nbtpReg.B.BRP + 1u;

    /* 2. Calculate baud rate */
    clockPeriod = 1.0f / (float32)IfxCanxl_getModuleFrequency(); /* CAN-XL clock period in seconds */
    timeQuantum = prescaler * clockPeriod;                       /* Length of time quantum in seconds */

    bitTimeTq   = timeSegment1 + timeSegment2 + 1u;              /* Bit time = Time segment 1 + Time segment 2 + 1 */
    bitTimeSec  = bitTimeTq * timeQuantum;
    baudrate    = 1.0f / bitTimeSec;

    return baudrate;
}


uint32 IfxCanxl_Node_getFdBaudRate(Ifx_CANXL_N *node)
{
    uint32           timeSegment1, timeSegment2, prescaler, baudrate, bitTimeTq;
    float32          clockPeriod, timeQuantum, bitTimeSec;
    Ifx_CANXL_N_DBTP dbtpReg;

    /* 1. Read register content */
    dbtpReg.U    = node->DBTP.U;
    timeSegment1 = dbtpReg.B.DTSEG1 + 1u;
    timeSegment2 = dbtpReg.B.DTSEG2 + 1u;
    prescaler    = node->NBTP.B.BRP + 1u;

    /* 2. Calculate baud rate */
    clockPeriod = 1.0f / (float32)IfxCanxl_getModuleFrequency(); /* CAN-XL clock period in seconds */
    timeQuantum = prescaler * clockPeriod;                       /* Length of time quantum in seconds */

    bitTimeTq   = timeSegment1 + timeSegment2 + 1u;              /* Bit time = Time segment 1 + Time segment 2 + 1 */
    bitTimeSec  = bitTimeTq * timeQuantum;
    baudrate    = 1.0f / bitTimeSec;

    return baudrate;
}


uint32 IfxCanxl_Node_getXlBaudRate(Ifx_CANXL_N *node)
{
    uint32           timeSegment1, timeSegment2, prescaler, baudrate, bitTimeTq;
    float32          clockPeriod, timeQuantum, bitTimeSec;
    Ifx_CANXL_N_XBTP xbtpReg;

    /* 1. Read register content */
    xbtpReg.U    = node->XBTP.U;
    timeSegment1 = xbtpReg.B.XTSEG1 + 1u;
    timeSegment2 = xbtpReg.B.XTSEG2 + 1u;
    prescaler    = node->NBTP.B.BRP + 1u;

    /* 2. Calculate baud rate */
    clockPeriod = 1.0f / (float32)IfxCanxl_getModuleFrequency(); /* CAN-XL clock period in seconds */
    timeQuantum = prescaler * clockPeriod;                       /* Length of time quantum in seconds */

    bitTimeTq   = timeSegment1 + timeSegment2 + 1u;              /* Bit time = Time segment 1 + Time segment 2 + 1 */
    bitTimeSec  = bitTimeTq * timeQuantum;
    baudrate    = 1.0f / bitTimeSec;

    return baudrate;
}
