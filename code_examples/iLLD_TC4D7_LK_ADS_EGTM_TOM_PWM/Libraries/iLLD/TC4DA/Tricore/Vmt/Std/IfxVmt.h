/**
 * \file IfxVmt.h
 * \brief VMT  basic functionality
 * \ingroup IfxLld_Vmt
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Vmt_Usage How to use the VMT driver?
 * \ingroup IfxLld_Vmt
 *
 * The Volatile Memory Test (VMT)  controls and monitors the test, initialization and data integrity checking functions of the various internal memories in the device
 *
 * The VMT driver provides set of routines for various Mbist operations
 *
 * In the following sections it will be described, how to integrate the Vmt driver into the application framework.
 *
 * \section IfxLld_Vmt_SramInit Sram Initialisation
 * \subsection IfxLld_Vmt_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Vmt/IfxVmt.h>
 * // include below file only if interrupt mode is used.
 * #include "Src/Std/IfxSrc.h"
 * \endcode
 *
 * \subsection IfxLld_Vmt_Variables Variables
 *
 * \code
 * // used only if interrupt mode is used.
 * static IfxVmt_MbistSel mbistSel;
 * \endcode
 *
 * \subsection IfxLld_Vmt_Interrupt Interrupt Handler Installation
 *
 * See also \ref IfxLld_Cpu_Irq_Usage
 *
 * Define priorities for the Interrrupt handlers. This is normally done in the Ifx_IntPrioDef.h file:
 * \code
 * // priorities are normally defined in Ifx_IntPrioDef.h
 * #define IFX_INTPRIO_VMT  10
 *
 * \endcode
 *
 * Add the interrupt service routines to your C code. They have to call the Vmt interrupt handlers:
 * \code
 * IFX_INTERRUPT(vmtDoneISR, 0, IFX_INTPRIO_VMT)
 * {
 *     IfxVmt_isrDone();
 * }
 * \endcode
 *
 * Finally install the interrupt handlers in your initialisation function:
 * \code
 *         volatile Ifx_SRC_SRCR *src;
 *         src = &MODULE_SRC.VMT[0].MBDONE ;
 *         IfxSrc_init(src, IfxCpu_Irq_getTos(IfxCpu_getCoreIndex()) , IFX_INTPRIO_VMT );
 *         IfxSrc_enable(src);
 *
 *     // install interrupt handlers
 *     IfxCpu_Irq_installInterruptHandler(&vmtDoneISR, IFX_INTPRIO_VMT);
 *     IfxCpu_enableInterrupts();
 * \endcode
 *
 * \subsection IfxLld_Vmt_ClearSram_SyncPolling Clear Sram (Synchronous polling mode)
 *
 * The Sram initialisation in synchronous polling mode (i.e wait till the complete operation is done) can be used as:
 *
 * \code
 *     clearSram(IfxVmt_MbistSel_cpu0Dspr);
 * \endcode
 *
 * \subsection IfxLld_Vmt_ClearSram_ASyncPolling Clear Sram (Asynchronous polling mode)
 *
 * The Sram initialisation can be triggered by calling IfxVmt_clearSramStart() function, then can be queried for completion in a task using IfxVmt_isMbistDone. Once it's completed, then IfxVmt_clearSramContinue() has to be
 * called.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE) for the IfxVmt_clearSramStart() and IfxVmt_clearSramContinue() functions.
 *
 * Following code triggers Sram initilisation.
 * \code
 *
 *     IfxVmt_clearSramStart(IfxVmt_MbistSel_cpu0Dspr);
 *
 * \endcode
 *
 * Sram initialisation status can be queried in a task and once done complete the operation using:
 * \code
 *     if (IfxVmt_isMbistDone(IfxVmt_MbistSel_cpu0Dspr))
 *     {
 *         // Sram Clear operation done
 *
 *
 *         IfxVmt_clearSramContinue(IfxVmt_MbistSel_cpu0Dspr);
 *
 *     }
 *     else
 *     {
 *         // Sram operation is still in progress
 *     }
 * \endcode
 *
 * \subsection IfxLld_Vmt_ClearSram_ASyncInterrupt Clear Sram (Asynchronous interrupt mode)
 * Do the interrupt configuration and initialisation as specified in \ref IfxLld_Vmt_Interrupt
 * The Sram initialisation can be triggered by calling IfxVmt_clearSramStart() function. Once the operation is completed, Vmt Done isr is raised. Inside the Isr IfxVmt_clearSramContinue() has to be called.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE) for the IfxVmt_clearSramStart() and IfxVmt_clearSramContinue() functions.
 *
 * Following code triggers Sram initialisation.
 * \code
 *
 *     mbistSel = IfxVmt_MbistSel_cpu0Dspr; // mbistSel is a static / global variable.
 *     IfxVmt_clearSramStart(mbistSel);
 *
 * \endcode
 * In the Vmt done isr, the following code can be used.
 *
 * \code
 *     if (IfxVmt_isMbistDone(mbistSel))
 *     {
 *         // Sram Clear operation done
 *
 *         IfxVmt_clearSramContinue(mbistSel);
 *
 *     }
 *
 * \endcode
 *
 * \section IfxLld_Vmt_SramError Sram Error tracking
 * Example usage of Sram Error tracking
 * \code
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE)
 *
 * IfxVmt_MbistSel mbistSel = IfxVmt_MbistSel_cpu1Dspr;
 * Ifx_MC *mc = (Ifx_MC *)(IFXVMT_MC_ADDRESS_BASE + 0x100 * mbistSel);
 *
 * IfxVmt_enableMbistShell(mbistSel);
 *
 * // for auto-init memories: wait for the end of the clear operation
 * while (IfxVmt_isAutoInitRunning(mbistSel))
 * {}
 * IfxVmt_enableErrorTracking(mbistSel, TRUE);
 * uint32 numEtrr = 5;
 * // print tracked error address
 * {
 *  Ifx_MC_ETRR trackedSramAddresses[IFXVMT_MAX_TRACKED_ADDRESSES];
 *  uint8  numTrackedAddresses = IfxVmt_getTrackedSramAddresses(mbistSel, trackedSramAddresses);
 *  for(uint32 i=0; i<numEtrr; ++i) {
 *                         printf("%d: Error Address:0x%04x, Error System Address:0x%04x \n",
 *                                    i,
 *                                    trackedSramAddresses[i].B.ADDR,
 *                                    IfxVmt_getSystemAddress(mbistSel, trackedSramAddresses[i]));
 *                       }
 *        }
 * }
 *
 * IfxVmt_disableMbistShell(mbistSel);
 *
 * \endcode
 *
 * \section IfxLld_Vmt_MemoryTest Memory Tests
 * \subsection IfxLld_Vmt_MemoryTest_NDI Non Destructive Inversion Test
 *
 * Usage Example:
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE)
 * \code
 *     // Enable VMT clock
 *     {
 *         IfxVmt_enableModule();
 *     }
 *
 *
 *     {
 *         uint16 errAddr = 0;
 *
 *        // run Non distructive inversion test for cpu0 DSPR memory (Range selection disabled)
 *         IfxVmt_runNonDestructiveInversionTest(IfxVmt_MbistSel_cpu0Dspr, 0, 0xFF, 0, &errAddr);
 *       // Clear Error Flags which are set in case you want to run further tests
 *         IfxVmt_clearErrorTracking(IfxVmt_MbistSel_cpu0Dspr);
 *
 *     }
 * \endcode
 *
 * \subsection IfxLld_Vmt_MemoryTest_CheckerBoard Checker Board Test
 * Usage Example:
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE)
 * \code
 *     // Enable VMT clock
 *     {
 *         IfxVmt_enableModule();
 *     }
 *
 *
 *     {
 *         uint16 errAddr = 0;
 *        // run checkerboard test for cpu0 DSPR memory (Range selection disabled)
 *         IfxVmt_runCheckerBoardTest(IfxVmt_MbistSel_cpu0Dspr, 0, 0xFFFF, 0, &errAddr, 0);
 *     }
 * \endcode
 *
 * \subsection IfxLld_Vmt_MemoryTest_MarchU MarchU Test
 * Usage Example:
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE)
 * \code
 *     // Enable VMT clock
 *     {
 *         IfxVmt_enableModule();
 *     }
 *
 *     {
 *         uint16 errAddr = 0;
 *        // run March U test for cpu0 DSPR memory (Range selection disabled)
 *         IfxVmt_runMarchUTest(IfxVmt_MbistSel_cpu0Dspr, 0, 0xFFFF, 0, &errAddr);
 *     }
 * \endcode
 *
 * \defgroup IfxLld_Vmt_Std_Utility Utility Functions
 * \ingroup IfxLld_Vmt_Std
 * \defgroup IfxLld_Vmt_Std_Operative MBIST Operations
 * \ingroup IfxLld_Vmt_Std
 * \defgroup IfxLld_Vmt_Std_ErrorTracking MBIST Error Tracking
 * \ingroup IfxLld_Vmt_Std
 */

#ifndef IFXVMT_H
#define IFXVMT_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxVmt_cfg.h"
#include "IfxVmt_reg.h"
#include "IfxVmt_bf.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

#define IFXVMT_WAIT_TIMEOUTCOUNT                 (((sint32)0x1000))

#define IFXVMT_LOOP_TIMEOUT_CHECK(tVar, tErr) \
    {                                         \
        if (((sint32)--tVar) <= 0)            \
        {                                     \
            tErr = (uint8)1;                  \
            break;                            \
        }                                     \
        else                                  \
        {                                     \
        }                                     \
    }

/** \brief Configuration patterns for the MBIST
 * Array of configurations which are used by MCx_CONFIG0 register
 */
#define IFXVMT_MBIST_CONFIG_NONDISTTEST_MCONTROL {(0x4008U)}

#define IFXVMT_MBIST_CONFIG_NONDISTTEST_CONFIG0       \
    {                                                 \
        (                                             \
            (5U << IFX_VMT_MC_CONFIG0_ACCSTYPE_OFF) | \
            (4U << IFX_VMT_MC_CONFIG0_NUMACCS_OFF)    \
        )                                             \
    }

#define IFXVMT_MBIST_CONFIG_NONDISTTEST_CONFIG1       \
    {                                                 \
        (                                             \
            (8U << IFX_VMT_MC_CONFIG1_ACCSPAT_OFF) |  \
            (0U << IFX_VMT_MC_CONFIG1_SELFASTB_OFF) | \
            (5U << IFX_VMT_MC_CONFIG1_AG_MOD_OFF)     \
        )                                             \
    }

/** \brief Mask for the ERROR flags
 */
#define IFXVMT_ERROR_FLAGS_MASK                                               \
    (((unsigned int)IFX_VMT_MC_ECCD_CERR_MSK << IFX_VMT_MC_ECCD_CERR_OFF) |   \
     ((unsigned int)IFX_VMT_MC_ECCD_UCERR_MSK << IFX_VMT_MC_ECCD_UCERR_OFF) | \
     ((unsigned int)IFX_VMT_MC_ECCD_MERR_MSK << IFX_VMT_MC_ECCD_MERR_OFF))

/** \brief CPU0 PSPR base address
 */
#define IFXVMT_PSPR_BEGIN               0xC0000000

/** \brief CPU0 DSPR base address
 */
#define IFXVMT_DSPR_BEGIN               0xD0000000

/** \brief FAILID Structure V-flag value
 */
#define IFXVMT_VALID_FLAG               0x57B5327F

/** \brief Maximum number of acceptable single-bit errors (MSBE)
 */
#define IFXVMT_MSBE                     10

/** \brief Maximum number of bitline-oriented errors (MBLE)
 */
#define IFXVMT_MBLE                     4

/** \brief Maximum FAILID structures
 */
#define IFXVMT_DATA_FAILID_MAX          13

/** \brief one FAILID size
 * 2words (Header: SAL+VFLAG) + IFXVMT_DATA_FAILID_MAX *[2byte (VMT/MCi) +2byte(SBE+BLE)] + 1 word (CRC), consider the page-alignment, 64 bytes used
 */
#define IFXVMT_ONE_FAILID_SIZE          0x40

/** \brief UCB sector in flash
 */
#define IFXVMT_UCB_LOG_SECTOR           15

/** \brief Number of FAILID entries
 */
#define IFXVMT_DATA_FAILID_ENTRY_NUMBER 13

/** \brief q (UCERR count) offset value
 */
#define IFXVMT_Q_OFFSET                 0x70C0

/** \brief FALIID offset value
 */
#define IFXVMT_FAILID_OFFSET            0x70C2

/** \brief Maximum fail dumps
 */
#define IFXVMT_MAXFAILDMPS              10

/** \brief FAILID WORD size
 */
#define IFXVMT_FAILID_WORD_SIZE         (sizeof(IfxVmt_FailIdStructure) / 4)

/** \brief Number of Data CRC
 */
#define IFXVMT_NUM_WORD_DATA_CRC        (IFXVMT_FAILID_WORD_SIZE - 2)

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

typedef struct
{
    IfxVmt_SshSelectionConfig *sshConfig;       /**< \brief Number of SSH configuration structure */
    uint8                      numSBE;          /**< \brief Number of Single Bit Error (SBE) */
    uint8                      numBLE;          /**< \brief Number of Bit Line Error (BLE) */
} IfxVmt_FailIdData;

typedef struct
{
    uint32 sal;         /**< \brief Storage Address Location of FAILID */
    uint32 vflag;       /**< \brief Flag indicating FAILID validity */
} IfxVmt_FailIdHeader;

/** \addtogroup IfxLld_Vmt_Std_Operative
 * \{ */
typedef struct
{
    Ifx_VMT_MC_CONFIG0 config0;
    Ifx_VMT_MC_CONFIG1 config1;
} IfxVmt_MbistConfigPattern;

typedef struct
{
    IfxVmt_MbistSel sshSel;               /**< \brief Member (config0) */
    uint8           preClearEnable;       /**< \brief Enable SRAM clearing before the test */
} IfxVmt_MbistSshConfig;

/** \} */

typedef struct
{
    IfxVmt_FailIdHeader *header;                             /**< \brief FAILID header structure */
    IfxVmt_FailIdData    data[IFXVMT_DATA_FAILID_MAX];       /**< \brief FAILID data structure */
    uint32               crc;                                /**< \brief CRC for FAILID */
} IfxVmt_FailIdStructure;

/** \addtogroup IfxLld_Vmt_Std_Operative
 * \{ */
typedef struct
{
    Ifx_VMT_MC_MCONTROL                  mcontrol;                     /**< \brief Value of MCONTROL register except START bit */
    uint8                                numOfSshConfigurations;       /**< \brief Number of SSH Configurations in the memory test */
    uint8                                numOfConfigPatterns;          /**< \brief Number of configuration patterns */
    IFX_CONST IfxVmt_MbistSshConfig     *sshConfigurations;            /**< \brief Pointer to number of SSH configuration structures */
    IFX_CONST IfxVmt_MbistConfigPattern *configPatterns;               /**< \brief Pointer to number of configuration patterns */
} IfxVmt_MbistConfig;

/** \} */

typedef struct
{
    uint32                  backupAddr;              /**< \brief Current Working RAM base address */
    uint32                  lastentryAddr;           /**< \brief FAILID last entry address in the NVM */
    IfxVmt_FailIdStructure *backupData;              /**< \brief FAILID data present in the Working RAM */
    IfxVmt_FailIdStructure *lastentryData;           /**< \brief FAILID data present in last valid entry in NVM */
    uint8                   sbeCount;                /**< \brief SBE count */
    uint8                   bleCount;                /**< \brief BLE count */
    uint8                   lastFailIdEntryNr;       /**< \brief Last FAIID entry number in the NVM */
} IfxVmt_K1CheckFailIdInfo;

typedef struct
{
    uint32                    failIdAddr;                   /**< \brief Current Working RAM base address */
    uint32                    failIdStoreAddr;              /**< \brief Current Working RAM data base address */
    uint8                    *failIdLength;                 /**< \brief FAILID length */
    uint8                    *currentFailidIndex;           /**< \brief Current fail id index */
    IfxVmt_SshSelectionConfig excludeIncludeInstance;       /**< \brief Structure containing VMT and SSH instance */
    uint8                     excludeIncludeSwitch;         /**< \brief SSH include/exclude switch for K3 Phase test */
} IfxVmt_K3PhaseInputs;

typedef struct
{
    uint8 rdbflNum;         /**< \brief Number of RDBFL registers */
    uint8 towerWidth;       /**< \brief Tower width of SSH instance */
    uint8 numOfTower;       /**< \brief Number of towers in a ssh instance */
} IfxVmt_SramInfo;

/** \addtogroup IfxLld_Vmt_Std_Utility
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disables the MBIST Shell of the given SRAM
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 *
 * Usage Example
 * \code
 *
 *     IfxVmt_disableMbistShell(IfxVmt_MbistSel_cpu0Dtag);
 *
 *     // Note: Wait for Auto-initilisation to be completed for auto-init memories like cpu-Dtag, cpu-Ptag,  Cpu-Dcache, Cpu-Pcache
 *     while (IfxVmt_isAutoInitRunning(IfxVmt_MbistSel_cpu0Dtag))
 *     {}
 * \endcode
 *
 */
IFX_INLINE void IfxVmt_disableMbistShell(IfxVmt_MbistSel mbistSel);

/** \brief Enables the MBIST Shell of the given SRAM.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 *
 * Usage Example
 * \code
 *     // Enable VMT clock
 *     {
 *         IfxVmt_enableModule();
 *     }
 *
 *     {
 *       IfxVmt_enableMbistShell(IfxVmt_MbistSel_cpu0Dtag);
 *
 *       // Note: Wait for Auto-initilisation to be completed for auto-init memories like cpu-Dtag, cpu-Ptag,  Cpu-Dcache, Cpu-Pcache,
 *       while (IfxVmt_isAutoInitRunning(IfxVmt_MbistSel_cpu0Dtag))
 *       {}
 *     }
 * \endcode
 *
 */
IFX_INLINE void IfxVmt_enableMbistShell(IfxVmt_MbistSel mbistSel);

/** \brief Enables the VMT module
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param dmtuInstance this will point to the DMTU instance passed by th user(0 to 6)
 * \return None
 */
IFX_INLINE void IfxVmt_enableModule(Ifx_VMT *dmtuInstance);

/** \brief Returns TRUE if Auto-Initialisation is running for the given SRAM.
 *
 * Should be polled after MBIST enableMbistShell to ensure that an auto-init operation is finished before starting a new operation.
 * \param mbistSel Memory Selection
 * \return TRUE if auto-initialisation running.
 */
IFX_INLINE boolean IfxVmt_isAutoInitRunning(IfxVmt_MbistSel mbistSel);

/** \brief Returns the status of whether the module is enabled or not
 * \return
 */
IFX_INLINE boolean IfxVmt_isModuleEnabled(Ifx_VMT *dmtuInstance);

/** \brief Returns the CE alarms status registers
 * \param dmtu DMTU module pointer
 * \return CE Alarm register value
 */
IFX_INLINE uint32 IfxVmt_getDmtuCeAlarmStatus(Ifx_VMT *dmtu);

/** \brief Returns the UCE alarms status registers
 * \param dmtu DMTU module pointer
 * \return UCE Alarm register value
 */
IFX_INLINE uint32 IfxVmt_getDmtuUceAlarmStatus(Ifx_VMT *dmtu);

/** \brief Returns the ME alarms status registers
 * \param dmtu DMTU module pointer
 * \return ME Alarm register value
 */
IFX_INLINE uint32 IfxVmt_getDmtuMeAlarmStatus(Ifx_VMT *dmtu);

/** \} */

/** \addtogroup IfxLld_Vmt_Std_Operative
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function disables alarm-reporting flags
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 */
IFX_INLINE void IfxVmt_disableErrorReporting(IfxVmt_MbistSel mbistSel);

/** \brief This function enables alarm-reporting flags
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 */
IFX_INLINE void IfxVmt_enableErrorReporting(IfxVmt_MbistSel mbistSel);

/** \brief This Function returns the status of MBIST clear Sram operation.
 * Caution: It is recommended not to call this function continously in a loop. Use IfxVmt_clearSram() function for Synchronous polling mode.
 * \param mbistSel Memory Selection
 * \return status of Mbist Clear Sram operation (TRUE - Operation completed, FALSE - Operation still in progress)
 *
 * A coding example can be found in \ref IfxLld_Vmt_Usage
 *
 */
IFX_INLINE boolean IfxVmt_isMbistDone(IfxVmt_MbistSel mbistSel);

/** \brief Returns if MBIST enabled or not
 * \param mbistSel Memory Selection
 * \return MBIST enabled or not
 */
IFX_INLINE boolean IfxVmt_isMbistEnabled(IfxVmt_MbistSel mbistSel);

/** \brief Returns is the fail dump is available or not
 * \param mbistSel Memory Selection
 * \return Fail Dump available or not
 */
IFX_INLINE boolean IfxVmt_isMbistFda(IfxVmt_MbistSel mbistSel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to Clear the MBIST SRAM (Synchronous mode).
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 *
 * A coding example can be found in \ref IfxLld_Vmt_Usage
 *
 */
IFX_EXTERN void IfxVmt_clearSram(IfxVmt_MbistSel mbistSel);

/** \brief This Function should be called after MBIST Clear SRAM operation is completed.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 *
 * A coding example can be found in \ref IfxLld_Vmt_Usage
 *
 */
IFX_EXTERN void IfxVmt_clearSramContinue(IfxVmt_MbistSel mbistSel);

/** \brief This Function triggers the Clear the MBIST SRAM operation (Asynchronous operation). It doesn't wait till the end of operation.
 * The application has to poll the Mbist status (IfxVmt_isMbistDone()) in a task and once the operation is done, the IfxVmt_clearSramContinue() function should be called to complete the operation.
 * Alternately the application can enable the "memory test done" interrupt. And in the ISR, the IfxVmt_clearSramContinue()  has to be called.
 * If Synchronous usage is need, use IfxVmt_clearSram() function.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 *
 * A coding example can be found in \ref IfxLld_Vmt_Usage
 *
 */
IFX_EXTERN void IfxVmt_clearSramStart(IfxVmt_MbistSel mbistSel);

/**
 * \param mbistSel Memory Selection
 * \param sramAddress SRAM address which should be read
 * \return None
 *
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * A coding example can be found in \ref IfxLld_Vmt_Usage
 *
 */
IFX_EXTERN void IfxVmt_readSramAddress(IfxVmt_MbistSel mbistSel, uint16 sramAddress);

/** \brief Run CheckerBoard test.  This test consists of writing the physical checkerboard pattern into the memory, then reading it back for verification
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \param rangeSel enable/disable range Selection (0 - disable, 1- enable)
 * \param rangeAddrUp when range mode is enabled, it specifies the upper logical block address limit in 64 word increments.
 * \param rangeAddrLow when range mode is enabled, it specifies the lower logical block address limit.
 * \param errorAddr If the test fails, it contains the error address (bit0 - bit12) and memory block index (Bit13 - Bit15)
 * \param numberRedundancyLines Number of redundancy lines
 * \return Test Status (0-PASS, 1- FAIL)
 */
IFX_EXTERN uint8 IfxVmt_runCheckerBoardTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr, uint32 numberRedundancyLines);

/** \brief Run March U test.  This test MARCHES 0 and 1 values through the memory array in an up and down direction. More precisely, 0 and 1 values are propagated through the memory in each direction; i.e. a single bit cell toggles into each direction with the neighboring cells having a given value and, in another run, the inverse given value.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \param rangeSel enable/disable range Selection (0 - disable, 1- enable)
 * \param rangeAddrUp when range mode is enabled, it specifies the upper logical block address limit in 64 word increments.
 * \param rangeAddrLow when range mode is enabled, it specifies the lower logical block address limit.
 * \param errorAddr If the test fails, it contains the error address (bit0 - bit12) and memory block index (Bit13 - Bit15)
 * \return Test Status (0-PASS, 1- FAIL)
 */
IFX_EXTERN uint8 IfxVmt_runMarchUTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr);

/** \brief This function runs the Non-Destructive Inversion test algorithm.
 * Non-Destructive Inversion test can be considered as a simple linear test that is able to find all Stuck-At faults (the cell remains stuck at a value for any operation) without destroying any user data. The test accesses every Word in the address range defined by the RANGE register, four times.
 * Test Steps:
 * 1. Read data Word including check bits
 * 2. write back all bits inverted
 * 3. Read data Word including check bits
 * 4. Write back all bits inverted
 * At the end of this procedure the user data remains unchanged and and every bit has been set to 0 and 1. Any single Stuck-At error will be visible as a correctable error.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * The Error flags need to be cleared to enable further tracking after the test
 * \param mbistSel Memory Selection
 * \param rangeSel enable/disable range Selection (0 - disable, 1- enable)
 * \param rangeAddrUp when range mode is enabled, it specifies the upper logical block address limit in 64 word increments.
 * \param rangeAddrLow when range mode is enabled, it specifies the lower logical block address limit.
 * \param errorAddr If the test fails, it contains the error address (bit0 - bit12) and memory block index (Bit13 - Bit15)
 * \return Test Status (0-PASS, 1- FAIL)
 */
IFX_EXTERN uint8 IfxVmt_runNonDestructiveInversionTest(IfxVmt_MbistSel mbistSel, uint8 rangeSel, uint8 rangeAddrUp, uint8 rangeAddrLow, uint16 *errorAddr);

/**
 * \param mbistSel Memory Selection
 * \param sramAddress SRAM address which should be written
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \return None
 */
IFX_EXTERN void IfxVmt_writeSramAddress(IfxVmt_MbistSel mbistSel, uint16 sramAddress);

/** \brief Configures access to all masters to all the VMTs in the device
 * \param apConfig config pointer to configuration structure.
 * \return None
 */
IFX_EXTERN void IfxVmt_configureAccessToVmts(IfxApApu_ApuConfig *apConfig);

/** \} */

/** \addtogroup IfxLld_Vmt_Std_ErrorTracking
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the status of the error tracking
 * \param mbistSel Memory Selection
 * \return TRUE if error tracking enabled.
 */
IFX_INLINE boolean IfxVmt_isErrorTrackingEnabled(IfxVmt_MbistSel mbistSel);

/** \brief Returns True if any Error Flags are set
 * \param mbistSel Memory slection
 * \return True if any error Flag is set
 */
IFX_INLINE boolean IfxVmt_checkErrorFlags(IfxVmt_MbistSel mbistSel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Clears the error tracking registers (ETRR), valid and overflow bits.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \return None
 *
 * A coding example can be found in \ref IfxLld_Vmt_Usage
 *
 */
IFX_EXTERN void IfxVmt_clearErrorTracking(IfxVmt_MbistSel mbistSel);

/** \brief Enables the tracking of SRAM errors.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \param enable TRUE to enable error tracking, FALSE to disable error tracking.
 * \return None
 *
 * A coding example can be found in \ref IfxLld_Vmt_Usage
 *
 */
IFX_EXTERN void IfxVmt_enableErrorTracking(IfxVmt_MbistSel mbistSel, boolean enable);

/** \brief Returns the tracked SRAM error addresses and memory blocks which are stored in the MBIST ETRR registers.
 * Note: The function should be called with adequate PROT and APU handling (PROTE/PROTCSE).
 * \param mbistSel Memory Selection
 * \param trackedSramAddresses will contain the tracked error addresses in trackedSramAdresses[x].B.ADDR and affected blocks in sramAddresses[x].B.MBI
 *
 * The array size shall be IFXVMT_MAX_TRACKED_ADDRESSES
 * \return number of tracked errors (0..IFXVMT_MAX_TRACKED_ADDRESSES)
 *
 * Example usage to print out tracked errors of a given memory:
 *
 * We assume that the VMT clock has already been enabled, and that the MBIST instance has been selected; e.g. for LMU:
 * \code
 *     uint16 password = IfxScuWdt_getCpuWatchdogPassword();
 *     IfxScuWdt_clearCpuEndinit(password);
 *
 *     IfxVmt_enableModule();
 *
 *     IfxVmt_MbistSel mbistSel = IfxVmt_MbistSel_lmu;
 *
 *     IfxVmt_enableMbistShell(mbistSel);
 *
 *     // for auto-init memories: wait for the end of the clear operation
 *     while (IfxVmt_isAutoInitRunning(mbistSel))
 *         {}
 * \endcode
 *
 * Now the tracking information can be retrieved with:
 *
 * \code
 *     {
 *         Ifx_MC_ETRR trackedSramAddresses[IFXVMT_MAX_TRACKED_ADDRESSES];
 *         uint8  numTrackedAddresses = IfxVmt_getTrackedSramAddresses(mbistSel, trackedSramAddresses);
 *
 *         for(int i=0; i<numTrackedAddresses; ++i) {
 *             clib_ver_printf("%d: A:0x%04x MBI:%d -> SystemAddress: 0x%08x\n",
 *                             i,
 *                             trackedSramAddresses[i].B.ADDR,
 *                             trackedSramAddresses[i].B.MBI,
 *                             IfxVmt_getSystemAddress(mbistSel, trackedSramAddresses[i]));
 *         }
 *     }
 * \endcode
 *
 */
IFX_EXTERN uint8 IfxVmt_getTrackedSramAddresses(IfxVmt_MbistSel mbistSel, Ifx_VMT_MC_ETRR *trackedSramAddresses);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief this API is used to get the DMTU Instance(0 to 6) corressponding to the ssh number passed
 */
IFX_INLINE uint32 IfxVmt_getSshInstance(IfxVmt_MbistSel sshNum);

/**
 * \return this API returns the pointer to the DMTU Instance corressponding to the SSH instance passed
 * If the SSH is a secure one it returns pointer to the secure DMTU Instance
 */
IFX_INLINE Ifx_VMT_MC *IfxVmt_getDmtuMcInstancePtr(IfxVmt_MbistSel mbistSel);

/** \brief Returns the DMTU base Address
 * \param mbistSel Memory Selection
 * \return DMTU base Address
 */
IFX_INLINE Ifx_VMT *IfxVmt_getDmtuAddress(IfxVmt_MbistSel mbistSel);

/** \brief Disables dmtuInstance
 * \param dmtuInstance this will point to the DMTU instance passed by th user(0 to 6)
 * \return None
 */
IFX_INLINE void IfxVmt_disableModule(Ifx_VMT *dmtuInstance);

/** \brief This function will derive fail position from rdbfls
 * \param rdbfl pointer to RDBFL register
 * \param towerNum consists of number of towers in a SRAM
 * \param towerWidth consists of width of each tower in a SRAM
 * \param failPosition pointer to fail position
 * \param failMarker pointer to fail marker
 * \return None
 */
IFX_INLINE void IfxVmt_getFailPostion(uint16 *rdbfl, uint8 towerNum, uint8 towerWidth, uint32 *failPosition, uint16 *failMarker);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function will:
 * 1. Check the last valid entry in the flash
 * 2. If last valid entry is found, move the failid from NVM to RAM (PSPR if first time)
 * 3. Check SAL, VFLAG, number of SBE and BLE count
 * \param k1Check structure consisting of FAILID information, Working RAM address and last FAILID entry address in NVM
 * \return 0 if k1 check passes else return 1
 */
IFX_EXTERN sint8 IfxVmt_K1Check(IfxVmt_K1CheckFailIdInfo *k1Check);

/** \brief This function will:
 * 1. Enables the mbist controller for selected Gx (G1/G2) groups of SRAM's
 * 2. Configure the test pattern in CONFIG0/1 registers for all SSHs as part of G1/G2 of SRAM memories
 * 3. Start MEMTEST
 * 4. Wait for MEMTEST to be done (MEMDONE)
 * 5. Loop through all SSHs in G1/G2, check for UCE error.
 * 5.1 If UCE error, first time increment q and restart.
 * 5.2 If any UCERR and if ucerrCount != 0, user has to configure to safe state.
 * 5.3 If no UCE error go next step
 * 6. Loop through all SSHs in G1/G2, check for CE error. If CE error, log the VMT and SSH info in FAILID
 * 7. Store the total count of CERR into failIdLength
 * \param mbistConfig structure consisting of SRAM group list G1/G2
 * \param numOfSshConfig consists number of SSH in each group G1/G2
 * \param failIdAddr consists of FAILID address
 * \param failIdLength consists of FAILID length
 * \param ucerrCount consists of number of UCERR count
 * \return 1 if Kx Test fails, 0 if pass
 */
IFX_EXTERN sint8 IfxVmt_KxTest(const IfxVmt_SshSelectionConfig *mbistConfig, uint8 numOfSshConfig, uint32 failIdAddr, uint8 *failIdLength, uint8 *ucerrCount);

/** \brief This function will loop through all SSHs in G1/G2 and performs the SRAM Initialization
 * \param mbistConfig structure consists of SRAM group list G1/G2
 * \param numOfSshConfig consists number of ssh in each group G1/G2
 * \return None
 */
IFX_EXTERN void IfxVmt_KxInit(const IfxVmt_SshSelectionConfig *mbistConfig, uint8 numOfSshConfig);

/** \brief This function will
 * 1. Initially checks if failIdLength = 0 (i.e No CERR is recorded in the FAILID), if YES, return from K3 test, if No, follow next steps
 * 2. Enable mbist controller via MEMTEST
 * 3. K3 Extract: Configure the march test via registers CONFIG0 = 0x400AH and CONFIG1 = 0x0003H
 * 4. Enable FAILIDDMP bit to 1 and start test MCONTROL = 0x201H
 * 5. Check for MSTATUS.DONE == 0
 * 6. Set MCONTROL = 0x200H and initialize fail bit counter failBitCounter = 0
 * 7. While MSTATUS.DONE is not equal to 1
 *    7.1 Check if MSTATUS.FDA = 1, If yes, get error address from ETRR and increment failBitCounter
 *    7.2 Calculate fail postion and assign fail marker with SBEs on concerned locations
 *    7.3 If failBitCounter < Msbe resume the test by setting MCONTROL = 0x202H, else run the test with FAILDMP disabled by setting MCONTROL = 0x0002H
 * 8. If more or equal than 3 fails within one bitline oriented position, count those as BLE
 * 9. K3 Store: count the total number of SBE and BLE errors by checking the error address entries containing 1 or 2 in fail marker
 * 10. Disable the mbist controller via MEMTEST register
 * \param sramInfo double pointer containing SRAM information for each SRAM (no.of RDBFL registers, tower width, no.of towers)
 * \param k3PhaseInputs structure contains information for the K3 Phase
 */
IFX_EXTERN uint32 IfxVmt_K3PrepareExtractStore(const IfxVmt_SramInfo **sramInfo, IfxVmt_K3PhaseInputs *k3PhaseInputs);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxVmt_disableErrorReporting(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc                  = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    mc->ALMSRCS.B.MISCE = 0;
    mc->ALMSRCS.B.OPENE = 0;
}


IFX_INLINE void IfxVmt_disableMbistShell(IfxVmt_MbistSel mbistSel)
{
    uint32           tempSel;
    uint32           sshSel;
    uint32           index;
    volatile uint32 *dmtuMemtest;
    uint32           mask;
    Ifx_VMT_MC      *mc;

    tempSel = mbistSel;

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        tempSel = (uint32)(mbistSel & 0xFFFFFEFFU);
    }

    sshSel = IfxVmt_getSshInstance((IfxVmt_MbistSel)tempSel);
    index  = (uint32)(sizeof(Ifx_VMT)) * (tempSel >> 5);
    mask   = 1 << (sshSel & 0x1F);

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        dmtuMemtest = (volatile uint32 *)((uint32)&VMT0_MEMTESTCS + index);
    }
    else
    {
        dmtuMemtest = (volatile uint32 *)((uint32)&VMT0_MEMTEST + index);
    }

    *dmtuMemtest &= ~mask;

    while (IfxVmt_isAutoInitRunning(mbistSel))
    {
        __nop();
    }

    /*Enable Error Reporting  */

    mc                  = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    mc->ALMSRCS.B.MISCE = 1;
    mc->ALMSRCS.B.OPENE = 1;
}


IFX_INLINE void IfxVmt_enableErrorReporting(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc                  = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    mc->ALMSRCS.B.MISCE = 1;
    mc->ALMSRCS.B.OPENE = 1;
}


IFX_INLINE void IfxVmt_enableMbistShell(IfxVmt_MbistSel mbistSel)
{
    uint32           tempSel;
    uint32           sshSel;
    uint32           index;
    volatile uint32 *dmtuMemtest;
    uint32           mask;
    Ifx_VMT_MC      *mc;

    tempSel = mbistSel;

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        tempSel = (uint32)(mbistSel & 0xFFFFFEFFU);
    }

    sshSel              = IfxVmt_getSshInstance((IfxVmt_MbistSel)tempSel);
    index               = (uint32)(sizeof(Ifx_VMT)) * (tempSel >> 5);

    mc                  = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    mc->ALMSRCS.B.MISCE = 0;
    mc->ALMSRCS.B.OPENE = 0;
    mask                = 1 << (sshSel & 0x1F);

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        dmtuMemtest = (volatile uint32 *)((uint32)&VMT0_MEMTESTCS + index);
    }
    else
    {
        dmtuMemtest = (volatile uint32 *)((uint32)&VMT0_MEMTEST + index);
    }

    *dmtuMemtest |= mask;
}


IFX_INLINE void IfxVmt_enableModule(Ifx_VMT *dmtuInstance)
{
    /*VMT clock enable */
    dmtuInstance->CLC.U = 0x0U;
}


IFX_INLINE boolean IfxVmt_isAutoInitRunning(IfxVmt_MbistSel mbistSel)
{
    uint32           tempSel;
    uint32           sshSel;
    uint32           index;
    volatile uint32 *vmtMemstat;
    uint32           mask;

    tempSel = mbistSel;

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        tempSel = (uint32)(mbistSel & 0xFFFFFEFFU);
    }

    sshSel = IfxVmt_getSshInstance((IfxVmt_MbistSel)tempSel);
    index  = (uint32)(sizeof(Ifx_VMT)) * (tempSel >> 5);
    mask   = 1 << (sshSel & 0x1f);

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        vmtMemstat = (volatile uint32 *)((uint32)&VMT0_MEMSTATCS + index);
    }
    else
    {
        vmtMemstat = (volatile uint32 *)((uint32)&VMT0_MEMSTAT + index);
    }

    return (*vmtMemstat & mask) != 0;
}


IFX_INLINE boolean IfxVmt_isErrorTrackingEnabled(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);

    return mc->ECCS.B.TRE ? TRUE : FALSE;
}


IFX_INLINE boolean IfxVmt_isMbistDone(IfxVmt_MbistSel mbistSel)
{
    uint32           tempSel;
    uint32           sshSel;
    uint32           index;
    volatile uint32 *memdone;
    uint32           mask;

    tempSel = mbistSel;

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        tempSel = (uint32)(mbistSel & 0xFFFFFEFFU);
    }

    sshSel = IfxVmt_getSshInstance((IfxVmt_MbistSel)tempSel);
    index  = (uint32)(sizeof(Ifx_VMT)) * (tempSel >> 5);
    mask   = 1 << (sshSel & 0x1f);

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        memdone = (volatile uint32 *)((uint32)&VMT0_MEMDONECS + index);
    }
    else
    {
        memdone = (volatile uint32 *)((uint32)&VMT0_MEMDONE + index);
    }

    return (*memdone & mask) != 0;
}


IFX_INLINE boolean IfxVmt_isModuleEnabled(Ifx_VMT *dmtuInstance)
{
    return dmtuInstance->CLC.B.DISS == 0;
}


IFX_INLINE boolean IfxVmt_checkErrorFlags(IfxVmt_MbistSel mbistSel)
{
    Ifx_VMT_MC *mc;
    mc = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    return (boolean)((mc->ECCD.U & IFXVMT_ERROR_FLAGS_MASK) > 0);
}


IFX_INLINE uint32 IfxVmt_getSshInstance(IfxVmt_MbistSel sshNum)
{
    /* Clear the 8th bit which indicates if CS-SSH */
    uint32 tempSsh;
    tempSsh = (uint32)sshNum;

    /* Clear the 8th bit which indicates if CS-SSH */
    if ((tempSsh >> 8U) != 0U)
    {
        tempSsh = (uint32)(tempSsh & 0xFFFFFEFFU);
    }

    tempSsh = (uint32)(tempSsh % 32U);

    return tempSsh;
}


IFX_INLINE Ifx_VMT_MC *IfxVmt_getDmtuMcInstancePtr(IfxVmt_MbistSel mbistSel)
{
    uint32            tempSel;
    uint32            sshSel;
    uint32            index;
    volatile Ifx_VMT *dmtuInstance;
    Ifx_VMT_MC       *mc;

    tempSel = mbistSel;

    if ((mbistSel >> 8U) != 0U)
    {
        tempSel = (uint32)(mbistSel & 0xFFFFFEFFU);
    }

    sshSel       = IfxVmt_getSshInstance((IfxVmt_MbistSel)tempSel);
    index        = (uint32)(sizeof(Ifx_VMT)) * (tempSel >> 5);
    dmtuInstance = (volatile Ifx_VMT *)((uint32)&MODULE_VMT0 + index);

    if ((mbistSel >> 8U) != 0U)
    {
        mc = (Ifx_VMT_MC *)&dmtuInstance->MCCS[sshSel];
    }
    else
    {
        mc = &dmtuInstance->MC[sshSel];
    }

    return mc;
}


IFX_INLINE uint32 IfxVmt_getDmtuCeAlarmStatus(Ifx_VMT *dmtu)
{
    return dmtu->CEALARM.U;
}


IFX_INLINE uint32 IfxVmt_getDmtuUceAlarmStatus(Ifx_VMT *dmtu)
{
    return dmtu->UCEALARM.U;
}


IFX_INLINE uint32 IfxVmt_getDmtuMeAlarmStatus(Ifx_VMT *dmtu)
{
    return dmtu->MEALARM.U;
}


IFX_INLINE boolean IfxVmt_isMbistEnabled(IfxVmt_MbistSel mbistSel)
{
    uint32           tempSel;
    uint32           sshSel;
    uint32           index;
    volatile uint32 *vmtMemtest;
    uint32           mask;

    tempSel = mbistSel;

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        tempSel = (uint32)(mbistSel & 0xFFFFFEFFU);
    }

    sshSel = IfxVmt_getSshInstance((IfxVmt_MbistSel)tempSel);
    index  = (uint32)(sizeof(Ifx_VMT)) * (tempSel >> 5);
    mask   = 1 << (sshSel & 0x1f);

    if (((mbistSel & 0x100U) >> 8U) != 0U)
    {
        vmtMemtest = (volatile uint32 *)((uint32)&VMT0_MEMTESTCS + index);
    }
    else
    {
        vmtMemtest = (volatile uint32 *)((uint32)&VMT0_MEMTEST + index);
    }

    return (*vmtMemtest & mask) != 0U;
}


IFX_INLINE boolean IfxVmt_isMbistFda(IfxVmt_MbistSel mbistSel)
{
    /* Read MSTATUS to clear FDA when it has been set */
    Ifx_VMT_MC *mc     = IfxVmt_getDmtuMcInstancePtr(mbistSel);
    uint32      status = mc->MSTATUS.U;
    return (status & (1 << IFX_VMT_MC_MSTATUS_FDA_OFF)) > 0;
}


IFX_INLINE Ifx_VMT *IfxVmt_getDmtuAddress(IfxVmt_MbistSel mbistSel)
{
    uint32   index       = (uint32)(sizeof(Ifx_VMT)) * ((mbistSel & 0x0ff) >> 5);
    Ifx_VMT *dmtuAddress = (volatile Ifx_VMT *)((uint32)&MODULE_VMT0 + index);

    return dmtuAddress;
}


IFX_INLINE void IfxVmt_disableModule(Ifx_VMT *dmtuInstance)
{
    /*VMT clock disable */
    dmtuInstance->CLC.U = 0x1U;
}


IFX_INLINE void IfxVmt_getFailPostion(uint16 *rdbfl, uint8 towerNum, uint8 towerWidth, uint32 *failPosition, uint16 *failMarker)
{
    /* derive fail position from rdbfls */
    /* initialize fail marker with SBE on fail encounter */

    uint8  tower, i, towerStart, towerEnd, towerBitPos, bitPos, start, end, failCount;
    uint16 mask;

    for (tower = 0; tower < towerNum; tower++)
    {
        failCount   = 0;
        towerStart  = tower * towerWidth / 16;
        towerEnd    = ((tower + 1) * towerWidth - 1) / 16;
        towerBitPos = 0;

        for (i = towerStart; i <= towerEnd; i++)
        {
            end   = 15;
            start = 0;

            if (i == towerStart)
            {
                start = (tower * towerWidth) % 16;
            }

            if (i == towerEnd)
            {
                end = ((tower + 1) * towerWidth - 1) % 16;
            }

            mask = ((1 << (end + 1)) - 1) ^ ((1 << start) - 1);

            if (rdbfl[i] & mask)
            {
                for (bitPos = start; bitPos <= end; bitPos++)
                {
                    if (((rdbfl[i] & mask) >> bitPos) & 1)
                    {
                        *failPosition |= (bitPos + towerBitPos + 1 - start) << 8 * tower; /* fail bit positions start at index 1 not index 0 */
                        *failMarker   |= 1 << 2 * tower;                                  /* set every fail to SBE in this step, reassessment follows after */
                        failCount++;                                                      /* only first fail is counted, since only one fail can be saved to fail_position for one tower */
                    }

                    if (failCount)                                                        /* only first fail is counted, since only one fail can be saved to fail_position for one tower */
                    {
                        break;
                    }
                }
            }

            towerBitPos += end - start + 1;

            if (failCount)  /* only first fail is counted, since only one fail can be saved to fail_position for one tower */
            {
                break;
            }
        }
    }
}


#endif /* IFXVMT_H */
