/**
 * \file IfxXspi.h
 * \brief XSPI  basic functionality
 * \ingroup IfxLld_Xspi
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Xspi_Std_Enumerations Enumerations
 * \ingroup IfxLld_Xspi_Std
 * \defgroup IfxLld_Xspi_Std_External External Functions
 * \ingroup IfxLld_Xspi_Std
 */

#ifndef IFXXSPI_H
#define IFXXSPI_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxXspi_cfg.h"
#include "_PinMap/IfxXspi_PinMap.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "Clock/Std/IfxClock.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"
#include "Src/Std/IfxSrc.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Xspi_Std_Enumerations
 * \{ */
/** \brief Only after this much bits are programmed in to the FIFO the transfer can begin
 *  Definition SPI_CTRLR0_ADDR_L
 */
typedef enum
{
    IfxXspi_AddressLength_L0  = 0,   /**< \brief (ADDR_L0): No Address */
    IfxXspi_AddressLength_L4  = 1,   /**< \brief (ADDR_L4): 4 bit Address length */
    IfxXspi_AddressLength_L8  = 2,   /**< \brief (ADDR_L8): 8 bit Address length */
    IfxXspi_AddressLength_L12 = 3,   /**< \brief (ADDR_L12): 12 bit Address length */
    IfxXspi_AddressLength_L16 = 4,   /**< \brief (ADDR_L16): 16 bit Address length */
    IfxXspi_AddressLength_L20 = 5,   /**< \brief (ADDR_L20): 20 bit Address length */
    IfxXspi_AddressLength_L24 = 6,   /**< \brief (ADDR_L24): 24 bit Address length */
    IfxXspi_AddressLength_L28 = 7,   /**< \brief (ADDR_L28): 28 bit Address length */
    IfxXspi_AddressLength_L32 = 8,   /**< \brief (ADDR_L32): 32 bit Address length */
    IfxXspi_AddressLength_L36 = 9,   /**< \brief (ADDR_L36): 36 bit Address length */
    IfxXspi_AddressLength_L40 = 10,  /**< \brief (ADDR_L40): 40 bit Address length */
    IfxXspi_AddressLength_L44 = 11,  /**< \brief (ADDR_L44): 44 bit Address length */
    IfxXspi_AddressLength_L48 = 12,  /**< \brief (ADDR_L48): 48 bit Address length */
    IfxXspi_AddressLength_L52 = 13,  /**< \brief (ADDR_L52): 52 bit Address length */
    IfxXspi_AddressLength_L56 = 14,  /**< \brief (ADDR_L56): 56 bit Address length */
    IfxXspi_AddressLength_L60 = 15   /**< \brief (ADDR_L60): 60 bit Address length */
} IfxXspi_AddressLength;

/** \brief XSPI Bus Status
 */
typedef enum
{
    IfxXspi_BusStatus_idle  = 0, /**< \brief XSPI Bus is Idle */
    IfxXspi_BusStatus_busy  = 1, /**< \brief XSPI Bus is Busy in Operation */
    IfxXspi_BusStatus_error = 2  /**< \brief XSPI Bus Error */
} IfxXspi_BusStatus;

/** \brief xSPI Clock-Phase,Valid when the frame format (FRF) is set to Motorola SPI.
 *  * Definition in IfxXspi_CTRLR0_SCPH
 */
typedef enum
{
    IfxXspi_ClockPhase_StartBit  = 1, /**< \brief Clock Polarity (SCPH = 1)) */
    IfxXspi_ClockPhase_MiddleBit = 0  /**< \brief Clock Polarity (SCPH = 0)) */
} IfxXspi_ClockPhase;

/** \brief xSPI Clock-Polarity,Valid when the frame format (FRF) is set to Motorola SPI.
 * Definition in IfxXspi_CTRLR0_SCPOL
 */
typedef enum
{
    IfxXspi_ClockPolarity_InactiveLow  = 0, /**< \brief Clock Polarity (SCPOL = 0) */
    IfxXspi_ClockPolarity_InactiveHigh = 1  /**< \brief Clock Polarity (SCPOL = 1) */
} IfxXspi_ClockPolarity;

/** \brief Data Collision Error
 *  * Definition SR_DCOL
 */
typedef enum
{
    IfxXspi_DataCollision_Error   = 1, /**< \brief 1: (TX_COLLISION_ERROR): Transmit Data Collision Error */
    IfxXspi_DataCollision_NoError = 0  /**< \brief 0: (NO_ERROR_CONDITION): No Error */
} IfxXspi_DataCollision;

/** \brief Data Frame Size, Selects the data frame length
 *  * Definition CTRLR0_DFS
 */
typedef enum
{
    IfxXspi_DataframeSize_4  = 3,   /**< \brief number of bits per transfer 4 */
    IfxXspi_DataframeSize_5  = 4,   /**< \brief number of bits per transfer 5 */
    IfxXspi_DataframeSize_6  = 5,   /**< \brief number of bits per transfer 6 */
    IfxXspi_DataframeSize_7  = 6,   /**< \brief number of bits per transfer 7 */
    IfxXspi_DataframeSize_8  = 7,   /**< \brief number of bits per transfer 8 */
    IfxXspi_DataframeSize_9  = 8,   /**< \brief number of bits per transfer 9 */
    IfxXspi_DataframeSize_10 = 9,   /**< \brief number of bits per transfer 10 */
    IfxXspi_DataframeSize_11 = 10,  /**< \brief number of bits per transfer 11 */
    IfxXspi_DataframeSize_12 = 11,  /**< \brief number of bits per transfer 12 */
    IfxXspi_DataframeSize_13 = 12,  /**< \brief number of bits per transfer 13 */
    IfxXspi_DataframeSize_14 = 13,  /**< \brief number of bits per transfer 14 */
    IfxXspi_DataframeSize_15 = 14,  /**< \brief number of bits per transfer 15 */
    IfxXspi_DataframeSize_16 = 15,  /**< \brief number of bits per transfer 16 */
    IfxXspi_DataframeSize_17 = 16,  /**< \brief number of bits per transfer 17 */
    IfxXspi_DataframeSize_18 = 17,  /**< \brief number of bits per transfer 18 */
    IfxXspi_DataframeSize_19 = 18,  /**< \brief number of bits per transfer 19 */
    IfxXspi_DataframeSize_20 = 19,  /**< \brief number of bits per transfer 20 */
    IfxXspi_DataframeSize_21 = 20,  /**< \brief number of bits per transfer 21 */
    IfxXspi_DataframeSize_22 = 21,  /**< \brief number of bits per transfer 22 */
    IfxXspi_DataframeSize_23 = 22,  /**< \brief number of bits per transfer 23 */
    IfxXspi_DataframeSize_24 = 23,  /**< \brief number of bits per transfer 24 */
    IfxXspi_DataframeSize_25 = 24,  /**< \brief number of bits per transfer 25 */
    IfxXspi_DataframeSize_26 = 25,  /**< \brief number of bits per transfer 26 */
    IfxXspi_DataframeSize_27 = 26,  /**< \brief number of bits per transfer 27 */
    IfxXspi_DataframeSize_28 = 27,  /**< \brief number of bits per transfer 28 */
    IfxXspi_DataframeSize_29 = 28,  /**< \brief number of bits per transfer 29 */
    IfxXspi_DataframeSize_30 = 29,  /**< \brief number of bits per transfer 30 */
    IfxXspi_DataframeSize_31 = 30,  /**< \brief number of bits per transfer 31 */
    IfxXspi_DataframeSize_32 = 31   /**< \brief number of bits per transfer 32 */
} IfxXspi_DataframeSize;

/** \brief SSI Enable Register
 * Definition SSIENR_SSIC_EN
 */
typedef enum
{
    IfxXspi_Dwc_Mode_Enable  = 1, /**< \brief 1: (ENABLED): Enables DWC_ssi */
    IfxXspi_Dwc_Mode_Disable = 0  /**< \brief 0: (DISABLE): Disables DWC_ssi */
} IfxXspi_Dwc_Mode;

/** \brief SSI Status Register
 */
typedef enum
{
    IfxXspi_Dwc_Status_Active   = 1, /**< \brief (ACTIVE): DWC_ssi is actively transferring data */
    IfxXspi_Dwc_Status_InActive = 0  /**< \brief (INACTIVE): DWC_ssi is idle or disabled */
} IfxXspi_Dwc_Status;

/** \brief xSPI Hyperbus Frame Format
 *   NOTE: This field is effective only when CTRLRO.FRF is set to SPI frame format
 *   Definition IfxXspi_CTRLR0_SPI_HYPERBUS_EN
 */
typedef enum
{
    IfxXspi_Hyperbus_Disable = 0,  /**< \brief 0: (DISABLE): Disable Hyperbus Format */
    IfxXspi_Hyperbus_Enable  = 1   /**< \brief 1: (ENABLE): Enable Hyperbus Format */
} IfxXspi_Hyperbus;

/** \brief INST_L - Dual/Quad/Octal mode instruction length in bits,
 *  Definition SPI_CTRLR0_INSTA_L
 */
typedef enum
{
    IfxXspi_InstructionLength_L0  = 0, /**< \brief (INST_L0): No Instruction */
    IfxXspi_InstructionLength_L4  = 1, /**< \brief (INST_L4): 4 bit Instruction length */
    IfxXspi_InstructionLength_L8  = 2, /**< \brief (INST_L8): 8 bit Instruction length */
    IfxXspi_InstructionLength_L16 = 3  /**< \brief (INST_L16): 16 bit Instruction length */
} IfxXspi_InstructionLength;

/** \brief Interrupt Mask Register
 */
typedef enum
{
    IfxXspi_InterruptMask_Mask   = 1, /**< \brief Interrupt Mask Enable */
    IfxXspi_InterruptMask_UnMask = 0  /**< \brief Interrupt Maks Disable */
} IfxXspi_InterruptMask;

/** \brief ISR - Interrupt Status Register
 */
typedef enum
{
    IfxXspi_InterruptStatus_Active,   /**< \brief 1: Interrupt Status Active */
    IfxXspi_InterruptStatus_InActive  /**< \brief 0: Interrupt Status Not Active */
} IfxXspi_InterruptStatus;

/** \brief This bit enables/disables the Receive FIFO DMA channel.
 * Definition DMA_RDMAE
 */
typedef enum
{
    IfxXspi_RxFifoDma_Enable  = 1, /**< \brief 1: (ENABLED): Receive DMA enabled */
    IfxXspi_RxFifoDma_Disable = 0  /**< \brief 0: (DISABLE): Receive DMA disabled */
} IfxXspi_RxFifoDma;

/** \brief Receive FIFO Not Empty
 *  * Definition SR_RFNE
 */
typedef enum
{
    IfxXspi_RxFifoEmpty_NotEmpty = 1,  /**< \brief 1: (NOT_EMPTY): Receive FIFO is not empty */
    IfxXspi_RxFifoEmpty_Empty    = 0   /**< \brief 0: (EMPTY): Receive FIFO is empty */
} IfxXspi_RxFifoEmpty;

/** \brief Receive FIFO Full
 *  * Definition SR_RFF
 */
typedef enum
{
    IfxXspi_RxFifoFull_Full    = 1, /**< \brief 1: (FULL): Receive FIFO is full */
    IfxXspi_RxFifoFull_NotFull = 0  /**< \brief 0: (NOT_FULL): Receive FIFO is not full */
} IfxXspi_RxFifoFull;

/** \brief Alternate input selection for Rx signal
 */
typedef enum
{
    IfxXspi_RxInputSelect_0 = 0,  /**< \brief alternate input selection 0 */
    IfxXspi_RxInputSelect_1 = 1,  /**< \brief alternate input selection 1 */
    IfxXspi_RxInputSelect_2 = 2,  /**< \brief alternate input selection 2 */
    IfxXspi_RxInputSelect_3 = 3,  /**< \brief alternate input selection 3 */
    IfxXspi_RxInputSelect_4 = 4,  /**< \brief alternate input selection 4 */
    IfxXspi_RxInputSelect_5 = 5,  /**< \brief alternate input selection 5 */
    IfxXspi_RxInputSelect_6 = 6,  /**< \brief alternate input selection 6 */
    IfxXspi_RxInputSelect_7 = 7   /**< \brief alternate input selection 7 */
} IfxXspi_RxInputSelect;

/** \brief xSPI Shift Register Loop.(LOOPBACK)
 *  Definition IfxXspi_CTRLR0_SRL
 */
typedef enum
{
    IfxXspi_ShiftRegisterLoop_NormalMode = 0,  /**< \brief 0: (NORMAL_MODE): Normal mode operation */
    IfxXspi_ShiftRegisterLoop_TestMode   = 1   /**< \brief 1: (TESTING_MODE): Test Mode Operation */
} IfxXspi_ShiftRegisterLoop;

/** \brief CTRLR0.SLV_OE - Slave output enable
 * Definition IfxXspi_SlaveOutputControl
 */
typedef enum
{
    IfxXspi_SlaveOutputControl_Disable = 0,  /**< \brief 0: (DISABLE): Slave output is Disabled */
    IfxXspi_SlaveOutputControl_Enable  = 1   /**< \brief 1: (ENABLE):  Slave output is Enabled */
} IfxXspi_SlaveOutputControl;

/** \brief xSPI Slave Select Toggle
 * Definition IfxXspi_CTRLR0_SPI_SSTE
 */
typedef enum
{
    IfxXspi_SlaveSelectToggle_Disable = 0,  /**< \brief 0: (TOGGLE_DISABLE) */
    IfxXspi_SlaveSelectToggle_Enable  = 1   /**< \brief 1: (TOGGLE_EN) */
} IfxXspi_SlaveSelectToggle;

/** \brief SPI Frame Format
 * Definition in IfxXspi_CTRLR0_SPI_FRF
 */
typedef enum
{
    IfxXspi_SpiFrameFormat_Std   = 0, /**< \brief XSPI in STANDERD SPI Frame Format */
    IfxXspi_SpiFrameFormat_Dual  = 1, /**< \brief XSPI in DUAL Frame Format [Enhanced Mode] */
    IfxXspi_SpiFrameFormat_Quad  = 2, /**< \brief XSPI in QUAD Frame Format [Enhanced Mode] */
    IfxXspi_SpiFrameFormat_Octal = 3  /**< \brief XSPI in OCTAL Frame Format [Enhanced Mode] */
} IfxXspi_SpiFrameFormat;

/** \brief Configuration Error status
 */
typedef enum
{
    IfxXspi_Status_noError            = 0,  /**< \brief No error */
    IfxXspi_Status_success            = 0,  /**< \brief xSPI return status is success */
    IfxXspi_Status_configurationError = 1,  /**< \brief Configuration error */
    IfxXspi_Status_failure            = 2   /**< \brief xSPI return status is failure */
} IfxXspi_Status;

/** \brief TRANS_TYPE - Address and instruction transfer format
 *  * Definition SPI_CTRLR0_TRANS_TYPE
 */
typedef enum
{
    IfxXspi_TransferFormat_TT0 = 0,  /**< \brief (TT0): Instruction and Address will be sent in Standard SPI Mode */
    IfxXspi_TransferFormat_TT1 = 1,  /**< \brief (TT1): Instruction will be sent in Standard SPI Mode and Address will be sent in the mode specified by CTRLR0.SPI_FRF */
    IfxXspi_TransferFormat_TT2 = 2   /**< \brief (TT2): Both Instruction and Address will be sent in the mode specified by SPI_FRF */
} IfxXspi_TransferFormat;

/** \brief xSPI Transfer mode (TMOD)
 *  * NOTE: The transfer mode setting does not affect the duplex of the serial transfer. TMOD is ignored for Microwire transfers, which are controlled by the MWCR register
 *  * Definition IfxXspi_CTRLR0_TMOD
 */
typedef enum
{
    IfxXspi_TransferMode_TxRx       = 0, /**< \brief TMOD = 2窶話00 Both Transmit and Receive Logic are Valid */
    IfxXspi_TransferMode_Tx         = 1, /**< \brief TMOD = 2窶話01 Transmit is Valid for Transfer occrs as normal */
    IfxXspi_TransferMode_Rx         = 2, /**< \brief TMOD = 2窶話10 Receive is Valid for receiving as normal */
    IfxXspi_TransferMode_EepromRead = 3  /**< \brief TMOD = 2窶話11 Only Transfer Mode is Valid for Master, Not Applicable in enhanced SPI operating mode */
} IfxXspi_TransferMode;

/** \brief ATW - AXI transfer width for DMA transfers
 */
typedef enum
{
    IfxXspi_TransferWidth_1 = 0,  /**< \brief Transfer Width of DMA Transfer */
    IfxXspi_TransferWidth_2 = 1,  /**< \brief Transfer Width of DMA Transfer */
    IfxXspi_TransferWidth_4 = 2,  /**< \brief Transfer Width of DMA Transfer */
    IfxXspi_TransferWidth_8 = 3   /**< \brief Transfer Width of DMA Transfer */
} IfxXspi_TransferWidth;

/** \brief TDMAE - Transmit DMA Enable, valid when configured with a set of DMA Controller interface signals (SSIC_HAS_DMA = 1)
 *  * This bit enables/disables the transmit FIFO DMA channel.
 *  * Definition DMA_TDMAE
 */
typedef enum
{
    IfxXspi_TxFifoDma_Enable  = 1, /**< \brief 1: (ENABLED): Transmit DMA enabled */
    IfxXspi_TxFifoDma_Disable = 0  /**< \brief 0: (DISABLE): Transmit DMA disabled */
} IfxXspi_TxFifoDma;

/** \brief Transmit FIFO Empty
 *  * Definition SR_TFE
 */
typedef enum
{
    IfxXspi_TxFifoEmpty_Empty    = 1, /**< \brief 1: (EMPTY): Transmit FIFO is empty */
    IfxXspi_TxFifoEmpty_NotEmpty = 0  /**< \brief 0: (NOT_EMPTY): Transmit FIFO is not empty */
} IfxXspi_TxFifoEmpty;

/** \brief Transmit FIFO Full
 *  * Definition SR_TFF
 */
typedef enum
{
    IfxXspi_TxFifoFull_NotFull = 1,  /**< \brief 1: (NOT_FULL): Tx FIFO is not Full */
    IfxXspi_TxFifoFull_Full    = 0   /**< \brief 0: (FULL): Tx FIFO is full */
} IfxXspi_TxFifoFull;

/** \brief XIP_MBL - XIP Mode bits length
 *   Sets the length of mode bits in XIP mode of operation
 *  Definition SPI_CTRLR0_XIP_MBL
 */
typedef enum
{
    IfxXspi_XipBitLength_MBL2  = 0, /**< \brief (MBL_2): Mode bits length equal to 2 */
    IfxXspi_XipBitLength_MBL4  = 1, /**< \brief (MBL_4): Mode bits length equal to 4 */
    IfxXspi_XipBitLength_MBL8  = 2, /**< \brief (MBL_8): Mode bits length equal to 8 */
    IfxXspi_XipBitLength_MBL16 = 3  /**< \brief (MBL_16): Mode bits length equal to 16 */
} IfxXspi_XipBitLength;

/** \brief XIP_CTRL.CONT_XFER_EN - continuous transfer mode in XIP
 * Definition IfxXspi_XipContTransfer
 */
typedef enum
{
    IfxXspi_XipContTransfer_Disable = 0,  /**< \brief 0: (DISABLE): Continuous transfer mode in XIP will be disabled */
    IfxXspi_XipContTransfer_Enable  = 1   /**< \brief 1: (ENABLE): Continuous transfer mode in XIP will be enabled */
} IfxXspi_XipContTransfer;

/** \brief XIP_CTRL.DFS_HC - Data frame size for XIP transfer
 * Definition IfxXspi_XipDataFrameSizeControl
 */
typedef enum
{
    IfxXspi_XipDataFrameSizeControl_Disable = 0,  /**< \brief 0: (DISABLE): Data frames size will be determined by HSIZE and HBURST signals */
    IfxXspi_XipDataFrameSizeControl_Enable  = 1   /**< \brief 1: (ENABLE):  Data frame size will be fixed to the programmed value in CTRLR0.DFS */
} IfxXspi_XipDataFrameSizeControl;

/** \brief XIP_CTRL.INST_EN - XIP instruction phase inclusion in XIP transfer
 * Definition IfxXspi_XipInstructionPhaseEnable
 */
typedef enum
{
    IfxXspi_XipInstructionPhaseEnable_Disable = 0,  /**< \brief 0: (DISABLE): XIP transfers will not have instruction phase */
    IfxXspi_XipInstructionPhaseEnable_Enable  = 1   /**< \brief 1: (ENABLE):  XIP transfers will have instruction phase */
} IfxXspi_XipInstructionPhaseEnable;

/** \brief xSPI XIP cached/Non Cached Memory Types
 */
typedef enum
{
    IfxXspi_XipMemType_cached    = 0, /**< \brief XIP Cached memory */
    IfxXspi_XipMemType_nonCached = 1  /**< \brief XIP Non Cached memory */
} IfxXspi_XipMemType;

/** \brief SER.SER - XIP transfer Slave select enable
 * Definition IfxXspi_XipSlaveSelectEnable
 */
typedef enum
{
    IfxXspi_XipSlaveSelectEnable_none = 0,  /**< \brief None: XIP transfer no Slave selected */
    IfxXspi_XipSlaveSelectEnable_1    = 1,  /**< \brief 1: (Slave1): XIP transfer Slave select enable 1 */
    IfxXspi_XipSlaveSelectEnable_2    = 2   /**< \brief 2: (Slave2): XIP transfer Slave select enable 2 */
} IfxXspi_XipSlaveSelectEnable;

/** \} */

/** \brief Clock Loopback
 * Definition in CTRL0.B.CLK_LOOP_EN
 */
typedef enum
{
    IfxXspi_ClockLoopBack_Disable = 0,  /**< \brief 0: (DISABLE): Disable Clock Loop back */
    IfxXspi_ClockLoopBack_Enable  = 1   /**< \brief 1: (ENABLE): Enable Clock Loop back */
} IfxXspi_ClockLoopBack;

/** \brief XSPI PORT selection
 */
typedef enum
{
    IfxXspi_SelectPort_16 = 0,  /**< \brief 0: XSPI PORT 16 (High speed) selection */
    IfxXspi_SelectPort_20 = 1   /**< \brief 1: XSPI PORT 20 (GPIO) selection */
} IfxXspi_SelectPort;

/** \brief SER.SER - Xspi transfer Slave select enable
 * Definition IfxXspi_SlaveSelectEnable
 */
typedef enum
{
    IfxXspi_SlaveSelectEnable_none = 0,  /**< \brief None: Xspi transfer no Slave selected */
    IfxXspi_SlaveSelectEnable_1    = 1,  /**< \brief 1: (Slave1): Xspi transfer Slave select enable 1 */
    IfxXspi_SlaveSelectEnable_2    = 2   /**< \brief 2: (Slave2): Xspi transfer Slave select enable 2 */
} IfxXspi_SlaveSelectEnable;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Xspi_Std_Enumerations
 * \{ */
/** \brief PROT and APU configuration
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;        /**< \brief PROTE configurations */
    IfxApProt_ProtConfig protseConfig;       /**< \brief PROTSE Configuration */
    IfxApApu_ApuConfig   apuConfig;          /**< \brief APU Configurations */
} IfxXspi_ApConfig;

/** \brief PROT and APU configuration
 */
typedef struct
{
    uint32 sClkout;               /**< \brief XSPI Clock out frequency */
    uint32 ssiClk;                /**< \brief XSPI SSI Clock frequency */
    uint32 baudrate;              /**< \brief Baudrate selected */
    uint32 sourceFrequency;       /**< \brief Reference Clock Input to XSPI */
} IfxXspi_BaudrateAndFrequencies;

/** \} */

/** \addtogroup IfxLld_Xspi_Std_External
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Get Scr Pointer for FIfo
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxXspi_getSrcPointerFifo(Ifx_XSPI *xspi);

/**
 * \param config Initialize the PROTs and APUs with default configuration
 *  param config Configuration pointer for the Access Protection
 * \return None
 */
IFX_EXTERN void IfxXspi_initApConfig(IfxXspi_ApConfig *config);

/** \brief Initialize the PROTs and APUs with default configuration
 * Xspi Xspi module pointer
 * config Configuration pointer for the Access Protection
 * \param config
 * \return None
 */
IFX_EXTERN void IfxXspi_initAp(Ifx_XSPI *xspi, IfxXspi_ApConfig *config);

/** \brief Get Scr Pointer for Error
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxXspi_getSrcPointerError(Ifx_XSPI *xspi);

/** \brief Configures access to all masters to all the XSPI in the device
 * \param apConfig config pointer to configuration structure.
 * \return None
 */
IFX_EXTERN void IfxXspi_configureAccessToXspi(IfxApApu_ApuConfig *apConfig);

/** \brief Writes data up to 8 bits
 * xspi pointer to XSPI registers
 * data Array of data to be send
 * \return None
 */
IFX_EXTERN void IfxXspi_write8(Ifx_XSPI *xspi, uint8 *data, uint32 count);

/** \brief Writes data up to 16 bits
 * xspi pointer to XSPI registers
 * data Array of data to be send
 * \return None
 */
IFX_EXTERN void IfxXspi_write16(Ifx_XSPI *xspi, uint16 *data, uint32 count);

/** \brief Writes data up to 32 bits
 * xspi pointer to XSPI registers
 * data Array of data to be send
 * \return None
 */
IFX_EXTERN void IfxXspi_write32(Ifx_XSPI *xspi, uint32 *data, uint32 count);

/** \brief Reads data up to 8 bits
 * xspi pointer to XSPI registers
 * data Array of data to be receive
 * \return None
 */
IFX_EXTERN void IfxXspi_read8(Ifx_XSPI *xspi, uint8 *data, uint32 count);

/** \brief Reads data up to 16 bits
 * xspi pointer to XSPI registers
 * data Array of data to be receive
 * \return None
 */
IFX_EXTERN void IfxXspi_read16(Ifx_XSPI *xspi, uint16 *data, uint32 count);

/** \brief Reads data up to 32 bits
 * xspi pointer to XSPI registers
 * data Array of data to be receive
 * \return None
 */
IFX_EXTERN void IfxXspi_read32(Ifx_XSPI *xspi, uint32 *data, uint32 count);

/** \brief Reset XSPI module
 * \param xspi Xspi module pointer
 * \return None
 */
IFX_EXTERN void IfxXspi_resetModule(Ifx_XSPI *xspi);

/** \brief Reset XSPI module
 * \param xspi Xspi module pointer
 * \param configStatus reference for Baudrate and frequencies status
 * \return None
 */
IFX_EXTERN void IfxXspi_getBaudrate(Ifx_XSPI *xspi, IfxXspi_BaudrateAndFrequencies *configStatus);

/** \} */

#endif /* IFXXSPI_H */
