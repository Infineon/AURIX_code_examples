/**
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

#include "Ifx_Cfg.h"
#include "IfxTcIpc.h"
#include "IfxCpu.h"
#include "IfxSrc.h"
#if (IFX_VP_DEBUG_PRINT == 1U)
#include "printf_to_tspi.h"
#endif

IfxCpu_mutexLock resourceLock;

#if defined(S2C_INTERRUPT_NOTIFICATION)

unsigned int krnl_execution_complete0=0U;

IFX_INTERRUPT(IpcISR,0,IFX_INTPRIO_IPC_TC0)
{
	krnl_execution_complete0 = 1U;
	IfxSrc_clearRequest(&MODULE_SRC.PPUC.ICI);
}

#if (IFX_CFG_SSW_ENABLE_TRICORE1 == 1U)
unsigned int krnl_execution_complete1=0U;

IFX_INTERRUPT(IpcISR1,1,IFX_INTPRIO_IPC_TC1)
{
	krnl_execution_complete1 = 1U;
	IfxSrc_clearRequest(&SRC_GPSR4SR0);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE2 == 1U)
unsigned int krnl_execution_complete2=0U;

IFX_INTERRUPT(IpcISR2,2,IFX_INTPRIO_IPC_TC2)
{
	krnl_execution_complete2 = 1U;
	IfxSrc_clearRequest(&SRC_GPSR4SR1);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE3 == 1U)
unsigned int krnl_execution_complete3=0U;

IFX_INTERRUPT(IpcISR3,3,IFX_INTPRIO_IPC_TC3)
{
	krnl_execution_complete3= 1U;
	IfxSrc_clearRequest(&SRC_GPSR4SR2);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE4 == 1U)
unsigned int krnl_execution_complete4=0U;

IFX_INTERRUPT(IpcISR4,4,IFX_INTPRIO_IPC_TC4)
{
	krnl_execution_complete4 = 1U;
	IfxSrc_clearRequest(&SRC_GPSR4SR3);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE5 == 1U)
unsigned int krnl_execution_complete5=0U;

IFX_INTERRUPT(IpcISR5,5,IFX_INTPRIO_IPC_TC5)
{
	krnl_execution_complete5 = 1U;
	IfxSrc_clearRequest(&SRC_GPSR4SR4);
}
#endif
#endif

unsigned int *mailbox_pointers[] =
{
	(unsigned int *)TRICORE_0_REQUEST_MAILBOX,
	(unsigned int *)TRICORE_1_REQUEST_MAILBOX,
	(unsigned int *)TRICORE_2_REQUEST_MAILBOX,
	(unsigned int *)TRICORE_3_REQUEST_MAILBOX,
	(unsigned int *)TRICORE_4_REQUEST_MAILBOX,
	(unsigned int *)TRICORE_5_REQUEST_MAILBOX
};

/*
 * Request execution of an OpenCL kernel on PPU.
 * Return 0 for success, 1 and above otherwise
 */
IfxMailbox_Status IfxTcIpc_Rpc(unsigned int id, unsigned int num_args, int *args[])
{
	int coreid = IfxCpu_getCoreId();
	unsigned int status = 0U;
	volatile IfxMailbox *mbx = (IfxMailbox *)(mailbox_pointers[coreid]);

	status = IfxCpu_acquireMutex(&resourceLock);
	if(status)
	{
#if (IFX_VP_DEBUG_PRINT == 1U)
		   printfTri ("\n Tricore log: Lock acquired by Tricore%d\n",coreid);
#endif
		   /* Submit a command if the mailbox is empty */
		   if(mbx->command == IfxMailbox_Command_none)
		   {
			   mbx->id = id;
			   mbx->num_args = num_args;

			   for(int i=0;i<num_args;i++)
			   {
				   mbx->args[i] = (args[i]);
			   }

			    /* Signal the PPU */
			    mbx->command = IfxMailbox_Command_new;

			#if !defined(S2C_INTERRUPT_NOTIFICATION)
			    /* POLL until PPU confirms that the request has been completed */
			    while( ((mbx->status) != IfxMailbox_Status_successful) && ((mbx->status) != IfxMailbox_Status_notsuccessful))
			    {
			      /* NOP */
			    }
			#endif

			#if defined(S2C_INTERRUPT_NOTIFICATION)
				unsigned int * krnl_execution_complete = NULL_PTR;
			    switch(coreid)
			    {
			    	case 0:
			    		krnl_execution_complete = &krnl_execution_complete0;
			    		break;
#if (IFX_CFG_SSW_ENABLE_TRICORE1 == 1U)
			    	case 1:
			    		krnl_execution_complete = &krnl_execution_complete1;
			    		break;
#endif
#if (IFX_CFG_SSW_ENABLE_TRICORE2 == 1U)
			    	case 2:
			    		krnl_execution_complete = &krnl_execution_complete2;
			    		break;
#endif
#if (IFX_CFG_SSW_ENABLE_TRICORE3 == 1U)
			    	case 3:
			    		krnl_execution_complete = &krnl_execution_complete3;
			    		break;
#endif
#if (IFX_CFG_SSW_ENABLE_TRICORE4 == 1U)
			    	case 4:
			    		krnl_execution_complete = &krnl_execution_complete4;
			    		break;
#endif
#if (IFX_CFG_SSW_ENABLE_TRICORE5 == 1U)
			    	case 5:
			    		krnl_execution_complete = &krnl_execution_complete5;
			    		break;
#endif
			    	default:
			    		break;
			    }

			    while(*krnl_execution_complete == 0U)
			    {
			    	__nop();
			    }
			    *krnl_execution_complete = 0U;
			#endif

			   /* Clear the command and return the status of execution */
			   status = mbx->status;
			   mbx->status = IfxMailbox_Status_requestDone;
			   mbx->command = IfxMailbox_Command_none;

			   IfxCpu_releaseMutex(&resourceLock);
			   return status;
		   }
		   else
		   {
			   return IfxMailbox_Status_tryLater;
		   }
	}
	else
	{
		return IfxMailbox_Status_tryLater;
	}
}

#if defined(S2C_INTERRUPT_NOTIFICATION)
void IfxTcIpc_initS2CInterruptTc0(void)
{
#if (IFX_VP_DEBUG_PRINT == 1U)
	printfTri ("\n Tricore0 log: Enabling the TC0 interrupt\n");
#endif
	IfxSrc_init(&MODULE_SRC.PPUC.ICI, IfxSrc_Tos_cpu0, IFX_INTPRIO_IPC_TC0, 0U);
	IfxSrc_enable(&MODULE_SRC.PPUC.ICI);
}

#if (IFX_CFG_SSW_ENABLE_TRICORE1 == 1U)
void IfxTcIpc_initS2CInterruptTc1(void)
{
#if (IFX_VP_DEBUG_PRINT == 1U)
	printfTri ("\n Tricore0 log: Enabling the TC1 interrupt\n");
#endif
	IfxSrc_init(&SRC_GPSR4SR0, IfxSrc_Tos_cpu1, IFX_INTPRIO_IPC_TC1, 0U);
	IfxSrc_enable(&SRC_GPSR4SR0);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE2 == 1U)
void IfxTcIpc_initS2CInterruptTc2(void)
{
#if (IFX_VP_DEBUG_PRINT == 1U)
	printfTri ("\n Tricore0 log: Enabling the TC2 interrupt\n");
#endif
	IfxSrc_init(&SRC_GPSR4SR1, IfxSrc_Tos_cpu2, IFX_INTPRIO_IPC_TC2, 0U);
	IfxSrc_enable(&SRC_GPSR4SR1);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE3 == 1U)
void IfxTcIpc_initS2CInterruptTc3(void)
{
#if (IFX_VP_DEBUG_PRINT == 1U)
	printfTri ("\n Tricore0 log: Enabling the TC3 interrupt\n");
#endif
	IfxSrc_init(&SRC_GPSR4SR2, IfxSrc_Tos_cpu3, IFX_INTPRIO_IPC_TC3, 0U);
	IfxSrc_enable(&SRC_GPSR4SR2);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE4 == 1U)
void IfxTcIpc_initS2CInterruptTc4(void)
{
#if (IFX_VP_DEBUG_PRINT == 1U)
	printfTri ("\n Tricore0 log: Enabling the TC4 interrupt\n");
#endif
	IfxSrc_init(&SRC_GPSR4SR3, IfxSrc_Tos_cpu4, IFX_INTPRIO_IPC_TC4, 0U);
	IfxSrc_enable(&SRC_GPSR4SR3);
}
#endif

#if (IFX_CFG_SSW_ENABLE_TRICORE5 == 1U)
void IfxTcIpc_initS2CInterruptTc5(void)
{
#if (IFX_VP_DEBUG_PRINT == 1U)
	printfTri ("\n Tricore0 log: Enabling the TC5 interrupt\n");
#endif
	IfxSrc_init(&SRC_GPSR4SR4, IfxSrc_Tos_cpu5, IFX_INTPRIO_IPC_TC5, 0U);
	IfxSrc_enable(&SRC_GPSR4SR4);
}
#endif
#endif

