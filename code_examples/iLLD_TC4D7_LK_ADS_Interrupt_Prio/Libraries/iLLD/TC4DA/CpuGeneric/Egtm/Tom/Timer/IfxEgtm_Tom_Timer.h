/**
 * \file IfxEgtm_Tom_Timer.h
 * \brief EGTM TIMER details
 * \ingroup IfxLld_Egtm
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Egtm_Tom_Timer_Usage How to use the EGTM TOM Timer Driver
 * \ingroup IfxLld_Egtm_Tom_Timer
 *
 *   This driver implements the timer functionalities.
 *
 * \section specific Specific Implementation
 *   The timer functionality is implemented using either a single or 2 TOM channels. The decision to use 1 or 2 channels is done
 *   depending on the following requirements:
 *   - relative position of the timer channel to the other channels used if any
 *   - need to trigger another module, for example ADC triggering.
 *
 *   Single TOM channel is used for the timer and trigger functionalities.
 *   The internal trigger signal is generated when the counter CN0 reach the CM0 compare register. The value of CM0 act as the period value. This internal
 *   trigger is used to reset the CN0 counter and simultaneously transfer the shadow values for the period value (SR0->CM0)
 *   and trigger edge (SR1->CM1). The internal trigger is used as a trigger input to the next TOM channel.
 *   The trigger signal (output trigger) is generated by the CM0 and CM1 compare values. Depending on the trigger signal active
 *   edge \ref IfxEgtm_Tom_Timer_Config "configuration", the CM0 will reset, and the CM1 will set the trigger signal, or vice versa.
 *
 *   In case 2 TOM channels are used for the timer and trigger functionalities,
 *   the 1st channel (CHz) is used for the generation of the period,  and the 2nd channel (CHz+n) is used for the trigger generation.
 *
 *   The CHz TOM channel generates the internal trigger signal when the counter CN0 reach the CM0 compare register.
 *   The value of CM0 of CHz act as the period value. This internal trigger is used to reset the  CN0 counter and simultaneously
 *   transfer the shadow period value (SR0->CM0). The internal trigger is used as an input for the next TOM channel.
 *
 *   The CHz+n TOM channel, uses the internal trigger signal to simultaneously resets the
 *   counter CN0, and transfer the shadow values used for the generation of the trigger falling and rising edges (SR0->CM0 and SR1->CM1).
 *   The internal trigger is used as a trigger input to the next TOM channel.
 *   Depending on the trigger signal active edge \ref IfxEgtm_Tom_Timer_Config "configuration", the CM0 will reset, and the CM1 will set the trigger signal, or vice versa.
 *   In orter to have a similar behaviour to the single channel implementation,
 *   the CM0 is set to the same value as CHz CM0, and CM1 is used for the trigger edge.
 *
 *   In order to ensure a coherent update of all registers, the internal trigger must be disable before updating
 *   the timer and trigger shadow values, and enabled once the update is done. The transfer will occurs at the next timer reset.
 *
 *   - Resources used:
 *       - if the trigger channel is identical to the timer channel, only one TOM channels is used.
 *       - if the trigger channel is different from the timer channel, 2 TOM channels are used.
 *       - All channels used must be of the same TOM and TOM TGC.
 *   - The timer counting direction is limited to \ref IfxEgtm_Tom_Timer_CountDir_up.
 *   - If the TOM trigger channel is not the same as the TOM timer channels.
 *       - The TOM channel used for the trigger must have a lower index than the TOM channels.
 *         used for the timer.
 *       - the TOM channels must be contiguous, unless specified by the driver using the timer driver.
 *
 *  Note: the timer and trigger must be part of the same TGC, but PWM channels can be of different TGC of the same TOM as the timer.
 *
 *   For a detailed configuration of the microcontroller, see \ref IfxEgtm_Tom_Timer_init().
 *
 *
 * \section Preparation Preparation
 * \subsection Include Include Files
 *
 * Include following header file into your C code:
 * \code
 *     #include <Egtm/Tom/Timer/IfxEgtm_Tom_Timer.h>
 * \endcode
 *
 * \subsection Variables Variables
 * define global variables if necessary
 *
 * \code
 * Ifx_EGTM *egtm = &MODULE_EGTM;
 * #define TOM0_CH0_PRIO 10
 * \endcode
 *
 * \subsection Interrupts Interrupts
 * define Interrupts if needed
 *
 * \code
 * IFX_INTERRUPT(TOM0Ch0_ISR, 0, TOM0_CH0_PRIO)
 * {}
 * \endcode
 *
 * \subsection Initialization Initialization
 *
 * \code
 * // install interrupt handlers
 * IfxCpu_Irq_installInterruptHandler (TOM0Ch0_ISR, TOM0_CH0_PRIO);
 *
 * // enable EGTM clock
 * {
 *     float32 frequency = IfxEgtm_Cmu_getModuleFrequency(egtm);
 *     // Enables the EGTM
 *     IfxEgtm_enable(egtm);
 *     // Set the global clock frequency to the max
 *     IfxEgtm_Cmu_setGclkFrequency(egtm, frequency);
 *     // Set the CMU CLK0
 *     IfxEgtm_Cmu_setClkFrequency(egtm, IfxEgtm_Cmu_Clk_0, frequency);
 *     // FXCLK: used by TOM and CLK0: used by ATOM
 *     IfxEgtm_Cmu_enableClocks(egtm, IFXEGTM_CMU_CLKEN_FXCLK | IFXEGTM_CMU_CLKEN_CLK0);
 * }
 *
 * // initialize TOM
 * \code
 * IfxEgtm_Tom_Timer_Config tomConfig;      \\configuration structure
 * IfxEgtm_Tom_Timer tomHandle;      \\ handle
 *
 * IfxEgtm_Tom_Pwm_initConfig(&tomConfig, egtm);
 *
 *     //configuration
 *     tomConfig.gtm                               = gtm;
 *     tomConfig.cluster                           = IfxEgtm_Cluster_0;
 *     tomConfig.timerChannel                      = IfxEgtm_Tom_Ch_0;
 *     tomConfig.clock                             = IfxEgtm_Tom_Ch_ClkSrc_cmuFxclk0;
 *     tomConfig.countDir                          = IfxEgtm_Tom_Timer_CountDir_up;
 *     tomConfig.initPins                          = FALSE;
 *     tomConfig.frequency                         = 200000; \\frequency in Hz
 *     tomConfig.startOffset				         = 0;
 *     tomConfig.minResolution                     = 0;
 *  tomConfig.interrupt.isrPriority             = INTERRUPT_TIMER;
 *
 * IfxEgtm_Tom_Timer_init (&tomHandle, &tomConfig);
 *
 * \endcode
 *
 * During run-time
 * \code
 *  IfxEgtm_Tom_Timer_run(&tomHandle);
 *  IfxEgtm_Tom_Timer_disableUpdate(&tomHandle);
 *  IfxEgtm_Tom_Timer_setPeriod(&tomHandle);
 *  IfxEgtm_Tom_Timer_applyUpdate(&tomHandle);
 *
 * \endcode
 *
 * \defgroup IfxLld_Egtm_Tom_Timer Tom Timer Interface Driver
 * \ingroup IfxLld_Egtm_Tom
 * \defgroup IfxLld_Egtm_Tom_Timer_Data_Structures Data Structures
 * \ingroup IfxLld_Egtm_Tom_Timer
 * \defgroup IfxLld_Egtm_Tom_Timer_Timer_Functions Timer Functions
 * \ingroup IfxLld_Egtm_Tom_Timer
 * \defgroup IfxLld_Egtm_Tom_Timer_Timer_StdIf_Functions Timer StdIf Functions
 * \ingroup IfxLld_Egtm_Tom_Timer
 * \defgroup IfxLld_Egtm_Tom_Timer_Enumerations Enumerations
 * \ingroup IfxLld_Egtm_Tom_Timer
 */

#ifndef IFXEGTM_TOM_TIMER_H
#define IFXEGTM_TOM_TIMER_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_PinMap/IfxEgtm_PinMap.h"
#include "Egtm/Std/IfxEgtm_Tom.h"
#include "Egtm/Std/IfxEgtm_Cmu.h"
#include "Egtm/Std/IfxEgtm_Dtm.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Tom_Timer_Enumerations
 * \{ */
/** \brief Timer increment direction
 */
typedef enum
{
    IfxEgtm_Tom_Timer_CountDir_up,         /**< \brief Timer is counting up */
    IfxEgtm_Tom_Timer_CountDir_upAndDown,  /**< \brief Timer is counting up and down */
    IfxEgtm_Tom_Timer_CountDir_down        /**< \brief Timer is counting down */
} IfxEgtm_Tom_Timer_CountDir;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Tom_Timer_Data_Structures
 * \{ */
/** \brief Interrupt configuration
 */
typedef struct
{
    Ifx_Priority    isrPriority;       /**< \brief Interrupt Priority, if 0 the interrupt is disable */
    IfxSrc_Tos      isrProvider;       /**< \brief Interrupt service provider */
    IfxEgtm_IrqMode irqMode;           /**< \brief Interrupt mode */
    IfxSrc_VmId     vmId;              /**< \brief Virtual machine interrupt service provider */
} IfxEgtm_Tom_Timer_Interrupt;

/** \} */

/** \addtogroup IfxLld_Egtm_Tom_Timer_Data_Structures
 * \{ */
/** \brief Trigger configuration
 */
typedef struct
{
    boolean                     enabled;                  /**< \brief If TRUE, the trigger functionality is initialized, else ignored */
    uint16                      triggerPoint;             /**< \brief Trigger point in timer ticks */
    IfxPort_OutputMode          outputMode;               /**< \brief Output mode */
    IfxPort_PadDriver           outputDriver;             /**< \brief Output pad driver */
    boolean                     risingEdgeAtPeriod;       /**< \brief Set the clock signal polarity, if TRUE, the rising edge is at the period, else at the trigger offset. When the timer is stopped, the output is set to high */
    boolean                     outputEnabled;            /**< \brief If TRUE, the output pin is enabled, else disabled. In case the output is disabled, the output pin is not initialized. */
    IfxEgtm_Tom_Timer_Interrupt interrupt;                /**< \brief Interrupt configuration */
} IfxEgtm_Tom_Timer_Trigger;

/** \} */

/** \addtogroup IfxLld_Egtm_Tom_Timer_Data_Structures
 * \{ */
/** \brief TOM Timer interface Handle
 */
typedef struct
{
    Ifx_EGTM                  *egtm;                                                     /**< \brief Pointer to EGTM module */
    Ifx_EGTM_CLS_TOM          *tom;                                                      /**< \brief Pointer to the TOM object */
    Ifx_EGTM_CLS_TOM_TGC      *tgc[IFXEGTM_TOM_NUM_TGC];                                 /**< \brief Pointer to the TGC object */
    IfxEgtm_Cluster            clsIndex;                                                 /**< \brief Enum for CLS objects */
    IfxEgtm_Tom_Ch             timerChannel;                                             /**< \brief TOM channel used for the timer */
    IfxEgtm_Tom_Ch             triggerChannel;                                           /**< \brief TOM channel used for the trigger, can be identical to the timer channel */
    uint16                     channelsMask[IFXEGTM_TOM_NUM_TGC];                        /**< \brief Mask for channels to be modified together, The 1st value corresponds to the Timer's TGC, the 2nd value corresponds to the timer's next TGC if any */
    uint32                     offset;                                                   /**< \brief Timer initial offset in ticks */
    uint32                     tgcGlobalControlDisableUpdate[IFXEGTM_TOM_NUM_TGC];       /**< \brief Cached value for TGC GLOB_CTR */
    uint32                     tgcGlobalControlApplyUpdate[IFXEGTM_TOM_NUM_TGC];         /**< \brief Cached value for TGC GLOB_CTR */
    Ifx_EGTM_CLS_CDTM_DTM     *dtm;                                                      /**< \brief Pointer to DTM object used by TOM */
    IfxEgtm_Dtm_Ch             dtmChannel;                                               /**< \brief DTM Channel */
    uint16                     period;                                                   /**< \brief Timer period in ticks (cached value) */
    boolean                    triggerEnabled;                                           /**< \brief If TRUE, the trigger functionality is initialized */
    float32                    clockFreq;                                                /**< \brief Timer input clock frequency (cached value) */
    IfxEgtm_Tom_Timer_CountDir countDir;                                                 /**< \brief Timer counting mode */
} IfxEgtm_Tom_Timer;

/** \brief Configuration structure for TOM Timer
 */
typedef struct
{
    Ifx_EGTM                   *egtm;                 /**< \brief Pointer to EGTM module */
    IfxEgtm_Cluster             cluster;              /**< \brief Index of the CLS object used */
    IfxEgtm_Tom_Ch              timerChannel;         /**< \brief TOM channel used for the timer */
    IfxEgtm_Tom_ToutMap        *triggerOut;           /**< \brief TOM channel used for the trigger output, can be identical to the timer channel */
    IfxEgtm_Tom_Ch_ClkSrc       clock;                /**< \brief Timer input clock */
    IfxEgtm_Dtm_ClockSource     dtmClockSource;       /**< \brief DTM clock source */
    float32                     frequency;            /**< \brief PWM frequency in Hz. This parameter is only used to initialize the timer structure. An additional cell is required to build the timer. */
    float32                     minResolution;        /**< \brief Minimum resolution of the timer in seconds. if 0, this parameter is ignored. If the configuration does not enable this setting a warning is given */
    float32                     startOffset;          /**< \brief FIXME make startOffset as Ifx_TimerValue. Timer initial offset in % of the period */
    IfxEgtm_Tom_Timer_CountDir  countDir;             /**< \brief Timer counting mode */
    IfxEgtm_Tom_Timer_Interrupt interrupt;            /**< \brief Interrupt configuration */
    IfxEgtm_Tom_Timer_Trigger   trigger;              /**< \brief Interrupt configuration */
    boolean                     initPins;             /**< \brief TRUE : Initialize pins in driver.
                                                       * FALSE: Don't initialize pins : handled separately by user */
} IfxEgtm_Tom_Timer_Config;

/** \} */

/** \addtogroup IfxLld_Egtm_Tom_Timer_Timer_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the initial timer offset in ticks
 * \param driver TOM Timer interface Handle
 * \return Returns the initial timer offset in ticks
 */
IFX_INLINE uint32 IfxEgtm_Tom_Timer_getOffset(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the pointer to timer channel
 * \param driver TOM Timer interface Handle
 * \return Pointer
 */
IFX_INLINE volatile uint32 *IfxEgtm_Tom_Timer_getPointer(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the pointer to trigger channel
 * \param driver TOM Timer interface Handle
 * \return Pointer
 */
IFX_INLINE volatile uint32 *IfxEgtm_Tom_Timer_getTriggerPointer(IfxEgtm_Tom_Timer *driver);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief initializes the timer object
 * \param driver TOM Timer interface Handle
 * \param config Configuration structure for TOM Timer
 * \return TRUE on success else FALSE
 */
IFX_EXTERN boolean IfxEgtm_Tom_Timer_init(IfxEgtm_Tom_Timer *driver, const IfxEgtm_Tom_Timer_Config *config);

/** \brief Initializes the configuration structure to default
 * \param config This parameter is initialized by the function
 * \param egtm Pointer to EGTM module
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tom_Timer_initConfig(IfxEgtm_Tom_Timer_Config *config, Ifx_EGTM *egtm);

/** \} */

/** \addtogroup IfxLld_Egtm_Tom_Timer_Timer_StdIf_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Add a channel to the channel mask
 * Channels present in the mask are started, stopped, updated at the same time as the timer:
 * IfxEgtm_Tom_Timer_applyUpdate, IfxEgtm_Tom_Timer_disableUpdate, IfxEgtm_Tom_Timer_stop, IfxEgtm_Tom_Timer_run
 * \param driver TOM Timer interface Handle
 * \param channel Channel to ba added to the mask
 * \return None
 */
IFX_INLINE void IfxEgtm_Tom_Timer_addToChannelMask(IfxEgtm_Tom_Timer *driver, IfxEgtm_Tom_Ch channel);

/** \brief Enables the transfer of the shadow registers
 * \see IfxStdIf_Timer_ApplyUpdate
 * Specific implementation: Enable the transfer of the shadow registers
 * \param driver TOM Timer interface Handle
 * \return None
 */
IFX_INLINE void IfxEgtm_Tom_Timer_applyUpdate(IfxEgtm_Tom_Timer *driver);

/** \brief Disables the update
 * \see IfxStdIf_Timer_DisableUpdate
 * Specific implementation: Disable the transfer of the shadow registers
 * \param driver TOM Timer interface Handle
 * \return None
 */
IFX_INLINE void IfxEgtm_Tom_Timer_disableUpdate(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the frequency
 * \see IfxStdIf_Timer_GetFrequency
 * \param driver TOM Timer interface Handle
 * \return Frequency
 */
IFX_INLINE float32 IfxEgtm_Tom_Timer_getFrequency(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the Input frequency
 * \param driver TOM Timer interface Handle
 * \return Frequency
 */
IFX_INLINE float32 IfxEgtm_Tom_Timer_getInputFrequency(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the period of the timer
 * \see IfxStdIf_Timer_GetPeriod
 * \param driver TOM Timer interface Handle
 * \return Period
 */
IFX_INLINE uint16 IfxEgtm_Tom_Timer_getPeriod(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the resolution
 * \see IfxStdIf_Timer_GetResolution
 * \param driver TOM Timer interface Handle
 * \return Resolution
 */
IFX_INLINE float32 IfxEgtm_Tom_Timer_getResolution(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the trigger point
 * \param driver TOM Timer interface Handle
 * \return Trigger point
 */
IFX_INLINE uint16 IfxEgtm_Tom_Timer_getTrigger(IfxEgtm_Tom_Timer *driver);

/** \brief Sets the frequency
 * \see IfxStdIf_Timer_SetFrequency
 * \param driver TOM Timer interface Handle
 * \param frequency Frequency
 * \return TRUE on success else FALSE
 */
IFX_INLINE boolean IfxEgtm_Tom_Timer_setFrequency(IfxEgtm_Tom_Timer *driver, float32 frequency);

/** \brief Sets the period for the timer
 * \see IfxStdIf_Timer_SetPeriod
 * \param driver TOM Timer interface Handle
 * \param period Period value
 * \return TRUE on success else FALSE
 */
IFX_INLINE boolean IfxEgtm_Tom_Timer_setPeriod(IfxEgtm_Tom_Timer *driver, uint16 period);

/** \brief Sets the single shot mode of the timer
 * \see IfxStdIf_Timer_SetSingleMode
 * \param driver TOM Timer interface Handle
 * \param enabled If TRUE, sets the single shot mode
 * \return None
 */
IFX_INLINE void IfxEgtm_Tom_Timer_setSingleMode(IfxEgtm_Tom_Timer *driver, boolean enabled);

/** \brief Sets the trigger
 * \see IfxStdIf_Timer_SetTrigger
 * \param driver TOM Timer interface Handle
 * \param triggerPoint Trigger point value
 * \return None
 */
IFX_INLINE void IfxEgtm_Tom_Timer_setTrigger(IfxEgtm_Tom_Timer *driver, uint16 triggerPoint);

/** \brief Updates the input frequency
 * \see IfxStdIf_Timer_UpdateInputFrequency
 * \param driver TOM Timer interface Handle
 * \return None
 */
IFX_INLINE void IfxEgtm_Tom_Timer_updateInputFrequency(IfxEgtm_Tom_Timer *driver);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the timer event
 * \see IfxStdIf_Timer_AckTimerIrq
 * \param driver TOM Timer interface Handle
 * \return Timer event
 */
IFX_EXTERN boolean IfxEgtm_Tom_Timer_acknowledgeTimerIrq(IfxEgtm_Tom_Timer *driver);

/** \brief Returns the trigger event
 * \see IfxStdIf_Timer_AckTriggerIrq
 * \param driver TOM Timer interface Handle
 * \return Trigger event
 */
IFX_EXTERN boolean IfxEgtm_Tom_Timer_acknowledgeTriggerIrq(IfxEgtm_Tom_Timer *driver);

/** \brief Runs the timer
 * \see IfxStdIf_Timer_Run
 * \param driver TOM Timer interface Handle
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tom_Timer_run(IfxEgtm_Tom_Timer *driver);

/** \brief Stops the timer
 * \see IfxStdIf_Timer_Stop
 * \param driver TOM Timer interface Handle
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tom_Timer_stop(IfxEgtm_Tom_Timer *driver);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxEgtm_Tom_Timer_addToChannelMask(IfxEgtm_Tom_Timer *driver, IfxEgtm_Tom_Ch channel)
{
    if (driver->timerChannel <= IfxEgtm_Tom_Ch_7)
    {
        if (channel <= IfxEgtm_Tom_Ch_7)
        {
            driver->channelsMask[0]                 |= (uint16)((uint16)1u << (uint16)channel);
            driver->tgcGlobalControlDisableUpdate[0] = IfxEgtm_Tom_Tgc_buildFeature(0, driver->channelsMask[0], IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
            driver->tgcGlobalControlApplyUpdate[0]   = IfxEgtm_Tom_Tgc_buildFeature(driver->channelsMask[0], 0, IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
        }
        else
        {
            driver->channelsMask[1]                 |= (uint16)((uint16)1u << (uint16)((uint16)channel - (uint16)IfxEgtm_Tom_Ch_8));
            driver->tgcGlobalControlDisableUpdate[1] = IfxEgtm_Tom_Tgc_buildFeature(0, driver->channelsMask[1], IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
            driver->tgcGlobalControlApplyUpdate[1]   = IfxEgtm_Tom_Tgc_buildFeature(driver->channelsMask[1], 0, IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
        }
    }
    else
    {
        driver->channelsMask[0]                 |= (uint16)((uint16)1u << (uint16)((uint16)channel - (uint16)IfxEgtm_Tom_Ch_8));
        driver->tgcGlobalControlDisableUpdate[0] = IfxEgtm_Tom_Tgc_buildFeature(0, driver->channelsMask[0], IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
        driver->tgcGlobalControlApplyUpdate[0]   = IfxEgtm_Tom_Tgc_buildFeature(driver->channelsMask[0], 0, IFX_EGTM_CLS_TOM_TGC_GLB_CTRL_UPEN_CTRL0_OFF);
    }
}


IFX_INLINE void IfxEgtm_Tom_Timer_applyUpdate(IfxEgtm_Tom_Timer *driver)
{
    IfxEgtm_Tom_Tgc_writeGlobalControl(driver->tgc[0], driver->tgcGlobalControlApplyUpdate[0]);

    if (driver->tgc[1] != NULL_PTR)
    {
        IfxEgtm_Tom_Tgc_writeGlobalControl(driver->tgc[1], driver->tgcGlobalControlApplyUpdate[1]); /* Note: Write of 0 value has no effect */
    }
}


IFX_INLINE void IfxEgtm_Tom_Timer_disableUpdate(IfxEgtm_Tom_Timer *driver)
{
    IfxEgtm_Tom_Tgc_writeGlobalControl(driver->tgc[0], driver->tgcGlobalControlDisableUpdate[0]);

    if (driver->tgc[1] != NULL_PTR)
    {
        IfxEgtm_Tom_Tgc_writeGlobalControl(driver->tgc[1], driver->tgcGlobalControlDisableUpdate[1]); /* Note: Write of 0 value has no effect */
    }
}


IFX_INLINE float32 IfxEgtm_Tom_Timer_getFrequency(IfxEgtm_Tom_Timer *driver)
{
    float32 tickTOS = IfxEgtm_tickToS(driver->clockFreq, driver->period);
    return (float32)1.0f / tickTOS;
}


IFX_INLINE float32 IfxEgtm_Tom_Timer_getInputFrequency(IfxEgtm_Tom_Timer *driver)
{
    return driver->clockFreq;
}


IFX_INLINE uint32 IfxEgtm_Tom_Timer_getOffset(IfxEgtm_Tom_Timer *driver)
{
    return driver->offset;
}


IFX_INLINE uint16 IfxEgtm_Tom_Timer_getPeriod(IfxEgtm_Tom_Timer *driver)
{
    return driver->period;
}


IFX_INLINE volatile uint32 *IfxEgtm_Tom_Timer_getPointer(IfxEgtm_Tom_Timer *driver)
{
    return IfxEgtm_Tom_Ch_getTimerPointer(driver->tom, driver->timerChannel);
}


IFX_INLINE float32 IfxEgtm_Tom_Timer_getResolution(IfxEgtm_Tom_Timer *driver)
{
    return (float32)1.0f / driver->clockFreq;
}


IFX_INLINE uint16 IfxEgtm_Tom_Timer_getTrigger(IfxEgtm_Tom_Timer *driver)
{
    return IfxEgtm_Tom_Ch_getCompareOne(driver->tom, driver->triggerChannel) - 1u;
}


IFX_INLINE volatile uint32 *IfxEgtm_Tom_Timer_getTriggerPointer(IfxEgtm_Tom_Timer *driver)
{
    return IfxEgtm_Tom_Ch_getCompareOnePointer(driver->tom, driver->triggerChannel);
}


IFX_INLINE boolean IfxEgtm_Tom_Timer_setFrequency(IfxEgtm_Tom_Timer *driver, float32 frequency)
{
    uint16 period = (uint16)IfxEgtm_sToTick(driver->clockFreq, (float32)1.0f / frequency);

    return IfxEgtm_Tom_Timer_setPeriod(driver, period);
}


IFX_INLINE boolean IfxEgtm_Tom_Timer_setPeriod(IfxEgtm_Tom_Timer *driver, uint16 period)
{
    driver->period = period;
    IfxEgtm_Tom_Ch_setCompareZeroShadow(driver->tom, driver->timerChannel, period);

    if (driver->triggerChannel != driver->timerChannel)
    {
        IfxEgtm_Tom_Ch_setCompareZeroShadow(driver->tom, driver->triggerChannel, period);
    }

    return TRUE;
}


IFX_INLINE void IfxEgtm_Tom_Timer_setSingleMode(IfxEgtm_Tom_Timer *driver, boolean enabled)
{
    IfxEgtm_Tom_Ch_setOneShotMode(driver->tom, driver->timerChannel, enabled);
}


IFX_INLINE void IfxEgtm_Tom_Timer_setTrigger(IfxEgtm_Tom_Timer *driver, uint16 triggerPoint)
{
    IfxEgtm_Tom_Ch_setCompareOneShadow(driver->tom, driver->triggerChannel, triggerPoint + 1u);
}


IFX_INLINE void IfxEgtm_Tom_Timer_updateInputFrequency(IfxEgtm_Tom_Timer *driver)
{
    driver->clockFreq = IfxEgtm_Tom_Ch_getClockFrequency(driver->egtm, driver->tom, driver->timerChannel);
}


#endif /* IFXEGTM_TOM_TIMER_H */
