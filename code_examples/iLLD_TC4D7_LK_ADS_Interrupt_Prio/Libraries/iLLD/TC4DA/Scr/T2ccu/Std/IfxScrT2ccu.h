/**
 * \file IfxScrT2ccu.h
 * \brief SCRT2CCU  basic functionality
 * \ingroup IfxLld_ScrT2ccu
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * * \defgroup IfxLld_ScrT2ccu_Std_Enumerations Enum
 * \ingroup IfxLld_ScrT2ccu_Std
 * \defgroup IfxLld_ScrT2ccu_Std_DataStructures Data structures
 * \ingroup IfxLld_ScrT2ccu_Std
 * \defgroup IfxLld_ScrT2ccu_Std_Timer2 Timer2 Functionality
 * \ingroup IfxLld_ScrT2ccu_Std
 * \defgroup IfxLld_ScrT2ccu_Std_Timer2_init Timer2 init Functionality
 * \ingroup IfxLld_ScrT2ccu_Std
 * \defgroup IfxLld_ScrT2ccu_Std_Cct Cct Timer Functionality
 * \ingroup IfxLld_ScrT2ccu_Std
 * \defgroup IfxLld_ScrT2ccu_Std_Cct_init Cct Timer init Functionality
 * \ingroup IfxLld_ScrT2ccu_Std
 * \defgroup IfxLld_ScrT2ccu_Std_CompareCapture  Compare and Capture functionality
 * \ingroup IfxLld_ScrT2ccu_Std
 * \defgroup IfxLld_ScrT2ccu_Std_CaptureCompare_init  Compare and Capture init functionality
 * \ingroup IfxLld_ScrT2ccu_Std
 */

#ifndef IFXSCRT2CCU_H
#define IFXSCRT2CCU_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxScrT2ccu_cfg.h"
#include "_Reg/IfxScr_bf.h"
#include "_Reg/IfxScr_reg.h"
#include "_Utilities/Ifx_Assert.h"
/*
 * FIXME:Macros are used below instead of a cleaner enum approach because enums inside struct was giving build error.
 * In future if we find a way of doing it or if it happens to be a compiler issue and is fixed, the macros will be replaced by enums
 *
 * Naming should be all caps or should it follow enum like convention? Latter will make it easier to port if enums can be included in future.
 * */

#define IfxScrT2ccu_Timer2Mode_timer             0
#define IfxScrT2ccu_Timer2Mode_counter           1

#define IfxScrT2ccu_Trigger_fallingEdge          0
#define IfxScrT2ccu_Trigger_risingEdge           1

#define IfxScrT2ccu_pclkDiv_None                 0U
#define IfxScrT2ccu_Divider_None                 1U
#define IfxScrT2ccu_Divider_2                    1U
#define IfxScrT2ccu_Divider_4                    2U
#define IfxScrT2ccu_Divider_8                    3U
#define IfxScrT2ccu_Divider_16                   4U
#define IfxScrT2ccu_Divider_32                   5U
#define IfxScrT2ccu_Divider_64                   6U
#define IfxScrT2ccu_Divider_128                  7U
#define IfxScrT2ccu_Divider_256                  8U
#define IfxScrT2ccu_Divider_512                  9U
#define IfxScrT2ccu_Divider_1024                 10U
#define IfxScrT2ccu_Divider_2048                 11U
#define IfxScrT2ccu_Divider_12                   12U

#define IfxScrT2ccu_CctClockSource_pclk          0U
#define IfxScrT2ccu_CctClockSource_timer2        1U

/* Macro for Base timer selection */
#define IfxScrT2ccuTimer_timer2                  0U
#define IfxScrT2ccuTimer_cct                     1U

/* Macro for compare mode selection */
#define IfxScrT2ccuCmpMode_mode0                 0U /**< \brief Compare Mode 0 selected */
#define IfxScrT2ccuCmpMode_mode1                 1U /**< \brief Compare Mode 1 selected */
#define IfxScrT2ccuCmpMode_concurrentmode        2U /**< \brief Concurrent Compare mode selected */

/* Macro for Enabling Compare/Capture operation */
#define IfxScrT2ccuCompareCapture_disable        0U /**< \brief Capture/Compare disabled */
#define IfxScrT2ccuCompareCapture_captureEdge    1U /**< \brief Capture on active edge at pin T2CC0 */
#define IfxScrT2ccuCompareCapture_compareEnable  2U /**< \brief Compare enabled */
#define IfxScrT2ccuCompareCapture_captureSwWrite 3U /**< \brief Capture on write operation into register CCxL */

/* -------------------------------------------Timer2------------------------------------------ */

//T2 config parameters

/*
 * Configuration for Timer 2 clock source
 *
 * Allowed Values for divider are:
 *
 * IfxScrT2ccu_Divider_None
 * IfxScrT2ccu_Divider_2
 * IfxScrT2ccu_Divider_4
 * IfxScrT2ccu_Divider_8
 * IfxScrT2ccu_Divider_16
 * IfxScrT2ccu_Divider_32
 * IfxScrT2ccu_Divider_64
 * IfxScrT2ccu_Divider_128
 * IfxScrT2ccu_Divider_4096
 *
 */

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_Enumerations
 * \{ */
/** \brief Enumeration for RTC clock input selection
 */
typedef enum
{
    IfxScrT2ccu_0 = 0,       /**< \brief T2CCU0 selected */
    IfxScrT2ccu_1 = 1        /**< \brief T2CCU1 selected*/
} IfxScrT2ccu;

/** \brief Enumeration for Channel Selection
 * [IfxScrT2ccuChannel_0 - IfxScrT2ccuChannel_3 -->Capture/Compare operation]
 * [IfxScrT2ccuChannel_4, IfxScrT2ccuChannel_5] --> Compare operation]
 * [0,2,4 Channels --> Group A]
 * [1,3,5 Channels --> Group B]
 */
typedef enum
{
    IfxScrT2ccuChannel_0 = 0,   /**< \brief T2CCU0 Channel 0 */
    IfxScrT2ccuChannel_1 = 1,   /**< \brief T2CCU0 Channel 1 */
    IfxScrT2ccuChannel_2 = 2,   /**< \brief T2CCU0 Channel 2 */
    IfxScrT2ccuChannel_3 = 3,   /**< \brief T2CCU0 Channel 3 */
    IfxScrT2ccuChannel_4 = 4,   /**< \brief T2CCU0 Channel 4 */
    IfxScrT2ccuChannel_5 = 5    /**< \brief T2CCU0 Channel 5 */
} IfxScrT2ccuChannel;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_DataStructures
 * \{ */
/*
 * 1. For Capture mode,
 *  DCEN = 0(override downCountEnable),
 *  T2CON.EXEN2 = 1
 *  T2MOD.EDGESEL = selected edge
 *  T2_CON.CP_RL2 =1
 *  NOTE: If captureModeEnable == TRUE, following are mandatoy for proper functionality:
 *  downCountEnable = FALSE
 *  externalEventEnable = TRUE
 *  captureModeEnable = TRUE
 * .
 * 2. For Reload mode
 *    captureModeEnable = FALSE
 *    reloadValue = val
 *
 * FIXME: No requirement yet for "Reload on external Trigger with T2CON.EXEN2".Will be implemented in future
 * Timer 2 Configuration
 * */

typedef struct
{
    uint8 timerOperationMode;        /** Select between Timer mode and Counter mode.Selected in T2CON.C_T2.Following are the available options:
                                      * IfxScrT2ccu_Timer2Mode_timer for timer mode
                                      * IfxScrT2ccu_Timer2Mode_counter for counter mode.
                                      */
    boolean hwRunTriggerEnable;      /* Enable triggering the run from configurable pin T2EX.Selected in T2_MOD.T2REGS */
    uint8   hwRunTriggerEdge;        /* Select edge(rising/falling) for triggering Timer 2 run from hardware. Selected in T2MOD.T2REGS. Following are the available options:
                                      * IfxScrT2ccu_Trigger_fallingEdge
                                      * IfxScrT2ccu_Trigger_risingEdge
                                      */
    boolean externalEventEnable;     /* Enable the external trigger of events like reload Timer 2 and capture */
/* IMPORTANT:
 * 1. Capture mode will disable facility for having custom reload value.Default reload value(i.e 0) will be used.To add custom reload value, select captureModeEnable = FALSE
 * 2. Capture mode is possible in "Up-counting only" mode(T2MOD.DCEN =0)
 * 3. Capture can be triggered only from hardware configurable pin T2EX
 */
    boolean captureModeEnable;       /** Enable capture mode.Options include TRUE and FALSE.Selected in T2CON.CP_RL2 */
    uint8   captureTriggerEdge;      /* Select edge(rising/falling) for triggering capture. Selected in T2MOD.EDGESEL. Options are:
                                      * IfxScrT2ccu_Trigger_fallingEdge
                                      * IfxScrT2ccu_Trigger_risingEdge
                                      */
    uint8   downCountEnable;         /*Enable down counting.Options being TRUE and FALSE,Selected in T2MOD.DCEN  */
    boolean overflowInterruptEnable; /** Enable interrupt trigger on timer overflow, Enabled in T2CON1.TF2EN and SCR_IEN0 */
    boolean externalInterruptEnable; /** Enable external interrupt trigger on timer overflow/reload/capture from configurable pin T2EX. Selected in T2CON1.EXF2EN */
    uint16  reloadValue;             /* Reload value for Timer2 in case of timer overflow or hardware pin generated overflow */
    uint8   clockDivider;            /* Divider value for T2CCU clock source in case the configurable prescaler is selected.Configured in T2MOD.T2PRE.
                                      * Valid options are:
                                      * IfxScrT2ccu_Divider_None
                                      * IfxScrT2ccu_Divider_2
                                      * IfxScrT2ccu_Divider_4
                                      * IfxScrT2ccu_Divider_8
                                      * IfxScrT2ccu_Divider_16
                                      * IfxScrT2ccu_Divider_32
                                      * IfxScrT2ccu_Divider_64
                                      * IfxScrT2ccu_Divider_128
                                      */
}IfxScrT2ccu_Timer2Config;

typedef struct
{
    uint8 clockSource;               /* Clock source for CCT.Filled in T2CCU_CCTBSEL.CASC. Options are:
                                      *   IfxScrT2ccu_CctClockSource_pclk
                                      *   IfxScrT2ccu_CctClockSource_timer2
                                      */
    uint8 pclkDivider;               /* Divider value for the clock source.Value set in T2CCU_CCTCON.CCTPRE.Following are the available options:
                                      * IfxScrT2ccu_Divider_None
                                      * IfxScrT2ccu_Divider_2
                                      * IfxScrT2ccu_Divider_4
                                      * IfxScrT2ccu_Divider_8
                                      * IfxScrT2ccu_Divider_16
                                      * IfxScrT2ccu_Divider_32
                                      * IfxScrT2ccu_Divider_64
                                      * IfxScrT2ccu_Divider_128
                                      * IfxScrT2ccu_Divider_256
                                      * IfxScrT2ccu_Divider_512
                                      * IfxScrT2ccu_Divider_1024
                                      * IfxScrT2ccu_Divider_2048
                                      */
    uint16  initialCount;            /* Inital value for CCT timer.To be written in T2CCU_CCTH/T2CCU_CCTL.Write to H followed by L */
    uint16  reloadValue;             /* Reload value for CCT timer.Value set in  CCTRELH,CCTREL */
    boolean overflowInterruptEnable; /* Trigger interrupt on CCT overflow.Set in T2CCU_CCTCON.CCTOVEN.Options are : TRUE or FALSE*/
    boolean timesync;                /* Synchronized timer start for CCT and T2. Options are : TRUE or FALSE*/
}IfxScrT2ccu_CctConfig;

typedef struct
{
    boolean deadTimeLevel;              /** Dead time level.[DTLEV] */
    uint8   deadTimeValue;              /** Dead time Value.[DTM] */
    boolean deadTimeEnable;             /** Dead time Enable.[DTE] */
}IfxScrT2ccu_deadtimeConfig;

typedef struct
{
    IfxScrT2ccuChannel channelId;                     /** Channel Id for T2CCU.
                                                       * For Capture operation: IfxScrT2ccuChannel_0 - IfxScrT2ccuChannel_3
                                                       * For Compare Operation : IfxScrT2ccuChannel_0 - IfxScrT2ccuChannel_5*/
    uint8 enableCmpCap;                               /** Enable Compare/Capture.
                                                       *  Valid Options :
                                                       *  IfxScrT2ccuCompareCapture_disable,
                                                       *  IfxScrT2ccuCompareCapture_captureEdge
                                                       *  IfxScrT2ccuCompareCapture_compareEnable
                                                       *  IfxScrT2ccuCompareCapture_captureSwWrite*/
    uint8 baseTimer;                                  /** Base timer selection.
                                                       *  Options: IfxScrT2ccuTimer_timer2,IfxScrT2ccuTimer_cct */
    uint8 cmpMode;                                    /** Compare Mode selection.
                                                       *  Options :
                                                       *  IfxScrT2ccuCmpMode_mode0,
                                                       *  IfxScrT2ccuCmpMode_mode1
                                                       *  IfxScrT2ccuCmpMode_concurrentmode*/
    uint16                      cmpValue;             /** Compare Value */
    boolean                     hwControl;            /** TRUE --> Trigger transfer from shadow register into compare register through overflow signal (TxOV)
                                                       *  FALSE --> Trigger transfer from shadow register into compare register through software (ENSHDW,COOUTx)*/
    boolean                     polarity;             /** Desired output polarity */
    boolean                     cmpOutput;            /** Compare output polarity */
    IfxScrT2ccu_deadtimeConfig *deadtimeCfg;          /** Dead time configuration ptr */
    uint8                       concurrentchannels;   /* Number of channels to be used in concurrent mode.
                                                       * Each bit represents channel number. (eg :00101010 Channel 1,3 and 5 is used)*/
    uint8                       concurrentModeOutput; /* Compare Output for each channel in concurrent mode.
                                                       *  Each bit represent initial compare output value of corresponding channel*/
}IfxScrT2ccu_CompareCaptureConfig;
/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_Timer2
 * \{ */
/** \brief Function to start timer2
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_runTimer2(IfxScrT2ccu module);

/** \brief Function to halt timer2
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_haltTimer2(IfxScrT2ccu module);

/** \brief Query timer 2 over flow flag
 * \param module T2CCU0 or T2CCU1
 * \return Status of SCR_T2CCUx_T2_CON.TF2
 */
IFX_INLINE boolean IfxScrT2ccu_hasTimer2OverflowOccured(IfxScrT2ccu module);

/** \brief Function to set timer2 over flow flag
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_setTimer2OverflowFlag(IfxScrT2ccu module);

/** \brief Function to clear timer2 over flow flag
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_clearTimer2OverflowFlag(IfxScrT2ccu module);

/** \brief Function to set external interrupt flag
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_setTimer2ExternalInterruptFlag(IfxScrT2ccu module);

/** \brief Function to clear external interrupt flag
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_clearTimer2ExternalInterruptFlag(IfxScrT2ccu module);

/** \brief Function to load timer 2 reload value
 * \param module T2CCU0 or T2CCU1
 * \param reloadValue reload value
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_loadTimer2ReloadValue(IfxScrT2ccu module, uint16 reloadValue);

/** \brief Function to get timer 2 capture value
 * \param module T2CCU0 or T2CCU1
 * \return Captured value
 */
IFX_INLINE uint16 IfxScrT2ccu_getTimer2CaptureValue(IfxScrT2ccu module);

/** \brief Function to read timer 2 value
 * \param module T2CCU0 or T2CCU1
 * \return Returns timer value
 */
IFX_INLINE uint16 IfxScrT2ccu_readTimer2Value(IfxScrT2ccu module);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_Cct
 * \{ */
/** \brief Function to start CCT timer
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_runCct(IfxScrT2ccu module);

/** \brief Function to halt CCT timer
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_haltCct(IfxScrT2ccu module);

/** \brief Function to set CCT overflow flag
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_setCctOverflowFlag(IfxScrT2ccu module);

/** \brief Function to clear CCT overflow flag
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_clearCctOverflowFlag(IfxScrT2ccu module);

/** \brief Function to trigger CCT overflow event
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_triggerCctOverflow(IfxScrT2ccu module);

/** \brief Function to load CCT initial count value
 * \param module T2CCU0 or T2CCU1
 * \param value  initial count value
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_loadCctCountValue(IfxScrT2ccu module, uint16 value);

/** \brief Function to get CCT count value
 * \param module T2CCU0 or T2CCU1
 * \return CCTH/CCTL value
 */
IFX_INLINE uint16 IfxScrT2ccu_getCctCountValue(IfxScrT2ccu module);

/** \brief Function to load CCT reload value
 * \param module T2CCU0 or T2CCU1
 * \param value reload value
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_loadCctReloadValue(IfxScrT2ccu module, uint16 value);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_CompareCapture
 * \{ */
/** \brief Function to trigger software shadow transfer
 * \param module T2CCU0 or T2CCU1
 * \param channelId Channel id
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_triggerShadowTransfer(IfxScrT2ccu module, IfxScrT2ccuChannel channelId);

/** \brief Function to set internal compare output register(T2CCU0_COSHDW.COOUTx)when a valid compare
 * match occurs for a channel in compare mode 1 or concurrent compare mode.
 * \param module T2CCU0 or T2CCU1
 * \param channelId Channel id
 * \param outputPolarity Compare output polarity
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_setCompareOutput(IfxScrT2ccu module, IfxScrT2ccuChannel channelId, boolean outputPolarity);

/** \brief Function to enable shadow transfer on timer overflow
 * \param module T2CCU0 or T2CCU1
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_enableTimerOverflow(IfxScrT2ccu module);

/** \brief Function to set compare value
 * \param module T2CCU0 or T2CCU1
 * \param channelId Channel id
 * \param value compare value
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_setCompareValue(IfxScrT2ccu module, IfxScrT2ccuChannel channelId, uint16 value);

/** \brief Function to enable compare operation for channel
 * \param module T2CCU0 or T2CCU1
 * \param channelId Channel id
 * \param mode Options: IfxScrT2ccuCompareCapture_disable
 *                      IfxScrT2ccuCompareCapture_captureEdge
 *                      IfxScrT2ccuCompareCapture_compareEnable
 *                      IfxScrT2ccuCompareCapture_captureSwWrite
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_enableCompareCaptureOperation(IfxScrT2ccu module, IfxScrT2ccuChannel channelId, uint8 mode);

/** \brief Function to trigger capture operation
 * \param module T2CCU0 or T2CCU1
 * \param channelId Channel id. (IfxScrT2ccuChannel_0 - IfxScrT2ccuChannel_3 to be used)
 * \return None
 */
IFX_INLINE void IfxScrT2ccu_triggerCapture(IfxScrT2ccu module, IfxScrT2ccuChannel channelId);

/** \brief Function to read capture value
 * \param module T2CCU0 or T2CCU1
 * \param channelId Channel id. (IfxScrT2ccuChannel_0 - IfxScrT2ccuChannel_3 to be used)
 * \return None
 */
IFX_INLINE uint16 IfxScrT2ccu_readCaptureValue(IfxScrT2ccu module, IfxScrT2ccuChannel channelId);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_Timer2_init
 * \{ */
/** \brief Function to initialize the configuration with default values
 * \param timer2Config Timer 2 configuration
 * \return None
 */
IFX_EXTERN void IfxScrT2ccu_initTimer2Config(IfxScrT2ccu_Timer2Config *timer2Config);

/** \brief Function to configure Timer 2 Instance 0 (T2CCU0)
 * \param module T2CCU instance 0/1
 * \param timer2Config Timer 2 configuration
 * \return None
 */
IFX_EXTERN void IfxScrT2ccu_configureTimer2(IfxScrT2ccu module, IfxScrT2ccu_Timer2Config *timer2Config);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_Cct_init
 * \{ */
/** \brief Function to initialize the CCT configuration with default values
 * \param cctConfig CCT configuration
 * \return None
 */
IFX_EXTERN void IfxScrT2ccu_initCctConfig(IfxScrT2ccu_CctConfig *cctConfig);

/** \brief Function to configure CCT
 * \param module T2CCU instance 0/1
 * \param cctConfig CCT configuration
 * \return None
 */
IFX_EXTERN void IfxScrT2ccu_configureCct(IfxScrT2ccu module, IfxScrT2ccu_CctConfig *cctConfig);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrT2ccu_Std_CaptureCompare_init
 * \{ */
/** \brief Function to initialize the capture compare configuration with default values
 * \param config Capture compare configuration
 * \return None
 */
IFX_EXTERN void IfxScrT2ccu_initCompareCaptureConfig(IfxScrT2ccu_CompareCaptureConfig *config);

/** \brief Function to configure compare
 *
 * Declare a global
 *    IfxScrT2ccu_CompareConfig channel0cmpConfig;
 * Note :
 *   Compare Mode 0 without dead time control:
 *   Set d
 *   Sequence of calling the API to get a proper compare operation already during the first timer period
 *     1. initConfig
 *     2. Select software trigger shadow transfer by making hwControl as FALSE
 *        channel0cmpConfig.deadtimeCfg = NULL_PTR;
 *        IfxScrT2ccu_configureCompareUnit(IfxScrT2ccu_0, &channel0cmpConfig);
 *     3. Clear enable shadow transfer T2CCU_COSHDW.ENSHDW to 0
 *        IfxScrT2ccu_enableTimerOverflow(IfxScrT2ccu_0);
 *     4. Enable selected base timer
 *        IfxScrT2ccu_runCct(IfxScrT2ccu_0) / IfxScrT2ccu_runTimer2(IfxScrT2ccu_0)
 *
 *   Compare Mode 0 with dead time control:
 *      Provide the dead time configuration and select the base timer as CCT or else the API will assert an error.
 *      Channel for other group will be selected inside the API based on the channel selected.
 *
 *   Compare Mode 1 :
 *    --> Set hwControl = TRUE for correct operation in compare mode 1
 *
 *    Concurrent Mode:
 *    --> Set channelId as IfxScrT2ccuChannel_0 and give the concurrent mode configuration.
 *    --> Set concurrentchannels (Specify channels for which the synchronous output signal to be generated.
 *         Other than IfxScrT2ccuChannel_0)
 *    --> Set concurrentModeOutput (Specify the compare output value for the channels other than IfxScrT2ccuChannel_0)
 *
 * \param module T2CCU instance 0/1
 * \param compConfig Compare configuration
 * \return None
 */
IFX_EXTERN void IfxScrT2ccu_configureCompareUnit(IfxScrT2ccu module, IfxScrT2ccu_CompareCaptureConfig *config);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Implementation-------------------------*/
/******************************************************************************/

/* -------------------------------------------T2Timer------------------------------------------ */

IFX_INLINE void IfxScrT2ccu_runTimer2(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU0_T2_CON.U |= (1u << IFX_SCR_T2CCU0_T2_CON_TR2_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU1_T2_CON.U |= (1u << IFX_SCR_T2CCU1_T2_CON_TR2_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_haltTimer2(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU0_T2_CON.U &= ~(1u << IFX_SCR_T2CCU0_T2_CON_TR2_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU1_T2_CON.U &= ~(1u << IFX_SCR_T2CCU1_T2_CON_TR2_OFF);
    }
}


/* T2CON.TF2*/
IFX_INLINE boolean IfxScrT2ccu_hasTimer2OverflowOccured(IfxScrT2ccu module)
{
    boolean status;

    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        status            = (boolean)((SCR_T2CCU0_T2_CON.U & (1u << IFX_SCR_T2CCU0_T2_CON_TF2_OFF)) >> IFX_SCR_T2CCU0_T2_CON_TF2_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        status            = (boolean)((SCR_T2CCU1_T2_CON.U & (1u << IFX_SCR_T2CCU1_T2_CON_TF2_OFF)) >> IFX_SCR_T2CCU1_T2_CON_TF2_OFF);
    }

    return status;
}


IFX_INLINE void IfxScrT2ccu_setTimer2OverflowFlag(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU0_T2_CON.U |= (1u << IFX_SCR_T2CCU0_T2_CON_TF2_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU1_T2_CON.U |= (1u << IFX_SCR_T2CCU1_T2_CON_TF2_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_clearTimer2OverflowFlag(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU0_T2_CON.U &= ~(1u << IFX_SCR_T2CCU0_T2_CON_TF2_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU1_T2_CON.U &= ~(1u << IFX_SCR_T2CCU1_T2_CON_TF2_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_setTimer2ExternalInterruptFlag(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU0_T2_CON.U |= (1u << IFX_SCR_T2CCU0_T2_CON_EXF2_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU1_T2_CON.U |= (1u << IFX_SCR_T2CCU1_T2_CON_EXF2_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_clearTimer2ExternalInterruptFlag(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU0_T2_CON.U &= ~(1u << IFX_SCR_T2CCU0_T2_CON_EXF2_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU1_T2_CON.U &= ~(1u << IFX_SCR_T2CCU1_T2_CON_EXF2_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_loadTimer2ReloadValue(IfxScrT2ccu module, uint16 reloadValue)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU0_T2_RC2H.U = (uint8)(reloadValue >> 8U);
        SCR_T2CCU0_T2_RC2L.U = (uint8)reloadValue;
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        SCR_T2CCU1_T2_RC2H.U = (uint8)(reloadValue >> 8U);
        SCR_T2CCU1_T2_RC2L.U = (uint8)reloadValue;
    }
}


IFX_INLINE uint16 IfxScrT2ccu_getTimer2CaptureValue(IfxScrT2ccu module)
{
    uint16 value;

    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
        value             = (uint16)((SCR_T2CCU0_T2_RC2H.U << 8u) | SCR_T2CCU0_T2_RC2L.U);
    }
    else
    {
        SCR_T2CCU1_PAGE.U = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
        value             = (uint16)((SCR_T2CCU1_T2_RC2H.U << 8u) | SCR_T2CCU1_T2_RC2L.U);
    }

    return value;
}

IFX_INLINE uint16 IfxScrT2ccu_readTimer2Value(IfxScrT2ccu module)
{
	uint16 tval = 0u;

	if (module == IfxScrT2ccu_0)
	{
		SCR_T2CCU0_PAGE.U = (SCR_T2CCU0_PAGE.U & (uint8)0xF8U);
		tval              = (uint16)((SCR_T2CCU0_T2_T2H.U << 8u) | SCR_T2CCU0_T2_T2L.U);
	}
	else
	{
		SCR_T2CCU1_PAGE.U = (SCR_T2CCU1_PAGE.U & (uint8)0xF8U);
		tval              = (uint16)((SCR_T2CCU1_T2_T2H.U << 8u) | SCR_T2CCU1_T2_T2L.U);
	}

	return tval;
}

/* -------------------------------------------CCT------------------------------------------ */

IFX_INLINE void IfxScrT2ccu_runCct(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU0_CCTCON.U |= (1u << IFX_SCR_T2CCU0_CCTCON_CCTST_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU1_CCTCON.U |= (1u << IFX_SCR_T2CCU1_CCTCON_CCTST_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_haltCct(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU0_CCTCON.U &= ~(1u << IFX_SCR_T2CCU0_CCTCON_CCTST_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU1_CCTCON.U &= ~(1u << IFX_SCR_T2CCU1_CCTCON_CCTST_OFF);
    }
}

IFX_INLINE void IfxScrT2ccu_setCctOverflowFlag(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU0_CCTCON.U |= (1u << IFX_SCR_T2CCU0_CCTCON_CCTOVF_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU1_CCTCON.U |= (1u << IFX_SCR_T2CCU1_CCTCON_CCTOVF_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_clearCctOverflowFlag(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU0_CCTCON.U &= ~(1u << IFX_SCR_T2CCU0_CCTCON_CCTOVF_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU1_CCTCON.U &= ~(1u << IFX_SCR_T2CCU1_CCTCON_CCTOVF_OFF);
    }
}

IFX_INLINE void IfxScrT2ccu_triggerCctOverflow(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U     = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU0_CCTBSEL.U |= (1u << IFX_SCR_T2CCU0_CCTBSEL_CCTTOV_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U     = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU1_CCTBSEL.U |= (1u << IFX_SCR_T2CCU0_CCTBSEL_CCTTOV_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_loadCctCountValue(IfxScrT2ccu module, uint16 value)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU0_CCTH.U = (uint8)(value >> 8);
        SCR_T2CCU0_CCTL.U = (uint8)value;
    }
    else
    {
        SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU1_CCTH.U = (uint8)(value >> 8);
        SCR_T2CCU1_CCTL.U = (uint8)value;
    }
}


IFX_INLINE uint16 IfxScrT2ccu_getCctCountValue(IfxScrT2ccu module)
{
    uint16 value;

    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        value             = (uint16)((SCR_T2CCU0_CCTH.U << 8u) | SCR_T2CCU0_CCTL.U);
    }
    else
    {
        SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        value             = (uint16)((SCR_T2CCU1_CCTH.U << 8u) | SCR_T2CCU1_CCTL.U);
    }

    return value;
}


IFX_INLINE void IfxScrT2ccu_loadCctReloadValue(IfxScrT2ccu module, uint16 value)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU0_CCTRELH.U = (uint8)(value >> 8);
        SCR_T2CCU0_CCTRELL.U = (uint8)value;
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
        SCR_T2CCU1_CCTRELH.U = (uint8)(value >> 8);
        SCR_T2CCU1_CCTRELL.U = (uint8)value;
    }
}


/*************************************Compare/Capture Unit**********************************************************/

IFX_INLINE void IfxScrT2ccu_triggerShadowTransfer(IfxScrT2ccu module, IfxScrT2ccuChannel channelId)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
        SCR_T2CCU0_COSHDW.U |= ((1u << IFX_SCR_T2CCU0_COSHDW_ENSHDW_OFF) | (1u << channelId));
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
        SCR_T2CCU1_COSHDW.U |= ((1u << IFX_SCR_T2CCU1_COSHDW_ENSHDW_OFF) | (1u << channelId));
    }
}


IFX_INLINE void IfxScrT2ccu_setCompareOutput(IfxScrT2ccu module, IfxScrT2ccuChannel channelId, boolean outputPolarity)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U   = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
        SCR_T2CCU0_COSHDW.U = ((SCR_T2CCU0_COSHDW.U & ~(1u << IFX_SCR_T2CCU0_COSHDW_ENSHDW_OFF)) | (outputPolarity << channelId));
    }
    else
    {
        SCR_T2CCU1_PAGE.U   = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
        SCR_T2CCU1_COSHDW.U = ((SCR_T2CCU1_COSHDW.U & ~(1u << IFX_SCR_T2CCU1_COSHDW_ENSHDW_OFF)) | (outputPolarity << channelId));
    }
}


IFX_INLINE void IfxScrT2ccu_enableTimerOverflow(IfxScrT2ccu module)
{
    if (module == IfxScrT2ccu_0)
    {
        SCR_T2CCU0_PAGE.U    = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
        SCR_T2CCU0_COSHDW.U |= (1u << IFX_SCR_T2CCU0_COSHDW_TXOV_OFF);
    }
    else
    {
        SCR_T2CCU1_PAGE.U    = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
        SCR_T2CCU1_COSHDW.U |= (1u << IFX_SCR_T2CCU1_COSHDW_TXOV_OFF);
    }
}


IFX_INLINE void IfxScrT2ccu_setCompareValue(IfxScrT2ccu module, IfxScrT2ccuChannel channelId, uint16 value)
{
    if (module == IfxScrT2ccu_0)
    {
        /* Set compare value to be reloaded*/
        if (channelId == IfxScrT2ccuChannel_0)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
            SCR_T2CCU0_CC0H.U = (uint8)(value >> 8u);
            SCR_T2CCU0_CC0L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_1)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
            SCR_T2CCU0_CC1H.U = (uint8)(value >> 8u);
            SCR_T2CCU0_CC1L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_2)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
            SCR_T2CCU0_CC2H.U = (uint8)(value >> 8u);
            SCR_T2CCU0_CC2L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU0_CC3H.U = (uint8)(value >> 8u);
            SCR_T2CCU0_CC3L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_4)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU0_CC4H.U = (uint8)(value >> 8u);
            SCR_T2CCU0_CC4L.U = (uint8)(value);
        }
        else
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU0_CC5H.U = (uint8)(value >> 8u);
            SCR_T2CCU0_CC5L.U = (uint8)(value);
        }
    }
    else
    {
        /* Set compare value to be reloaded*/
        if (channelId == IfxScrT2ccuChannel_0)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
            SCR_T2CCU1_CC0H.U = (uint8)(value >> 8u);
            SCR_T2CCU1_CC0L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_1)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
            SCR_T2CCU1_CC1H.U = (uint8)(value >> 8u);
            SCR_T2CCU1_CC1L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_2)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
            SCR_T2CCU1_CC2H.U = (uint8)(value >> 8u);
            SCR_T2CCU1_CC2L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU1_CC3H.U = (uint8)(value >> 8u);
            SCR_T2CCU1_CC3L.U = (uint8)(value);
        }
        else if (channelId == IfxScrT2ccuChannel_4)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU1_CC4H.U = (uint8)(value >> 8u);
            SCR_T2CCU1_CC4L.U = (uint8)(value);
        }
        else
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU1_CC5H.U = (uint8)(value >> 8u);
            SCR_T2CCU1_CC5L.U = (uint8)(value);
        }
    }
}


IFX_INLINE void IfxScrT2ccu_enableCompareCaptureOperation(IfxScrT2ccu module, IfxScrT2ccuChannel channelId, uint8 mode)
{
    if (module == IfxScrT2ccu_0)
    {
        if (channelId <= IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x01u);
            SCR_T2CCU0_CCEN.U = ((SCR_T2CCU0_CCEN.U & ~(3u << (channelId * 2))) | (mode << (channelId * 2)));
        }
        else if (channelId == IfxScrT2ccuChannel_4)
        {
            SCR_T2CCU0_PAGE.U   = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU0_COCON.U |= (1u << IFX_SCR_T2CCU0_COCON_CCM4_OFF);
        }
        else
        {
            SCR_T2CCU0_PAGE.U   = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU0_COCON.U |= (1u << IFX_SCR_T2CCU0_COCON_CCM5_OFF);
        }
    }
    else
    {
        if (channelId <= IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x01u);
            SCR_T2CCU1_CCEN.U = ((SCR_T2CCU1_CCEN.U & ~(3u << (channelId * 2))) | (mode << (channelId * 2)));
        }
        else if (channelId == IfxScrT2ccuChannel_4)
        {
            SCR_T2CCU1_PAGE.U   = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU1_COCON.U |= (1u << IFX_SCR_T2CCU1_COCON_CCM4_OFF);
        }
        else
        {
            SCR_T2CCU1_PAGE.U   = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x03u);
            SCR_T2CCU1_COCON.U |= (1u << IFX_SCR_T2CCU1_COCON_CCM5_OFF);
        }
    }
}


IFX_INLINE void IfxScrT2ccu_triggerCapture(IfxScrT2ccu module, IfxScrT2ccuChannel channelId)
{
    /* Random value is written in CCxl to trigger capture*/
    if (module == IfxScrT2ccu_0)
    {
        /*Page selection */
        if (channelId < IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
        }
        else
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x03u);
        }

        if (channelId == IfxScrT2ccuChannel_0)
        {
            SCR_T2CCU0_CC0L.U = 0x01;
        }
        else if (channelId == IfxScrT2ccuChannel_1)
        {
            SCR_T2CCU0_CC1L.U = 0x01;
        }
        else if (channelId == IfxScrT2ccuChannel_2)
        {
            SCR_T2CCU0_CC2L.U = 0x01;
        }
        else if (channelId == IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU0_CC3L.U = 0x01;
        }
        else
        {
            /* do nothing*/
        }
    }
    else
    {
        if (channelId < IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
        }
        else
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x03u);
        }

        if (channelId == IfxScrT2ccuChannel_0)
        {
            SCR_T2CCU1_CC0L.U = 0x01;
        }
        else if (channelId == IfxScrT2ccuChannel_1)
        {
            SCR_T2CCU1_CC1L.U = 0x01;
        }
        else if (channelId == IfxScrT2ccuChannel_2)
        {
            SCR_T2CCU1_CC2L.U = 0x01;
        }
        else if (channelId == IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU1_CC3L.U = 0x01;
        }
        else
        {
            /* do nothing*/
        }
    }
}


IFX_INLINE uint16 IfxScrT2ccu_readCaptureValue(IfxScrT2ccu module, IfxScrT2ccuChannel channelId)
{
    uint16 result = 0;

    if (module == IfxScrT2ccu_0)
    {
        if (channelId == IfxScrT2ccuChannel_0)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
            result            = (uint8)(SCR_T2CCU0_CC0H.U << 8u);
            result           |= (uint8)SCR_T2CCU0_CC0L.U;
        }
        else if (channelId == IfxScrT2ccuChannel_1)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
            result            = (uint8)(SCR_T2CCU0_CC1H.U << 8u);
            result           |= (uint8)SCR_T2CCU0_CC1L.U;
        }
        else if (channelId == IfxScrT2ccuChannel_2)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x02u);
            result            = (uint8)(SCR_T2CCU0_CC2H.U << 8u);
            result           |= (uint8)SCR_T2CCU0_CC2L.U;
        }
        else if (channelId == IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU0_PAGE.U = ((SCR_T2CCU0_PAGE.U & (uint8)0xF8U) | 0x03u);
            result            = (uint8)(SCR_T2CCU0_CC3H.U << 8u);
            result           |= (uint8)SCR_T2CCU0_CC3L.U;
        }
        else
        {
            /* do nothing*/
        }
    }
    else
    {
        if (channelId == IfxScrT2ccuChannel_0)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
            result            = (uint8)(SCR_T2CCU1_CC0H.U << 8u);
            result           |= (uint8)SCR_T2CCU1_CC0L.U;
        }
        else if (channelId == IfxScrT2ccuChannel_1)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
            result            = (uint8)(SCR_T2CCU1_CC1H.U << 8u);
            result           |= (uint8)SCR_T2CCU1_CC1L.U;
        }
        else if (channelId == IfxScrT2ccuChannel_2)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x02u);
            result            = (uint8)(SCR_T2CCU1_CC2H.U << 8u);
            result           |= (uint8)SCR_T2CCU1_CC2L.U;
        }
        else if (channelId == IfxScrT2ccuChannel_3)
        {
            SCR_T2CCU1_PAGE.U = ((SCR_T2CCU1_PAGE.U & (uint8)0xF8U) | 0x03u);
            result            = (uint8)(SCR_T2CCU1_CC3H.U << 8u);
            result           |= (uint8)SCR_T2CCU1_CC3L.U;
        }
        else
        {
            /* do nothing*/
        }
    }

    return result;
}


#endif /* IFXSCRT2CCU_H */
