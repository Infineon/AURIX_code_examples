/**********************************************************************************************************************
 * \file DSPR_TEST.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxMtu.h"
#include "IfxMtu_reg.h"
#include "IfxMtu_regdef.h"
#include "DSPR_TEST.h"

/*********************************************************************************************************************/
/*----------------------------------------------------- Macros ------------------------------------------------------*/
/*********************************************************************************************************************/
#define LED_PASS                        &MODULE_P00, 5                   /* LED for test success                     */
#define LED_FAIL                        &MODULE_P00, 6                   /* LED for test failure                     */

/* MTU MBIST Error flags */
#define MTU_CORRECTABLE_ERROR_FLAG      ((unsigned int)IFX_MTU_MC_ECCD_CERR_MSK << IFX_MTU_MC_ECCD_CERR_OFF)
#define MTU_UNCORRECTABLE_ERROR_FLAG    ((unsigned int)IFX_MTU_MC_ECCD_UCERR_MSK << IFX_MTU_MC_ECCD_UCERR_OFF)
#define MTU_ADDRESS_ERROR_FLAG          ((unsigned int)IFX_MTU_MC_ECCD_AERR_MSK << IFX_MTU_MC_ECCD_AERR_OFF)

#define MTU_CLEAR_FAULTSTS_OPERR0_MSK   0x3E                            /* Mask for clearing bit 0 of OPERR bitfield*/

#define Single_Bit_Error   0x01 
#define Double_Bit_Error   0x03  
/*********************************************************************************************************************/
/*--------------------------------------------------Global variables-------------------------------------------------*/
/*********************************************************************************************************************/
/* These global variable are not used during the MBIST and so can be located in DSPR*/
volatile uint32 g_errorInjection = TRUE;
volatile uint32 *mem_ptr = (uint32 *)0x70000050;
/* use 0x1 for single error injection and 0x3 for double error injection */
uint32 injected_error = Single_Bit_Error;

/*********************************************************************************************************************/
/*--------------------------------------------------Function Prototypes----------------------------------------------*/
/*********************************************************************************************************************/
static uint32 get_MTU_MBIST_Errors(IfxMtu_MbistSel mbistSel);
static void clear_MTU_MBIST_Errors(IfxMtu_MbistSel mbistSel);

/*********************************************************************************************************************/
/*------------------------------------------------Function Implementations-------------------------------------------*/
/*********************************************************************************************************************/
/* This function inject an error and tests CPU0 DSPR memory using MBIST, no context switch is allowed during the test */
void CPU0_DSPR_MTU_Test()
{
    uint16  password = 0;
    password = IfxScuWdt_getSafetyWatchdogPassword();
    /* Initialize the used LEDs */
    /* Setup Port Pin working mode to control the LEDs */
    IfxPort_setPinMode(LED_PASS, IfxPort_Mode_outputPushPullGeneral);
    IfxPort_setPinMode(LED_FAIL, IfxPort_Mode_outputPushPullGeneral);

    /* Turn off LEDs */
    IfxPort_setPinHigh(LED_PASS);
    IfxPort_setPinHigh(LED_FAIL);

    *mem_ptr=5;

    /* Enable MTU clock */
    IfxMtu_enableModule();

    /* Check if any error flag is set.
     * After any System Reset: For each and every SSH in the system, the UCE alarm status in the SMU, the ECCD.UCERR
     * (Consequently also SERR) and the FAULTSTS.OPERR[0] are set.
     */
    if(get_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr))
    {
        /* Clear the alarm status flags to enable a correct error tracking */
        clear_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr);
    }
    if(get_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr1))
    {
        /* Clear the alarm status flags to enable a correct error tracking */
        clear_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr1);
    }

    /* Error injection is selected */
    if(g_errorInjection == TRUE)
    {
        password = IfxScuWdt_getSafetyWatchdogPassword();
        if (IfxScuWdt_getSafetyWatchdogEndInit() == 1U)
        {
            /* Clear EndInit */
            IfxScuWdt_clearSafetyEndinit(password);
        }

        MTU_MC0_ECCS.B.ECCMAP = 1;
        __isync();
        MTU_MC34_ECCS.B.ECCMAP = 1;
        __isync();

        *mem_ptr=*mem_ptr ^ injected_error;
        __dsync();

        MTU_MC0_ECCS.B.ECCMAP = 0;
        __isync();
        MTU_MC34_ECCS.B.ECCMAP = 0;
        __isync();

        /*
         * Reading the address mem_ptr at this stage will trigger the ECC, uncomment for test purposes
         * In case a single error injected: The error will be corrected
         * In case a double error injected: The CPU will trap due to data integrity error (class 4, ID 6)
         * volatile uint32  VAR1=*mem_ptr;
         */

    }

    /* Run the Non-Destructive Test (NDT) on both MC0 and MC34 */

    /*Enable CPU0 DMEM SSH*/
    MTU_MEMTEST0.B.CPU0_DMEM_EN = 1;
    __isync();
    while( MTU_MEMSTAT0.B.CPU0_DMEM_AIU != 0)
    {}
    /*After this step everything in DSPR is unavailable (CSA, stack, heap, global variables...)*/

    /* Disable tracking of unnecessary errors*/
    MTU_MC0_ALMSRCS.B.MISCE =0U;
    MTU_MC0_ALMSRCS.B.OPENE =0U;

    /*Clear all the error bits*/
    MTU_MC0_ECCD.U  = 0x10;

    /*Config the NDT*/
    MTU_MC0_CONFIG0.U   = 0x4005;
    MTU_MC0_CONFIG1.U   = 0x5008;
    MTU_MC0_MCONTROL.U  = 0x4009;
    while(MTU_MC0_MSTATUS.B.DONE!=0){};

    MTU_MC0_MCONTROL.B.START  = 0;
    while(MTU_MC0_MSTATUS.B.DONE!=1){};

    /*Clear CPU0 DMEM SSH*/
    MTU_MEMTEST0.B.CPU0_DMEM_EN = 0;
    __isync();
    while( MTU_MEMSTAT0.B.CPU0_DMEM_AIU != 0)
    {}

    /*Enable CPU0 DMEM1 SSH*/
    MTU_MEMTEST1.B.CPU0_DMEM1_EN = 1;
    __isync();
    while( MTU_MEMSTAT1.B.CPU0_DMEM1_AIU != 0)
    {}

    /* Disable tracking of unnecessary errors*/
    MTU_MC34_ALMSRCS.B.MISCE =0U;
    MTU_MC34_ALMSRCS.B.OPENE =0U;

    /*Clear all the error bits*/
    MTU_MC34_ECCD.U = 0x10;

    /*Config the NDT*/
    MTU_MC34_CONFIG0.U   = 0x4005;
    MTU_MC34_CONFIG1.U   = 0x5008;
    MTU_MC34_MCONTROL.U  = 0x4009;
    while(MTU_MC34_MSTATUS.B.DONE!=0){};

    MTU_MC34_MCONTROL.B.START  = 0;
    while(MTU_MC34_MSTATUS.B.DONE!=1){};

    /*Disable CPU0 DMEM1 SSH*/
    MTU_MEMTEST1.B.CPU0_DMEM1_EN = 0;
    __isync();
    while( MTU_MEMSTAT1.B.CPU0_DMEM1_AIU != 0)
    {}
    /*After this step everything in DSPR is available again (CSA, stack, heap, global variables...)*/

    /*Restore the Endinit protection*/
    IfxScuWdt_setSafetyEndinit(password);

    /* Check the test result */
    /* The expected value of ECCD in case of correctable error is 0x23)*/
    if(((get_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr1)|get_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr)) & MTU_CORRECTABLE_ERROR_FLAG) != 0)
    {
        if(injected_error == Single_Bit_Error)
        {
            IfxPort_setPinLow(LED_PASS);
        }
        else
        {
            IfxPort_setPinLow(LED_FAIL);
        }
    }
    /* The expected value of ECCD in case of uncorrectable error is 0x25)*/
    else if(((get_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr1)|get_MTU_MBIST_Errors(IfxMtu_MbistSel_cpu0Dspr)) & MTU_UNCORRECTABLE_ERROR_FLAG) != 0)
    {
        if(injected_error == Double_Bit_Error)
        {
            IfxPort_setPinLow(LED_PASS);
        }
        else
        {
            IfxPort_setPinLow(LED_FAIL);
        }
    }
    else
    {
        /* Turn On FAIL LED: Error not detected */
        IfxPort_setPinLow(LED_FAIL);
    }
}

/* Get MBIST error flags of a specific memory */
static uint32 get_MTU_MBIST_Errors(IfxMtu_MbistSel mbistSel)
{
    Ifx_MTU_MC *mc = (Ifx_MTU_MC *)(IFXMTU_MC_ADDRESS_BASE + 0x100 * mbistSel);

    return (uint32)(mc->ECCD.U & (IFXMTU_ERROR_FLAGS_MASK));
}

/* Clear MCi_ECCD and MCi_FAULTSTS (i=0-95) error flags of a specific memory raised by a System Reset */
static void clear_MTU_MBIST_Errors(IfxMtu_MbistSel mbistSel)
{
    Ifx_MTU_MC *mc = &MODULE_MTU.MC[mbistSel];

    uint16  password = IfxScuWdt_getSafetyWatchdogPassword();
    uint8   isEndInitEnabled = 0;

    /* Check if the EndInit is already cleared:
     * if not, clear it to enable writes on MCi_FAULTST (i=0-95) register of a specific memory
     */
    if (IfxScuWdt_getSafetyWatchdogEndInit() == 1U)
    {
        /* Clear EndInit */
        IfxScuWdt_clearSafetyEndinit(password);
        isEndInitEnabled = 1;
    }

    mc->ECCD.B.SERR = 0;                                    /* Error Detected flag                          */
    mc->ECCD.B.UCERR = 0;                                   /* UnCorrectable Error (UCE) alarm flag         */
    mc->FAULTSTS.B.OPERR &= MTU_CLEAR_FAULTSTS_OPERR0_MSK;  /* SSH Critical Operation Error flags: clear
     * bit 0, set by any System Reset               */
    /* Restore the EndInit state */
    if (isEndInitEnabled == 1)
    {
        /* Set EndInit Watchdog (to prevent Watchdog Time Out) */
        IfxScuWdt_setSafetyEndinit(password);
    }

    IfxMtu_clearErrorTracking(mbistSel);                    /* Clear the error tracking registers (ETRR)    */
}
