/**********************************************************************************************************************
 * \file EDSADC.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxPort_reg.h"
#include "IfxConverter_reg.h"
#include "IfxStm.h"

#include "EVADC.h"

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* Variables to store the result */
extern volatile float32 g_resultVoltage[]; /* Array to store the calculated voltage values of queue */
extern volatile uint8 g_adc_event_flag;    /* Notification flag on the queue conversion completion */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
/* The following functions are implemented to maximize readability rather than performance */
static void init_CONVCTRL(void);

IFX_INTERRUPT(evadc_ch0_isr, 0, 0x1);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* This function initializes Convert Control module:
 * - Enable the CONVCTRL module
 * - Set up 40MHz clock
 */
static void init_CONVCTRL(void)
{
    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword ());
    CONVCTRL_CLC.U = 0x00000000;        /* Enable module CONVCTRL */
    IfxScuWdt_setCpuEndinit (IfxScuWdt_getCpuWatchdogPassword ());

    while(CONVCTRL_CLC.B.DISS == 0x1)   /* Wait until module clock is enabled   */
    {;}

    CONVCTRL_CCCTRL.U = 0xB0000000;     /* Unlock converter control registers   */
    CONVCTRL_PHSCFG.U = 0x00008003;     /* fADC=160MHz, fPHSYNC=160MHz/4=40MHz  */
    CONVCTRL_CCCTRL.U = 0x00000000;     /* Lock converter control registers     */
}
/* This function initializes the EVADC Group 0:
 * - Enable the module
 * - Set up internal clock to 40MHz
 * - Enable Normal operation mode
 * - Request calibration
 * - Set up Queue 2
 * - Set up external trigger GTM_trig_0
 * - Set up channel settings
 * */
void enable_EVADC_G0(void)
{
    init_CONVCTRL();        /* Enable CONVCTRL module*/

    IfxScuWdt_clearCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    EVADC_CLC.U = 0x0;      /* Enable clock for the EVADC module*/

    IfxScuWdt_setCpuEndinit(IfxScuWdt_getCpuWatchdogPassword());

    /* Wait until Module clock is enabled (DISS == 0) */
    while( EVADC_CLC.B.DISS == 0x1 );

    /* Setup Module clock
     * ANCFG - Analog Fct. Config. Register,
         * IPE[0]       - 0x0   --> Idle Precharge
         * BE[1]        - 0x0   --> Input Buffer
         * RPE[2]       - 0x0   --> Reference Precharge
         * RPC[3]       - 0x0   --> Reference Precharge Control
         * CALSTC[4:5]  - 0x0   --> Calibration Sample Time Control
         * DPCAL[6]     - 0x1   --> Disable Post-Calibration
         * ACSD[16:18]  - 0x00  --> Analog Clock Synchronization Delay
         * SSE[19]      - 0x0   --> Sample Synchronization
         * DIVA[20:24]  - 0x03  --> Divider Factor for the Analog Internal Clock (F_adci), 0x03 = 40MHz
         * DCMSB[25]    - 0x0   --> Double Clock for the MSB Conversion
     * */
    EVADC_G0ANCFG.B.IPE = 0;    /* Disable Idle Precharge */
    EVADC_G0ANCFG.B.BE  = 0;    /* Disable Input Buffer */
    EVADC_G0ANCFG.B.RPE = 0;    /* Reference Precharge */
    EVADC_G0ANCFG.B.DPCAL = 1;  /* Disable Post-Calibration */
    EVADC_G0ANCFG.B.DIVA = 0x3; /* Setup clock frequency fADC=160MHz/4=40MHz */

    EVADC_G0ANCFG.U = ( 0x1 << 6 ) | ( 0x3 << 20 );

    /* Enable Module Operation
    * GxARBCFG - Arbitration Config. Register
       * ANONC[0:1]     - 0x03 --> Analog Converter Control, 0x03 = Normal Operation
       * ANONs[16:17]   - rh --> Analog Converter Control Status
       * CHNR[20:24]    - rh --> Channel Number
       * SYNRUN[25]     - rh --> Synchronous Conversion Running
       * CAL[28]        - rh --> Start-Up Calibration Active Indication
       * BUSY[30]       - rh --> Converter Busy Flag
       * SAMPLE[31]     - rh --> Sample Phase Flag
    * */
    EVADC_G0ARBCFG.B.ANONC = 0x3;               /* Setup Normal Operation  */

    /* Wait at least 3us to settle analog part */
    for(int i=0; i < 30000; i++)
    {;}

    /* Request startup calibration
    * EVADC_GLOBCFG - Global Configuration Register
        * USC[12]       - 0x0   --> Unsynchronized Clock Generation
        * SUPLEV[13:14] - 0x00  --> Supply Voltage Level, Automatic control
        * CPWC[15]      - 0x1   --> Write Control
        * SUCAL[31]     - 0x1   --> Start-Up Calibration
    * */
    EVADC_GLOBCFG.U |= (1 << 15) | (1 << 31 ); /* Enable startup calibration */

    /* Wait until calibration is done */
    while(EVADC_G0ARBCFG.B.CAL == 0x1);

    /* Enable arbitration slot 2
    * GxARBPR - Arbitration Priority Register i, i=0-2
        * PRIOi[4*i+1:4*i]  - 0x03  --> Priority of Request Source i
        * CSMi[4*i+3]       - 0x0   --> Conversion Start Mode of Request Source i
        * ASENi[i+24]       - 0x1   --> Arbitration Source Input i Enable
    * */
    EVADC_G0ARBPR.B.ASEN2 = 0x1;    /* Enable Arbitration Slot  0 */


    /* Add Channel 0 to Group 0 Queue Source and enable External Trigger */
    /* GxQINRi (i=0-2) - Queue i Input Register, Group x
        * REQCHNR[0:4]  - 0x00  --> Request Channel Number
        * RF[5]         - 0x01  --> Refill
        * ENSI[6]       - 0x00  --> Enable Source Interrupt
        * EXTR[7]       - 0x01  --> External Trigger
        * PDD[9]        - 0x00  --> Pull-Down Diagnostics Enable
        * MDPD[10]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable
        * MDPU[11]      - 0x00  --> Multiplexer Diagnostics Pull-Devices Enable - MDPD,MDPU
        * CDEN[12]      - 0x00  --> Converter Diagnostics Enable
        * CDSEL[13:14]  - 0x00  --> Converter Diagnostics Pull-Devices Select
    * */
    EVADC_G0QINR2.U =   ( 0x0 << 0 ) |  /* Add Ch0 to the queue */
                        ( 0x1 << 5 ) |  /* Enable Refill */
                        ( 0x1 << 7 );  /* Enable External Trigger */


    EVADC_G0QINR2.U =   ( 0x1 << 0 ) |  /* Add Ch1 to the queue */
                        ( 0x1 << 5 );   /* Enable Refill */

    /* Configure Source Control Trigger & Gate
    * GxQCTRLi (i=0-2;x=0-11) - Queue i Source Contr. Register, Group x
        * SRCRESREG[0:3]    - 0x00  --> Source-specific Result Register
        * TRSEL[7:6]        - 0x00  --> Trigger Source Selection
        * XTSEL[8:11]       - 0x08  --> External Trigger Input Selection
        * XTLVL[12]         - 0x02  --> External Trigger Level
        * XTMODE[13:14]     - 0x00  --> Trigger Operating Mode
        * XTWC[15]          - 0x00  --> Control for Trigger Configuration
        * GTSEL[16:19]      - 0x00  --> Gate Input Selection
        * GTLVL[20]         - 0x00  --> Gate Input Level
        * GTWC[23]          - 0x00  --> Write Control for Gate Configuration
        * TMEN[28]          - 0x00  --> Timer Mode Enable
        * TMWC[31]          - 0x00  --> Write Control for Timer Mode
    * */
    EVADC_G0QCTRL2.U = ( 0x0 )      |    /* Use GxCHCTRy.RESREG to select result register for channels in group */
                      ( 0x8 << 8 )  |    /* Trigger on GTM_adcx_trig0 (see device appendix) */
                      ( 0x2 << 13 ) |    /* Trigger on rising edge*/
                      ( 0x1 << 15 ) |    /* Bitfields XTMODE, XTSEL, TRSEL can be written */
                      ( 0x0 << 16 ) |    /* Gate by GTM_adcx_trig0 */
                      ( 0x1 << 23 );     /* Bitfield GTSEL can be written */


    /* Enable Trigger & Gate for Request Source 2
    * GxQMRi (i=0-2;x=0-11) - Queue i Mode Register, Group x
        * ENGT[0:1]    - 0x01  --> Enable Gate
        * ENTR[2]      - 0x1   --> Enable External Trigger
        * CLRV[8]      - 0x0   --> Clear Valid Bit
        * TREV[9]      - 0x0   --> Trigger Event
        * FLUSH[10]    - 0x0   --> Flush Queue
        * CEV[11]      - 0x0   --> Clear Event Flag
        * PTDIS[16]    - 0x0   --> Repeat Disable
    * */
    EVADC_G0QMR2.B.ENGT = 0x1;  /* Enable Gate */
    EVADC_G0QMR2.B.ENTR = 0x1;  /* Enable External Trigger */


    /* Configure Channel Settings */

    /* Configure sample time of 6.45us = 16 x F_adci(40MHz), 2 + (STCS - 15) Ã— 16
    * GxICLASSi - Input Class Register i, (i=0-1)
        * STCS[0:4]     - 0x0F  --> Sample Time Control for Standard Conversions
        * AIPS[6:7]     - 0x00  --> Analog Input Precharge Control for Standard Conversions
        * CMS[8:9]      - 0x00  --> Conversion Mode for Standard Conversions
        * SESPS[10]     - 0x00  --> Spread Early Sample Point for Standard Conversions
        * STCE[16:20]   - 0x00  --> Sample Time Control for EMUX Conversions
        * AIPE[22:23]   - 0x00  --> Analog Input Precharge Control for EMUX Conversions
        * CME[24:25]    - 0x00  --> Conversion Mode for EMUX Conversions
        * SESPE[26]     - 0x00  --> Spread Early Sample Point for EMUX Conversions
    * */
    EVADC_G0ICLASS0.B.STCS  = 0x1F;

    /*
     * GxCHCTRy - Channel Control Register
        * ICLSEL [0:1]  - 0x00  --> Input Class Select
        * BNDSELL[4:5]  - 0x00  --> Lower Boundary Select
        * BNDSELU[6:7]  - 0x00  --> Upper Boundary Select
        * CHEVMODE[8:9] - 0x00  --> Channel Event Mode
        * SYNC[10]      - 0x00  --> Synchronization Request
        * REFSEL[11]    - 0x00  --> Reference Input Selection
        * BNDSELX[12:15]- 0x00  --> BoundaryExtensions
        * RESREG[16:19] - 0x00  --> Result Register
        * RESTGT[20]    - 0x00  --> Result Target
        * RESPOS[21]    - 0x00  --> Result Position
        * BWDCH[28:29]  - 0x00  --> Broken Wire Detection Channel
        * BWDEN[30]     - 0x00  --> Broken Wire Detection Enable
    * */
    EVADC_G0CHCTR0.B.RESREG = 0x0;  /* Store result from channel y to specified group result register */
    EVADC_G0CHCTR0.B.RESPOS = 0x0;  /* Store result right-aligned */

    EVADC_G0CHCTR1.B.RESREG = 0x1;  /* Store result from channel y to specified group result register */
    EVADC_G0CHCTR1.B.RESPOS = 0x0;  /* Store result right-aligned */

    /* Setup Data Reduction Mode
     * GxRCRy - Channel Control Register
       * DRCTR[16:19]   - 0x00  --> Data Reduction Control
       * DMM[20:21]     - 0x00  --> Data Modification Mode
       * WFR[24]        - 0x01  --> Wait-for-Read Mode Enable
       * FEN[25:26]     - 0x00  --> FIFO Mode Enable
       * SRGEN[31]      - 0x01  --> Service Request Generation Enable
    * */
    EVADC_G0RCR0.B.DRCTR = 0;   /* Data Reduction disabled */
    EVADC_G0RCR0.B.DMM = 0;     /* Standard data reduction */
    EVADC_G0RCR0.B.WFR = 1;     /* Wait-for-Read Mode enabled */
    EVADC_G0RCR0.B.FEN = 0;     /* FIFO Mode disabled */
    EVADC_G0RCR0.B.SRGEN = 1;   /* Enable Service Request Generation */


    EVADC_G0RCR1.B.DRCTR = 0;   /* Data Reduction disabled */
    EVADC_G0RCR1.B.DMM = 0;     /* Standard data reduction */
    EVADC_G0RCR1.B.WFR = 1;     /* Wait-for-Read Mode enabled */
    EVADC_G0RCR1.B.FEN = 0;     /* FIFO Mode disabled */
    EVADC_G0RCR1.B.SRGEN = 1;   /* Enable Service Request Generation */
}

/* Function to initialize the EVADC Group 0 diagnostics features
 * - Disable Arbiter
 * - Switch off the Analog part
 * - Flush the queue
 * - Configures ALIAS feature for Channel 0 and Channel 1
 * - Enable Test functions
 * - Configure Queue 2
 * - Switch on the analog part
 * - Enable Arbiter
 * */
void init_EVADC_G0_Diagnostics(void)
{
    /* Switch off analog converter */
    EVADC_G0ARBCFG.B.ANONC = 0x0;

    /* Disable arbiter slot 2 to prevent accepting requests from the request source - External Trigger*/
    EVADC_G0ARBPR.B.ASEN2 = 0x0;

    /* Disable Queue */
    EVADC_G0QMR2.B.ENGT = 0x0;      /* Disable Gate */
    EVADC_G0QMR2.B.CLRV = 0x1;      /* Invalidate pending queue entry */
    EVADC_G0QMR2.B.FLUSH = 0x1;     /* Flush Queue */

    /* Channel 0 - Converter diagnostics */
    /* ALIAS feature to avoid influence of the external circuit */
    EVADC_G0ALIAS.B.ALIAS0 = 24;

    /* Channel 1 - VDDK */
    EVADC_G0ALIAS.B.ALIAS1 = 29;

    /* Enable Test Functions */
    EVADC_GLOBTE.B.TFEP = 0x01; /* Test functions are activated for Group 0 */

    EVADC_G0QINR2.U =
                        ( 0x0 << 0 ) |  /* Add Ch0 to the queue */
                        ( 0x1 << 5 ) |  /* Enable Refill */
                        ( 0x1 << 7 ) |  /* Enable External Trigger */
                        ( 0x1 << 12 )|  /* Converter Diagnostics Enable */
                        ( CD_PULLUP_LEVEL << 13 );  /* Converter Diagnostics Pull-Devices Select */

    EVADC_G0QINR2.U =   ( 0x1 << 0 ) |  /* Add Ch1 to the queue */
                        ( 0x1 << 5 ) |  /* Enable Refill */
                        ( 0x0 << 7 );   /* Enable External Trigger */

    /* Switch on analog converter */
    EVADC_G0ARBCFG.B.ANONC = 0x3;

    /* Wait at least 3us to settle analog part */
    for(int i=0; i < 30000; i++)
    {;}

    EVADC_G0QMR2.B.ENGT = 0x1;  /* Enable Gate */
    EVADC_G0QMR2.B.ENTR = 0x1;  /* Enable External Trigger */

    EVADC_G0ARBPR.B.ASEN2 = 0x1;    /* Enable Arbitration Slot  2 */
}
/* Function to initialize the EVADC Group 0 diagnostics features
 * - Disable Arbiter
 * - Switch off the Analog part
 * - Flush the queue
 * - Disable ALIAS feature
 * - Disable Test Functions
 * - Configure Queue 2
 * - Switch on the analog part
 * - Enable Arbiter
 * */
void init_EVADC_G0_AnalogInput(void)
{
    /* Switch off analog converter */
    EVADC_G0ARBCFG.B.ANONC = 0x0;

    /* Disable arbiter slot 2 to prevent accepting requests from the request source - External Trigger*/
    EVADC_G0ARBPR.B.ASEN2 = 0x0;

    /* Disable Queue */
    EVADC_G0QMR2.B.ENGT = 0x0;      /* Disable Gate */
    EVADC_G0QMR2.B.CLRV = 0x1;      /* Invalidate pending queue entry */
    EVADC_G0QMR2.B.FLUSH = 0x1;     /* Flush Queue */

    /* Channel 0 - to analog input AN0 */
    EVADC_G0ALIAS.B.ALIAS0 = 0;

    /* Channel 1 - to analog input AN1 */
    EVADC_G0ALIAS.B.ALIAS1 = 1;

    /* Disable Test Functions */
    EVADC_GLOBTE.B.TFEP = 0x00; /* Test functions are deactivated for Group 0 */

    EVADC_G0QINR2.U =
                    ( 0x0 << 0 ) |  /* Add Ch0 to the queue */
                    ( 0x1 << 5 ) |  /* Enable Refill */
                    ( 0x1 << 7 );   /* Enable External Trigger */


    EVADC_G0QINR2.U =
                    ( 0x1 << 0 ) |  /* Add Ch1 to the queue */
                    ( 0x1 << 5 ) |  /* Enable Refill */
                    ( 0x0 << 7 );   /* Enable External Trigger */


    /* Switch on analog converter */
    EVADC_G0ARBCFG.B.ANONC = 0x3;

    /* Wait at least 3us to settle analog part */
    for(int i=0; i < 30000; i++)
    {;}

    EVADC_G0QMR2.B.ENGT = 0x1;  /* Enable Gate */
    EVADC_G0QMR2.B.ENTR = 0x1;  /* Enable External Trigger */

    EVADC_G0ARBPR.B.ASEN2 = 0x1;    /* Enable Arbitration Slot  2 */
}

/* This function implements EVADC service request handler:
 * - Read raw result from channel result register
 * - Convert raw result into voltage value
 * - Setup global result flag when results from both Channel 0 and Channel 1 are ready
 * - Toggle P00.1 pin
 */
IFX_INTERRUPT(evadc_ch0_isr, 0, 0x1)
{
    volatile uint16 resultEVADC_G0 = 0; /* Variable to store raw ADC value */

    /* Check valid result in G0RES0 */
    if( EVADC_G0RES0.B.VF == 1 )
    {
        resultEVADC_G0  = EVADC_G0RES0.B.RESULT;

        /* Convert result */
        g_resultVoltage[0] = ((float)resultEVADC_G0 * ANALOG_FULL_SCALE) / RAW_FULL_SCALE;

        /* Global result flag - 1 result is ready */
        g_adc_event_flag = 1;
    }

    /* Check valid result in G0RES1 */
    if( EVADC_G0RES1.B.VF == 1 )
    {
        resultEVADC_G0  = EVADC_G0RES1.B.RESULT;

        /* Convert result */
        g_resultVoltage[1] = ((float)resultEVADC_G0 * ANALOG_FULL_SCALE) / RAW_FULL_SCALE;

        /* Global result flag - 2 results are ready */
        g_adc_event_flag = 2;
    }

    /* Toggle pin for the debug purposes */
    IfxPort_togglePin( &MODULE_P00, 1 );
}
