/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "scr_io_sdcc.h"
#include "scr_irq_sdcc.h"
#include "scr_rtc_sdcc.h"
#include "scr_scu_sdcc.h"
#include "scr_sfr_sdcc.h"
#include "scr_wdt_sdcc.h"
#include "scr_common.h"
#include "../AppBsp_Conf.h"
#include "spi.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define WAIT_TC_STANDBY_MODE        TRUE

#define SPI_BUFFER_SIZE             (8u)
#define SPI_TRANSFER_SIZE           (1u)

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
__data volatile uint8 g_txBuffer[SPI_BUFFER_SIZE];
__data volatile uint8 g_rxBuffer[SPI_BUFFER_SIZE];
__data volatile uint8 g_bitMask;

/* Place flags which need fast access (like from ISR) in the bit-addressable internal data memory (16 bytes of RAM
 * that occupy addresses from 20h to 2Fh).
 */
__bit g_rtcTrigger; /* Set on RTC overflow event */
__bit g_runSpi;     /* Set on RTC overflow event if TC is in standby */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void rtcIsrHandler(void) __interrupt (XINTR13);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void main(void)
{
    /* Disable all generated resets */
    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    SCR_SCU_RSTCON = 0x0;

    /* Switch initially to HF mode (20 MHz) */
    Scr_set_fsys(DIV5);

    /* Initialize global flags to default values */
    g_rtcTrigger = FALSE;
    g_runSpi = FALSE;

#if USE_KIT_A2G_TC375_LITE
    /* Enable available pins
       P33.0 - P33.6, P33.9 - P33.13 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.1 to P01.5 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 );

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 (P33.4) as output, push-pull (external LED) */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (connect to button 1) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;

    /* Errata SCR_TC.021
     * - RTC not counting after reset if P33.10 is high.
     * - Device: TC37xEXT
     * - Marking/Step: (E)ES-AA)
     * 
     * Clear P01.2 (P33.10) to ensure a low level at the beginning, otherwise
     * it is possible that the RTC will not start.
     */
    SCR_SET_IO_PAGE(MOD_PAGE_0);
    SCR_IO_P01_OUT &= (~ScrIoPin2);
    /* Set P01.2 (P33.10) as output, push-pull */
    SCR_SET_IO_PAGE(MOD_PAGE_1);
    SCR_IO_P01_IOCR2 = ScrPortMode_outputPushPullGeneral;
    /* ~Errata SCR_TC.021 */
#endif /* USE_KIT_A2G_TC375_LITE */

#if USE_KIT_A2G_TC397_5V_TFT
    /* Enable available pins
       P33.0 - P33.6, P33.10 - P33.12 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.2 to P01.4 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin2 | ScrIoPin3 | ScrIoPin4);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 (P33.4) as output, push-pull (external LED) */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, pull up (external switch) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputPullUp;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_A2G_TC397_5V_TFT */

#if USE_KIT_TC397_TRB
    /* Enable available pins 
       P33.0 - P33.7, P34.1, P33.11 - P33.15 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);
    /* Enable P01.0, P01.3 to P01.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin0 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) to P00.7 (P33.7) out to 1 (LED off) */
    SCR_IO_P00_OUT = (ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 / P33.4 as output, push-pull (LED D302) */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P00.5 / P33.5 as output, push-pull (LED D303) */
    SCR_IO_P00_IOCR5 = ScrPortMode_outputPushPullGeneral;
    /* Set P00.6 / P33.6 as output, push-pull (LED D304) */
    SCR_IO_P00_IOCR6 = ScrPortMode_outputPushPullGeneral;
    /* Set P00.7 / P33.7 as output, push-pull (LED D305) */
    SCR_IO_P00_IOCR7 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (S202) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_TC397_TRB */

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    SCR_IO_P00_OMCR = ScrIoPin4;

#if WAIT_TC_STANDBY_MODE
    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    while(!Scr_is_in_standby()) /* Wait until TC enters standby mode */
    {}
#else
    while(SCR_IO_P01_IN & ScrIoPin3) /* Wait until button press */
    {}
#endif /* WAIT_TC_STANDBY_MODE */

    /*** Initialize interrupts ***/
    SCR_SET_SCU_PAGE(MOD_PAGE_1);
    /* Disable request: all except RTC, SSC and OCDS */
    SCR_SCU_PMCON1 = (LIN_DIS_MASK | WDT_DIS_MASK | WCAN_DIS_MASK | T2CCU_DIS_MASK);
    /* Clear all NMI service request flags. I.e. FNMIWKP */
    SCR_SCU_NMISR = 0x0;

    /* [0] EIREN - SSC Error Interrupt Enable
     * [1] TIREN - SSC Transmit Interrupt Enable
     * [2] RIREN - SSC Receive Interrupt Enable
     * [3] FEEN  - SSC Receive FIFO Empty Interrupt Enable
     * [4] FFEN  - SSC Receive FIFO Full Interrupt Enable
     */
    SCR_SCU_MODIEN = (SSC_RIREN | SSC_TIREN | SSC_EIREN);

    /* Reset all interrupts */
    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    SCR_SCU_IRCON0 = 0;
    SCR_SCU_IRCON1 = 0;
    SCR_SCU_IRCON2 = 0;

    /* Interrupt enable register 1:
     *  XINTR13 - interrupt node enable (RTC interrupt).
     *  XINTR7  - interrupt node enable (SSC/ADC interrupt).
     */
    SCR_IEN1 = 0x82;
    /* Interrupt enable register 0:
     *  EA - Global Interrupt Mask set.
     */
    SCR_IEN0_EA = 1;
    /*** ~Initialize interrupts ***/

    /*** Initialize SSC (SPI 8-bit) ***/
    {
        IfxScrSpi_Config spiMasterConfig = {
            .baudrate = IfxScrSpi_Baudrate_100kBaud,
            .sclkIo = IfxScrSpi_IoSel_A, /* P33.2 */
            .mosiIo = IfxScrSpi_IoSel_A, /* P33.0 */
            .misoIo = IfxScrSpi_IoSel_C, /* P33.1 */
            .csIo   = IfxScrSpi_IoSel_A, /* P33.3 */
        };
        Scr_spi_master_init(&spiMasterConfig);
    }
    /*** ~Initialize SSC (SPI 8-bit) ***/

    /*** Prepare Tx/Rx buffers ***/
    for(uint8 i = 0; i < SPI_BUFFER_SIZE; i++)
    {
        g_txBuffer[i] = 0xFF;
        g_rxBuffer[i] = 0;
    }
    /*** ~Prepare Tx/Rx buffers ***/

    /*** Initialize RTC ***/
    Scr_set_count_registers(0);
    /* RTC overflow setting */
    /* Counter setting for 0.2s@100MHz/DIV */
    SCR_RTC_CR3 = 0x00;
    SCR_RTC_CR2 = 0x3D;
    SCR_RTC_CR1 = 0x09;
    SCR_RTC_CR0 = 0x00;
    /* RTC interrupt enable, 9-bit prescaler is bypassed, RTC 100MHz/DIV -> 20MHz, RTC stopped */
    SCR_RTC_CON = (ECRTC_MASK | RTPBYP_MASK | RTCCLKSEL_MASK);
    /*** ~Initialize RTC ***/

    /* Start Real-Time Clock */
    Scr_start_rtc();

    /* Init bit mask for arbitrary data byte */
    g_bitMask = 0;

    while(1)
    {
        if(g_rtcTrigger)
        {
            g_rtcTrigger = FALSE;
            /* Toggle P00.4 (LED) */
            SCR_SET_IO_PAGE(MOD_PAGE_0);
            SCR_IO_P00_OMTR = ScrIoPin4;

            if(g_runSpi)
            {
                /* Reset bit mask */
                if(0 == g_bitMask)
                {
                    g_bitMask = 0x01;
                }

                /* Set next TX Byte */
                g_txBuffer[0] = (~g_bitMask);
                g_bitMask <<= 1;

                /* Start SPI transfer */
                Scr_spi_start_transfer(g_txBuffer, g_rxBuffer, SPI_TRANSFER_SIZE);
                while(Scr_spi_is_busy())
                {}
                /* Stop SPI transfer */
                Scr_spi_stop_transfer();

                g_runSpi = FALSE;

                /* TODO: check data read from slave */
            }
        }
    }
}

/* RTC Interrupt Service Routine (using SCR Interrupt Node 13)  */
void rtcIsrHandler(void) __interrupt (XINTR13)
{
    SCR_SET_SCU_PAGE_STNR1(MOD_PAGE_0); /* Store current SCU page and switch to page 0 */
    /* Clear compare match flag set by hardware */
    SCR_RTC_CON &= (~CFRTC_MASK);
    /* Set RTC trigger flag */
    g_rtcTrigger = TRUE;

    /* Check if TC is in standby */
    if(Scr_is_in_standby())
    {
        g_runSpi = TRUE;
    }
    SCR_RESTORE_SCU_PAGE_STNR1();   /* Restore previous SCU page */
}
