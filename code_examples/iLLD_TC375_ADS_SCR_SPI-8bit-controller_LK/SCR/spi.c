/**********************************************************************************************************************
 * \file spi.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "scr_io_sdcc.h"
#include "scr_scu_sdcc.h"
#include "scr_ssc_sdcc.h"
#include "spi.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
__data volatile IfxScrSpi_IoSel g_csIo;
__data volatile uint8 * g_pTxBuffer = 0; /* Pointer to transmit buffer, NULL if idle */
__data volatile uint8 * g_pRxBuffer = 0; /* Pointer to receive buffer, NULL if idle */
__data volatile uint8 g_transferSize = 0; /* Number of bytes to transmit/receive */
__data volatile uint8 g_txIndex = 0; /* Transmit buffer read index, reset on start of transfer */
__data volatile uint8 g_rxIndex = 0; /* Receive buffer write index, reset on start of transfer */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
SCR_INLINE void Scr_spi_select_slave(void);
SCR_INLINE void Scr_spi_deselect_slave(void);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

void Scr_spi_master_init(IfxScrSpi_Config * spiConfig)
{
    uint32 baudrate = spiConfig->baudrate;
    uint8 sclkIo = spiConfig->sclkIo;
    uint8 mosiIo = spiConfig->mosiIo;
    uint8 misoIo = spiConfig->misoIo;
    uint8 csIo = spiConfig->csIo;

    g_csIo = IfxScrSpi_Invalid;

    /* Configure chip select line (CS), Master OUT */
    if(IfxScrSpi_IoSel_A == csIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P00_OUT |= ScrIoPin3;
        /* Set P00.3 (P33.3) as output, push-pull (CS) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR3 = ScrPortMode_outputPushPullGeneral;
        g_csIo = csIo;
    }
    else if(IfxScrSpi_IoSel_B == csIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P00_OUT |= ScrIoPin4;
        /* Set P00.4 (P33.4) as output, push-pull (CS) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
        g_csIo = csIo;
    }
    else if(IfxScrSpi_IoSel_C == csIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P01_OUT |= ScrIoPin1;
        /* Set P01.1 (P33.9) as output, push-pull (CS) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P01_IOCR1 = ScrPortMode_outputPushPullGeneral;
        g_csIo = csIo;
    }
    else if(IfxScrSpi_IoSel_D == csIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P01_OUT |= ScrIoPin2;
        /* Set P01.2 (P33.10) as output, push-pull (CS) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P01_IOCR2 = ScrPortMode_outputPushPullGeneral;
        g_csIo = csIo;
    }

    /* Configure master transmit, slave receive line (MTSR/MOSI) */
    if(IfxScrSpi_IoSel_A == mosiIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P00_OUT |= ScrIoPin0;
        /* Set P00.0 (P33.0) as output, ALT2 (MTSR_O) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR0 = ScrPortMode_outputPushPullAlt2;
    }
    else if(IfxScrSpi_IoSel_B == mosiIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P00_OUT |= ScrIoPin6;
        /* Set P00.6 (P33.6) as output, ALT2 (MTSR_O) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR6 = ScrPortMode_outputPushPullAlt2;
    }
    else if(IfxScrSpi_IoSel_C == mosiIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P01_OUT |= ScrIoPin4;
        /* Set P01.4 (P33.12) as output, ALT3 (MTSR_O) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P01_IOCR5 = ScrPortMode_outputPushPullAlt3;
    }

    /* Configure master receive, slave transmit line (MRST/MISO) */
    if(IfxScrSpi_IoSel_A == misoIo)
    {
        /* Set P00.5 (P33.5) as input, pull up (MISO / MRST_I) 
         * Activate pull/up to ensure reading 1 if no slave is active */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR5 = ScrPortMode_inputPullUp;
        SCR_SET_SCU_PAGE(MOD_PAGE_2);
        /* [2:0] MIS - Master Mode Receive Input Select (A) */
        uint8 temp = (SCR_SCU_MODPISEL4 & 0xF8);
        SCR_SCU_MODPISEL4 = temp;
    }
    else if(IfxScrSpi_IoSel_B == misoIo)
    {
        /* Set P01.5 (P33.13) as input, pull up (MISO / MRST_I) 
         * Activate pull/up to ensure reading 1 if no slave is active */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P01_IOCR5 = ScrPortMode_inputPullUp;
        SCR_SET_SCU_PAGE(MOD_PAGE_2);
        /* [2:0] MIS - Master Mode Receive Input Select (B) */
        uint8 temp = (SCR_SCU_MODPISEL4 & 0xF8);
        temp |= 0x01;
        SCR_SCU_MODPISEL4 = temp;
    }
    else if(IfxScrSpi_IoSel_C == misoIo)
    {
        /* Set P00.1 (P33.1) as input, pull up (MISO / MRST_I) 
         * Activate pull/up to ensure reading 1 if no slave is active */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR1 = ScrPortMode_inputPullUp;
        SCR_SET_SCU_PAGE(MOD_PAGE_2);
        /* [2:0] MIS - Master Mode Receive Input Select (C) */
        uint8 temp = (SCR_SCU_MODPISEL4 & 0xF8);
        temp |= 0x02;
        SCR_SCU_MODPISEL4 = temp;
    }

    /* Configure clock line (SCLK), Master OUT */
    if(IfxScrSpi_IoSel_A == sclkIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P00_OUT |= ScrIoPin2;
        /* Set P00.2 (P33.2) as output, ALT2 (CLK / SCLK_O) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR2 = ScrPortMode_outputPushPullAlt2;
    }
    else if(IfxScrSpi_IoSel_B == sclkIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P00_OUT |= ScrIoPin7;
        /* Set P00.7 (P33.7) as output, ALT2 (CLK / SCLK_O) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P00_IOCR7 = ScrPortMode_outputPushPullAlt2;
    }
    else if(IfxScrSpi_IoSel_C == sclkIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P01_OUT |= ScrIoPin1;
        /* Set P01.1 (P33.9) as output, ALT2 (CLK / SCLK_O) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P01_IOCR1 = ScrPortMode_outputPushPullAlt2;
    }
    else if(IfxScrSpi_IoSel_D == sclkIo)
    {
        SCR_SET_IO_PAGE(MOD_PAGE_0);
        SCR_IO_P01_OUT |= ScrIoPin3;
        /* Set P01.3 (P33.11) as output, ALT2 (CLK / SCLK_O) */
        SCR_SET_IO_PAGE(MOD_PAGE_1);
        SCR_IO_P01_IOCR3 = ScrPortMode_outputPushPullAlt2;
    }

    /* Configure baudrate */
    SCR_SSC_BRL = (uint8)((baudrate >> 8) & 0x00FF);
    SCR_SSC_BRH = (uint8)(baudrate & 0x00FF);

    SCR_SSC_CONPL = 0x37; /* PO=0, PH=1, HB=1 (MSB first), 8 data bits */
    SCR_SSC_CONPH = (SSC_MS | SSC_TEN); /* SSC OFF, Master, enable receive error */

    /* Enable SSC */
    Scr_enable_ssc();
}

void Scr_spi_master_transfer(uint8 __data * pTxBuffer, uint8 __data * pRxBuffer, uint8 size)
{
    /* CS low */
    Scr_spi_select_slave();

    for(uint8 i = 0; i < size; i++)
    {
        /* write byte */
        SCR_SSC_TBL = pTxBuffer[i];
        /* all bit shifted? */
        while((SCR_SSC_CONOL & 0x0F) != 0);
        /* wait until idle */
        while((SCR_SSC_CONOH & 0x10));
        /* read byte */
        pRxBuffer[i] = SCR_SSC_RBL;
    }

    /* delay */
    for(uint8 j=0; j<14; j++)
    {}

    /* CS high */
    Scr_spi_deselect_slave();
}

boolean Scr_spi_start_transfer(uint8 __data * pTxBuffer, uint8 __data * pRxBuffer, uint8 size)
{
    /* Check if all internal data is reset and we are in idle state */
    if((0 != g_pTxBuffer) || (0 != g_pRxBuffer) || (0 != g_transferSize))
    {
        /* Signal not ready to start next transfer */
        return FALSE;
    }
    /* Store buffer pointers and number of bytes to transmit */
    g_pTxBuffer = pTxBuffer;
    g_pRxBuffer = pRxBuffer;
    g_transferSize = size;
    g_txIndex = 0;
    g_rxIndex = 0;

    /* CS low */
    Scr_spi_select_slave();
    /* Start transmission by writing first byte to TX register */
    SCR_SSC_TBL = g_pTxBuffer[g_txIndex];
    g_txIndex++;
    /* Signal successful start of transfer */
    return TRUE;
}

boolean Scr_spi_is_busy(void)
{
    if((0 != g_pTxBuffer) && (0 != g_pRxBuffer))
    {
        /* More bytes to transmit or receive */
        if((g_txIndex < g_transferSize) || (g_rxIndex < g_transferSize))
        {
            /* Signal SPI busy */
            return TRUE;
        }
        /* Everything transitted/received */
        if((g_txIndex == g_transferSize) && (g_rxIndex == g_transferSize))
        {
            /* Wait for last bit to shifted out */
            while(Scr_is_flag_set(SSC_BSY))
            {}
            /* Reset transfer data structures */
            g_pTxBuffer = 0;
            g_pRxBuffer = 0;
            g_transferSize = 0;
        }
        else
        {
            /* Signal SPI busy */
            return TRUE;
        }
    }
    /* Signal SPI idle */
    return FALSE;
}

void Scr_spi_stop_transfer(void)
{
    /* Add a short delay before deselecting slave */
    for(uint8 i=0; i<16; i++)
    {            
        for(uint8 j=0; j<200; j++)
        {}
    }
    /* CS high after transfer complete */
    Scr_spi_deselect_slave();
}

/* SSC Interrupt Service Routine (using SCR Interrupt Node 7) */
void sscIsrHandler(void) __interrupt (XINTR7)
{
    SCR_SET_SCU_PAGE_STNR2(MOD_PAGE_0); /* Store current SCU page and switch to page 0 */
    SCR_SET_IO_PAGE_STNR2(MOD_PAGE_0);  /* Store current IO page and switch to page 0 */

    if(SCR_SCU_IRCON1 & SSC_EIR)
    {
        SCR_SCU_IRCON1 &= (~SSC_EIR);

        if(Scr_is_flag_set(SSC_TE))
        {
            Scr_clear_flag(SSC_TE);
            /* TODO: handle transmit error */
        }

        if(Scr_is_flag_set(SSC_RE))
        {
            Scr_clear_flag(SSC_RE);
            /* TODO: handle receive error */
        }

        if(Scr_is_flag_set(SSC_BE))
        {
            Scr_clear_flag(SSC_BE);
            /* TODO: handle baudrate error */
        }
    }
    if(SCR_SCU_IRCON1 & SSC_TIR)
    {
        SCR_SCU_IRCON1 &= (~SSC_TIR);

        /* Check transmit buffer valid and more bytes to send */
        if((0 != g_pTxBuffer) && (g_txIndex < g_transferSize))
        {
            /* Write next byte to TX register */
            SCR_SSC_TBL = g_pTxBuffer[g_txIndex];
            g_txIndex++;
        }
    }
    if(SCR_SCU_IRCON1 & SSC_RIR)
    {
        SCR_SCU_IRCON1 &= (~SSC_RIR);

        /* Check receive buffer valid and more bytes to read */
        if((0 != g_pRxBuffer) && (g_rxIndex < g_transferSize))
        {
            /* Read byte from RX register */
            g_pRxBuffer[g_rxIndex] = SCR_SSC_RBL;
            g_rxIndex++;
        }
    }
    if(SCR_SCU_IRCON1 & SSC_RER)
    {
        SCR_SCU_IRCON1 &= (~SSC_RER);
        /* TODO: handle receive FIFO empty */
    }
    if(SCR_SCU_IRCON1 & SSC_RFR)
    {
        SCR_SCU_IRCON1 &= (~SSC_RFR);
        /* TODO: handle receive FIFO full */
    }

    SCR_RESTORE_IO_PAGE_STNR2();    /* Restore previous IO page */
    SCR_RESTORE_SCU_PAGE_STNR2();   /* Restore previous SCU page */
}

SCR_INLINE void Scr_spi_select_slave(void)
{
    SCR_SET_IO_PAGE(MOD_PAGE_0);
    switch(g_csIo)
    {
    case IfxScrSpi_IoSel_A:
        SCR_IO_P00_OMCR = ScrIoPin3;
        break;
    case IfxScrSpi_IoSel_B:
        SCR_IO_P00_OMCR = ScrIoPin4;
        break;
    case IfxScrSpi_IoSel_C:
        SCR_IO_P01_OMCR = ScrIoPin1;
        break;
    case IfxScrSpi_IoSel_D:
        SCR_IO_P01_OMCR = ScrIoPin2;
        break;
    default:
        break;
    }    
}

SCR_INLINE void Scr_spi_deselect_slave(void)
{
    SCR_SET_IO_PAGE(MOD_PAGE_0);
    switch(g_csIo)
    {
    case IfxScrSpi_IoSel_A:
        SCR_IO_P00_OMSR = ScrIoPin3;
        break;
    case IfxScrSpi_IoSel_B:
        SCR_IO_P00_OMSR = ScrIoPin4;
        break;
    case IfxScrSpi_IoSel_C:
        SCR_IO_P01_OMSR = ScrIoPin1;
        break;
    case IfxScrSpi_IoSel_D:
        SCR_IO_P01_OMSR = ScrIoPin2;
        break;
    default:
        break;
    }
}
