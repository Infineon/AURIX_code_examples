/**********************************************************************************************************************
 * \file CAN_Gateway_ISR.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include <CAN_Gateway_ISR.h>

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
McmcanType           g_mcmcan0;                       /* Global MCMCAN configuration and control structure    */
McmcanType           g_mcmcan1;                       /* Global MCMCAN configuration and control structure    */

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Interrupt Service Routine.
 * This macro:
 * - defines linker section as .intvec_tc<vector number>_<interrupt priority>.
 * - defines compiler specific attribute for the interrupt functions.
 * - defines the Interrupt service routine as ISR function.
 *
 * IFX_INTERRUPT(isr, vectabNum, priority)
 *  - isr: Name of the ISR function.
 *  - vectabNum: Vector table number.
 *  - priority: Interrupt priority. Refer Usage of Interrupt Macro for more details.
 */
IFX_INTERRUPT(can0IsrRxHandler, 0, ISR_PRIORITY_CAN0_RX);       /* RX message  Interrupt definition                   */

/* Interrupt Service Routine (ISR) called once the RX interrupt has been generated.
 * Compares the content of the received CAN message with the content of the transmitted CAN message
 * and in case of success, toggles an LED to indicate successful CAN message reception.
 */
void can0IsrRxHandler(void)
{
    Ifx_CAN_TXMSG * txBufferElement;
    uint8  i;

    IfxCan_TxBufferId bufferId = IfxCan_TxBufferId_0;

    /* Clear the "Message stored to RXFIF1 Buffer" interrupt flag */
    IfxCan_Node_clearInterruptFlag(g_mcmcan0.canSrcNode.node, IfxCan_Interrupt_rxFifo1NewMessage);

    while (IfxCan_Node_getRxFifo1FillLevel(g_mcmcan0.canSrcNode.node) !=0)
    {
        /* Read the received data from the RxFIFO1 and clear the new-data flag */
        g_mcmcan0.rxMsg.readFromRxFifo1 = TRUE;
        IfxCan_Can_readMessage(&g_mcmcan0.canSrcNode, &g_mcmcan0.rxMsg, (uint32*)&g_mcmcan0.rxData[0]);

        /* ==========================================================================================
         * prepare the routing Tx message from the received frame
         * ==========================================================================================
         */
        IfxCan_Can_initMessage(&g_mcmcan1.txMsg);

        /* get the FIFO PutIndex of the HW TxBuffer */
        bufferId=IfxCan_Node_getTxFifoQueuePutIndex(g_mcmcan1.canDstNode.node);

        /* copy information from RxMsg into TxMsg and initialize */
        g_mcmcan1.txMsg.bufferNumber=bufferId;  /* init. the SW TxMsg buffer number */

        g_mcmcan1.txMsg.dataLengthCode=g_mcmcan0.rxMsg.dataLengthCode; /* DLC */

        for (i = 0; i < IfxCan_Node_getDataLengthInBytes(g_mcmcan1.txMsg.dataLengthCode); i++)  /* data */
        {
            g_mcmcan1.txData[i] = g_mcmcan0.rxData[i];
        }

        g_mcmcan1.txMsg.frameMode=g_mcmcan0.rxMsg.frameMode; /* FrameMode */

        g_mcmcan1.txMsg.messageId = CAN1_GATEWAY_MESSAGE_ID; /* TxMsg ID */


        /* Write TxMsg information into the HW TxBuffer */
        /* get the HW TxBuffer address */
        txBufferElement = IfxCan_Node_getTxBufferElementAddress(g_mcmcan1.canDstNode.node, g_mcmcan1.canDstNode.messageRAM.baseAddress, g_mcmcan1.canDstNode.messageRAM.txBuffersStartAddress, bufferId);

        /* set the ID type */
        IfxCan_Node_setMsgId(txBufferElement, g_mcmcan1.txMsg.messageId, g_mcmcan1.txMsg.messageIdLength);

        /* set the DLC */
        IfxCan_Node_setDataLength(txBufferElement, g_mcmcan1.txMsg.dataLengthCode);

        /* set the data */
        IfxCan_Node_writeTxBufData(txBufferElement, g_mcmcan1.txMsg.dataLengthCode, g_mcmcan1.txData);

        /* copy the frame mode (FDF and BRS) */
         IfxCan_Node_setFrameModeReq(txBufferElement, g_mcmcan1.txMsg.frameMode);

        /*set transmit request */
         IfxCan_Node_setTxBufferAddRequest(g_mcmcan1.canDstNode.node, g_mcmcan1.txMsg.bufferNumber);
    }
}

/* Function to initialize MCMCAN module 0 and nodes related for this application use case */
void initMcmcan0(void)
{
    /* ==========================================================================================
     * CAN 0 module configuration and initialization:
     * ==========================================================================================
     *  - load default CAN module configuration into configuration structure
     *  - initialize CAN module with the default configuration
     *  - initialize CAN module RAM area
     * ==========================================================================================
     */
    IfxCan_Can_initModuleConfig(&g_mcmcan0.canConfig, &MODULE_CAN0);

    IfxCan_Can_initModule(&g_mcmcan0.canModule, &g_mcmcan0.canConfig);

    IfxCan_ramInit(&MODULE_CAN0);
    /* ==========================================================================================
     * Source CAN node configuration and initialization:
     * ==========================================================================================
     *  - load default CAN node configuration into configuration structure
     *  - assign source CAN node to CAN node 0
     *  - define the frame to be the transmit and receive (here as receive only node)
     *  - allocate the memory area (size and start address for each section) for receive process
     *  - configure the baud rate and the interrupt
     *  - configure pins to use header on Triboard
     *  - initialize the source CAN node with the modified configuration
     * ==========================================================================================
     */
    IfxCan_Can_initNodeConfig(&g_mcmcan0.canNodeConfig, &g_mcmcan0.canModule);

    g_mcmcan0.canNodeConfig.busLoopbackEnabled = FALSE;
    g_mcmcan0.canNodeConfig.nodeId = IfxCan_NodeId_0;
    g_mcmcan0.canNodeConfig.frame.type = IfxCan_FrameType_receive;

    g_mcmcan0.canNodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;
    g_mcmcan0.canNodeConfig.baudRate.baudrate      = SourceNodeBaud;
    g_mcmcan0.canNodeConfig.fastBaudRate.baudrate  = SourceNodeFastBaud;

    /* RAM allocation and message object configuration*/
    g_mcmcan0.canNodeConfig.messageRAM.baseAddress = (uint32)&MODULE_CAN0;
    g_mcmcan0.canNodeConfig.messageRAM.rxFifo1StartAddress = SourceNodeRxFIFO1AdrOffset;
    g_mcmcan0.canNodeConfig.messageRAM.standardFilterListStartAddress = SourceNodeStdIDAdrOffset;
    g_mcmcan0.canNodeConfig.rxConfig.rxMode = IfxCan_RxMode_fifo1;
    g_mcmcan0.canNodeConfig.rxConfig.rxFifo1DataFieldSize = IfxCan_DataFieldSize_64;
    g_mcmcan0.canNodeConfig.rxConfig.rxFifo1Size = SOURCE_RXFIFO1_SIZE;

    /* interrupt configuration */
    g_mcmcan0.canNodeConfig.interruptConfig.rxFifo1NewMessageEnabled = TRUE;
    g_mcmcan0.canNodeConfig.interruptConfig.rxf1n.priority = ISR_PRIORITY_CAN0_RX;
    g_mcmcan0.canNodeConfig.interruptConfig.rxf1n.interruptLine = IfxCan_InterruptLine_1;
    g_mcmcan0.canNodeConfig.interruptConfig.rxf1n.typeOfService = IfxSrc_Tos_cpu0;

    /* set up pins for CAN0 Node 0*/
    IfxCan_Can_Pins pinsCAN00;
    pinsCAN00.rxPin = &IfxCan_RXD00B_P20_7_IN;
    pinsCAN00.rxPinMode = IfxPort_InputMode_pullUp;
    pinsCAN00.txPin = &IfxCan_TXD00_P20_8_OUT;
    pinsCAN00.txPinMode = IfxPort_OutputMode_pushPull;
    pinsCAN00.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
    g_mcmcan0.canNodeConfig.pins = &pinsCAN00;

    /* re-initialize CAN node */
    IfxCan_Can_initNode(&g_mcmcan0.canSrcNode, &g_mcmcan0.canNodeConfig);

    /* ==========================================================================================
     * CAN filter configuration and initialization:
     * ==========================================================================================
     *  - filter configuration is stored under the filter element number 0
     *  - store received frame in a dedicated RX Buffer
     *  - define the same message ID as defined for the TX message
     *  - assign the filter to the RxFIFO1
     * ==========================================================================================
     */
    g_mcmcan0.canFilter.number = 0;
    g_mcmcan0.canFilter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxFifo1;
    g_mcmcan0.canFilter.id1 = CAN0_MESSAGE_ID;
    g_mcmcan0.canFilter.id2 = CAN0_MESSAGE_ID_MASK;
    g_mcmcan0.canFilter.type = IfxCan_FilterType_classic;

    IfxCan_Can_setStandardFilter(&g_mcmcan0.canSrcNode, &g_mcmcan0.canFilter);
}

/* Function to initialize MCMCAN module 1 and nodes related for this application use case */
void initMcmcan1(void)
{
    /* ==========================================================================================
     * CAN 0 module configuration and initialization:
     * ==========================================================================================
     *  - load default CAN module configuration into configuration structure
     *  - initialize CAN module with the default configuration
     *  - initialize CAN module RAM area
     * ==========================================================================================
     */
    IfxCan_Can_initModuleConfig(&g_mcmcan1.canConfig, &MODULE_CAN1);

    IfxCan_Can_initModule(&g_mcmcan1.canModule, &g_mcmcan1.canConfig);

    IfxCan_ramInit(&MODULE_CAN1);
    /* ==========================================================================================
     * Source CAN node configuration and initialization:
     * ==========================================================================================
     *  - load default CAN node configuration into configuration structure
     *  - assign source CAN node to CAN node 0
     *  - define the frame to be the transmit and receive (here transmit only, use TxFIFO)
     *  - allocate the memory area (size and start address for each section) for transmit process
     *  - configure the baud rate and the interrupt
     *  - configure pins to use header on Triboard
     *  - initialize the source CAN node with the modified configuration
     * ==========================================================================================
     */
    IfxCan_Can_initNodeConfig(&g_mcmcan1.canNodeConfig, &g_mcmcan1.canModule);

    g_mcmcan1.canNodeConfig.busLoopbackEnabled = FALSE;
    g_mcmcan1.canNodeConfig.nodeId = IfxCan_NodeId_0;
    g_mcmcan1.canNodeConfig.frame.type = IfxCan_FrameType_transmit;

    g_mcmcan1.canNodeConfig.frame.mode = IfxCan_FrameMode_fdLongAndFast;
    g_mcmcan1.canNodeConfig.baudRate.baudrate      = DestNodeBaud;
    g_mcmcan1.canNodeConfig.fastBaudRate.baudrate  = DestNodeFastBaud;

    /* RAM allocation and message object configuration*/
    g_mcmcan1.canNodeConfig.messageRAM.baseAddress = (uint32)&MODULE_CAN1;
    g_mcmcan1.canNodeConfig.messageRAM.txBuffersStartAddress =DestNodeTxBufferAdrOffset;
    g_mcmcan1.canNodeConfig.txConfig.txMode = IfxCan_TxMode_fifo;
    g_mcmcan1.canNodeConfig.txConfig.txBufferDataFieldSize=IfxCan_DataFieldSize_64;
    g_mcmcan1.canNodeConfig.txConfig.txFifoQueueSize = DESTINATION_TXFIFO_SIZE;

    /*set up pins for CAN1 node 0*/
    IfxCan_Can_Pins pinsCAN10;

    pinsCAN10.rxPin = &IfxCan_RXD10C_P23_0_IN; /* TC397TX board pins*/
    pinsCAN10.rxPinMode = IfxPort_InputMode_pullUp;
    pinsCAN10.txPin = &IfxCan_TXD10_P23_1_OUT; /* TC397TX board pins */
    pinsCAN10.txPinMode = IfxPort_OutputMode_pushPull;
    pinsCAN10.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
    g_mcmcan1.canNodeConfig.pins = &pinsCAN10;

    /* re-initialize CAN node */
    IfxCan_Can_initNode(&g_mcmcan1.canDstNode, &g_mcmcan1.canNodeConfig);
}

/* Function to initialize MCMCAN module RAM */
void IfxCan_ramInit(Ifx_CAN *can)
{
    Ifx_CAN_MCR mcr;

    /* enable CCCE and CI */
    mcr.U      = can->MCR.U;
    mcr.B.CCCE = 1;
    mcr.B.CI   = 1;
    can->MCR.U = mcr.U;

    while (can->MCR.B.RBUSY)
    {}

    can->MCR.B.RINIT = 0;       /*0 to 1 transition is needed*/
    can->MCR.B.RINIT = 1;       /*Clear RAM block*/
    uint32 mcr2 = can->MCR.U;   /*Dummy read required as per programming sequence*/

    IFX_UNUSED_PARAMETER(mcr2); /* Warning fix for LLVM Compiler */

    while (can->MCR.B.RBUSY)
    {}

    can->MCR.B.RINIT = 0;

    /* disable CCCE and CI */
    mcr.B.CCCE = 0;
    mcr.B.CI   = 0;
    can->MCR.U = mcr.U;
}
