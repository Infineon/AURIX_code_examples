/**
 * \file IfxPcie.h
 * \brief PCIE  basic functionality
 * \ingroup IfxLld_Pcie
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pcie_Architecture PCIe Driver Architecture
 * \ingroup IfxLld_Pcie
 *
 * <table>
 * <caption id="multi_row">PCIe Driver Architecture</caption>
 * <tr>
 *     <th colspan = "5">Pcie
 * <tr>
 *     <td rowspan="2"><b>Rc</b><BR>Pcie/Rc/IfxPcie_Rc.*
 *     <td rowspan = "2"><b>Ep</b><BR>Pcie/Ep/IfxPcie_Ep.*
 *     <td colspan = "3"><b>Lib</b><BR>
 * <tr>
 *     <td><b>Dma</b><BR>Pcie/Lib/Dma/IfxPcieLib_Dma.*
 *     <td><b>Device</b><BR>Pcie/Lib/Device/IfxPcieLib_Device.*
 *     <td><b>Cap</b><BR>Pcie/Lib/Cap/IfxPcieLib_Cap.*
 * <tr>
 *     <td colspan = "5"><b>Std</b><BR>Pcie/Std/IfxPcie*
 * </table>
 *
 * \section IfxLld_Pcie_Architecture_Desc File Description
 *
 * \subsection IfxLld_Pcie_Architecture_Desc_Rc Rc
 * Pcie/Rc/IfxPcie_Rc.*\n
 * These files contain APIs for configuring and initializing Aurix as RC
 *
 * \subsection IfxLld_Pcie_Architecture_Desc_Ep Ep
 * Pcie/Ep/IfxPcie_Ep.*\n
 * These files contain APIs for configuring and initializing Aurix as EP
 *
 * \subsection IfxLld_Pcie_Architecture_Desc_Lib Lib
 * This folder contains file libraries needed for both EP and RC
 *
 *     - Dma
 *       Pcie/Lib/Dma/IfxPcieLib_Dma.*
 *       These files contain APIs for configuring, initializing, and using PCIe DMA controller
 *
 *     - Device
 *       Pcie/Lib/Device/IfxPcieLib_Device.*
 *       These files contain APIs for using ATU and initializing SRC nodes.
 *
 *     - Cap
 *       Pcie/Lib/Cap/IfxPcieLib_Cap.*
 *       These files contain APIs for probing and configuring device capabilities
 *
 * \subsection IfxLld_Pcie_Architecture_Desc_Std Std
 * This folder contains standard layer files of PCIe
 *
 *     - Pcie/Std/IfxPcie.*
 *       These files contain low level APIs and data structures common to RC and EP mode
 *       Example: enabling link training, setting device mode, enabling/disabling module, etc.
 *
 *     - Pcie/Std/IfxPcieRc.*
 *       These files contain low level APIs and data structures used in RC mode
 *       Example: setting number of lanes, writing msi address, enabling interrupts, etc.
 *
 *     - Pcie/Std/IfxPcieEp.*
 *       These files contain low level APIs and data structures used in EP mode
 *       Example: setting bar mask, enabling local loopback, checking link state, etc.
 *
 *     - Pcie/Std/IfxPcieDma.*
 *       These files contain low level APIs and data structures for using DMA
 *       Data Structure Examples: Channel enum list, data element and link structures
 *       API Examples: enabling/disabling/starting dma channels
 *
 *     - Pcie/Std/IfxPcieCap.*
 *       These files contain APIs for accessing capability registers
 *
 *     - Pcie/Std/IfxPcieDevice.*
 *       These files contain data structures such as config headers and APIs for setting device id, enabing bus master, etc
 *
 * \defgroup IfxLld_Pcie_Std_Enumerations Enumerations
 * \ingroup IfxLld_Pcie_Std
 * \defgroup IfxLld_Pcie_Std_Structures Structures
 * \ingroup IfxLld_Pcie_Std
 * \defgroup IfxLld_Pcie_Std_Functions Functions
 * \ingroup IfxLld_Pcie_Std
 */

#ifndef IFXPCIE_H
#define IFXPCIE_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxPcie_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "Src/Std/IfxSrc.h"
#include "Hsphy/Std/IfxHsphy.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Interrupt Request Trigger Offset
 */
#define IFXPCIE_INTREQTRIG_BAR0_WORD_OFFSET   ((uint32)(0x0u))

/** \brief Interrupt Request Trigger Status
 */
#define IFXPCIE_INTREQSTATUS_BAR0_WORD_OFFSET ((uint32)(0x1u))

/** \brief PCI Capability list offset for Bridges, EP and RC
 */
#define IFXPCIE_PCI_CAPABILITY_LIST_OFFSET    (0x34)

/** \brief Get word size from size in bytes
 */
#define IFXPCIE_GET_WORDSIZE(x)                               (uint32)(x >> 2u)

/** \brief Get BAR mem size from BAR registers
 */
#define IFXPCIE_GET_BAR_MEMSIZE(x)                            (uint64)(x >> 4u)

/** \brief Get new wire memory from BAR memory size
 */
#define IFXPCIE_GET_WIREADDR_FROMBAR(wireMemBase, barMemSize) (((uint64)(wireMemBase % barMemSize) == 0u) ? wireMemBase : (((uint64)wireMemBase / barMemSize) + 1u) * barMemSize)

/** \brief Get number of MSI interrupts from enum
 */
#define IFXPCIE_GET_NUM_MSI_INTERRUPTS(msiInt)                ((uint16)(0x1u << (uint16)msiInt))

/** \brief Get the next 1 MB boundary
 */
#define IFXPCIE_GET_NEXT_1MB_BOUNDARY(x)                      ((((x) & 0x000FFFFFu) == 0u) ? (x) : (((x) + 0x100000u) & 0xFFF00000u))

/** \brief Get the next 4KB boundary
 */
#define IFXPCIE_GET_NEXT_4KB_BOUNDARY(x)                      ((((x) & 0x00000FFFu) == 0u) ? (x) : (((x) + 0x1000u) & 0xFFFFF000u))

/** \brief Get PHY Index for selected PCIE module index
 * TC49x: PCIE0 is connected to PHY0
 * TC4Dx: PCIE0 is connected to PHY0 and PCIE1 is connected to PHY2
 */
#define IFXPCIE_GET_PHY_INDEX(pcieIndex)                      ((IfxHsphy_PhyIndex)((IfxPcie_Index)(pcieIndex) == IfxPcie_Index_1) ? IfxHsphy_PhyIndex_2 : IfxHsphy_PhyIndex_0)

/** \brief In TC49x, CFG Write is posted and CFG Read is non-posted. Sometimes, the Read can overtake writes.
 * Hence, we need to wait for write to complete to avoid reading old values from same register.
 */
#define IFXPCIE_CONFIGWRITE_DELAY(loopCount)       \
    {                                              \
        volatile uint32 idx;                       \
        for (idx = 0; idx < loopCount; idx++) {; } \
    }                                              \


/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Call back for PCIE Interrupts
 */
typedef void (*IfxPcie_IntrCallBack)();

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Std_Enumerations
 * \{ */
/** \brief Address Width
 */
typedef enum
{
    IfxPcie_AddressWidth_32 = 0,  /**< \brief Bar width 32 bit */
    IfxPcie_AddressWidth_64 = 2   /**< \brief Bar width 64bit */
} IfxPcie_AddressWidth;

/** \brief ATU Region Direction
 */
typedef enum
{
    IfxPcie_AtuDirection_inBound,  /**< \brief Inbound ATU Region */
    IfxPcie_AtuDirection_outBound  /**< \brief Outbound ATU Region */
} IfxPcie_AtuDirection;

/** \brief ATU Region Lock Status
 */
typedef enum
{
    IfxPcie_AtuLock_unlocked = 0xAA,  /**< \brief ATU Region is unlocked */
    IfxPcie_AtuLock_locked   = 0x55   /**< \brief ATU Region is locked */
} IfxPcie_AtuLock;

/** \brief ATU outbound region (TODO: LEGACY - remove)
 */
typedef enum
{
    IfxPcie_AtuOutBoundRegion_none = -1,  /**< \brief no ATU outbound */
    IfxPcie_AtuOutBoundRegion_0,          /**< \brief iATU Region 0 */
    IfxPcie_AtuOutBoundRegion_1,          /**< \brief iATU Region 1 */
    IfxPcie_AtuOutBoundRegion_2,          /**< \brief iATU Region 2 */
    IfxPcie_AtuOutBoundRegion_3,          /**< \brief iATU Region 3 */
    IfxPcie_AtuOutBoundRegion_4,          /**< \brief iATU Region 4 */
    IfxPcie_AtuOutBoundRegion_5,          /**< \brief iATU Region 5 */
    IfxPcie_AtuOutBoundRegion_6,          /**< \brief iATU Region 6 */
    IfxPcie_AtuOutBoundRegion_7           /**< \brief iATU Region 7 */
} IfxPcie_AtuOutBoundRegion;

/** \brief ATU Region
 */
typedef enum
{
    IfxPcie_AtuRegion_none = -1,  /**< \brief no ATU Region */
    IfxPcie_AtuRegion_0,          /**< \brief iATU Region 0 */
    IfxPcie_AtuRegion_1,          /**< \brief iATU Region 1 */
    IfxPcie_AtuRegion_2,          /**< \brief iATU Region 2 */
    IfxPcie_AtuRegion_3,          /**< \brief iATU Region 3 */
    IfxPcie_AtuRegion_4,          /**< \brief iATU Region 4 */
    IfxPcie_AtuRegion_5,          /**< \brief iATU Region 5 */
    IfxPcie_AtuRegion_6,          /**< \brief iATU Region 6 */
    IfxPcie_AtuRegion_7,          /**< \brief iATU Region 7 */
    IfxPcie_AtuRegion_max         /**< \brief MAX ATU Region */
} IfxPcie_AtuRegion;

/** \brief BAR number
 */
typedef enum
{
    IfxPcie_BarNum_0 = 0,  /**< \brief BAR number0 */
    IfxPcie_BarNum_1,      /**< \brief BAR number1 */
    IfxPcie_BarNum_2,      /**< \brief BAR number2 */
    IfxPcie_BarNum_3,      /**< \brief BAR number3 */
    IfxPcie_BarNum_4,      /**< \brief BAR number4 */
    IfxPcie_BarNum_5       /**< \brief BAR number5 */
} IfxPcie_BarNum;

/** \brief Device ID
 */
typedef enum
{
    IfxPcie_DeviceId_0,     /**< \brief PCIE device 0 */
    IfxPcie_DeviceId_1,     /**< \brief PCIE device 1 */
    IfxPcie_DeviceId_2,     /**< \brief PCIE device 2 */
    IfxPcie_DeviceId_3,     /**< \brief PCIE device 3 */
    IfxPcie_DeviceId_4,     /**< \brief PCIE device 4 */
    IfxPcie_DeviceId_5,     /**< \brief PCIE device 5 */
    IfxPcie_DeviceId_6,     /**< \brief PCIE device 6 */
    IfxPcie_DeviceId_7,     /**< \brief PCIE device 7 */
    IfxPcie_DeviceId_8,     /**< \brief PCIE device 8 */
    IfxPcie_DeviceId_9,     /**< \brief PCIE device 9 */
    IfxPcie_DeviceId_10,    /**< \brief PCIE device 10 */
    IfxPcie_DeviceId_11,    /**< \brief PCIE device 11 */
    IfxPcie_DeviceId_12,    /**< \brief PCIE device 12 */
    IfxPcie_DeviceId_13,    /**< \brief PCIE device 13 */
    IfxPcie_DeviceId_14,    /**< \brief PCIE device 14 */
    IfxPcie_DeviceId_15,    /**< \brief PCIE device 15 */
    IfxPcie_DeviceId_16,    /**< \brief PCIE device 16 */
    IfxPcie_DeviceId_17,    /**< \brief PCIE device 17 */
    IfxPcie_DeviceId_18,    /**< \brief PCIE device 18 */
    IfxPcie_DeviceId_19,    /**< \brief PCIE device 19 */
    IfxPcie_DeviceId_20,    /**< \brief PCIE device 20 */
    IfxPcie_DeviceId_21,    /**< \brief PCIE device 21 */
    IfxPcie_DeviceId_22,    /**< \brief PCIE device 22 */
    IfxPcie_DeviceId_23,    /**< \brief PCIE device 23 */
    IfxPcie_DeviceId_24,    /**< \brief PCIE device 24 */
    IfxPcie_DeviceId_25,    /**< \brief PCIE device 25 */
    IfxPcie_DeviceId_26,    /**< \brief PCIE device 26 */
    IfxPcie_DeviceId_27,    /**< \brief PCIE device 27 */
    IfxPcie_DeviceId_28,    /**< \brief PCIE device 28 */
    IfxPcie_DeviceId_29,    /**< \brief PCIE device 29 */
    IfxPcie_DeviceId_30,    /**< \brief PCIE device 30 */
    IfxPcie_DeviceId_31,    /**< \brief PCIE device 31 */
    IfxPcie_DeviceId_Count  /**< \brief Max Number of PCIE devices per Bus */
} IfxPcie_DeviceId;

/** \brief Device mode indicating if it is EP or RC
 */
typedef enum
{
    IfxPcie_DeviceMode_unknown  = -1, /**< \brief Unknown device */
    IfxPcie_DeviceMode_ep       = 0,  /**< \brief EP device */
    IfxPcie_DeviceMode_legacyEp = 1,  /**< \brief Legacy EP type */
    IfxPcie_DeviceMode_rc       = 4   /**< \brief Root complex device */
} IfxPcie_DeviceMode;

/** \brief Device Type
 */
typedef enum
{
    IfxPcie_DeviceType_ep,     /**< \brief End Point */
    IfxPcie_DeviceType_bridge  /**< \brief Bridge */
} IfxPcie_DeviceType;

/** \brief Error Events
 */
typedef enum
{
    IfxPcie_ErrorEvent_none = -1,  /**< \brief No PME event */
    IfxPcie_ErrorEvent_corr,       /**< \brief Correctable Error Message */
    IfxPcie_ErrorEvent_nonFatal,   /**< \brief non Fatal error message */
    IfxPcie_ErrorEvent_fatal,      /**< \brief fatal error message */
    IfxPcie_ErrorEvent_count       /**< \brief Count of PME Events */
} IfxPcie_ErrorEvent;

/** \brief Function ID
 */
typedef enum
{
    IfxPcie_FunctionId_0,     /**< \brief PCIE device 0 */
    IfxPcie_FunctionId_1,     /**< \brief PCIE device 1 */
    IfxPcie_FunctionId_2,     /**< \brief PCIE device 2 */
    IfxPcie_FunctionId_3,     /**< \brief PCIE device 3 */
    IfxPcie_FunctionId_4,     /**< \brief PCIE device 4 */
    IfxPcie_FunctionId_5,     /**< \brief PCIE device 5 */
    IfxPcie_FunctionId_6,     /**< \brief PCIE device 6 */
    IfxPcie_FunctionId_7,     /**< \brief PCIE device 7 */
    IfxPcie_FunctionId_Count  /**< \brief Max number of PCIE functions per device */
} IfxPcie_FunctionId;

/** \brief Interrupt Vectors
 */
typedef enum
{
    IfxPcie_IntVector_none = -1,       /**< \brief no Interrupt Vector */
    IfxPcie_IntVector_remote0Msi,      /**< \brief Remote Interrupt 0 : MSI, MSIX */
    IfxPcie_IntVector_remote1Msi,      /**< \brief Remote Interrupt 1 : MSI, MSIX */
    IfxPcie_IntVector_remote2Msi,      /**< \brief Remote Interrupt 2 : MSI, MSIX */
    IfxPcie_IntVector_remote3Msi,      /**< \brief Remote Interrupt 3 : MSI, MSIX */
    IfxPcie_IntVector_remote4MsiIntA,  /**< \brief Remote Interrupt 4 : MSI, MSIX, INTA */
    IfxPcie_IntVector_remote5MsiIntB,  /**< \brief Remote Interrupt 5 : MSI, MSIX, INTB */
    IfxPcie_IntVector_remote6MsiIntC,  /**< \brief Remote Interrupt 6 : MSI, MSIX, INTC */
    IfxPcie_IntVector_remote7MsiIntD,  /**< \brief Remote Interrupt 7 : MSI, MSIX, INTD */
    IfxPcie_IntVector_dmaWrInt0,       /**< \brief DMA Interrupt 0 */
    IfxPcie_IntVector_dmaWrInt1,       /**< \brief DMA Interrupt 1 */
    IfxPcie_IntVector_dmaWrInt2,       /**< \brief DMA Interrupt 2 */
    IfxPcie_IntVector_dmaWrInt3,       /**< \brief DMA Interrupt 3 */
    IfxPcie_IntVector_dmaRdInt0,       /**< \brief DMA Interrupt 4 */
    IfxPcie_IntVector_dmaRdInt1,       /**< \brief DMA Interrupt 5 */
    IfxPcie_IntVector_dmaRdInt2,       /**< \brief DMA Interrupt 6 */
    IfxPcie_IntVector_dmaRdInt3,       /**< \brief DMA Interrupt 7 */
    IfxPcie_IntVector_genError,        /**< \brief General Error Interrupt */
    IfxPcie_IntVector_aerError,        /**< \brief AER Error Interrupt */
    IfxPcie_IntVector_pmRequest,       /**< \brief Power Management Interrupt */
    IfxPcie_IntVector_link,            /**< \brief Link State Management */
    IfxPcie_IntVector_message,         /**< \brief Message Interrupt */
    IfxPcie_IntVector_misc,            /**< \brief Miscellaneous Interrupt */
    IfxPcie_IntVector_count            /**< \brief MAX number of interrupt Vectors */
} IfxPcie_IntVector;

/** \brief Interrupt Type
 */
typedef enum
{
    IfxPcie_InterruptType_none,    /**< \brief no interrupts */
    IfxPcie_InterruptType_legacy,  /**< \brief legacy INTX messages */
    IfxPcie_InterruptType_msi,     /**< \brief MSI Interrupt */
    IfxPcie_InterruptType_msix     /**< \brief MSIX Interrupt */
} IfxPcie_InterruptType;

/** \brief List of LTSSM states
 */
typedef enum
{
    IfxPcie_LtssmState_detectQuiet,      /**< \brief detectQuiet */
    IfxPcie_LtssmState_detectAct,        /**< \brief detectAct */
    IfxPcie_LtssmState_pollActive,       /**< \brief pollActive */
    IfxPcie_LtssmState_pollCompliance,   /**< \brief pollCompliance */
    IfxPcie_LtssmState_pollConfig,       /**< \brief pollConfig */
    IfxPcie_LtssmState_preDetectQuiet,   /**< \brief preDetectQuiet */
    IfxPcie_LtssmState_detectWait,       /**< \brief detectWait */
    IfxPcie_LtssmState_cfgLinkwdStart,   /**< \brief cfgLinkwdStart */
    IfxPcie_LtssmState_cfgLinkwdAcept,   /**< \brief cfgLinkwdAcept */
    IfxPcie_LtssmState_cfgLanenumWai,    /**< \brief cfgLanenumWai */
    IfxPcie_LtssmState_cfgLanenumAcept,  /**< \brief cfgLanenumAcept */
    IfxPcie_LtssmState_cfgComplete,      /**< \brief cfgComplete */
    IfxPcie_LtssmState_cfgIdle,          /**< \brief cfgIdle */
    IfxPcie_LtssmState_rcvryLock,        /**< \brief rcvryLock */
    IfxPcie_LtssmState_rcvrySpeed,       /**< \brief rcvrySpeed */
    IfxPcie_LtssmState_rcvryRcvrcfg,     /**< \brief rcvryRcvrcfg */
    IfxPcie_LtssmState_rcvryIdle,        /**< \brief rcvryIdle */
    IfxPcie_LtssmState_l0,               /**< \brief l0 */
    IfxPcie_LtssmState_l0s,              /**< \brief l0s */
    IfxPcie_LtssmState_l123SendEidle,    /**< \brief l123SendEidle */
    IfxPcie_LtssmState_l1Idle,           /**< \brief l1Idle */
    IfxPcie_LtssmState_l2Idle,           /**< \brief l2Idle */
    IfxPcie_LtssmState_l2Wake,           /**< \brief l2Wake */
    IfxPcie_LtssmState_disabledEntry,    /**< \brief disabledEntry */
    IfxPcie_LtssmState_disabledIdle,     /**< \brief disabledIdle */
    IfxPcie_LtssmState_disabled,         /**< \brief disabled */
    IfxPcie_LtssmState_lpbkEntry,        /**< \brief lpbkEntry */
    IfxPcie_LtssmState_lpbkActive,       /**< \brief lpbkActive */
    IfxPcie_LtssmState_lpbkExit,         /**< \brief lpbkExit */
    IfxPcie_LtssmState_lpbkExitTimeout,  /**< \brief lpbkExitTimeout */
    IfxPcie_LtssmState_hotResetEntry,    /**< \brief hotResetEntry */
    IfxPcie_LtssmState_hotReset,         /**< \brief hotReset */
    IfxPcie_LtssmState_rcvryEq0,         /**< \brief rcvryEq0 */
    IfxPcie_LtssmState_rcvryEq1,         /**< \brief rcvryEq1 */
    IfxPcie_LtssmState_rcvryEq2,         /**< \brief rcvryEq2 */
    IfxPcie_LtssmState_rcvryEq3          /**< \brief rcvryEq3 */
} IfxPcie_LtssmState;

/** \brief Memory Type
 */
typedef enum
{
    IfxPcie_MemType_memNoPrefetch = 0,  /**< \brief non prefetch memory */
    IfxPcie_MemType_memPrefetch   = 1,  /**< \brief prefetch memory */
    IfxPcie_MemType_io            = 2   /**< \brief IO memory */
} IfxPcie_MemType;

/** \brief MSI Interrupts
 */
typedef enum
{
    IfxPcie_MsiInterrupt_none = -1,  /**< \brief none */
    IfxPcie_MsiInterrupt_1,          /**< \brief 1 Interrupts from Device */
    IfxPcie_MsiInterrupt_2,          /**< \brief 2 Interrupts from Device */
    IfxPcie_MsiInterrupt_4,          /**< \brief 4 Interrupts from Device */
    IfxPcie_MsiInterrupt_8,          /**< \brief 8 Interrupts from Device */
    IfxPcie_MsiInterrupt_16,         /**< \brief 16 Interrupts from Device */
    IfxPcie_MsiInterrupt_32          /**< \brief 32 Interrupts from Device */
} IfxPcie_MsiInterrupt;

/** \brief OBFF Event
 */
typedef enum
{
    IfxPcie_ObffEvent_none = -1,  /**< \brief No Event */
    IfxPcie_ObffEvent_idle,       /**< \brief Idle Event */
    IfxPcie_ObffEvent_obff,       /**< \brief OBFF Event */
    IfxPcie_ObffEvent_cpuActive,  /**< \brief CPU Active Event */
    IfxPcie_ObffEvent_wakeError   /**< \brief WAKE signal error Event */
} IfxPcie_ObffEvent;

/** \brief OBFF Type
 */
typedef enum
{
    IfxPcie_ObffType_None,  /**< \brief Disable OBFF */
    IfxPcie_ObffType_Msg,   /**< \brief OBFF using Message */
    IfxPcie_ObffType_Wake   /**< \brief OBFF using WAKE signalling */
} IfxPcie_ObffType;

/** \brief PME Events
 */
typedef enum
{
    IfxPcie_PmeEvent_none = -1,   /**< \brief No PME event */
    IfxPcie_PmeEvent_pmEvent,     /**< \brief PM State Event */
    IfxPcie_PmeEvent_message,     /**< \brief PME Message received */
    IfxPcie_PmeEvent_turnOffAck,  /**< \brief PM Turn Off Acknowledge Event */
    IfxPcie_PmeEvent_turnOff,     /**< \brief PM Turn Off Request Received */
    IfxPcie_PmeEvent_wakeUp,      /**< \brief PME Wake-up Interrupt Received */
    IfxPcie_PmeEvent_count        /**< \brief Count of PME Events */
} IfxPcie_PmeEvent;

/** \brief Status of Operations
 */
typedef enum
{
    IfxPcie_Status_success = 0u,  /**< \brief success */
    IfxPcie_Status_failure = 1u   /**< \brief failure */
} IfxPcie_Status;

/** \brief TLP FMT
 */
typedef enum
{
    IfxPcie_TlpFormat_3DWnoData   = 0,  /**< \brief 3 data words, no data */
    IfxPcie_TlpFormat_4DWnoData   = 1,  /**< \brief 4 data words, no data */
    IfxPcie_TlpFormat_3DWwithData = 2,  /**< \brief 3 data words, with data */
    IfxPcie_TlpFormat_4DWwithData = 3,  /**< \brief 4 data words, with data */
    IfxPcie_TlpFormat_tlpPrefix   = 4   /**< \brief TLP Prefix */
} IfxPcie_TlpFormat;

/** \brief TLP Message Format
 */
typedef enum
{
    IfxPcie_TlpMsgFormat_MsgNoData   = 1, /**< \brief 4 data words, no data */
    IfxPcie_TlpMsgFormat_MsgWithData = 3  /**< \brief 4 data words, with data */
} IfxPcie_TlpMsgFormat;

/** \brief TLP Message Routing
 */
typedef enum
{
    IfxPcie_TlpMsgRoute_toRootComplex,       /**< \brief Message to Root Complex */
    IfxPcie_TlpMsgRoute_byAddress,           /**< \brief Message Route by Address */
    IfxPcie_TlpMsgRoute_byID,                /**< \brief Message Route by ID */
    IfxPcie_TlpMsgRoute_broadcastFromRc,     /**< \brief Message Broadcast from RC */
    IfxPcie_TlpMsgRoute_terimateAtReceiver,  /**< \brief Message Terminate at the immediate receiver */
    IfxPcie_TlpMsgRoute_gatherToRootComplex  /**< \brief Message Gather and Route to Root Complex */
} IfxPcie_TlpMsgRoute;

/** \brief TLP Ordering Attributes
 */
typedef enum
{
    IfxPcie_TlpOrdering_default,  /**< \brief Default Ordering */
    IfxPcie_TlpOrdering_relaxed   /**< \brief Relaxed Ordering */
} IfxPcie_TlpOrdering;

/** \brief TLP Traffic Class
 */
typedef enum
{
    IfxPcie_TlpTrafficClass_0,  /**< \brief TC0 - best effort */
    IfxPcie_TlpTrafficClass_1,  /**< \brief TC1 - Differentiated class */
    IfxPcie_TlpTrafficClass_2,  /**< \brief TC2 - Differentiated class */
    IfxPcie_TlpTrafficClass_3,  /**< \brief TC3 - Differentiated class */
    IfxPcie_TlpTrafficClass_4,  /**< \brief TC4 - Differentiated class */
    IfxPcie_TlpTrafficClass_5,  /**< \brief TC5 - Differentiated class */
    IfxPcie_TlpTrafficClass_6,  /**< \brief TC6 - Differentiated class */
    IfxPcie_TlpTrafficClass_7   /**< \brief TC7 - Differentiated class */
} IfxPcie_TlpTrafficClass;

/** \brief TLP Types
 */
typedef enum
{
    IfxPcie_TlpType_memRequest         = 0,   /**< \brief memory Request */
    IfxPcie_TlpType_memLockRequest     = 1,   /**< \brief mem Lock Request */
    IfxPcie_TlpType_ioRequest          = 2,   /**< \brief IO Request */
    IfxPcie_TlpType_configType0        = 4,   /**< \brief Config Type 0 Request */
    IfxPcie_TlpType_configType1        = 5,   /**< \brief Config Type 1 Request */
    IfxPcie_TlpType_completion         = 10,  /**< \brief Completion */
    IfxPcie_TlpType_completionLocked   = 11,  /**< \brief Completion locked */
    IfxPcie_TlpType_fetchAddRequest    = 12,  /**< \brief Fetch Add Operation */
    IfxPcie_TlpType_swapRequest        = 13,  /**< \brief Swap Operation */
    IfxPcie_TlpType_compareSwapRequest = 14,  /**< \brief Compare and Swap Operation */
    IfxPcie_TlpType_msg                = 32   /**< \brief Messages */
} IfxPcie_TlpType;

/** \brief Vendor Defined Message type
 */
typedef enum
{
    IfxPcie_VendorMsgType_0 = 126,  /**< \brief Vendor Message Type 0 */
    IfxPcie_VendorMsgType_1 = 127   /**< \brief Vendor Message Type 1 */
} IfxPcie_VendorMsgType;

/** \brief Link power state
 */
typedef enum
{
    IfxPcie_lnkPowerState_l0,   /**< \brief L0 State */
    IfxPcie_lnkPowerState_l0s,  /**< \brief L0s state */
    IfxPcie_lnkPowerState_l1,   /**< \brief L1 State */
    IfxPcie_lnkPowerState_l2,   /**< \brief L2 state */
    IfxPcie_lnkPowerState_l3    /**< \brief L3 State */
} IfxPcie_lnkPowerState;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Std_Structures
 * \{ */
/** \brief Error Interrupt Configuration Bits
 */
typedef struct
{
    uint32 corr : 1;
    uint32 nonFatal : 1;
    uint32 fatal : 1;
    uint32 reserved_3 : 29;
} IfxPcie_ErrorInterruptBits;

/** \brief PME Interrupt Configuration Bits
 */
typedef struct
{
    uint32 pmeEvent : 1;                /**< \brief PM State Event */
    uint32 pmeMessage : 1;              /**< \brief PME Message received */
    uint32 turnOffAcknowledge : 1;      /**< \brief PM Turn Off Acknowledge Event */
    uint32 turnOff : 1;                 /**< \brief PM Turn Off Event */
    uint32 wakeUp : 1;                  /**< \brief PME Wake-up Event */
    uint32 reserved_5 : 27;
} IfxPcie_PmeInterruptBits;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Structures
 * \{ */
/** \brief This union is needed for common functionality implementations
 */
typedef union
{
    Ifx_PCIE_DSP DSP;
    Ifx_PCIE_USP USP;
} IfxPcie;

/** \brief Error Interrupt Configuration
 */
typedef union
{
    uint32                     U;       /**< \brief Word Access */
    IfxPcie_ErrorInterruptBits B;       /**< \brief Bits Access */
} IfxPcie_ErrorInterrupt;

/** \brief PME Interrupt Configuration
 */
typedef union
{
    uint32                   U;       /**< \brief Word Access */
    IfxPcie_PmeInterruptBits B;       /**< \brief Bits Access */
} IfxPcie_PmeInterrupt;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable the PCIE module
 * \param pcieSFR pointer (union type to allow DSP, USP)
 * \return None
 */
IFX_INLINE void IfxPcie_enableModule(IfxPcie *pcieSFR);

/** \brief Reset the PCIE module
 * \param pcieSFR pointer (union type to allow DSP, USP)
 * \return None
 */
IFX_INLINE void IfxPcie_resetModule(IfxPcie *pcieSFR);

/** \brief Set the Device Mode
 * \param pcieSFR pointer (union type to allow DSP, USP)
 * \param mode (ep, legacyEP, RC)
 * \return None
 */
IFX_INLINE void IfxPcie_setDeviceMode(IfxPcie *pcieSFR, IfxPcie_DeviceMode mode);

/** \brief Get the Device Mode
 * \param pcieSFR pointer (union type to allow DSP, USP)
 * \return mode (ep, legacyEP, RC)
 */
IFX_INLINE IfxPcie_DeviceMode IfxPcie_getDeviceMode(IfxPcie *pcieSFR);

/** \brief Check if DBI RO write access is enabled
 * \param pcieSFR pointer (union type to allow DSP, USP)
 * \return TRUE: DBI access enabled.
 * FALSE: No DBI Access
 */
IFX_INLINE boolean IfxPcie_isDbiRoAccessEnabled(IfxPcie *pcieSFR);

/** \brief Set the DBI RO write access
 * \param pcieSFR pointer (union type to allow DSP, USP)
 * \param enable (TRUE, FALSE)
 * \return None
 */
IFX_INLINE void IfxPcie_setDbiRoAccess(IfxPcie *pcieSFR, boolean enable);

/** \brief Get the SRC pointer from interrupt vector line
 * \param index Pcie index
 * \param intVector Interrupt Vector line from PCIE
 * \return Address of SRC node register
 */
IFX_INLINE Ifx_SRC_SRCR *IfxPcie_getSrcPointer(IfxPcie_Index index, IfxPcie_IntVector intVector);

/** \brief Check if the link is up
 * \param pcieSFR Pointer to the PCIE SFR
 * \return TRUE: Link is up
 * FALSE: Link is not up
 */
IFX_INLINE boolean IfxPcie_isLinkUp(IfxPcie *pcieSFR);

/** \brief Enable Link Training
 * \param pcieSFR Pointer to the PCIE SFR
 * \return None
 */
IFX_INLINE void IfxPcie_enableLtssm(IfxPcie *pcieSFR);

/** \brief Indicates the current Link state. Intended for debugging purposes, not for system operation.
 * \param pcieSFR Pointer to module register
 * \return Link power state
 */
IFX_INLINE IfxPcie_lnkPowerState IfxPcie_getLinkState(IfxPcie *pcieSFR);

/** \brief Current state of the LTSSM.
 * \param pcieSFR Pointer to module register
 * \return LTSSM state
 */
IFX_INLINE IfxPcie_LtssmState IfxPcie_getLtssmState(IfxPcie *pcieSFR);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configuration read in bytes
 * \param PcieRcReg Ptr to RC register
 * \param CfgstartAddr Configuration start address
 * \param offset Offset
 * \param val Read value
 * \return None
 */
IFX_EXTERN void IfxPcie_CfgRdb(Ifx_PCIE_DSP *PcieRcReg, uint32 CfgstartAddr, uint32 offset, uint8 *val);

/** \brief Configuration read in 32bit
 * \param CfgstartAddr Configuration start address
 * \param offset offset
 * \param val read value
 * \return None
 */
IFX_EXTERN void IfxPcie_CfgRdl(uint32 CfgstartAddr, uint32 offset, uint32 *val);

/** \brief Configuration read in 16bit
 * \param PcieRcReg Ptr to RC register
 * \param CfgstartAddr Configuration start address
 * \param offset offset
 * \param val read value
 * \return None
 */
IFX_EXTERN void IfxPcie_CfgRdw(Ifx_PCIE_DSP *PcieRcReg, uint32 CfgstartAddr, uint32 offset, uint16 *val);

/** \brief Config space write byte
 * \param PcieRcReg Ptr to RC register
 * \param CfgstartAddr Configuration start address
 * \param offset Offset value
 * \param val Value to be written
 * \return None
 */
IFX_EXTERN void IfxPcie_CfgWrb(Ifx_PCIE_DSP *PcieRcReg, uint32 CfgstartAddr, uint32 offset, uint8 val);

/** \brief Config space write word
 * \param PcieRcReg Ptr to RC register
 * \param CfgstartAddr Configuration start address
 * \param offset Offset value
 * \param val value to be written
 * \return None
 */
IFX_EXTERN void IfxPcie_CfgWrw(Ifx_PCIE_DSP *PcieRcReg, uint32 CfgstartAddr, uint32 offset, uint16 val);

/** \brief Config space write long
 * \param CfgstartAddr Configuration start address
 * \param offset offset value
 * \param val Value to be written
 * \return None
 */
IFX_EXTERN void IfxPcie_CfgWrl(uint32 CfgstartAddr, uint32 offset, uint32 val);

/** \brief Memory write long
 * \param PcieRcReg Ptr to RC register
 * \param MemstartAddr Memory start address
 * \param offset Offset value
 * \param val value to be read
 * \return None
 */
IFX_EXTERN void IfxPcie_MemRdl(Ifx_PCIE_DSP *PcieRcReg, uint32 MemstartAddr, uint32 offset, uint32 *val);

/**
 * \param PcieRcReg Ptr to RC register
 * \param MemstartAddr Memory start address
 * \param offset Offset value
 * \param val value to be written
 * \return None
 */
IFX_EXTERN void IfxPcie_MemWrl(Ifx_PCIE_DSP *PcieRcReg, uint32 MemstartAddr, uint32 offset, uint32 val);

/** \brief CPU memory read long
 * \param MemstartAddr Memory start address
 * \param offset Offset
 * \param val Value read
 * \return None
 */
IFX_EXTERN void IfxPcie_CpuMemRdl(uint32 MemstartAddr, uint32 offset, uint32 *val);

/** \brief CPU memory read long
 * \param MemstartAddr Memory start address
 * \param offset Offset
 * \param val Value to be written
 * \return None
 */
IFX_EXTERN void IfxPcie_CpuMemWrl(uint32 MemstartAddr, uint32 offset, uint32 val);

/** \brief Get Bar Memory size from bar register
 * \param barReg double word pointer to BAR register
 * \param doubleWord if TRUE, BAR is 64 bit decoded
 * \return bar memory size.
 */
IFX_EXTERN uint64 IfxPcie_getBarMemSize(volatile uint32 *barReg, boolean doubleWord);

/** \brief Get the Status of PME Event
 * \param pcieSFR pointer to the PCIE SFR
 * \param pmeEvent type of event
 * \return TRUE: Event has occurred
 * FALSE: Event has not occurred
 */
IFX_EXTERN boolean IfxPcie_getPmeEventStatus(IfxPcie *pcieSFR, IfxPcie_PmeEvent pmeEvent);

/** \brief Get the Pending PME Interrupt Event
 * \param pcieSFR pointer to the PCIE SFR
 * \param pmeInterrupt Pointer to the PME Interrupt Status
 * \return TRUE: A PME EVent has occurred.
 * FALSE: No PME EVents have occurred
 */
IFX_EXTERN boolean IfxPcie_getPendingPmeInterrupts(IfxPcie *pcieSFR, IfxPcie_PmeInterrupt *pmeInterrupt);

/** \brief Enable PME Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param enableMask ENABLE Bits ( 1 << "POS" means that "POS" Interrupt is enabled
 * \return None
 */
IFX_EXTERN void IfxPcie_enablePmeInterrupts(IfxPcie *pcieSFR, uint32 enableMask);

/** \brief Disable PME Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param disableMask Disable Bits ( 1 << "POS" means that "POS" Interrupt is disabled
 * \return None
 */
IFX_EXTERN void IfxPcie_disablePmeInterrupts(IfxPcie *pcieSFR, uint32 disableMask);

/** \brief Clear PME Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param clearMask Mask for clear. (1 << POS : means that "POS" will be cleared)
 * \return None
 */
IFX_EXTERN void IfxPcie_clearPmeInterrupts(IfxPcie *pcieSFR, uint32 clearMask);

/** \brief Get the Status of Error Event
 * \param pcieSFR pointer to the PCIE SFR
 * \param errorEvent type of event
 * \return TRUE: Event has occurred
 * FALSE: Event has not occurred
 */
IFX_EXTERN boolean IfxPcie_getErrorEventStatus(IfxPcie *pcieSFR, IfxPcie_ErrorEvent errorEvent);

/** \brief Get the Pending Error Interrupt Event
 * \param pcieSFR pointer to the PCIE SFR
 * \param errorInterrupt Pointer to the PME Interrupt Status
 * \return TRUE: A PME EVent has occurred.
 * FALSE: No PME EVents have occurred
 */
IFX_EXTERN boolean IfxPcie_getPendingErrorInterrupts(IfxPcie *pcieSFR, IfxPcie_ErrorInterrupt *errorInterrupt);

/** \brief Enable Error Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param enableMask ENABLE Bits ( 1 << "POS" means that "POS" Interrupt is enabled
 * \return None
 */
IFX_EXTERN void IfxPcie_enableErrorInterrupts(IfxPcie *pcieSFR, uint32 enableMask);

/** \brief Disable Error Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param disableMask Disable Bits ( 1 << "POS" means that "POS" Interrupt is disabled
 * \return None
 */
IFX_EXTERN void IfxPcie_disableErrorInterrupts(IfxPcie *pcieSFR, uint32 disableMask);

/** \brief Clear Error Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param clearMask Mask for clear. (1 << POS : means that "POS" will be cleared)
 * \return None
 */
IFX_EXTERN void IfxPcie_clearErrorInterrupts(IfxPcie *pcieSFR, uint32 clearMask);

/** \brief Send a Turn OFF message
 * \param pcieSFR pointer to the PCIE SFR
 * \return None
 */
IFX_EXTERN void IfxPcie_sendPmeTurnOffMessage(IfxPcie *pcieSFR);

/** \brief Wait for HSPHY complete
 * \param hsphySFR pointer to the HSPHY SFR
 * \param phyIndex PHY Index to wait for
 * \return None
 */
IFX_EXTERN void IfxPcie_waitForHsphy(Ifx_HSPHY *hsphySFR, IfxHsphy_PhyIndex phyIndex);

/** \brief Enable LTR Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \return None
 */
IFX_EXTERN void IfxPcie_enableLtrInterrupt(IfxPcie *pcieSFR);

/** \brief Disable LTR Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \return None
 */
IFX_EXTERN void IfxPcie_disableLtrInterrupt(IfxPcie *pcieSFR);

/** \brief Check if there is an LTR Event Pending
 * \param pcieSFR pointer to the PCIE SFR
 * \return TRUE: LTR Event is pending
 */
IFX_EXTERN boolean IfxPcie_isLtrEventPending(IfxPcie *pcieSFR);

/** \brief Clear LTR Event
 * \param pcieSFR pointer to the PCIE SFR
 * \return None
 */
IFX_EXTERN void IfxPcie_clearLtrEvent(IfxPcie *pcieSFR);

/** \brief Get LTR message Payload
 * \param pcieSFR pointer to the PCIE SFR
 * \return uint32 LTR message payload
 */
IFX_EXTERN uint32 IfxPcie_getLtrMessagePayload(IfxPcie *pcieSFR);

/** \brief Trigger an LTR message to RC
 * \param pcieSFR pointer to the PCIE SFR
 * \return None
 */
IFX_EXTERN void IfxPcie_triggerLtrMessage(IfxPcie *pcieSFR);

/** \brief Enable OBFF Event Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param obffType Type of OBFF
 * \param obffEvent State of OBFF event
 * \return None
 */
IFX_EXTERN void IfxPcie_enableObffEventInterrupt(IfxPcie *pcieSFR, IfxPcie_ObffType obffType, IfxPcie_ObffEvent obffEvent);

/** \brief Disable OBFF Event Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param obffType Type of OBFF
 * \param obffEvent State of OBFF event
 * \return None
 */
IFX_EXTERN void IfxPcie_disableObffEventInterrupt(IfxPcie *pcieSFR, IfxPcie_ObffType obffType, IfxPcie_ObffEvent obffEvent);

/** \brief Enable all OBFF Interrupts
 * \param pcieSFR pointer to the PCIE SFR
 * \param obffType Type of OBFF
 * \return None
 */
IFX_EXTERN void IfxPcie_enableObffInterrupts(IfxPcie *pcieSFR, IfxPcie_ObffType obffType);

/** \brief Disable all OBFF Event Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param obffType Type of OBFF
 * \return None
 */
IFX_EXTERN void IfxPcie_disableObffInterrupts(IfxPcie *pcieSFR, IfxPcie_ObffType obffType);

/** \brief Get the pending OBFF Event Interrupt
 * \param pcieSFR pointer to the PCIE SFR
 * \param obffType Type of OBFF
 * \return IfxPcie_ObffEvent OBFF event
 */
IFX_EXTERN IfxPcie_ObffEvent IfxPcie_getPendingObffEvent(IfxPcie *pcieSFR, IfxPcie_ObffType obffType);

/** \brief Clears pending OBFF events
 * \param pcieSFR pointer to the PCIE SFR
 * \param obffType Type of OBFF
 * \param obffEvent State of OBFF event
 * \return None
 */
IFX_EXTERN void IfxPcie_clearPendingObffEvent(IfxPcie *pcieSFR, IfxPcie_ObffType obffType, IfxPcie_ObffEvent obffEvent);

/** \brief Clears pending OBFF events
 * \param pcieSFR pointer to the PCIE SFR
 * \param obffType Type of OBFF
 * \param obffEvent State of the OBFF event
 * \return None
 */
IFX_EXTERN void IfxPcie_triggerObff(IfxPcie *pcieSFR, IfxPcie_ObffType obffType, IfxPcie_ObffEvent obffEvent);

/** \brief Configures access to all masters to all the PCIEs in the device
 * \param apConfig pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxPcie_configureAccessToPcies(IfxApApu_ApuConfig *apConfig);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxPcie_enableModule(IfxPcie *pcieSFR)
{
    Ifx_PCIE_DSP *pcie = (Ifx_PCIE_DSP *)pcieSFR;

    pcie->CLC.B.DISR = 0u;

    while (pcie->CLC.B.DISS != 0u)
    {
        /* wait here until the module is enabled */
        /* TODO: disable warning : this is needed */
    }
}


IFX_INLINE void IfxPcie_resetModule(IfxPcie *pcieSFR)
{
    Ifx_PCIE_DSP_RST *pcieRst = &(pcieSFR->DSP.RST);

    /* Request a new Reset */
    pcieRst->CTRLA.B.KRST = 1u;
    pcieRst->CTRLB.B.KRST = 1u;

    /* Ensure Reset occurred */
    while (pcieRst->STAT.B.KRST == 0u)
    {
        /* Wait here until Reset happens */
    }

    /* Clear the Reset Status */
    pcieRst->CTRLB.B.STATCLR = 1u;

    /* Wait until KRST is cleared, only after this reset sequence is completed */
    while (pcieRst->STAT.B.KRST == 1u)
    {}
}


IFX_INLINE void IfxPcie_setDeviceMode(IfxPcie *pcieSFR, IfxPcie_DeviceMode mode)
{
    pcieSFR->DSP.LNK.DVCTYP.B.TYP = (uint32)mode;
}


IFX_INLINE IfxPcie_DeviceMode IfxPcie_getDeviceMode(IfxPcie *pcieSFR)
{
    return (IfxPcie_DeviceMode)(pcieSFR->DSP.LNK.DVCTYP.B.TYP);
}


IFX_INLINE boolean IfxPcie_isDbiRoAccessEnabled(IfxPcie *pcieSFR)
{
    return (pcieSFR->DSP.PORTLOGIC.MISC_CONTROL_1_OFF.B.DBI_RO_WR_EN == (uint32)1) ? TRUE : FALSE;
}


IFX_INLINE void IfxPcie_setDbiRoAccess(IfxPcie *pcieSFR, boolean enable)
{
    pcieSFR->DSP.PORTLOGIC.MISC_CONTROL_1_OFF.B.DBI_RO_WR_EN = (uint32)enable;
}


IFX_INLINE Ifx_SRC_SRCR *IfxPcie_getSrcPointer(IfxPcie_Index index, IfxPcie_IntVector intVector)
{
    Ifx_SRC_SRCR *srcPointer = NULL_PTR;

    if (intVector != IfxPcie_IntVector_none)
    {
        srcPointer = &(((Ifx_SRC_SRCR *)&(MODULE_SRC.PCIE[index]))[intVector]);
    }

    return srcPointer;
}


IFX_INLINE boolean IfxPcie_isLinkUp(IfxPcie *pcieSFR)
{
    boolean linkStatus = FALSE;

    if (pcieSFR->DSP.LNK.STAT.B.LINKUP == 1u)
    {
        linkStatus = TRUE;
    }

    return linkStatus;
}


IFX_INLINE void IfxPcie_enableLtssm(IfxPcie *pcieSFR)
{
    Ifx_PCIE_DSP_LNK_CORECTRL lnkReg;
    lnkReg.U                    = pcieSFR->DSP.LNK.CORECTRL.U;  /* Read register */
    lnkReg.B.LTSSMEN            = 1u;
    pcieSFR->DSP.LNK.CORECTRL.U = lnkReg.U;
}


IFX_INLINE IfxPcie_lnkPowerState IfxPcie_getLinkState(IfxPcie *pcieSFR)
{
    return (IfxPcie_lnkPowerState)(pcieSFR->DSP.PM.STAT0.B.CURNTSTAT);
}


IFX_INLINE IfxPcie_LtssmState IfxPcie_getLtssmState(IfxPcie *pcieSFR)
{
    return (IfxPcie_LtssmState)(pcieSFR->DSP.PM.STAT0.B.LTSSMSTAT);
}


#endif /* IFXPCIE_H */
