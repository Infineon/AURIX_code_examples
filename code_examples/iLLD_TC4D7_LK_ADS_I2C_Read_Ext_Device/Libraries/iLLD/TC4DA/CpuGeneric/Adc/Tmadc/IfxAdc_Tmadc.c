/**
 * \file IfxAdc_Tmadc.c
 * \brief ADC TMADC details
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxAdc_Tmadc.h"

/******************************************************************************/
/*------------------------Inline Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to convert buffer size in word to Dma circular buffer enum
 * \param size Size of buffer in words
 * \return Size of buffer in enum of dma circular buffer
 */
IFX_INLINE uint16 IfxAdc_Tmadc_getDmaCircularBufferSize(uint16 size);

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Function to configure DMA for TMADC channel
 * \param queue Pointer to queue configuration
 * \param channel Pointer to handle of Tmadc channel
 * \return None
 */
IFX_STATIC void IfxAdc_Tmadc_configureDma(IfxAdc_Tmadc_QueueConfig *queue, IfxAdc_Tmadc_Ch *channel);

/** \brief Function to the configure DMA for TMADC group
 * \param groupConfig Pointer to group configuration
 * \param group Pointer to handle of Tmadc group
 * \return None
 */
IFX_STATIC void IfxAdc_Tmadc_configureDmaForGroup(IfxAdc_Tmadc_GroupConfig *groupConfig, IfxAdc_Tmadc_Group *group);

/** \brief Function to initialize the result buffer.
 * \param queueConfig Pointer to queue configuration
 * \param channel Pointer to handle of Tmadc channel
 * \return Return
 * IfxAdc_Status_success --> Setting up of result buffer is successful
 * IfxAdc_Status_failure --> Issue in setting up of result buffer
 */
IFX_STATIC IfxAdc_Status IfxAdc_Tmadc_initBuffer(IfxAdc_Tmadc_QueueConfig *queueConfig, IfxAdc_Tmadc_Ch *channel);

/** \brief Function to update internal handle information from DMA.
 * \param channel Pointer to handle of Tmadc channel
 * \return None
 */
IFX_STATIC void IfxAdc_Tmadc_updateHandleInfoFromDma(IfxAdc_Tmadc_Ch *channel);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint16 IfxAdc_Tmadc_getDmaCircularBufferSize(uint16 size)
{
    uint8 count = 0U;
    size = (size << 2U); //convert size in word to bytes. Multiply by 4

    while (size > 1U)
    {
        size >>= 1U;
        count++;
    }

    return count;
}


/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxAdc_Tmadc_initModule(IfxAdc_Tmadc *tmadc, const IfxAdc_Tmadc_Config *config)
{
    IfxAdc_TmadcModule                    moduleId       = config->id;
    IfxAdc_Tmadc_EmuxConfig              *emuxcfgPtr     = config->emuxCfg;
    IfxAdc_Tmadc_ModuleBoundConfig       *boundrycfgPtr  = config->bndryConfig;
    IfxAdc_Tmadc_GlobalServRequestConfig *globServReqPtr = config->glbsrvReqCfg;
    IfxAdc_Tmadc_ServRequestConfig       *servReqPtr     = config->srvReqCfg;
    Ifx_ADC                              *adcmodptr      = config->adcSFR;
    Ifx_ADC_TMADC                        *modptr         = &(adcmodptr->TMADC[moduleId]);
    volatile Ifx_SRC_SRCR                *src            = NULL_PTR;
    IfxAdc_TmadcServReq                   reqNode        = IfxAdc_TmadcServReq_none;

    /* Updating handle */
    tmadc->modSFR     = modptr;
    tmadc->state      = IfxAdc_Tmadc_moduleState_unknown;
    tmadc->id         = moduleId;
    tmadc->calEnabled = config->calEnable;
    Ifx_ADC_TMADC_MODCFG modCfg;
    Ifx_ADC_TMADC_SR_CFG srCfg;

    /* 1. Enable Tmadc Module clock */
    IfxAdc_enableTmadcModule(moduleId);

    /* Read registers */
    modCfg.U         = modptr->MODCFG.U;

    modCfg.B.BND0UPD = config->shadowBnd0Update;
    modCfg.B.BND1UPD = config->shadowBnd1Update;

    /* Output supervisor signal selection */
    modCfg.B.OSSEL = config->outputSignalSel;

    /* Writing registers back */
    modptr->MODCFG.U = modCfg.U;

    //4. Configure the boundary value registers
    if (boundrycfgPtr != NULL_PTR)
    {
        if (boundrycfgPtr->boundCfg1 != NULL_PTR)
        {
            IfxAdc_Tmadc_configureBoundary(modptr, boundrycfgPtr->boundCfg1, IfxAdc_TmadcBoundaryReg_0);
        }

        if (boundrycfgPtr->boundCfg2 != NULL_PTR)
        {
            IfxAdc_Tmadc_configureBoundary(modptr, boundrycfgPtr->boundCfg2, IfxAdc_TmadcBoundaryReg_1);
        }
    }

    /* Configure EMUX */
    if (emuxcfgPtr != NULL_PTR)
    {
        IfxAdc_Tmadc_configureEmux(modptr, emuxcfgPtr);
    }

    /* Configure Service request nodes and interrupt configuration*/
    if (servReqPtr != NULL_PTR)
    {
        uint8 i;

        for (i = 0u; i < (servReqPtr->numServReqNodes); i++)
        {
            if (servReqPtr->intConfig[i] != NULL_PTR)
            {
                /* Service request configuration */
                srCfg.U                                          = modptr->SR[servReqPtr->intConfig[i]->node].CFG.U;
                srCfg.B.EVOP                                     = servReqPtr->intConfig[i]->eventOp;
                srCfg.B.EVSEL                                    = servReqPtr->intConfig[i]->eventSel;
                modptr->SR[servReqPtr->intConfig[i]->node].CFG.U = srCfg.U;

                if (servReqPtr->intConfig[i]->node < IfxAdc_TmadcServReq_6)
                {
                    /* Interrupt configuration */
#if (IFXDMA_NUM_MODULES > 1U)

                    if ((servReqPtr->intConfig[i]->priority > 0u) || (servReqPtr->intConfig[i]->typeOfService == IfxSrc_Tos_dma0) || (servReqPtr->intConfig[i]->typeOfService == IfxSrc_Tos_dma1))
#else

                    if ((servReqPtr->intConfig[i]->priority > 0u) || (servReqPtr->intConfig[i]->typeOfService == IfxSrc_Tos_dma0))
#endif
                    {
                        reqNode = servReqPtr->intConfig[i]->node;
                        src     = IfxAdc_getTmadcSrcPointer(moduleId, reqNode);
                        IfxSrc_init(src, servReqPtr->intConfig[i]->typeOfService, servReqPtr->intConfig[i]->priority, servReqPtr->intConfig[i]->vmId);
                        IfxSrc_enable(src);
                    }
                }
            }
        }
    }

    /* Configure SR6 global service request */
    if (globServReqPtr != NULL_PTR)
    {
        if (globServReqPtr->enableEvent)
        {
            adcmodptr->GLSRCFG[globServReqPtr->servReq].B.EVEN |= (1u << moduleId);
            adcmodptr->GLSRCFG[globServReqPtr->servReq].B.EVOP  = globServReqPtr->eventLogic;

            /* Interrupt Configuration*/
#if (IFXDMA_NUM_MODULES > 1U)

            if ((globServReqPtr->priority > 0u) || (globServReqPtr->typeOfService == IfxSrc_Tos_dma0) || (globServReqPtr->typeOfService == IfxSrc_Tos_dma1))
#else

            if ((globServReqPtr->priority > 0u) || (globServReqPtr->typeOfService == IfxSrc_Tos_dma0))
#endif
            {
                IfxSrc_init(&MODULE_SRC.ADC.SR[globServReqPtr->servReq], globServReqPtr->typeOfService, globServReqPtr->priority, globServReqPtr->vmId);
                IfxSrc_enable(&MODULE_SRC.ADC.SR[globServReqPtr->servReq]);
            }
        }
    }

    tmadc->state = IfxAdc_Tmadc_moduleState_initialized;
}


void IfxAdc_Tmadc_initModuleConfig(IfxAdc_Tmadc_Config *config, Ifx_ADC *adc)
{
    //1. Initialize all to default values
    const IfxAdc_Tmadc_Config defaultConfig = {
        .id               = IfxAdc_TmadcModule_0,
        .adcSFR           = NULL_PTR,
        .shadowBnd0Update = FALSE,
        .shadowBnd1Update = FALSE,
        .calEnable        = FALSE,
        .outputSignalSel  = IfxAdc_TmadcOutputSupervisorMux_noConnection,
        .emuxCfg          = NULL_PTR,
        .bndryConfig      = NULL_PTR,
        .glbsrvReqCfg     = NULL_PTR,
        .srvReqCfg        = NULL_PTR
    };

    *config        = defaultConfig;

    config->adcSFR = adc;
}


void IfxAdc_Tmadc_initChannel(IfxAdc_Tmadc_Ch *channel, IfxAdc_Tmadc_ChConfig *config)
{
    uint8                          modId     = config->moduleId;
    uint8                          chId      = (uint8)(config->id);
    Ifx_ADC_TMADC                 *modptr    = &(config->adcSFR->TMADC[modId]);
    Ifx_ADC_TMADC_CH              *chptr     = &(modptr->CH[chId]);
    IfxAdc_Tmadc_ResultConfig     *resCfg    = &(config->resultCfg);
    IfxAdc_Tmadc_GroupConfig      *grpCfgPtr = config->groupCfg;
    IfxAdc_Tmadc_ChannelPinConfig *pinCfg    = config->channelPin;
    IfxAdc_TmadcServReq            errorNode = IfxAdc_TmadcServReq_0;
    IfxAdc_TmadcServReq            bndryNode = IfxAdc_TmadcServReq_0;
    IfxAdc_TmadcServReq            resltNode = IfxAdc_TmadcServReq_0;
    IfxAdc_TmadcResultReg          rsltReg   = resCfg->resultReg;

    /* Reading register */
    Ifx_ADC_TMADC_RSLT_CFG         resCfgReg;
    Ifx_ADC_TMADC_CH_CFG           chCfgReg;
    Ifx_ADC_TMADC_CH_STC           chStcReg;
    chCfgReg.U  = chptr->CFG.U;
    resCfgReg.U = modptr->RSLT[rsltReg].CFG.U;
    chStcReg.U  = chptr->STC.U;

    /* Update Channel handle */
    channel->id               = (IfxAdc_TmadcChannel)chId;
    channel->modSFR           = modptr;
    channel->chSFR            = chptr;
    channel->rsltSFR          = (Ifx_ADC_RES *)&(MODULE_ADC.TMADC[modId].AW1.RES0.U) + (rsltReg * IFXADC_TMADC_AW1_RES_TS_OFFSET);
    channel->tmstmpSFR        = (Ifx_ADC_TS *)(&(MODULE_ADC.TMADC[modId].AW1.TS0.U) + (rsltReg * IFXADC_TMADC_AW1_RES_TS_OFFSET));
    channel->state            = IfxAdc_Tmadc_channelState_uninitialized;
    channel->moduleId         = (IfxAdc_TmadcModule)modId;
    channel->resultRegNum     = rsltReg;
    channel->boundaryReg      = resCfg->boundRegSel;
    channel->timeStampEnabled = resCfg->enableTimestamp;

    /* 1. Initialize sampling time and channel core mapping*/
    {
        chStcReg.B.ST             = IfxAdc_getTmadcSamplingTimeValue(config->samplingTimeNS);
        modptr->CMATCFG.B.CHCSEL |= (config->core << chId);
    }

    //2. Trigger configuration
    if (grpCfgPtr == NULL_PTR)
    {
        /* Initializing trigger from channel configuration */
        if (config->mode == IfxAdc_TmadcOpMode_continuous)
        {
            /* No HW Triggers required. configure ATREN */
            chCfgReg.B.ATREN = (uint32)1;
        }
        else if (config->trigger != NULL_PTR)
        {
            IfxAdc_Tmadc_ChannelTriggerConfig *trgCfg = config->trigger;
            chCfgReg.B.HWTR0MS = (uint32)(trgCfg->hwTrigger1.muxSel);
            chCfgReg.B.HWTR1MS = (uint32)(trgCfg->hwTrigger2.muxSel);
            chCfgReg.B.HWTR0M  = (uint32)(trgCfg->hwTrigger1.edgeSel);
            chCfgReg.B.HWTR1M  = (uint32)(trgCfg->hwTrigger2.edgeSel);

            chStcReg.B.TRD     = IfxAdc_getTmadcTriggerDelayValue(trgCfg->delayNS);
        }
        else
        {
            /* do nothing. TODO: assert error? */
        }

        /* Set Wait for read if channel is not assigned to any group*/
        resCfgReg.B.WFR = resCfg->waitForRead;

        /*Enable timestamp counter for module if timestamp is reuqested for any channel */
        if ((resCfg->enableTimestamp) && (modptr->MODCFG.B.TSCRUN != 1))
        {
            modptr->MODCFG.B.TSCRUN = 1u;
        }

        chCfgReg.B.TSEN = resCfg->enableTimestamp;

        //Queue Configuration
        if (config->queueCfg != NULL_PTR)
        {
            /* Initialize and update the handle with buffer address and size*/
            IfxAdc_Tmadc_initBuffer(config->queueCfg, channel);

            if (config->queueCfg->dmaCfg != NULL_PTR)
            {
                IfxAdc_Tmadc_configureDma(config->queueCfg, channel);
            }
            else
            {
                /* If DMA not configured update handle with FALSE*/
                channel->queue.dma.useDma = FALSE;
            }
        }
    }
    else
    {
        // If config->groupConfig is not NULL:
        // 3. Initialize trigger from group configuration
        // 4.  if continuous, then set the auto Trigger mode.
        if (grpCfgPtr->mode == IfxAdc_TmadcOpMode_continuous)
        {
            /* No HW Triggers required. configure ATREN */
            chCfgReg.B.ATREN = (uint32)1;
        }
        else if (grpCfgPtr->trigger != NULL_PTR)
        {
            IfxAdc_Tmadc_ChannelTriggerConfig *grptrgCfg = grpCfgPtr->trigger;
            chCfgReg.B.HWTR0MS = (uint32)(grptrgCfg->hwTrigger1.muxSel);
            chCfgReg.B.HWTR1MS = (uint32)(grptrgCfg->hwTrigger2.muxSel);
            chCfgReg.B.HWTR0M  = (uint32)(grptrgCfg->hwTrigger1.edgeSel);
            chCfgReg.B.HWTR1M  = (uint32)(grptrgCfg->hwTrigger2.edgeSel);

            chStcReg.B.TRD     = IfxAdc_getTmadcTriggerDelayValue(grptrgCfg->delayNS);
        }
        else
        {
            /* do nothing */
        }

        /* Set wait for read as per group configuration */
        resCfgReg.B.WFR = grpCfgPtr->waitForRead;

        if ((grpCfgPtr->enableTimestamp) && (modptr->MODCFG.B.TSCRUN != 1))
        {
            modptr->MODCFG.B.TSCRUN = 1u;
        }

        chCfgReg.B.TSEN = grpCfgPtr->enableTimestamp;
    }

    /* Pin configurations */
    if (pinCfg != NULL_PTR)
    {
        /* Analog pin configuration*/
        if (pinCfg->tmadcInPin != NULL_PTR)
        {
            IfxAdc_initTmadcPin(pinCfg->tmadcInPin, pinCfg->tmadcPinMode, pinCfg->pinDriver);
        }
    }

    /* 6. Initialize result configuration */
    {
        chCfgReg.B.RSEL = rsltReg;       /* result register mapped to channel */

        /* Boundary configurations */
        resCfgReg.B.BNDMODE = resCfg->boundMode;
        resCfgReg.B.BNDSEL  = resCfg->boundCmpMode;
        resCfgReg.B.BNDSELR = resCfg->boundRegSel;
        resCfgReg.B.HYSTM   = resCfg->hysteresisEn;
    }

    /* 7.perform interrupt configuration */
    if (grpCfgPtr != NULL_PTR)
    {
        if (grpCfgPtr->grpSrvReq != NULL_PTR)
        {
            /* Error node */
            errorNode = grpCfgPtr->grpSrvReq->errorNode;

            if (errorNode != IfxAdc_TmadcServReq_none)
            {
                IfxAdc_Tmadc_enableChannelEvent(channel, errorNode, IfxAdc_TmadcEventSel_error);
            }

            /*Boundary node */
            bndryNode = grpCfgPtr->grpSrvReq->boundaryNode;

            if (bndryNode != IfxAdc_TmadcServReq_none)
            {
                /* boundary node is same as error node */
                IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (errorNode != bndryNode));
                IfxAdc_Tmadc_enableChannelEvent(channel, bndryNode, IfxAdc_TmadcEventSel_boundary);
            }

            /* Result node */
            resltNode = grpCfgPtr->grpSrvReq->resultNode;

            if (resltNode != IfxAdc_TmadcServReq_none)
            {
                /* Result node is same as error node */
                IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (errorNode != resltNode));
                /* Result node is same as boundary node */
                IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (bndryNode != resltNode));
                IfxAdc_Tmadc_enableChannelEvent(channel, resltNode, IfxAdc_TmadcEventSel_result);
            }
        }
    }
    else
    {
        if (config->channelSrvReq != NULL_PTR)
        {
            /* Error Node */
            errorNode = config->channelSrvReq->errorNode;

            if (errorNode != IfxAdc_TmadcServReq_none)
            {
                IfxAdc_Tmadc_enableChannelEvent(channel, errorNode, IfxAdc_TmadcEventSel_error);
            }

            /*Boundary node */
            bndryNode = config->channelSrvReq->boundaryNode;

            if (bndryNode != IfxAdc_TmadcServReq_none)
            {
                /* boundary node is same as error node */
                IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (errorNode != bndryNode));
                IfxAdc_Tmadc_enableChannelEvent(channel, bndryNode, IfxAdc_TmadcEventSel_boundary);
            }

            /* Result node */
            resltNode = config->channelSrvReq->resultNode;

            if (resltNode != IfxAdc_TmadcServReq_none)
            {
                /* Result node is same as error node */
                IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (errorNode != resltNode));
                /* Result node is same as boundary node */
                IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (bndryNode != resltNode));
                IfxAdc_Tmadc_enableChannelEvent(channel, resltNode, IfxAdc_TmadcEventSel_result);
            }
        }
    }

    /* Enable EMUX */
    chCfgReg.B.EMUXEN = config->enableEmux;
    {
        /* write back */
        chptr->CFG.U                = chCfgReg.U;
        modptr->RSLT[rsltReg].CFG.U = resCfgReg.U;
        chptr->STC.U                = chStcReg.U;
    }

    /* 8. enable the connection to SH unit */
    {
        chptr->CFG.B.EN = (uint32)1;
    }
    channel->state = IfxAdc_Tmadc_channelState_initialized;
}


void IfxAdc_Tmadc_initChannelConfig(IfxAdc_Tmadc_ChConfig *config, Ifx_ADC *adc)
{
    // initialize all to default values
    const IfxAdc_Tmadc_ChConfig defaultConfig = {
        .id             = IfxAdc_TmadcChannel_0,
        .moduleId       = IfxAdc_TmadcModule_0,
        .adcSFR         = NULL_PTR,
        .samplingTimeNS = 12.5f,
        .mode           = IfxAdc_TmadcOpMode_oneShot,
        .core           = IfxAdc_TmadcSarCore_0,
        .enableEmux     = FALSE,
        .resultCfg      = {
            .resultReg       = IfxAdc_TmadcResultReg_0,
            .waitForRead     = FALSE,
            .hysteresisEn    = FALSE,
            .boundMode       = FALSE,
            .enableTimestamp = FALSE,
            .boundCmpMode    = IfxAdc_TmadcBoundaryCmpMode_disable,
            .boundRegSel     = IfxAdc_TmadcBoundaryReg_0
        },
        .trigger       = NULL_PTR,
        .channelSrvReq = NULL_PTR,
        .channelPin    = NULL_PTR,
        .queueCfg      = NULL_PTR,
        .groupCfg      = NULL_PTR
    };

    *config        = defaultConfig;
    config->adcSFR = adc;
}


void IfxAdc_Tmadc_initGroupConfig(IfxAdc_Tmadc_GroupConfig *config)
{
    // initialize all to default values
    const IfxAdc_Tmadc_GroupConfig defaultConfig = {
        .channels        = 0u,
        .baseResultReg   = IfxAdc_TmadcResultReg_0,
        .trigger         = NULL_PTR,
        .mode            = IfxAdc_TmadcOpMode_oneShot,
        .waitForRead     = FALSE,
        .enableTimestamp = FALSE,
        .numChannels     = 0u,
        .moduleId        = IfxAdc_TmadcModule_0,
        .grpSrvReq       = NULL_PTR,
        .dmaCfg          = NULL_PTR,
        .groupResPtr     = NULL_PTR,
        .groupCallback   = NULL_PTR
    };

    *config = defaultConfig;
}


void IfxAdc_Tmadc_triggerChannel(IfxAdc_Tmadc_Ch *channel)
{
    IfxAdc_triggerTmadcChannel(&(MODULE_ADC.TMADC[channel->moduleId]), channel->id);
}


uint16 IfxAdc_Tmadc_readChannelResult(IfxAdc_Tmadc_Ch *channel)
{
    return channel->rsltSFR->B.RESULT;     /* read result */
}


void IfxAdc_Tmadc_configureBoundary(Ifx_ADC_TMADC *tmadc, IfxAdc_Tmadc_BoundaryConfig *config, IfxAdc_TmadcBoundaryReg reg)
{
    Ifx_ADC_TMADC              *sfrPtr    = tmadc;
    IfxAdc_Tmadc_TriggerConfig *trgcfgPtr = config->trigger;
    uint32                      delay     = 0u;

    /* Read register */
    Ifx_ADC_TMADC_BND_SEL       bndSel;
    Ifx_ADC_TMADC_BND_TRGCFG    bndtrgCfg;
    Ifx_ADC_TMADC_BFL_CFG       bflCfg;
    bndSel.U    = sfrPtr->BND[reg].SEL.U;
    bndtrgCfg.U = sfrPtr->BND[reg].TRGCFG.U;
    bflCfg.U    = sfrPtr->BFL[reg].CFG.U;

    /* configure UB and LB */
    bndSel.B.LB = config->lowerBound;
    bndSel.B.UB = config->upperBound;

    /* configure result register for boundary check*/
    bflCfg.B.RESEL = config->flagCfg.resultRegSel;
    bflCfg.B.BFM   = config->flagCfg.enable;

    /* Configuring trigger for boundary value update when shadow update mode is enabled */
    if (trgcfgPtr != NULL_PTR)
    {
        delay            = IfxAdc_getTmadcTriggerDelayValue(trgcfgPtr->delayNS);
        bndtrgCfg.B.TRD  = delay;
        bndtrgCfg.B.TRS  = trgcfgPtr->hwTrigger.muxSel;
        bndtrgCfg.B.TRMS = trgcfgPtr->hwTrigger.edgeSel;
    }

    /* Writing register back */
    sfrPtr->BND[reg].SEL.U    = bndSel.U;
    sfrPtr->BND[reg].TRGCFG.U = bndtrgCfg.U;
    sfrPtr->BFL[reg].CFG.U    = bflCfg.U;
}


void IfxAdc_Tmadc_configureEmux(Ifx_ADC_TMADC *tmadc, IfxAdc_Tmadc_EmuxConfig *emuxConfig)
{
    Ifx_ADC_TMADC              *sfrPtr = tmadc;
    IfxAdc_Tmadc_EmuxPinConfig *pinCfg = emuxConfig->emuxPins;
    /* Reading register */
    Ifx_ADC_TMADC_EMUXCFG       emuxCfg;
    emuxCfg.U = sfrPtr->EMUXCFG.U;

    /* EMUX Configuration */
    emuxCfg.B.CHCNT  = emuxConfig->count;
    emuxCfg.B.CISEL0 = emuxConfig->emuxCi0;
    emuxCfg.B.CISEL1 = emuxConfig->emuxCi1;
    emuxCfg.B.CS     = emuxConfig->exmuxCodeScheme;

    /* Pin configuration */
    if (pinCfg != NULL_PTR)
    {
        /* Emux control0 pin configuration */
        if (pinCfg->emuxCtrl0Pin != NULL_PTR)
        {
            IfxAdc_initTmadcEmuxCtrlPin(pinCfg->emuxCtrl0Pin, pinCfg->ctrl0PinMode, pinCfg->pinDriver);
        }

        /* Emux control1 pin configuration */
        if (pinCfg->emuxCtrl1Pin != NULL_PTR)
        {
            IfxAdc_initTmadcEmuxCtrlPin(pinCfg->emuxCtrl1Pin, pinCfg->ctrl1PinMode, pinCfg->pinDriver);
        }
    }

    /* Writing register back */
    sfrPtr->EMUXCFG.U = emuxCfg.U;
}


void IfxAdc_Tmadc_initGroup(IfxAdc_Tmadc_Group *grp, IfxAdc_Tmadc_GroupConfig *config)
{
    uint8          modId  = config->moduleId;
    Ifx_ADC_TMADC *modptr = &(MODULE_ADC.TMADC[modId]);
    /* Update Group handle */
    grp->numChannels      = config->numChannels;
    grp->channelset       = config->channels;
    grp->tmSFR            = modptr;
    grp->groupCallback    = config->groupCallback;
    grp->groupResPtr      = (uint32 *)config->groupResPtr;
    grp->timestampEnabled = config->enableTimestamp;
    grp->baseResultReg    = config->baseResultReg;

    /* Store the base address based on timestamp enabled/disabled in handle
     * This address will be used to configure source address of DMA
     * and at runtime it will be used to setupResult buffer.
     */
    if (config->enableTimestamp)
    {
        if (config->baseResultReg < IfxAdc_TmadcResultReg_7)
        {
            grp->sourceAddress = (uint32 *)(&(modptr->AW2.TS0.U));
        }
        else if (config->baseResultReg < IfxAdc_TmadcResultReg_14)
        {
            grp->sourceAddress = (uint32 *)(&(modptr->AW2.TS7.U));
        }
        else
        {
            grp->sourceAddress = (uint32 *)(&(modptr->AW2.TS14.U));
        }
    }
    else
    {
        grp->sourceAddress = (uint32 *)(&(modptr->AW2.RES0.U) + (config->baseResultReg));
    }

    //DMA Configuration
    if ((config->dmaCfg != NULL_PTR) && (config->groupResPtr != NULL_PTR))
    {
        IfxAdc_Tmadc_configureDmaForGroup(config, grp);
    }
    else
    {
        grp->dma.useDma = FALSE;
    }
}


uint16 IfxAdc_Tmadc_readTimestamp(IfxAdc_Tmadc_Ch *channel)
{
    uint16 timeStamp = 0;
    timeStamp = channel->tmstmpSFR->B.TIMESTAMP;
    return timeStamp;
}


IfxAdc_Tmadc_Result IfxAdc_Tmadc_readRawResult(IfxAdc_Tmadc_Ch *channel)
{
    IfxAdc_Tmadc_Result result = {0};
    result.result    = channel->rsltSFR->B.RESULT;
    result.timeStamp = channel->tmstmpSFR->B.TIMESTAMP;
    return result;
}


IfxAdc_Status IfxAdc_Tmadc_setupChannelResultBuffer(IfxAdc_Tmadc_Ch *channel, void *buffer, uint16 size)
{
    IfxAdc_Status status                = IfxAdc_Status_success;
    uint8         index                 = 0u;
    uint32        transferCount         = 0u;
    uint16        dmaCircularBufferSize = 0U;
    uint32       *localBuffer           = (uint32 *)buffer;

    /* Check if Fifo enabled, Buffer size is not zero and BufferPtr is not NULL */
    if ((size != 0U) && (buffer != NULL_PTR))
    {
        /* Update the handle for buffer address and size */
        channel->queue.bufferPtr    = (uint32 *)(buffer);
        channel->queue.writeIndex   = 0u;
        channel->queue.readIndex    = 0u;
        channel->queue.size         = size;
        channel->queue.bufferFull   = FALSE;
        channel->queue.validResult  = 0u;
        channel->queue.queueEnabled = TRUE;

        /* Flushing the fifo */
        for (index = 0u; index < size; index++)
        {
            localBuffer[index] = (uint16)0U;
        }

        /* If Dma configured update the destination address in Dma configuration */
        if (channel->queue.dma.useDma)
        {
            /*1. Update destination Address */
            IfxDma_Dma_setChannelDestinationAddress(&(channel->queue.dma.channel), (uint32)buffer);

            if (channel->queue.bufferType != IfxAdc_Tmadc_BufferType_circular)
            {
                transferCount = size;
                /* Update transfer count */
                IfxDma_Dma_setChannelTransferCount(&(channel->queue.dma.channel), transferCount);
                /* Enable channel hardware transaction request */
                IfxDma_enableChannelTransaction(channel->queue.dma.channel.dma, channel->queue.dma.channel.channelId);
            }
            else
            {
                dmaCircularBufferSize = IfxAdc_Tmadc_getDmaCircularBufferSize(size);
                /*2. Circular Buffer: Update Circular Address rang. */
                IfxDma_setCircularBufferDestinationLength(channel->queue.dma.channel.dma, channel->queue.dma.channel.channelId, dmaCircularBufferSize);
                /* Update transfer count */
                IfxDma_Dma_setChannelTransferCount(&(channel->queue.dma.channel), 1u);
            }
        }
    }
    else
    {
        /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
        channel->queue.queueEnabled = FALSE;
        status                      = IfxAdc_Status_failure;
    }

    return status;
}


IfxAdc_Status IfxAdc_Tmadc_updateGroupResultAddress(IfxAdc_Tmadc_Group *group, void *destAddr)
{
    IfxAdc_Status status = IfxAdc_Status_success;

    if (destAddr != NULL_PTR)
    {
        group->groupResPtr = (uint32 *)(destAddr);

        /* Enable hardware channel transaction request and update destination address */
        if (group->dma.useDma)
        {
            /* Update source address */
            IfxDma_Dma_setChannelSourceAddress(&(group->dma.channel), (uint32)group->sourceAddress);
            /* Update destination Address */
            IfxDma_Dma_setChannelDestinationAddress(&(group->dma.channel), (uint32)destAddr);
            /* Enable channel hardware transaction request */
            IfxDma_enableChannelTransaction(group->dma.channel.dma, group->dma.channel.channelId);
        }
    }
    else
    {
        status = IfxAdc_Status_failure;
    }

    return status;
}


void IfxAdc_Tmadc_writeChannelBuffer(IfxAdc_Tmadc_Ch *channel)
{
    Ifx_ADC_TMADC *modSfrPtr        = channel->modSFR;
    uint16         localWriteIndex  = channel->queue.writeIndex;
    uint16         localValidResult = channel->queue.validResult;
    boolean        localBufferFull  = channel->queue.bufferFull;
    uint32        *resultbufferPtr  = channel->queue.bufferPtr;
    uint16         localBufferSize  = channel->queue.size;

    if ((localBufferFull == TRUE) && (channel->queue.bufferType != IfxAdc_Tmadc_BufferType_circular))
    {
        /* Linear Buffer Full */
    }
    else
    {
        /* Store timestamp in buffer if enabled */
        if (channel->timeStampEnabled)
        {
            resultbufferPtr[localWriteIndex] = channel->tmstmpSFR->U;
            localWriteIndex                  = ((localWriteIndex + 1u) >= localBufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
            localValidResult++;
        }

        resultbufferPtr[localWriteIndex] = channel->rsltSFR->U;
        localWriteIndex                  = ((localWriteIndex + 1u) >= localBufferSize) ? 0u : (localWriteIndex + 1u); // Increment write index
        localValidResult++;
    }

    IfxAdc_clearTmadcResultFlag(modSfrPtr, channel->resultRegNum);

    /* Check if buffer full */
    if (localValidResult == localBufferSize)
    {
        localBufferFull = TRUE;
    }

    /* Update the handle */
    channel->queue.writeIndex  = localWriteIndex;
    channel->queue.bufferFull  = localBufferFull;
    channel->queue.validResult = (localBufferFull) ? localBufferSize : localValidResult;
}


void IfxAdc_Tmadc_writeGroupBuffer(IfxAdc_Tmadc_Group *group)
{
    uint16  numOfChannels = group->numChannels;
    uint16  index         = 0U;
    uint32 *resultBuffPtr = group->groupResPtr;
    uint32 *resultPtr     = (uint32 *)(group->sourceAddress);

    /* Extra loop to copy the timestamp */
    for (index = 0U; index <= numOfChannels; index++)
    {
        resultBuffPtr[index] = resultPtr[index];
    }
}


void IfxAdc_Tmadc_resultChannelIsr(IfxAdc_Tmadc_Ch *channel)
{
    IfxAdc_Tmadc_Queue *localquePtr = &(channel->queue);

    IfxAdc_Tmadc_writeChannelBuffer(channel);

    if ((localquePtr->bufferFull) && (localquePtr->buffFullCallback != NULL_PTR))
    {
        /*Callback for buffer full */
        (*localquePtr->buffFullCallback)();
    }
}


void IfxAdc_Tmadc_resultGroupIsr(IfxAdc_Tmadc_Group *group)
{
    IfxAdc_Tmadc_writeGroupBuffer(group);

    if (group->groupCallback != NULL_PTR)
    {
        (*group->groupCallback)();
    }
}


uint32 IfxAdc_Tmadc_readChannelCircularBufferResult(IfxAdc_Tmadc_Ch *channel)
{
    uint32 result           = 0U;
    uint16 localBufferSize  = channel->queue.size;
    uint16 localReadIndex   = channel->queue.readIndex;
    uint16 localValidResult = channel->queue.validResult;

    /* Return result 0 if buffer empty */
    if (localValidResult == 0U)
    {
        result = 0U;
    }
    else
    {
        /* If buffer is full the updating the read index since the current read index will contain the latest value */
        if (channel->queue.bufferFull)
        {
            localReadIndex = channel->queue.writeIndex;
        }

        /* Read immediate result from buffer based on read index */
        result                      = channel->queue.bufferPtr[localReadIndex];
        localReadIndex              = ((localReadIndex + 1u) >= localBufferSize) ? 0u : (localReadIndex + 1u); // Increment read index
        channel->queue.readIndex    = localReadIndex;                                                          //Update read index in handle
        channel->queue.validResult -= 1U;                                                                      //Decrement and update valid result count
        channel->queue.bufferFull   = FALSE;                                                                   //Update buffer full status
    }

    return result;
}


IFX_STATIC void IfxAdc_Tmadc_configureDma(IfxAdc_Tmadc_QueueConfig *queue, IfxAdc_Tmadc_Ch *channel)
{
    IfxAdc_Tmadc_DmaConfig *dmaCfgPtr         = (queue->dmaCfg);
    IfxAdc_Tmadc_Dma       *tmadcDmaHandlePtr = &(channel->queue.dma);
    IfxAdc_Tmadc_DmaSrvReq *dmaSrvReqPtr      = (dmaCfgPtr->dmaSrvReqCfg);
    Ifx_DMA                *dmaSFR            = (Ifx_DMA *)(IfxDma_cfg_indexMap[dmaCfgPtr->dmaId].module);

    //Update TMADC Handle
    tmadcDmaHandlePtr->useDma = TRUE;
    tmadcDmaHandlePtr->dmaId  = dmaCfgPtr->dmaId;

    //DMA module handle
    IfxDma_Dma dma;

    if (dmaSFR->CLC.B.DISS)
    {
        // DMA module configuration
        IfxDma_Dma_Config dmaConfig;
        IfxDma_Dma_initModuleConfig(&dmaConfig, dmaSFR);
        //Enable clock of DMA
        IfxDma_Dma_initModule(&dma, &dmaConfig);
    }

    IfxDma_Dma_createModuleHandle(&dma, dmaSFR);

    //DMA channel configuration
    IfxDma_Dma_ChannelConfig dmaCfg;
    IfxDma_Dma_initChannelConfig(&dmaCfg, &dma);

    /* Update DMA channel id from queue configuration to channel configuration */
    dmaCfg.channelId = dmaCfgPtr->channelId;

    /* Common DMA channel configuration
     * requestSource              = IfxDma_ChannelRequestSource_peripheral DMA request will be raised by TMADC result event
     * pattern                    = IfxDma_ChannelPattern_0_disable;
     * shadowControl              = IfxDma_ChannelShadow_none;
     * timestampEnabled           = FALSE;
     * wrapSourceInterruptEnabled = FALSE;*/

    dmaCfg.hardwareRequestEnabled = TRUE;        // will be triggered from TMADC result service request

    /* Source Address configuration */
    if (channel->timeStampEnabled)
    {
        dmaCfg.sourceAddress              = (uint32)&(channel->tmstmpSFR->U);      // Result register address
        dmaCfg.blockMode                  = (IfxDma_ChannelMove)IfxDma_ChannelMove_2;
        dmaCfg.sourceAddressCircularRange = IfxDma_ChannelIncrementCircular_8;     //Keep the same address
    }
    else
    {
        dmaCfg.sourceAddress              = (uint32)&(channel->rsltSFR->U);      // Result register address
        dmaCfg.blockMode                  = (IfxDma_ChannelMove)IfxDma_ChannelMove_1;
        dmaCfg.sourceAddressCircularRange = IfxDma_ChannelIncrementCircular_4;   //Keep the same address
    }

    dmaCfg.sourceAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
    dmaCfg.sourceAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;
    dmaCfg.sourceCircularBufferEnabled     = TRUE;

    /* Destination Address configuration */
    dmaCfg.destinationAddress                   = (uint32)(queue->bufferPtr);        //Destination buffer address
    dmaCfg.destinationAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
    dmaCfg.destinationAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;

    if (queue->bufferType == IfxAdc_Tmadc_BufferType_circular)
    {
        dmaCfg.transferCount                    = 1u;
        dmaCfg.requestMode                      = IfxDma_ChannelRequestMode_oneTransferPerRequest;
        dmaCfg.operationMode                    = IfxDma_ChannelOperationMode_continuous;     // hw request enable remains set after transaction
        dmaCfg.destinationAddressCircularRange  = (IfxDma_ChannelIncrementCircular)(IfxAdc_Tmadc_getDmaCircularBufferSize(queue->size));
        dmaCfg.destinationCircularBufferEnabled = TRUE;
        dmaCfg.wrapDestinationInterruptEnabled  = FALSE;
    }
    else //Linear Buffer
    {
        dmaCfg.transferCount                    = queue->size;
        dmaCfg.requestMode                      = IfxDma_ChannelRequestMode_oneTransferPerRequest;
        dmaCfg.operationMode                    = IfxDma_ChannelOperationMode_single;     // hw request is disabled after transaction
        dmaCfg.destinationAddressCircularRange  = IfxDma_ChannelIncrementCircular_none;
        dmaCfg.destinationCircularBufferEnabled = FALSE;
        dmaCfg.wrapDestinationInterruptEnabled  = FALSE;
        dmaCfg.channelInterruptEnabled          = TRUE;
        dmaCfg.channelInterruptControl          = IfxDma_ChannelInterruptControl_thresholdLimitMatch;     //Interrupt will be raised when TCOUNT = 0
    }

    dmaCfg.moveSize = IfxDma_ChannelMoveSize_32bit;

    /* DMA interrupt configuration */
    if (dmaSrvReqPtr != NULL_PTR)
    {
        dmaCfg.channelInterruptTypeOfService = dmaSrvReqPtr->typeOfService;
        dmaCfg.channelVmId                   = dmaSrvReqPtr->vmId;
        dmaCfg.channelInterruptPriority      = dmaSrvReqPtr->priority;
    }

    IfxDma_Dma_initChannel(&(tmadcDmaHandlePtr->channel), &dmaCfg);
}


IFX_STATIC void IfxAdc_Tmadc_configureDmaForGroup(IfxAdc_Tmadc_GroupConfig *groupConfig, IfxAdc_Tmadc_Group *group)
{
    IfxAdc_Tmadc_DmaConfig *dmaCfgPtr         = (groupConfig->dmaCfg);
    IfxAdc_Tmadc_Dma       *tmadcDmaHandlePtr = &(group->dma);
    IfxAdc_Tmadc_DmaSrvReq *dmaSrvReqPtr      = (dmaCfgPtr->dmaSrvReqCfg);
    Ifx_DMA                *dmaSFR            = (Ifx_DMA *)(IfxDma_cfg_indexMap[dmaCfgPtr->dmaId].module);

    //Update TMADC Handle
    tmadcDmaHandlePtr->useDma = TRUE;
    tmadcDmaHandlePtr->dmaId  = dmaCfgPtr->dmaId;

    //DMA module handle
    IfxDma_Dma dma;

    /* Initialize DMA */
    if (dmaSFR->CLC.B.DISS)
    {
        // DMA module configuration
        IfxDma_Dma_Config dmaConfig;
        IfxDma_Dma_initModuleConfig(&dmaConfig, dmaSFR);
        //Enable clock of DMA
        IfxDma_Dma_initModule(&dma, &dmaConfig);
    }

    IfxDma_Dma_createModuleHandle(&dma, dmaSFR);

    //DMA channel configuration
    IfxDma_Dma_ChannelConfig dmaCfg;
    IfxDma_Dma_initChannelConfig(&dmaCfg, &dma);

    /* Update DMA channel id from queue configuration to channel configuration */
    dmaCfg.channelId = dmaCfgPtr->channelId;

    /* Common DMA channel configuration */
    dmaCfg.requestSource              = IfxDma_ChannelRequestSource_peripheral; //DMA request will be raised by TMADC result event
    dmaCfg.pattern                    = IfxDma_ChannelPattern_0_disable;
    dmaCfg.shadowControl              = IfxDma_ChannelShadow_none;
    dmaCfg.timestampEnabled           = FALSE;
    dmaCfg.wrapSourceInterruptEnabled = FALSE;
    dmaCfg.hardwareRequestEnabled     = TRUE;                                    // will be triggered from TMADC result service request

    if (groupConfig->enableTimestamp)
    {
        dmaCfg.transferCount = groupConfig->numChannels + 1U;                    //Adding 1 for timestamp value
    }
    else
    {
        dmaCfg.transferCount = groupConfig->numChannels;
    }

    dmaCfg.blockMode                       = IfxDma_ChannelMove_1;
    dmaCfg.sourceAddress                   = (uint32)(group->sourceAddress);         // Result/Timestamp register address
    dmaCfg.sourceAddressCircularRange      = IfxDma_ChannelIncrementCircular_none;   //Keep the same address
    dmaCfg.sourceAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
    dmaCfg.sourceAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;
    dmaCfg.sourceCircularBufferEnabled     = FALSE;

    /* Destination Address configuration */
    dmaCfg.destinationAddress                   = (uint32)(groupConfig->groupResPtr);        //Destination buffer address
    dmaCfg.destinationAddressIncrementStep      = IfxDma_ChannelIncrementStep_1;
    dmaCfg.destinationAddressIncrementDirection = IfxDma_ChannelIncrementDirection_positive;

    dmaCfg.requestMode                          = IfxDma_ChannelRequestMode_completeTransactionPerRequest;
    dmaCfg.operationMode                        = IfxDma_ChannelOperationMode_single; // hw request is disabled after transaction
    dmaCfg.destinationAddressCircularRange      = IfxDma_ChannelIncrementCircular_none;
    dmaCfg.destinationCircularBufferEnabled     = FALSE;
    dmaCfg.wrapDestinationInterruptEnabled      = FALSE;
    dmaCfg.channelInterruptEnabled              = TRUE;
    dmaCfg.channelInterruptControl              = IfxDma_ChannelInterruptControl_thresholdLimitMatch; //Interrupt will be raised when TCOUNT = 0
    dmaCfg.moveSize                             = IfxDma_ChannelMoveSize_32bit;

    /* DMA interrupt configuration */
    if (dmaSrvReqPtr != NULL_PTR)
    {
        dmaCfg.channelInterruptTypeOfService = dmaSrvReqPtr->typeOfService;
        dmaCfg.channelVmId                   = dmaSrvReqPtr->vmId;
        dmaCfg.channelInterruptPriority      = dmaSrvReqPtr->priority;
    }

    IfxDma_Dma_initChannel(&(tmadcDmaHandlePtr->channel), &dmaCfg);
}


IFX_STATIC IfxAdc_Status IfxAdc_Tmadc_initBuffer(IfxAdc_Tmadc_QueueConfig *queueConfig, IfxAdc_Tmadc_Ch *channel)
{
    uint32       *localBufferPtr = (uint32 *)(queueConfig->bufferPtr);
    IfxAdc_Status status         = IfxAdc_Status_success;
    uint8         index          = 0u;
    uint16        buffersize     = queueConfig->size;

    /* Check if Buffer size is not zero and BufferPtr is not NULL */
    if ((buffersize != 0U) && (localBufferPtr != NULL_PTR))
    {
        /* Update the handle for buffer address and size */
        channel->queue.bufferPtr        = (uint32 *)localBufferPtr;
        channel->queue.writeIndex       = 0u;
        channel->queue.readIndex        = 0u;
        channel->queue.size             = buffersize;
        channel->queue.bufferFull       = FALSE;
        channel->queue.validResult      = 0u;
        channel->queue.queueEnabled     = TRUE;
        channel->queue.buffFullCallback = queueConfig->bufferFullCallback;
        channel->queue.bufferType       = queueConfig->bufferType;

        /* Flushing the user provided buffer */
        for (index = 0u; index < buffersize; index++)
        {
            localBufferPtr[index] = 0U;
        }
    }
    else
    {
        /* Update queueEnable to FALSE if BufferPtr is NULL or size is 0 */
        channel->queue.queueEnabled = FALSE;
        status                      = IfxAdc_Status_failure;
    }

    return status;
}


IFX_STATIC void IfxAdc_Tmadc_updateHandleInfoFromDma(IfxAdc_Tmadc_Ch *channel)
{
    uint32 *resultbufferPtr  = channel->queue.bufferPtr;
    uint16  localReadIndex   = channel->queue.readIndex;
    uint16  localWriteIndex  = 0u;
    uint32 *writePtr         = (uint32 *)(channel->queue.dma.channel.channel->DADR.U);
    uint16  bufferSize       = channel->queue.size;
    boolean bufferWrapStatus = channel->queue.dma.channel.channel->CHCSR.B.WRPD;

    localWriteIndex = (uint16)(writePtr - resultbufferPtr);

    /* Buffer empty : Read index same as write index and buffer not full*/
    if ((localReadIndex == localWriteIndex) && (!bufferWrapStatus))
    {
        channel->queue.validResult = 0u;
    }
    else if ((localReadIndex == localWriteIndex) && (bufferWrapStatus)) //Buffer full
    {
        channel->queue.validResult = bufferSize;                        //buffer full
        channel->queue.bufferFull  = TRUE;
    }
    else if ((localReadIndex < localWriteIndex) && (bufferWrapStatus))  //Buffer overflow. Update read Index
    {
        /* Buffer overflow. Updating the read index since the current read index will contain the new results */
        channel->queue.validResult = bufferSize;                        //buffer full
        channel->queue.bufferFull  = TRUE;
        channel->queue.readIndex   = localWriteIndex;
    }
    else if (localWriteIndex < localReadIndex)
    {
        channel->queue.validResult = (uint16)(bufferSize - localReadIndex + localWriteIndex);
    }
    else
    {
        channel->queue.validResult = (uint16)(localWriteIndex - localReadIndex);
    }

    /* Clear buffer warp status */
    if (bufferWrapStatus)
    {
        IfxDma_getAndClearChannelWrapDestinationBufferInterrupt(channel->queue.dma.channel.dma, channel->queue.dma.channel.channelId);
    }

    /*Update information in handle from DMA address */
    channel->queue.writeIndex = localWriteIndex;
}


uint16 IfxAdc_Tmadc_getNumberOfChannelResults(IfxAdc_Tmadc_Ch *channel)
{
    uint16 validResult = 0u;

    if (!channel->queue.dma.useDma)
    {
        validResult = channel->queue.validResult;
    }
    else //DMA: Calculate valid results from DMA destination address
    {
        IfxAdc_Tmadc_updateHandleInfoFromDma(channel);
        validResult = channel->queue.validResult;
    }

    return validResult;
}


void IfxAdc_Tmadc_runModule(IfxAdc_Tmadc *tmadc)
{
    Ifx_ADC_TMADC_MODCFG modCfg;
#if !defined(IFX_ILLD_PPU_USAGE)
    boolean              timeExpire = FALSE;
    uint32               stmFreq, waitTicks;
    uint8                calStatus;
    uint8                modStatus;
    uint64               stmCountBegin;
    uint64               currentCount;
#endif

    modCfg.U                = tmadc->modSFR->MODCFG.U;
    modCfg.B.SUCAL          = (tmadc->calEnabled) ? 1u : 0u;
    modCfg.B.RUN            = 1u;
    tmadc->modSFR->MODCFG.U = modCfg.U;

    if (tmadc->calEnabled)
    {
        tmadc->state = IfxAdc_Tmadc_moduleState_calibration;
#if defined(IFX_ILLD_PPU_USAGE)

        while ((tmadc->modSFR->MODSTAT.B.CALPH != IFXADC_TMADC_CALIBRATION_COMPLETE) || (tmadc->modSFR->MODSTAT.B.PONPH != IFXADC_TMADC_POWERONPHASE_COMPLETE))
        {}

        tmadc->state  = IfxAdc_Tmadc_moduleState_run;
#else
        stmFreq       = IfxClock_getStmFrequency();
        waitTicks     = (uint32)(((uint64)stmFreq * IFXADC_TMADC_MAX_TIMEOUT) / 1000000000U);
        stmCountBegin = IfxStm_get(&MODULE_CPU0);
        currentCount  = stmCountBegin;

        /* wait in this while loop until Calibration is complete */
        do
        {
            calStatus = tmadc->modSFR->MODSTAT.B.CALPH;
            modStatus = tmadc->modSFR->MODSTAT.B.PONPH;

            if (((currentCount - stmCountBegin) > waitTicks) && ((calStatus != IFXADC_TMADC_CALIBRATION_COMPLETE) \
                                                                 || (modStatus != IFXADC_TMADC_POWERONPHASE_COMPLETE)))
            {
                /* Timeout happened and calibration is not completed yet */
                timeExpire = TRUE;
            }

            /* Get current STM tick */
            currentCount = IfxStm_get(&MODULE_CPU0);
        } while (((calStatus != IFXADC_TMADC_CALIBRATION_COMPLETE) || (modStatus != IFXADC_TMADC_POWERONPHASE_COMPLETE)) && (timeExpire == FALSE));

        if (timeExpire == TRUE)
        {
            tmadc->state = IfxAdc_Tmadc_moduleState_calibrationError;
        }
        else
        {
            tmadc->state = IfxAdc_Tmadc_moduleState_run;
        }

#endif
    }
    else      /* Calibration not enabled */
    {
#if defined(IFX_ILLD_PPU_USAGE)

        while (tmadc->modSFR->MODSTAT.B.PONPH != IFXADC_TMADC_POWERONPHASE_COMPLETE)
        {}

        tmadc->state = IfxAdc_Tmadc_moduleState_run;

#else
        stmFreq       = IfxClock_getStmFrequency();
        waitTicks     = (uint32)(((uint64)stmFreq * IFXADC_TMADC_POWERON_TIMEOUT) / 1000000000U);
        stmCountBegin = IfxStm_get(&MODULE_CPU0);
        currentCount  = stmCountBegin;

        /* wait in this while loop until Calibration is complete */
        do
        {
            modStatus = tmadc->modSFR->MODSTAT.B.PONPH;

            if (((currentCount - stmCountBegin) > waitTicks) && (modStatus != IFXADC_TMADC_POWERONPHASE_COMPLETE))
            {
                /* Timeout happened and calibration is not completed yet */
                timeExpire = TRUE;
            }

            /* Get current STM tick */
            currentCount = IfxStm_get(&MODULE_CPU0);
        } while ((modStatus != IFXADC_TMADC_POWERONPHASE_COMPLETE) && (timeExpire == FALSE));

        if (timeExpire == TRUE)
        {
            tmadc->state = IfxAdc_Tmadc_moduleState_notPoweredOn;
        }
        else
        {
            tmadc->state = IfxAdc_Tmadc_moduleState_run;
        }

#endif
    }
}


void IfxAdc_Tmadc_initMonitorChannelConfig(IfxAdc_Tmadc_MonitorChannelConfig *config, Ifx_ADC *adc)
{
    // initialize all to default values
    const IfxAdc_Tmadc_MonitorChannelConfig defaultConfig = {
        .id             = IfxAdc_TmadcMonitorChannel_0,
        .moduleId       = IfxAdc_TmadcModule_0,
        .adcSFR         = NULL_PTR,
        .samplingTimeNS = 1000,
        .mode           = IfxAdc_TmadcOpMode_oneShot,
        .input          = IfxAdc_TmadcMonitorChannelInput_coreSupply,
        .enableChannel  = FALSE,
        .resultCfg      = {
            .waitForRead  = FALSE,
            .boundMode    = FALSE,
            .boundCmpMode = IfxAdc_TmadcBoundaryCmpMode_disable,
            .boundRegSel  = IfxAdc_TmadcBoundaryReg_0
        },
        .channelSrvReq    = {
            .errorNode    = IfxAdc_TmadcServReq_none,
            .boundaryNode = IfxAdc_TmadcServReq_none,
            .resultNode   = IfxAdc_TmadcServReq_none,
        },
    };

    *config        = defaultConfig;
    config->adcSFR = adc;
}


void IfxAdc_Tmadc_initMonitorChannel(IfxAdc_Tmadc_MonitorCh *channel, IfxAdc_Tmadc_MonitorChannelConfig *config)
{
    uint8                               modId     = config->moduleId;
    uint8                               chId      = (uint8)(config->id);
    Ifx_ADC_TMADC                      *modptr    = &(config->adcSFR->TMADC[modId]);
    Ifx_ADC_TMADC_MCH                  *chptr     = &(modptr->MCH[chId]);
    IfxAdc_Tmadc_MonitorChResultConfig *resCfg    = &(config->resultCfg);
    IfxAdc_TmadcServReq                 errorNode = IfxAdc_TmadcServReq_0;
    IfxAdc_TmadcServReq                 bndryNode = IfxAdc_TmadcServReq_0;
    IfxAdc_TmadcServReq                 resltNode = IfxAdc_TmadcServReq_0;

    /* Reading register */
    Ifx_ADC_TMADC_MRSLT_CFG             resCfgReg;
    Ifx_ADC_TMADC_MCH_CFG               chCfgReg;

    chCfgReg.U  = chptr->CFG.U;
    resCfgReg.U = modptr->MRSLT[chId].CFG.U;

    /* Update Channel handle */
    channel->id       = (IfxAdc_TmadcMonitorChannel)chId;
    channel->modSFR   = modptr;
    channel->chSFR    = chptr;
    channel->rsltSFR  = &(modptr->MRES[chId]);
    channel->moduleId = (IfxAdc_TmadcModule)modId;

    /* Channel configuration*/
    if (config->mode == IfxAdc_TmadcOpMode_continuous)
    {
        chCfgReg.B.ATREN = 1u;
    }

    if (config->samplingTimeNS <= 1000)
    {
        chCfgReg.B.ST = IFXADC_TMADC_MCH_MIN_SAMPLING_TIME;
    }
    else
    {
        chCfgReg.B.ST = IfxAdc_getTmadcSamplingTimeValue(config->samplingTimeNS);
    }

    chCfgReg.B.SEL = config->input;
    chCfgReg.B.EN  = config->enableChannel;

    /* Result configuration */
    resCfgReg.B.BNDMODE = resCfg->boundMode;
    resCfgReg.B.BNDSEL  = resCfg->boundCmpMode;
    resCfgReg.B.BNDSELR = resCfg->boundRegSel;
    resCfgReg.B.WFR     = resCfg->waitForRead;

    /* Error Node */
    errorNode = config->channelSrvReq.errorNode;

    if (errorNode != IfxAdc_TmadcServReq_none)
    {
        modptr->SR[errorNode].CFG.U |= (1u << (chId + IFXADC_TMADC_MCH_OFFSET));
    }

    /*Boundary node */
    bndryNode = config->channelSrvReq.boundaryNode;

    if (bndryNode != IfxAdc_TmadcServReq_none)
    {
        /* boundary node is same as error node */
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (errorNode != bndryNode));
        modptr->SR[bndryNode].CFG.U |= (1u << (chId + IFXADC_TMADC_MCH_OFFSET));
    }

    /* Result node */
    resltNode = config->channelSrvReq.resultNode;

    if (resltNode != IfxAdc_TmadcServReq_none)
    {
        /* Result node is same as error node */
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (errorNode != resltNode));
        /* Result node is same as boundary node */
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (bndryNode != resltNode));
        modptr->SR[resltNode].CFG.U |= (1u << (chId + IFXADC_TMADC_MCH_OFFSET));
    }

    /* Writing Register back */
    modptr->MRSLT[chId].CFG.U = resCfgReg.U;
    chptr->CFG.U              = chCfgReg.U;
}


void IfxAdc_Tmadc_triggerMonitorChannel(IfxAdc_Tmadc_MonitorCh *channel)
{
    IfxAdc_triggerTmadcMonitorChannel(channel->modSFR, channel->id);
}


uint16 IfxAdc_Tmadc_readMonitorChannelResult(IfxAdc_Tmadc_MonitorCh *channel)
{
    return channel->rsltSFR->B.RESULT;     /* read result */
}
