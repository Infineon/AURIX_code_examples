/**
 * \file IfxSmmSysMode.h
 * \brief SMM  basic functionality
 * \ingroup IfxLld_Smm
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_SmmSysMode_Usage How to use the SMM system mode driver?
 * \ingroup IfxLld_Smm
 *
 * SMM sys mode driver provides the functionality to move device to different modes which ensures the device operates with minimum required power
 * Processing units can be individually set into IDLE mode depending on application needs and wake up can happen through interrupt, watchdog or other sources.
 *
 * SMM driver supports moving the core to IDLE/RUN state and system to sleep state.
 * To move the system to standby refer PMS driver.
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_SmmSysMode_Preparation Preparation
 * \subsection IfxLld_SmmSysMode_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Smm/Std/IfxSmmSysMode.h>
 * \endcode
 *
 * \subsection IfxLld_SmmSysMode_Idle IDLE mode transition
 * \code
 * {
 *   //IDLE mode is selected by each individual CPU
 *   IfxSmmSysMode_sysModeConfig(IfxSmmSysMode_RqPwMd_idle, 0x00); //Entry to the respective Idle mode is decided by each individual CPU
 *
 *   // Set CPU1 to idle mode
 *   IfxSmmSysMode_setCoreIdle(IfxCpu_ResourceCpu_1);
 *
 *   if(TRUE == IfxSmmSysMode_isCoreIdle(IfxCpu_ResourceCpu_1))
 *   {
 *
 *   }
 *
 *   //Application could bring CPU1 to run mode using IfxSmmSysMode_setCoreRun API.
 *   IfxSmmSysMode_setCoreRun(IfxCpu_ResourceCpu_1);
 *
 *   //Exit from idle mode can also happen via interrupt request etc
 * }
 *
 * {
 *    //Application could select if a single CPU could send the idle request to other CPU or respective IDLE mode is selected by each individual CPU
 *    IfxSmmSysMode_sysModeConfig(IfxSmmSysMode_RqPwMd_idle, 0x01); //CPU0 Idle request will send all CPUs in Idle
 *    IfxSmmSysMode_setCoreIdle(IfxCpu_ResourceCpu_0);
 *
 *    //Exiting idle mode : Interrupt request, NMI, reset event etc
 *  }
 * \endcode
 *
 * \subsection IfxLld_SmmSysMode_Sleep Sleep mode transition
 * \code
 *
 *  // Enable sleep mode for the required modules as per application need
 *  // IFXSMM_DISABLE_MODULES_DURING_SLEEP hook defined below is for illustration purpose.
 *  #define IFXSMM_DISABLE_MODULES_DURING_SLEEP ({ \
 *  IfxAsclin_setSleepMode(&MODULE_ASCLIN0, IfxAsclin_SleepMode_enable);\
 *  IfxAsclin_setSleepMode(&MODULE_ASCLIN1, IfxAsclin_SleepMode_enable);\
 *  IfxHssl_setHsslSleepMode(&MODULE_HSSL1, IfxHssl_Hssl_SleepMode_enable);\
 *  })
 *
 *  //Below macro is used to disable other CPU watchdog apart from master CPU watchdog
 *  #define IFXSMM_IDLE_CPU_DISABLE_WATCHDOG ({ \
 *  masterCpu = IfxSmmSysMode_getMasterCpu();\
 *  IfxCpu_disableInterruptsAllExceptMaster(masterCpu);\
 *  IfxSmmSysMode_setAllIdleExceptMasterCpu(masterCpu);\
 *  })
 *
 *  #define IFXSMM_CLOCK_REDUCTION ({ \
 *  IfxClock_switchToBackupClock(&IfxClock_defaultClockConfig);\
 *   CLOCK_SYSPLLCON0.B.PLLPWR = 0u;\
 *  CLOCK_PERPLLCON0.B.PLLPWR = 0u;\
 *  CLOCK_PERCCUCON0.U = 0x00000000;\
 *  CLOCK_PERCCUCON1.U = 0x00000000;\
 *  IfxClock_switchToLowPowerMode(IfxClock_LowPowerDivRatio_divBy1);\
 * })
 *
 *  // If application needs to disable bank in flash below macro can be used.
 *  // iF all the banks are in sleep,..the code "IfxSmmSysMode_continueSleepSequenceInRAM" should be located to ram
 *  #define IFXSMM_DISABLE_FLASH ({ \
 *  volatile uint32  *sleepaddr = (volatile uint32 *)(0xF8080000U | 0xAA00U);  \
 *   *sleepaddr = 0x10FFFU;   \
 *  //Waiting for PFLASH[0-5] and Host DFLASH to enter sleep mode           \
 *   while (!((DMU_HCI_SLEEP.U & 0x10FFFU) == 0x10FFFU))                \
 *   {}     \
 * })
 *
 *  IfxSmmSysMode_startSleepSequenceinFlash();
 *
 * //Optionally standard layer API is also provided to request sleep mode.
 * IfxSmmSysMode_requestSleep(IfxCpu_ResourceCpu_0);
 *
 * //API is also provided to check if power management status of CPU.
 * //To check if IDLE mode is requested
 * if(IfxSmmSysMode_Pmst_idleModeRequest == IfxSmmSysMode_getCoreStatus(IfxSmmSysMode_Resource_Cpu_0))
 * {
 * }
 *
 * //To check if sleep mode is requested
 * if(IfxSmmSysMode_Pmst_sleepModeRequest == IfxSmmSysMode_getCoreStatus(IfxSmmSysMode_Resource_Cpu_0))
 * {
 * }
 *
 * \endcode
 *
 * \defgroup IfxLld_Smm_Std_SysMode SysMode Basic Functionality
 * \ingroup IfxLld_Smm_Std
 * \defgroup IfxLld_Smm_Std_SysMode_Enumerations Enumerations
 * \ingroup IfxLld_Smm_Std_SysMode
 * \defgroup IfxLld_Smm_Std_SysMode_DataStructures Data Structures
 * \ingroup IfxLld_Smm_Std_SysMode
 * \defgroup IfxLld_Smm_Std_SysMode_SystemModes System Modes
 * \ingroup IfxLld_Smm_Std_SysMode
 * \defgroup IfxLld_Smm_Std_SysMode_ModuleFunctions Module functions
 * \ingroup IfxLld_Smm_Std_SysMode
 */

#ifndef IFXSMMSYSMODE_H
#define IFXSMMSYSMODE_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxSmm_cfg.h"
#include "Cpu/Std/IfxCpu.h"
#include "IfxClock_reg.h"
#include "Smm/Std/IfxSmm.h"
#include "Wtu/Std/IfxWtu.h"
#include "Clock/Std/IfxClock.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro for Host Pflash and Dflash mask
 */
#define IFXSMMSYSMODE_HOST_PFLASH_DFLASH_MASK (0x10FFFU)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Smm_Std_SysMode_Enumerations
 * \{ */
/** \brief Power Management Status[PMST]
 */
typedef enum
{
    IfxSmmSysMode_Pmst_undefined          = 0,  /**< \brief Undefined state */
    IfxSmmSysMode_Pmst_normalRunMode      = 1,  /**< \brief Normal Run Mode */
    IfxSmmSysMode_Pmst_idleModeRequest    = 2,  /**< \brief CPU Idle Mode requested */
    IfxSmmSysMode_Pmst_idleModeRequestAwk = 3,  /**< \brief CPU Idle Mode acknowledged */
    IfxSmmSysMode_Pmst_sleepModeRequest   = 4,  /**< \brief Sleep Mode requested */
    IfxSmmSysMode_Pmst_standbyModeRequest = 6   /**< \brief Standby Mode requested */
} IfxSmmSysMode_Pmst;

/** \brief List of the available CPU resources
 */
typedef enum
{
    IfxSmmSysMode_Resource_Cpu_0,   /**< \brief Cpu 0  */
    IfxSmmSysMode_Resource_Cpu_1,   /**< \brief Cpu 1  */
    IfxSmmSysMode_Resource_Cpu_2,   /**< \brief Cpu 2  */
    IfxSmmSysMode_Resource_Cpu_3,   /**< \brief Cpu 3  */
    IfxSmmSysMode_Resource_Cpu_4,   /**< \brief Cpu 4  */
    IfxSmmSysMode_Resource_Cpu_5,   /**< \brief Cpu 5  */
    IfxSmmSysMode_Resource_Cpu_cs   /**< \brief CSRM CPU */
} IfxSmmSysMode_Resource;

/** \brief System power mode
 * As defined in SMM_PMCSR[x].B.REQSLP. Also refer PMSTAT0 register for halt mode related information.
 */
typedef enum
{
    IfxSmmSysMode_RqPwMd_run       = 0,   /**< \brief Request CPU Run Mode */
    IfxSmmSysMode_RqPwMd_idle      = 1,   /**< \brief Request CPU Idle Mode */
    IfxSmmSysMode_RqPwMd_sleep     = 2,   /**< \brief Request CPU Sleep Mode */
    IfxSmmSysMode_RqPwMd_standby   = 3,   /**< \brief Request CPU Standby Mode */
    IfxSmmSysMode_RqPwMd_undefined = 255  /**< \brief Undefined Mode */
} IfxSmmSysMode_RqPwMd;

/** \} */

/** \addtogroup IfxLld_Smm_Std_SysMode_SystemModes
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Api to configure the bit-fields "CPUIDLSEL" and "CPUSEL" of register SMM_PMSWCR1. Used for CPU selection for Idle,Sleep and Standby mode.
 * \param powerMode Mode configuration
 * \param reqMode CPUIDLSEL[CPU selection for Idle mode]:
 * Note: All other CPUIDLSEL bit combinations are reserved.
 * 000B Entry to the respective Idle mode is decided by each individual
 * CPU.
 * 001B CPU0 Idle request will send all CPUs in Idle.
 * 010B CPU1 Idle request will send all CPUs in Idle.
 * 011B CPU2 Idle request will send all CPUs in Idle.
 * 100B CPU3 Idle request will send all CPUs in Idle.
 * 101B CPU4 Idle request will send all CPUs in Idle.
 * 110B CPU5 Idle request will send all CPUs in Idle.
 *
 * CPUSEL[CPU selection for Sleep and Standby mode]:
 * Note: All other CPUSEL bit combinations are reserved.
 * 001B Only CPU0 can trigger power down modes.
 * 010B Only CPU1 can trigger power down modes.
 * 011B Only CPU2 can trigger power down modes.
 * 100B Only CPU3 can trigger power down modes.
 * 101B Only CPU4 can trigger power down modes.
 * 110B Only CPU5 can trigger power down modes.
 * 111B Entry to power down modes is unanimously decided by all the
 * CPUs.
 * \return None
 */
IFX_INLINE void IfxSmmSysMode_sysModeConfig(const IfxSmmSysMode_RqPwMd powerMode, const uint8 reqMode);

/** \brief Enable Global mode entry to system modes for all Processing units
 * \return None
 */
IFX_INLINE void IfxSmmSysMode_enableGlobalSystemModeEntry(void);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Sleep sequence in Flash memory
 * \return None
 */
IFX_EXTERN void IfxSmmSysMode_startSleepSequenceinFlash(void);

/** \brief Sleep sequence in RAM memory
 * \return None
 */
IFX_EXTERN void IfxSmmSysMode_continueSleepSequenceInRAM(void);

/** \brief Placing all CPUs to Idle state except the Master CPU
 * \param masterCpu Master Core(Cpu) Id.
 * \return None
 */
IFX_EXTERN void IfxSmmSysMode_setAllIdleExceptMasterCpu(const IfxCpu_ResourceCpu masterCpu);

/** \brief API to get current status of CPU
 * \param cpuIndex Index to identify different CPU cores
 * \return Current status of the CPU
 */
IFX_EXTERN IfxSmmSysMode_Pmst IfxSmmSysMode_getCoreStatus(IfxSmmSysMode_Resource cpuIndex);

/** \} */

/** \addtogroup IfxLld_Smm_Std_SysMode_ModuleFunctions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Set a given CPU as a Master CPU i.e. ability to trigger power down modes
 * \param cpuIndex Index to identify different CPU cores
 * \return None
 */
IFX_INLINE void IfxSmmSysMode_setMasterCpu(const IfxCpu_ResourceCpu cpuIndex);

/** \brief Gets the index of Master CPU
 * \return Extraction of Master CPU Information
 */
IFX_INLINE IfxCpu_ResourceCpu IfxSmmSysMode_getMasterCpu(void);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API evaluates if CPU is in idle state
 * \param cpuIndex Index to identify different CPU cores
 * \return TRUE --> CPU in idle state
 * FALSE --> CPU not in idle state
 */
IFX_INLINE boolean IfxSmmSysMode_isCoreIdle(IfxCpu_ResourceCpu cpuIndex);

/** \brief API to set core to Idle mode
 * \param cpuIndex specifies cpu index
 * \return None
 */
IFX_INLINE void IfxSmmSysMode_setCoreIdle(IfxCpu_ResourceCpu cpuIndex);

/** \brief API to set CPU core to run mode
 * \param cpuIndex specifies cpu index
 * \return None
 */
IFX_INLINE void IfxSmmSysMode_setCoreRun(IfxCpu_ResourceCpu cpuIndex);

/** \brief API to request sleep mode
 * \param cpuIndex specifies cpu index
 * \return None
 */
IFX_INLINE void IfxSmmSysMode_requestSleep(IfxCpu_ResourceCpu cpuIndex);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxSmmSysMode_setMasterCpu(const IfxCpu_ResourceCpu cpuIndex)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
    SMM_PMSWCR1.B.CPUSEL = cpuIndex + 1;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmmSysMode_sysModeConfig(const IfxSmmSysMode_RqPwMd powerMode, const uint8 reqMode)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

    switch (powerMode)
    {
    case IfxSmmSysMode_RqPwMd_idle:
        SMM_PMSWCR1.B.CPUIDLSEL = reqMode;
        break;

    case IfxSmmSysMode_RqPwMd_sleep:
    case IfxSmmSysMode_RqPwMd_standby:
        SMM_PMSWCR1.B.CPUSEL = reqMode;
        break;

    default:
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE IfxCpu_ResourceCpu IfxSmmSysMode_getMasterCpu(void)
{
    return (IfxCpu_ResourceCpu)(SMM_PMSWCR1.B.CPUSEL - 1);
}


IFX_INLINE void IfxSmmSysMode_enableGlobalSystemModeEntry(void)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
    SMM_PMSWCR1.B.PROCMODEEN = 1u;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE boolean IfxSmmSysMode_isCoreIdle(IfxCpu_ResourceCpu cpuIndex)
{
    boolean status = FALSE;

    if (cpuIndex < (IfxCpu_ResourceCpu)IFXCPU_NUM_SAFE_MODULES)
    {
        status = (MODULE_SMM.PMCSR[cpuIndex].B.PMST == IfxSmmSysMode_Pmst_idleModeRequestAwk) ? TRUE : FALSE;
    }
    else if (cpuIndex == IfxCpu_ResourceCpu_6)
    {
        status = (MODULE_SMM.PMCSRCS.B.PMST == IfxSmmSysMode_Pmst_idleModeRequestAwk) ? TRUE : FALSE;
    }
    else
    {}

    return status;
}


IFX_INLINE void IfxSmmSysMode_setCoreIdle(IfxCpu_ResourceCpu cpuIndex)
{
    if (cpuIndex < (IfxCpu_ResourceCpu)IFXCPU_NUM_SAFE_MODULES)
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
        MODULE_SMM.PMCSR[cpuIndex].B.REQSLP = IfxSmmSysMode_RqPwMd_idle;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
    }
    else if (cpuIndex == IfxCpu_ResourceCpu_6)
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_config);
#endif
        MODULE_SMM.PMCSRCS.B.REQSLP = IfxSmmSysMode_RqPwMd_idle;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_run);
#endif
    }
    else
    {}
}


IFX_INLINE void IfxSmmSysMode_setCoreRun(IfxCpu_ResourceCpu cpuIndex)
{
    if (cpuIndex < (IfxCpu_ResourceCpu)IFXCPU_NUM_SAFE_MODULES)
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
        MODULE_SMM.PMCSR[cpuIndex].B.REQSLP = IfxSmmSysMode_RqPwMd_run;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
    }
    else if (cpuIndex == IfxCpu_ResourceCpu_6)
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_config);
#endif
        MODULE_SMM.PMCSRCS.B.REQSLP = IfxSmmSysMode_RqPwMd_run;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_run);
#endif
    }
    else
    {}
}


IFX_INLINE void IfxSmmSysMode_requestSleep(IfxCpu_ResourceCpu cpuIndex)
{
    if (cpuIndex < (IfxCpu_ResourceCpu)IFXCPU_NUM_SAFE_MODULES)
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
        MODULE_SMM.PMCSR[cpuIndex].B.REQSLP = IfxSmmSysMode_RqPwMd_sleep;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
    }
    else if (cpuIndex == IfxCpu_ResourceCpu_6)
    {
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_config);
#endif
        MODULE_SMM.PMCSRCS.B.REQSLP = IfxSmmSysMode_RqPwMd_sleep;
#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_run);
#endif
    }
    else
    {}
}


#endif /* IFXSMMSYSMODE_H */
