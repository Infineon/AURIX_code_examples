/**
 * \file IfxEgtm_Tim_In.h
 * \brief EGTM IN details
 * \ingroup IfxLld_Egtm
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Egtm_Tim_In_Usage How to use the TIM Input Interface layer?
 * \ingroup IfxLld_Egtm_Tim_In
 *
 * \section IfxLld_Egtm_Tim_In_Overview Overview
 *
 * The TIM Input interface layer is used for usecases such as PWM measurement. It uses the TIM submodule of eGTM to perform this measurement.
 *
 * \section IfxLld_Egtm_Tim_In_Code Coding Example
 *
 * Below is an example that describes how to capture signals from a pin and measure the frequency and duty cycle of the signal.
 *
 * \subsection IfxLld_Egtm_Tim_In_Step1 Step 1: Enable eGTM and its clocks
 * Please enable the eGTM module and enable the required clocks for the TIM submodule.
 *
 * \subsection IfxLld_Egtm_Tim_In_Step2 Step 2: Instantiate variables
 *
 *     \code
 *     // Include interface
 *     #include "Egtm/Tim/In/IfxEgtm_Tim_In.h"
 *
 *     // Instantiate variables
 *     IfxEgtm_Tim_In          timIn;          // Driver handle
 *     IfxEgtm_Tim_In_Config   timInConfig;    // Configuration structure
 *     \endcode
 *
 * \subsection IfxLld_Egtm_Tim_In_Step3 Step 3: [OPTIONAL] Define interrupt handler
 *
 *     \code
 *     volatile unsigned timIsrCounter = 0;
 *
 *     IFX_INTERRUPT(TimDemo_ISR, 0, 1)
 *     {
 *         // Update values on interrupt
 *         IfxEgtm_Tim_In_onIsr(&timIn);
 *         timIsrCounter += 1;
 *     }
 *     \endcode
 *
 * \subsection IfxLld_Egtm_Tim_In_Step4 Step 4: Initalize TIM
 *
 *     \code
 *     // Initialize the Config Structure
 *     IfxEgtm_Tim_In_initConfig(&timInConfig, &MODULE_EGTM);
 *
 *     // Configure the Channel used
 *     timInConfig.cluster                      = IfxEgtm_Cluster_0;
 *     timInConfig.channelIndex                 = IfxEgtm_Tim_Ch_0;
 *     // Configure Interrupt parameters
 *     timInConfig.irqMode                      = IfxEgtm_IrqMode_pulseNotify;
 *     timInConfig.isrProvider                  = IfxSrc_Tos_cpu0;
 *     timInConfig.isrPriority                  = 1;
 *     // Give an interrupt on new value
 *     timInConfig.capture.irqOnNewVal          = TRUE;
 *     // Configure the Input
 *     timInConfig.filter.input                 = IfxEgtm_Tim_In_Input_currentChannel;
 *     timInConfig.filter.inputPin              = &IfxEgtm_TIM0_0_P02_0_IN;
 *     timInConfig.filter.inputPinMode          = IfxPort_InputMode_pullDown;
 *
 *     // Initialize the TIM Channel now
 *     IfxEgtm_Tim_In_init(&timIn, &timInConfig);
 *
 *     \endcode
 *
 * Now, whenever a new measurement is captured, the function IfxEgtm_Tim_In_onIsr is called. This will update the value of frequency and duty in handle
 *
 * \subsection IfxLld_Egtm_Tim_In_Step5 Step 5: Read measurement
 *
 *     \code
 *     // Check if data is coherent
 *     if (timIn.dataCoherent == TRUE)
 *     {
 *         timIn.dataCoherent = FALSE;
 *
 *         // Get measurements
 *         float32 measuredPwmFrequency    = 1.0f / IfxEgtm_Tim_In_getPeriodSecond(&timIn);
 *         float32 measuredDutyPercent     = IfxEgtm_Tim_In_getDutyPercent(&timIn, &dataCoherent);
 *     }
 *     \endcode
 *
 * \defgroup IfxLld_Egtm_Tim_In Tim Input Interface
 * \ingroup IfxLld_Egtm_Tim
 * \defgroup IfxLld_Egtm_Tim_In_Structures TIM Input Structures
 * \ingroup IfxLld_Egtm_Tim_In
 * \defgroup IfxLld_Egtm_Tim_In_Enumerations TIM Input Enumerations
 * \ingroup IfxLld_Egtm_Tim_In
 * \defgroup IfxLld_Egtm_Tim_In_Functions TIM Input Functions
 * \ingroup IfxLld_Egtm_Tim_In
 */

#ifndef IFXEGTM_TIM_IN_H
#define IFXEGTM_TIM_IN_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_PinMap/IfxEgtm_PinMap.h"
#include "Egtm/Std/IfxEgtm_Tim.h"
#include "Egtm/Std/IfxEgtm_Cmu.h"
#if !defined(IFX_ILLD_PPU_USAGE)
#include "Cpu/Std/IfxCpu.h"
#endif
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Tim_In_Enumerations
 * \{ */
/** \brief Active edge for measurement
 */
typedef enum
{
    IfxEgtm_Tim_In_ActiveEdge_falling,  /**< \brief Use falling edge as active edge */
    IfxEgtm_Tim_In_ActiveEdge_raising,  /**< \brief Use raising edge as active edge */
    IfxEgtm_Tim_In_ActiveEdge_both      /**< \brief Use both edge as active edge */
} IfxEgtm_Tim_In_ActiveEdge;

/** \brief Config Filter Mode
 */
typedef enum
{
    IfxEgtm_Tim_In_ConfigFilterMode_immediateEdgePropagation,      /**< \brief Immediate edge propagation mode */
    IfxEgtm_Tim_In_ConfigFilterMode_individualDeglitchTimeUpDown,  /**< \brief Individual deglitch time mode (Up Down) */
    IfxEgtm_Tim_In_ConfigFilterMode_individualDeglitchTimeHold,    /**< \brief Individual deglitch time mode (Hold) */
    IfxEgtm_Tim_In_ConfigFilterMode_none                           /**< \brief No filter */
} IfxEgtm_Tim_In_ConfigFilterMode;

/** \brief Input Source for the channel
 */
typedef enum
{
    IfxEgtm_Tim_In_SrcTimIn_currentChannel  = 0, /**< \brief Use the input from the current channel */
    IfxEgtm_Tim_In_SrcTimIn_previousChannel = 1  /**< \brief Use the input from the previous channel */
} IfxEgtm_Tim_In_SrcTimIn;

/** \} */

/** \brief Input Source common for both LUT enabled and bypassed case
 */
typedef enum
{
    IfxEgtm_Tim_In_Src_channelCurrentOrPrevious = 0,  /**< \brief Use the input signal for Current/Previous channel */
    IfxEgtm_Tim_In_Src_auxiliary                = 1,  /**< \brief Use the auxiliary input */
    IfxEgtm_Tim_In_Src_software                 = 2   /**< \brief Use the Software input fed at VALx */
} IfxEgtm_Tim_In_Src;

/** \brief Input Source for LUT 2nd channel
 */
typedef enum
{
    IfxEgtm_Tim_In_SrcForLutIn2_external_capture            = 0,  /**< \brief Use the External Capture input */
    IfxEgtm_Tim_In_SrcForLutIn2_inputSignal_previousChannel = 1,  /**< \brief Use the Input Signal from Previous Channel */
    IfxEgtm_Tim_In_SrcForLutIn2_outputSignal_tssmMode       = 2   /**< \brief Use the Output signal in the TSSM mode */
} IfxEgtm_Tim_In_SrcForLutIn2;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Tim_In_Structures
 * \{ */
/** \brief Configuration structure for TIM capture
 */
typedef struct
{
    boolean                   irqOnNewVal;             /**< \brief If TRUE, the interrupt on new value is enabled */
    boolean                   irqOnCntOverflow;        /**< \brief If TRUE, the interrupt on CNT overflow is enabled */
    boolean                   irqOnEcntOverflow;       /**< \brief If TRUE, the interrupt on ECNT (Edge counter) overflow is enabled */
    boolean                   irqOnDatalost;           /**< \brief If TRUE, the interrupt on data lost (GPR0, GPR1) is enabled */
    IfxEgtm_Cmu_Clk           clock;                   /**< \brief Timer input clock */
    Ifx_Pwm_Mode              mode;                    /**< \brief PWM mode, only Ifx_Pwm_Mode_leftAligned and Ifx_Pwm_Mode_righAligned are supported */
    IfxEgtm_Tim_In_ActiveEdge activeEdge;              /**< \brief Active edge to be selected as falling, raising or both */
    uint32                    gateCount;               /**< \brief Shadow count value */
} IfxEgtm_Tim_In_ConfigCapture;

/** \brief Configuration structure for TIM filter
 */
typedef struct
{
    IfxEgtm_Cmu_Tim_Filter_Clk      clock;                       /**< \brief Timeout clock */
    IfxEgtm_Tim_In_ConfigFilterMode risingEdgeMode;              /**< \brief Filter mode for rising edge */
    IfxEgtm_Tim_In_ConfigFilterMode fallingEdgeMode;             /**< \brief Filter mode for falling edge */
    float32                         risingEdgeFilterTime;        /**< \brief Rising edge filter time  in second */
    float32                         fallingEdgeFilterTime;       /**< \brief Falling edge filter time in second */
    boolean                         irqOnGlitch;                 /**< \brief If TRUE, the interrupt on glitch is enabled */
} IfxEgtm_Tim_In_ConfigFilter;

/** \brief Configuration structure for TIM timeout
 */
typedef struct
{
    IfxEgtm_Cmu_Clk clock;              /**< \brief Timeout clock */
    float32         timeout;            /**< \brief Timeout in second. Value of 0 disable the timeout functionality see 27.10.3 Timeout Detection Unit (TDU) */
    boolean         irqOnTimeout;       /**< \brief If TRUE, the interrupt on timeout is enabled */
} IfxEgtm_Tim_In_ConfigTimeout;

/** \} */

/** \addtogroup IfxLld_Egtm_Tim_In_Structures
 * \{ */
/** \brief Driver Handle
 */
typedef struct
{
    Ifx_EGTM_CLS_TIM_CH *channel;                     /**< \brief TIM channel used */
    uint32               periodTick;                  /**< \brief Period value in clock ticks */
    uint32               pulseLengthTick;             /**< \brief Duty value in clock ticks */
    boolean              dataCoherent;                /**< \brief TRUE, if the duty and period values are measured from the same period */
    boolean              overflowCnt;                 /**< \brief TRUE if the last measurement show an overflow in CNT */
    boolean              newData;                     /**< \brief TRUE when values are updated, and  if none of the counter CNT, CNTS have overflowed */
    boolean              dataLost;                    /**< \brief TRUE if data are lost */
    uint32               edgeCounterUpper;            /**< \brief upper part of the edge counter */
    boolean              glitch;                      /**< \brief TRUE if glitch is detected */
    float32              captureClockFrequency;       /**< \brief Capture clock frequency in Hz */
    IfxEgtm_Tim          clsIndex;                    /**< \brief Index of the CLS module being used. */
    IfxEgtm_Tim_Ch       channelIndex;                /**< \brief Index of the TIM channel being used. */
    uint16               edgeCount;                   /**< \brief number of edges counted. */
    boolean              softwareInputSet;            /**< \brief flag to check if the software input is provided */
    Ifx_EGTM_CLS_TIM    *tim;                         /**< \brief Pointer to TIM module */
} IfxEgtm_Tim_In;

/** \brief Configuration structure for TIM input capture
 */
typedef struct
{
    Ifx_EGTM                    *egtm;                   /**< \brief EGTM used */
    IfxEgtm_Tim                  cluster;                /**< \brief CLS index */
    IfxEgtm_Tim_Ch               channelIndex;           /**< \brief Channel index */
    IfxEgtm_IrqMode              irqMode;                /**< \brief Interrupt mode for the new value available */
    IfxSrc_Tos                   isrProvider;            /**< \brief Interrupt service provider for the timer interrupt */
    Ifx_Priority                 isrPriority;            /**< \brief Set the interrupt priority for new value available. If 0, no interrupt will be generated */
    IfxEgtm_Tim_In_ConfigCapture capture;                /**< \brief Capture configuration */
    IfxEgtm_Tim_In_ConfigFilter  filter;                 /**< \brief Filter configuration */
    IfxEgtm_Tim_In_ConfigTimeout timeout;                /**< \brief Timeout configuration */
    IfxSrc_VmId                  vmId;                   /**< \brief Virtual machine interrupt service provider */
    IfxEgtm_Tim_Mode             mode;                   /**< \brief TIM channel Mode */
    IfxEgtm_Tim_In_Src           inputSrc;               /**< \brief Input Source for LUT bypassed case plus LUT_IN0 for LUT case */
    IfxEgtm_Tim_In_SrcForLutIn2  input2ForLUT;           /**< \brief selected input for LUT 2 channel */
    IfxEgtm_Tim_In_SrcTimIn      srcTimIn;               /**< \brief CICTRL selection to decide current or previous channel */
    boolean                      useLUT;                 /**< \brief Input to check if the LUT is to be enabled or not */
    IfxEgtm_Tim_TinMap          *inputPin;               /**< \brief Input selection for the channel */
    IfxPort_InputMode            inputPinMode;           /**< \brief Input pin mode */
    uint8                        lookupTableValue;       /**< \brief Lookup Table Content */
} IfxEgtm_Tim_In_Config;

/** \} */

/** \addtogroup IfxLld_Egtm_Tim_In_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Clear the new data flag
 * \param driver TIM Input object
 * \return None
 */
IFX_INLINE void IfxEgtm_Tim_In_clearNewData(IfxEgtm_Tim_In *driver);

/** \brief return the dutycycle in percent
 * \param driver TIM Input object
 * \param dataCoherent If true, the duty cycle has been calculated with coherent values for the period and duty, else the period and duty value are from 2 adjacent periods
 * \return duty
 */
IFX_INLINE float32 IfxEgtm_Tim_In_getDutyPercent(IfxEgtm_Tim_In *driver, boolean *dataCoherent);

/** \brief Return the period in second
 * \param driver TIM Input object
 * \return period value in seconds
 */
IFX_INLINE float32 IfxEgtm_Tim_In_getPeriodSecond(IfxEgtm_Tim_In *driver);

/** \brief Return the period value in tick
 * \param driver TIM Input object
 * \return period value in ticks
 */
IFX_INLINE sint32 IfxEgtm_Tim_In_getPeriodTicks(IfxEgtm_Tim_In *driver);

/** \brief Return the pulse length value in tick
 * \param driver TIM Input object
 * \return pulse length
 */
IFX_INLINE sint32 IfxEgtm_Tim_In_getPulseLengthTick(IfxEgtm_Tim_In *driver);

/** \brief Indicates if data were lost
 * \param driver TIM Input object
 * \return TRUE if Data is lost FALSE otherwise
 */
IFX_INLINE boolean IfxEgtm_Tim_In_isDataLost(IfxEgtm_Tim_In *driver);

/** \brief Indicates if new data are present (new data flag)
 * \param driver TIM Input object
 * \return TRUE if New Data FALSE otherwise
 */
IFX_INLINE boolean IfxEgtm_Tim_In_isNewData(IfxEgtm_Tim_In *driver);

/** \brief Configures the Software Input
 * \param driver TIM Input Object
 * \param softwareInput Software Input for the LUT
 * \return None
 */
IFX_INLINE void IfxEgtm_Tim_In_configureSoftwareInput(IfxEgtm_Tim_In *driver, boolean softwareInput);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initializes the input capture object
 * \param driver TIM Input object
 * \param config Configuration structure for the input capture Timer
 * \return TRUE on success else FALSE
 */
IFX_EXTERN boolean IfxEgtm_Tim_In_init(IfxEgtm_Tim_In *driver, const IfxEgtm_Tim_In_Config *config);

/** \brief Initializes the configuration structure to default
 * \param config Configuration structure for the input capture Timer
 * \param egtm Pointer to EGTM module
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tim_In_initConfig(IfxEgtm_Tim_In_Config *config, Ifx_EGTM *egtm);

/** \brief will update the  driver state\n
 * To be called in the interrupt generated by the IfxEgtm_Tim_In driver
 * \param driver TIM Input object
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tim_In_onIsr(IfxEgtm_Tim_In *driver);

/** \brief Updates the period and duty cycle
 * \param driver TIM Input object
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tim_In_update(IfxEgtm_Tim_In *driver);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxEgtm_Tim_In_clearNewData(IfxEgtm_Tim_In *driver)
{
    driver->newData = FALSE;
}


IFX_INLINE float32 IfxEgtm_Tim_In_getDutyPercent(IfxEgtm_Tim_In *driver, boolean *dataCoherent)
{
    float32 duty;
#if !defined(IFX_ILLD_PPU_USAGE)
    boolean interruptState = IfxCpu_disableInterrupts();
#endif
    duty          = (float32)((float32)driver->pulseLengthTick * (float32)100.0f) / (float32)driver->periodTick;
    *dataCoherent = driver->dataCoherent;
#if !defined(IFX_ILLD_PPU_USAGE)
    IfxCpu_restoreInterrupts(interruptState);
#endif

    return duty;
}


IFX_INLINE float32 IfxEgtm_Tim_In_getPeriodSecond(IfxEgtm_Tim_In *driver)
{
    return (float32)IfxEgtm_Tim_In_getPeriodTicks(driver) / driver->captureClockFrequency;
}


IFX_INLINE sint32 IfxEgtm_Tim_In_getPeriodTicks(IfxEgtm_Tim_In *driver)
{
    return (sint32)driver->periodTick;
}


IFX_INLINE sint32 IfxEgtm_Tim_In_getPulseLengthTick(IfxEgtm_Tim_In *driver)
{
    return (sint32)driver->pulseLengthTick;
}


IFX_INLINE boolean IfxEgtm_Tim_In_isDataLost(IfxEgtm_Tim_In *driver)
{
    return driver->dataLost;
}


IFX_INLINE boolean IfxEgtm_Tim_In_isNewData(IfxEgtm_Tim_In *driver)
{
    return driver->newData;
}


IFX_INLINE void IfxEgtm_Tim_In_configureSoftwareInput(IfxEgtm_Tim_In *driver, boolean softwareInput)
{
    IfxEgtm_Tim_InputSourceSelect inputSourceSelect;

    if (driver->softwareInputSet == TRUE)
    {
        inputSourceSelect.mode = 2;

        if (softwareInput == TRUE)
        {
            inputSourceSelect.value = 2;
        }
        else
        {
            inputSourceSelect.value = 1;
        }

        IfxEgtm_Tim_Ch_setInputSourceSelection(driver->tim, driver->channelIndex, inputSourceSelect);
    }
}


#endif /* IFXEGTM_TIM_IN_H */
