/**
 * \file IfxApApu.h
 * \brief AP  basic functionality
 * \ingroup IfxLld_Ap
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Ap_Std_Apu Apu Basic Functionality
 * \ingroup IfxLld_Ap_Std
 * \defgroup IfxLld_Ap_Std_Apu_Default Enumerations
 * \ingroup IfxLld_Ap_Std_Apu
 * \defgroup IfxLld_Ap_Std_Apu_Default Structure
 * \ingroup IfxLld_Ap_Std_Apu
 * \defgroup IfxLld_Ap_Std_Apu_Default Functions
 * \ingroup IfxLld_Ap_Std_Apu
 */

#ifndef IFXAPAPU_H
#define IFXAPAPU_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxAp_cfg.h"
#include "IfxAccen_bf.h"
#include "IfxAccen_reg.h"
#include "IfxApProt.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Ap_Std_Apu_Default
 * \{ */
/** \brief PRS Read Write selection
 */
typedef enum
{
    IfxApApu_PrsRdWr_read = 0U,
    IfxApApu_PrsRdWr_write
} IfxApApu_PrsRdWr;

/** \brief VM Read Write selection
 */
typedef enum
{
    IfxApApu_VmRdWr_read = 0U,
    IfxApApu_VmRdWr_write
} IfxApApu_VmRdWr;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Ap_Std_Apu_Default
 * \{ */
/** \brief Configuration data structure of the APU
 */
typedef struct
{
    unsigned long wraTagId;
    unsigned long wrbTagId;
    unsigned long rdaTagId;
    unsigned long rdbTagId;
    unsigned char vmWrId;
    unsigned char vmRdId;
    unsigned char prsWrId;
    unsigned char prsRdId;
} IfxApApu_ApuConfig;

/** \} */

/** \addtogroup IfxLld_Ap_Std_Apu_Default
 * \{ */
/** \brief Configuration data structure of the APU with memory
 */
typedef struct
{
    IfxApApu_ApuConfig *apuConfig;
    unsigned long       rgnlaVal;
    unsigned long       rgnuaVal;
} IfxApApu_ApuMemoryConfig;

/** \} */

/** \addtogroup IfxLld_Ap_Std_Apu_Default
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure the master tag id for WriteA register
 * \param wraReg pointer to the WriteA register
 * \param configVal the register value to be configured
 * \return None
 */
IFX_INLINE void IfxApApu_configWriteRegA(volatile Ifx_ACCEN_ACCEN_WRA *wraReg, unsigned long configVal);

/** \brief Configure the master tag id for WriteB register
 * \param wrbReg pointer to the WriteB register
 * \param configVal the register value to be configured
 * \return None
 */
IFX_INLINE void IfxApApu_configWriteRegB(volatile Ifx_ACCEN_ACCEN_WRB_SRI *wrbReg, unsigned long configVal);

/** \brief Configure the master tag id for ReadA register
 * \param rdaReg pointer to the ReadA register
 * \param configVal the register value to be configured
 * \return None
 */
IFX_INLINE void IfxApApu_configReadRegA(volatile Ifx_ACCEN_ACCEN_RDA *rdaReg, unsigned long configVal);

/** \brief Configure the master tag id for ReadB register
 * \param rdbReg pointer to the ReadB register
 * \param configVal the register value to be configured
 * \return None
 */
IFX_INLINE void IfxApApu_configReadRegB(volatile Ifx_ACCEN_ACCEN_RDB_SRI *rdbReg, unsigned long configVal);

/** \brief Enable the master tad id for write access
 * \param accen pointer to the APU register set
 * \param tagId the master tagid
 * \return None
 */
IFX_INLINE void IfxApApu_enableMasterWrite(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId);

/** \brief Disable the master tad id for write access
 * \param accen pointer to the APU register set
 * \param tagId the master tagid
 * \return None
 */
IFX_INLINE void IfxApApu_disableMasterWrite(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId);

/** \brief Enable the master tad id for read access
 * \param accen pointer to the APU register set
 * \param tagId the master tagid
 * \return None
 */
IFX_INLINE void IfxApApu_enableMasterRead(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId);

/** \brief Disable the master tad id for read access
 * \param accen pointer to the APU register set
 * \param tagId the master tagid
 * \return None
 */
IFX_INLINE void IfxApApu_disableMasterRead(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId);

/** \brief Configure the VMs for Read Access
 * This API provides access to all the VMs specified in the configVal
 * \param vmReg pointer to the VM register
 * \param configVal the VM's for which read access is to be provided
 * \return None
 */
IFX_INLINE void IfxApApu_configVmReadAccess(volatile Ifx_ACCEN_ACCEN_VM *vmReg, unsigned char configVal);

/** \brief Configure the VMs for Write Access
 * This API provides access to all the VMs specified in the configVal
 * \param vmReg pointer to the VM register
 * \param configVal the VM's for which write access is to be provided
 * \return None
 */
IFX_INLINE void IfxApApu_configVmWriteAccess(volatile Ifx_ACCEN_ACCEN_VM *vmReg, unsigned char configVal);

/** \brief Enable the master VM id for write access
 * \param vmReg pointer to the VM register
 * \param readWr write to read or write offset
 * \param vmId the master vmId
 * \return None
 */
IFX_INLINE void IfxApApu_enableVmMasterWrite(volatile Ifx_ACCEN_ACCEN_VM *vmReg, IfxApApu_VmRdWr readWr, IfxApProt_VmId vmId);

/** \brief Disable the master VM id for write access
 * \param vmReg pointer to the VM register
 * \param readWr write to read or write offset
 * \param vmId the master vmId
 * \return None
 */
IFX_INLINE void IfxApApu_disableVmMasterWrite(volatile Ifx_ACCEN_ACCEN_VM *vmReg, IfxApApu_VmRdWr readWr, IfxApProt_VmId vmId);

/** \brief Configure the PRS sets for Read Access
 * This API provides access to all the PRS sets specified in the configVal
 * \param prsReg pointer to the PRS register
 * \param configVal the PRS's for which read access is to be provided
 * \return None
 */
IFX_INLINE void IfxApApu_configPrsReadAccess(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, unsigned char configVal);

/** \brief Configure the PRS sets for Write Access
 * This API provides access to all the PRS sets specified in the configVal
 * \param prsReg pointer to the PRS register
 * \param configVal the PRS's for which write access is to be provided
 * \return None
 */
IFX_INLINE void IfxApApu_configPrsWriteAccess(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, unsigned char configVal);

/** \brief Enable the master Prs id for write access
 * \param prsReg pointer to the PRS register
 * \param readWr write to read or write offset
 * \param PrsId the master PrsId
 * \return None
 */
IFX_INLINE void IfxApApu_enablePrsMasterWrite(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, IfxApApu_PrsRdWr readWr, IfxApProt_PrsId PrsId);

/** \brief Disable the master Prs id for write access
 * \param prsReg pointer to the PRS register
 * \param readWr write to read or write offset
 * \param PrsId the master PrsId
 * \return None
 */
IFX_INLINE void IfxApApu_disablePrsMasterWrite(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, IfxApApu_PrsRdWr readWr, IfxApProt_PrsId PrsId);

/** \brief Configure the lower address range
 * \param rgnla pointer to the rgnla register
 * \param lowerAddress the lower address
 * \return None
 */
IFX_INLINE void IfxApApu_configRegionLowerAddress(volatile Ifx_ACCEN_ACCEN_RGNLA *rgnla, unsigned long lowerAddress);

/** \brief Configure the upper address range
 * \param rgnua pointer to the rgnua register
 * \param upperAddress the upper address
 * \return None
 */
IFX_INLINE void IfxApApu_configRegionUpperAddress(volatile Ifx_ACCEN_ACCEN_RGNUA *rgnua, unsigned long upperAddress);

/** \brief Sets the VM register with the value provided
 * \param vmReg pointer to the VM register
 * \param value value to be written into register
 * \return None
 */
IFX_INLINE void IfxApApu_setVmReg(volatile Ifx_ACCEN_ACCEN_VM *vmReg, unsigned long value);

/** \brief Sets the PRS register with the value provided
 * \param prsReg pointer to the PRS register
 * \param value value to be written into register
 * \return None
 */
IFX_INLINE void IfxApApu_setPrsReg(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, unsigned long value);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initializes the APU
 * Configures the APU with the config value passed.
 * It is possible to provide multiple masters the access
 * In case of VM and PRS by default all VMs/PRS sets have access,
 * The init API will clear this and provide access to only the VMs/PRS sets configured
 * This API needs the respective PROT to be in the init or in the config state
 * \param accen pointer to the APU registers
 * \param config config pointer to the default APU configuration structure.
 * \return None
 */
IFX_EXTERN void IfxApApu_init(volatile Ifx_ACCEN_ACCEN *accen, IfxApApu_ApuConfig *config);

/** \brief Initializes the default configuration for the APU
 * \param config config pointer to the default APU configuration structure.
 * \return None
 */
IFX_EXTERN void IfxApApu_initConfig(IfxApApu_ApuConfig *config);

/** \brief Initializes the APU and the memory registers
 * Configures the APU with the config value passed.
 * This API needs to be used to configure the APU which has shadow registers
 * It is possible to provide multiple masters the access
 * In case of VM and PRS by default all VMs/PRS sets have access,
 * The init API will clear this and provide access to only the VMs/PRS sets configured
 * This API needs the respective PROT to be in the init or in the config state
 * \param accen pointer to the APU registers
 * \param config config pointer to the default APU configuration structure.
 * \param protReg PROT Register address pointer
 * \param accenIndex The accen index which needs to be configured
 * \return None
 */
IFX_EXTERN void IfxApApu_configMemoryAccess(volatile Ifx_ACCEN_ACCEN *accen, IfxApApu_ApuMemoryConfig *config, Ifx_PROT_PROT *protReg, unsigned char accenIndex);

/** \brief API to configure access to all masters to all LMUs
 * \return None
 */
IFX_EXTERN void IfxApApu_configureAccessToLmus(IfxApApu_ApuMemoryConfig *memConfig);

/** \brief API to configure access to all masters to all DLMUs
 * \return None
 */
IFX_EXTERN void IfxApApu_configureAccessToDlmus(IfxApApu_ApuMemoryConfig *memConfig);

/** \brief API to configure access to all masters to all DSPRs
 * \return None
 */
IFX_EXTERN void IfxApApu_configureAccessToDsprs(IfxApApu_ApuMemoryConfig *memConfig);

/** \brief API to configure access to all masters to all PSPRs
 * \return None
 */
IFX_EXTERN void IfxApApu_configureAccessToPsprs(IfxApApu_ApuMemoryConfig *memConfig);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxApApu_configWriteRegA(volatile Ifx_ACCEN_ACCEN_WRA *wraReg, unsigned long configVal)
{
    wraReg->U = configVal;
}


IFX_INLINE void IfxApApu_configWriteRegB(volatile Ifx_ACCEN_ACCEN_WRB_SRI *wrbReg, unsigned long configVal)
{
    wrbReg->U = configVal;
}


IFX_INLINE void IfxApApu_configReadRegA(volatile Ifx_ACCEN_ACCEN_RDA *rdaReg, unsigned long configVal)
{
    rdaReg->U = configVal;
}


IFX_INLINE void IfxApApu_configReadRegB(volatile Ifx_ACCEN_ACCEN_RDB_SRI *rdbReg, unsigned long configVal)
{
    rdbReg->U = configVal;
}


IFX_INLINE void IfxApApu_enableMasterWrite(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId)
{
    if (tagId < 32)
    {
        accen->WRA.U |= 1U << tagId;
    }
    else
    {
        /* In case ID >= 32 write into WRB register */
        accen->WRB.U |= 1U << (tagId - 32U);
    }
}


IFX_INLINE void IfxApApu_disableMasterWrite(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId)
{
    uint32 mask = 0U;

    if (tagId < 32)
    {
        mask          = 1U << tagId;
        accen->WRA.U &= ~(mask);
    }
    else
    {
        mask          = 1U << (tagId - 32U);
        accen->WRB.U &= ~(mask);
    }
}


IFX_INLINE void IfxApApu_enableMasterRead(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId)
{
    if (tagId < 32)
    {
        accen->RDA.U |= 1U << tagId;
    }
    else
    {
        /* In case ID >= 32 write into WRB register */
        accen->RDB.U |= 1U << (tagId - 32U);
    }
}


IFX_INLINE void IfxApApu_disableMasterRead(volatile Ifx_ACCEN_ACCEN *accen, IfxApProt_TagId tagId)
{
    uint32 mask = 0U;

    if (tagId < 32)
    {
        mask          = 1U << tagId;
        accen->RDA.U &= ~(mask);
    }
    else
    {
        mask          = 1U << (tagId - 32U);
        accen->RDB.U &= ~(mask);
    }
}


IFX_INLINE void IfxApApu_configVmReadAccess(volatile Ifx_ACCEN_ACCEN_VM *vmReg, unsigned char configVal)
{
    Ifx_ACCEN_ACCEN_VM tempReg;

    tempReg.U  = vmReg->U;
    tempReg.U  = tempReg.U & (0xFFFFFF00U);
    tempReg.U |= ((1U << configVal) - 1U);
    vmReg->U   = tempReg.U;
}


IFX_INLINE void IfxApApu_configVmWriteAccess(volatile Ifx_ACCEN_ACCEN_VM *vmReg, unsigned char configVal)
{
    Ifx_ACCEN_ACCEN_VM tempReg;

    tempReg.U  = vmReg->U;
    tempReg.U  = tempReg.U & (0xFF00FFFFU);
    tempReg.U |= ((1U << configVal) - 1U) << IFX_ACCEN_ACCEN_VM_WR00_OFF;
    vmReg->U   = tempReg.U;
}


IFX_INLINE void IfxApApu_enableVmMasterWrite(volatile Ifx_ACCEN_ACCEN_VM *vmReg, IfxApApu_VmRdWr readWr, IfxApProt_VmId vmId)
{
    if (readWr == IfxApApu_VmRdWr_read)
    {
        vmReg->U |= (1U << vmId);
    }
    else
    {
        vmReg->U |= (1U << vmId) << IFX_ACCEN_ACCEN_VM_WR00_OFF;
    }
}


IFX_INLINE void IfxApApu_disableVmMasterWrite(volatile Ifx_ACCEN_ACCEN_VM *vmReg, IfxApApu_VmRdWr readWr, IfxApProt_VmId vmId)
{
    uint32 mask = 0U;

    if (readWr == IfxApApu_VmRdWr_read)
    {
        mask = 1U << vmId;
    }
    else
    {
        mask = (1U << vmId) << IFX_ACCEN_ACCEN_VM_WR00_OFF;
    }

    vmReg->U &= ~(mask);
}


IFX_INLINE void IfxApApu_configPrsReadAccess(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, unsigned char configVal)
{
    Ifx_ACCEN_ACCEN_PRS tempReg;

    tempReg.U  = prsReg->U;
    tempReg.U  = tempReg.U & (0xFFFFFF00U);
    tempReg.U |= ((1U << configVal) - 1U);
    prsReg->U  = tempReg.U;
}


IFX_INLINE void IfxApApu_configPrsWriteAccess(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, unsigned char configVal)
{
    Ifx_ACCEN_ACCEN_PRS tempReg;

    tempReg.U  = prsReg->U;
    tempReg.U  = tempReg.U & (0xFF00FFFFU);
    tempReg.U |= ((1U << configVal) - 1U) << IFX_ACCEN_ACCEN_PRS_WR00_OFF;
    prsReg->U  = tempReg.U;
}


IFX_INLINE void IfxApApu_enablePrsMasterWrite(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, IfxApApu_PrsRdWr readWr, IfxApProt_PrsId PrsId)
{
    if (readWr == IfxApApu_PrsRdWr_read)
    {
        prsReg->U |= (1U << PrsId);
    }
    else
    {
        prsReg->U |= (1U << PrsId) << IFX_ACCEN_ACCEN_PRS_WR00_OFF;
    }
}


IFX_INLINE void IfxApApu_disablePrsMasterWrite(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, IfxApApu_PrsRdWr readWr, IfxApProt_PrsId PrsId)
{
    uint32 mask = 0U;

    if (readWr == IfxApApu_PrsRdWr_read)
    {
        mask = (1U << PrsId);
    }
    else
    {
        mask = (1U << PrsId) << IFX_ACCEN_ACCEN_PRS_WR00_OFF;
    }

    prsReg->U &= ~(mask);
}


IFX_INLINE void IfxApApu_configRegionLowerAddress(volatile Ifx_ACCEN_ACCEN_RGNLA *rgnla, unsigned long lowerAddress)
{
    rgnla->U = lowerAddress;
}


IFX_INLINE void IfxApApu_configRegionUpperAddress(volatile Ifx_ACCEN_ACCEN_RGNUA *rgnua, unsigned long upperAddress)
{
    rgnua->U = upperAddress;
}


IFX_INLINE void IfxApApu_setVmReg(volatile Ifx_ACCEN_ACCEN_VM *vmReg, unsigned long value)
{
    vmReg->U = value;
}


IFX_INLINE void IfxApApu_setPrsReg(volatile Ifx_ACCEN_ACCEN_PRS *prsReg, unsigned long value)
{
    prsReg->U = value;
}


#endif /* IFXAPAPU_H */
