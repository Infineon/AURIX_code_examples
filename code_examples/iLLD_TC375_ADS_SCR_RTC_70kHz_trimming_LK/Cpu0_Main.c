/**********************************************************************************************************************
 * \file Cpu0_Main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/
 /*\title iLLD_TC375_ADS_SCR_RTC_70kHz_trimming_LK
 * \abstract This code example demonstrates Standby Controller Real-Time Clock calibration using Wake-up Timer and Capture-Compare Unit.
 * \description This is a minimal code example presenting a solution to application scenario 3 from Application Note AP32465.
 *              The goal is to periodically trim the low power 70kHz low frequency (LF) oscillator. This oscillator is specially for low power application but naturally very imprecise and usually used by the Wake-up Timer (WUT) and Standby Controller (SCR) Real-Time Clock (RTC) timers.
 *              Using the WUT and the Capture/Compare Unit 6 (CCU6) a calibration coefficient is calculated and transferred to the SCR domain.
 *
 * \name iLLD_TC375_ADS_SCR_RTC_70kHz_trimming_LK
 * \version V1.0.0
 * \board AURIX TC375 lite Kit, KIT_A2G_TC375_LITE, TC37xTP_A-Step
 * \keywords SCR, CCU, WUT, RTC, LED, PORT, Interrupt, AURIX
 * \documents See README.md
 * \lastUpdated 2025-02-17
 *********************************************************************************************************************/
#include "Ifx_Types.h"
#include "IfxCpu.h"
#include "IfxScuWdt.h"
#include "SCR.h"
#include "AppBsp.h"
#include "WakeupTimer.h"
#include "CaptureCompare.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define DEBUG_SCR_DAP                   FALSE   /* Set to TRUE to enable DAP debugging */
#define DEBUG_SCR_NO_STBY               FALSE   /* Set to TRUE to prevent entering standby mode */

#define SCR_RTC_PERIOD_MS               (200u)  /* Expected RTC period in milliseconds */
#define SCR_TRIM_COUNT                  (50u)   /* Number of RTC ticks before next trimming wake-up */

#define NUMBER_CALIBRATION_CYCLES       (5u)    /* Number of calibration rounds for the 70kHz clock*/

/* Helper macro to calculate XRAM memory address information for RTC data exchange */
#define XRAM_EXCHANGE_ADDRESS(offset)   (uint32*)((uint8*)PMS_XRAM + (offset & (PMS_XRAM_SIZE-1)))

#define STATUSLED_POWERON               (AppBspStatusLed_2) /* LED showing PowerOn state */
#define STATUSLED_PINBWAKEUP            (AppBspStatusLed_2) /* LED showing PINBWKP state */
#define STATUSLED_ESR1WAKEUP            (AppBspStatusLed_2) /* LED showing ESR1WKP state */
#define STATUSLED_SCRWAKEUP             (AppBspStatusLed_2) /* LED showing SCRWKP state */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IFX_ALIGN(4) IfxCpu_syncEvent g_cpuSyncEvent = 0;

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
IFX_INLINE void delayMs(const uint32 msCnt);
IFX_INLINE void blinkLedCntTimes(const AppBspStatusLed ledId, const uint32 cnt);

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/
WUTcalibValues sWUTcalib = { DEFAULT_TIMER_FREQUENCY,   /* Initial calibration parameters for the WUT */
                             DEFAULT_TIMER_PERIOD,
                             DEFAULT_CALIBRATION_FACTOR };

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void core0_main(void)
{
    IfxCpu_enableInterrupts();
    
    /* !!WATCHDOG0 AND SAFETY WATCHDOG ARE DISABLED HERE!!
     * Enable the watchdogs and service them periodically if it is required
     */
    uint16 endinitCpu_pw = IfxScuWdt_getCpuWatchdogPassword ();
    uint16 endinitSfty_pw = IfxScuWdt_getSafetyWatchdogPassword();

    IfxScuWdt_disableCpuWatchdog(endinitCpu_pw);
    IfxScuWdt_disableSafetyWatchdog(endinitSfty_pw);
    
    /* Wait for CPU sync event */
    IfxCpu_emitEvent(&g_cpuSyncEvent);
    IfxCpu_waitEvent(&g_cpuSyncEvent, 1);
    
    /* Clear sticky status bits (SCU_RSTCON2) indicating any previous cold reset
     * if a Reset Request Trigger was detected (SCU_RSTSTAT) */
    if(SCU_RSTSTAT.B.STBYR)
    {
        IfxScuWdt_clearCpuEndinit(endinitCpu_pw);
        SCU_RSTCON2.B.CLRC = 1;         /* A write access to this register is Endinit protected;
                                           the protection has to be removed and set again afterward. */
        IfxScuWdt_setCpuEndinit(endinitCpu_pw);
        while(SCU_RSTSTAT.B.STBYR)      /* Wait until status is finally reset */
        {
        }
    }

    /* Clear the SCROVRUN register to prevent immediate wake-up after entering standby */
    if(PMS_PMSWSTAT2.B.SCROVRUN)
    {
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        PMS_PMSWSTATCLR.B.SCROVRUNCLR = 1;  /* A write access to this register is Endinit protected;
                                               the protection has to be removed and set again afterward. */
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
        while(PMS_PMSWSTAT2.B.SCROVRUN)     /* Wait until status is finally reset */
        {
        }
    }

    configureAppBspStatusLeds();

    /* Configure wakeup timer */
    configureWUT(sWUTcalib.period);

    /* Configure CCU6 to calibrate RTC */
    uint32 CCU6freq = init_CCU6();
    start_CCU60_T12();

    /* Enable CCU service request */
    enable_CCU6_service_request();

    /* check if it was ESR1 edge wake-up trigger */
    if (PMS_PMSWSTAT2.B.ESR1WKP ==1)
    {
        blinkLedCntTimes(STATUSLED_ESR1WAKEUP, 4u);

        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        PMS_PMSWSTATCLR.B.ESR1WKPCLR = 1;       /* A write access to this register is Endinit protected;
                                                   the protection has to be removed and set again afterward. */
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
        while(PMS_PMSWSTAT2.B.ESR1WKP)          /* Wait until status is finally reset */
        {
        }
    }
    /* check if it was PINB edge wake-up trigger */
    else if (PMS_PMSWSTAT2.B.PINBWKP ==1)
    {
        blinkLedCntTimes(STATUSLED_PINBWAKEUP, 3u);
        activateAppBspStateLed(STATUSLED_PINBWAKEUP);

        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        PMS_PMSWSTATCLR.B.PINBWKPCLR = 1;       /* A write access to this register is Endinit protected;
                                                   the protection has to be removed and set again afterward. */
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
        while(PMS_PMSWSTAT2.B.PINBWKP)          /* Wait until status is finally reset */
        {
        }
    }
    /* check if it was SCR wake-up trigger */
    else if (PMS_PMSWSTAT2.B.SCRWKP == 1)
    {
        activateAppBspStateLed(STATUSLED_SCRWAKEUP);

        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        PMS_PMSWSTATCLR.B.SCRWKPCLR = 1;        /* A write access to this register is Endinit protected;
                                                   the protection has to be removed and set again afterward. */
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);
        while(PMS_PMSWSTAT2.B.SCRWKP)           /* Wait until status is finally reset */
        {
        }

        if(WAKEUP_REASON_TRIM == IfxScr_getWakeUpCause(XRAM_EXCHANGE_ADDRESS(XRAM_EXCHANGE_OFFSET2)))
        {
            /* Trigger few calibration rounds for result convergence */
            uint32 numOfCalibrationCycles = NUMBER_CALIBRATION_CYCLES;
            /* add a few wakeup timer calibration rounds */
            while(numOfCalibrationCycles)
            {
                /*WUT calibration part*/
                if(g_calibrateWUT)
                {
                    clear_CCU60_T12();
                    sWUTcalib = calibrateWUT(sWUTcalib, g_CCU60_capture, CCU6freq);
                    g_CCU60_capture = 0;
                    g_calibrateWUT = FALSE;
                    numOfCalibrationCycles--;
                }
            }
            /* Set the new RTC period */
            IfxScr_setRTCperiodOn70kHz(SCR_RTC_PERIOD_MS, sWUTcalib.calibCoeff, XRAM_EXCHANGE_ADDRESS(XRAM_EXCHANGE_OFFSET));
        }
        else
        {
            /* Add some delay (~200ms) to debounce the button */
            delayMs(200U);
            waitForButtonPress();
            /* Add some delay (~200ms) to debounce the button */
            delayMs(200U);
        }

        /* Set new trimming interval */
        IfxScr_setTrimCounter(SCR_TRIM_COUNT, XRAM_EXCHANGE_ADDRESS(XRAM_EXCHANGE_OFFSET2));
        deactivateAppBspStateLed(STATUSLED_SCRWAKEUP);

        /* Issue standby request */
        IfxScuWdt_clearCpuEndinit(endinitCpu_pw);
        SCU_PMCSR0.B.REQSLP = 0x3;
        IfxScuWdt_setCpuEndinit(endinitCpu_pw);
    }
    /* check if no wake-up trigger */
    else if((PMS_PMSWSTAT2.B.SCRWKP == 0) && (PMS_PMSWSTAT2.B.ESR1WKP == 0) && (PMS_PMSWSTAT2.B.PINBWKP == 0))
    {
        blinkLedCntTimes(STATUSLED_POWERON, 5u);
        activateAppBspStateLed(STATUSLED_POWERON);

        /* Hand over the control of pins */
        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        /* Hand over the control of pins to the SCR */
        configureAppBspScrPorts();

        /* Restart SCR clock */
        IfxScr_disableSCR();
        IfxScr_enableSCR();

        /* boot_mode = 0 - XRAM not programmed */
        IfxScr_initSCR(ScrBootMode_UserMode_0);
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

        /* Write SCR program to XRAM */
        IfxScr_copySCRprogram();

        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);

#if DEBUG_SCR_DAP   /* OCDS boot */
        /* boot_mode = 0x0A - SCR Enable DAP debug interface */
        IfxScr_initSCR(ScrBootMode_DebugMode_DAP);
#else               /* User Mode 1 boot */
        /* boot_mode = 1 - XRAM programmed */
        IfxScr_initSCR(ScrBootMode_UserMode_1);
#endif

        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

#if DEBUG_SCR_NO_STBY /* No standby entry */
        deactivateAppBspStateLed(STATUSLED_POWERON);

        while(1)
        {
            showTcActivity();
        }
#endif

        IfxScuWdt_clearSafetyEndinit(endinitSfty_pw);
        /* [29]    SCRWKEN      (Standby Controller Wake-up enable from Standby)
         * [27]    PINPWKEN     (Pin B Wake-up enable from Standby)
         * [15:14] PINBEDCON    (PINB Edge Detection Control, falling edge)
         * [13]    PINBDFEN     (PINB Digital Filter Enable)
         */
        PMS_PMSWCR0.U = 0x2800A000;
        IfxScuWdt_setSafetyEndinit(endinitSfty_pw);

        waitForButtonPress();
        /* Add some delay (~200ms) to debounce the button */
        delayMs(200U);

        /* Issue standby request */
        IfxScuWdt_clearCpuEndinit(endinitCpu_pw);
        SCU_PMCSR0.B.REQSLP = 0x3;
        IfxScuWdt_setCpuEndinit(endinitCpu_pw);
    }

    while(1)
    {
        showTcActivity();
    }
}

IFX_INLINE void delayMs(const uint32 msCnt)
{
    /* TICKS_FOR_1_MS needs to be evaluated for each new target */
    volatile uint32 delay = (uint32)(TICKS_FOR_1_MS * msCnt);
    /* A simple busy waiting loop, not for real application */
    for (uint32 cnt = 0U; cnt < delay; cnt++)
    {}
}

IFX_INLINE void blinkLedCntTimes(const AppBspStatusLed ledId, const uint32 cnt)
{
    activateAppBspStateLed(ledId);

    for (uint32 i = 0U; i < (2*cnt-1); i++)
    {
        /* Add a delay of ~250ms */
        delayMs(250U);
        toggleAppBspStateLed(ledId);
    }
}
