/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "scr_io_sdcc.h"
#include "scr_irq_sdcc.h"
#include "scr_rtc_sdcc.h"
#include "scr_scu_sdcc.h"
#include "scr_sfr_sdcc.h"
#include "scr_wdt_sdcc.h"
#include "scr_common.h"
#include "../AppBsp_Conf.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define RTC_INTERVAL_1S             TRUE

#define DEFAULT_TRIM_COUNT_SLOW     5u      /* Number of RTC ticks before first trimming wake-up (slow RTC interval) */
#define DEFAULT_TRIM_COUNT_FAST     25u     /* Number of RTC ticks before first trimming wake-up (fast RTC interval) */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* XRAM memory address for TriCore <-> SCR data exchange.
 * - Adresses accessed from TriCore need to be 32-bit aligned!
 *
 * ATTENTION: Provide an initializer to make sure there memory allocation will take place and overlaps will
 *            be detected by the linker. The assembler listing file (.lst) and the linker output files (.rst)
 *            and (.map) are good places to look for to ensure 32-bit alignment for TriCore.
 *            It is left to the programmer to add padding bytes if variables need to be accessed by TriCore
 *            are not correctly aligned!
 */
__xdata volatile uint8 g_exchangeBytes[4] = {0};
__xdata volatile uint8 g_wakeUpReason = 0;
__xdata volatile uint8 g_nextTrimCounter = 0;

/* Place global helper variables in internal data memory */
__data volatile uint8 g_debugCounter;

/* Place flags which need fast access (like from ISR) in the bit-addressable internal data memory (16 bytes of RAM
 * that occupy addresses from 20h to 2Fh).
 */
__bit g_RTCtick;        /* Global flag to signal RTC tick event */
__bit g_trimRTC;        /* Global flag to signal wake-up for next clock trimming */
__bit g_extTrigger;     /* Global flag to signal wake-up by external trigger event */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void rtcIsrHandler(void) __interrupt (XINTR13);
void exi3to6IsrHandler(void) __interrupt (XINTR9);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void main(void)
{
    /* Enable access to non-mapped (standard) special function register area */
    SCR_SYSCON0 = 0;
    /* Disable watchdog timer, to ensure it will not disrupt the idle mode */
    SCR_WDT_CON = 0;

    /* Initialize the dummy counter for debug purpose */
    g_debugCounter = 0;
    /* Initialize status flags to default values */
    g_RTCtick = FALSE;
    g_trimRTC = FALSE;
    g_extTrigger = FALSE;

    /* Initialize the TC shared memory locations for the wake-up cause and RTC overflow.
     * May be overwritten from the TriCore(TM) for change of the RTC period */
    g_wakeUpReason = WAKEUP_REASON_NONE;
#if RTC_INTERVAL_1S
    /* Counter setting for 1s@70kHz */
    g_exchangeBytes[3] = 0x00;
    g_exchangeBytes[2] = 0x01;
    g_exchangeBytes[1] = 0x11;
    g_exchangeBytes[0] = 0x70;
    g_nextTrimCounter = DEFAULT_TRIM_COUNT_SLOW;
#else
    /* Counter setting for 0.2s@70kHz */
    g_exchangeBytes[3] = 0x00;
    g_exchangeBytes[2] = 0x00;
    g_exchangeBytes[1] = 0x36;
    g_exchangeBytes[0] = 0xB0;
    g_nextTrimCounter = DEFAULT_TRIM_COUNT_FAST;
#endif /* RTC_INTERVAL_1S */

#if USE_KIT_A2G_TC375_LITE
    /* Enable available pins
       P33.0 - P33.6, P33.9 - P33.13 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.1 to P01.5 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 );

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 (P33.4) as output, push-pull */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (connect to button 1) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;

    /* Errata SCR_TC.021
     * - RTC not counting after reset if P33.10 is high.
     * - Device: TC37xEXT
     * - Marking/Step: (E)ES-AA)
     * 
     * Clear P01.2 (P33.10) to ensure a low level at the beginning, otherwise
     * it is possible that the RTC will not start.
     */
    SCR_SET_IO_PAGE(MOD_PAGE_0);
    SCR_IO_P01_OUT &= (~ScrIoPin2);
    /* Set P01.2 (P33.10) as output, push-pull */
    SCR_SET_IO_PAGE(MOD_PAGE_1);
    SCR_IO_P01_IOCR2 = ScrPortMode_outputPushPullGeneral;
    /* ~Errata SCR_TC.021 */
#endif /* USE_KIT_A2G_TC375_LITE */

#if USE_KIT_A2G_TC397_5V_TFT
    /* Enable available pins
       P33.0 - P33.6, P33.10 - P33.12 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.2 to P01.4 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin2 | ScrIoPin3 | ScrIoPin4);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 (P33.4) as output, push-pull */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, pull up (external switch) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputPullUp;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_A2G_TC397_5V_TFT */

#if USE_KIT_TC397_TRB
    /* Enable available pins 
       P33.0 - P33.7, P34.1, P33.11 - P33.15 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);
    /* Enable P01.0, P01.3 to P01.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin0 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 / P33.4 as output, push-pull (LED D302) */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (S202) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_TC397_TRB */

    /* Enable 20MHz clock to SCR */
    Scr_set_fsys(DIV5);

    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    while(!Scr_is_in_standby()); /* Wait until TC enters standby mode */

    /*** Initialize interrupts ***/
    SCR_SET_SCU_PAGE(MOD_PAGE_2);
    /* Select P01.3 / P33.11 as input for External Interrupt 6 */
    SCR_SCU_MODPISEL2 = 0x40;
    SCR_SET_SCU_PAGE(MOD_PAGE_1);
    /* Disable request: all except RTC and OCDS */
    SCR_SCU_PMCON1 = (LIN_DIS_MASK | WDT_DIS_MASK | WCAN_DIS_MASK | T2CCU_DIS_MASK | SSC_DIS_MASK);
    /* Clear all NMI service request flags. I.e. FNMIWKP */
    SCR_SCU_NMISR = 0x0;
    /* Reset Triggers for all External Interrupts to default */
    SCR_SCU_EXICON0 = 0xF0;
    SCR_SCU_EXICON1 = 0xCF; /* Set falling edge trigger for External Interrupt 6 */
    SCR_SCU_EXICON2 = 0xFF;
    SCR_SCU_EXICON3 = 0xFF;
    /* Reset all interrupts */
    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    SCR_SCU_IRCON0 = 0;
    SCR_SCU_IRCON1 = 0;
    SCR_SCU_IRCON2 = 0;

    /* Interrupt enable register 1:
     *  XINTR13 - interrupt node enable (RTC interrupt).
     *  XINTR9  - interrupt node enable (External Interrupt 3-6).
     */
    SCR_IEN1 = 0x88;
    /* Interrupt enable register 0:
     *  EA - Global Interrupt Mask set.
     */
    SCR_IEN0_EA = 1;
    /*** ~Initialize interrupts ***/

    /*** Initialize RTC ***/
    Scr_set_count_registers(0);
    /* Set RTC overflow setting with the shared data from the TC */
    SCR_RTC_CR3 = g_exchangeBytes[3];
    SCR_RTC_CR2 = g_exchangeBytes[2];
    SCR_RTC_CR1 = g_exchangeBytes[1];
    SCR_RTC_CR0 = g_exchangeBytes[0];
    /*** ~Initialize RTC ***/

    /* Switch to LF mode */
    Scr_set_fsys_70kHz();
    /* Enable Real-Time clock compare interrupt, 9-bit prescaler is bypassed, 70 kHz clock is selected */
    SCR_RTC_CON = (ECRTC_MASK | RTPBYP_MASK);
    /* Start Real-Time clock operation */
    Scr_start_rtc();

    while(1)
    {
        /* Periodic update of RTC overflow setting with the shared data from the TC */
        if(g_RTCtick)
        {
            /* Clear flag */
            g_RTCtick = FALSE;
            /* Toggle P00.4 (LED) */
            SCR_SET_IO_PAGE(MOD_PAGE_0);
            SCR_IO_P00_OMTR = ScrIoPin4;
            SCR_RTC_CR3 = g_exchangeBytes[3];
            SCR_RTC_CR2 = g_exchangeBytes[2];
            SCR_RTC_CR1 = g_exchangeBytes[1];
            SCR_RTC_CR0 = g_exchangeBytes[0];
        }

        /* Periodic wake-up for trimming RTC */
        if(g_trimRTC)
        {
            /* Clear flag */
            g_trimRTC = FALSE;
            /* Set wake-up reason */
            g_wakeUpReason = WAKEUP_REASON_TRIM;
            /* Software Wake-Up from Standby Mode */
            SCR_SET_SCU_PAGE(MOD_PAGE_1);
            SCR_SCU_STDBYWKP = SCRWKP_MASK;
            while(Scr_is_in_standby());    /* Wait until TC leaves standby mode */
        }

        /* Wake-up caused by external interrupt */
        if(g_extTrigger)
        {
            /* Clear flag */
            g_extTrigger = FALSE;
            /* Set wake-up reason */
            g_wakeUpReason = WAKEUP_REASON_EXTI;
            /* Software Wake-Up from Standby Mode */
            SCR_SET_SCU_PAGE(MOD_PAGE_1);
            SCR_SCU_STDBYWKP = SCRWKP_MASK;
            while(Scr_is_in_standby());    /* Wait until TC leaves standby mode */
        }
    }
}

/* RTC Interrupt Service Routine (using SCR Interrupt Node 13)  */
void rtcIsrHandler(void) __interrupt (XINTR13)
{
    SCR_SET_SCU_PAGE_STNR1(MOD_PAGE_0); /* Store current SCU page and switch to page 0 */
    SCR_SET_IO_PAGE_STNR1(MOD_PAGE_0);  /* Store current IO page and switch to page 0 */
    /* Clear compare match flag set by hardware */
    SCR_RTC_CON &= (~CFRTC_MASK);

    /* Share the dummy counter with TC via SCRINTEXCHG, counter for debug purpose */
    g_debugCounter = SCR_SCU_SCRINTEXCHG;
    g_debugCounter += 1;
    SCR_SCU_SCRINTEXCHG = g_debugCounter;

    g_RTCtick = TRUE;

    /* Check if TC is in standby */
    if(Scr_is_in_standby())
    {
        if(g_nextTrimCounter > 0)
        {
            g_nextTrimCounter--;

            if(g_nextTrimCounter == 0)
            {
                g_trimRTC = TRUE;
            }
        }
    }

    SCR_RESTORE_IO_PAGE_STNR1();    /* Restore previous IO page */
    SCR_RESTORE_SCU_PAGE_STNR1();   /* Restore previous SCU page */
}

/* External Interrupt Service Routine (using SCR Interrupt Node 9) */
void exi3to6IsrHandler(void) __interrupt (XINTR9)
{
    SCR_SET_SCU_PAGE_STNR2(MOD_PAGE_0); /* Store current SCU page and switch to page 0 */
    /* EXINT6 (P01.3/P33.11) */
    if(SCR_SCU_IRCON0 & IRCON0_EXINT6_MASK)
    {
        /* Clear interrupt flag set by hardware */
        SCR_SCU_IRCON0 &= ((~IRCON0_EXINT6_MASK) & IRCON0_MASK);
        g_extTrigger = TRUE;
    }

    SCR_RESTORE_SCU_PAGE_STNR2();   /* Restore previous SCU page */
}
