/**********************************************************************************************************************
 * \file CaptureCompare.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "CaptureCompare.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define TIMER_ID            (0u)    /* Timer ID of the CCU6 timer - T12 ID = 0 */
#define INPUT_ID            (3u)    /* Interrupt ID of the CCU6xIND connected to WUT output */
#define MODE_SEL            (7u)    /* CCU6 MODE 4: T12 Capture, Any edge, Simultaneous transfer */
#define NODE_SEL            (0u)    /* Interrupt node SR0 for all CCU6 interrupts */

/* Run the CCU6 clock as slow as possible */
#define CCU6_FREQ_PRESC     (7u)    /* prescaler/128 */
#define CCU6_ADD_PRESC_EN   (1u)    /* additional prescaler of /256 */
#define CCU6_PERIOD         (2.0f)  /* [sec] */
#define CCU60_INT0          (5u)    /* CCU60 interrupt priority */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
uint16 g_CCU60_capture = 0;     /* Global variable that stores a new delta capture */
boolean g_calibrateWUT = FALSE; /* Global variable used as a flag to indicated new calibration event */

/*********************************************************************************************************************/
/*--------------------------------------------Private Variables/Constants--------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/

/* Function: init_CCU6
 * --------------------
 * Initializes CCU6 to capture CCU60_CC60IND.
 * Configures CCU6 for required wake-up period, close to WUT Tnom+30% in order to capture
 * WUT overflow events.
 * Configures WUT clock source as SYSPLL.
 *
 * returns: resulting frequency of CCU6_T12 timer in Hz
 */
uint32 init_CCU6(void)
{
    uint32 countMode = IfxCcu6_T12CountMode_edgeAligned;
    uint32 timerID = IfxCcu6_TimerId_t12; /* Use T12 timer for capturing*/
    uint32 SPBfrequency = IfxScuCcu_getSpbFrequency(); /* Get SPB frequency*/

    /* Enable module clock*/
    {
        uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
        IfxScuWdt_clearCpuEndinit(passwd);
        CCU60_CLC.U = 0x0;
        IfxScuWdt_setCpuEndinit(passwd);

        /* Wait until module is enabled */
        while (CCU60_CLC.B.DISS != 0);
    }

    CCU60_MCFG.U = CCU60_MCFG.U | (1U << TIMER_ID); /* Enable Timer12 if it hasn't been enabled by any other interface */

    CCU60_PISEL0.U = (CCU60_PISEL0.U & ~0x3U) | (INPUT_ID); /* Configure CC6xIND vector */

    CCU60_INP.U = (uint32)(NODE_SEL << 10 & NODE_SEL); /* Configure interrupt node pointer */

    CCU60_IEN.U = 0x1; /* Interrupt enable - ENCC60R */

    CCU60_T12MSEL.U = (uint32)MODE_SEL << TIMER_ID; /* Enable capture mode for T12 */

    CCU60_TCTR4.U = (uint32)(1 << 7); /* T12 clear without shadow transfer */

    uint32 freqT12 = SPBfrequency >> CCU6_FREQ_PRESC; /* T12 clock frequency fT12 = fSPB/128 */

    CCU6_ADD_PRESC_EN ? freqT12 = freqT12 >> 8 : freqT12; /* If additional prescaler enabled fT12 = fSPB/32768 (by default ~3052 Hz) */

    float periodT12_in_clk = freqT12 * CCU6_PERIOD; /* Number of clock ticks to get predefined CCU6_T12 period */

    Ifx_TimerValue period_in_clk = ((Ifx_TimerValue)(periodT12_in_clk / 2)) * 2; /* Floor it and use as a period value depending on the clock edge alignment */
    uint16 periodVal = (uint16)((countMode != IfxCcu6_T12CountMode_edgeAligned) ? ((period_in_clk / 2) - 1) : (period_in_clk - 1));
    CCU60_T12PR.B.T12PV = periodVal;

    /* Setup the T1x clock*/
    IfxCcu6_TimerInputClock timerSetup = (IfxCcu6_TimerInputClock)((CCU6_FREQ_PRESC & 0x7U) | CCU6_ADD_PRESC_EN << 3 | countMode << 7);
    uint32 shift = (timerID * 8); /* Select T1x timer with shift and mask */
    uint32 mask = (0x7U << shift);
    CCU60_TCTR0.U = (CCU60_TCTR0.U & ~mask) | ((uint32)timerSetup << shift);
    CCU60_TCTR4.U |= (uint32)(1 << 6) << shift; /* T1x enable */

    return freqT12; /* CCU6_T12_frequency (Hz) */
}

void enable_CCU6_service_request(void)
{
    IfxSrc_init (&SRC_CCU60SR0, IfxSrc_Tos_cpu0, CCU60_INT0);
    IfxSrc_enable (&SRC_CCU60SR0);
}

/* Interrupt: __CCU60_capture_int
 * --------------------
 * CCU60 interrupt service routine for CCU6_INT0. Estimates the time delta for the CCU60 between old
 * and new captured values.
 *
 * g_CCU60_capture: global variable that stores a new delta capture.
 * g_calibrateWUT: global variable used as a flag to indicated new calibration event.
 *
 * returns: none
 */
IFX_INTERRUPT (__CCU60_capture_int, 0, CCU60_INT0);
void __CCU60_capture_int(void)
{
    if(CCU60_IS.B.ICC60R || CCU60_IS.B.ICC60F)
    {
        CCU60_ISR.B.RCC60R = 1;
        CCU60_ISR.B.RCC60F = 1;
    }

    g_CCU60_capture = CCU60_CC60SR.U - g_CCU60_capture;
    g_calibrateWUT = TRUE; /* Set the flag for the next calibration request */
}
