/**
 * \file IfxAdc_Tmadc.h
 * \brief ADC TMADC details
 * \ingroup IfxLld_Adc
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * Interface layer for TMADC functionality of converter.
 *
 *  \defgroup IfxLld_Adc_Tmadc_Usage How to use the TMADC Interface driver?
 *  \ingroup IfxLld_Adc
 *
 *  Design of module:
 *
 *  Initializations
 *
 *   1. Module configuration does high level settings and boundary value settings.
 *       a. It also assigns the SAR cores.
 *   2. Triggers are configured : user configures multiple triggers config with trigger sources.
 *       a. These triggers are then mapped to a group  or a channel as per user need
 *   3. A group configuration is only logical:
 *       a. It is for trigger uniformity
 *       b. It is also for interrupt configuration (all channels done interrupts)
 *   4. channel configuration does all the actual configurations:
 *       a. It picks up the appropriate configuration of trigger from channel  / group config
 *       b. It optionally initializes the interrupt if not part of a group  /or if user wants a separate interrupt for this.
 *
 *  Run time:
 *
 *   1. Due to logical group concept implemented in driver, user can:
 *       a. Trigger  / read  / view state of individual channels
 *       b. Trigger / read  / view state of groups
 *
 *  How to use (Brief expectation):
 *
 *  Configuration
 *
 *   1. Configure module configuration data structure
 *       a. Emux configuration
 *       b. Boundary value registers configuration
 *       c. SAR core assignments
 *   2. Configure Trigger configuration data structure
 *       a. Select trigger sources
 *       b. Select trigger delays
 *       c. This can be mapped to a group / channel
 *   3. Configure an optional group data structure
 *       a. Select the trigger configuration
 *       b. Set all channels
 *       c. Configure the interrupt configuration
 *   4. Configure all channel data structure
 *       a. Sampling time / mode / channel ID
 *       b. Select the trigger (if not in group)
 *       c.Pin configuration
 *
 *  Initialization routine:
 *
 *   1. Module init  (IfxAdc_Tmadc_initModule())
 *       a. channel mapping
 *   2. Call the optional group init  (IfxAdc_Tmadc_initGroup())
 *       a. Interrupt initialize
 *       b. All applicable channel handles will be mapped to group handle
 *   3. Loop and Initialize all channels. (IfxAdc_Tmadc_initChannel)
 *       a.All initialization for channel done here
 *
 *  Steps to use the driver:
 *
 *  \section IfxLld_Adc_Tmadc_Preparation Preparation
 *  \subsection IfxLld_Adc_Tmadc_Include Include Files
 *
 *  Include following header file into your C code:
 *  \code
 *  #include <Adc/Tmadc/IfxAdc_Tmadc.h>
 *  \endcode
 *
 *  \subsection IfxLld_Adc_Tmadc_Interrupt Interrupt Handler Installation
 *  See also \ref IfxLld_Cpu_Irq_Usage
 *
 *  Define priorities for the Interrupt handlers. This is normally done in the Ifx_IntPrioDef.h file:
 * \code
 * // priorities are normally defined in Ifx_IntPrioDef.h
 * #define IFX_INTPRIO_TMADC_SR0  1
 * #define IFX_INTPRIO_TMADC_SR1  2
 * #define IFX_INTPRIO_TMADC_SR2  3
 * \endcode
 *
 * Add the interrupt service routines to your C code:
 * \code
 * IFX_INTERRUPT(resultIsr, 0, IFX_INTPRIO_CDSP_SR0);
 * IFX_INTERRUPT(boundaryEventIsr,  0, IFX_INTPRIO_CDSP_SR1);
 *
 * IfxCpu_enableInterrupts();
 *
 * void resultIsr(void)
 * {
 *   // Read TMADC channel result
 *   // Refer IfxLld_Adc_Tmadc_ConversionResult section
 * }
 *
 * void boundaryEventIsr(void)
 * {
 *   //Boundary event
 * }
 *
 * \endcode
 *
 *  \subsection IfxLld_Adc_Tmadc_Init Module Initialization
 *  \code
 *    #define NUM_CHANNELS_GROUP (2U)
 *
 *    //Declare a TMADC module,channel structure and module,channel handle
 *    IfxAdc_Tmadc_Config module0Config;
 *    IfxAdc_Tmadc module0Handle;
 *    IfxAdc_Tmadc_ChConfig channel0Config;
 *    IfxAdc_Tmadc_Ch channel0Handle;
 *
 *    // Channel 0 and channel 1 are grouped
 *    IfxAdc_Tmadc_ChConfig channelConfig[NUM_CHANNELS_GROUP];
 *    IfxAdc_Tmadc_Ch channelHandle[NUM_CHANNELS_GROUP];
 *
 *    // Declare group configuration structure and handle if group is needed
 *    IfxAdc_Tmadc_GroupConfig mygrpCfg;
 *    IfxAdc_Tmadc_Group mygrpHandle;
 *
 *    //Enable ADC module
 *    IfxAdc_enableModule(&MODULE_ADC);
 *
 *   //Set the global configuration of module to default values.
 *   IfxAdc_Tmadc_initModuleConfig(&module0Config, &MODULE_ADC);
 *
 *   //Modify the module configuration as per application need
 *   module0Config.id               = IfxAdc_TmadcModule_0;
 *   module0Config.calEnable        = 1;
 *   module0Config.shadowBnd0Update = 1; //Update boundary values on a HW trigger event
 *
 * //Interrupt configuration
 * IfxAdc_Tmadc_InterruptConfig  myintCfg0 = {IfxAdc_TmadcServReq_0,IfxAdc_TmadcEventOp_andLogic,IfxAdc_TmadcEventSel_result,IfxSrc_Tos_cpu0,0,IFX_INTPRIO_SR0};
 * IfxAdc_Tmadc_InterruptConfig myintCfg1 = {IfxAdc_TmadcServReq_1,IfxAdc_TmadcEventOp_orLogicWithoutWfc,IfxAdc_TmadcEventSel_boundary,IfxSrc_Tos_cpu0,0,IFX_INTPRIO_SR1};
 * IfxAdc_Tmadc_InterruptConfig  myintCfg2 = {IfxAdc_TmadcServReq_2,IfxAdc_TmadcEventOp_andLogic,IfxAdc_TmadcEventSel_result,IfxSrc_Tos_cpu0,0,IFX_INTPRIO_SR2};
 * IfxAdc_Tmadc_ServRequestConfig mySrvConfig;
 * {
 *  mySrvConfig.intConfig[0] = &myintCfg0;
 *  mySrvConfig.intConfig[1] = &myintCfg1;
 *  mySrvConfig.intConfig[2] = &myintCfg2;
 *  mySrvConfig.numServReqNodes = 3;
 *  module0Config.srvReqCfg = &mySrvConfig;
 * }
 *
 * // Boundary configuration
 * IfxAdc_Tmadc_TriggerConfig bound_trig;
 * IfxAdc_Tmadc_BoundaryConfig bound_cfg;
 * IfxAdc_Tmadc_ModuleBoundConfig moduleBoundCfg;
 * {
 *  //Initialize boundary configuration
 *  bound_cfg.lowerBound = 0x100;
 *  bound_cfg.upperBound = 0x200;
 *  bound_cfg.flagCfg.enable = 1;
 *  bound_cfg.flagCfg.resultRegSel = IfxAdc_TmadcResultReg_0;
 *  bound_trig.hwTrigger.muxSel = IfxAdc_TmadcTriggerMuxSel_7;
 *  bound_trig.hwTrigger.edgeSel = IfxAdc_TmadcTriggerMode_risingEdge;
 *  bound_cfg.trigger = &bound_trig;
 *  moduleBoundCfg.boundCfg1 = &bound_cfg;
 *  moduleBoundCfg.boundCfg2 = NULL_PTR;
 *  module0Config.bndryConfig = &moduleBoundCfg;
 * }
 *
 * // Initialize TMADC module
 * IfxAdc_Tmadc_initModule(&module0Handle, &module0Config);
 *
 *  //Set the configuration of channel/group to default values.
 *  IfxAdc_Tmadc_initGroupConfig(&mygrpCfg);
 *
 *  //Modify group configuration
 *  IfxAdc_Tmadc_ChannelTriggerConfig groupTrigger = {{IfxAdc_TmadcTriggerMuxSel_5, IfxAdc_TmadcTriggerMode_risingEdge},{IfxAdc_TmadcTriggerMuxSel_none,IfxAdc_TmadcTriggerMode_disable},50};;
 *  IfxAdc_Tmadc_ChannelServReqConfig grpservReqNode = {IfxAdc_TmadcServReq_none, IfxAdc_TmadcServReq_1, IfxAdc_TmadcServReq_2};
 *  {
 *      mygrpCfg.channels = ((1u << IfxAdc_TmadcChannel_1) | (1u << IfxAdc_TmadcChannel_2)); //(Each bit position represents channel id 0x06 --> 0110)
 *      mygrpCfg.trigger     = &groupTrigger;
 *      mygrpCfg.numChannels = 2;
 *      mygrpCfg.grpSrvReq   = &grpservReqNode;
 *      }
 *
 * IfxAdc_Tmadc_initChannelConfig(&channel0Config, &MODULE_ADC);
 * channel0Config.moduleId = IfxAdc_TmadcModule_0;
 * channel0Config.id       = IfxAdc_TmadcChannel_0;
 *
 *  //Modify the channel/group configuration
 *  IfxAdc_Tmadc_ChannelTriggerConfig chnl0trig = {{IfxAdc_TmadcTriggerMuxSel_1, IfxAdc_TmadcTriggerMode_risingEdge},{IfxAdc_TmadcTriggerMuxSel_none,IfxAdc_TmadcTriggerMode_disable},50};
 *  IfxAdc_Tmadc_ChannelServReqConfig chnl0servReq = {IfxAdc_TmadcServReq_none, IfxAdc_TmadcServReq_1, IfxAdc_TmadcServReq_0};
 *  {
 *  channel0Config.samplingTimeNS = 50;
 *  channel0Config.trigger = &chnl0trig;
 *  channel0Config.channelSrvReq = &chnl0servReq;
 *  channel0Config.resultCfg.boundMode = 0;
 *  channel0Config.resultCfg.boundCmpMode = 1;
 *  channel0Config.resultCfg.boundRegSel = IfxAdc_TmadcBoundaryReg_0;
 *  channel0Config.resultCfg.resultReg = IfxAdc_TmadcResultReg_0;
 *  }
 *  IfxAdc_Tmadc_initChannel(&channel0Handle, &channel0Config);
 *
 *  for(uint8 index = 0u; index < NUM_CHANNELS_GROUP; index++)
 *  {
 *  IfxAdc_Tmadc_initChannelConfig(&channelConfig[index], &MODULE_ADC);
 *  channelConfig[index].moduleId              = IfxAdc_TmadcModule_0;
 *  channelConfig[index].id                    = (IfxAdc_TmadcChannel)(index + IfxAdc_TmadcModule_1);
 *  channelConfig[index].resultCfg.boundMode    = 1; //set boundary flag if resut outside boundary, boundary event generated
 *  channelConfig[index].resultCfg.boundCmpMode = IfxAdc_TmadcBoundaryCmpMode_bothBound;
 *  channelConfig[index].resultCfg.boundRegSel  = IfxAdc_TmadcBoundaryReg_0;
 *  channelConfig[index].groupCfg               = &mygrpCfg;
 *  channelConfig[index].resultCfg.resultReg    = (IfxAdc_TmadcResultReg)(index + IfxAdc_TmadcResultReg_1);
 *
 *  //Initialize TMADC channel/group
 *  IfxAdc_Tmadc_initChannel(&channelHandle[index], &channelConfig[index]);
 *  }
 *
 * //Note: Group Trigger configuration will be set in channel initialization if
 * // channel is part of group else channel trigger configuration will be used.
 * IfxAdc_Tmadc_initGroup(&mygrpHandle, &mygrpCfg);
 *
 *   //Initialize TMADC channel/group
 *   IfxAdc_Tmadc_initChannel(&channel0Handle, &module0Handle, &channel0Config);
 *   IfxAdc_Tmadc_initChannel(&channel1Handle, &module0Handle, &channel1Config);
 *   IfxAdc_Tmadc_initChannel(&channel2Handle, &module0Handle, &channel2Config);
 *
 *   //Note: Group Trigger configuration will be set in channel initialization if
 *   // channel is part of group else channel trigger configuration will be used.
 *    IfxAdc_Tmadc_initGroup(&mygrpHandle, &mygrpCfg);
 *
 *   // Run TMADC module.
 *   IfxAdc_Tmadc_runModule(&module0Handle);
 * \endcode
 *
 *  \section IfxLld_Adc_Tmadc_ConversionResult Conversion Result
 *  \code
 *        //API to read result value.
 *        uint16 result;
 *        result = IfxAdc_Tmadc_readChannelResult(&channel0Handle);
 *
 *        // API to read timestamp value
 *        uint16 timestamp;
 *        timestamp = IfxAdc_Tmadc_readTimestamp(&channel0Handle);
 *
 *        //API to read result and timestamp and result both
 *        IfxAdc_Tmadc_Result result;
 *        result = IfxAdc_Tmadc_readRawResult(&channel0Handle);
 *  \endcode
 *
 *  \section IfxLld_Adc_Tmadc_Trigger Trigger API
 *  \code
 *
 *       //Api available for software trigger
 *       IfxAdc_Tmadc_triggerChannel(&channel0Handle);
 *       IfxAdc_Tmadc_triggerGroup(&mygrpHandle);
 * \endcode
 *
 *  Circular buffer configuration to store multiple results of single channel through DMA.
 *  \subsection IfxLld_Adc_Tmadc_Queue Circular buffer with type of service as DMA.
 *  The conversion result in the TMADC result register is copied in software buffer on result service request event.
 *
 *   Queue Configuration with DMA
 *  \code
 *  #define BUFFER_SIZE 8
 *
 *  uint32 __attribute__ ((aligned(64)))  resultData[BUFFER_SIZE];
 *
 *  //Refer Module initialization section above for below points
 *  //1. Enable ADC module
 *  //2. Enable Clock to Tmadc Module
 *  //3. Declare a TMADC module,channel structure and module,channel handle
 *  //4. Call IfxAdc_Tmadc_initModuleConfig to set the global configuration of module to default values.
 *  //5. Modify the module configuration as per application need
 *
 *  //Result service request
 *  IfxAdc_Tmadc_InterruptConfig myservReq0 = {IfxAdc_TmadcServReq_0,IfxAdc_TmadcEventOp_orLogicWithoutWfc,IfxAdc_TmadcEventSel_result,IfxSrc_Tos_dma0,0,IfxDma_ChannelId_1};
 *  //Boundary service request
 *  IfxAdc_Tmadc_InterruptConfig myservReq1 = {IfxAdc_TmadcServReq_1,IfxAdc_TmadcEventOp_orLogicWithoutWfc,IfxAdc_TmadcEventSel_boundary,IfxSrc_Tos_cpu0,0,2};
 *
 * IfxAdc_Tmadc_ServRequestConfig mySrvConfig;
 * mySrvConfig.intConfig[0] = &myservReq0;
 * mySrvConfig.intConfig[1] = &myservReq1;
 * mySrvConfig.numServReqNodes = 2;
 * module0Config.srvReqCfg = &mySrvConfig;
 *
 *  //6. Call IfxAdc_Tmadc_initChannelConfig to set the channel configuration to default values.
 *  //7. Modify the channel configuration
 *  //Trigger configuration
 *  IfxAdc_Tmadc_ChannelTriggerConfig chnl0trig = {{IfxAdc_TmadcTriggerMuxSel_0,IfxAdc_TmadcTriggerMode_risingEdge}, {IfxAdc_TmadcTriggerMuxSel_0, IfxAdc_TmadcTriggerMode_risingEdge}, 0};
 *  //Service request configuration
 *  IfxAdc_Tmadc_ChannelServReqConfig chnl0servReq = {IfxAdc_TmadcServReq_none,IfxAdc_TmadcServReq_1,IfxAdc_TmadcServReq_0};
 *
 *  channel0Config.trigger = &chnl0trig;
 *  channel0Config.channelSrvReq = &chnl0servReq;
 *
 *  //DMA configuration
 *  IfxAdc_Tmadc_DmaConfig dmaConfig;
 * dmaConfig.channelId    = IfxDma_ChannelId_1;
 * dmaConfig.dmaId        = IfxDma_Index_0;
 * dmaConfig.dmaSrvReqCfg =  NULL_PTR;
 *
 * IfxAdc_Tmadc_QueueConfig queueConfig;
 * queueConfig.bufferPtr          = &resultData;
 * queueConfig.bufferType         = IfxAdc_Tmadc_BufferType_circular;
 * queueConfig.size                     = BUFFER_SIZE;
 * queueConfig.bufferFullCallback = NULL_PTR;
 * queueConfig.dmaCfg             = &dmaConfig;
 *
 * channel0Config.queueCfg  = &queueConfig;
 *
 *  //8. Initialize TMADC channel
 *  IfxAdc_Tmadc_initChannel(&channel0Handle, &channel0Config);
 *
 *  //9. Initialize TMADC module
 *  IfxAdc_Tmadc_initModule(&module0Handle, &module0Config);
 *
 *  // Reading result from circular buffer
 *  uint16 numOfValidResult;
 *  uint16 result;
 *  numOfValidResult = IfxAdc_Tmadc_getNumberOfChannelResults(&channel0Handle);
 *
 *  for(uint16 index = 0; index < numOfValidResult; index++)
 *  {
 *      result = IfxAdc_Tmadc_readChannelCircularBufferResult(&channel0Handle); //use result in your application
 *  }
 *  \endcode
 *
 * \defgroup IfxLld_Adc_Tmadc TMADC
 * \ingroup IfxLld_Adc
 * \defgroup IfxLld_Adc_Tmadc_Enum Enumerations
 * \ingroup IfxLld_Adc_Tmadc
 * \defgroup IfxLld_Adc_Tmadc_Data_Structures Data Structures
 * \ingroup IfxLld_Adc_Tmadc
 * \defgroup IfxLld_Adc_Tmadc_Module_Initialization Module initialization
 * \ingroup IfxLld_Adc_Tmadc
 * \defgroup IfxLld_Adc_Tmadc_Channel_Initialization Channel Initialization
 * \ingroup IfxLld_Adc_Tmadc
 * \defgroup IfxLld_Adc_Tmadc_Group_Initialization Group Initialization
 * \ingroup IfxLld_Adc_Tmadc
 * \defgroup IfxLld_Adc_Tmadc_Trigger Trigger functionality
 * \ingroup IfxLld_Adc_Tmadc
 * \defgroup IfxLld_Adc_Tmadc_Result Result
 * \ingroup IfxLld_Adc_Tmadc
 */

#ifndef IFXADC_TMADC_H
#define IFXADC_TMADC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Adc/Std/IfxAdc.h"
#include "Dma/Dma/IfxDma_Dma.h"
#if !defined(IFX_ILLD_PPU_USAGE)
#include "Stm/Timer/IfxStm_Timer.h"
#endif

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro to assist in adding a channel to the core
 */
#define IFXADC_TMADC_ADD_CHANNEL_TO_CORE(chSet, x) (((uint16)(1 << x)) | chSet)

/** \brief Number of service request per TMADC module
 */
#define IFXADC_TMADC_MAX_SERV_REQ_NODE     ((uint32)(0x07u))

/** \brief Offset between two result and timestamp register in AW2 segment
 */
#define IFXADC_TMADC_AW1_RES_TS_OFFSET     (2U)

/** \brief Macro for Calibration successfully completed
 */
#define IFXADC_TMADC_CALIBRATION_COMPLETE  (2U)

/** \brief MACRO to get linear buffer type with timestamp
 */
#define IFXADC_TMADC_RESULT_BUFFER_WITH_TS(typeName) \
    typedef struct {                                 \
        uint32 timeStamp;                            \
        uint32 results;                              \
    } typeName;

/** \brief Macro for minimum sampling time for monitor channel
 */
#define IFXADC_TMADC_MCH_MIN_SAMPLING_TIME (0x4FU)

/** \brief Macro for TMADC module power on phase completed
 */
#define IFXADC_TMADC_POWERONPHASE_COMPLETE (2U)

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Type definition for Callback functions
 * \return None
 */
typedef void (*IfxAdc_Tmadc_Callback)(void);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Tmadc_Enum
 * \{ */
/** \brief Enumeration describing buffer types.
 */
typedef enum
{
    IfxAdc_Tmadc_BufferType_linear              = 0,  /**< \brief Configured buffer is linear buffer */
    IfxAdc_Tmadc_BufferType_linearWithTimestamp = 1,  /**< \brief Configured buffer is Linear buffer with timestamp */
    IfxAdc_Tmadc_BufferType_circular            = 2   /**< \brief Configured buffer is circular buffer */
} IfxAdc_Tmadc_BufferType;

/** \brief Enumeration describing channel states
 */
typedef enum
{
    IfxAdc_Tmadc_channelState_uninitialized = 0,  /**< \brief uninitialized state */
    IfxAdc_Tmadc_channelState_initialized   = 1   /**< \brief initialized */
} IfxAdc_Tmadc_channelState;

/** \brief Enumeration describing various states of module
 */
typedef enum
{
    IfxAdc_Tmadc_moduleState_unknown          = 0,  /**< \brief unknown state */
    IfxAdc_Tmadc_moduleState_calibration      = 1,  /**< \brief calibration ongoing */
    IfxAdc_Tmadc_moduleState_calibrationError = 2,  /**< \brief calibration error occured */
    IfxAdc_Tmadc_moduleState_initialized      = 3,  /**< \brief initialized */
    IfxAdc_Tmadc_moduleState_run              = 4,  /**< \brief Run State */
    IfxAdc_Tmadc_moduleState_notPoweredOn     = 5   /**< \brief Module is not powered on or power on sequence is active */
} IfxAdc_Tmadc_moduleState;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Tmadc_Data_Structures
 * \{ */
/** \brief Hardware Trigger Configuration
 */
typedef struct
{
    IfxAdc_TmadcTriggerMuxSel muxSel;        /**< \brief mux Selection value for trigger */
    IfxAdc_TmadcTriggerMode   edgeSel;       /**< \brief Edge selection for trigger */
} IfxAdc_Tmadc_HwTriggerConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Data_Structures
 * \{ */
/** \brief Tmadc Boundary flag configuration
 */
typedef struct
{
    IfxAdc_TmadcResultReg resultRegSel;       /**< \brief Result register selection for boundary flag */
    boolean               enable;             /**< \brief enable/disable boundary flag */
} IfxAdc_Tmadc_BoundaryFlagCfg;

/** \brief Data structure holding service request configuration raised by DMA to CPU.
 * If configured buffer is of type linear then buffer full interrupt.
 */
typedef struct
{
    Ifx_Priority priority;            /**< \brief Interrupt priority */
    IfxSrc_Tos   typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
} IfxAdc_Tmadc_DmaSrvReq;

/** \brief Boundary Trigger Configuration
 */
typedef struct
{
    IfxAdc_Tmadc_HwTriggerConfig hwTrigger;       /**< \brief Hardware Trigger Source 1 */
    float32                      delayNS;         /**< \brief trigger delay in nano seconds */
} IfxAdc_Tmadc_TriggerConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Data_Structures
 * \{ */
/** \brief Data structure holding a boundary configuration
 */
typedef struct
{
    uint16                       upperBound;       /**< \brief Upper boundary (12 Bit) */
    uint16                       lowerBound;       /**< \brief Lower boundary (12 Bit) */
    IfxAdc_Tmadc_TriggerConfig  *trigger;          /**< \brief Pointer to the trigger configuration for update */
    IfxAdc_Tmadc_BoundaryFlagCfg flagCfg;          /**< \brief Boundary flag Configuration */
} IfxAdc_Tmadc_BoundaryConfig;

/** \brief Data Structure holding the channel service request configuration
 */
typedef struct
{
    IfxAdc_TmadcServReq errorNode;          /**< \brief Service request error node */
    IfxAdc_TmadcServReq boundaryNode;       /**< \brief Service request boundary node */
    IfxAdc_TmadcServReq resultNode;         /**< \brief Service request result node */
} IfxAdc_Tmadc_ChannelServReqConfig;

/** \brief DMA handle
 */
typedef struct
{
    IfxDma_Dma_Channel channel;       /**< \brief DMA channel handle */
    IfxDma_Index       dmaId;         /**< \brief Dma Module Index */
    boolean            useDma;        /**< \brief use Dma for Data transfer/s */
} IfxAdc_Tmadc_Dma;

/** \brief Dma configuration
 */
typedef struct
{
    IfxAdc_Tmadc_DmaSrvReq *dmaSrvReqCfg;       /**< \brief ISR configuration from DMA to CPU on buffer full */
    IfxDma_ChannelId        channelId;          /**< \brief DMA channel number */
    IfxDma_Index            dmaId;              /**< \brief Dma Module Index */
} IfxAdc_Tmadc_DmaConfig;

/** \brief Emux pin configuration
 */
typedef struct
{
    IFX_CONST IfxAdc_Emuxctrl_Out *emuxCtrl0Pin;       /**< \brief Emux Control 0 pin which should be configured */
    IfxPort_OutputMode             ctrl0PinMode;       /**< \brief Emux control0 pin mode */
    IFX_CONST IfxAdc_Emuxctrl_Out *emuxCtrl1Pin;       /**< \brief Emux Control 1 pin which should be configured */
    IfxPort_OutputMode             ctrl1PinMode;       /**< \brief Emux control1 pin mode */
    IfxPort_PadDriver              pinDriver;          /**< \brief Pin Driver Configuration */
} IfxAdc_Tmadc_EmuxPinConfig;

/** \brief Structure for Interrupt configuration
 */
typedef struct
{
    IfxAdc_TmadcServReq  node;                /**< \brief Service request node selection */
    IfxAdc_TmadcEventOp  eventOp;             /**< \brief Service request event operation */
    IfxAdc_TmadcEventSel eventSel;            /**< \brief TMADC event selection */
    IfxSrc_Tos           typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId          vmId;                /**< \brief Virtual Machine Number */
    Ifx_Priority         priority;            /**< \brief Channel event priority */
} IfxAdc_Tmadc_InterruptConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Data_Structures
 * \{ */
/** \brief Channel pin configuration
 */
typedef struct
{
    IFX_CONST IfxAdc_TmadcCh_In *tmadcInPin;         /**< \brief Analog input channel */
    IfxPort_InputMode            tmadcPinMode;       /**< \brief Analog tmadc input pin mode */
    IfxPort_PadDriver            pinDriver;          /**< \brief Pin Driver Configuration */
} IfxAdc_Tmadc_ChannelPinConfig;

/** \brief Data structure holding the trigger Configuration
 */
typedef struct
{
    IfxAdc_Tmadc_HwTriggerConfig hwTrigger1;       /**< \brief Hardware Trigger Source 1 */
    IfxAdc_Tmadc_HwTriggerConfig hwTrigger2;       /**< \brief Hardware Trigger 2 */
    float32                      delayNS;          /**< \brief trigger delay in nano seconds */
} IfxAdc_Tmadc_ChannelTriggerConfig;

/** \brief Tmadc Emux configuration
 */
typedef struct
{
    uint8                        count;                 /**< \brief Channel count */
    boolean                      emuxCi0;               /**< \brief True --> Control interface 0 enabled */
    boolean                      emuxCi1;               /**< \brief True --> Control interface 1 enabled */
    IfxAdc_TmadcEmuxCodingScheme exmuxCodeScheme;       /**< \brief True --> EMUX channel selection lines are gray coded */
    IfxAdc_Tmadc_EmuxPinConfig  *emuxPins;              /**< \brief Emux Pinx configuration */
} IfxAdc_Tmadc_EmuxConfig;

/** \brief Structure for Global SR6 Service Request configuration
 */
typedef struct
{
    IfxAdc_TmadcGlobalServReq servReq;             /**< \brief Global service request node selection */
    boolean                   enableEvent;         /**< \brief True --> Enable event on SR6 for corresponding TMADC */
    boolean                   eventLogic;          /**< \brief EVOP True --> AND Logic, False --> OR Logic */
    IfxSrc_Tos                typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId               vmId;                /**< \brief Virtual Machine Number */
    Ifx_Priority              priority;            /**< \brief Global event priority */
} IfxAdc_Tmadc_GlobalServRequestConfig;

/** \brief Data Structure holding the group Configuration
 */
typedef struct
{
    uint16                             channels;              /**< \brief Set of channels in this group */
    IfxAdc_TmadcResultReg              baseResultReg;         /**< \brief Lowest Result register number in the group. Result register in the group should be contiguous */
    IfxAdc_Tmadc_ChannelTriggerConfig *trigger;               /**< \brief Pointer to the Trigger configuration for this group */
    IfxAdc_TmadcOpMode                 mode;                  /**< \brief Continuous / one shot mode for group conversion */
    boolean                            waitForRead;           /**< \brief If Set, then the next conversion only happens once all results are read */
    boolean                            enableTimestamp;       /**< \brief True --> Timestamp enabled, False --> Timestamp disabled */
    uint8                              numChannels;           /**< \brief Number of channels in the group */
    IfxAdc_TmadcModule                 moduleId;              /**< \brief Module to which the group belongs */
    IfxAdc_Tmadc_ChannelServReqConfig *grpSrvReq;             /**< \brief Pointer to the channel group service request node configuration */
    IfxAdc_Tmadc_DmaConfig            *dmaCfg;                /**< \brief Dma Configuration */
    void                              *groupResPtr;           /**< \brief Pointer to the group result buffer */
    IfxAdc_Tmadc_Callback              groupCallback;         /**< \brief Callback when result for all channels in group is copied to buffer. */
} IfxAdc_Tmadc_GroupConfig;

/** \brief Module boundary register configurations
 */
typedef struct
{
    IfxAdc_Tmadc_BoundaryConfig *boundCfg1;       /**< \brief 1st boundary register configurations */
    IfxAdc_Tmadc_BoundaryConfig *boundCfg2;       /**< \brief 2nd boundary register configuration */
} IfxAdc_Tmadc_ModuleBoundConfig;

/** \brief Configuration of result handling of a monitor channel in TMADC
 */
typedef struct
{
    boolean                     waitForRead;        /**< \brief If set, no conversion happens until value is read */
    boolean                     boundMode;          /**< \brief True --> set BFL if conversion result outside configured boundary */
    IfxAdc_TmadcBoundaryCmpMode boundCmpMode;       /**< \brief Mode of checking boundary */
    IfxAdc_TmadcBoundaryReg     boundRegSel;        /**< \brief Select boundary register */
} IfxAdc_Tmadc_MonitorChResultConfig;

/** \brief TMADC Queue Handle
 */
typedef struct
{
    uint32                 *bufferPtr;              /**< \brief Application buffer */
    IfxAdc_Tmadc_Callback   buffFullCallback;       /**< \brief Call back if Buffer full. Call back is provided only if ToS = CPU */
    IfxAdc_Tmadc_Dma        dma;                    /**< \brief Dma Handle */
    IfxAdc_Tmadc_BufferType bufferType;             /**< \brief Type of the buffer */
    uint16                  writeIndex;             /**< \brief Write Index of the buffer. */
    uint16                  readIndex;              /**< \brief Read Index of the buffer */
    uint16                  size;                   /**< \brief Size of the buffer in in words */
    uint16                  validResult;            /**< \brief Number of valid results */
    boolean                 bufferFull;             /**< \brief Flag to indicate if buffer full */
    boolean                 queueEnabled;           /**< \brief True --> If queue enabled */
} IfxAdc_Tmadc_Queue;

/** \brief TMADC Queue Configuration
 */
typedef struct
{
    IfxAdc_Tmadc_DmaConfig *dmaCfg;                   /**< \brief Dma Configuration */
    void                   *bufferPtr;                /**< \brief Pointer to the application buffer */
    IfxAdc_Tmadc_Callback   bufferFullCallback;       /**< \brief Callback if Buffer gets full */
    uint16                  size;                     /**< \brief Size of buffer in words */
    IfxAdc_Tmadc_BufferType bufferType;               /**< \brief Type of the buffer */
} IfxAdc_Tmadc_QueueConfig;

/** \brief Configuration of result handling of a channel in TMADC
 */
typedef struct
{
    IfxAdc_TmadcResultReg       resultReg;             /**< \brief Result register associated with channel */
    boolean                     waitForRead;           /**< \brief If set, no conversion happens until value is read */
    boolean                     hysteresisEn;          /**< \brief enable hysteresis mode for bounday check */
    boolean                     boundMode;             /**< \brief True --> set BFL if conversion result outside configured boundary */
    boolean                     enableTimestamp;       /**< \brief True --> Timestamp enabled, False --> Timestamp disabled */
    IfxAdc_TmadcBoundaryCmpMode boundCmpMode;          /**< \brief Mode of checking boundary */
    IfxAdc_TmadcBoundaryReg     boundRegSel;           /**< \brief Select boundary register */
} IfxAdc_Tmadc_ResultConfig;

/** \brief Structure for Service Request Node configuration
 */
typedef struct
{
    IfxAdc_Tmadc_InterruptConfig *intConfig[IFXADC_TMADC_MAX_SERV_REQ_NODE];       /**< \brief Interrupt configuration for SR0-SR6 nodes */
    uint8                         numServReqNodes;                                 /**< \brief Total number of service request nodes */
} IfxAdc_Tmadc_ServRequestConfig;

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Data_Structures
 * \{ */
/** \brief Handle of TMADC module
 */
typedef struct
{
    IfxAdc_TmadcModule       id;               /**< \brief module ID */
    Ifx_ADC_TMADC           *modSFR;           /**< \brief pointer to the module SFR set */
    IfxAdc_Tmadc_moduleState state;            /**< \brief State of module */
    boolean                  calEnabled;       /**< \brief True --> Calibration Enabled */
} IfxAdc_Tmadc;

/** \brief Data structure describing the handle of a channel
 */
typedef struct
{
    Ifx_ADC_TMADC            *modSFR;                 /**< \brief Pointer to tmadc module sfr */
    Ifx_ADC_TMADC_CH         *chSFR;                  /**< \brief Pointer to the channel SFR set */
    volatile Ifx_ADC_RES     *rsltSFR;                /**< \brief Pointer to the result register from SRI view */
    volatile Ifx_ADC_TS      *tmstmpSFR;              /**< \brief Pointer to the timestamp register from SRI view */
    IfxAdc_TmadcResultReg     resultRegNum;           /**< \brief Result register */
    IfxAdc_TmadcChannel       id;                     /**< \brief Channel ID */
    IfxAdc_Tmadc_channelState state;                  /**< \brief state of channel */
    IfxAdc_TmadcBoundaryReg   boundaryReg;            /**< \brief boundary register that is selected for this channel */
    IfxAdc_TmadcModule        moduleId;               /**< \brief Module to which channel belongs */
    IfxAdc_Tmadc_Queue        queue;                  /**< \brief TMADC  queue information */
    boolean                   timeStampEnabled;       /**< \brief True --> Timestamp enabled, False --> Timestamp disabled */
} IfxAdc_Tmadc_Ch;

/** \brief Data Structure holding configuration of a channel of TMADC
 */
typedef struct
{
    IfxAdc_TmadcChannel                id;                   /**< \brief channel ID */
    IfxAdc_TmadcModule                 moduleId;             /**< \brief Module to which channel belongs */
    Ifx_ADC                           *adcSFR;               /**< \brief Pointer to ADC module sfr */
    float32                            samplingTimeNS;       /**< \brief sampling time for channel in NS */
    IfxAdc_TmadcOpMode                 mode;                 /**< \brief Continuous conversion / one shot */
    IfxAdc_TmadcSarCore                core;                 /**< \brief SAR core selection for channel. */
    boolean                            enableEmux;           /**< \brief If TRUE, Channel is connected to EMUX. */
    IfxAdc_Tmadc_ResultConfig          resultCfg;            /**< \brief Result configuration for this channel */
    IfxAdc_Tmadc_ChannelTriggerConfig *trigger;              /**< \brief Pointer to the trigger configuration */
    IfxAdc_Tmadc_ChannelServReqConfig *channelSrvReq;        /**< \brief Pointer to the channel service request configuration */
    IfxAdc_Tmadc_ChannelPinConfig     *channelPin;           /**< \brief Channel Pin configuration */
    IfxAdc_Tmadc_QueueConfig          *queueCfg;             /**< \brief Queue configuration */
    IfxAdc_Tmadc_GroupConfig          *groupCfg;             /**< \brief Pointer to the group configuration */
} IfxAdc_Tmadc_ChConfig;

/** \brief Data Structure holding the configuration of TMADC module
 */
typedef struct
{
    IfxAdc_TmadcModule                    id;                     /**< \brief module ID */
    Ifx_ADC                              *adcSFR;                 /**< \brief pointer to the module SFR set */
    boolean                               shadowBnd0Update;       /**< \brief Enable shadow update of boundary values */
    boolean                               shadowBnd1Update;       /**< \brief Enable shadow update of boundary values for Boundary Register 1 */
    boolean                               calEnable;              /**< \brief True --> Calibration configuration. */
    IfxAdc_TmadcOutputSupervisorMux       outputSignalSel;        /**< \brief Output Supervisor signal selection */
    IfxAdc_Tmadc_EmuxConfig              *emuxCfg;                /**< \brief External multiplexer configuration */
    IfxAdc_Tmadc_ModuleBoundConfig       *bndryConfig;            /**< \brief Pointer to boundary configuration */
    IfxAdc_Tmadc_GlobalServRequestConfig *glbsrvReqCfg;           /**< \brief Pointer to global service request configuration for SR6 node */
    IfxAdc_Tmadc_ServRequestConfig       *srvReqCfg;              /**< \brief Pointer to service request configuration */
} IfxAdc_Tmadc_Config;

/** \brief Handle of a group defined for TMADC
 */
typedef struct
{
    uint8                 numChannels;            /**< \brief Number of channels in this group */
    uint16                channelset;             /**< \brief Set of channels in this group */
    IfxAdc_TmadcResultReg baseResultReg;          /**< \brief Lowest Result register number in the group */
    Ifx_ADC_TMADC        *tmSFR;                  /**< \brief Pointer to the TMADC SFR set */
    uint32               *sourceAddress;          /**< \brief Source Address if timestamp enable it will contain the address of timestamp register else result register address */
    uint32               *groupResPtr;            /**< \brief Pointer to the group result buffer */
    IfxAdc_Tmadc_Callback groupCallback;          /**< \brief Callback provided when the result for all channels in group is copied to buffer */
    IfxAdc_Tmadc_Dma      dma;                    /**< \brief Dma Handle */
    boolean               timestampEnabled;       /**< \brief True --> Timestamp enabled False --> Timestamp disabled */
} IfxAdc_Tmadc_Group;

/** \brief Data structure describing the handle of a channel
 */
typedef struct
{
    IfxAdc_TmadcMonitorChannel   id;             /**< \brief Channel ID */
    IfxAdc_TmadcModule           moduleId;       /**< \brief Module to which channel belongs */
    Ifx_ADC_TMADC               *modSFR;         /**< \brief Pointer to tmadc module sfr */
    Ifx_ADC_TMADC_MCH           *chSFR;          /**< \brief Pointer to the channel SFR set */
    volatile Ifx_ADC_TMADC_MRES *rsltSFR;        /**< \brief Pointer to the result register from SRI view */
} IfxAdc_Tmadc_MonitorCh;

/** \brief Data Structure holding configuration of a monitor channel of TMADC
 */
typedef struct
{
    IfxAdc_TmadcMonitorChannel         id;                   /**< \brief channel ID */
    IfxAdc_TmadcModule                 moduleId;             /**< \brief Module to which channel belongs */
    Ifx_ADC                           *adcSFR;               /**< \brief Pointer to ADC module sfr */
    float32                            samplingTimeNS;       /**< \brief sampling time for channel in NS. Minimum sampling time of monitor channel is 1us */
    IfxAdc_TmadcOpMode                 mode;                 /**< \brief Continuous conversion / one shot */
    IfxAdc_TmadcMonitorChannelInput    input;                /**< \brief Channel Input mux selection */
    boolean                            enableChannel;        /**< \brief Enable Channel input connection */
    IfxAdc_Tmadc_MonitorChResultConfig resultCfg;            /**< \brief Result configuration for channel */
    IfxAdc_Tmadc_ChannelServReqConfig  channelSrvReq;        /**< \brief Channel service request configuration */
} IfxAdc_Tmadc_MonitorChannelConfig;

/** \brief Tmadc Result structure
 */
typedef struct
{
    uint16 timeStamp;       /**< \brief Timestamp (0 if disabled) */
    uint16 result;          /**< \brief Result */
} IfxAdc_Tmadc_Result;

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Module_Initialization
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to the initialize one TMADC module
 * \param tmadc pointer to the module handle
 * \param config configuration of module
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initModule(IfxAdc_Tmadc *tmadc, const IfxAdc_Tmadc_Config *config);

/** \brief Function to initialize module configuration to default.
 * \param config Configuration of module
 * \param adc Pointer to ADC module sfr
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initModuleConfig(IfxAdc_Tmadc_Config *config, Ifx_ADC *adc);

/** \brief Function to configure boundary
 * \param tmadc Pointer to tmadc module sfr
 * \param config Pointer to boundary configuration
 * \param reg Boundary register 0/1
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_configureBoundary(Ifx_ADC_TMADC *tmadc, IfxAdc_Tmadc_BoundaryConfig *config, IfxAdc_TmadcBoundaryReg reg);

/** \brief Function to configure emux of Tmadc module
 * \param tmadc Pointer to tmadc module sfr
 * \param emuxConfig Pointer to Emux configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_configureEmux(Ifx_ADC_TMADC *tmadc, IfxAdc_Tmadc_EmuxConfig *emuxConfig);

/** \brief Function to start calibration and run TMADC module
 * \param tmadc pointer to the module handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_runModule(IfxAdc_Tmadc *tmadc);

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Channel_Initialization
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to enable channel event for the requested node
 * \param channel pointer to the tmadc channel handle
 * \param srvnode Service request node for which the event should be enabled.
 * \param eventType Event type for service request nodes(boundary,error and result)
 * \return None
 */
IFX_INLINE void IfxAdc_Tmadc_enableChannelEvent(IfxAdc_Tmadc_Ch *channel, IfxAdc_TmadcServReq srvnode, IfxAdc_TmadcEventSel eventType);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize one channel of TMADC
 * \param channel pointer to the channel handle
 * \param config pointer to the channel config
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initChannel(IfxAdc_Tmadc_Ch *channel, IfxAdc_Tmadc_ChConfig *config);

/** \brief Function to initialize the channel configuration to default values.
 * \param config Pointer to the channel configuration
 * \param adc Pointer to ADC module sfr
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initChannelConfig(IfxAdc_Tmadc_ChConfig *config, Ifx_ADC *adc);

/** \brief Function to initialize the monitor channel configuration to default values.
 * \param config Pointer to the monitor channel configuration
 * \param adc Pointer to ADC module sfr
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initMonitorChannelConfig(IfxAdc_Tmadc_MonitorChannelConfig *config, Ifx_ADC *adc);

/** \brief Function to initialize monitor channel of TMADC
 * \param channel Pointer to the channel handle
 * \param config pointer to the channel config
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initMonitorChannel(IfxAdc_Tmadc_MonitorCh *channel, IfxAdc_Tmadc_MonitorChannelConfig *config);

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Group_Initialization
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief
 * \param config pointer to the group configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initGroupConfig(IfxAdc_Tmadc_GroupConfig *config);

/** \brief Function to initialize group handle.
 * \param grp Pointer to group handle
 * \param config Pointer to group configruation
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_initGroup(IfxAdc_Tmadc_Group *grp, IfxAdc_Tmadc_GroupConfig *config);

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Trigger
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/**
 * \param grp Pointer to the group handle
 * \return None
 */
IFX_INLINE void IfxAdc_Tmadc_triggerGroup(IfxAdc_Tmadc_Group *grp);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Trigger a channel for conversion
 * \param channel Pointer to the channel handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_triggerChannel(IfxAdc_Tmadc_Ch *channel);

/** \brief Trigger monitor channel for conversion
 * \param channel Pointer to the channel handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_triggerMonitorChannel(IfxAdc_Tmadc_MonitorCh *channel);

/** \} */

/** \addtogroup IfxLld_Adc_Tmadc_Result
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Reads the result from the result register.
 * \param channel Pointer to the channel handle
 * \return result value after conversion
 */
IFX_EXTERN uint16 IfxAdc_Tmadc_readChannelResult(IfxAdc_Tmadc_Ch *channel);

/** \brief Reads the timestamp from the register. (0 if timestamp is disabled for the channel)
 * \param channel Pointer to the channel handle
 * \return Returns timestamp value.
 */
IFX_EXTERN uint16 IfxAdc_Tmadc_readTimestamp(IfxAdc_Tmadc_Ch *channel);

/** \brief Reads the result and timestamp from the register.
 * \param channel Pointer to the channel handle
 * \return Returns both timestamp(if enabled) and result value.
 */
IFX_EXTERN IfxAdc_Tmadc_Result IfxAdc_Tmadc_readRawResult(IfxAdc_Tmadc_Ch *channel);

/** \brief Reads the monitor channel result from the result register.
 * \param channel Pointer to the channel handle
 * \return Returns result value
 */
IFX_EXTERN uint16 IfxAdc_Tmadc_readMonitorChannelResult(IfxAdc_Tmadc_MonitorCh *channel);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to clear buffer for TMADC channel
 * \param channel Pointer to Tmadc channel handle
 * \return None
 */
IFX_INLINE void IfxAdc_Tmadc_clearChannelBuffer(IfxAdc_Tmadc_Ch *channel);

/** \brief Function to check if buffer full
 * \param channel Pointer to Tmadc channel handle
 * \return Return buffer full status.
 * TRUE --> Buffer full
 */
IFX_INLINE boolean IfxAdc_Tmadc_isChannelBufferFull(IfxAdc_Tmadc_Ch *channel);

/** \brief Function to check if buffer empty
 * \param channel Pointer to Tmadc channel handle
 * \return Return buffer empty status.
 * TRUE --> Buffer empty
 */
IFX_INLINE boolean IfxAdc_Tmadc_isChannelBufferEmpty(IfxAdc_Tmadc_Ch *channel);

/** \brief API to check the availability of new result.
 * \param channel Pointer to the channel handle
 * \return Returns TRUE: New result available
 *  FALSE : No new result available
 */
IFX_INLINE boolean IfxAdc_Tmadc_isResultAvailable(IfxAdc_Tmadc_Ch *channel);

/** \brief API to clear result flag.
 * \param channel Pointer to the channel handle
 * \return None
 */
IFX_INLINE void IfxAdc_Tmadc_clearResultFlag(IfxAdc_Tmadc_Ch *channel);

/** \brief API to check if new result is available for the monitor channel in the result register.
 * \param channel Pointer to the monitor channel handle
 * \return Returns TRUE: New result available
 *  FALSE : No new result available
 */
IFX_INLINE boolean IfxAdc_Tmadc_isMonitorChannelResultAvailable(IfxAdc_Tmadc_MonitorCh *channel);

/** \brief API to clear monitor channel result flag.
 * \param channel Pointer to the monitor channel handle
 * \return None
 */
IFX_INLINE void IfxAdc_Tmadc_clearMonitorChannelResultFlag(IfxAdc_Tmadc_MonitorCh *channel);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to setup the result buffer for TMADC channel
 * \param channel Pointer to the channel handle
 * \param buffer Pointer to the buffer
 * \param size Size of the buffer in words.
 * \return Returns
 * IfxAdc_Status_success --> Setting up the result buffer is successful
 * IfxAdc_Status_failure --> Issue in setting up the result buffer
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Tmadc_setupChannelResultBuffer(IfxAdc_Tmadc_Ch *channel, void *buffer, uint16 size);

/** \brief Function to update the destination address for group result.
 * The next set of data from result register will be stored in this new destination address.
 * \param group Pointer to the group handle
 * \param destAddr Pointer to buffer, to store next set of group results.
 * \return Returns
 * IfxAdc_Status_success --> Setting up the result buffer is successful
 * IfxAdc_Status_failure --> Issue in setting up the result buffer.
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Tmadc_updateGroupResultAddress(IfxAdc_Tmadc_Group *group, void *destAddr);

/** \brief Function to copy data from hardware result register to software buffer for a TMADC channel.
 * \param channel Pointer to Tmadc channel handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_writeChannelBuffer(IfxAdc_Tmadc_Ch *channel);

/** \brief Function to copy data from hardware result register to software buffer for all channels in a group.
 * \param group Pointer to the group handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_writeGroupBuffer(IfxAdc_Tmadc_Group *group);

/** \brief TMADC channel ISR for copying the multiple results of single channel to the buffer. It also provides the callback on buffer full if configured.
 * \param channel Pointer to Tmadc channel handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_resultChannelIsr(IfxAdc_Tmadc_Ch *channel);

/** \brief TMADC group ISR to copy result of all channels in the group to the configured buffer.
 * \param group Pointer to Tmadc group handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Tmadc_resultGroupIsr(IfxAdc_Tmadc_Group *group);

/** \brief Function to read immediate conversion result from circular buffer for TMADC channel.
 * \param channel Pointer to Tmadc channel handle
 * \return Returns immediate result data from the circular buffer.
 */
IFX_EXTERN uint32 IfxAdc_Tmadc_readChannelCircularBufferResult(IfxAdc_Tmadc_Ch *channel);

/** \brief Function to get number of new results in the buffer for the TMADC channel
 * \param channel Pointer to Tmadc channel handle
 * \return Return number of new results from the buffer
 */
IFX_EXTERN uint16 IfxAdc_Tmadc_getNumberOfChannelResults(IfxAdc_Tmadc_Ch *channel);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAdc_Tmadc_triggerGroup(IfxAdc_Tmadc_Group *grp)
{
    IfxAdc_triggerTmadcChannelSet(grp->tmSFR, grp->channelset);
}


IFX_INLINE void IfxAdc_Tmadc_enableChannelEvent(IfxAdc_Tmadc_Ch *channel, IfxAdc_TmadcServReq srvnode, IfxAdc_TmadcEventSel eventType)
{
    if (eventType == IfxAdc_TmadcEventSel_error)
    {
        channel->modSFR->SR[srvnode].CFG.U |= (1u << channel->id);
    }
    else if ((eventType == IfxAdc_TmadcEventSel_result) || (eventType == IfxAdc_TmadcEventSel_boundary))
    {
        channel->modSFR->SR[srvnode].CFG.U |= (1u << channel->resultRegNum);
    }
    else
    {
        /* do nothing */
    }
}


IFX_INLINE void IfxAdc_Tmadc_clearChannelBuffer(IfxAdc_Tmadc_Ch *channel)
{
    uint16  bufferSize     = channel->queue.size;
    uint32 *localBufferPtr = channel->queue.bufferPtr;
    uint16  index          = 0;

    for (index = 0; index < bufferSize; index++)
    {
        localBufferPtr[index] = 0;
    }
}


IFX_INLINE boolean IfxAdc_Tmadc_isChannelBufferFull(IfxAdc_Tmadc_Ch *channel)
{
    return channel->queue.bufferFull;
}


IFX_INLINE boolean IfxAdc_Tmadc_isChannelBufferEmpty(IfxAdc_Tmadc_Ch *channel)
{
    return (channel->queue.validResult == 0u) ? TRUE : FALSE;
}


IFX_INLINE boolean IfxAdc_Tmadc_isResultAvailable(IfxAdc_Tmadc_Ch *channel)
{
    uint32 resultEvent = channel->modSFR->RESF.B.RESEV;
    return (resultEvent & ((uint32)1 << channel->resultRegNum)) != (uint32)0;
}


IFX_INLINE void IfxAdc_Tmadc_clearResultFlag(IfxAdc_Tmadc_Ch *channel)
{
    channel->modSFR->RESFCLR.B.RESEVCLR = ((uint32)1 << channel->resultRegNum);
}


IFX_INLINE boolean IfxAdc_Tmadc_isMonitorChannelResultAvailable(IfxAdc_Tmadc_MonitorCh *channel)
{
    uint32 resultEvent = channel->modSFR->RESF.B.RESEV;
    uint8  shift       = channel->id + IFXADC_TMADC_MCH_OFFSET;
    return (resultEvent & ((uint32)1 << shift)) != (uint32)0;
}


IFX_INLINE void IfxAdc_Tmadc_clearMonitorChannelResultFlag(IfxAdc_Tmadc_MonitorCh *channel)
{
    channel->modSFR->RESFCLR.B.RESEVCLR = ((uint32)1 << (channel->id + IFXADC_TMADC_MCH_OFFSET));
}


#endif /* IFXADC_TMADC_H */
