/**
 * \file IfxHsphy_Hsphy.h
 * \brief HSPHY HSPHY details
 * \ingroup IfxLld_Hsphy
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Hsphy_Hsphy_Usage How to use the HSPHY Interface driver?
 *   \ingroup IfxLld_Hsphy
 *
 *   The HPSHY can be used in the stand alone mode.
 *
 *   In the following sections it will be described, how to integrate the driver into the application framework.
 *   \section IfxLld_Hsphy_Hsphy_Preparation Preparation
 *   \subsection IfxLld_Hsphy_Hsphy_Variables Integration with PCIe driver
 *
 *
 *
 *   \code
 *   typedef struct
 *   {
 *      Ifx_HSPHY               *hsphySFR;
 *      IfxHsphy_Hsphy_phyConfig phyConfig[IFXHSPHY_NUM_OF_PHY];
 *   }IfxHsphy_Hsphy_Cfg;
 *   \endcode
 *
 *
 *   configure the above structure from the application framework for the available Phy in the Hsphy
 *
 *   \code
 *   typedef struct
 *   {
 *     IfxHsphy_PhyIndex           phyIdx;
 *     IfxHsphy_PadNativeInterface padInterface;
 *     IfxHsphy_TrgtDevice         trgtDevice;
 *     uint8                       trgtDeviceIdx;
 *      IfxHsphy_TrgtDeviceSpeed    deviceSpeed;
 *      const void                 *cfgData;
 *   }IfxHsphy_Hsphy_phyConfig;
 *   \endcode
 *
 *   Configure the above struct for the target selection through to used to hsphy i.e PCIE,XGMAC,XSPI,TRACE
 *
 *   The HSPHY driver needs the following infromation to check if the connectivity is possible using the indexes
 *   hsphyIdx - Refers to the HPSHY module index.
 *   phyIdx - Refers to PHY index in the HSPHY module
 *   padInterface - Refers to interfaces like xpcs, upcs
 *   trgtDevice - Target device for HSPHY like PCIE, XGMAC, Trace.
 *   trgtDeviceIdx - Device index if more devices exists.
 *   deviceSpeed - Configuration for device speeds
 *   cfgData - Configure this parameter with the desired traget device to be used i.e to use xgmac through rgmiipads configure this for the type as IfxHsphy_Geth_RgmiiCfg with appropriate cfg data
 *
 *    // Example configuration for connecting PHY to the different target devices available
 *
 *
 *    // Configure the PHY[0] to use the XGMAC0 through SGMII pads in 100M mode
 *
 *
 *   \code
 *
 *    IfxHsphy_Hsphy_Cfg Config = {
 *              .hsphySFR = NULL_PTR,
 *              .phyConfig[0] = {		                                       // Config the PHY[0] to use the XGMAC0 through SGMII pads in 100M mode
 *                      .phyIdx = IfxHsphy_PhyIndex_0,
 *                      .padInterface = IfxHsphy_PadInterface_sgmii,
 *                      .trgtDevice = IfxHsphy_TrgtDevice_xgmac,
 *                      .trgtDeviceIdx = 0,
 *                      .deviceSpeed = IfxHsphy_TrgtDeviceSpeed_0P1G            // In this example 100M mode is considered can be configured to available speeds
 *                      .cfgData       = &IfxHsphy_Hsphy_userSgmiiConfig[0],	// Config this array with IfxHsphy_GethXpcsParams data type for Sgmii interface usage explicitly
 *               }
 *
 *    // Example for IfxHsphy_Hsphy_userSgmiiConfig configuration for using sgmii pads the following data cfg should be assigned
 *
 *        IfxHsphy_GethXpcsParams  IfxHsphy_Hsphy_userSgmiiConfig[IFXHSPHY_NUM_OF_PHY] = {
 *            {IfxHsphy_XpcsIndex_0, IfxHsphy_XpcsRefClk_100Mhz},				// config for ref clk freq required and xpcs index
 *            {IfxHsphy_XpcsIndex_1, IfxHsphy_XpcsRefClk_100Mhz}
 *          };
 *
 *   \endcode
 *
 *
 *
 *      // Config the PHY[0] to use the XGMAC0 through MII PADS in 100M mode
 *
 *   \code
 *          IfxHsphy_Hsphy_Cfg Config = {
 *              .phyConfig[0] = {		// Config the PHY[0] to use the XGMAC0 through MII PADS in 100M mode
 *                      .phyIdx = IfxHsphy_PhyIndex_0,
 *                      .padInterface = IfxHsphy_PadInterface_miiPads,
 *                      .trgtDevice = IfxHsphy_TrgtDevice_xgmac,
 *                      .trgtDeviceIdx = 0,
 *                      .deviceSpeed = IfxHsphy_TrgtDeviceSpeed_0P1G
 *                      .cfgData       = &IfxHsphy_Hsphy_userMiiConfig[0],		//config this array with IfxHsphy_Geth_MiiCfg data type for Mii interface usage explicitly
 *
 *          }
 *
 *          // Example for IfxHsphy_Hsphy_userMiiConfig MII  configuration for voltage levels of 1.8V,ref clk,Dllskew levels as follows
 *
 *                      IfxHsphy_Geth_MiiCfg IfxHsphy_Hsphy_userMiiConfig ={
 *                                      .dllCfg ={
 *                                                .dllOutputVolt = IfxHsphy_DllOutputVoltage_1P8V,
 *                                                .dllRefClkSel = IfxHsphy_Xspi_DllClkMode_diffClk,
 *                                                .dllTxClk = IfxHsphy_Geth_DllTxClk_disable,
 *                                                .dllRxClk = IfxHsphy_Geth_DllTxClk_disable,
 *                                                .rxClkSkew = IfxHsphy_DllSkew_0,
 *                                                .txClkSkew = IfxHsphy_DllSkew_0
 *                                      },
 *                                      .IfxHsphy_Geth_MiiPins = NULL_PTR
 *                              }
 *
 *   \endcode
 *
 *
 *    // Config the PHY[0] to use the XGMAC0 through RMII PADS in 100M mode
 *
 *   \code
 *              .phyConfig[0] = {		// Config the PHY[0] to use the XGMAC0 through RMII PADS in 100M mode
 *                      .phyIdx = IfxHsphy_PhyIndex_0,
 *                      .padInterface = IfxHsphy_PadInterface_rmiiPads,
 *                      .trgtDevice = IfxHsphy_TrgtDevice_xgmac,
 *                      .trgtDeviceIdx = 0,
 *                      .deviceSpeed = IfxHsphy_TrgtDeviceSpeed_0P1G
 *                      .cfgData       = &IfxHsphy_Hsphy_userRmiiConfig[0],     //config this array with IfxHsphy_Geth_RmiiCfg data type for Rmii interface usage explicitly
 *
 *
 *      // Example for IfxHsphy_Hsphy_userRmiiConfig RMII  configuration for voltage levels of 1.8V,ref clk,Dllskew levels as follows
 *
 *                      IfxHsphy_Geth_RmiiCfg IfxHsphy_Hsphy_userRmiiConfig ={
 *                                      .dllCfg ={
 *                                                .dllOutputVolt = IfxHsphy_DllOutputVoltage_1P8V,		// can be config for 1.8v or 3v
 *                                                .dllRefClkSel = IfxHsphy_Geth_DllRefClkSel_gRef,		// sel for ref clk i.e gRef,pllref
 *                                                .dllTxClk = IfxHsphy_Geth_DllTxClk_disable,
 *                                                .dllRxClk = IfxHsphy_Geth_DllTxClk_disable,
 *                                                .rxClkSkew = IfxHsphy_DllSkew_0,						// To select skew rates
 *                                                .txClkSkew = IfxHsphy_DllSkew_0
 *                                      },
 *                                      .IfxHsphy_Geth_RmiiPins = NULL_PTR
 *                              }
 *
 *   \endcode
 *
 *
 *
 *     //To configure the PHY to connect to XGMAC0 through RGMII pads following configuration is required
 *
 *
 *   \code
 *              .phyConfig[0] = {		// Config the PHY[0] to use the XGMAC0 through RGMII PADS in 100M mode
 *                      .phyIdx = IfxHsphy_PhyIndex_0,
 *                      .padInterface = IfxHsphy_PadInterface_rgmiiPads,
 *                      .trgtDevice = IfxHsphy_TrgtDevice_xgmac,
 *                      .trgtDeviceIdx = 0,
 *                      .deviceSpeed = IfxHsphy_TrgtDeviceSpeed_0P1G
 *                      .cfgData       = &IfxHsphy_Hsphy_userRgmiiConfig[0],     //config this array with IfxHsphy_Geth_RgmiiCfg data type for Rgmii interface usage explicitly
 *
 *      // Example for IfxHsphy_Hsphy_userRgmiiConfig RGMII  configuration for voltage levels of 1.8V,ref clk,Dllskew levels as follows
 *                      IfxHsphy_Geth_RgmiiCfg IfxHsphy_Hsphy_userRgmiiConfig[] ={
 *                                {
 *                                    .dllCfg = {
 *                                                  .dllOutputVolt = IfxHsphy_DllOutputVoltage_1P8V,  // can be config for 1.8v or 3v
 *                                                  .dllRefClkSel= IfxHsphy_Geth_DllRefClkSel_gRef,   // sel for ref clk i.e gRef,pllref
 *                                                  .dllTxClk = IfxHsphy_Geth_DllTxClk_disable,
 *                                                  .dllRxClk =IfxHsphy_Geth_DllTxClk_disable,
 *                                                  .rxClkSkew = IfxHsphy_DllSkew_0,                  // To select skew rates
 *                                                  .txClkSkew = IfxHsphy_DllSkew_0
 *                                              },
 *                                   .rgmiiPins = NULL_PTR			//config this for the related RGMII pins
 *                                }
 *                          };
 *    \endcode
 *
 *
 *
 *      // Config the PHY to connect to the Xspi using the XSPI PADS
 *      \code
 *              .phyConfig[0] = {		// Config the PHY[0] to communicate to Xspi using the XSPI PADS
 *                      .phyIdx = IfxHsphy_PhyIndex_0,
 *                      .padInterface = IfxHsphy_PadInterface_xspiPads,
 *                      .trgtDevice = IfxHsphy_TrgtDevice_xgmac,
 *                      .trgtDeviceIdx = 0,
 *                      .deviceSpeed = IfxHsphy_TrgtDeviceSpeed_0P4G
 *                      .cfgData       = &IfxHsphy_Hsphy_userXspiConfig[0],     //config this array with IfxHsphy_Xspi_xspiCfg data type for xspi interface usage explicitly
 *
 *              // Example for IfxHsphy_Xspi_XspiCfg Xspi  configuration for voltage levels of 1.8V,ref clk,Dllskew levels as follows
 *
 *              IfxHsphy_Xspi_XspiCfg IfxHsphy_Hsphy_xspiConfig ={
 *                  .dllCfg ={
 *                      .dllOutputVolt = IfxHsphy_DllOutputVoltage_1P8V ,		// can be config for 1.8v or 3v
 *                      .dllClkMode = IfxHsphy_Xspi_DllClkMode_diffClk,          // sel for ref clk i.e single ref,diff ref clk
 *                      .dllFreqMode = IfxHsphy_Xspi_DllFreqMode_below166Mhz,
 *                      .rxClkSkew = IfxHsphy_DllSkew_0,
 *                      .txClkSkew = IfxHsphy_DllSkew_0							 // To select skew rates
 *                      },
 *                  .xspiPins = NULL_PTR
 *              }
 *      \endcode
 *
 *
 *    // Configure the PHY[1] to use the XGMAC1 through SGMII pads in 100M mode
 *
 *
 *   \code
 *
 *    IfxHsphy_Hsphy_Cfg Config = {
 *              .hsphySFR = NULL_PTR,
 *              .phyConfig[1] = {		                                       // Config the PHY[1] to use the XGMAC0 through SGMII pads in 100M mode
 *                      .phyIdx = IfxHsphy_PhyIndex_0,
 *                      .padInterface = IfxHsphy_PadInterface_sgmii,
 *                      .trgtDevice = IfxHsphy_TrgtDevice_xgmac,
 *                      .trgtDeviceIdx = 0,
 *                      .deviceSpeed = IfxHsphy_TrgtDeviceSpeed_0P1G            // In this example 100M mode is considered can be configured to available speeds
 *                      .cfgData       = &IfxHsphy_Hsphy_userSgmiiConfig[1],	// Config this array with IfxHsphy_GethXpcsParams data type for Sgmii interface usage explicitly
 *               }
 *
 *    // Example for IfxHsphy_Hsphy_userSgmiiConfig configuration for using sgmii pads the following data cfg should be assigned
 *
 *        IfxHsphy_GethXpcsParams  IfxHsphy_Hsphy_userSgmiiConfig[IFXHSPHY_NUM_OF_PHY] = {
 *            {IfxHsphy_XpcsIndex_0, IfxHsphy_XpcsRefClk_100Mhz},				// config for ref clk freq required and xpcs index
 *            {IfxHsphy_XpcsIndex_1, IfxHsphy_XpcsRefClk_100Mhz}
 *          };
 *
 *   \endcode
 *
 *
 *      // Presently Configuration of the PHY[1] to use the Trace is not supported
 *
 *
 *      };
 *
 * \defgroup IfxLld_Hsphy_Hsphy HSPHY
 * \ingroup IfxLld_Hsphy
 * \defgroup IfxLld_Hsphy_Hsphy_Default Data Structures
 * \ingroup IfxLld_Hsphy_Hsphy
 * \defgroup IfxLld_Hsphy_Hsphy_Default Initialisation functions
 * \ingroup IfxLld_Hsphy_Hsphy
 * \defgroup IfxLld_Hsphy_Hsphy_Default Config Variable
 * \ingroup IfxLld_Hsphy_Hsphy
 */

#ifndef IFXHSPHY_HSPHY_H
#define IFXHSPHY_HSPHY_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Hsphy/Std/IfxHsphy.h"
#include "Geth/Std/IfxGeth.h"

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Hsphy_Hsphy_Default
 * \{ */
/** \brief HSPHY config
 */
typedef struct
{
    IfxHsphy_PhyIndex           phyIdx;              /**< \brief PHY index in HSPHY */
    IfxHsphy_PadNativeInterface padInterface;        /**< \brief PHY target interface */
    IfxHsphy_TrgtDevice         trgtDevice;          /**< \brief Target device */
    uint8                       trgtDeviceIdx;       /**< \brief geth Speed param */
    IfxHsphy_TrgtDeviceSpeed    deviceSpeed;         /**< \brief Target device Idx */
    IFX_CONST void             *cfgData;             /**< \brief cfg data for reference the config data for selected native pad */
} IfxHsphy_Hsphy_phyConfig;

/** \} */

/** \addtogroup IfxLld_Hsphy_Hsphy_Default
 * \{ */
/** \brief Phy data struct
 */
typedef struct
{
    IfxHsphy_Hsphy_phyConfig hsphyCfg;       /**< \brief Hsphy config struct */
} IfxHsphy_Hsphy_phyData;

/** \} */

/** \addtogroup IfxLld_Hsphy_Hsphy_Default
 * \{ */
/** \brief Hsphy struct
 */
typedef struct
{
    Ifx_HSPHY              *hsphySFR;                             /**< \brief Hsphy register pointer */
    IfxHsphy_Hsphy_phyData *hsphyData[IFXHSPHY_NUM_OF_PHY];       /**< \brief Hsphy data values */
} IfxHsphy_Hsphy;

/** \brief Cfg struct for hsphy
 */
typedef struct
{
    Ifx_HSPHY               *hsphySFR;                             /**< \brief pointer for hsphy register */
    IfxHsphy_Hsphy_phyConfig phyConfig[IFXHSPHY_NUM_OF_PHY];       /**< \brief Phy config values */
} IfxHsphy_Hsphy_Cfg;

/** \} */

/** \addtogroup IfxLld_Hsphy_Hsphy_Default
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Init module API
 * \param hsphy Hsphy struct param
 * \param config Configuration strcuture for HPSHY connection
 * \return status for success ,failure, invalid config ,timeout error
 */
IFX_EXTERN IfxHsphy_status IfxHsphy_Hsphy_initModule(IfxHsphy_Hsphy *hsphy, IfxHsphy_Hsphy_Cfg *config);

/** \brief HSPHY bootloading finished and External loading of the application in HSPHY SRAM is complete
 * \param hsphyIdx HSPHY index
 * \param phyIndex PHY index in HSPHY
 * \return TRUE: Successful     FALSE: Error
 */
IFX_EXTERN boolean IfxHsphy_Hsphy_initDone(IfxHsphy_hsphyIndex hsphyIdx, IfxHsphy_PhyIndex phyIndex);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief init module config API
 * \param hsphy Hsphy param
 * \param config config params
 * \return None
 */
IFX_EXTERN void IfxHsphy_Hsphy_initModuleConfig(Ifx_HSPHY *hsphy, IfxHsphy_Hsphy_Cfg *config);

/** \brief Phy init API
 * \param hsphyData Hsphy data param
 * \param phyConfig Phy config pointer
 * \return True : returns the status for initialisation
 */
IFX_EXTERN boolean IfxHsphy_Hsphy_phyInit(IfxHsphy_Hsphy_phyData *hsphyData, IfxHsphy_Hsphy_phyConfig *phyConfig);
/** \addtogroup IfxLld_Hsphy_Hsphy_Default
 * \{ */

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
/** \brief List of possible combinations for the derivative
 */
IFX_EXTERN IFX_CONST IfxHsphy_Hsphy_phyConfig IfxHsphy_Hsphy_configLookUpTbl[];

/** \brief Default configuration
 */
IFX_EXTERN IFX_CONST IfxHsphy_GethXpcsParams  IfxHsphy_Hsphy_defaultConfig[IFXHSPHY_NUM_OF_PHY];

/** \} */

#endif /* IFXHSPHY_HSPHY_H */
