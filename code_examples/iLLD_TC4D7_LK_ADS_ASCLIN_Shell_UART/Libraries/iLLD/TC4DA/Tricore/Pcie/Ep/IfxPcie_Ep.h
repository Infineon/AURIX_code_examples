/**
 * \file IfxPcie_Ep.h
 * \brief PCIE EP details
 * \ingroup IfxLld_Pcie
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Pcie_Ep_Usage How to use the EP Interface layer?
 * \ingroup IfxLld_Pcie
 *
 * \section IfxLld_Pcie_Ep_Overview Overview
 *
 * PCIe devices can be of various types such as Endpoint (EP), Root Complex (RC), or a bridge.
 * Aurix TC49x can be configured either as a RC or EP and this documentation describes how to use the device as an EP.
 *
 * \subsection IfxLld_Pcie_Ep_Overview_Func Functionalities Provided
 * The EP interface layer provides the following functionalities:
 *     -# Configuration of Aurix as EP
 *     -# Configuration of BARs and ATUs for inbound reception
 *     -# Configuration of outbound ATUs for sending TLPs
 *     -# Reception of all (remote, message, error, and power management) interrupts supported by Aurix
 *     -# Generation of all (INTX, MSI, and MSIX) interrupts supported by Aurix
 *
 * \subsection IfxLld_Pcie_Ep_Overview_Init Module Initialization
 *
 * Module Initialization can be done by two methods:
 *     -# By calling the IfxPcie_Ep_init() function.
 *     -# By calling the functions inside IfxPcie_Ep_init() individually.
 *         - Step 1: Call IfxPcie_Ep_initModule() to initialize Aurix as EP. Following steps are performed:
 *             -# Enable Module and set device mode as EP
 *             -# Perform Kernel reset
 *             -# Setup HSPHY for PCIe and get clock
 *             -# Set device id, vendor id, bar mask, and bar parameters
 *             -# Configure inbound ATU for TLP reception
 *             -# Probe it's capabilites
 *             -# Initialize interrupts for reception
 *         - Step 2: Call IfxPcie_Ep_initLink() to enable link training
 *         - Step 3: Wait for EP enumeration to complete
 *         - Step 4: Call IfxPcie_Ep_initPostEnumeration(). Following steps are performed:
 *             -# Initialize interrupt generation
 *             -# Configure outbound ATU
 *
 * \section IfxLld_Pcie_Ep_Code Coding example
 *
 * \subsection IfxLld_Pcie_Ep_Step1 STEP 1: Configure HSPHY
 * This needs to be done in all cases (except VP) for PCIe to use PHY.\n
 * For more details, refer to the documentaion of HSPHY iLLD code.\n
 *
 * In this section, we will do the following:
 *     - Include HSPHY interface (see below: #0)
 *     - Instantiate Variables (see below: #1)
 *     - Initialize and configure HSPHY configuration structure (see below: #2)
 *     - Initialize HSPHY (see below: #3)
 *
 *     \code
 *
 *     //=====================================
 *     // 0. Include HSPHY Interface
 *     //=====================================
 *
 *     #include <Hsphy/Hsphy/IfxHsphy_Hsphy.h>
 *
 *     //=====================================
 *     // 1. Variable Instantiation
 *     //=====================================
 *
 *     IfxHsphy_Hsphy          hsphy;
 *     IfxHsphy_Hsphy_Cfg      phy_config;
 *     IfxHsphy_Hsphy_phyData  hsphyData0;
 *     IfxHsphy_Hsphy_phyData  hsphyData1;
 *
 *     //=====================================
 *     // 2. Configure HSPHY
 *     //=====================================
 *
 *     // 2.1 Assign default values to config structure
 *     IfxHsphy_Hsphy_initModuleConfig(&MODULE_HSPHY,&phy_config);
 *
 *     // 2.2 Configure PHY for PCIE
 *     phy_config.phyConfig[0].phyIdx        = IfxHsphy_PhyIndex_0;
 *     phy_config.phyConfig[0].padInterface  = IfxHsphy_PadNativeInterface_pcie;
 *     phy_config.phyConfig[0].trgtDevice    = IfxHsphy_TrgtDevice_pcie;
 *     phy_config.phyConfig[0].trgtDeviceIdx = IfxPcie_Index_0;
 *     phy_config.phyConfig[0].deviceSpeed   = IfxHsphy_TrgtDeviceSpeed_8G;
 *
 *     // 2.3 Configure PHY for MII
 *     phy_config.phyConfig[1].phyIdx        = IfxHsphy_PhyIndex_1;
 *     phy_config.phyConfig[1].padInterface  = IfxHsphy_PadNativeInterface_sgbt;
 *     phy_config.phyConfig[1].trgtDevice    = IfxHsphy_TrgtDevice_trace;
 *     phy_config.phyConfig[1].trgtDeviceIdx = 0;
 *     phy_config.phyConfig[1].deviceSpeed   = IfxHsphy_TrgtDeviceSpeed_1G;
 *
 *     hsphy.hsphyData[0] = &hsphyData0;
 *     hsphy.hsphyData[1] = &hsphyData1;
 *
 *     //=====================================
 *     // 3. Initialize HSPHY
 *     //=====================================
 *
 *     // 3.1 Init HSPHY for PCIE
 *     IfxHsphy_Hsphy_initModule(&hsphy, &phy_config);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pcie_Ep_Step2 STEP 2: Initialize EP configuration structure
 *
 * In this section, we will do the following:
 *     - Include EP interface (see below: #0)
 *     - Instantiate Variables (see below: #1)
 *     - Initialize EP configuration structure (see below: #2)
 *
 *     \code
 *
 *     //=====================================
 *     // 0. Include EP Interface
 *     //=====================================
 *
 *     #include "Pcie/Ep/IfxPcie_Ep.h"
 *
 *     //=====================================
 *     // 1. Variable Instantiation
 *     //=====================================
 *
 *     // 1.1 Instantiate Config structure
 *     IfxPcie_Ep_Config config;
 *     // 1.2 Instantiate Module Handle
 *     IfxPcie_Ep ep;
 *     // 1.3 Instantiate other variables
 *     IfxPcie_Status status;
 *
 *     //=====================================
 *     // 2. Config structure initialization
 *     //=====================================
 *
 *     // 2.1 Assign default values to config structure members
 *     IfxPcie_Ep_initConfig(&MODULE_PCIE_USP, &config);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pcie_Ep_Step3 STEP 3: Manually configure EP
 *
 * In this section, we will do the following:
 *     - Manually configure EP before initialization (see below: #3)
 *         - Configure BARs (see below: #3.1)
 *         - Configure outbound ATU (see below: #3.2)
 *         - Configure interrupt reception (see below: #3.3)
 *
 *     \code
 *     //=====================================
 *     // 3. Configure EP manually
 *     //=====================================
 *
 *     // 3.1 Configure necessary BARs
 *     // Note: BAR0 is enabled by default
 *     uint32 lmuAddress = 0x90300000u;
 *     config.barRegion[1].atuRegion       = IfxPcie_AtuRegion_1;  // Assign inbound ATU region (bar mapped)
 *     config.barRegion[1].localMemBase    = lmuAddress;           // Assign Local Address for ATU
 *     config.barRegion[1].size            = 0x1000u;              // Assign Size of bar
 *     config.barRegion[1].enable          = TRUE;                 // Enable bar
 *     config.barRegion[2].atuRegion       = IfxPcie_AtuRegion_2;
 *     config.barRegion[2].localMemBase    = config.barRegion[1].localMemBase + config.barRegion[1].size;
 *     config.barRegion[2].size            = 0x1000u;
 *     config.barRegion[2].enable          = TRUE;
 *     config.barRegion[4].atuRegion       = IfxPcie_AtuRegion_3;
 *     config.barRegion[4].localMemBase    = config.barRegion[2].localMemBase + config.barRegion[2].size;
 *     config.barRegion[4].size            = 0x2000u;
 *     config.barRegion[4].enable          = TRUE;
 *
 *     // [Optional] 3.2 Configure outbound ATU
 *     IfxPcie_Ep_MemCfg outboundRegion;
 *     uint32 outboundLocalMemStart    = 0xFC100000u;
 *     uint32 outboundWireMemStart     = 0x00100000u;
 *
 *     outboundRegion.atuRegion        = IfxPcie_AtuRegion_1;          // Set ATU region
 *     outboundRegion.localMemBase     = outboundLocalMemStart;        // Set local address for ATU
 *     outboundRegion.size             = 0x1000u;                      // Set ATU size
 *     outboundRegion.wireMemBase      = (uint64)outboundWireMemStart; // Set wire address for ATU
 *     config.outBoundRegion           = &outboundRegion;              // Assign pointer to outbound region
 *     config.numOutBoundRegions       = 1u;                           // Set number of outbound regions
 *
 *     // [Optional] 3.3 Configure interrupt reception for remote trigger from Aurix EP
 *     config.interrupt.numTriggerVectors  = 8u;   // Initialize all nodes
 *     config.interrupt.triggerEnableMask  = 0u;   // Don't mask anything
 *
 *     // initialize all nodes for reception from RC
 *     for (intVector = 0; intVector < config.interrupt.numTriggerVectors; intVector++)
 *     {
 *         config.interrupt.triggerIntNode[intVector].typeOfService  = IfxSrc_Tos_cpu0,                // CPU0 by default
 *         config.interrupt.triggerIntNode[intVector].priority       = 2,                              // all of them have same Prio - same ISR
 *         config.interrupt.triggerIntNode[intVector].vmNumber       = IfxSrc_VmId_0,                  // VM ID 0
 *         config.interrupt.triggerIntNode[intVector].intVector      = (IfxPcie_IntVector)intVector;   // Vector configured
 *     }
 *
 *     // 3.4 Complete Configuration
 *     config.hsphySFR                 = &MODULE_HSPHY;    // Pointer to the HSPHY SFR space
 *     config.epFunction.deviceId      = 0xCCDD;           // Device ID
 *     config.epFunction.vendorId      = 0xAABB;           // Vendor ID
 *     config.drsSupport               = FALSE;            // Support for DRS
 *     // Choose to wait till enumeration is completed to perform post enumeration steps
 *     config.pollForEnumeration       = FALSE;
 *
 *     \endcode
 *
 * \subsection IfxLld_Pcie_Ep_Step4 STEP 4: Initialize EP
 *
 * In this section, we will do the following:
 *     - Initialize EP (see below: #4)
 *
 *     \code
 *     //=====================================
 *     // 4. Initialize EP
 *     //=====================================
 *
 *     // 4.1 Initialize EP with above configuration
 *     status = IfxPcie_Ep_init(&ep, &config);
 *
 *     // 4.2 [Optional] Applicable if (config.pollForEnumeration == FALSE)
 *
 *     // 4.2.1 Wait for enumeration
 *     // User code
 *
 *     // 4.2.2 Complete post enumeration
 *     status = IfxPcie_Ep_initPostEnumeration(&ep);
 *
 *     // Aurix device is now active as EP
 *
 *     \endcode
 *
 * At this point the endpoint handle provides:
 *     -# Pointers to capabilites stored inside these structure members
 *         - ep.epFunction.capabilities.msi
 *         - ep.epFunction.capabilities.msix
 *         - ep.epFunction.capabilities.pcie
 *         - ep.epFunction.capabilities.pmc
 *         - ep.epFunction.capabilities.extendedCap
 *
 * \subsection IfxLld_Pcie_Ep_Int Generate Interrupt
 *
 * In this section, we will do the following:
 *     - Generate interrupt from EP to RC (see below: #5)
 *
 *     \code
 *     //=====================================
 *     // 5. Generate interrupt
 *     //=====================================
 *
 *     // Function generates interrupt based on the interrupt type configured by RC
 *     // Index defines which MSI or MSIX interrupt to generate
 *     uint8 interruptIndex = 0;
 *     status = IfxPcie_Ep_generateInterrupt(&ep, interruptIndex);
 *     \endcode
 *
 * \defgroup IfxLld_Pcie_Ep EP
 * \ingroup IfxLld_Pcie
 * \defgroup IfxLld_Pcie_Ep_Enumerations Enumerations
 * \ingroup IfxLld_Pcie_Ep
 * \defgroup IfxLld_Pcie_Ep_Structures Structures
 * \ingroup IfxLld_Pcie_Ep
 * \defgroup IfxLld_Pcie_Ep_Functions Functions
 * \ingroup IfxLld_Pcie_Ep
 */

#ifndef IFXPCIE_EP_H
#define IFXPCIE_EP_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Pcie/Std/IfxPcie.h"
#include "Pcie/Std/IfxPcieEp.h"
#include "Pcie/Lib/Cap/IfxPcieLib_Cap.h"
#include "Pcie/Lib/Device/IfxPcieLib_Device.h"
#include "Hsphy/Std/IfxHsphy.h"

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Ep_Enumerations
 * \{ */
/** \brief PCIE EP states
 */
typedef enum
{
    IfxPcie_Ep_State_unknown = -1,
    IfxPcie_Ep_State_initialized,
    IfxPcie_Ep_State_linkUp,
    IfxPcie_Ep_State_enumerated,
    IfxPcie_Ep_State_initPostEnumeration,
    IfxPcie_Ep_State_error,
    IfxPcie_Ep_State_configError
} IfxPcie_Ep_State;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Ep_Structures
 * \{ */
/** \brief EP Bar Handle
 */
typedef struct
{
    boolean              enable;             /**< \brief if TRUE: BAR Region is Enabled */
    uint32               localMemBase;       /**< \brief Local Memory Base Value */
    uint64               size;               /**< \brief size of memory */
    IfxPcie_AddressWidth addressWidth;       /**< \brief Address Width of the BAR (32,64) */
    boolean              prefetch;           /**< \brief if TRUE: Region is pre-fetchable */
    IfxPcie_AtuRegion    atuRegion;          /**< \brief ATU Region Index */
} IfxPcie_Ep_Bar;

/** \brief EP Bar Configuration
 */
typedef struct
{
    boolean              enable;             /**< \brief if TRUE: BAR Region is Enabled */
    uint32               localMemBase;       /**< \brief Local Memory Base Value (NA for BAR0) */
    uint64               size;               /**< \brief Size of BAR Region */
    IfxPcie_AddressWidth addressWidth;       /**< \brief Address Width of the BAR (32,64) */
    boolean              prefetch;           /**< \brief if TRUE: Region is pre-fetchable */
    IfxPcie_AtuRegion    atuRegion;          /**< \brief ATU Region Index */
} IfxPcie_Ep_BarCfg;

/** \brief EP Interrupt handle
 */
typedef struct
{
    uint8                 numTriggerVectors;       /**< \brief Number of Trigger from EP to SOC */
    uint32                triggerEnableMask;       /**< \brief Initial Mask. 1<<pos: mask interrupt #"pos" (ignored for INTx) */
    uint32                triggerPending;          /**< \brief Pending INTR. 1<<pos: Interrupt Pending @ #"pos" (ignored for INTx) */
    IfxPcie_InterruptType remoteIntType;           /**< \brief Type of Interrupt Set by RC */
    uint8                 numRemoteInt;            /**< \brief Number of Remote Interrupts allowed for this EP */
} IfxPcie_Ep_Int;

/** \brief EP Interrupt configuration
 * This configures the special Interrupt which Aurix as an EP is able to receive.
 */
typedef struct
{
    uint8                        numTriggerVectors;                                        /**< \brief Number of Vectors from EP to SOC */
    uint32                       triggerEnableMask;                                        /**< \brief Initial Mask. 1<<pos: enable interrupt #"pos" */
    IfxPcieLib_Device_IntNodeCfg triggerIntNode[IFXPCIE_CFG_MAX_NUM_EP_TRIGVECTORS];       /**< \brief Vector Node Configurations */
    IfxPcieLib_Device_IntNodeCfg errorIntnode;                                             /**< \brief General Error Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg aerIntnode;                                               /**< \brief AER Error Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg pmeIntNode;                                               /**< \brief PME Interrupt Node configuration */
    IfxPcieLib_Device_IntNodeCfg linkIntNode;                                              /**< \brief Link Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg msgIntnode;                                               /**< \brief Message Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg miscIntnode;                                              /**< \brief Miscellaneous Interrupt node configuration */
} IfxPcie_Ep_InterruptCfg;

/** \brief EP Memory Handle (outbound)
 */
typedef struct
{
    uint64            wireMemBase;        /**< \brief Wire Memory to be Accessed */
    uint32            localMemBase;       /**< \brief Local Memory Base Value */
    uint32            size;               /**< \brief Size of memory */
    IfxPcie_AtuRegion atuRegion;          /**< \brief ATU Region Index */
    boolean           enabled;            /**< \brief if TRUE: Memory translation is enabled */
} IfxPcie_Ep_Mem;

/** \brief EP Memory Configuration (Outbound)
 */
typedef struct
{
    uint64            wireMemBase;        /**< \brief Wire Memory to be Accessed */
    uint32            localMemBase;       /**< \brief Local Memory Base Value */
    uint32            size;               /**< \brief Size of BAR Region */
    IfxPcie_AtuRegion atuRegion;          /**< \brief ATU Region Index */
} IfxPcie_Ep_MemCfg;

/** \} */

/** \addtogroup IfxLld_Pcie_Ep_Structures
 * \{ */
/** \brief EP Handle
 */
typedef struct
{
    Ifx_PCIE_USP              *pcieSFR;                                        /**< \brief Pointer to the PCIE EP SFR space */
    Ifx_HSPHY                 *hsphySFR;                                       /**< \brief Pointer to the HSPHY SFR space */
    IfxPcie_Index              index;                                          /**< \brief Index of the PCIE */
    IfxPcieLib_Device_EndPoint epFunction;                                     /**< \brief End Point Function */
    IfxPcie_Ep_Bar             barRegion[IFXPCIE_CFG_MAX_NUM_EP_BARS];         /**< \brief EP Bar Regions */
    IfxPcie_Ep_Mem             outBoundMemRegion[IfxPcie_AtuRegion_max];       /**< \brief EP Outbound Memory Regions */
    IfxPcieLib_Device_Atu      atu;                                            /**< \brief ATU Handle */
    IfxPcie_Ep_Int             interrupt;                                      /**< \brief EP  Interrupt */
    uint8                      numOutBoundMemRegions;                          /**< \brief Number of Outbound memory regions */
    boolean                    drsSupport;                                     /**< \brief if TRUE, DRS message will be sent */
    boolean                    busMasterAccess;                                /**< \brief if TRUE, the EP Device can access outbound memory */
    IfxPcie_Ep_State           state;                                          /**< \brief State of the EP Object */
} IfxPcie_Ep;

/** \brief EP Configuration
 */
typedef struct
{
    Ifx_PCIE_USP                 *pcieSFR;                                      /**< \brief Pointer to the PCIE EP SFR space */
    Ifx_HSPHY                    *hsphySFR;                                     /**< \brief Pointer to the HSPHY SFR space */
    IfxPcie_Index                 index;                                        /**< \brief Index of the PCIE */
    IfxPcieLib_Device_FunctionCfg epFunction;                                   /**< \brief Protocol EP Function Config */
    IfxPcie_Ep_BarCfg             barRegion[IFXPCIE_CFG_MAX_NUM_EP_BARS];       /**< \brief EP Bar Region Configurations */
    IfxPcie_Ep_MemCfg            *outBoundRegion;                               /**< \brief List of EP Outbound Memory Region Configurations */
    IfxPcie_Ep_InterruptCfg       interrupt;                                    /**< \brief EP Outbound Interrupt Configuration */
    uint8                         numOutBoundRegions;                           /**< \brief Number of Outbound Memory Regions Configured */
    boolean                       drsSupport;                                   /**< \brief if TRUE, DRS message will be sent */
    boolean                       pollForEnumeration;                           /**< \brief if TRUE, Driver will wait for enumeration Complete */
} IfxPcie_Ep_Config;

/** \} */

/** \addtogroup IfxLld_Pcie_Ep_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Default values of modules. Currenlty DMA module not included
 * \param pcieEpSfr PCIE EP sfr
 * \param config EP config ptr
 * \return None
 */
IFX_EXTERN void IfxPcie_Ep_initConfig(Ifx_PCIE_USP *pcieEpSfr, IfxPcie_Ep_Config *config);

/** \brief Initialize EP
 * \param epHandle EP Handler ptr
 * \param config Ptr to EP config
 * \return Status of Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_init(IfxPcie_Ep *epHandle, IfxPcie_Ep_Config *config);

/** \brief Initialize EP Module
 * \param epHandle EP Handler ptr
 * \param config Ptr to EP config
 * \return Status of Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_initModule(IfxPcie_Ep *epHandle, IfxPcie_Ep_Config *config);

/** \brief Initialize LTSSM
 * \param epHandle EP Handler ptr
 * \return None
 */
IFX_EXTERN void IfxPcie_Ep_initLink(IfxPcie_Ep *epHandle);

/** \brief Initialize EP Module after Enumeration
 * \param epHandle EP Handler ptr
 * \return Status of Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_initPostEnumeration(IfxPcie_Ep *epHandle);

/** \brief Initialize EP outbound accesses after enumeration
 * \param epHandle EP Handler ptr
 * \return Status of Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_initOutBoundAccess(IfxPcie_Ep *epHandle);

/** \brief Allocate EP Bar Regions
 * \param epHandle EP Handler ptr
 * \param barCfgPtr Ptr to BAR config array
 * \return Status of Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_allocateBarMemories(IfxPcie_Ep *epHandle, IfxPcie_Ep_BarCfg *barCfgPtr);

/** \brief Configure Memory ATU for outbound Transactions
 * \param epHandle Pointer to the EP device handle
 * \param wireMemBase Base address of wire memory (NOTE: 64 Bit)
 * \param localMemBase Base address of local memory
 * \param size size of the region
 * \param region ATU outbound region
 * \return Success: configuration successful
 * Failure: Configuration not successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_configureOutBoundAtu(IfxPcie_Ep *epHandle, uint64 wireMemBase, uint32 localMemBase, uint32 size, IfxPcie_AtuRegion region);

/** \brief Configure Memory ATU for inbound Transactions
 * \param epHandle Pointer to the EP device handle
 * \param barIndex Index of the BAR
 * \param localMemBase Base address of local memory
 * \param region ATU outbound region
 * \return Success: configuration successful
 * Failure: Configuration not successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_configureInBoundAtu(IfxPcie_Ep *epHandle, IfxPcie_BarNum barIndex, uint32 localMemBase, IfxPcie_AtuRegion region);

/** \brief Disable BAR Region
 * \param epHandle EP Handler ptr
 * \param barIndex Index of BAR to be disabled
 * \return None
 */
IFX_EXTERN void IfxPcie_Ep_disableBar(IfxPcie_Ep *epHandle, IfxPcie_BarNum barIndex);

/** \brief Initialize EP Module Interrupts to SOC
 * \param epHandle EP Handler ptr
 * \param config Ptr to EP config
 * \return Status of Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_initInterrupts(IfxPcie_Ep *epHandle, IfxPcie_Ep_Config *config);

/** \brief Initialize Interrupt Generation from EP after enumeration
 * NOTE: Capabilities have to probed prior to calling this function.
 * \param epHandle EP Handler ptr
 * \return Status of Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_initInterruptGen(IfxPcie_Ep *epHandle);

/** \brief Generate Interrupt from an EP to RC
 * NOTE: Will be generated as configured and allowed by RC
 * MSIX supports 64 interrupts
 * MSI supports only 32 interrupts
 * INTX supports only 1 interrupt
 * \param epHandle Pointer to the EP device handle
 * \param interruptIndex index of the interrupt
 * \return Success: Generation of Interrupt successful
 * failure: Interrupt failed due to error
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_generateInterrupt(IfxPcie_Ep *epHandle, uint8 interruptIndex);

/** \brief Get capability pointer
 * \param epHandle Pointer to the EP device Handle
 * \param capId capability ID
 * \param extendedCap If extended Capability, this is TRUE
 * \return void *pointer to the capability
 * returns NULL_PTR, if no capability found.
 */
IFX_EXTERN void *IfxPcie_Ep_getCapabilityPtr(IfxPcie_Ep *epHandle, uint16 capId, boolean extendedCap);

/** \brief Generate Wake-up request from EP to RC
 * \return None
 */
IFX_EXTERN void IfxPcie_Ep_triggerWakeup(IfxPcie_Ep *epHandle);

/** \brief Send LTR MEssage to RC
 * NOTE: Capabilities have to probed prior to calling this function.
 * NOTE: LTR capability must be enabled prior to this function
 * \param epHandle EP Handler ptr
 * \param ltrMessagePtr pointer to the LTR Message payload
 * \return Status: LTR is enabled, and message is SENT: success.
 * In any other case: Failure
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Ep_sendLtrMessage(IfxPcie_Ep *epHandle, IfxPcieCap_LtrMessage *ltrMessagePtr);

/** \} */

#endif /* IFXPCIE_EP_H */
