/**
 * \file IfxSmmRst.h
 * \brief SMM  basic functionality
 * \ingroup IfxLld_Smm
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_SmmRst_Usage How to use the SMM reset driver?
 * \ingroup IfxLld_Smm
 *
 * SMM reset driver provides the functionality of reset triggers and configurability.
 *
 * In the following sections it will be described, how to integrate the driver into the application framework.
 *
 * \section IfxLld_SmmRst_Preparation Preparation
 * \subsection IfxLld_SmmRst_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Smm/Std/IfxSmmRst.h>
 * \endcode
 *
 * \subsection IfxLld_SmmRst_Init Module Initialization
 * \code
 *
 * IfxSmmRst_Config rstConfig;
 * //API will initialize the reset configuration with default values
 * IfxSmmRst_initConfig(&rstConfig);
 *
 * //Modify the configuration as per application need.
 * rstConfig.rstTrigCfg.software = IfxSmmRst_TriggerRstCfgType_applicationReset; // Trigger application reset via software.
 * //Configure the ESRx pins
 * //Configure reset elongation time if needed.
 *
 * //Initialize the reset configuration
 * IfxSmmRst_init(&rstConfig);
 *
 * \endcode
 *
 * \subsection IfxLld_SmmRst_Evaulation Reset evaluation
 * \code
 *  // Reset evaluation API evaluates the last reset type and triggers. Evaluation is stored in reset variable.
 *
 *  IfxSmmRst_Reset reset;
 *  IfxSmmRst_evaluateReset(&reset);
 *
 *  //Reset trigger information for safe SMU and secure SMU alarm group and alarm id can be found using below API
 *  IfxSmmRst_SmuSafeRstTrigger safeRstTrig;
 *  IfxSmmRst_SmuSecureRstTrigger secRstTrig;
 *
 *  IfxSmmRst_getSmuSafeRstTrigger(&safeRstTrig, FALSE);
 *  IfxSmmRst_getSmuSafeRstTrigger(&safeRstTrig, TRUE);
 *  IfxSmmRst_getSmuSecureRstTrigger(&secRstTrig);
 *
 *  // Reset information is stored in  reset, safeRstTrig, secRstTrig.
 *  // Stored information could be later used in application. Application could clear all reset register if needed, to store next reset cycle data.
 *  IfxSmmRst_clearAllResetRegisters();
 *
 *  // To check last reset type
 *  if(reset.lastResetType == IfxSmmRst_ResetType_application)
 *  {
 *  }
 *
 *  //To check highest reset type
 *  if(reset.highestResetType = IfxSmmRst_ResetType_system)
 *  {
 *  }
 *
 *  //To check if the highest warm reset trigger was stm0
 *  if(reset.highestWarmRstTrigger == IfxSmmRst_WarmRstTrigger_stm0)
 *  {
 *  }
 *
 *  // Similarly all the accumulated cold reset, warm reset trigger and accumulated resets are stored in a structure.
 *
 *  //Reset driver also provides functionality to trigger different resets.
 *  //To trigger application reset.
 *  IfxSmmRst_triggerReset(IfxSmmRst_TriggerRstCfgType_applicationReset);
 *
 *  //If application needs to store the user info before doing a reset then use IfxSmmRst_performReset API.
 *  IfxSmmRst_performReset(IfxSmmRst_TriggerRstCfgType_systemReset, 0x100);
 *
 *  //To trigger cold power on reset
 *  IfxSmmRst_triggerColdPowerOnReset();
 *
 *  \endcode
 *
 * \defgroup IfxLld_Smm_Std_Rst Rst Basic Functionality
 * \ingroup IfxLld_Smm_Std
 */

#ifndef IFXSMMRST_H
#define IFXSMMRST_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxSmm_cfg.h"
#include "Cpu/Std/IfxCpu.h"
#include "Smm/Std/IfxSmm.h"
#include "IfxPms_reg.h"
#include "Port/Std/IfxPort.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

#define IFXSMMRST_PERFORM_RESET_DELAY      (90000U)

/** \brief Macro for Reset counter base clock
 */
#define IFXSMMRST_RESET_COUNTER_BASE_CLOCK (100e6f)

/** \brief Macro for time in nanoseconds
 */
#define IFXSMMRST_TIME_IN_NS               (1000000000U)

/** \brief Macro for maximum tick count
 */
#define IFXSMMRST_RESET_COUNTER_MAX_VALUE  (4096U)

/** \brief SMM ESR Pad level selection offset
 */
#define IFXSMMRST_DRVCFG_PL_OFF            (9U)

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief Cold Reset Trigger
 */
typedef enum
{
    IfxSmmRst_ColdResetTrigger_vdd       = 0,   /**< \brief VDD rail */
    IfxSmmRst_ColdResetTrigger_vddext    = 1,   /**< \brief VEXT rail */
    IfxSmmRst_ColdResetTrigger_vssdchs   = 2,   /**< \brief VSSDCHS rail */
    IfxSmmRst_ColdResetTrigger_vddextdc  = 3,   /**< \brief VDDEXTDC rail */
    IfxSmmRst_ColdResetTrigger_vddcls    = 4,   /**< \brief VDD CLS rail */
    IfxSmmRst_ColdResetTrigger_vddevrsb  = 5,   /**< \brief VEVRSB rail */
    IfxSmmRst_ColdResetTrigger_vddm      = 6,   /**< \brief VDDM rail */
    IfxSmmRst_ColdResetTrigger_vddphphy0 = 7,   /**< \brief VDDPHPHY0 rail */
    IfxSmmRst_ColdResetTrigger_vddphphy1 = 8,   /**< \brief VDDPHPHY1 rail */
    IfxSmmRst_ColdResetTrigger_vddhsif   = 10,  /**< \brief VDDHSIF rail */
    IfxSmmRst_ColdResetTrigger_vddpad    = 11,  /**< \brief VDDPAD rail */
    IfxSmmRst_ColdResetTrigger_vddcpua   = 12,  /**< \brief VDDCPUA rail = VDDCPU4 */
    IfxSmmRst_ColdResetTrigger_vddcpub   = 13,  /**< \brief VDDCPUB rail = VDDCPU5 */
    IfxSmmRst_ColdResetTrigger_vddcpuc   = 14,  /**< \brief VDDCPUC rail = VDDCPU3 */
    IfxSmmRst_ColdResetTrigger_vddppu    = 15,  /**< \brief VDDPPU rail */
    IfxSmmRst_ColdResetTrigger_vddlmu    = 16,  /**< \brief VDD LMU rail */
    IfxSmmRst_ColdResetTrigger_vddphy0   = 17,  /**< \brief VDDPHY0 rail */
    IfxSmmRst_ColdResetTrigger_vddphy1   = 18,  /**< \brief VDDPHY1 rail */
    IfxSmmRst_ColdResetTrigger_vddphy2   = 19,  /**< \brief VDDPHY2 rail */
    IfxSmmRst_ColdResetTrigger_pdcld     = 23,  /**< \brief VDD threshold violation */
    IfxSmmRst_ColdResetTrigger_undefined = 255  /**< \brief Volt Undefined */
} IfxSmmRst_ColdResetTrigger;

/** \brief Enumeration describing service request trigger edge
 */
typedef enum
{
    IfxSmmRst_EdgeTrigger_none        = 0,  /**< \brief None of the edges will trigger anything */
    IfxSmmRst_EdgeTrigger_risingEdge  = 1,  /**< \brief Trigger is generated upon a rising edge */
    IfxSmmRst_EdgeTrigger_fallingEdge = 2,  /**< \brief Trigger is generated upon a falling edge */
    IfxSmmRst_EdgeTrigger_bothEdge    = 3   /**< \brief Trigger is generated upon a rising OR falling edge */
} IfxSmmRst_EdgeTrigger;

/** \brief Enumeration describing Reset release and ESR0 reset output elongation behaviour
 */
typedef enum
{
    IfxSmmRst_Esr0RstOutputRelease_immediate                = 0,  /**< \brief ESR0 output is de-asserted immediately on reset release */
    IfxSmmRst_Esr0RstOutputRelease_bothResetElongatedByTime = 1,  /**< \brief Both ESR0 Reset Output and reset release are elongated by RESETCNT time */
    IfxSmmRst_Esr0RstOutputRelease_esr0ElongatedByTime      = 2,  /**< \brief ESR0 reset output is elongated by RSTECNT time but reset is released immediately */
    IfxSmmRst_Esr0RstOutputRelease_software                 = 3   /**< \brief ESR0 output is released by user software (ARC bit) and reset release is elongate by RSTECNT */
} IfxSmmRst_Esr0RstOutputRelease;

/** \brief Enumeration describing counter clock
 */
typedef enum
{
    IfxSmmRst_EsrCounterClock_fback        = 0, /**< \brief Counter is clocked by fback */
    IfxSmmRst_EsrCounterClock_fbackDiv1024 = 1  /**< \brief Counter is clocked by fback/1024 */
} IfxSmmRst_EsrCounterClock;

/** \brief Enumeration describing digital filter usage.
 */
typedef enum
{
    IfxSmmRst_EsrDigitalFilter_bypassed = 0,  /**< \brief Filter is bypassed */
    IfxSmmRst_EsrDigitalFilter_used     = 1   /**< \brief Filter is used. Pulses less than 30ns are suppressed and pulses longer than 100ns will result in a trigger */
} IfxSmmRst_EsrDigitalFilter;

/** \brief Enumeration describing external service request.
 */
typedef enum
{
    IfxSmmRst_ExternalServiceRequest_esr0 = 0,  /**< \brief External Service Request 0 */
    IfxSmmRst_ExternalServiceRequest_esr1 = 1,  /**< \brief External Service Request 1 */
    IfxSmmRst_ExternalServiceRequest_esr2 = 2   /**< \brief External Service Request 2 */
} IfxSmmRst_ExternalServiceRequest;

/** \brief Reset Type Status(Refer Reset Type Status Register)
 */
typedef enum
{
    IfxSmmRst_ResetType_lvd         = 0,  /**< \brief Lvd Reset */
    IfxSmmRst_ResetType_powerdomain = 1,  /**< \brief Power Domain Cold Reset */
    IfxSmmRst_ResetType_coldpoweron = 2,  /**< \brief Cold Power On Reset */
    IfxSmmRst_ResetType_warmpoweron = 3,  /**< \brief Warm Power On Reset */
    IfxSmmRst_ResetType_system      = 4,  /**< \brief System Reset */
    IfxSmmRst_ResetType_application = 5,  /**< \brief Application reset */
    IfxSmmRst_ResetType_debug       = 6,  /**< \brief Debug reset */
    IfxSmmRst_ResetType_trace       = 7,  /**< \brief Trace reset */
    IfxSmmRst_ResetType_undefined   = 255 /**< \brief Undefined Reset */
} IfxSmmRst_ResetType;

/** \brief Reset Trigger
 */
typedef enum
{
    IfxSmmRst_Trigger_esr0       = 0,  /**< \brief ESR0 */
    IfxSmmRst_Trigger_esr1       = 1,  /**< \brief ESR1 */
    IfxSmmRst_Trigger_esr2       = 2,  /**< \brief ESR2 */
    IfxSmmRst_Trigger_esr3       = 3,  /**< \brief ESR3 */
    IfxSmmRst_Trigger_smusafe0ar = 4,  /**< \brief SAFE0 AR */
    IfxSmmRst_Trigger_smusafe0sr = 5,  /**< \brief SAFE0 SR */
    IfxSmmRst_Trigger_smusafe1ar = 6,  /**< \brief SAFE1 AR */
    IfxSmmRst_Trigger_smusafe1sr = 7,  /**< \brief SAFE1 SR */
    IfxSmmRst_Trigger_sw         = 9,  /**< \brief Software reset */
    IfxSmmRst_Trigger_stm0       = 10, /**< \brief STM0 Compare Match */
    IfxSmmRst_Trigger_stm1       = 11, /**< \brief STM1 Compare Match */
    IfxSmmRst_Trigger_stm2       = 12, /**< \brief STM2 Compare Match */
    IfxSmmRst_Trigger_stm3       = 13, /**< \brief STM3 Compare Match */
    IfxSmmRst_Trigger_stm4       = 14, /**< \brief STM4 Compare Match */
    IfxSmmRst_Trigger_stm5       = 15, /**< \brief STM5 Compare Match */
    IfxSmmRst_Trigger_porst      = 16, /**< \brief PORST */
    IfxSmmRst_Trigger_cb0        = 17, /**< \brief Cerberus(CB0) System Reset */
    IfxSmmRst_Trigger_cb1        = 18, /**< \brief Cerberus(CB1) Debug Reset */
    IfxSmmRst_Trigger_cb3        = 19, /**< \brief Cerberus(CB3) Application Reset */
    IfxSmmRst_Trigger_dwr        = 20, /**< \brief Double SMU Reset */
    IfxSmmRst_Trigger_csrts      = 22, /**< \brief CSRT System Reset */
    IfxSmmRst_Trigger_csrta      = 23, /**< \brief CSRT Application Reset */
    IfxSmmRst_Trigger_lbporst    = 24, /**< \brief LBIST termination due to PORST */
    IfxSmmRst_Trigger_lbterm     = 25, /**< \brief LBIST was properly terminated */
    IfxSmmRst_Trigger_padrst     = 26, /**< \brief Pad Reset Configuration */
    IfxSmmRst_Trigger_phyrst     = 27, /**< \brief Phy Reset Configuration */
    IfxSmmRst_Trigger_undefined  = 255 /**< \brief Undefined Value */
} IfxSmmRst_Trigger;

/** \brief Reset trigger configuration Type
 */
typedef enum
{
    IfxSmmRst_TriggerRstCfgType_noReset           = 0,  /**< \brief No reset is generated for a trigger */
    IfxSmmRst_TriggerRstCfgType_systemReset       = 1,  /**< \brief System Reset is generated for a trigger */
    IfxSmmRst_TriggerRstCfgType_applicationReset  = 2,  /**< \brief Application Reset is generated for a trigger */
    IfxSmmRst_TriggerRstCfgType_moduleGroup0Reset = 3,  /**< \brief Module Group-0 Reset is generated for a trigger */
    IfxSmmRst_TriggerRstCfgType_moduleGroup1Reset = 4,  /**< \brief Module Group-1 Reset is generated for a trigger */
    IfxSmmRst_TriggerRstCfgType_moduleGroup2Reset = 5,  /**< \brief Module Group-2 Reset is generated for a trigger */
    IfxSmmRst_TriggerRstCfgType_moduleGroup3Reset = 6,  /**< \brief Module Group-3 Reset is generated for a trigger */
    IfxSmmRst_TriggerRstCfgType_undefinedReset    = 7   /**< \brief Reserved bit not use this combination */
} IfxSmmRst_TriggerRstCfgType;

/** \brief Enum describing status of warm reset events. (WRMRSTTRIG)
 */
typedef enum
{
    IfxSmmRst_WarmRstTrigger_esr0       = 0,  /**< \brief ESR0 */
    IfxSmmRst_WarmRstTrigger_esr1       = 1,  /**< \brief ESR1 */
    IfxSmmRst_WarmRstTrigger_esr2       = 2,  /**< \brief ESR2 */
    IfxSmmRst_WarmRstTrigger_smusafe0ar = 4,  /**< \brief SAFE0 AR */
    IfxSmmRst_WarmRstTrigger_smusafe0sr = 5,  /**< \brief SAFE0 SR */
    IfxSmmRst_WarmRstTrigger_smusafe1ar = 6,  /**< \brief SAFE1 AR */
    IfxSmmRst_WarmRstTrigger_smusafe1sr = 7,  /**< \brief SAFE1 SR */
    IfxSmmRst_WarmRstTrigger_smusec     = 8,  /**< \brief Secure SMU */
    IfxSmmRst_WarmRstTrigger_sw         = 9,  /**< \brief Software reset */
    IfxSmmRst_WarmRstTrigger_stm0       = 10, /**< \brief STM0 */
    IfxSmmRst_WarmRstTrigger_stm1       = 11, /**< \brief STM1 */
    IfxSmmRst_WarmRstTrigger_stm2       = 12, /**< \brief STM2 */
    IfxSmmRst_WarmRstTrigger_stm3       = 13, /**< \brief STM3 */
    IfxSmmRst_WarmRstTrigger_stm4       = 14, /**< \brief STM4 */
    IfxSmmRst_WarmRstTrigger_stm5       = 15, /**< \brief STM5 */
    IfxSmmRst_WarmRstTrigger_cb0        = 18, /**< \brief Cerberus(CB0) System Reset */
    IfxSmmRst_WarmRstTrigger_cb3        = 20, /**< \brief Cerberus(CB3) Application Reset */
    IfxSmmRst_WarmRstTrigger_dwr        = 21, /**< \brief Double SMU Reset */
    IfxSmmRst_WarmRstTrigger_tcu        = 22, /**< \brief TCU */
    IfxSmmRst_WarmRstTrigger_lbporst    = 29, /**< \brief LBIST termination due to PORST */
    IfxSmmRst_WarmRstTrigger_lbterm     = 30, /**< \brief LBIST was properly terminated */
    IfxSmmRst_WarmRstTrigger_undefined  = 255 /**< \brief Undefined Value */
} IfxSmmRst_WarmRstTrigger;

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \brief Data structure holding ESR input configuration
 */
typedef struct
{
    IfxSmmRst_EdgeTrigger      edge;                   /**< \brief Edge that leads to an ESR trigger */
    IfxSmmRst_EsrDigitalFilter filter;                 /**< \brief Activates digital spike filter. Pulses less than 30ns are suppressed and longer than 100ns will result in a trigger */
    IfxSmmRst_EsrCounterClock  clkDiv;                 /**< \brief Counter clock */
    boolean                    eventSel;               /**< \brief TRUE --> Event triggered when captured pulse greater than RSTDELAY count value */
    uint16                     rstPulseCmpValue;       /**< \brief Reset pulse width compare value */
} IfxSmmRst_EsrInputConfig;

/** \brief Data structure holding ESR0 configuration
 */
typedef struct
{
    IfxSmmRst_EsrInputConfig       inputCfg;             /**< \brief Input configuration */
    IfxSmmRst_Esr0RstOutputRelease rstRelease;           /**< \brief Reset release output elongation behaviour */
    uint32                         rstElongTimeNs;       /**< \brief Reset elongation time */
    IfxSmm_PortMode                portMode;             /**< \brief Specifies the port pin mode */
    IfxPort_PadDriver              padDriver;            /**< \brief Specifies the driver mode */
} IfxSmmRst_Esr0Config;

/** \brief Data structure holding ESR1 configuration
 */
typedef struct
{
    IfxSmmRst_EsrInputConfig inputCfg;        /**< \brief Input configuration */
    IfxSmm_PortMode          portMode;        /**< \brief Specifies the port pin mode */
    IfxPort_PadDriver        padDriver;       /**< \brief Specifies the driver mode */
} IfxSmmRst_Esr1Config;

/** \brief Data structure holding ESR2 configuration
 */
typedef struct
{
    IfxSmmRst_EsrInputConfig inputCfg;                        /**< \brief Input configuration */
    boolean                  enableRstElongInWarmPorst;       /**< \brief Enable reset elongation for warm PORST */
    boolean                  enableRstElongInAppRst;          /**< \brief Enable reset elongation for application reset */
    uint32                   rstElongTimeNs;                  /**< \brief Reset elongation time */
} IfxSmmRst_Esr2Config;

/** \brief Data structure holding Reset trigger configuration
 */
typedef struct
{
    IfxSmmRst_TriggerRstCfgType esr0;             /**< \brief ESR0 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType esr1;             /**< \brief ESR1 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType esr2;             /**< \brief ESR2 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType smuSafe0Ar;       /**< \brief SMU safe0 reset0 trigger configuration */
    IfxSmmRst_TriggerRstCfgType smuSafe0Sr;       /**< \brief SMU safe0 reset1 trigger configuration */
    IfxSmmRst_TriggerRstCfgType smuSafe1Ar;       /**< \brief SMU safe1 reset0 trigger configuration */
    IfxSmmRst_TriggerRstCfgType smuSafe1Sr;       /**< \brief SMU safe1 reset1 trigger configuration */
    IfxSmmRst_TriggerRstCfgType software;         /**< \brief Software reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType stm0;             /**< \brief STM0 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType stm1;             /**< \brief STM1 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType stm2;             /**< \brief STM2 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType stm3;             /**< \brief STM3 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType stm4;             /**< \brief STM4 reset trigger configuration */
    IfxSmmRst_TriggerRstCfgType stm5;             /**< \brief STM5 reset trigger configuration */
    boolean                     padRst;           /**< \brief TRUE --> Pad gets reset after 240us. FALSE --> resets instantly */
    boolean                     phyRst;           /**< \brief TRUE --> Phy gets reset after 240us. FALSE --> resets instantly */
} IfxSmmRst_ResetTrigConfig;

/** \brief Data structure holding reset configuration
 */
typedef struct
{
    IfxSmmRst_Esr0Config      esr0Cfg;          /**< \brief ESR0 configuration */
    IfxSmmRst_Esr1Config      esr1Cfg;          /**< \brief ESR1 configuration */
    IfxSmmRst_Esr2Config      esr2Cfg;          /**< \brief ESR2 configuration */
    IfxSmmRst_ResetTrigConfig rstTrigCfg;       /**< \brief Reset trigger configuration */
} IfxSmmRst_Config;

/** \brief Data structure holding reset data
 */
typedef struct
{
    Ifx_SMM_WRMRSTTRIG         warmRstTrigger;              /**< \brief All the reset types accumulated for the last reset type(WRMRSTTRIG). */
    Ifx_PMS_CLDRSTRIG          coldResetTrigger;            /**< \brief Cold Reset Trigger (CLDRSTRIG) */
    Ifx_PMS_CLDRSTSTAT         coldResetStatus;             /**< \brief Accumulated Cold Reset status(CLDRSTSTAT) */
    Ifx_SMM_RSTSTAT            resetStatus;                 /**< \brief Type of last resets which happened accumulatively(RSTSTAT) */
    IfxSmmRst_ResetType        highestResetType;            /**< \brief Highest Reset Type (RSTSTATH) */
    IfxSmmRst_WarmRstTrigger   highestWarmRstTrigger;       /**< \brief Highest Warm Reset Trigger (WRMRSTTRIGH) */
    IfxSmmRst_ColdResetTrigger lastColdRstTrigger;          /**< \brief Last Cold Reset Trigger (CLDRSTRIGL) */
    boolean                    cpuSafeState;                /**< \brief CPU Safe state ( 1- Safe, 0 - Non-Safe) */
} IfxSmmRst_Reset;

/** \brief SMU SAFE Reset Trigger information
 */
typedef struct
{
    uint8 safe0AlmGrp[2];       /**< \brief SAFE0 ALM Grp 0 and 1 */
    uint8 safe0AlmId[2];        /**< \brief SAFE0 ALM ID 0 and 1 */
    uint8 safe1AlmGrp[2];       /**< \brief SAFE1 ALM Grp 0 and 1 */
    uint8 safe1AlmId[2];        /**< \brief SAFE1 ALM ID 0 and 1 */
} IfxSmmRst_SmuSafeRstTrigger;

/** \brief SMU SECURE Reset Trigger information
 */
typedef struct
{
    uint8 secureAlmGrp;       /**< \brief Secure ALM Grp */
    uint8 secureAlmId;        /**< \brief Secure ALM ID */
} IfxSmmRst_SmuSecureRstTrigger;

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief API to clear the Cold Reset Status
 * \return None
 */
IFX_INLINE void IfxSmmRst_clearColdResetStatus(void);

/** \brief This function configures the request trigger in the Reset Configuration Register
 * \param trigger Reset Trigger
 * \param rstCfgType Reset Configuration Type
 * \return None
 */
IFX_INLINE void IfxSmmRst_configureResetRequestTrigger(const IfxSmmRst_Trigger trigger, const IfxSmmRst_TriggerRstCfgType rstCfgType);

/** \brief API reads and returns the warm reset trigger status.
 * API provides information on all the triggers accumulated for the last reset types after the last clear event.
 * \return Returns all the triggers accumulated for the last reset types
 */
IFX_INLINE uint32 IfxSmmRst_readWarmResetTriggerStatus(void);

/** \brief API to check if the previous reset was application reset or not.
 * \return returns application reset (1) or not (0)
 */
IFX_INLINE boolean IfxSmmRst_wasApplicationReset(void);

/** \brief API reads and returns the cold reset trigger status
 * \return Voltage Domain Raw Reset Status
 */
IFX_INLINE uint32 IfxSmmRst_readColdResetTriggerStatus(void);

/** \brief Returns if Flash has shutdown correctly. Also tells if the memory content is valid
 * \return If the flash has shutdown correctly after reset
 */
IFX_INLINE boolean IfxSmmRst_wasFlashShutdown(void);

/** \brief Returns if Cpu's have shutdown correctly. Also tells if the memory content is valid
 * \param cpu Cpu id
 * \return True --> CPU shutdown successful.
 * False --> CPU shutdown not successful. Possible that memory content is corrupted by the reset
 */
IFX_INLINE boolean IfxSmmRst_wasCpuShutdown(IfxCpu_ResourceCpu cpu);

/** \brief Returns if PPU has shutdown correctly. Also tells if the memory content is valid
 * \return If the ppuc has shutdown correctly after reset
 */
IFX_INLINE boolean IfxSmmRst_wasPpuShutdown(void);

/** \brief Returns the Highest reset type after the CLRC.
 * \return Returns Highest reset type
 */
IFX_INLINE IfxSmmRst_ResetType IfxSmmRst_getHighestResetType(void);

/** \brief Returns the highest warm reset trigger register
 * \return Returns the highest warm RST trigger.
 */
IFX_INLINE IfxSmmRst_WarmRstTrigger IfxSmmRst_readHighestWarmResetTrigger(void);

/** \brief API sets the trigger edge for ESRx.
 * \param esr External service request selection ESRx.
 * \param edge Edge selection
 * \return None
 */
IFX_INLINE void IfxSmmRst_setEsrTriggerEdge(IfxSmmRst_ExternalServiceRequest esr, IfxSmmRst_EdgeTrigger edge);

/** \brief API to use or bypass digital filter for ESRx
 * \param esr External service request selection ESRx.
 * \param enableEsrFilter Configuration to bypass or use digital filter
 * \return None
 */
IFX_INLINE void IfxSmmRst_useEsrDigitalFilter(IfxSmmRst_ExternalServiceRequest esr, IfxSmmRst_EsrDigitalFilter enableEsrFilter);

/** \brief API to clear all(reset type, reset trigger, SMU reset flag and cold reset status) reset registers.
 * \return None
 */
IFX_INLINE void IfxSmmRst_clearAllResetRegisters(void);

/** \brief API to trigger reset.
 * To write user data before reset refer API IfxSmmRst_performReset.
 * \param rstCfgType Type of reset.
 * \return None
 */
IFX_INLINE void IfxSmmRst_triggerReset(const IfxSmmRst_TriggerRstCfgType rstCfgType);

/** \brief API to trigger cold power on reset.
 * \return None
 */
IFX_INLINE void IfxSmmRst_triggerColdPowerOnReset(void);

/** \brief API to set ESR pin mode.
 * \param esr ESRx(ESR0, ESR1, ESR2) selection
 * \param mode Port mode
 * \return None
 */
IFX_INLINE void IfxSmmRst_setEsrPinMode(IfxSmmRst_ExternalServiceRequest esr, IfxSmm_PortMode mode);

/** \brief This function configures the request trigger for the secure SMU.
 * NOTE : Default CPUCS has access to RSTTRIGCTRLC. Access should be provided for
 * To invoke the API from other cores access should be provided.
 * \param rstCfgType Reset Configuration Type
 * \return None
 */
IFX_INLINE void IfxSmmRst_configureSecureSmuRstTrigger(const IfxSmmRst_TriggerRstCfgType rstCfgType);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function Evaluate the Reset and store the reset details
 * \param reset Pointer to store evaluated reset data
 * \return None
 */
IFX_EXTERN void IfxSmmRst_evaluateReset(IfxSmmRst_Reset *reset);

/** \brief This function triggers system/application reset via software.
 * \param rstCfgType reset type (only application and system reset are valid)
 * \param userResetInfo user Reset Information
 * \return None
 */
IFX_EXTERN void IfxSmmRst_performReset(const IfxSmmRst_TriggerRstCfgType rstCfgType, const uint16 userResetInfo);

/** \brief Stores the reset triggers information with respect to alarm group number and alarm id.
 * \param safeTrigger Pointer to store SMU safe reset trigger information
 * \param smuSafeIndex SMU SAFE Index number
 * \return None
 */
IFX_EXTERN void IfxSmmRst_getSmuSafeRstTrigger(IfxSmmRst_SmuSafeRstTrigger *safeTrigger, boolean smuSafeIndex);

/** \brief API to get SMU secure reset triggers information with respect to alarm group number and alarm id.
 * \param secureTrigger Pointer to store SMU secure reset trigger information
 * \return None
 */
IFX_EXTERN void IfxSmmRst_getSmuSecureRstTrigger(IfxSmmRst_SmuSecureRstTrigger *secureTrigger);

/** \brief API to configure the ESR0 reset output elongation time.
 * \param esrBehaviour ESR0 reset output elongation behaviour
 * \param timeInNs Time duration in nanoseconds.
 * \return None
 */
IFX_EXTERN void IfxSmmRst_configureEsr0ElongationTime(IfxSmmRst_Esr0RstOutputRelease esrBehaviour, uint32 timeInNs);

/** \brief API to configure the ESR2 reset output elongation time.
 * \param timeInNs Time duration in nanoseconds.
 * \return None
 */
IFX_EXTERN void IfxSmmRst_configureEsr2ElongationTime(uint32 timeInNs);

/** \brief API to initialize reset configuration with default values.
 * \param resetCfg Pointer to reset configuratio
 * \return None
 */
IFX_EXTERN void IfxSmmRst_initConfig(IfxSmmRst_Config *resetCfg);

/** \brief API to initialize reset  registers.
 * \param resetCfg Pointer to reset configuration
 * \return None
 */
IFX_EXTERN void IfxSmmRst_init(IfxSmmRst_Config *resetCfg);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxSmmRst_clearColdResetStatus(void)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_config);
#endif

    /* Clear Cold Reset status */
    PMS_CLDRSTSTATCLR.B.CLEAR = 1U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmmRst_configureResetRequestTrigger(const IfxSmmRst_Trigger trigger, const IfxSmmRst_TriggerRstCfgType rstCfgType)
{
    Ifx_SMM_RSTTRIGCTRLA Rstcona;
    Ifx_SMM_RSTTRIGCTRLB Rstconb;

    Rstcona.U = SMM_RSTTRIGCTRLA.U;
    Rstconb.U = SMM_RSTTRIGCTRLB.U;

    switch (trigger)
    {
    case IfxSmmRst_Trigger_esr0:
        Rstcona.B.ESR0 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_esr1:
        Rstcona.B.ESR1 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_esr2:
        Rstcona.B.ESR2 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_smusafe0ar:
        Rstcona.B.SMUSAFE0AR = rstCfgType;
        break;

    case IfxSmmRst_Trigger_smusafe0sr:
        Rstcona.B.SMUSAFE0SR = rstCfgType;
        break;

    case IfxSmmRst_Trigger_smusafe1ar:
        Rstcona.B.SMUSAFE1AR = rstCfgType;
        break;

    case IfxSmmRst_Trigger_smusafe1sr:
        Rstcona.B.SMUSAFE1SR = rstCfgType;
        break;

    case IfxSmmRst_Trigger_sw:
        Rstcona.B.SW = rstCfgType;
        break;

    case IfxSmmRst_Trigger_padrst:
        Rstcona.B.PINRST = rstCfgType;
        break;

    case IfxSmmRst_Trigger_phyrst:
        Rstcona.B.PHYRST = rstCfgType;
        break;

    case IfxSmmRst_Trigger_stm0:
        Rstconb.B.STM0 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_stm1:
        Rstconb.B.STM1 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_stm2:
        Rstconb.B.STM2 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_stm3:
        Rstconb.B.STM3 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_stm4:
        Rstconb.B.STM4 = rstCfgType;
        break;

    case IfxSmmRst_Trigger_stm5:
        Rstconb.B.STM5 = rstCfgType;
        break;

    default:
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

    SMM_RSTTRIGCTRLA.U = Rstcona.U;
    SMM_RSTTRIGCTRLB.U = Rstconb.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE uint32 IfxSmmRst_readWarmResetTriggerStatus(void)
{
    return SMM_WRMRSTTRIG.U;
}


IFX_INLINE boolean IfxSmmRst_wasApplicationReset(void)
{
    return (boolean)SMM_RSTSTAT.B.APPRST;
}


IFX_INLINE uint32 IfxSmmRst_readColdResetTriggerStatus(void)
{
    return PMS_CLDRSTRIG.U;
}


IFX_INLINE boolean IfxSmmRst_wasFlashShutdown(void)
{
    return SMM_SHSEQCTRLD.B.FLSS;
}


IFX_INLINE boolean IfxSmmRst_wasCpuShutdown(IfxCpu_ResourceCpu cpu)
{
    return (SMM_SHSEQCTRLD.B.CSSX & (1u << cpu)) >> cpu;
}


IFX_INLINE boolean IfxSmmRst_wasPpuShutdown(void)
{
    return SMM_SHSEQCTRLD.B.PPUSS;
}


IFX_INLINE IfxSmmRst_ResetType IfxSmmRst_getHighestResetType(void)
{
    uint8               index;
    Ifx_SMM_RSTSTATH    smmRststatH;
    IfxSmmRst_ResetType highestResetType = IfxSmmRst_ResetType_undefined;

    smmRststatH.U = SMM_RSTSTATH.U;

    for (index = 0; index < 32; index++)
    {
        if (smmRststatH.U & (1 << index))
        {
            highestResetType = (IfxSmmRst_ResetType)index;
            break;
        }
    }

    return highestResetType;
}


IFX_INLINE IfxSmmRst_WarmRstTrigger IfxSmmRst_readHighestWarmResetTrigger(void)
{
    uint8                    index;
    Ifx_SMM_WRMRSTTRIGH      wrmRstTrigH;
    IfxSmmRst_WarmRstTrigger highestResetTrigger = IfxSmmRst_WarmRstTrigger_undefined;

    wrmRstTrigH.U = SMM_WRMRSTTRIGH.U;

    for (index = 0; index < 32; index++)
    {
        if (wrmRstTrigH.U & (1 << index))
        {
            highestResetTrigger = (IfxSmmRst_WarmRstTrigger)index;
            break;
        }
    }

    return highestResetTrigger;
}


IFX_INLINE void IfxSmmRst_setEsrTriggerEdge(IfxSmmRst_ExternalServiceRequest esr, IfxSmmRst_EdgeTrigger edge)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

    switch (esr)
    {
    case IfxSmmRst_ExternalServiceRequest_esr0:
        SMM_ESRCFG0.B.EDCON = edge;
        break;
    case IfxSmmRst_ExternalServiceRequest_esr1:
        SMM_ESRCFG1.B.EDCON = edge;
        break;
    case IfxSmmRst_ExternalServiceRequest_esr2:
        SMM_ESRCFG2.B.EDCON = edge;
        break;
    default:
        /* Invalid external service request selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmmRst_useEsrDigitalFilter(IfxSmmRst_ExternalServiceRequest esr, IfxSmmRst_EsrDigitalFilter enableEsrFilter)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

    switch (esr)
    {
    case IfxSmmRst_ExternalServiceRequest_esr0:
        SMM_ESRCFG0.B.DFEN = enableEsrFilter;
        break;
    case IfxSmmRst_ExternalServiceRequest_esr1:
        SMM_ESRCFG1.B.DFEN = enableEsrFilter;
        break;
    case IfxSmmRst_ExternalServiceRequest_esr2:
        SMM_ESRCFG2.B.DFEN = enableEsrFilter;
        break;
    default:
        /* Invalid external service request selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmmRst_clearAllResetRegisters(void)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_config);
#endif

    SMM_RSTSTATCLR.B.CLRSMUIRF = 1u;
    SMM_RSTSTATCLR.B.CLRC      = 1u;
    PMS_CLDRSTSTATCLR.B.CLEAR  = 1u;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmmRst_triggerReset(const IfxSmmRst_TriggerRstCfgType rstCfgType)
{
    uint32 index;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
    SMM_RSTTRIGCTRLA.B.SW   = rstCfgType;
    SMM_SWRSTCON.B.SWRSTREQ = 1u;

    /* Add some delay for HW to reset */
    for (index = 0U; index < (uint32)IFXSMMRST_PERFORM_RESET_DELAY; index++)
    {}

    /* Setting the PROT state back to RUN is not needed, as the micro would RESET */
}


IFX_INLINE void IfxSmmRst_triggerColdPowerOnReset(void)
{
    uint32 index;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_PMS.PROTE, IfxApProt_State_config);
#endif
    PMS_CLDRSTCON.B.CPTRIG = 0xA5;

    /* Add some delay for HW to reset */
    for (index = 0U; index < (uint32)IFXSMMRST_PERFORM_RESET_DELAY; index++)
    {}

    /* Setting the PROT state back to RUN is not needed, as the micro would RESET */
}


IFX_INLINE void IfxSmmRst_setEsrPinMode(IfxSmmRst_ExternalServiceRequest esr, IfxSmm_PortMode mode)
{
    uint32 mask = 0u;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

    switch (esr)
    {
    case IfxSmmRst_ExternalServiceRequest_esr0:
        mask             = ((IFX_SMM_DRVCFGESR0_MODE_MSK << IFX_SMM_DRVCFGESR0_MODE_OFF) | (IFX_SMM_DRVCFGESR0_OD_MSK << IFX_SMM_DRVCFGESR0_OD_OFF) | (IFX_SMM_DRVCFGESR0_DIR_MSK << IFX_SMM_DRVCFGESR0_DIR_OFF));
        SMM_DRVCFGESR0.U = ((SMM_DRVCFGESR0.U & ~mask) | mode);
        break;
    case IfxSmmRst_ExternalServiceRequest_esr1:
        mask             = ((IFX_SMM_DRVCFGESR1_MODE_MSK << IFX_SMM_DRVCFGESR1_MODE_OFF) | (IFX_SMM_DRVCFGESR1_OD_MSK << IFX_SMM_DRVCFGESR1_OD_OFF) | (IFX_SMM_DRVCFGESR1_DIR_MSK << IFX_SMM_DRVCFGESR1_DIR_OFF));
        SMM_DRVCFGESR1.U = ((SMM_DRVCFGESR1.U & ~mask) | mode);
        break;
    case IfxSmmRst_ExternalServiceRequest_esr2:
        break;
    default:
        /*Invalid ESR selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


IFX_INLINE void IfxSmmRst_configureSecureSmuRstTrigger(const IfxSmmRst_TriggerRstCfgType rstCfgType)
{
    Ifx_SMM_RSTTRIGCTRLC Rstconc;
    Rstconc.U        = SMM_RSTTRIGCTRLC.U;

    Rstconc.B.SMUSEC = rstCfgType;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_config);
#endif
    SMM_RSTTRIGCTRLC.U = Rstconc.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTCE, IfxApProt_State_run);
#endif
}


#endif /* IFXSMMRST_H */
