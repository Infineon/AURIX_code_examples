/**
 * \file IfxCan.c
 * \brief CAN  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxCan.h"
#include "IfxCan_bf.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint32 IfxCan_Node_getDataLength(IfxCan_DataLengthCode dataLengthCode)
{
    uint32 numBytes;

    if (dataLengthCode <= IfxCan_DataLengthCode_8)
    {
        numBytes = (uint32)dataLengthCode;
    }
    else if (dataLengthCode <= IfxCan_DataLengthCode_24)
    {
        numBytes = ((uint32)dataLengthCode - 6) << 2;
    }
    else
    {
        numBytes = ((uint32)dataLengthCode - 11) << 4;
    }

    return (numBytes + 3) >> 2;
}


uint32 IfxCan_Node_getDataLengthFromCode(Ifx_CAN_N *node, IfxCan_DataLengthCode dataLengthCode)
{
    uint32 numBytes;
    IFX_UNUSED_PARAMETER(node);

    if ((dataLengthCode <= IfxCan_DataLengthCode_64) && (dataLengthCode > IfxCan_DataLengthCode_24))
    {
        numBytes = ((uint32)dataLengthCode - 11) * 16;
    }
    else if ((dataLengthCode <= IfxCan_DataLengthCode_24) && (dataLengthCode > IfxCan_DataLengthCode_8))
    {
        numBytes = ((uint32)dataLengthCode - 6) * 4;
    }
    else
    {
        numBytes = (uint32)dataLengthCode;
    }

    return (numBytes + 3) / 4;
}


IfxCan_FrameMode IfxCan_Node_getFrameMode(Ifx_CAN_RXMSG *rxBufferElement)
{
    IfxCan_FrameMode frameMode;

    /* if CAN FD long frame is been selected */
    if (rxBufferElement->R1A.B.FDF)
    {
        /* if bitrate switch is been set */
        if (rxBufferElement->R1A.B.BRS)
        {
            frameMode = IfxCan_FrameMode_fdLongAndFast;
        }
        /* if bitrate switch is not been set */
        else
        {
            frameMode = IfxCan_FrameMode_fdLong;
        }
    }
    /* if CAN FD long frame is not been selected */
    else
    {
        frameMode = IfxCan_FrameMode_standard;
    }

    return frameMode;
}


boolean IfxCan_Node_initRxPin(Ifx_CAN_N *node, IfxCan_Rxd_In *rxd, IfxPort_InputMode mode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeInput(rxd->pin.port, rxd->pin.pinIndex, mode);
    IfxPort_setPinPadDriver(rxd->pin.port, rxd->pin.pinIndex, padDriver);
    node->PORTCTRL.B.RXSEL = rxd->select;

    return TRUE;
}


boolean IfxCan_Node_initTxPin(IfxCan_Txd_Out *txd, IfxPort_OutputMode mode, IfxPort_PadDriver padDriver)
{
    IfxPort_setPinModeOutput(txd->pin.port, txd->pin.pinIndex, mode, txd->select);
    IfxPort_setPinPadDriver(txd->pin.port, txd->pin.pinIndex, padDriver);

    return TRUE;
}


void IfxCan_Node_setBitTiming(Ifx_CAN_N *node, uint32 moduleFreq, uint32 baudrate, uint16 samplePoint, uint16 syncJumpWidth)
{
    sint32  maxBRP   = IFX_CAN_N_NBTP_NBRP_MSK + 1;
    sint32  minBRP   = 1;
    sint32  maxTSEG1 = IFX_CAN_N_NBTP_NTSEG1_MSK + 1;
    sint32  minTSEG1 = 3;
    sint32  maxTSEG2 = IFX_CAN_N_NBTP_NTSEG2_MSK + 1;
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = 0;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 1, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
    float32 bestError = 0;

    /*
     * Bit timing & sampling
     * Tq = (BRP+1)/Fcan if DIV8 = 0
     * Tq = 8*(BRP+1)/Fcan if DIV8 = 1
     * TSync = 1.Tq
     * TSeg1 = (TSEG1+1)*Tq                >= 3Tq
     * TSeg2 = (TSEG2+1)*Tq                >= 2Tq
     * Bit Time = TSync + TSeg1 + TSeg2    >= 8Tq
     *
     * Resynchronization:
     *
     * Tsjw = (SJW + 1)*Tq
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = (float32)baudrate;
    maxTBAUD  = maxTSEG1 + maxTSEG2 + 1;

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = (float32)moduleFreq / tempBRP;
        tempTBAUD = Fquanta / baudrate;

        if (tempTBAUD == 0)
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
            {
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
    {
        bestBRP   = maxBRP;
        bestTBAUD = maxTBAUD;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
    {
        bestBRP   = minBRP;
        bestTBAUD = minTBAUD;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.25f; /* 25% tolerance in sample point as max error */

    if (bestTBAUD < maxTSEG1)
    {
        maxTSEG1 = bestTBAUD;
    }

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > error)
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
        {
            /*least possible error */
            break;  /* least possible error has already occured */
        }
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
    {
        bestTSEG2 = minTSEG2;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSyncJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error             = __abs(tempSyncJumpWidth - syncJumpWidth);

        if (bestError > error)
        {
            bestSJW   = tempSJW;
            bestError = (float)error;
        }
    }

    {
        node->NBTP.B.NBRP   = bestBRP - 1;
        node->NBTP.B.NSJW   = bestSJW - 1;
        node->NBTP.B.NTSEG1 = bestTSEG1 - 1;
        node->NBTP.B.NTSEG2 = bestTSEG2 - 1;
    }
}


void IfxCan_Node_setBitTimingValues(Ifx_CAN_N *node, uint16 syncJumpWidth, uint8 timeSegment2, uint8 timeSegment1, uint16 prescaler)
{
    Ifx_CAN_N_NBTP nbtp;
    nbtp.U        = node->NBTP.U;
    nbtp.B.NSJW   = syncJumpWidth;
    nbtp.B.NTSEG1 = timeSegment1;
    nbtp.B.NTSEG2 = timeSegment2;
    nbtp.B.NBRP   = prescaler;

    node->NBTP.U  = nbtp.U;
}


void IfxCan_Node_setFastBitTiming(Ifx_CAN_N *node, uint32 moduleFreq, uint32 baudrate, uint16 samplePoint, uint16 syncJumpWidth)
{
    sint32  maxBRP   = IFX_CAN_N_DBTP_DBRP_MSK + 1;
    sint32  minBRP   = 1;
    sint32  maxTSEG1 = IFX_CAN_N_DBTP_DTSEG1_MSK + 1;
    sint32  minTSEG1 = 3;
    sint32  maxTSEG2 = IFX_CAN_N_DBTP_DTSEG2_MSK + 1;
    sint32  minTSEG2 = 2;
    sint32  maxTBAUD = 0;
    sint32  minTBAUD = 8;

    sint32  tempBRP, tempSJW, tempTSEG1, tempTBAUD;
    sint32  bestBRP   = 1, bestSJW = 1, bestTBAUD = 8, bestTSEG1 = 3, bestTSEG2 = 2;
    float32 bestError = 0;

    /*
     * Bit timing & sampling
     * Tq = (BRP+1)/Fcan if DIV8 = 0
     * Tq = 8*(BRP+1)/Fcan if DIV8 = 1
     * TSync = 1.Tq
     * TSeg1 = (TSEG1+1)*Tq                >= 3Tq
     * TSeg2 = (TSEG2+1)*Tq                >= 2Tq
     * Bit Time = TSync + TSeg1 + TSeg2    >= 8Tq
     *
     * Resynchronization:
     *
     * Tsjw = (SJW + 1)*Tq
     * TSeg1 >= Tsjw + Tprop
     * TSeg2 >= Tsjw
     */

    /* search for best baudrate */
    bestError = (float32)baudrate;
    maxTBAUD  = maxTSEG1 + maxTSEG2 + 1;

    for (tempBRP = 1; tempBRP <= maxBRP; tempBRP++)
    {
        float32 Fquanta = (float32)moduleFreq / tempBRP;
        tempTBAUD = Fquanta / baudrate;

        if (tempTBAUD == 0)
        {
            break; /* to avoid division by 0 */
        }

        float32 tempBaudrate = Fquanta / tempTBAUD;
        float32 error        = __absf(tempBaudrate - baudrate);

        if (tempTBAUD < minTBAUD)
        {
            break;  /* below the minimum allowed limits, break is required otherwise TSEG1 and TSEG2 may result in negitive values */
        }

        if ((tempTBAUD <= maxTBAUD) && (bestError >= error))
        {
            bestBRP   = tempBRP;
            bestTBAUD = tempTBAUD;
            bestError = error;

            if ((tempTBAUD <= 20) && (error < 0.1f))
            {
                break;      /* optimal condition */
            }
        }
    }

    if ((bestBRP == 0) && (tempBRP == (maxBRP + 1)))
    {
        bestBRP   = maxBRP;
        bestTBAUD = maxTBAUD;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if ((bestBRP == 0) && (tempTBAUD < minTBAUD))
    {
        bestBRP   = minBRP;
        bestTBAUD = minTBAUD;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best sample point */
    bestError = samplePoint * 0.25f; /* 25% tolerance in sample point as max error */

    if (bestTBAUD < maxTSEG1)
    {
        maxTSEG1 = bestTBAUD;
    }

    bestTSEG1 = maxTSEG1;

    for (tempTSEG1 = maxTSEG1; tempTSEG1 >= minTSEG1; tempTSEG1--)
    {
        sint32 tempSamplePoint = ((tempTSEG1 + 1) * 10000) / bestTBAUD;
        sint32 error           = __abs(tempSamplePoint - samplePoint);

        if (bestError > error)
        {
            bestTSEG1 = tempTSEG1;
            bestError = (float)error;
        }

        if (tempSamplePoint < samplePoint)
        {
            break;  /* least possible error has already occured */
        }
    }

    bestTSEG2 = bestTBAUD - bestTSEG1 - 1;

    if (bestTSEG2 > maxTSEG2)
    {
        bestTSEG2 = maxTSEG2;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    if (bestTSEG2 < minTSEG2)
    {
        bestTSEG2 = minTSEG2;

        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* search for best SJW */
    bestError = 10000;

    for (tempSJW = 1; tempSJW <= bestTSEG2; tempSJW++)
    {
        sint32 tempSyncJumpWidth = (tempSJW * 10000) / bestTBAUD;
        sint32 error             = __abs(tempSyncJumpWidth - syncJumpWidth);

        if (bestError > error)
        {
            bestSJW   = tempSJW;
            bestError = (float)error;
        }
    }

    {
        node->DBTP.B.DBRP   = bestBRP - 1;
        node->DBTP.B.DSJW   = bestSJW - 1;
        node->DBTP.B.DTSEG1 = bestTSEG1 - 1;
        node->DBTP.B.DTSEG2 = bestTSEG2 - 1;
    }
}


void IfxCan_Node_setFastBitTimingValues(Ifx_CAN_N *node, uint16 syncJumpWidth, uint8 timeSegment2, uint8 timeSegment1, uint16 prescaler)
{
    Ifx_CAN_N_DBTP dbtp;
    dbtp.U        = node->DBTP.U;
    dbtp.B.DSJW   = syncJumpWidth;
    dbtp.B.DTSEG1 = timeSegment1;
    dbtp.B.DTSEG2 = timeSegment2;
    dbtp.B.DBRP   = prescaler;

    node->DBTP.U  = dbtp.U;
}


void IfxCan_Node_setFrameMode(Ifx_CAN_N *node, IfxCan_FrameMode frameMode)
{
    switch (frameMode)
    {
    case IfxCan_FrameMode_standard:
        node->CCCR.B.FDOE = 0;
        node->CCCR.B.BRSE = 0;
        break;
    case IfxCan_FrameMode_fdLong:
        node->CCCR.B.FDOE = 1;
        node->CCCR.B.BRSE = 0;
        break;
    case IfxCan_FrameMode_fdLongAndFast:
        node->CCCR.B.FDOE = 1;
        node->CCCR.B.BRSE = 1;
        break;
    }
}


void IfxCan_Node_setFrameModeReq(Ifx_CAN_TXMSG *txBufferElement, IfxCan_FrameMode frameMode)
{
    switch (frameMode)
    {
    case IfxCan_FrameMode_standard:
        txBufferElement->T1.B.FDF = 0;
        txBufferElement->T1.B.BRS = 0;
        break;
    case IfxCan_FrameMode_fdLong:
        txBufferElement->T1.B.FDF = 1;
        txBufferElement->T1.B.BRS = 0;
        break;
    case IfxCan_FrameMode_fdLongAndFast:
        txBufferElement->T1.B.FDF = 1;
        txBufferElement->T1.B.BRS = 1;
        break;
    }
}


void IfxCan_Node_setFrameModeRequest(Ifx_CAN_N *node, Ifx_CAN_TXMSG *txBufferElement, IfxCan_FrameMode frameMode)
{
    IFX_UNUSED_PARAMETER(node);

    switch (frameMode)
    {
    case IfxCan_FrameMode_standard:
        txBufferElement->T1.B.FDF = 0;
        txBufferElement->T1.B.BRS = 0;
        break;
    case IfxCan_FrameMode_fdLong:
        txBufferElement->T1.B.FDF = 1;
        txBufferElement->T1.B.BRS = 0;
        break;
    case IfxCan_FrameMode_fdLongAndFast:
        txBufferElement->T1.B.FDF = 1;
        txBufferElement->T1.B.BRS = 1;
        break;
    }
}


uint32 IfxCan_Node_getDataLengthInBytes(IfxCan_DataLengthCode dataLengthCode)
{
    uint32 numBytes;

    if (dataLengthCode <= IfxCan_DataLengthCode_8)
    {
        numBytes = (uint32)dataLengthCode;
    }
    else if (dataLengthCode <= IfxCan_DataLengthCode_24)
    {
        numBytes = ((uint32)dataLengthCode - 6) << 2;
    }
    else
    {
        numBytes = ((uint32)dataLengthCode - 11) << 4;
    }

    return numBytes;
}


uint8 IfxCan_Node_getTxBufferDataFieldSize(Ifx_CAN_N *node)
{
    IfxCan_DataFieldSize sizeCode = (IfxCan_DataFieldSize)node->TX.ESC.B.TBDS;

    uint8                size;

    if (sizeCode < IfxCan_DataFieldSize_32)
    {
        size = ((uint8)sizeCode + 2) * 4;
    }
    else
    {
        size = ((uint8)sizeCode - 3) * 16;
    }

    return size;
}


Ifx_CAN_TXMSG *IfxCan_Node_getTxBufferElementAddress(Ifx_CAN_N *node, uint32 ramBaseAddress, uint16 txBuffersStartAddress, IfxCan_TxBufferId txBufferNumber)
{
    uint16 txBufferIndex, txBufferSize, numOfDataBytes, numOfConfigBytes = 8;

    numOfDataBytes = IfxCan_Node_getTxBufferDataFieldSize(node);
    txBufferSize   = numOfConfigBytes + numOfDataBytes;
    txBufferIndex  = txBufferSize * ((uint16)txBufferNumber);

    uint32 txBufferElementAddress = ramBaseAddress + txBuffersStartAddress + txBufferIndex;
    return (Ifx_CAN_TXMSG *)txBufferElementAddress;
}


void IfxCan_Node_writeTxBufData(Ifx_CAN_TXMSG *txBufferElement, IfxCan_DataLengthCode dataLengthCode, uint32 *data)
{
    uint32  i;

    uint32 *destinationAddress = (uint32 *)txBufferElement + 2;
    /* get number of data bytes from data length code (DLC) */
    uint32  length             = IfxCan_Node_getDataLength(dataLengthCode);

    /* write data into the data section of Tx Buffer element  */
    for (i = 0; i < length; i++)
    {
        destinationAddress[i] = data[i];
    }
}


void IfxCan_Node_writeData(Ifx_CAN_N *node, Ifx_CAN_TXMSG *txBufferElement, IfxCan_DataLengthCode dataLengthCode, uint32 *data)
{
    IFX_UNUSED_PARAMETER(node);
    uint32  i;

    uint32 *destinationAddress = (uint32 *)txBufferElement + 2;
    /* get number of data bytes from data length code (DLC) */
    uint32  length             = IfxCan_Node_getDataLength(dataLengthCode);

    /* write data into the data section of Tx Buffer element  */
    for (i = 0; i < length; i++)
    {
        destinationAddress[i] = data[i];
    }
}


void IfxCan_Node_clearRxBufferNewDataFlag(Ifx_CAN_N *node, IfxCan_RxBufferId rxBufferId)
{
    uint32 value;

    if (rxBufferId < IfxCan_RxBufferId_32)
    {
        value         = (1U << rxBufferId);
        node->NDAT1.U = value;
    }
    else
    {
        value         = (1U << (rxBufferId - 32));
        node->NDAT2.U = value;
    }
}


uint8 IfxCan_Node_getRxBufferDataFieldSize(Ifx_CAN_N *node)
{
    IfxCan_DataFieldSize sizeCode = (IfxCan_DataFieldSize)node->RX.ESC.B.RBDS;

    uint8                size;

    if (sizeCode < IfxCan_DataFieldSize_32)
    {
        size = ((uint8)sizeCode + 2) * 4;
    }
    else
    {
        size = ((uint8)sizeCode - 3) * 16;
    }

    return size;
}


Ifx_CAN_RXMSG *IfxCan_Node_getRxBufferElementAddress(Ifx_CAN_N *node, uint32 ramBaseAddress, uint16 rxBuffersStartAddress, IfxCan_RxBufferId rxBufferNumber)
{
    uint16 rxBufferIndex, rxBufferSize, numOfDataBytes, numOfconfigBytes = 8;

    numOfDataBytes = IfxCan_Node_getRxBufferDataFieldSize(node);
    rxBufferSize   = numOfconfigBytes + numOfDataBytes;
    rxBufferIndex  = rxBufferSize * ((uint16)rxBufferNumber);
    uint32 rxBufferElementAddress = ramBaseAddress + rxBuffersStartAddress + rxBufferIndex;

    return (Ifx_CAN_RXMSG *)rxBufferElementAddress;
}


uint8 IfxCan_Node_getRxFifo0DataFieldSize(Ifx_CAN_N *node)
{
    IfxCan_DataFieldSize sizeCode = (IfxCan_DataFieldSize)node->RX.ESC.B.F0DS;

    uint8                size;

    if (sizeCode < IfxCan_DataFieldSize_32)
    {
        size = ((uint8)sizeCode + 2) * 4;
    }
    else
    {
        size = ((uint8)sizeCode - 3) * 16;
    }

    return size;
}


Ifx_CAN_RXMSG *IfxCan_Node_getRxFifo0ElementAddress(Ifx_CAN_N *node, uint32 ramBaseAddress, uint16 rxFifo0StartAddress, IfxCan_RxBufferId rxBufferNumber)
{
    uint16 rxFifoElementIndex, rxFifoElementSize, numOfDataBytes, numOfconfigBytes = 8;

    numOfDataBytes     = IfxCan_Node_getRxFifo0DataFieldSize(node);
    rxFifoElementSize  = numOfconfigBytes + numOfDataBytes;
    rxFifoElementIndex = rxFifoElementSize * ((uint16)rxBufferNumber);
    uint32 rxFifoElementAddress = ramBaseAddress + rxFifo0StartAddress + rxFifoElementIndex;

    return (Ifx_CAN_RXMSG *)rxFifoElementAddress;
}


uint8 IfxCan_Node_getRxFifo1DataFieldSize(Ifx_CAN_N *node)
{
    IfxCan_DataFieldSize sizeCode = (IfxCan_DataFieldSize)node->RX.ESC.B.F1DS;

    uint8                size;

    if (sizeCode < IfxCan_DataFieldSize_32)
    {
        size = ((uint8)sizeCode + 2) * 4;
    }
    else
    {
        size = ((uint8)sizeCode - 3) * 16;
    }

    return size;
}


Ifx_CAN_RXMSG *IfxCan_Node_getRxFifo1ElementAddress(Ifx_CAN_N *node, uint32 ramBaseAddress, uint16 rxFifo1StartAddress, IfxCan_RxBufferId rxBufferNumber)
{
    uint16 rxFifoElementIndex, rxFifoElementSize, numOfDataBytes, numOfconfigBytes = 8;

    numOfDataBytes     = IfxCan_Node_getRxFifo1DataFieldSize(node);
    rxFifoElementSize  = numOfconfigBytes + numOfDataBytes;
    rxFifoElementIndex = rxFifoElementSize * ((uint16)rxBufferNumber);
    uint32 rxFifoElementAddress = ramBaseAddress + rxFifo1StartAddress + rxFifoElementIndex;

    return (Ifx_CAN_RXMSG *)rxFifoElementAddress;
}


boolean IfxCan_Node_isRxBufferNewDataUpdated(Ifx_CAN_N *node, IfxCan_RxBufferId rxBufferId)
{
    uint32  mask;
    boolean tempVar;

    if (rxBufferId < IfxCan_RxBufferId_32)
    {
        mask    = (1U << rxBufferId);
        tempVar = (boolean)((node->NDAT1.U & mask) != 0 ? 1 : 0);
        return tempVar;
    }
    else
    {
        mask    = (1U << (rxBufferId - 32));
        tempVar = (boolean)((node->NDAT2.U & mask) != 0 ? 1 : 0);
        return tempVar;
    }
}


void IfxCan_Node_readData(Ifx_CAN_RXMSG *rxBufferElement, IfxCan_DataLengthCode dataLengthCode, uint32 *data)
{
    uint32  i;
    uint32 *destinationAddress = (uint32 *)rxBufferElement + 2;
    /* get number of data bytes from data length code (DLC) */
    uint32  length             = IfxCan_Node_getDataLength(dataLengthCode);

    /* read data from the data section of Rx Buffer element  */
    for (i = 0; i < length; i++)
    {
        data[i] = destinationAddress[i];
    }
}


Ifx_CAN_EXTMSG *IfxCan_Node_getExtendedFilterElementAddress(uint32 ramBaseAddress, uint16 extendedFilterListStartAddress, uint8 filterNumber)
{
    uint32 extendedFilterElementAddress, filterIndex;

    filterIndex                  = filterNumber * 8;
    extendedFilterElementAddress = ramBaseAddress + extendedFilterListStartAddress + filterIndex;

    return (Ifx_CAN_EXTMSG *)extendedFilterElementAddress;
}


Ifx_CAN_STDMSG *IfxCan_Node_getStandardFilterElementAddress(uint32 ramBaseAddress, uint16 standardFilterListStartAddress, uint8 filterNumber)
{
    uint32 standardFilterElementAddress, filterIndex;

    filterIndex                  = filterNumber * 4;
    standardFilterElementAddress = ramBaseAddress + standardFilterListStartAddress + filterIndex;

    return (Ifx_CAN_STDMSG *)standardFilterElementAddress;
}


void IfxCan_Node_setGroupInterruptLine(Ifx_CAN_N *node, IfxCan_InterruptGroup interruptGroup, IfxCan_InterruptLine interruptLine)
{
    if (interruptGroup <= IfxCan_InterruptGroup_loi)
    {
        node->G0INTR.U |= (interruptLine) << (interruptGroup * 4);
    }
    else if (interruptGroup <= IfxCan_InterruptGroup_traco)
    {
        node->G1INTR.U |= (interruptLine) << ((interruptGroup % 8) * 4);
    }
    else
    {
        node->G2INTR.U |= (interruptLine) << ((interruptGroup % 8) * 4);
    }
}


void IfxCan_Node_setInterruptLine(Ifx_CAN_N *node, IfxCan_Interrupt interrupt, IfxCan_InterruptLine interruptLine)
{
    switch (interrupt)
    {
    case IfxCan_Interrupt_rxFifo0NewMessage:
        node->G1INTR.B.RXF0N = interruptLine;
        break;
    case IfxCan_Interrupt_rxFifo0WatermarkReached:
    case IfxCan_Interrupt_rxFifo1WatermarkReached:
    case IfxCan_Interrupt_txEventFifoWatermarkReached:
        node->G0INTR.B.WATI = interruptLine;
        break;
    case IfxCan_Interrupt_rxFifo0Full:
        node->G1INTR.B.RXF0F = interruptLine;
        break;
    case IfxCan_Interrupt_rxFifo0MessageLost:
    case IfxCan_Interrupt_rxFifo1MessageLost:
    case IfxCan_Interrupt_txEventFifoEventLost:
    case IfxCan_Interrupt_timestampWraparound:
    case IfxCan_Interrupt_errorPassive:
    case IfxCan_Interrupt_warningStatus:
        node->G0INTR.B.ALRT = interruptLine;
        break;
    case IfxCan_Interrupt_rxFifo1NewMessage:
        node->G1INTR.B.RXF1N = interruptLine;
        break;
    case IfxCan_Interrupt_rxFifo1Full:
        node->G1INTR.B.RXF1F = interruptLine;
        break;
    case IfxCan_Interrupt_highPriorityMessage:
        node->G0INTR.B.HPE = interruptLine;
        break;
    case IfxCan_Interrupt_transmissionCompleted:
    case IfxCan_Interrupt_transmissionCancellationFinished:
        node->G1INTR.B.TRACO = interruptLine;
        break;
    case IfxCan_Interrupt_txFifoEmpty:
        node->G1INTR.B.TRAQ = interruptLine;
        break;
    case IfxCan_Interrupt_txEventFifoNewEntry:
    case IfxCan_Interrupt_txEventFifoFull:
        node->G0INTR.B.TEFIFO = interruptLine;
        break;
    case IfxCan_Interrupt_messageRAMAccessFailure:
    case IfxCan_Interrupt_watchdog:
        node->G0INTR.B.MOER = interruptLine;
        break;
    case IfxCan_Interrupt_timeoutOccurred:
        node->G1INTR.B.RETI = interruptLine;
        break;
    case IfxCan_Interrupt_messageStoredToDedicatedRxBuffer:
        node->G1INTR.B.REINT = interruptLine;
        break;
    case IfxCan_Interrupt_errorLoggingOverflow:
        node->G0INTR.B.SAFE = interruptLine;
        break;
    case IfxCan_Interrupt_busOffStatus:
        node->G0INTR.B.BOFF = interruptLine;
        break;
    case IfxCan_Interrupt_protocolErrorArbitration:
    case IfxCan_Interrupt_protocolErrorData:
        node->G0INTR.B.LOI = interruptLine;
        break;
    case IfxCan_Interrupt_creRxBuffer0:
        node->G2INTR.B.RXHBUF0 = interruptLine;
        break;
    case IfxCan_Interrupt_creRxBuffer1:
        node->G2INTR.B.RXHBUF1 = interruptLine;
        break;
    case IfxCan_Interrupt_creTxBuffer0:
        node->G2INTR.B.TXHBUF0 = interruptLine;
        break;
    case IfxCan_Interrupt_creTxBuffer1:
        node->G2INTR.B.TXHBUF1 = interruptLine;
        break;
    case IfxCan_Interrupt_creIdmuStdFrameRateMeasurementLost:
    case IfxCan_Interrupt_creIdmuXtdFrameRateMeasurementLost:
        node->G2INTR.B.IDMU = interruptLine;
        break;
    case IfxCan_Interrupt_creError:
        node->G2INTR.B.CEI = interruptLine;
        break;
    default:
        break;
    }
}


void IfxCan_disableModule(Ifx_CAN *can)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(can->PROTE), IfxApProt_State_config);
#endif

    /*Disable module */
    can->CLC.B.DISR = 1U;

    /*Wait until module is disabled*/
    while (IfxCan_isModuleEnabled(can) == TRUE)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(can->PROTE), IfxApProt_State_run);
#endif
}


void IfxCan_enableModule(Ifx_CAN *can)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(can->PROTE), IfxApProt_State_config);
#endif

    /*Enable module, disregard Sleep Mode request */
    can->CLC.B.DISR = 0U;

    /*Wait until module is enabled*/
    while (IfxCan_isModuleEnabled(can) == FALSE)
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(can->PROTE), IfxApProt_State_run);
#endif
}


Ifx_CAN *IfxCan_getAddress(IfxCan_Index can)
{
    Ifx_CAN *module;

    if (can < IFXCAN_NUM_MODULES)
    {
        module = (Ifx_CAN *)IfxCan_cfg_indexMap[can].module;
    }
    else
    {
        module = NULL_PTR;
    }

    return module;
}


IfxCan_Index IfxCan_getIndex(Ifx_CAN *can)
{
    uint32       index;
    IfxCan_Index result;

    result = IfxCan_Index_none;

    for (index = 0; index < IFXCAN_NUM_MODULES; index++)
    {
        if (IfxCan_cfg_indexMap[index].module == can)
        {
            result = (IfxCan_Index)IfxCan_cfg_indexMap[index].index;
            break;
        }
    }

    return result;
}


uint32 IfxCan_getModuleFrequency(void)
{
    uint32 moduleFreq = 0;

    moduleFreq = IfxClock_getMcanFrequency();

    return moduleFreq;
}


void IfxCan_resetModule(Ifx_CAN *can)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(can->PROTE), IfxApProt_State_config);
#endif

    can->RST.CTRLA.B.KRST = 1;          /* Only if both Kernel reset bits are set a reset is executed */
    can->RST.CTRLB.B.KRST = 1;

    while (can->RST.STAT.B.KRST == 0)   /* Wait until reset is executed */
    {}

    can->RST.CTRLB.B.STATCLR = 1;       /* Clear Kernel reset status bit */

    while (can->RST.STAT.B.KRST == 1)   /* Wait until KRST is cleared, only after this reset sequence is completed */
    {}

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(can->PROTE), IfxApProt_State_run);
#endif
}


void IfxCan_setClockSource(Ifx_CAN *can, IfxCan_ClockSelect clockSelect, IfxCan_ClockSource clockSource)
{
    Ifx_CAN_MCR mcr;

    /* enable CCCE and CI */
    mcr.U      = can->MCR.U;
    mcr.B.CCCE = 1;
    mcr.B.CI   = 1;
    can->MCR.U = mcr.U;

    /* select clock */
    switch (clockSelect)
    {
    case IfxCan_ClockSelect_0:
        mcr.B.CLKSEL0 = clockSource;
        break;
    case IfxCan_ClockSelect_1:
        mcr.B.CLKSEL1 = clockSource;
        break;
    case IfxCan_ClockSelect_2:
        mcr.B.CLKSEL2 = clockSource;
        break;
    case IfxCan_ClockSelect_3:
        mcr.B.CLKSEL3 = clockSource;
        break;
    }

    can->MCR.U = mcr.U;

    /* disable CCCE and CI */
    mcr.B.CCCE = 0;
    mcr.B.CI   = 0;
    can->MCR.U = mcr.U;
}


Ifx_CAN_SRT *IfxCan_Node_getStandardRoutingElementAddress(uint32 ramBaseAddress, uint16 standardRoutingTableStartAddress, uint8 index)
{
    uint32 standardRoutingElementAddress = ramBaseAddress + standardRoutingTableStartAddress + (index * 4);

    return (Ifx_CAN_SRT *)standardRoutingElementAddress;
}


Ifx_CAN_XRT *IfxCan_Node_getExtendedRoutingElementAddress(uint32 ramBaseAddress, uint16 extendedRoutingTableStartAddress, uint8 index)
{
    uint32 extendedRoutingElementAddress = ramBaseAddress + extendedRoutingTableStartAddress + (index * 4);

    return (Ifx_CAN_XRT *)extendedRoutingElementAddress;
}


void IfxCan_ramInit(Ifx_CAN *can)
{
    Ifx_CAN_MCR mcr;

    /* enable CCCE and CI */
    mcr.U      = can->MCR.U;
    mcr.B.CCCE = 1;
    mcr.B.CI   = 1;
    can->MCR.U = mcr.U;

    while (can->MCR.B.RBUSY)
    {}

    can->MCR.B.RINIT = 0;       /*0 to 1 transition is needed*/
    can->MCR.B.RINIT = 1;       /*Clear RAM block*/
    uint32 mcr2 = can->MCR.U;   /*Dummy read required as per programming sequence*/

    IFX_UNUSED_PARAMETER(mcr2); /* Warning fix for LLVM Compiler */

    while (can->MCR.B.RBUSY)
    {}

    can->MCR.B.RINIT = 0;

    /* disable CCCE and CI */
    mcr.B.CCCE = 0;
    mcr.B.CI   = 0;
    can->MCR.U = mcr.U;
}


IfxCan_FrameMode IfxCan_Node_getFrameModeFromTxEventFifo(Ifx_CAN_TXEVENT *txEventFifoElement)
{
    IfxCan_FrameMode frameMode;

    /* if CAN FD long frame is been selected */
    if (txEventFifoElement->E1A.B.FDF)
    {
        /* if bitrate switch is been set */
        if (txEventFifoElement->E1A.B.BRS)
        {
            frameMode = IfxCan_FrameMode_fdLongAndFast;
        }
        /* if bitrate switch is not been set */
        else
        {
            frameMode = IfxCan_FrameMode_fdLong;
        }
    }
    /* if CAN FD long frame is not been selected */
    else
    {
        frameMode = IfxCan_FrameMode_standard;
    }

    return frameMode;
}


Ifx_CAN_TXEVENT *IfxCan_Node_getTxEventFifoElementAddress(uint32 ramBaseAddress, uint16 txEventFifoStartAddress, uint8 txEventFifoNumber)
{
    uint32 txEventFifoElementAddress, txEventFifoIndex;

    txEventFifoIndex          = txEventFifoNumber * 8;
    txEventFifoElementAddress = ramBaseAddress + txEventFifoStartAddress + txEventFifoIndex;

    return (Ifx_CAN_TXEVENT *)txEventFifoElementAddress;
}


volatile Ifx_SRC_SRCR *IfxCan_getSrcPointer(Ifx_CAN *can, IfxCan_InterruptLine interruptLine)
{
    IfxCan_Index       canIndex                              = IfxCan_getIndex(can);
    Ifx_SRC_CAN *const srcCanBaseAddress[IFXCAN_NUM_MODULES] = {
        &MODULE_SRC.CAN[0],
        &MODULE_SRC.CAN[1],
        &MODULE_SRC.CAN[2],
        &MODULE_SRC.CAN[3],
        &MODULE_SRC.CAN[4]
    };
    return &(srcCanBaseAddress[canIndex]->INT[interruptLine]);
}


void IfxCan_Node_setInternalTimeStamp(Ifx_CAN_N *node, IfxCan_IntTimerPrescalar prescalar)
{
    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(node);

    node->TSCC.B.TSS = IfxCan_TSCC_TSS_internal; //MCMCAN Internal 16-bit Time Stamp
    node->TSCC.B.TCP = prescalar;                //In CAN bit times. Valid values are 0x0 to 0xF
    node->TSCV.B.TSC = (uint16)0;                //A write will clear the counter, when TSS=0b01.
    /* disable configuration change CCCR.CCE = 0, CCCR.INIT = 0 */
    IfxCan_Node_disableConfigurationChange(node);
}


void IfxCan_Node_setTsccPrescalar(Ifx_CAN_N *node, IfxCan_IntTimerPrescalar prescalar)
{
    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(node);
    node->TSCC.B.TCP = prescalar; //In CAN bit times. Valid values are 0x0 to 0xF
    /* disable configuration change CCCR.CCE = 0, CCCR.INIT = 0 */
    IfxCan_Node_disableConfigurationChange(node);
}


void IfxCan_Node_tsuInit(Ifx_CAN_N *node, IfxCan_TsuConfig tsuConfig)
{
    node->TSU.TSCFG.B.TSUE = 1;                                 /*Enable TSU*/

/* Configure TSU Internal Node's Counter or TSU External Node 0 Counter
 * Node 0: Only Internal Counter Exists,
 * Nodes 1,2,3: Each can have Internal Counter or External Couunter.
 * If Configured to external counter they will be connected to Node 0's counter.
 * User must configure Node 0 TSU first before connecting Node 1,2 or 3 to Node 0's counter*/
    node->TSU.TSCFG.B.TBCS = tsuConfig.tsuCounterType;          /*Configure TSU Internal Node's Counter or TSU External Node 0 Counter*/

    if (tsuConfig.tsuCounterType == IfxCan_TsuCounter_internal) /*No prescalar H/w Support for External(Node 0's TSU) Counter*/
    {
        node->TSU.TSCFG.B.TBPRE = tsuConfig.prescalar;
    }

    node->TSU.TSCFG.B.SCP = tsuConfig.position; /*Capture Time Stamp at End of Frame*/
}


void IfxCan_Node_setTsuCounter(Ifx_CAN_N *node, IfxCan_TsuCounter counterType)
{
    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(node);

/* Node 0: Only Internal Counter Exists,
 * Nodes 1,2,3: Each can have Internal Counter and External Couunter.
 * If Configured to external counter they will be connected to Node 0's counter.
 * User must configure Node 0 TSU first before connecting Node 1,2 or 3 to Node 0's counter*/
    node->TSU.TSCFG.B.TBCS = counterType;

    /* disable configuration change CCCR.CCE = 0, CCCR.INIT = 0 */
    IfxCan_Node_disableConfigurationChange(node);
}


uint32 IfxCan_Cre_getInterArrivalMeasure(Ifx_CAN_RHBUF *rxHostBuffer)
{
    if (rxHostBuffer->THEAD_INTRD.B.IAMSTAT == IfxCan_InterArrivalMeasureStatus_available)
    {
        return rxHostBuffer->THEAD_INTRD.B.IAM;
    }

    else
    {
        return 0;
    }
}


uint32 IfxCan_Cre_waitAndGetValidIam(Ifx_CAN_RHBUF *rxHostBuffer)
{
    while (IfxCan_Cre_getIamStatus(rxHostBuffer) == IfxCan_InterArrivalMeasureStatus_unavailable)
    {}

    return rxHostBuffer->THEAD_INTRD.B.IAM;
}


uint16 IfxCan_Node_Cre_getStdGroupXFrameRate(Ifx_CAN_N *node, IfxCan_StdFrameGroupId id, uint32 ramAddress, boolean clearEnable)
{
    uint32  frameTableAddress = (uint32)IfxCan_Node_Cre_getStdFrameRateAddress(node, ramAddress);

    uint32  wordIndex         = id / 2; /*2 Elements are stored per word*/
    uint32 *frameratepairptr  = (uint32 *)(frameTableAddress + (wordIndex * 4));

    uint32  frameratepair     = (uint32)(*frameratepairptr);

    uint16  frameRate         = 0;

    if (id % 2)
    {
        frameRate = (uint16)(frameratepair >> 16); /*Higher Element*/

        if (clearEnable)
        {
            *frameratepairptr = (frameratepair & 0x0000FFFF); /*Clear Higher 16 bits*/
        }
    }
    else
    {
        frameRate = (uint16)frameratepair; /*Lower Element*/

        if (clearEnable)
        {
            *frameratepairptr = (frameratepair & 0xFFFF0000); /*Clear Lower 16 bits*/
        }
    }

    return frameRate;
}


uint16 IfxCan_Node_Cre_getXtdGroupXFrameRate(Ifx_CAN_N *node, IfxCan_XtdFrameGroupId id, uint32 ramAddress, boolean clearEnable)
{
    uint32  frameTableAddress = (uint32)IfxCan_Node_Cre_getXtdFrameRateAddress(node, ramAddress);

    uint32  wordIndex         = id / 2; /*2 Elements are stored per word*/

    uint32 *frameratepairptr  = (uint32 *)(frameTableAddress + (wordIndex * 4));

    uint32  frameratepair     = (uint32)(*frameratepairptr);

    uint16  frameRate         = 0;

    if (id % 2)
    {
        frameRate = (uint16)(frameratepair >> 16); /*Higher Element*/

        if (clearEnable)
        {
            *frameratepairptr = (frameratepair & 0x0000FFFF); /*Clear Higher 16 bits*/
        }
    }
    else
    {
        frameRate = (uint16)frameratepair; /*Lower Element*/

        if (clearEnable)
        {
            *frameratepairptr = (frameratepair & 0xFFFF0000); /*Clear Lower 16 bits*/
        }
    }

    return frameRate;
}


void IfxCan_Node_setExternalTimeStamp(Ifx_CAN_N *node, IfxCan_ExtTimerPrescalar prescalar, IfxCan_TimerTrigger trigger)
{
    node->TIMER.CCR.B.TPSC    = prescalar;
    node->TIMER.CCR.B.TRIGSRC = trigger;

    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(node);

    /*Configure External Timers before this point*/
    node->TSCC.B.TSS = IfxCan_TSCC_TSS_external;         //External 16-bit Time Stamp

    /* disable configuration change CCCR.CCE = 0, CCCR.INIT = 0 */
    IfxCan_Node_disableConfigurationChange(node);
}


void IfxCan_Node_forceStartExternalTimer(Ifx_CAN_N *node)
{
    node->TIMER.CCR.B.STRESET = FALSE; /*STSTART cannot be set to 1 if STRESET is set*/
    node->TIMER.CCR.B.STSTART = TRUE;
}


void IfxCan_Node_setStartExternalTimer(Ifx_CAN_N *node, boolean start)
{
    node->TIMER.CCR.B.STSTART = start;
}


void IfxCan_Node_setResetExternalTimer(Ifx_CAN_N *node, boolean reset)
{
    node->TIMER.CCR.B.STRESET = reset;
}


void IfxCan_Node_tsuInitWithConfigChangeEnable(Ifx_CAN_N *node, IfxCan_TsuConfig tsuConfig)
{
    /* enable configuration change CCCR.CCE = 1, CCCR.INIT = 1 */
    IfxCan_Node_enableConfigurationChange(node);

    IfxCan_Node_tsuInit(node, tsuConfig);

    /* disable configuration change CCCR.CCE = 0, CCCR.INIT = 0 */
    IfxCan_Node_disableConfigurationChange(node);
}


void IfxCan_initApConfig(IfxCan_ApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuCanConfig);
    IfxApApu_initConfig(&config->apuNode0Config);
    IfxApApu_initConfig(&config->apuNode1Config);
    IfxApApu_initConfig(&config->apuNode2Config);
    IfxApApu_initConfig(&config->apuNode3Config);
}


void IfxCan_initAp(Ifx_CAN *can, IfxCan_ApConfig *config)
{
    /* Initialize the PROTs */
    IfxApProt_init((Ifx_PROT_PROT *)&can->PROTE, &config->proteConfig);
    IfxApProt_init((Ifx_PROT_PROT *)&can->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&can->PROTSE, IfxApProt_State_config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->ACCEN, &config->apuCanConfig);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->N[0].ACCEN, &config->apuNode0Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->N[1].ACCEN, &config->apuNode1Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->N[2].ACCEN, &config->apuNode2Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->N[3].ACCEN, &config->apuNode3Config);
    IfxApProt_setState((Ifx_PROT_PROT *)&can->PROTSE, IfxApProt_State_run);
}


void IfxCan_Node_clearCreInterrupts(Ifx_CAN_N *node)
{
    node->CRE.IR.U = IFXCAN_CRE_IR_CLEAR; /*Interrupt clear on write of 1*/
}


void IfxCan_Node_clearCreInterrupt(Ifx_CAN_N *node, IfxCan_CreInterrupt index)
{
    node->CRE.IR.U = (1 << index); /*Interrupt clear on write of 1*/
}


void IfxCan_Node_setRamStartAddress(Ifx_CAN_N *node, uint16 address)
{
    /*Set PROTE to config before use*/
    node->STARTADR.B.PROT_RANGE_START = (address >> 2);
}


void IfxCan_Node_setRamEndAddress(Ifx_CAN_N *node, uint16 address)
{
    /*Set PROTE to config before use*/
    node->ENDADR.B.PROT_RANGE_END = (address >> 2);
}


void IfxCan_configureAccessToCans(IfxApApu_ApuConfig *apConfig)
{
    uint8 index;

    for (index = 0; index < IFXCAN_NUM_MODULES; index++)
    {
        uint8    node;
        Ifx_CAN *can = (Ifx_CAN *)(((uint32)&MODULE_CAN0) + index * ((uint32)&MODULE_CAN1 - (uint32)&MODULE_CAN0));

        IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->ACCEN, apConfig);

        for (node = 0; node < IFXCAN_NUM_NODES; node++)
        {
            IfxApApu_init((Ifx_ACCEN_ACCEN *)&can->N[node].ACCEN, apConfig);
        }
    }
}


void IfxCan_disableModuleCreWatchdog(Ifx_CAN *can)
{
    can->WDT.B.EN = 0;
}


void IfxCan_enableModuleCreWatchdog(Ifx_CAN *can, uint16 fastPrescalar, uint16 slowPrescalar)
{
    can->WDT.B.EN   = 1;
    can->WDT.B.FWDP = fastPrescalar;
    can->WDT.B.SWDP = slowPrescalar;
}


void IfxCan_enableCreNodeWatchdogGroups(Ifx_CAN *can, IfxCan_NodeId nodeId, IfxCan_CreWatchdogGroups *enableGroups)
{
    Ifx_CAN_N *nodePtr = (Ifx_CAN_N *)&can->N[nodeId];
    nodePtr->ERRCTRL.B.WDG1 = enableGroups->group1;
    nodePtr->ERRCTRL.B.WDG2 = enableGroups->group2;
    nodePtr->ERRCTRL.B.WDG3 = enableGroups->group3;
}


void IfxCan_enableCreNodeErrorInterrupts(Ifx_CAN *can, IfxCan_NodeId nodeId, IfxCan_CreErrorInterruptEnable *enableInterrupts)
{
    Ifx_CAN_N *nodePtr = (Ifx_CAN_N *)&can->N[nodeId];
    nodePtr->ERRCTRL.B.RWD0IE = enableInterrupts->rxWatchdogTimeout0;
    nodePtr->ERRCTRL.B.RWD1IE = enableInterrupts->rxWatchdogTimeout1;
    nodePtr->ERRCTRL.B.TWD0IE = enableInterrupts->txWatchdogTimeout0;
    nodePtr->ERRCTRL.B.TWD1IE = enableInterrupts->txWatchdogTimeout1;
    nodePtr->ERRCTRL.B.CRCIE  = enableInterrupts->crcError;
    nodePtr->ERRCTRL.B.IRSIE  = enableInterrupts->incorrectReadSequenceError;
    nodePtr->ERRCTRL.B.IWSIE  = enableInterrupts->incorrectWriteSequenceError;
}


uint32 IfxCan_Node_getNominalBaudRate(Ifx_CAN_N *node)
{
    uint32         timeSegment1, timeSegment2, prescaler, baudrate, bitTimeTq;
    float32        clockPeriod, timeQuantum, bitTimeSec;
    Ifx_CAN_N_NBTP nbtpReg;

    /* 1. Read register content */
    nbtpReg.U    = node->NBTP.U;
    timeSegment1 = nbtpReg.B.NTSEG1 + 1u;
    timeSegment2 = nbtpReg.B.NTSEG2 + 1u;
    prescaler    = nbtpReg.B.NBRP + 1u;

    /* 2. Calculate baud rate */
    clockPeriod = 1.0f / (float32)IfxCan_getModuleFrequency(); /* CAN clock period in seconds */
    timeQuantum = prescaler * clockPeriod;                     /* Length of time quantum in seconds */

    bitTimeTq   = timeSegment1 + timeSegment2 + 1u;            /* Bit time = Time segment 1 + Time segment 2 + 1 */
    bitTimeSec  = bitTimeTq * timeQuantum;
    baudrate    = 1.0f / bitTimeSec;

    return baudrate;
}


uint32 IfxCan_Node_getFdBaudRate(Ifx_CAN_N *node)
{
    uint32         timeSegment1, timeSegment2, prescaler, baudrate, bitTimeTq;
    float32        clockPeriod, timeQuantum, bitTimeSec;
    Ifx_CAN_N_DBTP dbtpReg;

    /* 1. Read register content */
    dbtpReg.U    = node->DBTP.U;
    timeSegment1 = dbtpReg.B.DTSEG1 + 1u;
    timeSegment2 = dbtpReg.B.DTSEG2 + 1u;
    prescaler    = dbtpReg.B.DBRP + 1u;

    /* 2. Calculate baud rate */
    clockPeriod = 1.0f / (float32)IfxCan_getModuleFrequency(); /* CAN clock period in seconds */
    timeQuantum = prescaler * clockPeriod;                     /* Length of time quantum in seconds */

    bitTimeTq   = timeSegment1 + timeSegment2 + 1u;            /* Bit time = Time segment 1 + Time segment 2 + 1 */
    bitTimeSec  = bitTimeTq * timeQuantum;
    baudrate    = 1.0f / bitTimeSec;

    return baudrate;
}
