/**********************************************************************************************************************
 * \file CCU6_ADC.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "CCU6_ADC.h"
#include "Ifx_Types.h"
#include "IfxAsclin_Asc.h"
#include "IfxCcu6_Timer.h"
#include "IfxVadc_Adc.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_ADC                4                               /* ADC result interrupt's priority          */
#define ADC_CHANNEL                     0                               /* ADC channel number                       */

#define ISR_PRIORITY_ASCLIN_TX          1                               /* Priority of the interrupt ISR Transmit   */
#define ISR_PRIORITY_ASCLIN_RX          2                               /* Priority of the interrupt ISR Receive    */
#define ISR_PRIORITY_ASCLIN_ER          3                               /* Priority of the interrupt ISR Errors     */
#define ASC_TX_BUFFER_SIZE              64
#define ASC_RX_BUFFER_SIZE              64
#define ASC_PRESCALER                   1
#define ASC_BAUDRATE                    115200

#define CCU6_T12_TIMER_FREQ             48828                           /* T12 Timer module frequency in Hz         */
#define CCU6_T13_TIMER_FREQ             48828                           /* T13 Timer module frequency in Hz         */
#define CCU6_T12_TIMER_MATCH_FREQ       1                               /* T12 Period Match frequency in Hz         */
#define CCU6_T13_TIMER_MATCH_PERIOD     0.5f                            /* T13 Period Match time in seconds         */

/* Timers period in ticks */
#define CCU6_T12_TIMER_PERIOD           (CCU6_T12_TIMER_FREQ / CCU6_T12_TIMER_MATCH_FREQ) - 1
#define CCU6_T13_TIMER_PERIOD           (CCU6_T13_TIMER_FREQ * CCU6_T13_TIMER_MATCH_PERIOD) - 1

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
/* VADC handle */
IfxVadc_Adc g_vadc;
IfxVadc_Adc_Group g_adcGroup;
IfxVadc_Adc_Channel g_adcChannel;

/* Timer handle */
IfxCcu6_Timer g_timer;

/* Variable for Standard interface */
IfxAsclin_Asc g_asc;
IfxStdIf_DPipe g_stdInterface;

/* The transfer buffers allocate memory for the data itself and for the FIFO runtime variables.
 * 8 more bytes have to be added to ensure a proper circular buffer handling independent from
 * the address to which the buffers have been located.
 */
uint8 g_AscTxBuffer[ASC_TX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];
uint8 g_AscRxBuffer[ASC_RX_BUFFER_SIZE + sizeof(Ifx_Fifo) + 8];

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the CCU6 module */
void init_ccu6(void)
{
    IfxCcu6_Timer_Config timerConfig;
    IfxCcu6_Timer_initModuleConfig(&timerConfig, &MODULE_CCU60);

    /* Configure the T12 timer frequency/period (trigger for T13 timer) and T13 timer frequency/period (trigger
     * for ADC). Timer T13 starts counting in single shot mode triggered by a period-match event of the T12 timer.
     * The period of the timer T13 represents a delay (from the period-match event of the T12 timer) of the ADC
     * trigger event.
     */
    timerConfig.base.t12Frequency = CCU6_T12_TIMER_FREQ;                /* Timer T12 frequency                      */
    timerConfig.base.waitingTime = CCU6_T12_TIMER_PERIOD;               /* waitingTime is the period of T12 timer   */
    timerConfig.base.t13Frequency = CCU6_T13_TIMER_FREQ;                /* Timer T13 frequency                      */
    timerConfig.base.t13Period = CCU6_T13_TIMER_PERIOD;                 /* Timer T13 period                         */
    timerConfig.timer = IfxCcu6_TimerId_t13;                            /* Select the timer, T13 is the master      */
    timerConfig.synchronousOperation = FALSE;                           /* Disable synchronous start of the timers  */
    timerConfig.trigger.t13InSyncWithT12 = TRUE;                        /* T12 timer starts the T13 timer           */

    /* Configure the T13 timer start event */
    timerConfig.timer13.t12SyncEvent = IfxCcu6_T13TriggerEvent_onT12Period;
    timerConfig.timer13.t12SyncDirection = IfxCcu6_T13TriggerDirection_onT12CountingUp;

    /* Apply the configuration to the CCU6 module */
    IfxCcu6_Timer_initModule(&g_timer, &timerConfig);

    /* Activate the line ServiceRequest_3 to route the T13 period match event trigger to the VADC module */
    IfxCcu6_enableInterrupt(&MODULE_CCU60, IfxCcu6_InterruptSource_t13PeriodMatch);
    IfxCcu6_routeInterruptNode(&MODULE_CCU60, IfxCcu6_InterruptSource_t13PeriodMatch, IfxCcu6_ServiceRequest_3);

    /* Configure the T13 timer for single shot mode */
    IfxCcu6_enableSingleShotMode(&MODULE_CCU60, IfxCcu6_TimerId_t13);
}

/* Function to start the CCU6 timer, according to the configuration */
void start_ccu6_timer(void)
{
    IfxCcu6_Timer_start(&g_timer);
}

/* Configuration and initialization of the VADC module and the group that are used */
void init_vadc(void)
{
    /* Create configuration */
    IfxVadc_Adc_Config adcConfig;
    IfxVadc_Adc_initModuleConfig(&adcConfig, &MODULE_VADC);

    /* Initialize module */
    IfxVadc_Adc_initModule(&g_vadc, &adcConfig);

    /* Create and initialize group configuration with default values */
    IfxVadc_Adc_GroupConfig adcGroupConfig;
    IfxVadc_Adc_initGroupConfig(&adcGroupConfig, &g_vadc);

    /* Setting user configuration using group 0 */
    adcGroupConfig.groupId = IfxVadc_GroupId_0;                                         /* Select the VADC group    */
    adcGroupConfig.master = adcGroupConfig.groupId;                                     /* Select the master group  */
    adcGroupConfig.arbiter.requestSlotScanEnabled = TRUE;                               /* Enable scan source       */
    adcGroupConfig.scanRequest.autoscanEnabled = FALSE;                                 /* Disable auto scan        */

    /* Prerequisite for enabling the ADC conversion (due to the fact that in this example the gating signal is
     * not used)
     */
    adcGroupConfig.scanRequest.triggerConfig.gatingMode = IfxVadc_GatingMode_always;

    /* Configure the VADC module to trigger a conversion based on CCU6 timer period match event */
    /* Trigger 0 is connected to CCU6 ServiceRequest_3 line */
    adcGroupConfig.scanRequest.triggerConfig.triggerSource = IfxVadc_TriggerSource_0;
    /* Select the trigger event type */
    adcGroupConfig.scanRequest.triggerConfig.triggerMode = IfxVadc_TriggerMode_uponRisingEdge;

    /* Set that requests with higher priority cancel a running lower priority conversion */
    adcGroupConfig.scanRequest.requestSlotStartMode = IfxVadc_RequestSlotStartMode_cancelInjectRepeat;

    /* Initialize the VADC group */
    IfxVadc_Adc_initGroup(&g_adcGroup, &adcGroupConfig);

    /* Create channel configuration */
    IfxVadc_Adc_ChannelConfig adcChannelConfig;
    IfxVadc_Adc_initChannelConfig(&adcChannelConfig, &g_adcGroup);

    adcChannelConfig.channelId = (IfxVadc_ChannelId) (ADC_CHANNEL);             /* Select the VADC channel          */
    adcChannelConfig.resultRegister = (IfxVadc_ChannelResult) (ADC_CHANNEL);    /* Use dedicated result register    */

    /* Interrupt for sending the data via UART */
    adcChannelConfig.resultPriority = ISR_PRIORITY_ADC;                 /* Set the VADC interrupt priority          */
    adcChannelConfig.resultServProvider = IfxSrc_Tos_cpu0;              /* Set the VADC interrupt service provider  */

    /* Initialize the channel */
    IfxVadc_Adc_initChannel(&g_adcChannel, &adcChannelConfig);

    /* Add the selected channel to the scan sequence */
    uint32 channels = (1 << adcChannelConfig.channelId);   /* Set the bit corresponding to the input channel of the */
    uint32 mask = channels;                                /* respective group to take part in the scan sequence.   */
    IfxVadc_Adc_setScan(&g_adcGroup, channels, mask);
}

/* ADC Interrupt Service Routine */
IFX_INTERRUPT(ISR_ADC_result, 0, ISR_PRIORITY_ADC);

void ISR_ADC_result(void)
{
    /* Get the result from the VADC result register and print it using the UART communication */
    Ifx_VADC_RES conversionResult = IfxVadc_Adc_getResult(&g_adcChannel);
    IfxStdIf_DPipe_print(&g_stdInterface, "ADC Sample: %d\r\n", conversionResult.B.RESULT);
}

/* ASCLIN TX Interrupt Service Routine */
IFX_INTERRUPT(ASCLIN_ISR_Tx, 0, ISR_PRIORITY_ASCLIN_TX);

void ASCLIN_ISR_Tx(void)
{
    IfxAsclin_Asc_isrTransmit(&g_asc);
}

/* ASCLIN RX Interrupt Service Routine */
IFX_INTERRUPT(ASCLIN_ISR_Rx, 0, ISR_PRIORITY_ASCLIN_RX);

void ASCLIN_ISR_Rx(void)
{
    IfxAsclin_Asc_isrReceive(&g_asc);
}

/* ASCLIN Error Interrupt Service Routine */
IFX_INTERRUPT(ASCLIN_ISR_Er, 0, ISR_PRIORITY_ASCLIN_ER);

void ASCLIN_ISR_Er(void)
{
    IfxAsclin_Asc_isrError(&g_asc);
}

/* Function to initialize ASCLIN module */
void init_uart(void)
{
    IfxAsclin_Asc_Config ascConf;

    IfxAsclin_Asc_initModuleConfig(&ascConf, &MODULE_ASCLIN0);

    /* Set the desired baud rate */
    ascConf.baudrate.prescaler = ASC_PRESCALER;
    ascConf.baudrate.baudrate = ASC_BAUDRATE;
    ascConf.baudrate.oversampling = IfxAsclin_OversamplingFactor_4;

    /* ISR priorities and interrupt target */
    ascConf.interrupt.txPriority = ISR_PRIORITY_ASCLIN_TX;
    ascConf.interrupt.rxPriority = ISR_PRIORITY_ASCLIN_RX;
    ascConf.interrupt.erPriority = ISR_PRIORITY_ASCLIN_ER;
    ascConf.interrupt.typeOfService = IfxSrc_Tos_cpu0;

    /* FIFO configuration */
    ascConf.txBuffer = g_AscTxBuffer;
    ascConf.txBufferSize = ASC_TX_BUFFER_SIZE;
    ascConf.rxBuffer = g_AscRxBuffer;
    ascConf.rxBufferSize = ASC_RX_BUFFER_SIZE;

    /* Pin configuration */
    const IfxAsclin_Asc_Pins pins = {
            NULL, IfxPort_InputMode_pullUp,                         /* CTS port pin not used */
            &IfxAsclin0_RXA_P14_1_IN, IfxPort_InputMode_pullUp,     /* RX port pin           */
            NULL, IfxPort_OutputMode_pushPull,                      /* RTS port pin not used */
            &IfxAsclin0_TX_P14_0_OUT, IfxPort_OutputMode_pushPull,  /* TX port pin           */
            IfxPort_PadDriver_cmosAutomotiveSpeed1
    };
    ascConf.pins = &pins;

    /* Initialize module */
    IfxAsclin_Asc_initModule(&g_asc, &ascConf);

    /* Initialize Standard Interface */
    IfxAsclin_Asc_stdIfDPipeInit(&g_stdInterface, &g_asc);
}
