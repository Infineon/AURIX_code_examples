/**********************************************************************************************************************
 * \file IOM_Signals_Comparison.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "IfxGtm_Tom_Pwm.h"
#include "IfxIom_Driver.h"
#include "IfxIom.h"
#include "IfxScuWdt.h"
#include "IfxSmu.h"
#include "IfxPort.h"
#include "IOM_Signals_Comparison.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define ISR_PRIORITY_TOM    20                                              /* Interrupt priority number            */
#define ISR_PRIORITY_SMU    10                                              /* SMU Interrupt Priority Level         */

#define PWM_PERIOD          50000                                           /* PWM period of both TOM [ticks]       */
#define DUTYCYCLE           50                                              /* Duty cycle of both PWM signals [%]   */
#define DUTY_THRESHOLD      0.000050                                        /* Duty cycle threshold of 50us         */

#define REF                 IfxGtm_TOM1_0_TOUT9_P00_0_OUT                   /* Port pin driven by the PWM signal    */
#define REF_INPUT           IfxIom_MonInput_p33_1                           /* Define input for IOM reference       */
#define REF_PIN             &MODULE_P33, 1                                  /* Port pin for IOM reference input     */

#define MON                 IfxGtm_TOM0_0_TOUT18_P00_9_OUT                  /* Port pin driven by the PWM signal    */
#define MON_INPUT           IfxIom_MonInput_p33_2                           /* Define input for IOM monitor         */
#define MON_PIN             &MODULE_P33, 2                                  /* Port pin for IOM monitor input       */

#define NUM_OF_LAM_EVENTS   1                                /* Number of LAM events that triggers the System Event */

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/
IfxGtm_Tom_Pwm_Config g_tomConfig0;                                         /* TOM0 Timer configuration structure   */
IfxGtm_Tom_Pwm_Driver g_tomDriver0;                                         /* TOM0 Timer driver structure          */

IfxGtm_Tom_Pwm_Config g_tomConfig1;                                         /* TOM1 Timer configuration structure   */
IfxGtm_Tom_Pwm_Driver g_tomDriver1;                                         /* TOM1 Timer driver structure          */

IfxIom_Driver g_driver;                                                     /* IOM driver handle                    */
IfxIom_Driver_Lam g_lam;                                                    /* IOM LAM driver handle                */
IfxIom_Driver_Config g_configDriver;                                        /* IOM driver configuration             */
IfxIom_Driver_LamConfig g_configLam;                                        /* IOM LAM configuration                */

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/
/* Interrupt triggered by the SMU when IOM raises an event */
IFX_INTERRUPT(smuIsrHandler, 0, ISR_PRIORITY_SMU);

void smuIsrHandler(void)
{
    IfxPort_setPinLow(LED1);                                               /* Switch ON the LED1                    */
    IfxSmu_clearAlarmStatus(IfxSmu_Alarm_IOM_Pin_MismatchIndication);      /* Clear the SMU flag related to the IOM */
    /* Clear the Alarm Executed mechanism */
    IfxSmu_clearAlarmExecutedStatus(IfxSmu_AlarmExecutionStatus_irq0);
}

/* Initialization and configuration of the SMU module
 * This module handles the event generated by the IOM module
 */
void initSmu(void)
{
    /* Enable the SMU register configuration by setting the CFGLCK field of the SMU_KEYS register to 0xBC */
    IfxSmu_unlockConfigRegisters();
    IfxScuWdt_clearSafetyEndinit(IfxScuWdt_getSafetyWatchdogPasswordInline());

    /* Enable the 'Interrupt Generation Configuration Set 0' of the SMU */
    MODULE_SMU.AGC.U = 0x1;

    /* Set Safety ENDINIT protection after modification of the configuration registers */
    IfxScuWdt_setSafetyEndinit(IfxScuWdt_getSafetyWatchdogPasswordInline());
    IfxSmu_setAlarmAction(IfxSmu_Alarm_IOM_Pin_MismatchIndication, IfxSmu_InternalAlarmAction_igcs0);

    /* After configuration, lock of the SMU configuration */
    IfxSmu_lockConfigRegisters();
}

/* Initialization and configuration of the Interrupt Router module
 * This module handles the Software Interrupt generated by the SMU module
 */
void initIR(void)
{
    volatile Ifx_SRC_SRCR *src;
    src = &SRC_SMU0;                                            /* Assign the register                              */
    IfxSrc_init(src, IfxSrc_Tos_cpu0, ISR_PRIORITY_SMU);        /* Configuration of the interrupt level and its ToS */
    IfxSrc_enable(src);                                         /* Enable the related interrupt service request     */
    IfxSmu_activateRunState();                                  /* Start the SMU state machine (SSM)                */
}

/* This function initializes the TOMs */
void initGtmTomPwm(void)
{
    IfxGtm_enable(&MODULE_GTM);                                                 /* Enable GTM                       */

    /*-------------------------------------Configuration for PWM-signal monitor-------------------------------------*/

    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);               /* Enable the FXU clock             */
    IfxGtm_Tom_Pwm_initConfig(&g_tomConfig0, &MODULE_GTM);                      /* Initialize default parameters    */

    g_tomConfig0.tom = MON.tom;                                                 /* Select the TOM                   */
    g_tomConfig0.tomChannel = MON.channel;                                      /* Select the channel               */
    g_tomConfig0.period = PWM_PERIOD;                                           /* Set timer period                 */
    g_tomConfig0.dutyCycle = (DUTYCYCLE * PWM_PERIOD) / 100;                    /* Set duty cycle                   */
    g_tomConfig0.pin.outputPin = &MON;                                          /* Set LED as output                */
    g_tomConfig0.synchronousUpdateEnabled = TRUE;                               /* Enable synchronous update        */

    IfxGtm_Tom_Pwm_init(&g_tomDriver0, &g_tomConfig0);                          /* Initialize the PWM               */
    IfxGtm_Tom_Pwm_start(&g_tomDriver0, TRUE);                                  /* Start the PWM                    */

    /*------------------------------------Configuration for PWM-signal reference------------------------------------*/

    IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_FXCLK);               /* Enable the FXU clock             */
    IfxGtm_Tom_Pwm_initConfig(&g_tomConfig1, &MODULE_GTM);                      /* Initialize default parameters    */

    g_tomConfig1.tom = REF.tom;                                                 /* Select the TOM                   */
    g_tomConfig1.tomChannel = REF.channel;                                      /* Select the channel               */
    g_tomConfig1.period = PWM_PERIOD;                                           /* Set timer period                 */
    g_tomConfig1.dutyCycle = (DUTYCYCLE * PWM_PERIOD) / 100;                    /* Set duty cycle                   */
    g_tomConfig1.pin.outputPin = &REF;                                          /* Set LED as output                */
    g_tomConfig1.synchronousUpdateEnabled = TRUE;                               /* Enable synchronous update        */

    IfxGtm_Tom_Pwm_init(&g_tomDriver1, &g_tomConfig1);                          /* Initialize the PWM               */
    IfxGtm_Tom_Pwm_start(&g_tomDriver1, TRUE);                                  /* Start the PWM                    */
}

/* Initialization and configuration of the IOM module. The IOM monitor the duty cycle of a PWM signal */
void initIOM(void)
{
    /* Initialization of the LED used in this example */
    IfxPort_setPinModeOutput(LED1, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);
    IfxPort_setPinHigh(LED1);                                       /* Switch OFF the LED (active low)              */

    IfxPort_setPinMode(REF_PIN, IfxPort_Mode_inputPullDown);        /* IOM reference input                          */
    IfxPort_setPinMode(MON_PIN, IfxPort_Mode_inputPullDown);        /* IOM monitor input                            */

    IfxIom_enableModule(&MODULE_IOM, 1);                            /* Initialization of the IOM module             */
    IfxIom_Driver_initConfig(&g_configDriver, &MODULE_IOM);         /* Creation of the IOM default configuration    */
    IfxIom_Driver_init(&g_driver, &g_configDriver);                 /* Apply the configuration                      */

    IfxIom_Driver_initLamConfig(&g_configLam, &g_driver);           /* Creation of a default LAM configuration      */

    g_configLam.channel = IfxIom_LamId_0;                           /* Selection of LAM ID 0                        */

    /* Configuration of the Monitor signal */
    g_configLam.mon.input = MON_INPUT;                              /* IOM - Monitor signal input                   */
    g_configLam.mon.filter.mode = IfxIom_LamFilterMode_noFilter;    /* No filter applied on the signal              */
    g_configLam.mon.inverted = FALSE;                               /* Input signal NOT inverted                    */

    /* Configuration of the Reference signal */
    g_configLam.ref.input = REF_INPUT;                              /* IOM - Reference signal input                 */
    g_configLam.ref.filter.mode = IfxIom_LamFilterMode_noFilter;    /* No filter applied on the signal              */
    g_configLam.ref.inverted = FALSE;                               /* Input signal NOT inverted                    */

    /* Configuration of the Event Window */
    g_configLam.eventWindow.controlSource = IfxIom_LamEventWindowControlSource_mon; /* Event window generation determined from the monitor signal   */
    g_configLam.eventWindow.run = IfxIom_LamEventWindowRunControl_freeRunning;      /* Event generation window is not gated                         */
    g_configLam.eventWindow.clearEvent = IfxIom_LamEventWindowClearEvent_anyEdge;   /* Window clears at any edge                                    */
    g_configLam.eventWindow.threshold = DUTY_THRESHOLD;                             /* Set the threshold                                            */
    g_configLam.eventWindow.inverted = FALSE;                                       /* Window: NOT INVERTED                                         */

    /* Configuration of the IOM event */
    g_configLam.event.source = IfxIom_LamEventSource_monXorRef;     /* Signal comparison: Reference XOR Monitor     */
    g_configLam.event.trigger = IfxIom_LamEventTrigger_fallingEdge; /* Falling edge is used for event generation    */
    g_configLam.systemEventTriggerThreshold = NUM_OF_LAM_EVENTS;    /* Alarm generated after 1 event                */

    IfxIom_Driver_initLam(&g_lam, &g_configLam);                    /* Apply the custom configuration               */

    IfxIom_Driver_enableLamEvent(&g_lam);                           /* Enable LAM events                            */
}

/* Change the PWM signal duty cycle */
void changeDutyCycle(float32 duty)
{
    g_tomConfig0.dutyCycle = (duty * PWM_PERIOD) / 100;             /* Set the duty cycle                           */
    IfxGtm_Tom_Pwm_init(&g_tomDriver0, &g_tomConfig0);              /* Re-initialize the PWM                        */
}
