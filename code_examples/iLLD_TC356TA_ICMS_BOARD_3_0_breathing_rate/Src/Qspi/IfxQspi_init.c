/**********************************************************************************************************************
 * \file Qspi_init.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/


#include <IfxQspi_init.h>

void spiTxISR();
void spiRxISR();

IFX_INTERRUPT(spiTxISR, ISR_VECTAB_CPU0, ISR_PRIORITY_MMIC_SPI_TX);  /* SPI Master ISR for transmit data         */
IFX_INTERRUPT(spiRxISR, ISR_VECTAB_CPU0, ISR_PRIORITY_MMIC_SPI_RX);  /* SPI Master ISR for receive data          */


volatile Ifx_SRC_SRCR *IfxQspi_getSrcPointerIntRx(Ifx_QSPI *qspi);
volatile Ifx_SRC_SRCR *IfxQspi_getSrcPointerIntTx(Ifx_QSPI *qspi);

Ifx_QSPI_BACON single32_bacon, single12_bacon;
Ifx_QSPI_BACON burstHeader_bacon, burstData_bacon, burstDataLast_bacon;
IFX_ALIGN (64) uint32 burstCmdQueue[10];


void Qspi_Init(float32 f_qspi)
{

    Radar *rdr = &g_rdr;

    /* Enable QSPI module clock */
    Ifx_SCU * scu = &MODULE_SCU;
    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearSafetyEndinitInline(passwd);
    scu->CCUCON1.B.CLKSELQSPI = 1; /*fsource1 is used as clock source fSOURCEMSC*/
    scu->CCUCON1.B.QSPIDIV    = 1; /*fQSPI = fSOURCEQSPI*/
    IfxScuWdt_setSafetyEndinitInline(passwd);
    IfxScuCcu_setQspiFrequency(f_qspi);


    /******** INIT QSPI MODULE 3 AS MASTER ********/
    rdr->mmic.spi.spiSfr = &MODULE_QSPI3;
    IfxQspi_SpiMaster_Config spiMasterConfig;
    IfxQspi_SpiMaster_initModuleConfig(&spiMasterConfig, rdr->mmic.spi.spiSfr);

    spiMasterConfig.base.mode = SpiIf_Mode_master;                      /* MASTER mode*/

    /* Select the port pins for communication */
    const IfxQspi_SpiMaster_Pins qspi3MasterPins = {
        &IfxQspi3_SCLK_P02_7_OUT, IfxPort_OutputMode_pushPull,          /* SCLK Pin                       (CLK)     */
        &IfxQspi3_MTSR_P02_6_OUT, IfxPort_OutputMode_pushPull,          /* MasterTransmitSlaveReceive pin (MOSI)    */
        &IfxQspi3_MRSTA_P02_5_IN, IfxPort_InputMode_noPullDevice,       /* MasterReceiveSlaveTransmit pin (MISO)    */
        IfxPort_PadDriver_ttl3v3Speed1                                  /* Pad driver mode                          */
    };
    spiMasterConfig.pins = &qspi3MasterPins;


    /* Set the ISR priorities and the service provider */
    spiMasterConfig.base.txPriority = ISR_PRIORITY_MMIC_SPI_TX;
    spiMasterConfig.base.rxPriority = ISR_PRIORITY_MMIC_SPI_RX;
    spiMasterConfig.base.erPriority = ISR_PRIORITY_MMIC_SPI_ER;
    spiMasterConfig.base.isrProvider = IfxSrc_Tos_cpu0;


    /* SPI baudrate */
    spiMasterConfig.base.maximumBaudrate = (float32)QSPI_BAUDRATE;

    /* Initialize the QSPI Master module */
    IfxQspi_SpiMaster_initModule(&rdr->mmic.spi.spiMaster, &spiMasterConfig);


    /********** INIT QSPI CHANNEL **********/
    IfxQspi_SpiMaster_ChannelConfig spiMasterChannelConfig;             /* Define a Master Channel configuration    */

    /* Initialize the configuration with default values */
    IfxQspi_SpiMaster_initChannelConfig(&spiMasterChannelConfig, &rdr->mmic.spi.spiMaster);

    spiMasterChannelConfig.channelBasedCs = IfxQspi_SpiMaster_ChannelBasedCs_disabled;
    spiMasterChannelConfig.dummyRxValue = 0;
    spiMasterChannelConfig.dummyTxValue = 0;

     /* Select the port pin for the Chip Select signal */
     const IfxQspi_SpiMaster_Output qspi3SlaveSelect = {
         &IfxQspi3_SLSO0_P02_4_OUT, IfxPort_OutputMode_pushPull,         /* Slave Select port pin (CS)               */
         IfxPort_PadDriver_ttl3v3Speed1                          /* Pad driver mode                          */
     };
     spiMasterChannelConfig.sls.output = qspi3SlaveSelect;

     spiMasterChannelConfig.mode = IfxQspi_SpiMaster_Mode_shortContinuous;

     spiMasterChannelConfig.base.baudrate = (float32)QSPI_BAUDRATE;      /* Set SCLK frequency               */

     spiMasterChannelConfig.base.mode.enabled           = TRUE;
     spiMasterChannelConfig.base.mode.dataHeading       = SpiIf_DataHeading_msbFirst;
     spiMasterChannelConfig.base.mode.dataWidth         = 32;
     spiMasterChannelConfig.base.mode.clockPolarity     = SpiIf_ClockPolarity_idleLow;
     spiMasterChannelConfig.base.mode.shiftClock        = SpiIf_ShiftClock_shiftTransmitDataOnTrailingEdge;
     spiMasterChannelConfig.base.mode.autoCS            = 1;
     spiMasterChannelConfig.base.mode.csActiveLevel     = Ifx_ActiveState_low;
     spiMasterChannelConfig.base.mode.csLeadDelay       = SpiIf_SlsoTiming_6; /*min 9ns*/
     spiMasterChannelConfig.base.mode.csTrailDelay      = SpiIf_SlsoTiming_4; /*min 1clk+1ns*/
     spiMasterChannelConfig.base.mode.csInactiveDelay   = SpiIf_SlsoTiming_6;
     spiMasterChannelConfig.base.mode.parityCheck       = FALSE;
     spiMasterChannelConfig.base.mode.parityMode        = Ifx_ParityMode_even;
     spiMasterChannelConfig.base.mode.loopback          = FALSE;


     spiMasterChannelConfig.base.errorChecks.baudrate   = FALSE;
     spiMasterChannelConfig.base.errorChecks.phase      = FALSE;
     spiMasterChannelConfig.base.errorChecks.receive    = FALSE;
     spiMasterChannelConfig.base.errorChecks.transmit   = FALSE;


     /* Initialize the QSPI Master channel */
     IfxQspi_SpiMaster_initChannel(&rdr->mmic.spi.spiMasterChannel, &spiMasterChannelConfig);

     /********** CREATE SPI BACONs  **********/
     single32_bacon.B.LAST    = TRUE;         /**[0:0] Last Word in a Frame - LAST (rh) */
     single32_bacon.B.IPRE    = 0;            /**[3:1] Prescaler for the Idle Delay - IPRE (rh) */
     single32_bacon.B.IDLE    = 0;            /**[6:4] Idle Delay Length - IDLE (rh) */
     single32_bacon.B.LPRE    = 0;            /**[9:7] Prescaler for the Leading Delay - LPRE (rh) */
     single32_bacon.B.LEAD    = 3;            /**[12:10] Leading Delay Length - LEAD (rh) */
     single32_bacon.B.TPRE    = 0;            /**[15:13] Prescaler for the Trailing Delay - TPRE (rh) */
     single32_bacon.B.TRAIL   = 3;            /**[18:16] Trailing Delay Length - TRAIL (rh) */
     single32_bacon.B.PARTYP  = 0;            /* 0=even, 1=odd */
     single32_bacon.B.UINT    = FALSE;        /* user interrupt */
     single32_bacon.B.MSB     = 1;            /* 1=MSB first, 0=LSB first */
     single32_bacon.B.BYTE    = 0;            /* 0=DL in bits, 1=DL in bytes */
     single32_bacon.B.DL      = 32-1;         /* 1=2bits, 2=3bits  etc..., DL+1 bits per frame */
     single32_bacon.B.CS      = 0;            /* 0=Channel0 */

     burstHeader_bacon.U = single32_bacon.U;
     burstHeader_bacon.B.DL = 32-1;
     burstHeader_bacon.B.LAST = FALSE;

     burstData_bacon.U = single32_bacon.U;
     burstData_bacon.B.DL = 12-1;
     burstData_bacon.B.LAST = FALSE;

     burstDataLast_bacon.U = burstData_bacon.U;
     burstDataLast_bacon.B.DL = 12-1;
     burstDataLast_bacon.B.LAST = TRUE;

     /********** Command array for DMA transfers **********/
     burstCmdQueue[0] = burstHeader_bacon.U;        /*BACON for burst header*/
     burstCmdQueue[1] = (0x7F<<25) | (1<<24) | (0x64<<17) | (0<<16) | (0<<9); /* burst header command*/
     burstCmdQueue[2] = burstData_bacon.U;          /* BACON for 12-bit samples excluding last sample*/
     burstCmdQueue[3] = 0x0;                        /* Dummy data*/
     burstCmdQueue[4] = burstDataLast_bacon.U;      /* BACON for last 12-bit sample*/
     burstCmdQueue[5] = 0x0;                        /* Dummy data*/
     burstCmdQueue[6] = 0x200;                      /* TX Flags Clear*/

     rdr->mmic.spi.spi_busy = FALSE;

     Qspi_Mode(Spi_Single);
}

/* Send/receive a single 32-bit data packet */
uint32 Qspi_exchange32(uint32 cmd)
{
    IfxMmicSpi * spi = &g_rdr.mmic.spi;

    if(spi->mode != Spi_Single)
        Qspi_Mode(Spi_Single);

    while(spi->spi_busy); /*ensure previous transaction has finished*/

    spi->spi_busy = TRUE;

    spi->spiSfr->BACONENTRY.U   = single32_bacon.U;
    spi->spiSfr->DATAENTRY[0].U = cmd;

    /* after writing to BACON and DATAENTRY, the transfer is triggered.
     * Upon finalization of the transfer, the TX and RX ISRs are called
     */

    while(spi->spi_busy); /* wait until receive is finished */

    return spi->rxData.U;
}

/* switch between SPI modes.
 * --SINGLE mode: interrupt served by CPU,
 * --BURST mode: interrupt served by DMA
 */
void Qspi_Mode(uint32 mode)
{
    IfxMmicSpi *spi = &g_rdr.mmic.spi;
    volatile Ifx_SRC_SRCR *src;
    if (mode==Spi_Single)
    {
        spi->mode = Spi_Single;
        /* SPI receive interrupt CPU*/
        src = IfxQspi_getSrcPointerIntRx(spi->spiSfr);
        IfxSrc_init(src, ISR_PROVIDER_CPU0, ISR_PRIORITY_MMIC_SPI_RX); /*Serve RX with CPU0*/
        IfxSrc_enable(src);
        /* SPI transmit interrupt CPU*/
        src = IfxQspi_getSrcPointerIntTx(spi->spiSfr);
        IfxSrc_init(src, ISR_PROVIDER_CPU0, ISR_PRIORITY_MMIC_SPI_TX); /*Serve TX with CPU0*/
        IfxSrc_enable(src);
    }
    else
    {
        spi->mode = Spi_Burst;
        /* SPI receive interrupt DMA*/
        src = IfxQspi_getSrcPointerIntRx(spi->spiSfr);
        IfxSrc_init(src, ISR_PROVIDER_DMA, ISR_DMA_CH_MMIC_SPI_RX); /* Serve RX with DMA Channel 1*/
        IfxSrc_enable(src);
        /* SPI transmit interrupt DMA*/
        src = IfxQspi_getSrcPointerIntTx(spi->spiSfr);
        IfxSrc_init(src, ISR_PROVIDER_DMA, ISR_DMA_CH_MMIC_SPI_TX); /* Serve TX with DMA Channel 0*/
        IfxSrc_enable(src);
    }
}

/* This routine returns the address of QSPI RX interrupt service node */
volatile Ifx_SRC_SRCR *IfxQspi_getSrcPointerIntRx(Ifx_QSPI *qspi)
{
    return &MODULE_SRC.QSPI.QSPI[IfxQspi_getIndex(qspi)].RX;
}


/* This routine returns the address of QSPI TX interrupt service node  */
volatile Ifx_SRC_SRCR *IfxQspi_getSrcPointerIntTx(Ifx_QSPI *qspi)
{
    return &MODULE_SRC.QSPI.QSPI[IfxQspi_getIndex(qspi)].TX;
}

void spiTxISR()
{
    Radar * rdr = &g_rdr;
    IfxCpu_enableInterrupts();
    rdr->mmic.spi.spiSfr->FLAGSCLEAR.B.TXC = 1; /*clear SPI TX flag*/
}

void spiRxISR()
{
    IfxMmicSpi * spi = &g_rdr.mmic.spi;
    IfxCpu_enableInterrupts();

    spi->rxData.U = spi->spiSfr->RXEXIT.U;
    spi->spiSfr->FLAGSCLEAR.B.RXC = 1; /*clear RX flag;*/

    spi->spi_busy = FALSE;
}
