/**********************************************************************************************************************
 * \file IfxSpu_init.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*
 ******************************************************************************
 * Standard include files
 ******************************************************************************
 */
#include "IfxScuWdt.h"
#include "IfxCpu.h"
#include "IfxSrc.h"
#include "IfxSrc_reg.h"
/*
 ******************************************************************************
 * Project include files
 ******************************************************************************
 */
#include "IfxSpu_init.h"
#include "Spu/Std/IfxSpu.h"
#include "_Reg/IfxSpu_reg.h"
#include "_Impl/IfxSpu_cfg.h"
#include "_Impl/IfxEmem_cfg.h"
#include "IfxIsr_cfg.h"
#include "IfxRadar_cfg.h"
#include "IfxMtu_init.h"
#include "IfxStm.h"

#include "Ifx_Types.h"

#include <stdint.h>
/*
 ******************************************************************************
 * Global variables
 ******************************************************************************
 */
Ifx_SPU_BE_ODP_CONF odp_conf;

/*
 ******************************************************************************
 * Routine prototypes
 ******************************************************************************
 */
IFX_INTERRUPT(ISR_spu0_lld, ISR_VECTAB_CPU0, ISR_PRIORITY_SPU0_INT);

/*
 ******************************************************************************
 * Routine implementation
 ******************************************************************************
 */
IFX_INLINE void IfxSpu_Cfg(void);
IFX_INLINE volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerInt(Ifx_SPU *spu);
void IfxSpu_CalibWin_init(void *cmem_wnd, uint32 N, const void *wnd, boolean highres, boolean complex, boolean antenna_calib, const sint32 calib_factor_real, const sint32 calib_factor_imags);

/*
 ******************************************************************************
 * Brief:   The  routine void IfxSpu_init(void)
 * Details: This routine initializes the SPU and pre-initializes the CFGRAM
 ******************************************************************************
 */
void IfxSpu_Init(){
    /*Initialize SPU0/1*/
    Radar *rdr = &g_rdr;

    rdr->spu0  = &MODULE_SPU0; /* pointer to SPU0 SFRs*/
    rdr->cmem0 = (SPU_Cmem0_Map_t*)IFXSPU_CONFIG_RAM0_BASE;      /* pointer to CMEM0*/

    IfxSpu_ModuleConfig spu_cfg;
    IfxSpu_initModuleConfig(&spu_cfg);
    spu_cfg.clockDivisionRatio = IfxSpu_ClockDivisionRatio_unity; /* Set FFT performance to SPU_CLK/2*/
    spu_cfg.interrupt.linkedListEnd        = TRUE;/* INTMSK[3]: A configuration with CTLR.LAST bit set has been executed*/
    spu_cfg.interrupt.pactrTrigger         = FALSE; /* INTMSK[4]: Pactr Limit trigger interrupt*/

    spu_cfg.interrupt.inputDmaReadError    = TRUE;  /* ERRMSK[0]*/
    spu_cfg.interrupt.inputDmaWriteError   = TRUE;  /* ERRMSK[1]*/
    spu_cfg.interrupt.outputDmaEngineError = TRUE;  /* ERRMSK[2]*/
    spu_cfg.interrupt.fifoOverrun          = TRUE;  /* ERRMSK[3]*/
    spu_cfg.interrupt.pactrError           = FALSE; /* ERRMSK[4]*/
    spu_cfg.interrupt.math2UnitOverrun     = TRUE;  /* ERRMSK[5]*/

    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
        IfxSpu_initModule(rdr->spu0, &spu_cfg);
    IfxScuWdt_setCpuEndinit(passwd);

    IfxMtu_SpuInit(); /* initialize all SPU0/1 memories*/

    volatile Ifx_SRC_SRCR *src;
    src = IfxSpu_getSrcPointerInt(rdr->spu0);
    IfxSrc_init(src, ISR_PROVIDER_CPU0, ISR_PRIORITY_SPU0_INT);
    IfxSrc_enable(src);

    IfxSpu_Cfg(); /* initialize SPU0/1 CMEM*/

}

/*
 ******************************************************************************
 * Brief:   The routine void IfxSpu_cfg_init(void)
 * Details: This routine initializes the SPU and pre-initializes the CFGRAM
 ******************************************************************************
 */
void IfxSpu_Cfg(){
    Radar *rdr = &g_rdr;
    IfxSpu_SlotConfig   cfg0[NUM_CONFIG_SLOTS_SPU0];

    IfxSpu_cfg1_sortadc(&cfg0[0], 1, rdr->spu0);

    IfxSpu_CtrlConfig ctrlConfig[1];

    ctrlConfig[0].clkDiv            = IfxSpu_ClockDivisionRatio_unity;
    ctrlConfig[0].crossTrigger      = FALSE;
    ctrlConfig[0].attentionRequest  = FALSE;
    ctrlConfig[0].trigger           = TRUE;
    ctrlConfig[0].mode              = IfxSpu_TriggerMode_software;

    IfxSpu_setupConfigSequence(rdr->spu0, 1, 0, &ctrlConfig[0]);
    odp_conf.U = rdr->cmem0->slots[0].BE[0].ODP_CONF.U;

    /*measured and scaled 0 deg calibration values*/
    const csint32 calibVector[RADAR_NUM_VRX] = {
    {0x43A2144C, 0x00000000},
    {0xF56315F0, 0xFFAB0938},
    {0xF714E720, 0xF6E86595},
    {0x06F44AED, 0xF5364B4A},
    {0xD8778FD8, 0x078C1C98},
    {0x12C01D8E, 0xFF83501F},
    {0x716A3B36, 0x7FFFFFFF},
    {0xE9FEBD60, 0x274E27AC},
    };


    uint16 filter[RADAR_FFT2_LEN/2];

    /*write phase FFT filter values*/
    for (int in=0;in<RADAR_FFT2_LEN;in++)
    {
        if(in > PHASE_FFT_FILTER_BIN_MIN && in < PHASE_FFT_FILTER_BIN_MAX)
        {
            filter[in]=1;
        }
        else
        {
            filter[in]=0;
        }
    }

    /*write window functions of TxRx specific calibration constants to CMEM*/
    for (int ix=0;ix<8;ix++)
    {
        IfxSpu_CalibWin_init(&rdr->cmem0->calibWndw[ix], RADAR_NUM_SAMPLES, &rWnd_Hann[0], FALSE, TRUE, TRUE, calibVector[ix].real, calibVector[ix].imag);
    }
    IfxSpu_CalibWin_init(&rdr->cmem0->filter[0], RADAR_FFT2_LEN, &filter[0], FALSE, FALSE, FALSE, 0, 0);

    /* set up configuration slots */
    IfxSpu_cfg2_rFFT              (&cfg0[1],     2, rdr->spu0);  /* slotNr is 1-based [1-128] */
    IfxSpu_cfg3_microDopplerBuffer(&cfg0[3],     4, rdr->spu0);  /* slotNr is 1-based [1-128] */
    IfxSpu_cfg4_sum_ramps         (&cfg0[4],     5, rdr->spu0);  /* slotNr is 1-based [1-128] */
    IfxSpu_cfg5_avg               (&cfg0[5],     6, rdr->spu0);
    IfxSpu_cfg6_avg32to16         (&cfg0[6],     7, rdr->spu0);
    IfxSpu_cfg7_reshape           (&cfg0[7],     8, rdr->spu0);
    IfxSpu_cfg8_sub               (&cfg0[8],     9, rdr->spu0);
    IfxSpu_cfg9_aCFAR             (&cfg0[9],     10, rdr->spu0);
    IfxSpu_cfg10_rCFAR            (&cfg0[10],     11, rdr->spu0);
    IfxSpu_cfg11_rThreshLM        (&cfg0[11],     12, rdr->spu0);
    IfxSpu_cfg12_aThreshLM        (&cfg0[12],     13, rdr->spu0);
    IfxSpu_cfg13_pFFT             (&cfg0[13],     14, rdr->spu0);
    IfxSpu_cfg14_filter           (&cfg0[14],    15, rdr->spu0);

    /*frame processing (range FFT with calibration, sum across ramps, writing to micro doppler buffer)*/
    IfxSpu_setupConfigSequence(rdr->spu0, 2, 4, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 4, 5, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 5, 0, &ctrlConfig[0]);

    /*clutter removal on micro doppler frame*/
    IfxSpu_setupConfigSequence(rdr->spu0, 6, 7, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 7, 8, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 8, 9, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 9, 0, &ctrlConfig[0]);

    /*detections*/
    IfxSpu_setupConfigSequence(rdr->spu0, 10, 11, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 11, 12, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 12, 13, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 13, 0, &ctrlConfig[0]);

    /*phase FFT for breathing rate detection*/
    IfxSpu_setupConfigSequence(rdr->spu0, 14, 15, &ctrlConfig[0]);
    IfxSpu_setupConfigSequence(rdr->spu0, 15, 0, &ctrlConfig[0]);
}


/*
 ******************************************************************************
 * Brief:   The routine void ISR_spu0_lld(void)
 * Details: This routine is the ISR for linked list done event
 ******************************************************************************
 */
void ISR_spu0_lld()
{

    Radar *rdr = &g_rdr;
    rdr->spuOk++;
}

/*
 ******************************************************************************
 * Brief:   The volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerInt(Ifx_SPU *spu)
 * Details: This routine returns the address of SPU interrupt service node
 ******************************************************************************
 */
IFX_INLINE volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerInt(Ifx_SPU *spu)
{
    return &MODULE_SRC.SPU.SPU[IfxSpu_getIndex(spu)].INT;
}

/*
 ******************************************************************************
 * Brief:   The routine IfxSpu_CalibWin_init writes window data scaled with
 * calibration values per antenna to CMEM so that it can be used by SPU
 ******************************************************************************
 */
void IfxSpu_CalibWin_init(void *cmem_wnd, uint32 N, const void *wnd, boolean highres, boolean complex, boolean antenna_calib, const sint32 calib_factor_real, const sint32 calib_factor_imag)
{
    /* NOTE: CMEM MUST BE WRITTEN IN 32-BIT CHUNKS! */
    uint32  ix;
    uint32  iy;
    uint32 *out = cmem_wnd;
    const uint16 *in16  = wnd;
    const uint32 *in  = wnd;

    if (highres==TRUE && complex==FALSE)
    {
        iy = N;
    }
    else if (highres==TRUE && complex==TRUE)
    {
        iy = N<<1;
    }
    else if (highres==FALSE && complex==TRUE)
    {
        iy = N;
    }
    else
    {
        iy = N>>1;
    }

    for (ix=0;ix<iy;ix++)
    {
        if (antenna_calib ==FALSE)
        {
        *out++ = *in++;
        }
        else
        {
          /*32 bit complex window output - calibration and hanning window product*/
          volatile sint32 int16to32 = (sint32)*in16;
          *out++ = calib_factor_real/32768*int16to32;/*scaled to 32bit*/
          *out++ = calib_factor_imag/32768*int16to32;/*scaled to 32bit*/
          in16++;
        }

    }
}
