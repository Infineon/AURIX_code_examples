/**********************************************************************************************************************
 * \file IfxSpu_cfg13_pFFT
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include <Src/Configurations/IfxRadar_cfg.h>
#include <Src/Spu/IfxSpu_Init.h>
#include "IfxEmem_cfg.h"
#include "IfxSpu_cfg.h"

/*This SPU config performas a FFT across micro doppler bins and rejects one half of the spectrum */

IfxSpu_ConfigSlot *IfxSpu_cfg13_pFFT(IfxSpu_SlotConfig *cfg, uint32 slotNr, Ifx_SPU *spu)
{
    IfxSpu_ConfigSlot* slot = IfxSpu_getConfigSlot(spu, slotNr);

    /** ------------ GLOBAL ------------ */
    /* PASS MODE */
    IfxSpu_setPassMode(slot, IfxSpu_PassMode_single);

    /* INPUT SOURCE */
    uint32 bin_size_bytes = sizeof(sint32);
    cfg->input.dataSource             = IfxSpu_DataSource_emem;
    cfg->input.rm.baseAddress         = IFX_OFFSETOF(SPU_Rmem_Map_t, PHI[0]);
    cfg->input.rm.dataFormat          = IfxSpu_RM_InputDataFormat_real32Bit;

    cfg->input.rm.antennaMapping     = IfxSpu_RM_AntennaMapping_default;
    cfg->input.rm.addressingMode     = IfxSpu_RM_AddressingMode_linear;
    cfg->input.rm.processingMode     = IfxSpu_RM_ProcessingMode_default;

    cfg->input.rm.numBlocks          = 0;

    cfg->input.rm.binLoopRepeat       = RADAR_NUM_MICRO_DOPPLER;
    cfg->input.rm.innerLoopRepeat     = 1;
    cfg->input.rm.outerLoopRepeat     = DEMO_MAX_TARGETS;

    cfg->input.rm.binLoopOffset       = bin_size_bytes;
    cfg->input.rm.innerLoopOffset     = bin_size_bytes * RADAR_NUM_MICRO_DOPPLER;
    cfg->input.rm.outerLoopOffset     = bin_size_bytes * RADAR_NUM_MICRO_DOPPLER;
    IfxSpu_setupInput(slot, &cfg->input);

    /* LOCAL MAX */
    IfxSpu_setupLocalMax(slot, NULL_PTR);

    /* BIN REJECTION */
    cfg->binrej.mode            = IfxSpu_BinRejection_Mode_reject;
    cfg->binrej.numAllowedBins  = RADAR_FFT2_LEN/2;
    cfg->binrej.leftJustify     = FALSE;
    cfg->binrej.thresholdEnabled = FALSE;
    IfxSpu_setupBinRejection(slot, &cfg->binrej);

    /* NCI WEIGHTS */
    IfxSpu_setupNciWeights(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* MAGNITUDE */
    IfxSpu_setupMagnitude(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* CFAR (CA/GOS) */
    IfxSpu_setupCfarCA(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    IfxSpu_setupCfarGOS(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */


    /** ------------ PASS 0 ------------ */
    {
        IfxSpu_PassId passId         = IfxSpu_PassId_0;
        IfxSpu_PassConfig* pcfg0     = &cfg->pass[passId];

        /* MATH1 */
        pcfg0->math1.loaderExponent         = 0;
        pcfg0->math1.numDropFirstSamples    = 0;
        pcfg0->math1.numDropLastSamples     = 0;
        pcfg0->math1.numPadFrontSamples     = 0;      /*zeros are automatically added at the end to match FFT length*/
        pcfg0->math1.window.enabled         = FALSE;
        pcfg0->math1.window.baseAddress     = 0;
        pcfg0->math1.window.dataFormat      = IfxSpu_WindowDataFormat_real32;
        pcfg0->math1.phaseShift             = IfxSpu_PhaseShift_0;
        for(uint32 antNr=0; antNr<RADAR_NUM_RX; antNr++)
        {
            pcfg0->math1.window.antennaOffsets[antNr] = 0;
        }
        IfxSpu_setupMath1(slot, passId, &pcfg0->math1);

        /* FFT */
        pcfg0->fft.enabled          = TRUE;
        pcfg0->fft.inversed         = FALSE;
        pcfg0->fft.size             = IfxSpu_getSizeCode(RADAR_FFT2_LEN);
        pcfg0->fft.dataFormat       = IfxSpu_FftDataFormat_complex32Bit;
        pcfg0->fft.exponent         = 12;
        pcfg0->fft.forceToReal      = FALSE;
        IfxSpu_setupFft(slot, passId, &pcfg0->fft);

        /* FFT OUTPUT */
        pcfg0->fftOut.enabled         = TRUE;
        pcfg0->fftOut.baseAddress     = IFX_OFFSETOF(SPU_Rmem_Map_t, rr_spectrum[0]);
        pcfg0->fftOut.format          = IfxSpu_ODP_Format_complex32Bit;
        pcfg0->fftOut.exponent        = 0;
        pcfg0->fftOut.inPlace         = FALSE;
        IfxSpu_setupFftOutput(slot, passId, &pcfg0->fftOut);

        /*CFAR*/
        IfxSpu_setupCfar(slot, passId, NULL_PTR);

        /* MATH2 */
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);

        IfxSpu_setupLog2PowerSummation(slot, passId, NULL_PTR);

        IfxSpu_setupNci(slot, passId, NULL_PTR);

        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);

        pcfg0->statistics.baseAddress = IFX_OFFSETOF(SPU_Rmem_Map_t, stat_br[0]);
        pcfg0->statistics.enabled = TRUE;
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR);

        IfxSpu_setupSummation(slot, passId, NULL_PTR);
    }

    /** ------------ PASS 1 ------------ */
    {
        IfxSpu_PassId passId = IfxSpu_PassId_1;

        /* Due to mirrored registers, the alternate pass uses same configuration as main pass */
        IfxSpu_setupMath1(slot, passId, &cfg->pass[0].math1);
        IfxSpu_setupFft(slot, passId, &cfg->pass[0].fft);

        IfxSpu_setupFftOutput(slot, passId, NULL_PTR);
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupNci(slot, passId, NULL_PTR);                /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupCfar(slot, passId, NULL_PTR);               /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    }

    return slot;
}
