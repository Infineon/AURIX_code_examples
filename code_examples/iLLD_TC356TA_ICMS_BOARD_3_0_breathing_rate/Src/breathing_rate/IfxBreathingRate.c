/**********************************************************************************************************************
 * \file IfxBreathingRate.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include <IfxBreathingRate.h>
#include "dsplib.h"

/*helper sign function*/
sint32 sign(sint32 x) {
    return (x > 0) - (x < 0);
}

/*this function calculates the phase and performs phase unwrapping*/
void phaseExtraction(void)
{
    Radar *rdr = &g_rdr;
    uint16 md, i;
    sint16 re16, im16;

    sint32 DF;

    volatile float32 th_f = M_PI*8192;
    sint32 th = (sint32)th_f;   /*decision threshold for phase unwrapping scaled with 2^13 to match format*/
    float32 twoPiScaled_f = 2*M_PI*8192;/*2^13 = 8192*/
    sint32 twoPiScaled = (sint32)twoPiScaled_f;   /*2pi scaled with 2^13 (3q13 format) for phase unwrapping*/

    for(i = 0; i<rdr->det_targets.count; i++){
        for(md = 0; md < RADAR_NUM_MICRO_DOPPLER; md++)
        {
            /*microDoppler frames are scaled with 65 to be able to cast them into integers for phase extraction*/
            re16 = (sint16) rdr->rmem->microDopplerbeamformed[i][md].real;
            im16 = (sint16) rdr->rmem->microDopplerbeamformed[i][md].imag;
            rdr->rmem->phaseData[i][md] = Ifx_atan2Q15(im16, re16);/*output value of Ifx_atan2Q15()(3q13 format)*/
        }
        rdr->rmem->PHI[i][0]=(sint32) rdr->rmem->phaseData[i][1];
        /*phase unwrapping for every range gate*/
        for (md = 1; md < RADAR_NUM_MICRO_DOPPLER; md++)
        {
            /*DF is the difference to the next element*/
            DF = rdr->rmem->phaseData[i][md] - rdr->rmem->phaseData[i][md-1];
            /*if the absolute value of the difference is greater than the threshold*/
            if (DF > th)
            {
                DF = DF - twoPiScaled;
            }
            else if(DF < -th)
            {
                DF = DF + twoPiScaled;
            }
            rdr->rmem->PHI[i][md] = rdr->rmem->PHI[i][md-1] +DF;
        }
    }
}

/*this function calculates the mean of the signal and subtracts it to remove DC offset*/
void subtract_mean(void)
{
    Radar * rdr = &g_rdr;
    uint16 md, i;
    sint32 mean;
    for(i = 0; i < rdr->det_targets.count; i++){
        for(md = 0; md < RADAR_NUM_MICRO_DOPPLER+1; md++){
            mean += rdr->rmem->PHI[i][md];
        }
        mean = (mean/(RADAR_NUM_MICRO_DOPPLER+1));
        for(md = 0; md < RADAR_NUM_MICRO_DOPPLER+1; md++){
            rdr->rmem->PHI[i][md] = rdr->rmem->PHI[i][md] - mean;
        }
    }
}

/*this function calculates the breathing rate from the identified maximum peak in the phase FFT result*/
void calculate_respiration_rate(void)
{
    Radar * rdr = &g_rdr;
    float32 fs;
    fs = 1000/(float)RADAR_CYCLE_MS;
    uint8 i;
    for(i = 0; i < rdr->det_targets.count; i++)
    {
        rdr->det_targets.targets[i].breathingRate = (rdr->rmem->stat_br[i].max_idx + 1) * (fs / RADAR_FFT2_LEN) * 60;
    }

}
