/**
 * \file IfxScrI2c.c
 * \brief SCR I2c basic functionality
 * \ingroup IfxLld_ScrI2c
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2022 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxScrI2c.h"

/******************************************************************************/
/*-----------------------Exported Variables/Constants-------------------------*/
/******************************************************************************/
IFX_CONST IfxScrI2c_BaudrateConfig i2cbaudrateLookup[] = {
    {IfxScrI2c_PreDiv_2, IfxScrI2c_Prescaler_4 },                                        /* For fpclk = 20Mhz, fscl = 100Khz */
    {IfxScrI2c_PreDiv_2, IfxScrI2c_Prescaler_8 },                                        /* For fpclk = 33.3Mhz, fscl = 92.5Khz */
    {IfxScrI2c_PreDiv_2, IfxScrI2c_Prescaler_12},                                        /* For fpclk = 50Mhz, fscl = 96.15Khz */
    {IfxScrI2c_PreDiv_4, IfxScrI2c_Prescaler_6 },                                        /* For fpclk = 100Mhz, fscl = 89.2Khz */
    {IfxScrI2c_PreDiv_1, IfxScrI2c_Prescaler_2 },                                        /* For fpclk = 20Mhz, fscl = 333.3Khz */
    {IfxScrI2c_PreDiv_1, IfxScrI2c_Prescaler_4 },                                        /* For fpclk = 33.3Mhz, fscl = 333Khz */
    {IfxScrI2c_PreDiv_1, IfxScrI2c_Prescaler_6 },                                        /* For fpclk = 50Mhz, fscl = 357.14Khz */
    {IfxScrI2c_PreDiv_1, IfxScrI2c_Prescaler_12},                                        /* For fpclk = 100Mhz, fscl = 384.16Khz */
};

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxScrI2c_initConfig(IfxScrI2c_Config *i2cConfig)
{
    i2cConfig->baudRate   = i2cbaudrateLookup[IfxScrI2c_Baudrate_100khz];
    i2cConfig->deviceAddr = 0u;
    i2cConfig->sclSel     = IfxScrI2c_Scl_A;
    i2cConfig->sdaSel     = IfxScrI2c_Sda_A;
    i2cConfig->sdaPinCfg  = NULL_PTR;
    i2cConfig->sclPinCfg  = NULL_PTR;
}


void IfxScrI2c_init(IfxScrI2c_Config *i2cConfig)
{
    /* 1. Enable I2c module */
    IfxScrScu_enableModule(IfxScrScu_Module_i2c);

    /* 2. Select baudrate */
    SCR_I2C_BRCR.U = (i2cConfig->baudRate.preScaler << IFX_SCR_I2C_BRCR_BRP_OFF) | (i2cConfig->baudRate.predivider);

    /* 3. Configure device address */
    IfxScrI2c_configureSlaveAddress(i2cConfig->deviceAddr);

    /* 4. Pin configuration */
    IfxScrI2c_selectScl(i2cConfig->sclSel);
    IfxScrI2c_selectSda(i2cConfig->sdaSel);

    /* Sda pin configuration */
    if (i2cConfig->sdaPinCfg != NULL_PTR)
    {
        IfxScrPort_configurePin(i2cConfig->sdaPinCfg);
    }

    /* Scl pin configuration */
    if (i2cConfig->sclPinCfg != NULL_PTR)
    {
        IfxScrPort_configurePin(i2cConfig->sclPinCfg);
    }

    /* 4. Enable I2c */
    IfxScrI2c_enable(TRUE);
}


IfxScrI2c_Status IfxScrI2c_masterSendData(uint8 *txbuffer, uint16 len, uint16 slaveAddress)
{
    volatile IfxScrI2c_Status status;
    uint8            index = 0u;

    /* 1. Transmit a start condition */
    IfxScrI2c_transmitStart();

    /* 2. Check if start condition is correctly generated */
    while (IfxScrI2c_Status_startCondtx != IfxScrI2c_getStatusCode())
    {}

    /* 3. Load slave address(7/10 bit) in data register with write bit to specify transmit mode */
    IfxScrI2c_sendAddress(slaveAddress, FALSE);
    do
    {
    status = IfxScrI2c_getStatusCode();
    }while ((IfxScrI2c_Status_addrAndWriteBitTxAckRx != status) && (IfxScrI2c_Status_addrAndWriteBitTxAckNotRx != status));

    /* 5. Continue sending data */
    for (index = 0u; index < len; index++)
    {
        SCR_I2C_DATA.U = txbuffer[index];
        /* Clear IFLG bit to continue transfer */
        IfxScrI2c_clearInterrupt();
        do
        {
            status = IfxScrI2c_getStatusCode();
        }while ((IfxScrI2c_Status_dataTxMasterModeAckRx != status) && (IfxScrI2c_Status_dataTxMasterModeAckNotRx != status));
    }

    /* 6. Transmit stop condition */
    IfxScrI2c_transmitStop();

    /* 7. Clear IFLG bit to continue transfer */
    IfxScrI2c_clearInterrupt();

    /* 8. I2c should return to idle state  */
    status = IfxScrI2c_getStatusCode();

    return status;
}


IfxScrI2c_Status IfxScrI2c_masterReceiveData(uint8 *rxBuffer, uint16 len, uint16 slaveAddress)
{
    volatile IfxScrI2c_Status status;
    uint16           index = 0u;

    /* 1. Transmit a start condition */
    IfxScrI2c_transmitStart();

    /* 2. Check if start condition is correctly generated */
    while (IfxScrI2c_Status_startCondtx != IfxScrI2c_getStatusCode())
    {}

    /* 3. Load slave address(7/10 bit) in data register with read bit to specify receive mode */
    IfxScrI2c_sendAddress(slaveAddress, TRUE);

    /* 4. Wait untill address phase is completed */
    while (IfxScrI2c_Status_addrAndReadBitTxAckRx != IfxScrI2c_getStatusCode())
    {}

    /* Clear IFLG bit to continue transfer */
    IfxScrI2c_clearInterrupt();

    /* 5. Continue receiving data */
    for (index = len; index > 0u; index--)
    {
        // Set NACK or ACK
        if (index == 1u)
        {
            /* Send nack for the last date */
            IfxScrI2c_assertNack();
        }
        else
        {
            /* Asser ACK bit */
            IfxScrI2c_assertAck();
        }
    	do
    	{
        status = IfxScrI2c_getStatusCode();
    	}while ((IfxScrI2c_Status_dataRxMasterModeAckTx != status) && (IfxScrI2c_Status_dataRxMasterModeAckNotTx != status));

        *rxBuffer = SCR_I2C_DATA.U;

        if(status == IfxScrI2c_Status_dataRxMasterModeAckNotTx)
        {
            /* Transmit stop condition */
            IfxScrI2c_transmitStop();
        }

        /* Clear IFLG bit to continue reception */
        IfxScrI2c_clearInterrupt();
        /* Increment buffer address */
        rxBuffer++;
    }

    /* 8. I2c should return to idle state  */
    status = IfxScrI2c_getStatusCode();

    return status;
}


IfxScrI2c_Status IfxScrI2c_slaveSendData(uint8 *txBuffer, uint16 len)
{
    uint16           index = 0u;
    IfxScrI2c_Status status;

    /* Slave address and read bit is received.
     * I2c transmits Ack bit and set status code as Slave address and read bit received, ACK transmitted
     * Wait for status code to 0xA8
     */
	do
	{
		status = IfxScrI2c_getStatusCode();
	}while (IfxScrI2c_Status_slaveAndReadBitRxAckTx != status);

    for (index = len; index > 1u; index--)
    {
        /* Load data into register */
        SCR_I2C_DATA.U = *txBuffer;
        /* Clear IFLG bit */
        IfxScrI2c_clearInterrupt();

        /* Wait until the data byte transmitted in slave mode, ACK received */
        while (IfxScrI2c_Status_dataByteTxSlaveModeAckRx != IfxScrI2c_getStatusCode())
        {}

        txBuffer++;
    }

    /* Load last data byte in register */
    SCR_I2C_DATA.U = *txBuffer;

    /* Send nack for the last data */
    IfxScrI2c_assertNack();

    /* Clear IFLG bit */
    IfxScrI2c_clearInterrupt();

    /* Wait until the last byte transmitted in slave mode, ACK received */
    while (IfxScrI2c_Status_lastByteTxSlaveModeAckRx != IfxScrI2c_getStatusCode())
    {}

    status = IfxScrI2c_getStatusCode();

    return status;
}


IfxScrI2c_Status IfxScrI2c_slaveReceiveData(uint8 *rxBuffer, uint16 len)
{
    uint16           index = 0u;
    IfxScrI2c_Status status;

    /* Slave address and Write bit is received.
     * I2c transmits Ack bit and set status code as Slave address and write bit received, ACK transmitted
     * Wait for status code to 0x60 or 0x70 for general call address
     */
	do
	{
		status = IfxScrI2c_getStatusCode();
	}while ((IfxScrI2c_Status_slaveAddrAndWriteBitRxAckTx != status) && (IfxScrI2c_Status_genCallAddressRxAckTx != status));

    /* Clear IFLG bit to continue transfer*/
    IfxScrI2c_clearInterrupt();

    /* Wait for the status code to become 0x80.
     * Data byte received after slave address received, Ack transmitted (0x80)
     * Data byte received after general call address, Ack transmitted (0x90)
     */
    do
    {
    	status = IfxScrI2c_getStatusCode();
    }while ((IfxScrI2c_Status_dataRxAfterSlaveAddrRxAckTx != status) && (IfxScrI2c_Status_dataRxAfterGenCallAddRxAckTx != status));

    for (index = 0u; index < len; index++)
    {
        *rxBuffer = SCR_I2C_DATA.U;
        /* Clear IFLG bit */
        IfxScrI2c_clearInterrupt();
    }

    /* Wait for status code to set 0xA0, STOP or repeated START mode received in slave mode */
    do
    {
    	status = IfxScrI2c_getStatusCode();
    }while (IfxScrI2c_Status_stopOrRepeatedStartRx != status);

    /* Clear IFLG bit */
    IfxScrI2c_clearInterrupt();

    status = IfxScrI2c_getStatusCode();
    return status;
}
