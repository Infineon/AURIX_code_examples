/**
 * \file IfxCanxl.h
 * \brief CANXL  basic functionality
 * \ingroup IfxLld_Canxl
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Canxl_Std_Enum Enumerations
 * \ingroup IfxLld_Canxl_Std
 * \defgroup IfxLld_Canxl_Std_Structures_Tx_Header TX Header structures
 * \ingroup IfxLld_Canxl_Std
 * \defgroup IfxLld_Canxl_Std_Structures Data Structures
 * \ingroup IfxLld_Canxl_Std
 * \defgroup IfxLld_Canxl_Std_Structures_Rx_Header RX Header structures
 * \ingroup IfxLld_Canxl_Std
 * \defgroup IfxLld_Canxl_Std_Structures_Tx_Descriptors TX Descriptor Structures
 * \ingroup IfxLld_Canxl_Std
 * \defgroup IfxLld_Canxl_Std_Structures_Rx_Descriptors RX Descriptor Structures
 * \ingroup IfxLld_Canxl_Std
 * \defgroup IfxLld_Canxl_Std_Functions General Functions
 * \ingroup IfxLld_Canxl_Std
 * \defgroup IfxLld_Canxl_Std_Functions_Node Canxl Node level functions
 * \ingroup IfxLld_Canxl_Std
 */

#ifndef IFXCANXL_H
#define IFXCANXL_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxCanxl_cfg.h"
#include "_PinMap/IfxCanxl_PinMap.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "IfxCanxl_bf.h"
#include "Src/Std/IfxSrc.h"
#include "Clock/Std/IfxClock.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Macro that calculates PWM Symbol length (PWMS + PWML + 2)
 */
#define IFXCANXL_CALC_PWM_SYMBOL_LENGTH(shortPhase, longPhase) ((uint16)shortPhase + (uint16)longPhase + 2u)

/** \brief Macro that checks 32 bit multiplicity of input data byte size
 */
#define IFXCANXL_CHECK_INPUT_BYTE_SIZE(x)                      (((x & (uint32)(4 - 1)) == (uint32)0))

/** \brief Macro that calculates 32 bit  memory words from input byte size
 */
#define IFXCANXL_CALC_WORDS_FROM_BYTES(x)                      (IFXCANXL_CHECK_INPUT_BYTE_SIZE(x) ? (uint32)(x >> 2U) : (uint32)((x >> 2U) + 1U))

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Canxl_Std_Enum
 * \{ */
/** \brief Data Length code of the CAN Classic and FD Message
 */
typedef enum
{
    IfxCanxl_DataLengthCode_0 = 0,  /**< \brief 0 data bytes */
    IfxCanxl_DataLengthCode_1,      /**< \brief 1 data bytes */
    IfxCanxl_DataLengthCode_2,      /**< \brief 2 data bytes */
    IfxCanxl_DataLengthCode_3,      /**< \brief 3 data bytes */
    IfxCanxl_DataLengthCode_4,      /**< \brief 4 data bytes */
    IfxCanxl_DataLengthCode_5,      /**< \brief 5 data bytes */
    IfxCanxl_DataLengthCode_6,      /**< \brief 6 data bytes */
    IfxCanxl_DataLengthCode_7,      /**< \brief 7 data bytes */
    IfxCanxl_DataLengthCode_8,      /**< \brief 8 data bytes */
    IfxCanxl_DataLengthCode_12,     /**< \brief 12 data bytes */
    IfxCanxl_DataLengthCode_16,     /**< \brief 16 data bytes */
    IfxCanxl_DataLengthCode_20,     /**< \brief 20 data bytes */
    IfxCanxl_DataLengthCode_24,     /**< \brief 24 data bytes */
    IfxCanxl_DataLengthCode_32,     /**< \brief 32 data bytes */
    IfxCanxl_DataLengthCode_48,     /**< \brief 48 data bytes */
    IfxCanxl_DataLengthCode_64      /**< \brief 64 data bytes */
} IfxCanxl_DataLengthCode;

/** \brief CAN Frame formats
 */
typedef enum
{
    IfxCanxl_FrameMode_classic = 0,  /**< \brief Classic CAN */
    IfxCanxl_FrameMode_fd      = 2,  /**< \brief CAN FD */
    IfxCanxl_FrameMode_xl      = 3   /**< \brief CAN XL */
} IfxCanxl_FrameMode;

/** \brief Max number of possible DMA AXI transactions
 */
typedef enum
{
    IfxCanxl_MaxAxiTransactions_none = 0,  /**< \brief No transfer. DMA doesn't do any read/write */
    IfxCanxl_MaxAxiTransactions_1,         /**< \brief 1 outstanding transaction */
    IfxCanxl_MaxAxiTransactions_2,         /**< \brief 2 outstanding transaction */
    IfxCanxl_MaxAxiTransactions_3          /**< \brief 3 outstanding transaction */
} IfxCanxl_MaxAxiTransactions;

/** \brief Maximum number of TX message re-transmissions
 */
typedef enum
{
    IfxCanxl_MaxMsgRetransmissions_none      = 0, /**< \brief No re-transmission */
    IfxCanxl_MaxMsgRetransmissions_1         = 1, /**< \brief 1 re-transmission */
    IfxCanxl_MaxMsgRetransmissions_2         = 2, /**< \brief 2 re-transmissions */
    IfxCanxl_MaxMsgRetransmissions_3         = 3, /**< \brief 3 re-transmissions */
    IfxCanxl_MaxMsgRetransmissions_4         = 4, /**< \brief 4 re-transmissions */
    IfxCanxl_MaxMsgRetransmissions_5         = 5, /**< \brief 5 re-transmissions */
    IfxCanxl_MaxMsgRetransmissions_6         = 6, /**< \brief 6 re-transmissions */
    IfxCanxl_MaxMsgRetransmissions_unlimited = 7  /**< \brief Unlimited re-transmissions */
} IfxCanxl_MaxMsgRetransmissions;

/** \brief Node activity as defined by Ni_STAT.ACT
 */
typedef enum
{
    IfxCanxl_NodeActivity_inactive    = 0, /**< \brief Inactive state */
    IfxCanxl_NodeActivity_idle        = 1, /**< \brief Idle state */
    IfxCanxl_NodeActivity_receiver    = 2, /**< \brief Receiver state */
    IfxCanxl_NodeActivity_transmitter = 3  /**< \brief Transmitter state */
} IfxCanxl_NodeActivity;

/** \brief CAN-XL Node Operation modes
 */
typedef enum
{
    IfxCanxl_Node_OperationMode_classical,            /**< \brief Supports only Classical CAN frame format */
    IfxCanxl_Node_OperationMode_classicalAndFd,       /**< \brief Supports Classical CAN and CAN FD frame format */
    IfxCanxl_Node_OperationMode_classicalAndFdAndXl,  /**< \brief Supports Classical CAN, CAN FD, and CAN XL frame formats, without XL transceiver */
    IfxCanxl_Node_OperationMode_xl,                   /**< \brief Supports CAN-XL frame format only, without XL transceiver, error frames are disabled for all communication */
    IfxCanxl_Node_OperationMode_xlWithTransciever     /**< \brief Supports CAN-XL frame format only, enabling XL transceiver, error frames are disabled for all communication */
} IfxCanxl_Node_OperationMode;

/** \brief Select OTGB Bus (OCS.B.TGB)
 */
typedef enum
{
    IfxCanxl_OtgbBusSelect_0 = 0,  /**< \brief Trigger Set is output on OTGB0 */
    IfxCanxl_OtgbBusSelect_1       /**< \brief Trigger Set is output on OTGB1 */
} IfxCanxl_OtgbBusSelect;

/** \brief Select Trigger Set for OTGB0/1 (OCS.B.TGS)
 */
typedef enum
{
    IfxCanxl_OtgbTriggerSet_none = 0,  /**< \brief No Trigger Set output */
    IfxCanxl_OtgbTriggerSet_HDP  = 1   /**< \brief CANXL_HDP16, The HW signals defined by DEBUG_TEST_CTRL.HDP_SEL */
} IfxCanxl_OtgbTriggerSet;

/** \brief CAN Protocol operations as defined in Ni_CTRL
 */
typedef enum
{
    IfxCanxl_ProtocolOperation_stop          = 1,    /**< \brief Stop CAN protocol operation */
    IfxCanxl_ProtocolOperation_immediateStop = 3,    /**< \brief Stop CAN protocol operation immediately */
    IfxCanxl_ProtocolOperation_start         = 16,   /**< \brief Start CAN protocol operation */
    IfxCanxl_ProtocolOperation_softwareReset = 256,  /**< \brief Software Reset */
    IfxCanxl_ProtocolOperation_test          = 4096  /**< \brief Enable Test Mode */
} IfxCanxl_ProtocolOperation;

/** \brief Memory organization of RX Data containers
 */
typedef enum
{
    IfxCanxl_RxDataContainer_normal     = 0, /**< \brief RX messages split over several data container and one or more RX descriptor is user per RX msg */
    IfxCanxl_RxDataContainer_continuous = 1  /**< \brief Single data container is defined per RX FIFO Queue and one RX descriptor is used per RX msg */
} IfxCanxl_RxDataContainer;

/** \brief RX DMA FIFO fill level
 */
typedef enum
{
    IfxCanxl_RxDmaFifoLevel_0,   /**< \brief RX DMA FIFO Level 0 */
    IfxCanxl_RxDmaFifoLevel_1,   /**< \brief RX DMA FIFO Level 1 */
    IfxCanxl_RxDmaFifoLevel_2,   /**< \brief RX DMA FIFO Level 2 */
    IfxCanxl_RxDmaFifoLevel_3,   /**< \brief RX DMA FIFO Level 3 */
    IfxCanxl_RxDmaFifoLevel_4,   /**< \brief RX DMA FIFO Level 4 */
    IfxCanxl_RxDmaFifoLevel_5,   /**< \brief RX DMA FIFO Level 5 */
    IfxCanxl_RxDmaFifoLevel_6,   /**< \brief RX DMA FIFO Level 6 */
    IfxCanxl_RxDmaFifoLevel_7,   /**< \brief RX DMA FIFO Level 7 */
    IfxCanxl_RxDmaFifoLevel_8,   /**< \brief RX DMA FIFO Level 8 */
    IfxCanxl_RxDmaFifoLevel_9,   /**< \brief RX DMA FIFO Level 9 */
    IfxCanxl_RxDmaFifoLevel_10,  /**< \brief RX DMA FIFO Level 10 */
    IfxCanxl_RxDmaFifoLevel_11,  /**< \brief RX DMA FIFO Level 11 */
    IfxCanxl_RxDmaFifoLevel_12,  /**< \brief RX DMA FIFO Level 12 */
    IfxCanxl_RxDmaFifoLevel_13,  /**< \brief RX DMA FIFO Level 13 */
    IfxCanxl_RxDmaFifoLevel_14,  /**< \brief RX DMA FIFO Level 14 */
    IfxCanxl_RxDmaFifoLevel_15,  /**< \brief RX DMA FIFO Level 15 */
    IfxCanxl_RxDmaFifoLevel_16,  /**< \brief RX DMA FIFO Level 16 */
    IfxCanxl_RxDmaFifoLevel_17,  /**< \brief RX DMA FIFO Level 17 */
    IfxCanxl_RxDmaFifoLevel_18,  /**< \brief RX DMA FIFO Level 18 */
    IfxCanxl_RxDmaFifoLevel_19,  /**< \brief RX DMA FIFO Level 19 */
    IfxCanxl_RxDmaFifoLevel_20,  /**< \brief RX DMA FIFO Level 20 */
    IfxCanxl_RxDmaFifoLevel_21,  /**< \brief RX DMA FIFO Level 21 */
    IfxCanxl_RxDmaFifoLevel_22,  /**< \brief RX DMA FIFO Level 22 */
    IfxCanxl_RxDmaFifoLevel_23,  /**< \brief RX DMA FIFO Level 23 */
    IfxCanxl_RxDmaFifoLevel_24,  /**< \brief RX DMA FIFO Level 24 */
    IfxCanxl_RxDmaFifoLevel_25,  /**< \brief RX DMA FIFO Level 25 */
    IfxCanxl_RxDmaFifoLevel_26,  /**< \brief RX DMA FIFO Level 26 */
    IfxCanxl_RxDmaFifoLevel_27,  /**< \brief RX DMA FIFO Level 27 */
    IfxCanxl_RxDmaFifoLevel_28,  /**< \brief RX DMA FIFO Level 28 */
    IfxCanxl_RxDmaFifoLevel_29,  /**< \brief RX DMA FIFO Level 29 */
    IfxCanxl_RxDmaFifoLevel_30,  /**< \brief RX DMA FIFO Level 30 */
    IfxCanxl_RxDmaFifoLevel_31   /**< \brief RX DMA FIFO Level 31 */
} IfxCanxl_RxDmaFifoLevel;

/** \brief RX FIFO Queue Index
 */
typedef enum
{
    IfxCanxl_RxFifoQueue_0 = 0,  /**< \brief RX FIFO Queue Index 0 */
    IfxCanxl_RxFifoQueue_1 = 1,  /**< \brief RX FIFO Queue Index 1 */
    IfxCanxl_RxFifoQueue_2 = 2,  /**< \brief RX FIFO Queue Index 2 */
    IfxCanxl_RxFifoQueue_3 = 3,  /**< \brief RX FIFO Queue Index 3 */
    IfxCanxl_RxFifoQueue_4 = 4,  /**< \brief RX FIFO Queue Index 4 */
    IfxCanxl_RxFifoQueue_5 = 5,  /**< \brief RX FIFO Queue Index 5 */
    IfxCanxl_RxFifoQueue_6 = 6,  /**< \brief RX FIFO Queue Index 6 */
    IfxCanxl_RxFifoQueue_7 = 7   /**< \brief RX FIFO Queue Index 7 */
} IfxCanxl_RxFifoQueue;

/** \brief Status of the RX message received
 */
typedef enum
{
    IfxCanxl_RxMsgStatus_none        = 0,  /**< \brief None */
    IfxCanxl_RxMsgStatus_success     = 1,  /**< \brief message received successfully */
    IfxCanxl_RxMsgStatus_notFiltered = 2,  /**< \brief message received but not filtered */
    IfxCanxl_RxMsgStatus_parityError = 15  /**< \brief message acknowledged with parity error */
} IfxCanxl_RxMsgStatus;

/** \brief OCDS Suspend Control (OCS.B.SUS). Defines sensitivity to the suspend signal coming from the OCDS Trigger Switch (OTGS)
 */
typedef enum
{
    IfxCanxl_SuspendMode_none = 0,  /**< \brief Will not suspend */
    IfxCanxl_SuspendMode_hard = 1,  /**< \brief Hard Suspend. Clock is off immediately. */
    IfxCanxl_SuspendMode_soft = 2   /**< \brief Soft Suspend. Clock is switched off after completion of the ongoing transmission and reception events. */
} IfxCanxl_SuspendMode;

/** \brief Select Time stamp position (Ni_MODE.SFS)
 */
typedef enum
{
    IfxCanxl_TimeStampPosition_endOfFrame   = 0, /**< \brief Time Stamp taken at end of the frame */
    IfxCanxl_TimeStampPosition_startOfFrame = 1  /**< \brief Time Stamp taken at start of the frame */
} IfxCanxl_TimeStampPosition;

/** \brief Select prescaler for clock source (Ni_TS_CLOCK_CTL.PRESCALER)
 */
typedef enum
{
    IfxCanxl_TimebaseClockPrescaler_divBy0  = 0,   /**< \brief Divide option 0 */
    IfxCanxl_TimebaseClockPrescaler_divBy1  = 1,   /**< \brief Divide option 1 */
    IfxCanxl_TimebaseClockPrescaler_divBy2  = 2,   /**< \brief Divide option 2 */
    IfxCanxl_TimebaseClockPrescaler_divBy3  = 3,   /**< \brief Divide option 3 */
    IfxCanxl_TimebaseClockPrescaler_divBy4  = 4,   /**< \brief Divide option 4 */
    IfxCanxl_TimebaseClockPrescaler_divBy5  = 5,   /**< \brief Divide option 5 */
    IfxCanxl_TimebaseClockPrescaler_divBy6  = 6,   /**< \brief Divide option 6 */
    IfxCanxl_TimebaseClockPrescaler_divBy7  = 7,   /**< \brief Divide option 7 */
    IfxCanxl_TimebaseClockPrescaler_divBy8  = 8,   /**< \brief Divide option 8 */
    IfxCanxl_TimebaseClockPrescaler_divBy9  = 9,   /**< \brief Divide option 9 */
    IfxCanxl_TimebaseClockPrescaler_divBy10 = 10,  /**< \brief Divide option 10 */
    IfxCanxl_TimebaseClockPrescaler_divBy11 = 11,  /**< \brief Divide option 11 */
    IfxCanxl_TimebaseClockPrescaler_divBy12 = 12,  /**< \brief Divide option 12 */
    IfxCanxl_TimebaseClockPrescaler_divBy13 = 13,  /**< \brief Divide option 13 */
    IfxCanxl_TimebaseClockPrescaler_divBy14 = 14,  /**< \brief Divide option 14 */
    IfxCanxl_TimebaseClockPrescaler_divBy15 = 15   /**< \brief Divide option 15 */
} IfxCanxl_TimebaseClockPrescaler;

/** \brief Select clock source for timebase generation (Ni_TS_CLOCK_CTL.SRC_SEL)
 */
typedef enum
{
    IfxCanxl_TimebaseClockSource_canInternal = 0,  /**< \brief Host clock (fCANXLH) */
    IfxCanxl_TimebaseClockSource_stm         = 1,  /**< \brief External 0 (STM Trigger) */
    IfxCanxl_TimebaseClockSource_gtm         = 2,  /**< \brief External 1 (GTM Trigger) */
    IfxCanxl_TimebaseClockSource_egtm        = 3   /**< \brief External 2 (eGTM Trigger) */
} IfxCanxl_TimebaseClockSource;

/** \brief TX FIFO Queue Index
 */
typedef enum
{
    IfxCanxl_TxFifoQueue_0 = 0,  /**< \brief TX FIFO Queue Index 0 */
    IfxCanxl_TxFifoQueue_1 = 1,  /**< \brief TX FIFO Queue Index 1 */
    IfxCanxl_TxFifoQueue_2 = 2,  /**< \brief TX FIFO Queue Index 2 */
    IfxCanxl_TxFifoQueue_3 = 3,  /**< \brief TX FIFO Queue Index 3 */
    IfxCanxl_TxFifoQueue_4 = 4,  /**< \brief TX FIFO Queue Index 4 */
    IfxCanxl_TxFifoQueue_5 = 5,  /**< \brief TX FIFO Queue Index 5 */
    IfxCanxl_TxFifoQueue_6 = 6,  /**< \brief TX FIFO Queue Index 6 */
    IfxCanxl_TxFifoQueue_7 = 7   /**< \brief TX FIFO Queue Index 7 */
} IfxCanxl_TxFifoQueue;

/** \brief XCAN TX Queue Type
 */
typedef enum
{
    IfxCanxl_TxQueueType_fifo,     /**< \brief TX FIFO Queue */
    IfxCanxl_TxQueueType_priority  /**< \brief TX Priority Queue */
} IfxCanxl_TxQueueType;

/** \brief RX filter header frame in CANXL msg frame
 */
typedef enum
{
    IfxCanxl_frameHeaderWord_None,  /**< \brief CANXL frame header word None */
    IfxCanxl_frameHeaderWord_R0,    /**< \brief CANXL frame header word R0 */
    IfxCanxl_frameHeaderWord_R1,    /**< \brief CANXL frame header word R1 */
    IfxCanxl_frameHeaderWord_R2     /**< \brief CANXL frame header word R2 */
} IfxCanxl_frameHeaderWord;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Canxl_Std_Structures_Tx_Header
 * \{ */
/** \brief CAN Classical TX Header 0
 */
typedef struct
{
    uint32 ExtID : 18;        /**< \brief Extended ID */
    uint32 BaseID : 11;       /**< \brief Base ID */
    uint32 XTD : 1;           /**< \brief Extended Identifier */
    uint32 XLF : 1;           /**< \brief XL Format */
    uint32 FDF : 1;           /**< \brief FD Format */
} IfxCanxl_ClassicalTxHeader0_Bits;

/** \brief CAN Classical TX Header 1
 */
typedef struct
{
    uint32 reserved_0 : 16;       /**< \brief Reserved */
    uint32 DLC : 4;               /**< \brief Data Length Code */
    uint32 reserved_20 : 6;       /**< \brief Reserved */
    uint32 RTR : 1;               /**< \brief Remote Transmission Request */
    uint32 reserved_27 : 3;       /**< \brief FD Format */
    uint32 FIR : 1;               /**< \brief Fault Injection Request */
    uint32 reserved_31 : 1;       /**< \brief Reserved */
} IfxCanxl_ClassicalTxHeader1_Bits;

/** \brief CAN FD TX Header 0
 */
typedef struct
{
    uint32 ExtID : 18;        /**< \brief Extended ID */
    uint32 BaseID : 11;       /**< \brief Base ID */
    uint32 XTD : 1;           /**< \brief Extended Identifier */
    uint32 XLF : 1;           /**< \brief XL Format */
    uint32 FDF : 1;           /**< \brief FD Format */
} IfxCanxl_FdTxHeader0_Bits;

/** \brief CAN FD TX Header 1
 */
typedef struct
{
    uint32 reserved_0 : 16;       /**< \brief Reserved */
    uint32 DLC : 4;               /**< \brief Data Length Code */
    uint32 ESI : 1;               /**< \brief Error State Indicator */
    uint32 reserved_21 : 4;       /**< \brief Reserved */
    uint32 BRS : 1;               /**< \brief Bit Rate Switch */
    uint32 reserved_26 : 4;       /**< \brief Reserved */
    uint32 FIR : 1;               /**< \brief Fault Injection Request */
    uint32 reserved_31 : 1;       /**< \brief Reserved */
} IfxCanxl_FdTxHeader1_Bits;

/** \brief CAN XL TX Header 0
 */
typedef struct
{
    uint32 SDT : 8;               /**< \brief SDU Type */
    uint32 VCID : 8;              /**< \brief Virtual CAN Network ID */
    uint32 SEC : 1;               /**< \brief Simple Extended Content */
    uint32 RRS : 1;               /**< \brief Remote Request Substitution */
    uint32 PriorityID : 11;       /**< \brief Priority Identifier */
    uint32 XTD : 1;               /**< \brief Extended Identifier */
    uint32 XLF : 1;               /**< \brief XL Format */
    uint32 FDF : 1;               /**< \brief FD Format */
} IfxCanxl_XlTxHeader0_Bits;

/** \brief CAN XL TX Header 1
 */
typedef struct
{
    uint32 reserved_0 : 16;       /**< \brief Reserved */
    uint32 DLC_XL : 11;           /**< \brief Data Length Code with CAN XL encoding */
    uint32 reserved_27 : 3;       /**< \brief Reserved */
    uint32 FIR : 1;               /**< \brief Fault Injection Request */
    uint32 reserved_31 : 1;       /**< \brief Reserved */
} IfxCanxl_XlTxHeader1_Bits;

/** \brief CAN XL TX Header 2
 */
typedef struct
{
    uint32 AF : 32;       /**< \brief Acceptance Field */
} IfxCanxl_XlTxHeader2_Bits;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Rx_Header
 * \{ */
/** \brief CAN Classical RX Header 0
 */
typedef struct
{
    uint32 ExtID : 18;        /**< \brief Extended ID */
    uint32 BaseID : 11;       /**< \brief Base ID */
    uint32 XTD : 1;           /**< \brief Extended Identifier */
    uint32 XLF : 1;           /**< \brief XL Format */
    uint32 FDF : 1;           /**< \brief FD Format */
} IfxCanxl_ClassicalRxHeader0_Bits;

/** \brief CAN Classical RX Header 1
 */
typedef struct
{
    uint32 FIDX : 8;              /**< \brief Filter index */
    uint32 FM : 1;                /**< \brief Filter Match */
    uint32 BLK : 1;               /**< \brief Black List */
    uint32 FAB : 1;               /**< \brief Filter Aborted */
    uint32 reserved_11 : 5;       /**< \brief Reserved */
    uint32 DLC : 4;               /**< \brief Data Length Code */
    uint32 reserved_20 : 6;       /**< \brief Reserved */
    uint32 RTR : 1;               /**< \brief Remote Transmission Request */
    uint32 reserved_27 : 5;       /**< \brief Reserved */
} IfxCanxl_ClassicalRxHeader1_Bits;

/** \brief CAN FD RX Header 0
 */
typedef struct
{
    uint32 ExtID : 18;        /**< \brief Extended ID */
    uint32 BaseID : 11;       /**< \brief Base ID */
    uint32 XTD : 1;           /**< \brief Extended Identifier */
    uint32 XLF : 1;           /**< \brief XL Format */
    uint32 FDF : 1;           /**< \brief FD Format */
} IfxCanxl_FdRxHeader0_Bits;

/** \brief CAN FD RX Header 1
 */
typedef struct
{
    uint32 FIDX : 8;              /**< \brief Filter index */
    uint32 FM : 1;                /**< \brief Filter Match */
    uint32 BLK : 1;               /**< \brief Black List */
    uint32 FAB : 1;               /**< \brief Filter Aborted */
    uint32 reserved_11 : 5;       /**< \brief Reserved */
    uint32 DLC : 4;               /**< \brief Data Length Code */
    uint32 ESI : 1;               /**< \brief Error State Indicator */
    uint32 reserved_21 : 4;       /**< \brief Reserved */
    uint32 BRS : 1;               /**< \brief Bit Rate Switch */
    uint32 reserved_26 : 6;       /**< \brief Reserved */
} IfxCanxl_FdRxHeader1_Bits;

/** \brief CAN XL RX Header 0
 */
typedef struct
{
    uint32 SDT : 8;               /**< \brief SDU Type */
    uint32 VCID : 8;              /**< \brief Virtual CAN Network ID */
    uint32 SEC : 1;               /**< \brief Simple Extended Content */
    uint32 RRS : 1;               /**< \brief Remote Request Substitution */
    uint32 BriorityID : 11;       /**< \brief Priority ID */
    uint32 reserved_29 : 1;       /**< \brief Reserved */
    uint32 XLF : 1;               /**< \brief XL Format */
    uint32 FDF : 1;               /**< \brief FD Format */
} IfxCanxl_XlRxHeader0_Bits;

/** \brief CAN XL RX Header 1
 */
typedef struct
{
    uint32 FIDX : 8;              /**< \brief Filter index */
    uint32 FM : 1;                /**< \brief Filter Match */
    uint32 BLK : 1;               /**< \brief Black List */
    uint32 FAB : 1;               /**< \brief Filter Aborted */
    uint32 reserved_11 : 5;       /**< \brief Reserved */
    uint32 DLC_XL : 11;           /**< \brief Data Length Code with CAN XL encoding */
    uint32 reserved_27 : 6;       /**< \brief Reserved */
} IfxCanxl_XlRxHeader1_Bits;

/** \brief CAN XL RX Header 2
 */
typedef struct
{
    uint32 AF : 32;       /**< \brief Acceptance Field */
} IfxCanxl_XlRxHeader2_Bits;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Rx_Header
 * \{ */
/** \brief CAN Classical RX Header 0
 */
typedef union
{
    IfxCanxl_ClassicalRxHeader0_Bits B;       /**< \brief Bitwise access */
    uint32                           U;       /**< \brief Unsigned access */
} IfxCanxl_ClassicalRxHeader0;

/** \brief CAN Classical RX Header 1
 */
typedef union
{
    IfxCanxl_ClassicalRxHeader1_Bits B;       /**< \brief Bitwise access */
    uint32                           U;       /**< \brief Unsigned access */
} IfxCanxl_ClassicalRxHeader1;

/** \brief CAN FD RX Header 0
 */
typedef union
{
    IfxCanxl_FdRxHeader0_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_FdRxHeader0;

/** \brief CAN FD RX Header 1
 */
typedef union
{
    IfxCanxl_FdRxHeader1_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_FdRxHeader1;

/** \brief CAN XL RX Header 0
 */
typedef union
{
    IfxCanxl_XlRxHeader0_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_XlRxHeader0;

/** \brief CAN XL RX Header 1
 */
typedef union
{
    IfxCanxl_XlRxHeader1_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_XlRxHeader1;

/** \brief CAN XL RX Header 2
 */
typedef union
{
    IfxCanxl_XlRxHeader2_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_XlRxHeader2;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Tx_Descriptors
 * \{ */
/** \brief TX Descriptor Element 0 managed by Message Handler
 */
typedef struct
{
    uint32 STS : 4;               /**< \brief Status[0:3] */
    uint32 reserved_4 : 27;       /**< \brief Reserved[4:30] */
    uint32 VALID : 1;             /**< \brief Valid[31] */
} IfxCanxl_TxDescr0_MH_Bits;

/** \brief TX Descriptor Element 0 managed by Software
 */
typedef struct
{
    uint32 reserved_0 : 4;       /**< \brief Reserved[0:3] */
    uint32 RC : 5;               /**< \brief Rolling Counter[4:8] */
    uint32 reserved_9 : 2;       /**< \brief Reserved[9:10] */
    uint32 PQSN0 : 1;            /**< \brief PQSN[0]: TX Priority FQ slot number [11] */
    uint32 FQN : 4;              /**< \brief TX FIFO Queue number / PQSN[1:4]: TX Priority FQ slot number [12:15] */
    uint32 CRC : 9;              /**< \brief CRC[16:24] */
    uint32 END : 1;              /**< \brief END[25] */
    uint32 PQ : 1;               /**< \brief PQ: When set to 1, descriptor belongs to PQ[26] */
    uint32 IRQ : 1;              /**< \brief Interrupt[27] */
    uint32 NEXT : 1;             /**< \brief NEXT: must be set to 0[28] */
    uint32 WRAP : 1;             /**< \brief WRAP[29] */
    uint32 HD : 1;               /**< \brief Message Header[30] */
    uint32 VALID : 1;            /**< \brief Valid[31] */
} IfxCanxl_TxDescr0_SW_Bits;

/** \brief TX Descriptor Element 1 managed by Message Handler
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_TxDescr1_MH_Bits;

/** \brief TX Descriptor Element 1 managed by Software
 */
typedef struct
{
    uint32 reserved_0 : 2;        /**< \brief Reserved[0:1] */
    uint32 NHDO : 10;             /**< \brief TX FIFO Queue: set to 1, TX Priority queue: set to 0 [2:11] */
    uint32 reserved_12 : 1;       /**< \brief Reserved[12] */
    uint32 IN : 3;                /**< \brief Instance Number[13:15] */
    uint32 SIZE : 10;             /**< \brief Buffer Size[16:25] */
    uint32 PLSRC : 1;             /**< \brief Payload Source[26] */
    uint32 reserved_27 : 5;       /**< \brief Reserved[27:31] */
} IfxCanxl_TxDescr1_SW_Bits;

/** \brief TX Descriptor Element 2 managed by Message Handler
 */
typedef struct
{
    uint32 TS0 : 32;       /**< \brief LSB of the 64 bits timestamp[0:32] */
} IfxCanxl_TxDescr2_MH_Bits;

/** \brief TX Descriptor Element 2 managed by Software
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_TxDescr2_SW_Bits;

/** \brief TX Descriptor Element 3 managed by Message Handler
 */
typedef struct
{
    uint32 TS1 : 32;       /**< \brief MSB of the 64 bits timestamp[0:32] */
} IfxCanxl_TxDescr3_MH_Bits;

/** \brief TX Descriptor Element 3 managed by Software
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_TxDescr3_SW_Bits;

/** \brief TX Descriptor Element 4 managed by Message Handler
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_TxDescr4_MH_Bits;

/** \brief TX Descriptor Element 4 managed by Software
 */
typedef union
{
    IfxCanxl_ClassicalTxHeader0_Bits cl;       /**< \brief Classical CAN bits */
    IfxCanxl_FdTxHeader0_Bits        fd;       /**< \brief CAN-FD bits */
    IfxCanxl_XlTxHeader0_Bits        xl;       /**< \brief CAN-XL bits */
} IfxCanxl_TxDescr4_SW_Bits;

/** \brief TX Descriptor Element 5 managed by Message Handler
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_TxDescr5_MH_Bits;

/** \brief TX Descriptor Element 5 managed by Software
 */
typedef union
{
    IfxCanxl_ClassicalTxHeader1_Bits cl;       /**< \brief Classical CAN bits */
    IfxCanxl_FdTxHeader1_Bits        fd;       /**< \brief CAN-FD bits */
    IfxCanxl_XlTxHeader1_Bits        xl;       /**< \brief CAN-XL bits */
} IfxCanxl_TxDescr5_SW_Bits;

/** \brief TX Descriptor Element 6 managed by Message Handler
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_TxDescr6_MH_Bits;

/** \brief TX Descriptor Element 6 managed by Software
 */
typedef union
{
    uint32                    TD0;       /**< \brief Classic CAN and CAN FD: define the first payload of the TX message[0:32] */
    IfxCanxl_XlTxHeader2_Bits T2;        /**< \brief T2[0:32] */
} IfxCanxl_TxDescr6_SW_Bits;

/** \brief TX Descriptor Element 7 managed by Message Handler
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_TxDescr7_MH_Bits;

/** \brief TX Descriptor Element 7 managed by Software
 */
typedef union
{
    uint32 TD1 : 32;         /**< \brief Define the last payload data of the TX message for the Classical CAN [0:32] */
    uint32 TX_AP : 32;       /**< \brief Address pointer to fetch the TX message payload data [0:32] */
} IfxCanxl_TxDescr7_SW_Bits;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Rx_Descriptors
 * \{ */
/** \brief RX Descriptor Element 0 managed by Message Handler
 */
typedef struct
{
    uint32 STS : 4;               /**< \brief Status[0:4] */
    uint32 reserved_4 : 24;       /**< \brief Reserved[4:27] */
    uint32 NEXT : 1;              /**< \brief Next bit[28] */
    uint32 reserved_29 : 1;       /**< \brief Reserved[29] */
    uint32 HD : 1;                /**< \brief Message Header[30] */
    uint32 VALID : 1;             /**< \brief Valid[32] */
} IfxCanxl_RxDescr0_MH_Bits;

/** \brief RX Descriptor Element 0 managed by Software
 */
typedef struct
{
    uint32 reserved_0 : 4;        /**< \brief Reserved[0:3] */
    uint32 RC : 5;                /**< \brief Rolling Counter[4:8] */
    uint32 IN : 3;                /**< \brief Instance Number[9:11] */
    uint32 FQN : 4;               /**< \brief RX FIFO Queue Number[12:15] */
    uint32 CRC : 9;               /**< \brief CRC[16:24] */
    uint32 reserved_25 : 2;       /**< \brief Reserved[25:26] */
    uint32 IRQ : 1;               /**< \brief Interrupt[27] */
    uint32 reserved_28 : 3;       /**< \brief Reserved[28:30] */
    uint32 VALID : 1;             /**< \brief Valid[32] */
} IfxCanxl_RxDescr0_SW_Bits;

/** \brief RX Descriptor Element 1 managed by Message Handler
 */
typedef struct
{
    uint32 RX_AP : 32;       /**< \brief RX Address pointer[0:32] */
} IfxCanxl_RxDescr1_MH_Bits;

/** \brief RX Descriptor Element 1 managed by Software
 */
typedef struct
{
    uint32 RX_AP : 32;       /**< \brief RX Address pointer[0:32] */
} IfxCanxl_RxDescr1_SW_Bits;

/** \brief RX Descriptor Element 2 managed by Message Handler
 */
typedef struct
{
    uint32 TS0 : 32;       /**< \brief LSB of the 64 bits timestamp[0:32] */
} IfxCanxl_RxDescr2_MH_Bits;

/** \brief RX Descriptor Element 2 managed by Software
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_RxDescr2_SW_Bits;

/** \brief RX Descriptor Element 3 managed by Message Handler
 */
typedef struct
{
    uint32 TS1 : 32;       /**< \brief MSB of the 64 bits timestamp[0:32] */
} IfxCanxl_RxDescr3_MH_Bits;

/** \brief RX Descriptor Element 3 managed by Software
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved[0:32] */
} IfxCanxl_RxDescr3_SW_Bits;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures
 * \{ */
/** \brief define for RX filter element
 */
typedef struct
{
    uint32 CREF0 : 8;             /**< \brief Reference Index: provide the index of the reference pair (value and mask) to be used for comparison 0 */
    uint32 WI0 : 2;               /**< \brief Word Index: provide the index of the RX message header word to compare, 1 for R0, 2 for R1 and 3 for R2. */
    uint32 AR0 : 1;               /**< \brief Accept or Reject on match: when set to 1 the RX message is rejected on match otherwise accepted on match */
    uint32 reserved_11 : 1;       /**< \brief Reserved */
    uint32 CREF1 : 8;             /**< \brief Reference Index: provide the index of the reference pair (value and mask) to be used for comparison 1 */
    uint32 WI1 : 2;               /**< \brief Word Index: provide the index of the RX message header word to compare, 1 for R0, 2 for R1 and 3 for R2. */
    uint32 AR1 : 1;               /**< \brief Accept or Reject on match: when set to 1 the RX message is rejected on match otherwise accepted on match */
    uint32 reserved_23 : 3;       /**< \brief Reserved */
    uint32 BLK : 1;               /**< \brief BlackList: When set to 1 the BLK bit defined in the RX message header is set to 1 */
    uint32 IRQ : 1;               /**< \brief Interrupt: When set to 1 an interrupt is triggered to the system when a match is detected */
    uint32 FIFO : 4;              /**< \brief RX FIFO Queue number to store the receive CAN data */
} IfxCanxl_RxFilterElement_Bits;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Rx_Header
 * \{ */
/** \brief Classic CAN RX Header
 */
typedef struct
{
    IfxCanxl_ClassicalRxHeader0 R0;       /**< \brief DWORD0 */
    IfxCanxl_ClassicalRxHeader1 R1;       /**< \brief DWORD1 */
} IfxCanxl_ClassicalRxHeader;

/** \brief CAN-FD RX Header
 */
typedef struct
{
    IfxCanxl_FdRxHeader0 R0;       /**< \brief DWORD0 */
    IfxCanxl_FdRxHeader1 R1;       /**< \brief DWORD1 */
} IfxCanxl_FdRxHeader;

/** \brief CAN-XL RX Header
 */
typedef struct
{
    IfxCanxl_XlRxHeader0 R0;       /**< \brief DWORD0 */
    IfxCanxl_XlRxHeader1 R1;       /**< \brief DWORD1 */
    IfxCanxl_XlRxHeader2 R2;       /**< \brief DWORD2 */
} IfxCanxl_XlRxHeader;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Tx_Descriptors
 * \{ */
/** \brief TX Descriptor Element 0
 */
typedef union
{
    IfxCanxl_TxDescr0_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr0_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr0;

/** \brief TX Descriptor Element 1
 */
typedef union
{
    IfxCanxl_TxDescr1_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr1_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr1;

/** \brief TX Descriptor Element 2
 */
typedef union
{
    IfxCanxl_TxDescr2_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr2_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr2;

/** \brief TX Descriptor Element 3
 */
typedef union
{
    IfxCanxl_TxDescr3_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr3_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr3;

/** \brief TX Descriptor Element 4
 */
typedef union
{
    IfxCanxl_TxDescr4_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr4_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr4;

/** \brief TX Descriptor Element 5
 */
typedef union
{
    IfxCanxl_TxDescr5_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr5_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr5;

/** \brief TX Descriptor Element 6
 */
typedef union
{
    IfxCanxl_TxDescr6_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr6_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr6;

/** \brief TX Descriptor Element 7
 */
typedef union
{
    IfxCanxl_TxDescr7_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_TxDescr7_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_TxDescr7;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Rx_Descriptors
 * \{ */
/** \brief RX Descriptor Element 0
 */
typedef union
{
    IfxCanxl_RxDescr0_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_RxDescr0_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_RxDescr0;

/** \brief RX Descriptor Element 1
 */
typedef union
{
    IfxCanxl_RxDescr1_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_RxDescr1_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_RxDescr1;

/** \brief RX Descriptor Element 2
 */
typedef union
{
    IfxCanxl_RxDescr2_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_RxDescr2_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_RxDescr2;

/** \brief RX Descriptor Element 3
 */
typedef union
{
    IfxCanxl_RxDescr3_SW_Bits SW;       /**< \brief Managed by Software */
    IfxCanxl_RxDescr3_MH_Bits MH;       /**< \brief Managed by Message Handler */
    uint32                    U;        /**< \brief Unsigned Access */
} IfxCanxl_RxDescr3;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Tx_Header
 * \{ */
/** \brief CAN Classical TX Header 0
 */
typedef union
{
    IfxCanxl_ClassicalTxHeader0_Bits B;       /**< \brief Bitwise access */
    uint32                           U;       /**< \brief Unsigned access */
} IfxCanxl_ClassicalTxHeader0;

/** \brief CAN Classical TX Header 1
 */
typedef union
{
    IfxCanxl_ClassicalTxHeader1_Bits B;       /**< \brief Bitwise access */
    uint32                           U;       /**< \brief Unsigned access */
} IfxCanxl_ClassicalTxHeader1;

/** \brief CAN FD TX Header 0
 */
typedef union
{
    IfxCanxl_FdTxHeader0_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_FdTxHeader0;

/** \brief CAN FD TX Header 1
 */
typedef union
{
    IfxCanxl_FdTxHeader1_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_FdTxHeader1;

/** \brief CAN XL TX Header 0
 */
typedef union
{
    IfxCanxl_XlTxHeader0_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_XlTxHeader0;

/** \brief CAN XL TX Header 1
 */
typedef union
{
    IfxCanxl_XlTxHeader1_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_XlTxHeader1;

/** \brief CAN XL TX Header 2
 */
typedef union
{
    IfxCanxl_XlTxHeader2_Bits B;       /**< \brief Bitwise access */
    uint32                    U;       /**< \brief Unsigned access */
} IfxCanxl_XlTxHeader2;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures
 * \{ */
/** \brief PROT and APU configuration structure for CAN-XL
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;          /**< \brief PROTE configurations */
    IfxApProt_ProtConfig protseConfig;         /**< \brief PROTSE Configuration */
    IfxApApu_ApuConfig   apuCanxlConfig;       /**< \brief APU Configurations for CAN-XL */
    IfxApApu_ApuConfig   apuNode0Config;       /**< \brief APU Configurations for Node 0 */
    IfxApApu_ApuConfig   apuNode1Config;       /**< \brief APU Configurations for Node 1 */
    IfxApApu_ApuConfig   apuNode2Config;       /**< \brief APU Configurations for Node 2 */
    IfxApApu_ApuConfig   apuNode3Config;       /**< \brief APU Configurations for Node 3 */
} IfxCanxl_ApConfig;

/** \brief configuration structure for CANXL RX filter global settings
 */
typedef struct
{
    boolean                 acceptNoMatch;                 /**< \brief TRUE: Msg frames on no match are stored in RX queues FALSE: Msg frames are rejected Note: If this param is 0 all RX frames will be stored in default queue specified */
    boolean                 acceptNonFilterFrames;         /**< \brief TRUE: Msg frames which are not filtered before threshold level they stored in default RX queue specified FALSE: Non filtered frame post threshold are discarded */
    uint8                   numRxFilterElements;           /**< \brief Configure the number of RX filter elements to be used */
    IfxCanxl_RxDmaFifoLevel thresholdRxDmaFifolevel;       /**< \brief 5-bit value to specify the threshold interm's of RX DMA FIFO level post this level unfiltered frames are rejected or placed in default RX queues if param acceptNonFilterFrames = TRUE */
    IfxCanxl_RxFifoQueue    defaultRxQueueNum;             /**< \brief Configure the default RX queue number where the msg are stored when acceptNoMatch = TRUE */
} IfxCanxl_Can_RxFilterGlobalConfig;

/** \brief Configuration structure for CAN-FD/CAN-XL Data phase
 */
typedef struct
{
    uint32 baudrate;            /**< \brief Baud rate. Unit: baud(bits per second). Max value: 8Mbps for CAN-FD, 15Mbps for CAN-XL */
    uint16 samplePoint;         /**< \brief Specifies the sample point. Range = [0, 10000] resp. [0%, 100%] of the total bit time. */
    uint8  syncJumpWidth;       /**< \brief Specifies the re-synchronization jump width. Range: 0x00-0x7F. HW Interpretation: (syncJumpWidth + 1)TQ */
    uint8  delayOffset;         /**< \brief Transmitter Delay Compensation Offset for FD/XL frames. Range: 0x00 - 0xFF. Unit: fCANXL clock period */
} IfxCanxl_DataBaudrateConfig;

/** \brief Configuration structure for registers Ni_DBTP or Ni_XBTP
 */
typedef struct
{
    uint8 syncJumpWidth;       /**< \brief Synchronization Jump Width
                                * Valid values: 0x00-0x7F | Actual interpretation by HW: FD data phase Synchronization Jump Width is (syncJumpWidth + 1) TQ long */
    uint8 timeSegment2;        /**< \brief Time segment after sample point. Defines the length of Phase_Seg2(D)
                                * Valid values: 0x01-0x7F | Actual interpretation by HW: (timeSegment2 + 1) TQ long */
    uint8 timeSegment1;        /**< \brief Time segment before sample point. Defines the sum of Prop_Seg(D) and Phase_Seg1(D).
                                * Valid values: 0x00-0xFF | Actual interpretation by HW: (timeSegment1 + 1) TQ long */
    uint8 delayOffset;         /**< \brief Transmitter Delay Compensation Offset for FD frames. Defines the distance between the measured delay
                                * from CAN_TX to CAN_RX and the secondary sample point SSP, measured in CLK periods | Valid values: 0x00-0xFF. Unit: fCANXL clock period */
} IfxCanxl_DataBaudrateRegConfig;

/** \brief Configuration structure for Nominal/Arbitration phase or Classical CAN frames
 */
typedef struct
{
    uint32 baudrate;            /**< \brief Baud rate. Unit: baud(bits per second). Max value: 1Mbps */
    uint16 samplePoint;         /**< \brief Specifies the sample point. Range = [0, 10000] resp. [0%, 100%] of the total bit time. */
    uint8  syncJumpWidth;       /**< \brief Specifies the re-synchronization jump width. Range: 0x00-0x7F. HW Interpretation: (syncJumpWidth + 1)TQ */
} IfxCanxl_NominalBaudrateConfig;

/** \brief Configuration structure for register Ni_NBTP
 */
typedef struct
{
    uint8  syncJumpWidth;       /**< \brief Synchronization Jump Width.
                                 * Valid values: 0x00-0x7F | Actual interpretation by HW: Nominal Synchronization Jump Width is (syncJumpWidth + 1) TQ long */
    uint8  timeSegment2;        /**< \brief Time segment after sample point. Defines the length of Phase_Seg2(N)
                                 * Valid values: 0x01-0x7F | Actual interpretation by HW: (timeSegment2 + 1) TQ long */
    uint16 timeSegment1;        /**< \brief Time segment before sample point. Defines the sum of Prop_Seg(N) and Phase_Seg1(N).
                                 * Valid values: 0x01-0x1FF | Actual interpretation by HW: (timeSegment1 + 1) TQ long */
    uint8  prescaler;           /**< \brief Baud Rate Prescaler. Defines the length of the Time Quantum TQ for all three bit time configurations.
                                 * Valid values: 0x00-0x1F | Actual interpretation by HW: TQ is (prescaler + 1) CLK periods long */
} IfxCanxl_NominalBaudrateRegConfig;

/** \brief RX filter element
 */
typedef union
{
    IfxCanxl_RxFilterElement_Bits B;       /**< \brief Bitfield access */
    uint32                        U;       /**< \brief Unsigned access */
} IfxCanxl_RxFilterElement;

/** \brief Node APU configuration structure for CAN-XL
 */
typedef struct
{
    boolean         prsEnable;       /**< \brief Protection set PRS Tag ID */
    boolean         vmEnable;        /**< \brief Virtual machine Enable True : VM Enabled False : VM disabled */
    IfxApProt_PrsId prsId;           /**< \brief Protection set PRS ID */
    IfxApProt_VmId  vmId;            /**< \brief Virtual machine ID */
} IfxCanxl_nodeApuConfig;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Rx_Header
 * \{ */
/** \brief CAN RX Header
 */
typedef union
{
    IfxCanxl_ClassicalRxHeader cl;       /**< \brief Classic CAN header */
    IfxCanxl_FdRxHeader        fd;       /**< \brief CAN-FD header */
    IfxCanxl_XlRxHeader        xl;       /**< \brief CAN-XL header */
} IfxCanxl_RxHeader;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Tx_Descriptors
 * \{ */
/** \brief TX Descriptor
 */
typedef struct
{
    IfxCanxl_TxDescr0 TXDES0;       /**< \brief TX Descriptor DWORD 0 */
    IfxCanxl_TxDescr1 TXDES1;       /**< \brief TX Descriptor DWORD 1 */
    IfxCanxl_TxDescr2 TXDES2;       /**< \brief TX Descriptor DWORD 2 */
    IfxCanxl_TxDescr3 TXDES3;       /**< \brief TX Descriptor DWORD 3 */
    IfxCanxl_TxDescr4 TXDES4;       /**< \brief TX Descriptor DWORD 4 */
    IfxCanxl_TxDescr5 TXDES5;       /**< \brief TX Descriptor DWORD 5 */
    IfxCanxl_TxDescr6 TXDES6;       /**< \brief TX Descriptor DWORD 6 */
    IfxCanxl_TxDescr7 TXDES7;       /**< \brief TX Descriptor DWORD 7 */
} IfxCanxl_TxDescr;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Structures_Rx_Descriptors
 * \{ */
/** \brief RX Descriptor
 */
typedef struct
{
    IfxCanxl_RxDescr0 RXDES0;       /**< \brief RX Descriptor DWORD 0 */
    IfxCanxl_RxDescr1 RXDES1;       /**< \brief RX Descriptor DWORD 1 */
    IfxCanxl_RxDescr2 RXDES2;       /**< \brief RX Descriptor DWORD 2 */
    IfxCanxl_RxDescr3 RXDES3;       /**< \brief RX Descriptor DWORD 3 */
} IfxCanxl_RxDescr;

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the base address of the selected Node of CAN-XL module
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \param nodeId Node number of the module
 * \return Specifies the pointer to the CAN-XL Node registers
 */
IFX_INLINE Ifx_CANXL_N *IfxCanxl_getNodePointer(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId);

/** \brief Returns the status of module enabled or disabled
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \return Status (TRUE / FALSE)
 */
IFX_INLINE boolean IfxCanxl_isModuleEnabled(Ifx_CANXL *canxl);

/** \brief Returns the status of CAN-XL node enabled or disabled
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \param nodeId Node index
 * \return Status (TRUE / FALSE)
 */
IFX_INLINE boolean IfxCanxl_isNodeEnabled(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId);

/** \brief Configure the Module to Hard/Soft suspend mode.
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \param mode Module suspend mode
 * \return None
 */
IFX_INLINE void IfxCanxl_setSuspendMode(Ifx_CANXL *canxl, IfxCanxl_SuspendMode mode);

/** \brief Check if module is suspended
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \return TRUE: Module is suspended. FALSE: Module is not (yet) suspended
 */
IFX_INLINE boolean IfxCanxl_isModuleSuspended(Ifx_CANXL *canxl);

/** \brief Configure the OTGB Trigger
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \param triggerSet Trigger set for OTGB0/1
 * \param busSelect Select OTGB0/1
 * \return None
 */
IFX_INLINE void IfxCanxl_configureOtgbTrigger(Ifx_CANXL *canxl, IfxCanxl_OtgbTriggerSet triggerSet, IfxCanxl_OtgbBusSelect busSelect);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initialize the PROT and APU structures with default configuration
 * \param config Configuration pointer for the Access Protection
 * \return None
 */
IFX_EXTERN void IfxCanxl_initApConfig(IfxCanxl_ApConfig *config);

/** \brief Initialize the PROTs and all 5 APU register set
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \param config Configuration pointer to the AP configuration structure
 * \return None
 */
IFX_EXTERN void IfxCanxl_initAp(Ifx_CANXL *canxl, IfxCanxl_ApConfig *config);

/** \brief Node bus ID APU configuration
 * \param canSFR CANXL module pointer
 * \param nodeId node index
 * \param nodeApuConfig Configuration pointer to the node VM and PRS
 * \return None
 */
IFX_EXTERN void IfxCanxl_nodeBusIdConfig(Ifx_CANXL *canSFR, IfxCanxl_NodeId nodeId, IfxCanxl_nodeApuConfig *nodeApuConfig);

/** \brief Disables the module (sets the disable request)
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \return None
 */
IFX_EXTERN void IfxCanxl_disableModule(Ifx_CANXL *canxl);

/** \brief Enables the module (clears the disable request)
 * \param canxl Specifies the pointer to the CAN-XL registers
 * \return None
 */
IFX_EXTERN void IfxCanxl_enableModule(Ifx_CANXL *canxl);

/** \brief Resets CAN-XL kernel
 * \param canxl Pointer to CAN-XL registers
 * \return None
 */
IFX_EXTERN void IfxCanxl_resetModule(Ifx_CANXL *canxl);

/** \brief Resets CAN-XL node kernel
 * \param canxl Pointer to CAN-XL registers
 * \param nodeId Node index
 * \return None
 */
IFX_EXTERN void IfxCanxl_resetNode(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId);

/** \brief Enables CAN-XL node clock
 * \param canxl Pointer to CAN-XL registers
 * \param nodeId Node index
 * \return None
 */
IFX_EXTERN void IfxCanxl_enableNode(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId);

/** \brief Disables CAN-XL node clock
 * \param canxl Pointer to CAN-XL registers
 * \param nodeId Node index
 * \return None
 */
IFX_EXTERN void IfxCanxl_disableNode(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId);

/** \brief Returns the operating frequency of the CAN-XL module
 * \return Module Frequency
 */
IFX_EXTERN uint32 IfxCanxl_getModuleFrequency(void);

/** \brief Configures access to all masters to all the CANXL module and nodes in the device
 * \param apConfig pointer to configuration structure.
 * \return None
 */
IFX_EXTERN void IfxCanxl_configureAccessToCanxls(IfxApApu_ApuConfig *apConfig);

/** \} */

/** \addtogroup IfxLld_Canxl_Std_Functions_Node
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enables the Timestamp counter
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableTimeStamp(Ifx_CANXL_N *node);

/** \brief Disables the Timestamp counter
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_disableTimeStamp(Ifx_CANXL_N *node);

/** \brief Checks whether Timestamp is enabled
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return TRUE: Timestamp unit is enabled. FALSE: Timestamp unit is disabled.
 */
IFX_INLINE boolean IfxCanxl_Node_isTimeStampEnabled(Ifx_CANXL_N *node);

/** \brief Gets the Timestamp counter value
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return 64 bit count of current timestamp value
 */
IFX_INLINE uint64 IfxCanxl_Node_getTimeStampCount(Ifx_CANXL_N *node);

/** \brief Sends request to clear the Timestamp counter
 * Note: Ensure Timestamp unit is disabled before calling this API. Otherwise there is no effect.
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearTimeStampCounter(Ifx_CANXL_N *node);

/** \brief Sets the Timestamp position
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param capturePosition Specifies the position of frame where timestamp is taken
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_setTimeStampPosition(Ifx_CANXL_N *node, IfxCanxl_TimeStampPosition capturePosition);

/** \brief Returns the SRC pointer for FUNC node
 * \param nodeId CAN-XL Node ID
 * \return None
 */
IFX_INLINE Ifx_SRC_SRCR *IfxCanxl_Node_getSrcPointerFunc(IfxCanxl_NodeId nodeId);

/** \brief Returns the SRC pointer for ERR node
 * \param nodeId CAN-XL Node ID
 * \return None
 */
IFX_INLINE Ifx_SRC_SRCR *IfxCanxl_Node_getSrcPointerErr(IfxCanxl_NodeId nodeId);

/** \brief Returns the SRC pointer for SAFETY node
 * \param nodeId CAN-XL Node ID
 * \return None
 */
IFX_INLINE Ifx_SRC_SRCR *IfxCanxl_Node_getSrcPointerSafety(IfxCanxl_NodeId nodeId);

/** \brief Enables Transmitter Delay Compensation
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableTransmitterDelayCompensation(Ifx_CANXL_N *node);

/** \brief Disables Transmitter Delay Compensation
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_disableTransmitterDelayCompensation(Ifx_CANXL_N *node);

/** \brief Enables Protocol Exception Handling
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableProtocolExceptionHandling(Ifx_CANXL_N *node);

/** \brief Disables Protocol Exception Handling
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_disableProtocolExceptionHandling(Ifx_CANXL_N *node);

/** \brief Enables Functional interrupts
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param enableMask 32 bit value to be written to register FUNC_ENA which enables the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableFunctionalInterrupt(Ifx_CANXL_N *node, uint32 enableMask);

/** \brief Gets Functional interrupt status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return 32 bit value of register FUNC_RAW. Bits with 1 corresponds to interrupt occurred. 0 corresponds to interrupt did not occur.
 */
IFX_INLINE uint32 IfxCanxl_Node_getFunctionalInterruptStatus(Ifx_CANXL_N *node);

/** \brief Clears Functional interrupts
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param clearMask 32 bit value to be written to register FUNC_CLR which clears the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearFunctionalInterruptStatus(Ifx_CANXL_N *node, uint32 clearMask);

/** \brief Enables Error interrupts
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param enableMask 32 bit value to be written to register ERR_ENA which enables the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableErrorInterrupt(Ifx_CANXL_N *node, uint32 enableMask);

/** \brief Gets Error interrupt status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return 32 bit value of register ERR_RAW. Bits with 1 corresponds to interrupt occurred. 0 corresponds to interrupt did not occur.
 */
IFX_INLINE uint32 IfxCanxl_Node_getErrorInterruptStatus(Ifx_CANXL_N *node);

/** \brief Clears Error interrupts
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param clearMask 32 bit value to be written to register ERR_CLR which clears the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearErrorInterruptStatus(Ifx_CANXL_N *node, uint32 clearMask);

/** \brief Enables Safety interrupts
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param enableMask 32 bit value to be written to register SAFTEY_ENA which enables the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableSafetyInterrupt(Ifx_CANXL_N *node, uint32 enableMask);

/** \brief Gets Safety interrupt status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return 32 bit value of register SAFETY_RAW. Bits with 1 corresponds to interrupt occurred. 0 corresponds to interrupt did not occur.
 */
IFX_INLINE uint32 IfxCanxl_Node_getSafetyInterruptStatus(Ifx_CANXL_N *node);

/** \brief Clears Safety interrupts
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param clearMask 32 bit value to be written to register SAFETY_CLR which clears the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearSafetyInterruptStatus(Ifx_CANXL_N *node, uint32 clearMask);

/** \brief Enables MTI flags
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param enableMask 32 bit value to be written to register MTI_ENA which enables the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableMtiFlags(Ifx_CANXL_NODE *node, uint32 enableMask);

/** \brief Gets MTI flags status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return 32 bit value of register MTI_RAW. Bits with 1 corresponds to interrupt occurred. 0 corresponds to interrupt did not occur.
 */
IFX_INLINE uint32 IfxCanxl_Node_getMtiFlagsStatus(Ifx_CANXL_NODE *node);

/** \brief Clears MTI flags
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param clearMask 32 bit value to be written to register MTI_CLR which clears the corresponding interrupts
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearMtiFlagsStatus(Ifx_CANXL_NODE *node, uint32 clearMask);

/** \brief Gets TX FIFO Queue interrupt status
 * Note: To know the cause of interrupt, check status of IfxCanxl_Node_getTxFifoSentStatus and IfxCanxl_Node_getTxFifoInvalidStatus
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return TRUE: Interrupt occurred. FALSE: Interrupt did not occur
 */
IFX_INLINE boolean IfxCanxl_Node_getTxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex);

/** \brief Clears TX FIFO Queue interrupt status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearTxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex);

/** \brief Gets RX FIFO Queue interrupt status
 * Note: To know the cause of interrupt, check status of IfxCanxl_Node_getRxFifoReceivedStatus and IfxCanxl_Node_getRxFifoInvalidStatus
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return TRUE: Interrupt occurred. FALSE: Interrupt did not occur
 */
IFX_INLINE boolean IfxCanxl_Node_getRxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex);

/** \brief Clears RX FIFO Queue interrupt status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearRxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex);

/** \brief Gets TX FIFO Queue Sent status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return TRUE: A TX message was sent from the TX FIFO Queue
 */
IFX_INLINE boolean IfxCanxl_Node_getTxFifoSentStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex);

/** \brief Clears TX FIFO Queue Sent status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearTxFifoSentStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex);

/** \brief Gets TX FIFO Queue Unvalid status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return TRUE: When TX FIFO Queue loads a TX descriptor with VALID = 0
 */
IFX_INLINE boolean IfxCanxl_Node_getTxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex);

/** \brief Clears TX FIFO Queue Unvalid status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearTxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex);

/** \brief Gets RX FIFO Queue Received status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return TRUE: An RX message was received in the RX FIFO Queue
 */
IFX_INLINE boolean IfxCanxl_Node_getRxFifoReceivedStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex);

/** \brief Clears RX FIFO Queue Received status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearRxFifoSentStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex);

/** \brief Gets RX FIFO Queue Unvalid status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return TRUE: When RX FIFO Queue loads an RX descriptor with VALID = 0
 */
IFX_INLINE boolean IfxCanxl_Node_getRxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex);

/** \brief Clears RX FIFO Queue Unvalid status
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param queueIndex FIFO Queue index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearRxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex);

/** \brief Starts the Message Handler block of CAN-XL Node
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_startMessageHandler(Ifx_CANXL_N *node);

/** \brief Stops the Message Handler block of CAN-XL Node
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_stopMessageHandler(Ifx_CANXL_N *node);

/** \brief Enable TX filtering
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableTxFiltering(Ifx_CANXL_N *node);

/** \brief Disable TX filtering
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_disableTxFiltering(Ifx_CANXL_N *node);

/** \brief CAN FD frames are allowed to TX
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_acceptCanFDFrameTx(Ifx_CANXL_N *node);

/** \brief CAN FD frames are not allowed to TX
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_rejectCanFDFrameTx(Ifx_CANXL_N *node);

/** \brief Classic CAN frames are allowed to TX
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_acceptClassicCanFrameTx(Ifx_CANXL_N *node);

/** \brief Classic CAN frames are not allowed to TX
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_rejectClassicCanFrameTx(Ifx_CANXL_N *node);

/** \brief Message Handler (MH) busy status check
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return TRUE: If MH is busy FALSE: If MH is not busy
 */
IFX_INLINE boolean IfxCanxl_Node_mhBusyStatus(Ifx_CANXL_N *node);

/** \brief Clears Successful and unsuccessful reception counters
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearRxStatistics(Ifx_CANXL_N *node);

/** \brief Clears Successful and unsuccessful transmission counters
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_clearTxStatistics(Ifx_CANXL_N *node);

/** \brief Get current node activity
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return Current node activity
 */
IFX_INLINE IfxCanxl_NodeActivity IfxCanxl_Node_getNodeActivity(Ifx_CANXL_N *node);

/** \brief Enables loop back mode
 * Note: Ensure TEST mode is enabled prior to calling this API
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_enableLoopbackMode(Ifx_CANXL_N *node);

/** \brief Starts TX FIFO Queue
 * Note: Ensure MH, PRT is started and queue is enabled before calling this API
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_startTxFifoQueue(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue idx);

/** \brief Starts TX Priority Queue
 * Note: Ensure MH, PRT is started and queue is enabled before calling this API
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_startTxPriorityQueue(Ifx_CANXL_N *node, uint8 idx);

/** \brief Starts RX FIFO Queue
 * Note: Ensure MH, PRT is started and queue is enabled before calling this API
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_startRxFifoQueue(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue idx);

/** \brief Checks whether TX FIFO queue is stopped
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return TRUE: Queue is stopped
 */
IFX_INLINE boolean IfxCanxl_Node_isTxFifoQueueStopped(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue idx);

/** \brief Checks whether TX FIFO queue is busy
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return TRUE: Queue is busy
 */
IFX_INLINE boolean IfxCanxl_Node_isTxFifoQueueBusy(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue idx);

/** \brief Checks whether TX Priority queue is busy
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return TRUE: Queue is busy
 */
IFX_INLINE boolean IfxCanxl_Node_isTxPriorityQueueBusy(Ifx_CANXL_N *node, uint8 idx);

/** \brief Checks whether RX FIFO queue is stopped
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return TRUE: Queue is stopped
 */
IFX_INLINE boolean IfxCanxl_Node_isRxFifoQueueStopped(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue idx);

/** \brief Checks whether RX FIFO queue is busy
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param idx Queue Index
 * \return TRUE: Queue is busy
 */
IFX_INLINE boolean IfxCanxl_Node_isRxFifoQueueBusy(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue idx);

/** \brief Configures the maximum read and write pending transactions on DMA_AXI interface
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param read maximum read pending transactions
 * \param write maximum write pending transactions
 * \return None
 */
IFX_INLINE void IfxCanxl_Node_configureAxiParams(Ifx_CANXL_N *node, IfxCanxl_MaxAxiTransactions read, IfxCanxl_MaxAxiTransactions write);

/** \brief Checks whether PRT is done with bus integration
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return TRUE: Bus integration done
 */
IFX_INLINE boolean IfxCanxl_Node_isBusIntegrationDone(Ifx_CANXL_N *node);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Select and initialize the CAN-XL Node receive pin
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param rxd Rx pin
 * \param mode Input mode
 * \param padDriver Pad Driver Configuration
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_initRxPin(Ifx_CANXL_NODE *node, IfxCanxl_Rxd_In *rxd, IfxPort_InputMode mode, IfxPort_PadDriver padDriver);

/** \brief Select and initialize the CAN-XL node transmit pin
 * \param txd Tx pin
 * \param mode Output mode
 * \param padDriver Pad driver Configuration
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_initTxPin(IfxCanxl_Txd_Out *txd, IfxPort_OutputMode mode, IfxPort_PadDriver padDriver);

/** \brief Configure PWME block used for CAN-XL transmission when transceiver is connected
 * \param node Pointer to CAN-XL node registers
 * \param shortPhase PWM phase Short (PWMS). Valid values are 0x0 to 0x3F (5 bits).
 * The actual interpretation of this value is that the PWM short phase length is (PWMS + 1) clock cycles long
 * \param longPhase PWM phase Long (PWML). Valid values are 0x0 to 0x3F (5 bits).
 * The actual interpretation of this value is that the PWM long phase length is (PWML + 1) clock cycles long.
 * \param offset PWM Offset (PWMO). Valid values are 0x0 to 0x3F (5 bits).
 * PWMO shall always be smaller than the PWM symbol length (PWMO < PWMS + PWML + 2)
 * \return TRUE: Correct configuration was provided and the register was modified.
 * FALSE: Incorrect configuration was provided and register was NOT modified.
 */
IFX_EXTERN boolean IfxCanxl_Node_configurePwmEncoder(Ifx_CANXL_N *node, uint8 shortPhase, uint8 longPhase, uint8 offset);

/** \brief Sets CAN-XL node's operation mode
 * \param node Pointer to CAN-XL node registers
 * \param mode Desired operation mode
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_setOperationMode(Ifx_CANXL_N *node, IfxCanxl_Node_OperationMode mode);

/** \brief Configures the Arbitration/Nominal bit time and prescaler for all CAN frames
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param syncJumpWidth Synchronization Jump Width
 * Valid values: 0x00-0x7F | Actual interpretation by HW: Nominal Synchronization Jump Width is (syncJumpWidth + 1) TQ long
 * \param timeSegment2 Time segment after sample point. Defines the length of Phase_Seg2(N)
 * Valid values: 0x01-0x7F | Actual interpretation by HW: (timeSegment2 + 1) TQ long
 * \param timeSegment1 Time segment before sample point. Defines the sum of Prop_Seg(N) and Phase_Seg1(N).
 * Valid values: 0x01-0x1FF | Actual interpretation by HW: (timeSegment1 + 1) TQ long
 * \param prescaler Baud Rate Prescaler. Defines the length of the Time Quantum TQ for all three bit time configurations.
 * Valid values: 0x00-0x1F | Actual interpretation by HW: TQ is (prescaler + 1) CLK periods long
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_setNominalBitTimingValues(Ifx_CANXL_N *node, uint8 syncJumpWidth, uint8 timeSegment2, uint16 timeSegment1, uint8 prescaler);

/** \brief Configures the FD data phase bit time for CAN-FD frames
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param syncJumpWidth Synchronization Jump Width
 * Valid values: 0x00-0x7F | Actual interpretation by HW: FD data phase Synchronization Jump Width is (syncJumpWidth + 1) TQ long
 * \param timeSegment2 Time segment after sample point. Defines the length of Phase_Seg2(D)
 * Valid values: 0x01-0x7F | Actual interpretation by HW: (timeSegment2 + 1) TQ long
 * \param timeSegment1 Time segment before sample point. Defines the sum of Prop_Seg(D) and Phase_Seg1(D).
 * Valid values: 0x00-0xFF | Actual interpretation by HW: (timeSegment1 + 1) TQ long
 * \param delayOffset Transmitter Delay Compensation Offset for FD frames. Defines the distance between the measured delay
 * from CAN_TX to CAN_RX and the secondary sample point SSP, measured in CLK periods
 * Valid values: 0x00-0xFF. Unit: fCANXL clock period
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_setFdDataBitTimingValues(Ifx_CANXL_N *node, uint8 syncJumpWidth, uint8 timeSegment2, uint8 timeSegment1, uint8 delayOffset);

/** \brief Configures the XL data phase bit time for CAN-XL frames
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param syncJumpWidth Synchronization Jump Width
 * Valid values: 0x00-0x7F | Actual interpretation by HW: XL data phase Synchronization Jump Width is (syncJumpWidth + 1) TQ long
 * \param timeSegment2 Time segment after sample point. Defines the length of Phase_Seg2(X)
 * Valid values: 0x01-0x7F | Actual interpretation by HW: (timeSegment2 + 1) TQ long
 * \param timeSegment1 Time segment before sample point. Defines the sum of Prop_Seg(X) and Phase_Seg1(X).
 * Valid values: 0x00-0xFF | Actual interpretation by HW: (timeSegment1 + 1) TQ long
 * \param delayOffset Transmitter Delay Compensation Offset for XL frames. Defines the distance between the measured delay
 * from CAN_TX to CAN_RX and the secondary sample point SSP, measured in CLK periods
 * Valid values: 0x00-0xFF. Unit: fCANXL clock period
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_setXlDataBitTimingValues(Ifx_CANXL_N *node, uint8 syncJumpWidth, uint8 timeSegment2, uint8 timeSegment1, uint8 delayOffset);

/** \brief Calculate optimum bit rate prescaler when given required data and nominal baud rate
 * \param moduleFreq CAN-XL module frequency
 * \param dataBaudRate Baud rate for data phase
 * Note: In case of Classical CAN, pass 0
 * \param nominalBaudrate Baud rate for nominal/arbitration phase
 * \return Prescaler value (If optimum value is not found then 1 is returned)
 */
IFX_EXTERN uint8 IfxCanxl_Node_calculateBitratePrescaler(uint32 moduleFreq, uint32 dataBaudRate, uint32 nominalBaudrate);

/** \brief Sets baud rate for Classical CAN operating mode
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param moduleFreq CAN-XL module frequency
 * \param nominalConfig Baud rate configuration
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_configureClassicalBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig);

/** \brief Sets baud rate for Classical CAN/CAN-FD operating mode
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param moduleFreq CAN-XL module frequency
 * \param nominalConfig Baud rate configuration for arbitration/nominal phase
 * \param fdDataConfig Baud rate configuration for data phase
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_configureFdBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig, IfxCanxl_DataBaudrateConfig *fdDataConfig);

/** \brief Sets baud rate for CAN-XL only operating modes
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param moduleFreq CAN-XL module frequency
 * \param nominalConfig Baud rate configuration for arbitration/nominal phase
 * \param xlDataConfig Baud rate configuration for data phase
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_configureXlBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig, IfxCanxl_DataBaudrateConfig *xlDataConfig);

/** \brief Sets baud rate for Classical/FD/XL CAN operating mode
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param moduleFreq CAN-XL module frequency
 * \param nominalConfig Baud rate configuration for arbitration/nominal phase
 * \param fdDataConfig Baud rate configuration for FD data phase
 * \param xlDataConfig Baud rate configuration for XL data phase
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_configureFdXlBitTiming(Ifx_CANXL_N *node, uint32 moduleFreq, IfxCanxl_NominalBaudrateConfig *nominalConfig, IfxCanxl_DataBaudrateConfig *fdDataConfig, IfxCanxl_DataBaudrateConfig *xlDataConfig);

/** \brief Sets the operation mode of Node protocol controller block
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param operation Desired operation
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_configureProtocolOperation(Ifx_CANXL_N *node, IfxCanxl_ProtocolOperation operation);

/** \brief Global configuration setting for RX filter
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \param config configure the global setting for RX filter
 * \return None
 */
IFX_EXTERN void IfxCanxl_Node_configureGlobalSettingsRxFilter(Ifx_CANXL_N *node, IfxCanxl_Can_RxFilterGlobalConfig *config);

/** \brief This API provides the nominal baudrate of CAN Classical, FD, and XL frames.
 * Note: Configure baud rate before calling this API
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return Baud rate
 */
IFX_EXTERN uint32 IfxCanxl_Node_getNominalBaudRate(Ifx_CANXL_N *node);

/** \brief This API provides the data phase baud rate of CAN FD frames
 * Note: API will return correct values only if FD baud rate is already configured
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return Baud rate
 */
IFX_EXTERN uint32 IfxCanxl_Node_getFdBaudRate(Ifx_CANXL_N *node);

/** \brief This API provides the data phase baud rate of CAN XL frames
 * Note: API will return correct values only if XL baud rate is already configured
 * \param node Specifies the pointer to the CAN-XL Node registers
 * \return Baud rate
 */
IFX_EXTERN uint32 IfxCanxl_Node_getXlBaudRate(Ifx_CANXL_N *node);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE Ifx_CANXL_N *IfxCanxl_getNodePointer(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId)
{
    return &(canxl->N[nodeId]);
}


IFX_INLINE boolean IfxCanxl_isModuleEnabled(Ifx_CANXL *canxl)
{
    boolean enabled = (canxl->MODULE.CLC.B.DISS == 0u) ? TRUE : FALSE;
    return enabled;
}


IFX_INLINE boolean IfxCanxl_isNodeEnabled(Ifx_CANXL *canxl, IfxCanxl_NodeId nodeId)
{
    uint32  statusMask = IFX_CANXL_CLKEN_N0_CCS_MSK << ((uint32)nodeId + IFX_CANXL_CLKEN_N0_CCS_OFF);
    boolean enabled    = ((canxl->CLKEN.U & statusMask) == 0u) ? FALSE : TRUE;
    return enabled;
}


IFX_INLINE void IfxCanxl_setSuspendMode(Ifx_CANXL *canxl, IfxCanxl_SuspendMode mode)
{
    /* Set SUS_P to 1 to enable write to SUS. Configure SUS (suspend mode) */
    canxl->OCS.B.SUS_P = 1u;
    canxl->OCS.B.SUS   = mode;
}


IFX_INLINE boolean IfxCanxl_isModuleSuspended(Ifx_CANXL *canxl)
{
    /* Read suspend state. 1 means module is suspended */
    boolean result = (canxl->OCS.B.SUSSTA == 1u) ? TRUE : FALSE;

    return result;
}


IFX_INLINE void IfxCanxl_configureOtgbTrigger(Ifx_CANXL *canxl, IfxCanxl_OtgbTriggerSet triggerSet, IfxCanxl_OtgbBusSelect busSelect)
{
    /* TGB, TGS is only written when TG_P is 1 */
    canxl->OCS.B.TG_P = 1u;
    canxl->OCS.B.TGB  = busSelect;
    canxl->OCS.B.TGS  = triggerSet;
}


IFX_INLINE void IfxCanxl_Node_enableTimeStamp(Ifx_CANXL_N *node)
{
    node->TS_CTL.B.ENABLED = 0x1u;
}


IFX_INLINE void IfxCanxl_Node_disableTimeStamp(Ifx_CANXL_N *node)
{
    node->TS_CTL.B.ENABLED = 0x0u;
}


IFX_INLINE boolean IfxCanxl_Node_isTimeStampEnabled(Ifx_CANXL_N *node)
{
    boolean enabled = (node->TS_CTL.B.ENABLED == 1u) ? TRUE : FALSE;
    return enabled;
}


IFX_INLINE uint64 IfxCanxl_Node_getTimeStampCount(Ifx_CANXL_N *node)
{
    uint64 count;
    /* Concatenate MSB and LSB */
    count = ((uint64)node->TS_CNT_HI.U << 32u) | ((uint64)node->TS_CNT_LO.U);
    return count;
}


IFX_INLINE void IfxCanxl_Node_clearTimeStampCounter(Ifx_CANXL_N *node)
{
    node->TS_CMD.U = (uint32)0x1u;
}


IFX_INLINE void IfxCanxl_Node_setTimeStampPosition(Ifx_CANXL_N *node, IfxCanxl_TimeStampPosition capturePosition)
{
    node->MODE.B.SFS = (uint32)capturePosition;
}


IFX_INLINE Ifx_SRC_SRCR *IfxCanxl_Node_getSrcPointerFunc(IfxCanxl_NodeId nodeId)
{
    return (Ifx_SRC_SRCR *)(&MODULE_SRC.CANXL[nodeId].FUNC);
}


IFX_INLINE Ifx_SRC_SRCR *IfxCanxl_Node_getSrcPointerErr(IfxCanxl_NodeId nodeId)
{
    return (Ifx_SRC_SRCR *)(&MODULE_SRC.CANXL[nodeId].ERR);
}


IFX_INLINE Ifx_SRC_SRCR *IfxCanxl_Node_getSrcPointerSafety(IfxCanxl_NodeId nodeId)
{
    return (Ifx_SRC_SRCR *)(&MODULE_SRC.CANXL[nodeId].SAFETY);
}


IFX_INLINE void IfxCanxl_Node_enableTransmitterDelayCompensation(Ifx_CANXL_N *node)
{
    node->MODE.B.TDCE = 1u;
}


IFX_INLINE void IfxCanxl_Node_disableTransmitterDelayCompensation(Ifx_CANXL_N *node)
{
    node->MODE.B.TDCE = 0u;
}


IFX_INLINE void IfxCanxl_Node_enableProtocolExceptionHandling(Ifx_CANXL_N *node)
{
    node->MODE.B.PXHD = 0u;
}


IFX_INLINE void IfxCanxl_Node_disableProtocolExceptionHandling(Ifx_CANXL_N *node)
{
    node->MODE.B.PXHD = 1u;
}


IFX_INLINE void IfxCanxl_Node_enableFunctionalInterrupt(Ifx_CANXL_N *node, uint32 enableMask)
{
    node->FUNC_ENA.U = enableMask;
}


IFX_INLINE uint32 IfxCanxl_Node_getFunctionalInterruptStatus(Ifx_CANXL_N *node)
{
    return (uint32)node->FUNC_RAW.U;
}


IFX_INLINE void IfxCanxl_Node_clearFunctionalInterruptStatus(Ifx_CANXL_N *node, uint32 clearMask)
{
    node->FUNC_CLR.U = clearMask;
}


IFX_INLINE void IfxCanxl_Node_enableErrorInterrupt(Ifx_CANXL_N *node, uint32 enableMask)
{
    node->ERR_ENA.U = enableMask;
}


IFX_INLINE uint32 IfxCanxl_Node_getErrorInterruptStatus(Ifx_CANXL_N *node)
{
    return (uint32)node->ERR_RAW.U;
}


IFX_INLINE void IfxCanxl_Node_clearErrorInterruptStatus(Ifx_CANXL_N *node, uint32 clearMask)
{
    node->ERR_CLR.U = clearMask;
}


IFX_INLINE void IfxCanxl_Node_enableSafetyInterrupt(Ifx_CANXL_N *node, uint32 enableMask)
{
    node->SAFETY_ENA.U = enableMask;
}


IFX_INLINE uint32 IfxCanxl_Node_getSafetyInterruptStatus(Ifx_CANXL_N *node)
{
    return (uint32)node->SAFETY_RAW.U;
}


IFX_INLINE void IfxCanxl_Node_clearSafetyInterruptStatus(Ifx_CANXL_N *node, uint32 clearMask)
{
    node->SAFETY_CLR.U = clearMask;
}


IFX_INLINE void IfxCanxl_Node_enableMtiFlags(Ifx_CANXL_NODE *node, uint32 enableMask)
{
    node->MTI_ENA.U = enableMask;
}


IFX_INLINE uint32 IfxCanxl_Node_getMtiFlagsStatus(Ifx_CANXL_NODE *node)
{
    return (uint32)node->MTI_RAW.U;
}


IFX_INLINE void IfxCanxl_Node_clearMtiFlagsStatus(Ifx_CANXL_NODE *node, uint32 clearMask)
{
    node->MTI_CLR.U = clearMask;
}


IFX_INLINE boolean IfxCanxl_Node_getTxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex)
{
    boolean result = (boolean)((node->FUNC_RAW.U >> (uint32)queueIndex) & 0x1u);
    return result;
}


IFX_INLINE void IfxCanxl_Node_clearTxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex)
{
    node->FUNC_CLR.U = (uint32)1u << (uint32)queueIndex;
}


IFX_INLINE boolean IfxCanxl_Node_getRxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex)
{
    boolean result = (boolean)((node->FUNC_RAW.U >> ((uint32)queueIndex + IFX_CANXL_N_FUNC_RAW_MH_RX_FQ0_IRQ_OFF)) & 0x1u);
    return result;
}


IFX_INLINE void IfxCanxl_Node_clearRxFifoInterruptStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex)
{
    node->FUNC_CLR.U = (uint32)1u << ((uint32)queueIndex + IFX_CANXL_N_FUNC_RAW_MH_RX_FQ0_IRQ_OFF);
}


IFX_INLINE boolean IfxCanxl_Node_getTxFifoSentStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex)
{
    boolean result = (boolean)((node->TX_FQ_INT_STS.U >> (uint32)queueIndex) & 0x1u);
    return result;
}


IFX_INLINE void IfxCanxl_Node_clearTxFifoSentStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex)
{
    node->TX_FQ_INT_STS.U = (uint32)1u << (uint32)queueIndex;
}


IFX_INLINE boolean IfxCanxl_Node_getTxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex)
{
    boolean result = (boolean)((node->TX_FQ_INT_STS.U >> ((uint32)queueIndex + IFX_CANXL_N_TX_FQ_INT_STS_UNVALID_OFF)) & 0x1u);
    return result;
}


IFX_INLINE void IfxCanxl_Node_clearTxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue queueIndex)
{
    node->TX_FQ_INT_STS.U = (uint32)1u << ((uint32)queueIndex + IFX_CANXL_N_TX_FQ_INT_STS_UNVALID_OFF);
}


IFX_INLINE boolean IfxCanxl_Node_getRxFifoReceivedStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex)
{
    boolean result = (boolean)((node->RX_FQ_INT_STS.U >> (uint32)queueIndex) & 0x1u);
    return result;
}


IFX_INLINE void IfxCanxl_Node_clearRxFifoSentStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex)
{
    node->RX_FQ_INT_STS.U = (uint32)1u << (uint32)queueIndex;
}


IFX_INLINE boolean IfxCanxl_Node_getRxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex)
{
    boolean result = (boolean)((node->RX_FQ_INT_STS.U >> ((uint32)queueIndex + IFX_CANXL_N_RX_FQ_INT_STS_UNVALID_OFF)) & 0x1u);
    return result;
}


IFX_INLINE void IfxCanxl_Node_clearRxFifoUnvalidStatus(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue queueIndex)
{
    node->RX_FQ_INT_STS.U = (uint32)1u << ((uint32)queueIndex + IFX_CANXL_N_RX_FQ_INT_STS_UNVALID_OFF);
}


IFX_INLINE void IfxCanxl_Node_startMessageHandler(Ifx_CANXL_N *node)
{
    node->MH_CTRL.U = 0x1u;
}


IFX_INLINE void IfxCanxl_Node_stopMessageHandler(Ifx_CANXL_N *node)
{
    node->MH_CTRL.U = 0x0u;
}


IFX_INLINE void IfxCanxl_Node_enableTxFiltering(Ifx_CANXL_N *node)
{
    while (IfxCanxl_Node_mhBusyStatus(node))
    {}

    node->TX_FILTER_CTRL0.B.EN = 1U;
}


IFX_INLINE void IfxCanxl_Node_disableTxFiltering(Ifx_CANXL_N *node)
{
    while (IfxCanxl_Node_mhBusyStatus(node))
    {}

    node->TX_FILTER_CTRL0.B.EN = 0U;
}


IFX_INLINE void IfxCanxl_Node_acceptCanFDFrameTx(Ifx_CANXL_N *node)
{
    while (IfxCanxl_Node_mhBusyStatus(node))
    {}

    node->TX_FILTER_CTRL0.B.CAN_FD = 0U;
}


IFX_INLINE void IfxCanxl_Node_rejectCanFDFrameTx(Ifx_CANXL_N *node)
{
    while (IfxCanxl_Node_mhBusyStatus(node))
    {}

    node->TX_FILTER_CTRL0.B.CAN_FD = 1U;
}


IFX_INLINE void IfxCanxl_Node_acceptClassicCanFrameTx(Ifx_CANXL_N *node)
{
    while (IfxCanxl_Node_mhBusyStatus(node))
    {}

    node->TX_FILTER_CTRL0.B.CC_CAN = 0U;
}


IFX_INLINE void IfxCanxl_Node_rejectClassicCanFrameTx(Ifx_CANXL_N *node)
{
    while (IfxCanxl_Node_mhBusyStatus(node))
    {}

    node->TX_FILTER_CTRL0.B.CC_CAN = 1U;
}


IFX_INLINE boolean IfxCanxl_Node_mhBusyStatus(Ifx_CANXL_N *node)
{
    return (node->MH_STS.B.BUSY == 1U) ? TRUE : FALSE;
}


IFX_INLINE void IfxCanxl_Node_clearRxStatistics(Ifx_CANXL_N *node)
{
    node->RX_STATISTICS.U = 0u;
}


IFX_INLINE void IfxCanxl_Node_clearTxStatistics(Ifx_CANXL_N *node)
{
    node->TX_STATISTICS.U = 0u;
}


IFX_INLINE IfxCanxl_NodeActivity IfxCanxl_Node_getNodeActivity(Ifx_CANXL_N *node)
{
    IfxCanxl_NodeActivity activity = (IfxCanxl_NodeActivity)node->STAT.B.ACT;
    return activity;
}


IFX_INLINE void IfxCanxl_Node_enableLoopbackMode(Ifx_CANXL_N *node)
{
    /* Enable loopback and ignore RX messages */
    node->TEST.B.LBCK = 0x1u;
    node->TEST.B.TXC  = 0x1u;
}


IFX_INLINE void IfxCanxl_Node_startTxFifoQueue(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue idx)
{
    node->TX_FQ_CTRL0.U = 1u << (uint32)idx;
}


IFX_INLINE void IfxCanxl_Node_startTxPriorityQueue(Ifx_CANXL_N *node, uint8 idx)
{
    node->TX_PQ_CTRL0.U = 1u << (uint32)idx;
}


IFX_INLINE void IfxCanxl_Node_startRxFifoQueue(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue idx)
{
    node->RX_FQ_CTRL0.U = 1u << (uint32)idx;
}


IFX_INLINE boolean IfxCanxl_Node_isTxFifoQueueStopped(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue idx)
{
    boolean stopped;
    stopped = (((node->TX_FQ_STS0.B.STOP >> (uint32)idx) & 0x1u) == 1u) ? TRUE : FALSE;
    return stopped;
}


IFX_INLINE boolean IfxCanxl_Node_isTxFifoQueueBusy(Ifx_CANXL_N *node, IfxCanxl_TxFifoQueue idx)
{
    boolean busy;
    busy = (((node->TX_FQ_STS0.B.BUSY >> (uint32)idx) & 0x1u) == 1u) ? TRUE : FALSE;
    return busy;
}


IFX_INLINE boolean IfxCanxl_Node_isTxPriorityQueueBusy(Ifx_CANXL_N *node, uint8 idx)
{
    boolean busy;
    busy = (((node->TX_PQ_STS0.U >> (uint32)idx) & 0x1u) == 1u) ? TRUE : FALSE;
    return busy;
}


IFX_INLINE boolean IfxCanxl_Node_isRxFifoQueueStopped(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue idx)
{
    boolean stopped;
    stopped = (((node->RX_FQ_STS0.B.STOP >> (uint32)idx) & 0x1u) == 1u) ? TRUE : FALSE;
    return stopped;
}


IFX_INLINE boolean IfxCanxl_Node_isRxFifoQueueBusy(Ifx_CANXL_N *node, IfxCanxl_RxFifoQueue idx)
{
    boolean busy;
    busy = (((node->RX_FQ_STS0.B.BUSY >> (uint32)idx) & 0x1u) == 1u) ? TRUE : FALSE;
    return busy;
}


IFX_INLINE void IfxCanxl_Node_configureAxiParams(Ifx_CANXL_N *node, IfxCanxl_MaxAxiTransactions read, IfxCanxl_MaxAxiTransactions write)
{
    node->AXI_PARAMS.B.AR_MAX_PEND = (uint32)read;
    node->AXI_PARAMS.B.AW_MAX_PEND = (uint32)write;
}


IFX_INLINE boolean IfxCanxl_Node_isBusIntegrationDone(Ifx_CANXL_N *node)
{
    boolean result = (node->STAT.B.INT == 1u) ? FALSE : TRUE;
    return result;
}


#endif /* IFXCANXL_H */
