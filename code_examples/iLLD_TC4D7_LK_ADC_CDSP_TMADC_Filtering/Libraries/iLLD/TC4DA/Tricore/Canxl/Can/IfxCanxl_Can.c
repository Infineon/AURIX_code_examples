/**
 * \file IfxCanxl_Can.c
 * \brief CANXL CAN details
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxCanxl_Can.h"

/** \addtogroup IfxLld_Canxl_Can_Functions
 * \{ */

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Calculates CAN message size in words from data length code (DLC)
 * \param frameMode CAN frame mode
 * \param dataLengthCode DLC encoding
 * \return Payload size in words
 */
IFX_STATIC uint32 IfxCanxl_Can_calculateMessageSizeWords(IfxCanxl_FrameMode frameMode, uint16 dataLengthCode);

/** \} */

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxCanxl_Can_initModule(IfxCanxl_Can *canxl, IfxCanxl_Can_Config *config)
{
    uint8 nodeId;
    canxl->canxl = config->canxl;

    if (IfxCanxl_isModuleEnabled(canxl->canxl) != TRUE)
    {
        /*Enable Module*/
        IfxCanxl_enableModule(canxl->canxl);
    }

    for (nodeId = 0; nodeId < IFXCANXL_NUM_NODES; nodeId++)
    {
        if ((config->enableNode[nodeId] == TRUE) && (IfxCanxl_isNodeEnabled(canxl->canxl, (IfxCanxl_NodeId)nodeId) != TRUE))
        {
            /*Enable Node*/
            IfxCanxl_enableNode(canxl->canxl, (IfxCanxl_NodeId)nodeId);
        }
    }

    /*Store RAM Addresses in handle, will be initialized during initNode*/
    uint32 baseAddress = (uint32)(&MODULE_CANXL0_RAM);

    for (nodeId = 0U; nodeId < IFXCANXL_NUM_NODES; nodeId++)
    {
        canxl->ramAddressNode[nodeId].rxFilterStartAddress       = baseAddress + config->ramOffsetsNode[nodeId].rxFilter;
        canxl->ramAddressNode[nodeId].txFifoQueueDescAddress     = baseAddress + config->ramOffsetsNode[nodeId].txFifoQueueDesc;
        canxl->ramAddressNode[nodeId].txPriorityQueueDescAddress = baseAddress + config->ramOffsetsNode[nodeId].txPriorityQueueDesc;
    }
}


void IfxCanxl_Can_initModuleConfig(IfxCanxl_Can_Config *config, Ifx_CANXL *canxl)
{
    const IfxCanxl_Can_Config defaultConfig = {
        .canxl          = NULL_PTR,
        .enableNode     = {TRUE,   FALSE,FALSE, FALSE},
        .ramOffsetsNode = {
            {
                .rxFilter            = 0U,
                .txFifoQueueDesc     = 0x100U,
                .txPriorityQueueDesc = 0x1000U,
            },
            {
                .rxFilter            = 0x2000U,
                .txFifoQueueDesc     = 0x2100U,
                .txPriorityQueueDesc = 0x3000U,
            },
            {
                .rxFilter            = 0U,
                .txFifoQueueDesc     = 0U,
                .txPriorityQueueDesc = 0U,
            },
            {
                .rxFilter            = 0U,
                .txFifoQueueDesc     = 0U,
                .txPriorityQueueDesc = 0U,
            }
        },
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* take over module pointer */
    config->canxl = canxl;
}


void IfxCanxl_Can_initNodeConfig(IfxCanxl_Can_NodeConfig *config, IfxCanxl_NodeId nodeId, IfxCanxl_Can *canxl)
{
    IFX_CONST IfxCanxl_Can_NodeConfig defaultConfig = {
        .canxl               = NULL_PTR,
        .nodeId              = IfxCanxl_NodeId_0,
        .rxDataContainerMode = IfxCanxl_RxDataContainer_normal,
        .maxRetransmissions  = IfxCanxl_MaxMsgRetransmissions_unlimited,
        .instanceNumber      = 0u,
        .ramAddresses        = {
            .rxFilterStartAddress       = canxl->ramAddressNode[nodeId].rxFilterStartAddress,
            .txFifoQueueDescAddress     = canxl->ramAddressNode[nodeId].txFifoQueueDescAddress,
            .txPriorityQueueDescAddress = canxl->ramAddressNode[nodeId].txPriorityQueueDescAddress,
        },
        .mode      = IfxCanxl_Node_OperationMode_classicalAndFdAndXl,
        .axiParams = {
            .read  = IfxCanxl_MaxAxiTransactions_1,
            .write = IfxCanxl_MaxAxiTransactions_1
        },
        .baudrate                          = {
            .nominal                       = {
                .calc                      = {
                    .baudrate      = 1000000u,
                    .samplePoint   = 7500u,
                    .syncJumpWidth = 0x1u
                },
            },
            .fd                            = {
                .calc                      = {
                    .baudrate      = 1000000u,
                    .samplePoint   = 7500u,
                    .syncJumpWidth = 0x1u,
                    .delayOffset   = 0x1u
                },
            },
            .xl                            = {
                .calc                      = {
                    .baudrate      = 1000000u,
                    .samplePoint   = 7500u,
                    .syncJumpWidth = 0x1u,
                    .delayOffset   = 0x1u
                },
            },
        },
        .pwmEncoder                        = {
            .shortPhase = 0u,
            .longPhase  = 0u,
            .offset     = 0u,
            .enable     = FALSE
        },
        .txFifoQueue                       = {
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = TRUE
            },
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = FALSE
            },
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = FALSE
            },
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = FALSE
            },
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = FALSE
            },
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = FALSE
            },
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = FALSE
            },
            {
                .descriptorStartAddress = 0u,
                .numDescriptors         = IFXCANXL_MAX_TX_DESCRIPTORS,
                .enable                 = FALSE
            },
        },
        .txPriorityQueue                   = {
            .descriptorStartAddress = 0x0u,
            .numSlots               = 0x2u,
            .enable                 = FALSE
        },
        .rxFifoQueue                       = {
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = TRUE
            },
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = FALSE
            },
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = FALSE
            },
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = FALSE
            },
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = FALSE
            },
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = FALSE
            },
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = FALSE
            },
            {
                .descriptorStartAddress    = 0x0u,
                .numDescriptors            = IFXCANXL_MAX_RX_DESCRIPTORS,
                .dataContainerSize         = 65u,
                .dataContainerStartAddress = 0x0u,
                .enable                    = FALSE
            }
        },
        .timeStamp                         = {
            .clockSource      = IfxCanxl_TimebaseClockSource_canInternal,
            .prescaler        = IfxCanxl_TimebaseClockPrescaler_divBy0,
            .capturePosition  = IfxCanxl_TimeStampPosition_startOfFrame,
            .useNode0Timebase = FALSE,
            .enable           = TRUE
        },
        .interrupt                         = {
            .functional                    = {
                .enableMask    = 0x0u,
                .priority      = 0x0u,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .error                         = {
                .enableMask    = 0x0u,
                .priority      = 0x0u,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            },
            .safety                        = {
                .enableMask    = 0x0u,
                .priority      = 0x0u,
                .typeOfService = IfxSrc_Tos_cpu0,
                .vmId          = IfxSrc_VmId_0
            }
        },
        .mti                               = {
            .enableMask                    = 0x0u
        },
        .pins                     = NULL_PTR,
        .calculateBitTimingValues = TRUE,
        .rxFilterConfig           = {
            .acceptNoMatch           = 0x1U,
            .acceptNonFilterFrames   = 0x0U,
            .numRxFilterElements     = 0x0U,
            .thresholdRxDmaFifolevel = IfxCanxl_RxDmaFifoLevel_0,
            .defaultRxQueueNum       = IfxCanxl_RxFifoQueue_0
        }
    };

    /* Default Configuration */
    *config = defaultConfig;

    /* take over module pointer */
    config->canxl  = canxl->canxl;
    config->nodeId = nodeId;
}


boolean IfxCanxl_Can_initNode(IfxCanxl_Can_Node *node, IfxCanxl_Can_NodeConfig *config)
{
    boolean      status  = TRUE;
    Ifx_CANXL_N *nodeSFR = IfxCanxl_getNodePointer(config->canxl, config->nodeId);

    /* Copy configuration variables to handle */
    node->canxl               = config->canxl;
    node->node                = nodeSFR;
    node->rxDataContainerMode = config->rxDataContainerMode;
    node->nodeId              = config->nodeId;
    node->instanceNumber      = config->instanceNumber;
    node->numRxFilterElements = config->rxFilterConfig.numRxFilterElements;

    /* Step: Global configuration of Message handler and FIFO/Queue/Filter */
    {
        IfxCanxl_Node_setOperationMode(nodeSFR, config->mode);

        /* Configure Message handler configuration structure */
        Ifx_CANXL_N_MH_CFG mhCfgReg;
        mhCfgReg.B.RX_CONT_DC  = config->rxDataContainerMode;
        mhCfgReg.B.MAX_RETRANS = config->maxRetransmissions;
        mhCfgReg.B.INST_NUM    = config->instanceNumber;
        nodeSFR->MH_CFG.U      = mhCfgReg.U;

        /* Configure AXI Params */
        IfxCanxl_Node_configureAxiParams(nodeSFR, config->axiParams.read, config->axiParams.write);

        /* Store offsets in registers */
        nodeSFR->RX_FILTER_MEM_ADD.U            = config->ramAddresses.rxFilterStartAddress & 0x0000FFFFU;
        nodeSFR->TX_DESC_MEM_ADD.B.PQ_BASE_ADDR = (uint16)(config->ramAddresses.txPriorityQueueDescAddress & 0x0000FFFFU);
        nodeSFR->TX_DESC_MEM_ADD.B.FQ_BASE_ADDR = (uint16)(config->ramAddresses.txFifoQueueDescAddress & 0x0000FFFFU);

        /* Store absolute addresses in handle */
        node->ramAddresses.rxFilterStartAddress       = config->ramAddresses.rxFilterStartAddress;
        node->ramAddresses.txFifoQueueDescAddress     = config->ramAddresses.txFifoQueueDescAddress;
        node->ramAddresses.txPriorityQueueDescAddress = config->ramAddresses.txPriorityQueueDescAddress;

        /* TODO FUTURE MH_SFTY_CFG and MH_SFTY_CTRL registers */

        /* Reset TX, RX statistics */
        IfxCanxl_Node_clearRxStatistics(nodeSFR);
        IfxCanxl_Node_clearTxStatistics(nodeSFR);
    }

    /* Step: Baud rate calculation */
    if (config->calculateBitTimingValues == TRUE)
    {
        uint32 moduleFreq = IfxCanxl_getModuleFrequency();

        switch (config->mode)
        {
        case IfxCanxl_Node_OperationMode_classical:
        {
            IfxCanxl_Node_configureClassicalBitTiming(nodeSFR, moduleFreq, &config->baudrate.nominal.calc);
            break;
        }
        case IfxCanxl_Node_OperationMode_classicalAndFd:
        {
            IfxCanxl_Node_configureFdBitTiming(nodeSFR, moduleFreq, &config->baudrate.nominal.calc, &config->baudrate.fd.calc);
            break;
        }
        case IfxCanxl_Node_OperationMode_classicalAndFdAndXl:
        {
            IfxCanxl_Node_configureFdXlBitTiming(nodeSFR, moduleFreq, &config->baudrate.nominal.calc, &config->baudrate.fd.calc, &config->baudrate.xl.calc);
            break;
        }
        case IfxCanxl_Node_OperationMode_xl:
        case IfxCanxl_Node_OperationMode_xlWithTransciever:
        default:
        {
            IfxCanxl_Node_configureXlBitTiming(nodeSFR, moduleFreq, &config->baudrate.nominal.calc, &config->baudrate.xl.calc);
            break;
        }
        }
    }
    else
    {
        IfxCanxl_NominalBaudrateRegConfig *regConfig = &config->baudrate.nominal.reg;
        IfxCanxl_Node_setNominalBitTimingValues(nodeSFR, regConfig->syncJumpWidth, regConfig->timeSegment2, regConfig->timeSegment1, regConfig->prescaler);

        if ((config->mode >= IfxCanxl_Node_OperationMode_classicalAndFd) && (config->mode <= IfxCanxl_Node_OperationMode_classicalAndFdAndXl))
        {
            IfxCanxl_DataBaudrateRegConfig *regConfig = &config->baudrate.fd.reg;
            IfxCanxl_Node_setFdDataBitTimingValues(nodeSFR, regConfig->syncJumpWidth, regConfig->timeSegment2, regConfig->timeSegment1, regConfig->delayOffset);
        }

        if (config->mode >= IfxCanxl_Node_OperationMode_classicalAndFdAndXl)
        {
            IfxCanxl_DataBaudrateRegConfig *regConfig = &config->baudrate.xl.reg;
            IfxCanxl_Node_setXlDataBitTimingValues(nodeSFR, regConfig->syncJumpWidth, regConfig->timeSegment2, regConfig->timeSegment1, regConfig->delayOffset);
        }
    }

    /* Step: PWM encoder configuration */
    if (config->pwmEncoder.enable == TRUE)
    {
        status = IfxCanxl_Node_configurePwmEncoder(nodeSFR, config->pwmEncoder.shortPhase, config->pwmEncoder.longPhase, config->pwmEncoder.offset);
    }

    uint8 idx;

    /* Step: TX Queue configuration */
    for (idx = 0U; idx < IFXCANXL_NUM_TX_QUEUES; idx++)
    {
        /* To configure N TX FIFO Queues, only the queue number from 0 to N-1 can be used */
        if (config->txFifoQueue[idx].enable == TRUE)
        {
            IfxCanxl_Can_initTxFifoQueue(node, &config->txFifoQueue[idx], (IfxCanxl_TxFifoQueue)idx);
        }
    }

    /* Step: TX Priority Queue configuration */
    if (config->txPriorityQueue.enable == TRUE)
    {
        IfxCanxl_Can_initTxPriorityQueue(node, &config->txPriorityQueue);
    }

    /* Step: RX Queue configuration */
    for (idx = 0U; idx < IFXCANXL_NUM_RX_QUEUES; idx++)
    {
        if (config->rxFifoQueue[idx].enable == TRUE)
        {
            IfxCanxl_Can_initRxFifoQueue(node, &config->rxFifoQueue[idx], (IfxCanxl_RxFifoQueue)idx);
        }
    }

    /* Step: Timestamp configuration */
    if (config->timeStamp.enable == TRUE)
    {
        IfxCanxl_Can_initTimeStamp(node, &(config->timeStamp));
    }

    /* Step: Interrupt configuration */
    IfxCanxl_Can_initInterrupts(node, &(config->interrupt));

    /* Step: Configure MTI flags */
    IfxCanxl_Node_enableMtiFlags(&node->canxl->NODE[node->nodeId], config->mti.enableMask);

    /* Step: TX & RX Pins Initialization */
    if (config->pins != NULL_PTR)
    {
        if (config->pins->txPin != NULL_PTR)
        {
            IfxCanxl_Node_initTxPin(config->pins->txPin, config->pins->txPinMode, config->pins->padDriver);
        }

        if (config->pins->rxPin != NULL_PTR)
        {
            IfxCanxl_Node_initRxPin(&node->canxl->NODE[config->nodeId], config->pins->rxPin, config->pins->rxPinMode, config->pins->padDriver);
        }
    }

    IfxCanxl_Node_configureGlobalSettingsRxFilter(node->node, &(config->rxFilterConfig));

    return status;
}


void IfxCanxl_Can_initTxFifoQueue(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxFifoQueueConfig *config, IfxCanxl_TxFifoQueue idx)
{
    Ifx_CANXL_N *nodeSFR = node->node;

    /* 1. Store TX Descriptor start address and number of descriptors */
    nodeSFR->TX_FQ[idx].START_ADD.U = config->descriptorStartAddress;
    nodeSFR->TX_FQ[idx].SIZE.U      = config->numDescriptors;

    /* 2. Enable queue */
    nodeSFR->TX_FQ_CTRL2.U |= 1u << (uint32)idx;

    /* 3. Copy to handle */
    node->txFifoQueue[idx].descriptorStartAddress = config->descriptorStartAddress;
}


void IfxCanxl_Can_initTxPriorityQueue(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxPriorityQueueConfig *config)
{
    Ifx_CANXL_N *nodeSFR = node->node;

    /* 1. Store TX Descriptor start address */
    nodeSFR->TX_PQ_START_ADD.U = config->descriptorStartAddress;

    /* 2. Enable queues */
    nodeSFR->TX_PQ_CTRL2.U = (uint32)(((uint64)1u << config->numSlots) - 1u);
}


void IfxCanxl_Can_initRxFifoQueue(IfxCanxl_Can_Node *node, IfxCanxl_Can_RxFifoQueueConfig *config, IfxCanxl_RxFifoQueue idx)
{
    Ifx_CANXL_N *nodeSFR = node->node;

    /* 1. Store RX Descriptor start address, number of descriptors, container size */
    nodeSFR->RX_FQ[idx].START_ADD.U     = config->descriptorStartAddress;
    nodeSFR->RX_FQ[idx].SIZE.B.MAX_DESC = config->numDescriptors;
    nodeSFR->RX_FQ[idx].SIZE.B.DC_SIZE  = config->dataContainerSize;

    /* 2. Store Data container start address if continuous mode is enabled */
    if (node->rxDataContainerMode == IfxCanxl_RxDataContainer_continuous)
    {
        nodeSFR->RX_FQ[idx].DC_START_ADD.U = config->dataContainerStartAddress;
        nodeSFR->RX_FQ[idx].RD_ADD_PT.U    = config->dataContainerStartAddress | 0x3;
    }

    /* 3. Enable queue */
    nodeSFR->RX_FQ_CTRL2.U |= 1u << (uint32)idx;

    /* 4. Copy config into handle. Size in words = Word(data container size * 32 bytes) */
    node->rxFifoQueue[idx].dataContainerSizeWords = (uint16)IFXCANXL_CALC_WORDS_FROM_BYTES((config->dataContainerSize << 5u));
    node->rxFifoQueue[idx].descriptorStartAddress = config->descriptorStartAddress;
    node->rxFifoQueue[idx].numDescriptors         = config->numDescriptors;
    node->rxFifoQueue[idx].descriptor             = (IfxCanxl_RxDescr *)config->descriptorStartAddress;
}


void IfxCanxl_Can_initInterrupts(IfxCanxl_Can_Node *node, IfxCanxl_Can_InterruptConfig *config)
{
    Ifx_CANXL_N  *nodeSFR = node->node;
    Ifx_SRC_SRCR *srcPtr;

    /* 1. Configure functional interrupts */
    if (config->functional.priority > 0u)
    {
        IfxCanxl_Node_enableFunctionalInterrupt(nodeSFR, config->functional.enableMask);

        srcPtr = IfxCanxl_Node_getSrcPointerFunc(node->nodeId);
        IfxSrc_init(srcPtr, config->functional.typeOfService, config->functional.priority, config->functional.vmId);
        IfxSrc_enable(srcPtr);
    }

    /* 2. Configure error interrupts */
    if (config->error.priority > 0u)
    {
        IfxCanxl_Node_enableErrorInterrupt(nodeSFR, config->error.enableMask);

        srcPtr = IfxCanxl_Node_getSrcPointerErr(node->nodeId);
        IfxSrc_init(srcPtr, config->error.typeOfService, config->error.priority, config->error.vmId);
        IfxSrc_enable(srcPtr);
    }

    /* 3. Configure safety interrupts */
    if (config->safety.priority > 0u)
    {
        IfxCanxl_Node_enableSafetyInterrupt(nodeSFR, config->safety.enableMask);

        srcPtr = IfxCanxl_Node_getSrcPointerSafety(node->nodeId);
        IfxSrc_init(srcPtr, config->safety.typeOfService, config->safety.priority, config->safety.vmId);
        IfxSrc_enable(srcPtr);
    }
}


void IfxCanxl_Can_initTimeStamp(IfxCanxl_Can_Node *node, IfxCanxl_Can_TimeStampConfig *config)
{
    Ifx_CANXL_N *nodeSFR = node->node;

    /* 1. Disable Timestamp */
    IfxCanxl_Node_disableTimeStamp(nodeSFR);

    /* 2. Configure clock control */
    Ifx_CANXL_N_TS_CLOCK_CTL clockControlReg;
    clockControlReg.U = 0u;

    if (config->useNode0Timebase == TRUE)   /* Select external timestamp counter and clock */
    {
        clockControlReg.B.SYNC_SEL = 1u;
    }
    else                                    /* Select and configure internal timestamp counter and clock */
    {
        clockControlReg.B.SYNC_SEL  = 0u;
        clockControlReg.B.SRC_SEL   = (uint32)config->clockSource;
        clockControlReg.B.PRESCALER = (uint32)config->prescaler;
    }

    nodeSFR->TS_CLOCK_CTL.U = clockControlReg.U;

    /* 3. Clear Timestamp counter */
    IfxCanxl_Node_clearTimeStampCounter(nodeSFR);

    /* 4. Set timestamp position */
    IfxCanxl_Node_setTimeStampPosition(nodeSFR, config->capturePosition);

    /* 5. Enable Timestamp */
    IfxCanxl_Node_enableTimeStamp(nodeSFR);
}


void IfxCanxl_Can_startNode(IfxCanxl_Can_Node *node, IfxCanxl_Can_StartMode mode)
{
    Ifx_CANXL_N *nodeSFR = node->node;

    /* 1. Enable loop back mode if applicable */
    if (mode == IfxCanxl_Can_StartMode_testLoopback)
    {
        IfxCanxl_Node_configureProtocolOperation(nodeSFR, IfxCanxl_ProtocolOperation_test);
        IfxCanxl_Node_enableLoopbackMode(nodeSFR);
    }

    /* 2. Start the message handler */
    IfxCanxl_Node_startMessageHandler(nodeSFR);

    /* 3. Start the Protocol controller */
    IfxCanxl_Node_configureProtocolOperation(nodeSFR, IfxCanxl_ProtocolOperation_start);
}


void IfxCanxl_Can_stopNode(IfxCanxl_Can_Node *node)
{
    Ifx_CANXL_N *nodeSFR = node->node;

    /* 1. Stop the Protocol controller and wait */
    IfxCanxl_Node_configureProtocolOperation(nodeSFR, IfxCanxl_ProtocolOperation_stop);

    while (IfxCanxl_Node_getNodeActivity(nodeSFR) != IfxCanxl_NodeActivity_inactive)
    {}

    /* 2. Abort all TX FIFO Queues */
    nodeSFR->LOCK.B.ULK    = IFXCANXL_FUNCTIONAL_UNLOCK_KEY1;
    nodeSFR->LOCK.B.ULK    = IFXCANXL_FUNCTIONAL_UNLOCK_KEY2;
    nodeSFR->TX_FQ_CTRL1.U = 0xFFu;

    /* 3. Abort all RX FIFO Queues */
    nodeSFR->LOCK.B.ULK    = IFXCANXL_FUNCTIONAL_UNLOCK_KEY1;
    nodeSFR->LOCK.B.ULK    = IFXCANXL_FUNCTIONAL_UNLOCK_KEY2;
    nodeSFR->RX_FQ_CTRL1.U = 0xFFu;

    /* 4. Abort all TX Priority Queue slots */
    nodeSFR->LOCK.B.ULK    = IFXCANXL_FUNCTIONAL_UNLOCK_KEY1;
    nodeSFR->LOCK.B.ULK    = IFXCANXL_FUNCTIONAL_UNLOCK_KEY2;
    nodeSFR->TX_PQ_CTRL1.U = 0xFFFFFFFFu;

    /* 5. Stop the message handler */
    IfxCanxl_Node_stopMessageHandler(nodeSFR);
}


void IfxCanxl_Can_configureTxFilter(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxFilterConfig *config)
{
    Ifx_CANXL_N                *nodeSFR = node->node;

    Ifx_CANXL_N_TX_FILTER_CTRL0 regTxFilterCtrl0;
    regTxFilterCtrl0.U = 0u;

    /* Enable global Tx filtering. Configure Tx filter interrupt, filter modes, mask & combine mode */
    regTxFilterCtrl0.B.EN     = 1U;
    regTxFilterCtrl0.B.IRQ_EN = config->enableInterrupt;
    regTxFilterCtrl0.B.MODE   = config->mode;
    regTxFilterCtrl0.B.COMB   = config->combineFilter;
    regTxFilterCtrl0.B.MASK   = config->maskFilter;

    Ifx_CANXL_N_TX_FILTER_CTRL1 regTxFilterCtrl1;
    regTxFilterCtrl1.U = 0u;

    /* Configure the valid filter elements and CANXL msg field to be used for compare match */
    regTxFilterCtrl1.B.FIELD = config->fieldMatch;
    regTxFilterCtrl1.B.VALID = config->validFilters;

    Ifx_CANXL_N_TX_FILTER_REFVAL regTxFilterRefVal0;
    regTxFilterRefVal0.U = 0u;

    /*Configure reference value in REFVAL0 register i.e filter element 0 to 3 */
    regTxFilterRefVal0.B.REF_VAL0 = config->refValue->REFVAL0_0;
    regTxFilterRefVal0.B.REF_VAL1 = config->refValue->REFVAL0_1;
    regTxFilterRefVal0.B.REF_VAL2 = config->refValue->REFVAL0_2;
    regTxFilterRefVal0.B.REF_VAL3 = config->refValue->REFVAL0_3;

    Ifx_CANXL_N_TX_FILTER_REFVAL regTxFilterRefVal1;
    regTxFilterRefVal1.U = 0u;

    /*Configure reference value in REFVAL1 register i.e filter element 4 to 7 */
    regTxFilterRefVal1.B.REF_VAL0 = config->refValue->REFVAL1_0;
    regTxFilterRefVal1.B.REF_VAL1 = config->refValue->REFVAL1_1;
    regTxFilterRefVal1.B.REF_VAL2 = config->refValue->REFVAL1_2;
    regTxFilterRefVal1.B.REF_VAL3 = config->refValue->REFVAL1_3;

    Ifx_CANXL_N_TX_FILTER_REFVAL regTxFilterRefVal2;
    regTxFilterRefVal2.U = 0u;

    /*Configure reference value in REFVAL2 register i.e filter element 8 to 11 */
    regTxFilterRefVal2.B.REF_VAL0 = config->refValue->REFVAL2_0;
    regTxFilterRefVal2.B.REF_VAL1 = config->refValue->REFVAL2_1;
    regTxFilterRefVal2.B.REF_VAL2 = config->refValue->REFVAL2_2;
    regTxFilterRefVal2.B.REF_VAL3 = config->refValue->REFVAL2_3;

    Ifx_CANXL_N_TX_FILTER_REFVAL regTxFilterRefVal3;
    regTxFilterRefVal3.U = 0u;

    /*Configure reference value in REFVAL1 register i.e filter element 8 to 11 */
    regTxFilterRefVal3.B.REF_VAL0 = config->refValue->REFVAL3_0;
    regTxFilterRefVal3.B.REF_VAL1 = config->refValue->REFVAL3_1;
    regTxFilterRefVal3.B.REF_VAL2 = config->refValue->REFVAL3_2;
    regTxFilterRefVal3.B.REF_VAL3 = config->refValue->REFVAL3_3;

    /*poll MH_STS.B.BUSY bit before performing write operation to TX filter configure registers*/
    while (IfxCanxl_Node_mhBusyStatus(nodeSFR))
    {}

    nodeSFR->TX_FILTER_CTRL0.U     = regTxFilterCtrl0.U;
    nodeSFR->TX_FILTER_CTRL1.U     = regTxFilterCtrl1.U;
    nodeSFR->TX_FILTER[0].REFVAL.U = regTxFilterRefVal0.U;
    nodeSFR->TX_FILTER[1].REFVAL.U = regTxFilterRefVal1.U;
    nodeSFR->TX_FILTER[2].REFVAL.U = regTxFilterRefVal2.U;
    nodeSFR->TX_FILTER[3].REFVAL.U = regTxFilterRefVal3.U;
}


void IfxCanxl_Can_configureRxFilterElements(IfxCanxl_Can_Node *node, uint8 rxFilterIndex, IfxCanxl_Can_RxFilterElementConfig *config)
{
    IfxCanxl_RxFilterElement  rxFilterElementvalue;
    rxFilterElementvalue.U = 0U;

    uint32                    rxFilterElementAddress = (uint32)(node->ramAddresses.rxFilterStartAddress + (rxFilterIndex * (4u)));
    IfxCanxl_RxFilterElement *rxFilterElement        = (IfxCanxl_RxFilterElement *)rxFilterElementAddress;

    rxFilterElementvalue.B.CREF0 = config->refIndex0;
    rxFilterElementvalue.B.WI0   = config->wordIndex0;
    rxFilterElementvalue.B.AR0   = config->rejectOnMatch0;
    rxFilterElementvalue.B.CREF1 = config->refIndex1;
    rxFilterElementvalue.B.WI1   = config->wordIndex1;
    rxFilterElementvalue.B.AR1   = config->rejectOnMatch1;
    rxFilterElementvalue.B.IRQ   = config->interruptOnMatch;
    rxFilterElementvalue.B.BLK   = config->enableBlackList;
    rxFilterElementvalue.B.FIFO  = config->rxFifoQueueIndex;

    *(rxFilterElement)           = rxFilterElementvalue;
}


void IfxCanxl_Can_configureRxFilterRefMaskValues(IfxCanxl_Can_Node *node, uint8 rxFilterRefIndex, IfxCanxl_Can_RxFilterRefMaskConfig *config)
{
    uint32  rxFilterRefMaskValueAddress = (uint32)(node->ramAddresses.rxFilterStartAddress + ((node->numRxFilterElements) * (4u)) + (rxFilterRefIndex * (8u)));
    uint32 *rxFilterRefMaskValue        = (uint32 *)rxFilterRefMaskValueAddress;

    *rxFilterRefMaskValue        = config->refValue;
    *(rxFilterRefMaskValue + 1u) = config->maskValue;
}


boolean IfxCanxl_Can_sendMessage(IfxCanxl_Can_Node *node, IfxCanxl_Can_TxMessage *msg, IfxCanxl_TxQueueType queueType, uint8 queueIndex)
{
    IfxCanxl_TxDescr *descriptor = NULL_PTR;
    Ifx_CANXL_N      *nodeSFR    = node->node;
    boolean           result     = TRUE;

    /* Step: Wait for queue to free up */
    if (queueType == IfxCanxl_TxQueueType_fifo)
    {
        /* Wait if queue is busy and running */
        while ((IfxCanxl_Node_isTxFifoQueueBusy(nodeSFR, (IfxCanxl_TxFifoQueue)queueIndex) == TRUE) &&
               (IfxCanxl_Node_isTxFifoQueueStopped(nodeSFR, (IfxCanxl_TxFifoQueue)queueIndex) == FALSE))
        {}
    }
    else
    {
        /* TX Priority Queue slot must be inactive */
        while (IfxCanxl_Node_isTxPriorityQueueBusy(nodeSFR, queueIndex) == TRUE)
        {}
    }

    /* Step: Get S_MEM address where descriptor will be stored */
    descriptor = IfxCanxl_Can_getTxDescrPtr(node, queueType, queueIndex);

    /* Step: Prepare TX descriptor */
    IfxCanxl_Can_TxDescrConfig config;
    config.dataPtr          = msg->dataPtr;
    config.frame            = msg->frame;
    config.frameMode        = msg->frameMode;
    config.triggerInterrupt = msg->triggerInterrupt;
    config.wrapQueue        = msg->wrapQueue;
    config.endQueue         = msg->endQueue;
    config.rollingCounter   = (queueType == IfxCanxl_TxQueueType_fifo) ? IFXCANXL_CAN_CALC_TX_RC(node->txFifoQueue[queueIndex].descriptorStartAddress, (uint32)descriptor) : 0u;
    IfxCanxl_Can_configureTxDescriptor(node, descriptor, &config, queueType, queueIndex);

    /* Wait until data is written before triggering new transfer */
    Ifx__dsync();

    /* Step: Start the Queue and wait for it to start */
    if (queueType == IfxCanxl_TxQueueType_fifo)
    {
        IfxCanxl_Node_startTxFifoQueue(nodeSFR, (IfxCanxl_TxFifoQueue)queueIndex);

        while (IfxCanxl_Node_isTxFifoQueueStopped(nodeSFR, (IfxCanxl_TxFifoQueue)queueIndex) == TRUE)
        {}
    }
    else
    {
        IfxCanxl_Node_startTxPriorityQueue(nodeSFR, queueIndex);

        while (IfxCanxl_Node_isTxPriorityQueueBusy(nodeSFR, queueIndex) == FALSE)
        {}
    }

    return result;
}


boolean IfxCanxl_Can_readMessage(IfxCanxl_Can_Node *node, IfxCanxl_Can_RxMessage *msg, IfxCanxl_RxFifoQueue queueIndex)
{
    boolean           status       = TRUE;
    uint32           *rxPtr        = NULL_PTR;
    uint32            idx          = 0U;
    IfxCanxl_RxDescr *descriptor   = node->rxFifoQueue[queueIndex].descriptor;
    uint8             headerLength = 0u;
    /* Initialize message structure */
    msg->dataSizeInWords = 0u;

    if (IfxCanxl_Can_isRxMessageAvailable(node, queueIndex) == TRUE)
    {
        /* Step 1: Read reception address, time stamp information, message status from descriptor */
        rxPtr          = (uint32 *)(descriptor->RXDES1.SW.RX_AP & (~(uint32)0x3u));
        msg->timeStamp = ((uint64)descriptor->RXDES3.U << 32u) | (uint64)descriptor->RXDES2.U;
        msg->msgStatus = (IfxCanxl_RxMsgStatus)descriptor->RXDES0.MH.STS;

        /* Step 2: Get frame mode and header length from first header word. Then, copy the header into message structure */
        msg->frameMode = (IfxCanxl_FrameMode)((*rxPtr >> 30u) & 0x3u);
        headerLength   = (msg->frameMode == IfxCanxl_FrameMode_xl) ? 3u : 2u;

        switch (msg->frameMode)
        {
        case IfxCanxl_FrameMode_classic:
        {
            msg->header.cl.R0.U  = *rxPtr;
            msg->header.cl.R1.U  = *(++rxPtr);
            msg->dataSizeInWords = IfxCanxl_Can_calculateMessageSizeWords(IfxCanxl_FrameMode_classic, (uint16)msg->header.cl.R1.B.DLC);
            break;
        }
        case IfxCanxl_FrameMode_fd:
        {
            msg->header.fd.R0.U  = *rxPtr;
            msg->header.fd.R1.U  = *(++rxPtr);
            msg->dataSizeInWords = IfxCanxl_Can_calculateMessageSizeWords(IfxCanxl_FrameMode_fd, (uint16)msg->header.fd.R1.B.DLC);
            break;
        }
        default:
        case IfxCanxl_FrameMode_xl:
        {
            msg->header.xl.R0.U  = *rxPtr;
            msg->header.xl.R1.U  = *(++rxPtr);
            msg->header.xl.R2.U  = *(++rxPtr);
            msg->dataSizeInWords = IfxCanxl_Can_calculateMessageSizeWords(IfxCanxl_FrameMode_xl, (uint16)msg->header.xl.R1.B.DLC_XL);
            break;
        }
        }

        rxPtr++;    /* Increment pointer to point to payload */

        /* Step 3: Calculate number of words to read from data container. Then copy data from container to user variable */
        uint32  numWords, dataContainerSizeWords, remainingWords;
        uint32 *destPtr = msg->dataPtr;
        dataContainerSizeWords = node->rxFifoQueue[queueIndex].dataContainerSizeWords;
        remainingWords         = msg->dataSizeInWords;
        numWords               = (remainingWords > dataContainerSizeWords - headerLength) ? (dataContainerSizeWords - headerLength) : remainingWords;

        for (idx = 0u; idx < numWords; idx++)
        {
            *destPtr = *rxPtr;
            rxPtr++;
            destPtr++;
        }

        node->node->RX_FQ[queueIndex].RD_ADD_PT.U = (uint32)rxPtr - 4;

        /* Increment RC and set VALID to 0 */
        descriptor->RXDES0.SW.RC    = (uint8)(((uint32)descriptor->RXDES0.SW.RC + node->rxFifoQueue[queueIndex].numDescriptors) & 0x1Fu);
        descriptor->RXDES0.SW.VALID = 0u;

        remainingWords              = msg->dataSizeInWords - numWords;
        IfxCanxl_RxDescr *lastDescriptor = (IfxCanxl_RxDescr *)(node->rxFifoQueue[queueIndex].descriptorStartAddress + (node->rxFifoQueue[queueIndex].numDescriptors - 1u) * 0x10u);

        /* Step 4: Check if data continues to further descriptors. Read more data if needed */
        if ((descriptor->RXDES0.MH.NEXT == 1u) &&   /* NEXT bit must be set */
            (remainingWords > 0u))                  /* Words are remaining */
        {
            while (remainingWords > 0u)
            {
                /* Get next descriptor. If current descriptor is last then jump to first descriptor */
                if (descriptor == lastDescriptor)
                {
                    descriptor = (IfxCanxl_RxDescr *)node->rxFifoQueue[queueIndex].descriptorStartAddress;
                }
                else
                {
                    descriptor++;
                }

                if (descriptor->RXDES0.MH.HD == 1u)     /* If header is set, get out and report failure */
                {
                    status = FALSE;
                    break;
                }

                /* Get pointer to payload in system memory. Copy from data container to user variable */
                rxPtr    = (uint32 *)(descriptor->RXDES1.SW.RX_AP & (~(uint32)0x3u));
                numWords = (remainingWords > dataContainerSizeWords) ? dataContainerSizeWords : remainingWords;

                for (idx = 0u; idx < numWords; idx++)
                {
                    *destPtr = *rxPtr;
                    rxPtr++;
                    destPtr++;
                }

                node->node->RX_FQ[queueIndex].RD_ADD_PT.U = (uint32)rxPtr - 4;

                remainingWords                            = msg->dataSizeInWords - numWords;

                /* Increment RC and set VALID to 0 */
                descriptor->RXDES0.SW.RC    = (uint8)(((uint32)descriptor->RXDES0.SW.RC + node->rxFifoQueue[queueIndex].numDescriptors) & 0x1Fu);
                descriptor->RXDES0.SW.VALID = 0u;
            }
        }

        /* Step 5: Update handle to point to next descriptor */
        if (status == TRUE)
        {
            if (descriptor == lastDescriptor)
            {
                descriptor = (IfxCanxl_RxDescr *)node->rxFifoQueue[queueIndex].descriptorStartAddress;
            }
            else
            {
                descriptor++;
            }
        }

        node->rxFifoQueue[queueIndex].descriptor = descriptor;
    }
    else
    {
        status = FALSE;
    }

    return status;
}


IfxCanxl_TxDescr *IfxCanxl_Can_getTxDescrPtr(IfxCanxl_Can_Node *node, IfxCanxl_TxQueueType queueType, uint8 queueIndex)
{
    IfxCanxl_TxDescr *descriptor = NULL_PTR;
    Ifx_CANXL_N      *nodeSFR    = node->node;

    if (queueType == IfxCanxl_TxQueueType_fifo)
    {
        /* If Queue is not busy, queue starts from START_ADD */
        if (IfxCanxl_Node_isTxFifoQueueBusy(nodeSFR, (IfxCanxl_TxFifoQueue)queueIndex) == FALSE)
        {
            descriptor = (IfxCanxl_TxDescr *)(nodeSFR->TX_FQ[queueIndex].START_ADD.U);
        }
        /* If Queue is busy and stopped, queue starts from Address pointer */
        else if (IfxCanxl_Node_isTxFifoQueueStopped(nodeSFR, (IfxCanxl_TxFifoQueue)queueIndex) == TRUE)
        {
            descriptor = (IfxCanxl_TxDescr *)(nodeSFR->TX_FQ[queueIndex].ADD_PT.U);
        }
        else
        {   /* Unknown */
        }
    }
    else
    {
        /* Define in S_MEM the TX descriptor for the TX Priority Queue slot n, at the address TX_PQ_START_ADD[31:0] + n * 32byte */
        descriptor = (IfxCanxl_TxDescr *)(nodeSFR->TX_PQ_START_ADD.U + (queueIndex << 5u));
    }

    return descriptor;
}


void IfxCanxl_Can_configureTxDescriptor(IfxCanxl_Can_Node *node, IfxCanxl_TxDescr *descriptor, IfxCanxl_Can_TxDescrConfig *config, IfxCanxl_TxQueueType queueType, uint8 queueIndex)
{
    /* Clear all descriptor words */
    descriptor->TXDES0.U = 0u;
    descriptor->TXDES1.U = 0u;
    descriptor->TXDES2.U = 0u;
    descriptor->TXDES3.U = 0u;
    descriptor->TXDES4.U = 0u;
    descriptor->TXDES5.U = 0u;
    descriptor->TXDES6.U = 0u;
    descriptor->TXDES7.U = 0u;

    /* Configure Frame format independent settings */
    /* DWORD 0 */
    descriptor->TXDES0.SW.VALID = 1u;
    descriptor->TXDES0.SW.HD    = 1u;
    descriptor->TXDES0.SW.WRAP  = config->wrapQueue;
    descriptor->TXDES0.SW.IRQ   = config->triggerInterrupt;
    descriptor->TXDES0.SW.PQ    = (queueType == IfxCanxl_TxQueueType_priority) ? TRUE : FALSE;
    descriptor->TXDES0.SW.END   = (queueType == IfxCanxl_TxQueueType_priority) ? 0u : (uint32)config->endQueue;
    descriptor->TXDES0.SW.CRC   = 0u;     /* TODO FUTURE */
    descriptor->TXDES0.SW.FQN   = (queueType == IfxCanxl_TxQueueType_priority) ? (queueIndex >> 1u) : queueIndex;
    descriptor->TXDES0.SW.PQSN0 = (queueType == IfxCanxl_TxQueueType_priority) ? (queueIndex & 1u) : 0u;
    descriptor->TXDES0.SW.RC    = config->rollingCounter;
    /* DWORD 1 */
    descriptor->TXDES1.SW.IN    = node->instanceNumber;
    descriptor->TXDES1.SW.NHDO  = (queueType == IfxCanxl_TxQueueType_priority) ? 0u : 1u;

    /* Configure Frame format dependent settings */
    switch (config->frameMode)
    {
    case IfxCanxl_FrameMode_classic:
    {
        IfxCanxl_Can_ClassicTxMsgConfig *frame = &config->frame.cl;
        /* DWORD 1 */
        descriptor->TXDES1.SW.SIZE   = IfxCanxl_Can_calculateMessageSizeWords(config->frameMode, frame->dataLengthCode);
        /* DWORD 4 */
        descriptor->TXDES4.U         = (frame->extendedId == TRUE) ? frame->messageId : frame->messageId << 18u;
        descriptor->TXDES4.SW.cl.XTD = (uint32)frame->extendedId;
        /* DWORD 5 */
        descriptor->TXDES5.SW.cl.FIR = (frame->faultInjectionRequest == TRUE) ? 1u : 0u;
        descriptor->TXDES5.SW.cl.RTR = (frame->remoteTransmitRequest == TRUE) ? 1u : 0u;

        if (frame->remoteTransmitRequest == FALSE)
        {
            descriptor->TXDES5.SW.cl.DLC = (uint32)frame->dataLengthCode;
            /* DWORD 6 */
            descriptor->TXDES6.SW.TD0    = *config->dataPtr;

            /* DWORD 7 */
            if (frame->dataLengthCode > IfxCanxl_DataLengthCode_4)
            {
                descriptor->TXDES7.SW.TD1 = *(++config->dataPtr);
            }
        }
        else
        {
            descriptor->TXDES5.SW.cl.DLC = 0;
        }

        break;
    }
    case IfxCanxl_FrameMode_fd:
    {
        IfxCanxl_Can_FdTxMsgConfig *frame = &config->frame.fd;

        /* DWORD 1 */
        if (frame->dataLengthCode > IfxCanxl_DataLengthCode_4)
        {
            descriptor->TXDES1.SW.PLSRC = 1u;
        }

        descriptor->TXDES1.SW.SIZE   = IfxCanxl_Can_calculateMessageSizeWords(config->frameMode, frame->dataLengthCode);
        /* DWORD 4 */
        descriptor->TXDES4.U         = (frame->extendedId == TRUE) ? frame->messageId : frame->messageId << 18u;
        descriptor->TXDES4.SW.fd.XTD = (uint32)frame->extendedId;
        descriptor->TXDES4.SW.fd.FDF = 1u;
        /* DWORD 5 */
        descriptor->TXDES5.SW.fd.FIR = (frame->faultInjectionRequest == TRUE) ? 1u : 0u;
        descriptor->TXDES5.SW.fd.ESI = (frame->errorStateIndicator == TRUE) ? 1u : 0u;
        descriptor->TXDES5.SW.fd.BRS = frame->brs;
        descriptor->TXDES5.SW.fd.DLC = (uint32)frame->dataLengthCode;
        /* DWORD 6. Provide copy of first word */
        descriptor->TXDES6.SW.TD0    = *config->dataPtr;
        /* DWORD 7 */
        descriptor->TXDES7.SW.TX_AP  = (uint32)config->dataPtr;
        break;
    }
    default:
    case IfxCanxl_FrameMode_xl:
    {
        IfxCanxl_Can_XlTxMsgConfig *frame = &config->frame.xl;
        /* DWORD 1 */
        descriptor->TXDES1.SW.PLSRC         = 1u;
        descriptor->TXDES1.SW.SIZE          = IfxCanxl_Can_calculateMessageSizeWords(config->frameMode, frame->dataLengthCode);
        /* DWORD 4 */
        descriptor->TXDES4.SW.xl.PriorityID = frame->messageId;
        descriptor->TXDES4.SW.xl.FDF        = 1u;
        descriptor->TXDES4.SW.xl.XLF        = 1u;
        descriptor->TXDES4.SW.xl.SDT        = frame->sduType;
        descriptor->TXDES4.SW.xl.VCID       = frame->virtualCanId;
        /* DWORD 5 */
        descriptor->TXDES5.SW.xl.FIR        = (frame->faultInjectionRequest == TRUE) ? 1u : 0u;
        descriptor->TXDES5.SW.xl.DLC_XL     = (uint32)frame->dataLengthCode;
        /* DWORD 6 */
        descriptor->TXDES6.SW.T2.AF         = frame->acceptanceField;
        /* DWORD 7 */
        descriptor->TXDES7.SW.TX_AP         = (uint32)config->dataPtr;
        break;
    }
    }
}


void IfxCanxl_Can_configureRxDescriptor(IfxCanxl_Can_Node *node, IfxCanxl_RxDescr *descriptor, IfxCanxl_Can_RxDescrConfig *config, uint8 queueIndex)
{
    /* Clear all descriptor words */
    descriptor->RXDES0.U = 0u;
    descriptor->RXDES1.U = 0u;
    descriptor->RXDES2.U = 0u;
    descriptor->RXDES3.U = 0u;

    /* Configure descriptors */
    /* DWORD 0 */
    descriptor->RXDES0.SW.IRQ   = (config->triggerInterrupt == TRUE) ? 1u : 0u;
    descriptor->RXDES0.SW.CRC   = 0u;     /* TODO FUTURE */
    descriptor->RXDES0.SW.FQN   = queueIndex;
    descriptor->RXDES0.SW.IN    = node->instanceNumber;
    descriptor->RXDES0.SW.RC    = config->rollingCounter;
    /* DWORD 1 */
    descriptor->RXDES1.SW.RX_AP = (node->rxDataContainerMode == IfxCanxl_RxDataContainer_normal) ? (uint32)config->dataContainerStartAddress : 0u;
}


IFX_STATIC uint32 IfxCanxl_Can_calculateMessageSizeWords(IfxCanxl_FrameMode frameMode, uint16 dataLengthCode)
{
    uint32 dataSizeInWords;

    switch (frameMode)
    {
    case IfxCanxl_FrameMode_classic:
    {
        if (dataLengthCode <= 8u)
        {
            dataSizeInWords = IFXCANXL_CALC_WORDS_FROM_BYTES(dataLengthCode);
        }
        else
        {
            dataSizeInWords = 2u;
        }

        break;
    }
    case IfxCanxl_FrameMode_fd:
    {
        if (dataLengthCode <= 8u)
        {
            dataSizeInWords = IFXCANXL_CALC_WORDS_FROM_BYTES(dataLengthCode);
        }
        else
        {
            /* CAN-FD mapping of DLC to number of bytes */
            uint16 dataSizeInBytes[7] = {
                12u, 16u, 20u, 24u, 32u, 48u, 64u
            };
            dataSizeInWords = IFXCANXL_CALC_WORDS_FROM_BYTES(dataSizeInBytes[dataLengthCode - 9u]);
        }

        break;
    }
    default:
    case IfxCanxl_FrameMode_xl:
    {
        /* For XL frames, the numbers 0 to 2047 code 1 to 2048 data bytes */
        dataSizeInWords = IFXCANXL_CALC_WORDS_FROM_BYTES((dataLengthCode + 1U));
        break;
    }
    }

    return dataSizeInWords;
}


boolean IfxCanxl_Can_isRxMessageAvailable(IfxCanxl_Can_Node *node, uint8 queueIndex)
{
    boolean                    status;
    volatile IfxCanxl_RxDescr *descriptor = (volatile IfxCanxl_RxDescr *)node->rxFifoQueue[queueIndex].descriptor;

    /* Check if descriptor has been executed and header is present */
    status = ((descriptor->RXDES0.SW.VALID == 1u) && (descriptor->RXDES0.MH.HD == 1u)) ? TRUE : FALSE;

    return status;
}
