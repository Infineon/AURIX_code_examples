/**
 * \file IfxPms_cfg.h
 * \brief PMS on-chip implementation data
 * \ingroup IfxLld_Pms
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2021 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pms PMS
 * \ingroup IfxLld
 * \defgroup IfxLld_Pms_Impl Implementation
 * \ingroup IfxLld_Pms
 * \defgroup IfxLld_Pms_Std Pm and Evr Drivers
 * \ingroup IfxLld_Pms
 */

#ifndef IFXPMS_CFG_H
#define IFXPMS_CFG_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Ifx_Cfg.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief This macro is intended to be defined in Ifx_Cfg.h and is meant to cut off the clock supply to desired modules by writing to their respective CLC.B.DISR or CLC.B.EDIS.
 * It is used in IfxPmsPm_startStandbySequenceInFlash().
 * If the master CPU does not have the permission. Functionality should be handled through IPC mechanism
 *
 * This macro is empty by default.
 *
 *   Example usage:
 *  #define IFXPMS_DISABLE_ALL_MODULES_STANDBY        ({  \                                                      \
 *    #if (IFX_PROT_ENABLED == 1U)                        \
 *         IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_ASCLIN.PROT_E, \ IfxApProt_State_config); \
 *       #endif                 \
 *     MODULE_ASCLIN.CLC.B.DISR = 1;                      \
 *  #if (IFX_PROT_ENABLED == 1U)     \
 *        IfxApProt_setState((Ifx_PROT_PROT *)&&MODULE_ASCLIN.PROT_E), \ IfxApProt_State_run);       \
 *  #endif                 \
 *   })
 */
#ifndef IFXPMS_DISABLE_ALL_MODULES_STANDBY
#define IFXPMS_DISABLE_ALL_MODULES_STANDBY
#endif

/** \brief Number of cycles to wait after switching to backup clock is triggered before shutting down the oscillator.
 * This is given as a configurable macro because the value required has been seen to vary and so the application may define it in Ifx_Cfg.h.
 */
#ifndef IFXPMS_WAIT_CYCLES
#define IFXPMS_WAIT_CYCLES 100
#endif

/** \brief This macro is intended to be defined in Ifx_Cfg.h.
 *  It is meant for throttling system clock to 100Mhz, switch to backup clock and enable low power operation(LPDIV =1).
 *  It is used in IfxPmsPm_startStandbySequenceInFlash().
 *  If the master CPU does not have the permission. Functionality should be handled through IPC mechanism
 *  This macro is empty by default.
 *  Example usage:
 *
 *  Declare global
 *  IfxClock_Config clkConfig;
 *  //Do the required configuration
 *
 * #define IFXPMS_CLOCK_REDUCTION      ({    \
 * IfxClock_switchToBackupClock(&clkConfig);                     \
 * #if (IFX_PROT_ENABLED == 1U)                                   \
 *   IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTSE, IfxApProt_State_config); \
 * #endif                                                         \
 * CLOCK_SYSPLLCON0.B.PLLPWR = 0;                                \
 * CLOCK_PERPLLCON0.B.PLLPWR = 0;                                \
 * #if (IFX_PROT_ENABLED == 1U)                                  \
 *   IfxApProt_setState((Ifx_PROT_PROT *)&CLOCK_PROTSE, IfxApProt_State_run); \
 * #endif                                                        \
 * IfxClock_switchToLowPowerMode(IfxClock_LowPowerDivRatio_divBy1) \
 * })
 */
#ifndef IFXPMS_CLOCK_REDUCTION
#define IFXPMS_CLOCK_REDUCTION
#endif

/** \brief CPU5 DCache base address
 */
#define IFXPMS_CPU5_DCACHE_ADDRESS (0x2001C000)

/** \brief CPU4 DCache base address
 */
#define IFXPMS_CPU4_DCACHE_ADDRESS (0x3001C000)

/** \brief CPU3 DCache base address
 */
#define IFXPMS_CPU3_DCACHE_ADDRESS (0x4001C000)

/** \brief CPU2 DCache base address
 */
#define IFXPMS_CPU2_DCACHE_ADDRESS (0x5003C000)

/** \brief CPU1 DCache base address
 */
#define IFXPMS_CPU1_DCACHE_ADDRESS (0x6003C000)

/** \brief CPU0 DCache base address
 */
#define IFXPMS_CPU0_DCACHE_ADDRESS (0x7003C000)

/** \brief CPU0 segment
 */
#define IFXPMS_CPU0_DCACHE_SEGMENT (7U)

/** \brief CPU1 segment
 */
#define IFXPMS_CPU1_DCACHE_SEGMENT (6U)

/** \brief CPU2 segment
 */
#define IFXPMS_CPU2_DCACHE_SEGMENT (5U)

/** \brief CPU3 segment
 */
#define IFXPMS_CPU3_DCACHE_SEGMENT (4U)

/** \brief CPU4 segment
 */
#define IFXPMS_CPU4_DCACHE_SEGMENT (3U)

/** \brief CPU5 segment
 */
#define IFXPMS_CPU5_DCACHE_SEGMENT (2U)

/** \brief This macro is intended to be defined in Ifx_Cfg.h and is meant for disabling the watchdog,interrupt of other cores and Dcache writeback of other cores.
 *  Once the interrupts are disabled set the core state to idle
 * It is used in IfxPmsPm_startStandbySequenceInFlash().
 *
 *  If the master CPU does not have the permission. Functionality should be handled through IPC mechanism.
 *  Create a variable locate in LMU and poll the variable from other cores.
 *  Set the variable from core for which the user wish to trigger standby entry, to indicate to other cores.
 *  Example for IPC mechanism will be added later.
 *
 *  This macro is empty by default.For example:
 *  Example usage:
 *  1. Clear all the pending interrupt
 *  2. Disable Interrupt for other cores except master
 *  --> If the master Cpu has the permission to disable interrupt of other cores.
 *      IfxCpu_disableInterruptsAllExceptMaster(masterCpu)
 *  --> If the master cpu does not have the permission then through IPC mechanism disable IE bit for the respective core
 *      CPUx_ICR.B.IE = 0;
 *  3. Disable watchdog for other cores using below API
 *     wdgPwd = IfxWtu_getCpuWatchdogPassword();
 *     IfxWtu_disableCpuWatchdog(wdgPwd);
 *  4. Dcache writeback for other cpu
 *  5. Placing all CPUs to Idle state except master.
 *     --> If the master cpu has the permission to put other cores to idle
 *         IfxSmmSysMode_setAllIdleExceptMasterCpu(masterCpu);
 *     --> If the master cpu does not have the permission then through IPC mechanism call the below function from the respective core
 *         IfxSmmSysMode_setCoreMode(cpu, IfxSmmSysMode_RqPwMd_idle);
 *
 * #define IFXPMS_DISABLE_INTERRUPT_WATCDHDOG          \
 * ({                                                 \
 *      IfxCpu_disableInterruptsAllExceptMaster(masterCpu);
 *     //Call below api from other cores to disable watchdog   \
 *     //  wdgPwd = IfxWtu_getCpuWatchdogPassword();   \
 *     //  IfxWtu_disableCpuWatchdog(wdgPwd); \
 *     IfxSmmSysMode_setAllIdleExceptMasterCpu(masterCpu);   \
 * })
 */
#ifndef IFXPMS_DISABLE_INTERRUPT_WATCDHDOG_DCADCHE_WRITEBACK
#define IFXPMS_DISABLE_INTERRUPT_WATCDHDOG_DCADCHE_WRITEBACK
#endif

/** \brief This macro is intended to be defined in Ifx_Cfg.h and is meant for disabling the HOST and CSRM FLASH
 * It is used in IfxPmsPm_continueStandbySequenceInRAM().
 *
 *  If the master CPU does not have the permission. Functionality should be handled through IPC mechanism
 *  This macro is empty by default.
 *  Example usage:
 *
 * #define IFXPMS_DISABLE_FLASH          \
 * ({                                        \
 *  //Disabling FLASH                         \
 *  volatile uint32  *sleepaddr = (volatile uint32 *)(0xF8080000U | 0xAA00U);  \
 *  *sleepaddr = 0x10FFFU;                                              \
 *                                                                      \
 *  //Waiting for PFLASH[0-5] and Host DFLASH to enter sleep mode           \
 *  while (!((DMU_HCI_SLEEP.U & 0x10FFFU) == 0x10FFFU))                \
 *  {}     \
 *             \
 *  //Disabling CSRM FLASH                 \
 *  volatile uint32  *csrmsleepaddr = (volatile uint32 *)(0xF80C0000U | 0xAA00U);  \
 *  *csrmsleepaddr =  0x60000U;                                    \
 * })
 */
#ifndef IFXPMS_DISABLE_FLASH
#define IFXPMS_DISABLE_FLASH
#endif

/** \brief SCR XRAM address to load the magic pattern
 */
#define IFXPMS_SCR_XRAM_MAGIC_PATTERN_ADDRESS (0xF0247FF8)

/** \brief TImeout value for SCR to enable.
 */
#ifndef IFXPMS_SCR_ENABLE_TIMEOUT
#define IFXPMS_SCR_ENABLE_TIMEOUT             (0x100)
#endif

#endif /* IFXPMS_CFG_H */
