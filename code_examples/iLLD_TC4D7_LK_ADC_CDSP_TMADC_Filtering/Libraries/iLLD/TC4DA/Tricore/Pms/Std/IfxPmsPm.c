/**
 * \file IfxPmsPm.c
 * \brief PMS  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxPmsPm.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

void IfxPmsPm_initStandbyConfig(IfxPmsPm_StandbyConfig *standbyConfig)
{
    standbyConfig->trigger                                            = IfxPmsPm_StandbyTriggerMode_hardware_undervoltage_vddext;
    standbyConfig->minDelayBeforeWakeUp                               = IfxPmsPm_BlankingFilterDelay_156us;
    standbyConfig->scrCfg.enableScr                                   = FALSE;
    standbyConfig->scrCfg.scrClockSupply                              = IfxPmsPm_ScrClocking_startswith70kHz;
    standbyConfig->scrCfg.scrTriggerTransition                        = IfxPmsPm_ScrTriggerTransition_disable;
    standbyConfig->standbyCfg.standbyRamBlock                         = IfxPmsPm_StandbyRamSupply_never;
    standbyConfig->standbyCfg.standbySCRRamSupply                     = IfxPmsPm_StandbySCRRamSupply_nosupply;
    standbyConfig->standbyCfg.standbyModeSel                          = IfxPmsPm_StandbyModeSelection_stdby0;
    standbyConfig->standbyCfg.enableVddextdcPowerDown                 = FALSE;
    standbyConfig->standbyCfg.esr2DigitalFilterUsage                  = IfxPmsPm_DigitalFilterConfiguration_bypassed;
    standbyConfig->padCfg.allPads                                     = IfxPmsPm_PadStateRequest_inputWithWeakPullUp;
    standbyConfig->padCfg.standbyPads                                 = IfxPmsPm_PadStateRequest_inputWithWeakPullUp;
    standbyConfig->padCfg.esr0PinStateRequest                         = IfxPmsPm_PinStateRequest_resetOutput;
    standbyConfig->voltageCfg.enableStandbyOnVextRampDown             = FALSE;
    standbyConfig->voltageCfg.enableStandbyOnVddRampDown              = FALSE;
    standbyConfig->voltageCfg.vextUnderVoltageThreshold               = 2912.07f;
    standbyConfig->voltageCfg.vddUnderVoltageThreshold                = 838.566f;
    standbyConfig->voltageCfg.vddFilter                               = 4U;
    standbyConfig->voltageCfg.vextFilter                              = 4U;
    standbyConfig->voltageCfg.vddUnderVoltageMode                     = IfxPmsEvr_UnderVoltageMonitoring_inactive;
    standbyConfig->voltageCfg.vextUnderVoltageMode                    = IfxPmsEvr_UnderVoltageMonitoring_inactive;
    standbyConfig->wakeupCfg.enableWakeupOnScr                        = FALSE;
    standbyConfig->wakeupCfg.enableWakeupOnPorst                      = FALSE;
    standbyConfig->wakeupCfg.enableWakeupOnPinA                       = FALSE;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModeWut                 = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModeRtc                 = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModePinC                = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModePinB                = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModePinSSB              = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModePinSEXT             = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModeEsr2                = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.enableWakeupOnEsr1                       = FALSE;
    standbyConfig->wakeupCfg.enableWakeupOnEsr0                       = FALSE;
    standbyConfig->wakeupCfg.wakeupEvent.stdbyModePower               = IfxPmsPm_WakeupStandbyModeSel_disable;
    standbyConfig->wakeupCfg.eventFilterConfig.esr2DigitalFilterUsage = IfxPmsPm_DigitalFilterConfiguration_bypassed;
    standbyConfig->wakeupCfg.eventFilterConfig.esr1DigitalFilterUsage = IfxPmsPm_DigitalFilterConfiguration_bypassed;
    standbyConfig->wakeupCfg.eventFilterConfig.esr0DigitalFilterUsage = IfxPmsPm_DigitalFilterConfiguration_bypassed;
    standbyConfig->wakeupCfg.eventFilterConfig.pinCDigitalFilterUsage = IfxPmsPm_DigitalFilterConfiguration_bypassed;
    standbyConfig->wakeupCfg.eventFilterConfig.pinADigitalFilterUsage = IfxPmsPm_DigitalFilterConfiguration_bypassed;
    standbyConfig->wakeupCfg.eventFilterConfig.pinBDigitalFilterUsage = IfxPmsPm_DigitalFilterConfiguration_bypassed;
    standbyConfig->wakeupCfg.edgeTrigger.esr2TriggerEvent             = IfxPmsPm_PinEdgeTriggerEvent_none;
    standbyConfig->wakeupCfg.edgeTrigger.esr1TriggerEvent             = IfxPmsPm_PinEdgeTriggerEvent_none;
    standbyConfig->wakeupCfg.edgeTrigger.esr0TriggerEvent             = IfxPmsPm_PinEdgeTriggerEvent_none;
    standbyConfig->wakeupCfg.edgeTrigger.pinCTriggerEvent             = IfxPmsPm_PinEdgeTriggerEvent_none;
    standbyConfig->wakeupCfg.edgeTrigger.pinBTriggerEvent             = IfxPmsPm_PinEdgeTriggerEvent_none;
    standbyConfig->wakeupCfg.edgeTrigger.pinATriggerEvent             = IfxPmsPm_PinEdgeTriggerEvent_none;
}


void IfxPmsPm_startStandbySequenceInFlash(Ifx_PMS *pms, IfxPmsPm_StandbyConfig *standbyConfig)
{
    Ifx_SMM_PMSWCR1      pmsWcr1;
    Ifx_PMS_STANDBY_CON0 stdbyCon0;
    Ifx_PMS_STANDBY_CON1 stdbyCon1;
    uint16               wdgPwd;

    /*Reading register */
    pmsWcr1.U   = SMM_PMSWCR1.U;
    stdbyCon1.U = pms->STANDBY.CON1.U;
    stdbyCon0.U = pms->STANDBY.CON0.U;

    /*Set current CPU as the Master CPU*/
    IfxSmmSysMode_setMasterCpu(IfxCpu_getCoreIndex());

    standbyConfig->masterCpu = IfxSmmSysMode_getMasterCpu();

    if (standbyConfig->trigger == IfxPmsPm_StandbyTriggerMode_software)
    {
        /* Enable global system mode entry if not enabled*/
        if (!SMM_PMSWCR1.B.PROCMODEEN)
        {
            pmsWcr1.B.PROCMODEEN = 1u;
        }

        /* Disabling CPU watchdog */
        wdgPwd = IfxWtu_getCpuWatchdogPassword();
        IfxWtu_disableCpuWatchdog(wdgPwd);

        /* Peripherals module clock should be switched off */
        IFXPMS_DISABLE_ALL_MODULES_STANDBY;

        /*User has to Ramp down system clock, switch off SYSPLL and PERPLL, lower clock dividers */
        IFXPMS_CLOCK_REDUCTION;

        /*Application hook for disabling watchdog, interrupt and placing other CPU to idle state*/
        IFXPMS_DISABLE_INTERRUPT_WATCDHDOG_DCADCHE_WRITEBACK;

        /*Choosing Standby entry mode in the case of both VEVRSB and VEXT remaining active in Standby Mode*/
        /* Standby entry triggered by software */
        pmsWcr1.B.STBYEVEN    = 1;
        pmsWcr1.B.STBYEV      = IfxPmsPm_StandbyTriggerMode_software;
        stdbyCon1.B.SWESRSBEN = 1;

        /* Disable Standby SMU*/
        IfxSmuStdby_enableSmuStdby(IfxSmuStdby_SmuStdbyModuleState_disable);

        /*  IRADIS bit to disable Idle Request Acknowledge sequence
         * activation for fast Standby Mode entry. This ensures that standby request
         * is not blocked by pending request or sequence*/
        pmsWcr1.B.IRADIS = 1;
    }
    else if (standbyConfig->trigger == IfxPmsPm_StandbyTriggerMode_hardware_esr1)
    {
        /* Standby entry triggered by NMI event*/
        pmsWcr1.B.STBYEVEN    = 1;
        pmsWcr1.B.STBYEV      = IfxPmsPm_StandbyTriggerMode_hardware_esr1;
        stdbyCon1.B.SWESRSBEN = 1;
    }
    else if (standbyConfig->trigger == IfxPmsPm_StandbyTriggerMode_hardware_esr2)
    {
        /* Standby entry triggered on ESR2 event */
        stdbyCon0.B.ESR2SBEN = 1;
    }
    else if (standbyConfig->trigger == IfxPmsPm_StandbyTriggerMode_hardware_undervoltage_vddext)
    {
        /* Standby entry trigger on vddext under voltage event */
        stdbyCon0.B.VDDEXTSBEN = 1;
    }
    else
    {
        /* Standby entry trigger on vdd under voltage event */
        stdbyCon1.B.VDDSBEN = 1;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

    /*Writing register back */
    SMM_PMSWCR1.U       = pmsWcr1.U;
    pms->STANDBY.CON0.U = stdbyCon0.U;
    pms->STANDBY.CON1.U = stdbyCon1.U;

    /* Configure UVVAL and UVMOD for vddext and vdd */
    if (standbyConfig->voltageCfg.enableStandbyOnVextRampDown)
    {
        IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(pms, standbyConfig->voltageCfg.vextUnderVoltageThreshold, IfxPmsEvr_SecondaryMonitorVoltageSource_vddext);
        IfxPmsEvr_setUnderVoltageMonitoringMode(pms, standbyConfig->voltageCfg.vextUnderVoltageMode, IfxPmsEvr_SecondaryMonitorVoltageSource_vddext);
        pms->VMONS.VDDEXTCON.B.FILTER = standbyConfig->voltageCfg.vextFilter;
    }

    if (standbyConfig->voltageCfg.enableStandbyOnVddRampDown)
    {
        IfxPmsEvr_setSecondaryUnderVoltageThresholdMv(pms, standbyConfig->voltageCfg.vddUnderVoltageThreshold, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
        IfxPmsEvr_setUnderVoltageMonitoringMode(pms, standbyConfig->voltageCfg.vddUnderVoltageMode, IfxPmsEvr_SecondaryMonitorVoltageSource_vdd);
        pms->VMONS.VDDCON.B.FILTER = standbyConfig->voltageCfg.vddFilter;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_continueStandbySequenceInRAM(Ifx_PMS *pms, IfxPmsPm_StandbyConfig *standbyConfig)
{
    Ifx_PMS_STANDBY_CON0 stdbyCon0;
    Ifx_PMS_PAD_CON      padCon;
    Ifx_PMS_SCR_CON0     scrCon0;

    if (standbyConfig->trigger == IfxPmsPm_StandbyTriggerMode_software)
    {
        /* Application hook for disabling HOST/CSRM flash for other CPU*/
        IFXPMS_DISABLE_FLASH;

        uint32 datacache    = (uint32)__mfcr(CPU_PMA0);
        uint8 *cpucacheptr  = NULL_PTR;
        uint8  cachesegment = 0;
        uint16 index;

        switch (standbyConfig->masterCpu)
        {
        case IfxCpu_ResourceCpu_0:
            cpucacheptr  = (uint8 *)IFXPMS_CPU0_DCACHE_ADDRESS;
            cachesegment = IFXPMS_CPU0_DCACHE_SEGMENT;
            break;
#if IFXCPU_NUM_MODULES > 2
        case IfxCpu_ResourceCpu_1:
            cpucacheptr  = (uint8 *)IFXPMS_CPU1_DCACHE_ADDRESS;
            cachesegment = IFXPMS_CPU1_DCACHE_SEGMENT;
            break;
#endif
#if IFXCPU_NUM_MODULES > 3
        case IfxCpu_ResourceCpu_2:
            cpucacheptr  = (uint8 *)IFXPMS_CPU2_DCACHE_ADDRESS;
            cachesegment = IFXPMS_CPU2_DCACHE_SEGMENT;
            break;
#endif
#if IFXCPU_NUM_MODULES > 4
        case IfxCpu_ResourceCpu_3:
            cpucacheptr  = (uint8 *)IFXPMS_CPU3_DCACHE_ADDRESS;
            cachesegment = IFXPMS_CPU3_DCACHE_SEGMENT;
            break;
#endif
#if IFXCPU_NUM_MODULES > 5
        case IfxCpu_ResourceCpu_4:
            cpucacheptr  = (uint8 *)IFXPMS_CPU4_DCACHE_ADDRESS;
            cachesegment = IFXPMS_CPU4_DCACHE_SEGMENT;
            break;
#endif
#if IFXCPU_NUM_MODULES > 6
        case IfxCpu_ResourceCpu_5:
            cpucacheptr  = (uint8 *)IFXPMS_CPU5_DCACHE_ADDRESS;
            cachesegment = IFXPMS_CPU5_DCACHE_SEGMENT;
            break;
#endif
        default:
            /* Invalid Core selected */
            break;
        }

        if (cpucacheptr != NULL_PTR)
        {
            if (datacache & (1 << cachesegment))
            {
                /* D-cahe writeback for master CPU D-cache*/
                for (index = 0; index < 512; index++)
                {
                    Ifx__cacheiwi(cpucacheptr);
                    cpucacheptr = cpucacheptr + 0x20;
                }
            }
        }

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif

        /*Disabling possibilities for Application Reset and System Reset*/
        SMM_RSTTRIGCTRLA.U = 0;
        SMM_RSTTRIGCTRLB.U = 0;

#if (IFX_PROT_ENABLED == 1U)
        IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
    }

    /*Reading register */
    stdbyCon0.U = pms->STANDBY.CON0.U;
    scrCon0.U   = pms->SCR.CON0.U;
    padCon.U    = pms->PAD.CON.U;

    /*Standby Configuration */
    {
        /* Standby RAM block supply */
        stdbyCon0.B.SBRAMSEL      = standbyConfig->standbyCfg.standbyRamBlock;
        /* SCR RAM select */
        stdbyCon0.B.SCRRAMSEL     = standbyConfig->standbyCfg.standbySCRRamSupply;
        /* Enable/Disable transition from STBY1 to STDBY0 */
        stdbyCon0.B.SCRSTBY0EN    = standbyConfig->scrCfg.scrTriggerTransition;
        /* Enable/Disable Vddextdc power down during standby mode */
        stdbyCon0.B.VDDEXTDCPWRDN = standbyConfig->standbyCfg.enableVddextdcPowerDown;
        /* Enable/Disable Esr2 digital filter usage for standby entry */
        stdbyCon0.B.ESR2DFEN      = standbyConfig->standbyCfg.esr2DigitalFilterUsage;
    }
    /* Pad state configuration */
    {
        padCon.B.ALLTRIST_P = 1;
        padCon.B.ALLTRIST   = standbyConfig->padCfg.allPads;
        padCon.B.SBTRIST_P  = 1;
        padCon.B.SBTRIST    = standbyConfig->padCfg.standbyPads;
        padCon.B.ESR0PD     = standbyConfig->padCfg.esr0PinStateRequest;
    }

    /* SCR Configuration. Enable and configure SCR if not enabled */
    if ((standbyConfig->scrCfg.enableScr == TRUE) && (pms->SCR.CON0.B.SCREN != 1u))
    {
        /* Standby clock source selection */
        scrCon0.B.SCRCLKSEL  = standbyConfig->scrCfg.scrClockSupply;
        /* Configuring Standby Controller(SCR) if usage during standby mode is enabled */
        scrCon0.B.SCREN_P    = 1;
        scrCon0.B.SCREN      = 1u;
        scrCon0.B.PORSTREQ_P = 1;
        scrCon0.B.PORSTREQ   = 0;                                                        //To avoid SCR reset during standby entry.
    }
    else if ((standbyConfig->scrCfg.enableScr == TRUE) && (pms->SCR.CON0.B.SCREN == 1u)) /* Configure clock source and PORST if SCR already enabled */
    {
        /* Standby clock source selection */
        scrCon0.B.SCRCLKSEL  = standbyConfig->scrCfg.scrClockSupply;
        scrCon0.B.PORSTREQ_P = 1;
        scrCon0.B.PORSTREQ   = 0;  //To avoid SCR reset during standby entry.
    }
    else /* Disable SCR */
    {
        scrCon0.B.SCREN   = 0u;
        scrCon0.B.SCREN_P = 1;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    /*Standby Configuration */
    pms->STANDBY.CON0.U          = stdbyCon0.U;
    /*PAD configuration */
    pms->PAD.CON.U               = padCon.U;
    /*SCR configuration */
    pms->SCR.CON0.U              = scrCon0.U;
    /* Clearing all overrun and wakeup status bits.*/
    pms->WAKEUP.CLR0.U           = IFXPMSPM_WAKEUP_OVRUN_FLAGS_CLR0;
    pms->WAKEUP.CLR1.U           = IFXPMSPM_WAKEUP_OVRUN_FLAGS_CLR1;
    /* Standby Mode Selection */
    pms->STANDBY.CON1.B.SBMODSEL = standbyConfig->standbyCfg.standbyModeSel;
    /* Configure blanking filter */
    pms->WAKEUP.CON0.B.BLNKFIL   = standbyConfig->minDelayBeforeWakeUp;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
    /* Wakeup Configuration */
    IfxPmsPm_configureWakeup(pms, &standbyConfig->wakeupCfg);
}


void IfxPmsPm_configureWakeup(Ifx_PMS *pms, IfxPmsPm_WakeupConfig *wakeupConfig)
{
    Ifx_PMS_WAKEUP_CON0 wakeupCon0;
    Ifx_PMS_WAKEUP_CON1 wakeupCon1;

    wakeupCon0.U = pms->WAKEUP.CON0.U;
    wakeupCon1.U = pms->WAKEUP.CON1.U;

    /*SCR wakeup enable */
    if (wakeupConfig->enableWakeupOnScr)
    {
        wakeupCon1.B.SCRWKEN = 1u;
    }

    /*RTC and WUT wakeup configuration */
    wakeupCon0.B.WUTWKEN   = wakeupConfig->wakeupEvent.stdbyModeWut;
    wakeupCon0.B.RTCWKEN   = wakeupConfig->wakeupEvent.stdbyModeRtc;
    /*ESR2 Wakeup configuration */
    wakeupCon0.B.ESR2WKEN  = wakeupConfig->wakeupEvent.stdbyModeEsr2;
    wakeupCon0.B.ESR2DFEN  = wakeupConfig->eventFilterConfig.esr2DigitalFilterUsage;
    wakeupCon0.B.ESR2EDCON = wakeupConfig->edgeTrigger.esr2TriggerEvent;
    /*PINC wakeup configuration*/
    wakeupCon0.B.PINCWKEN  = wakeupConfig->wakeupEvent.stdbyModePinC;
    wakeupCon0.B.PINCDFEN  = wakeupConfig->eventFilterConfig.pinCDigitalFilterUsage;
    wakeupCon0.B.PINCEDCON = wakeupConfig->edgeTrigger.pinCTriggerEvent;
    /*PINB wakeup configuration */
    wakeupCon0.B.PINBWKEN  = wakeupConfig->wakeupEvent.stdbyModePinB;
    wakeupCon0.B.PINBDFEN  = wakeupConfig->eventFilterConfig.pinBDigitalFilterUsage;
    wakeupCon0.B.PINBEDCON = wakeupConfig->edgeTrigger.pinBTriggerEvent;

    /*PINSSB wakeup configuration */
    if (wakeupConfig->wakeupEvent.stdbyModePinSSB < IfxPmsPm_WakeupStandbyModeSel_stdby0Tostdby1)
    {
        wakeupCon0.B.PINSSBWKEN = wakeupConfig->wakeupEvent.stdbyModePinSSB;
    }
    else
    {
        /* Assert Error : Incorrect value configured. Possible values are 0 or 1*/
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

    /* Wakeup enable on Vddext supply ramp up */
    wakeupCon0.B.PWRWKEN   = wakeupConfig->wakeupEvent.stdbyModePower;
    /* Wakeup enable on Vddext supply ramp up */
    wakeupCon0.B.PWRWKEN   = wakeupConfig->wakeupEvent.stdbyModePower;
    wakeupCon1.B.PORSTWKEN = wakeupConfig->enableWakeupOnPorst;

    /*PINA wakeup configuration */
    if (wakeupConfig->enableWakeupOnPinA)
    {
        wakeupCon1.B.PINAWKEN  = 1u;
        wakeupCon1.B.PINADFEN  = wakeupConfig->eventFilterConfig.pinADigitalFilterUsage;
        wakeupCon1.B.PINAEDCON = wakeupConfig->edgeTrigger.pinATriggerEvent;
    }

    /*ESR0 wakeup configuration */
    if (wakeupConfig->enableWakeupOnEsr0)
    {
        wakeupCon1.B.ESR0WKEN  = wakeupConfig->enableWakeupOnEsr0;
        wakeupCon1.B.ESR0DFEN  = wakeupConfig->eventFilterConfig.esr0DigitalFilterUsage;
        wakeupCon1.B.ESR0EDCON = wakeupConfig->edgeTrigger.esr0TriggerEvent;
    }

    /*ESR1 wakeup configuration */
    if (wakeupConfig->enableWakeupOnEsr1)
    {
        wakeupCon1.B.ESR1WKEN  = wakeupConfig->enableWakeupOnEsr1;
        wakeupCon1.B.ESR1DFEN  = wakeupConfig->eventFilterConfig.esr1DigitalFilterUsage;
        wakeupCon1.B.ESR1EDCON = wakeupConfig->edgeTrigger.esr1TriggerEvent;
    }

    /* PINSEXT wakeup configuration */
    if (wakeupConfig->wakeupEvent.stdbyModePinSEXT < IfxPmsPm_WakeupStandbyModeSel_stdby0Tostdby1)
    {
        wakeupCon0.B.PINSEXTWKEN = wakeupConfig->wakeupEvent.stdbyModePinSEXT;
    }
    else
    {
        /* Assert Error : Incorrect value configured. Possible values are 0 or 1*/
        IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, FALSE);
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->WAKEUP.CON0.U = wakeupCon0.U;
    pms->WAKEUP.CON1.U = wakeupCon1.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_standbyModeEntry(void)
{
    IfxCpu_ResourceCpu materCpu;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_config);
#endif
    /* Single CPU decision */
    materCpu = (IfxCpu_ResourceCpu)(SMM_PMSWCR1.B.CPUSEL - 1);

    switch (materCpu)
    {
    case IfxCpu_ResourceCpu_0: SMM_PMCSR0.B.REQSLP = IFXPMSPM_STANDBY_MODE;
        break;
#if IFXCPU_NUM_MODULES > 2
    case IfxCpu_ResourceCpu_1: SMM_PMCSR1.B.REQSLP = IFXPMSPM_STANDBY_MODE;
        break;
#endif
#if IFXCPU_NUM_MODULES > 3
    case IfxCpu_ResourceCpu_2: SMM_PMCSR2.B.REQSLP = IFXPMSPM_STANDBY_MODE;
        break;
#endif
#if IFXCPU_NUM_MODULES > 4
    case IfxCpu_ResourceCpu_3: SMM_PMCSR3.B.REQSLP = IFXPMSPM_STANDBY_MODE;
        break;
#endif
#if IFXCPU_NUM_MODULES > 5
    case IfxCpu_ResourceCpu_4: SMM_PMCSR4.B.REQSLP = IFXPMSPM_STANDBY_MODE;
        break;
#endif
#if IFXCPU_NUM_MODULES > 6
    case IfxCpu_ResourceCpu_5: SMM_PMCSR5.B.REQSLP = IFXPMSPM_STANDBY_MODE;
        break;
#endif
    default:
        /* Invalid core selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_SMM.PROTE, IfxApProt_State_run);
#endif
}


void IfxPmsPm_digitalFilterEnableDisable(Ifx_PMS *pms, IfxPmsPm_DigitalFilter event, IfxPmsPm_DigitalFilterConfiguration config)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (event)
    {
    case IfxPmsPm_DigitalFilter_esr2:
        pms->WAKEUP.CON0.B.ESR2DFEN = config;
        break;
    case IfxPmsPm_DigitalFilter_pinC:
        pms->WAKEUP.CON0.B.PINCDFEN = config;
        break;
    case IfxPmsPm_DigitalFilter_esr0:
        pms->WAKEUP.CON1.B.ESR0DFEN = config;
        break;
    case IfxPmsPm_DigitalFilter_esr1:
        pms->WAKEUP.CON1.B.ESR1DFEN = config;
        break;
    case IfxPmsPm_DigitalFilter_pinA:
        pms->WAKEUP.CON1.B.PINADFEN = config;
        break;
    case IfxPmsPm_DigitalFilter_pinB:
        pms->WAKEUP.CON0.B.PINBDFEN = config;
        break;
    default:
        /* Invalid core selected */
        break;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_wutConfiguration(Ifx_PMS *pms, IfxPmsPm_WutConfig *wutConfig)
{
    Ifx_PMS_WUT_CON wutCon;
    wutCon.U        = pms->WUT.CON.U;

    wutCon.B.DIV    = wutConfig->clockDiv;
    wutCon.B.MODE   = wutConfig->mode;
    wutCon.B.RELOAD = wutConfig->reloadValue;
    wutCon.B.ENABLE = wutConfig->enableWut;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->WUT.CON.U = wutCon.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_rtcClockConfiguration(Ifx_PMS *pms, IfxPmsPm_RtcClockConfig *rtcClkConfig)
{
    Ifx_PMS_RTC_CON0 rtcCon0;
    Ifx_PMS_RTC_CON1 rtcCon1;

    rtcCon0.U           = pms->RTC.CON0.U;
    rtcCon1.U           = pms->RTC.CON1.U;

    rtcCon0.B.RTCOSCEN  = rtcClkConfig->oscEnable;
    rtcCon0.B.REGEN     = rtcClkConfig->ampRegEnable;
    rtcCon0.B.HYSEN     = rtcClkConfig->hystEnable;
    rtcCon0.B.GAINSEL   = rtcClkConfig->gainSel;
    rtcCon0.B.RTCOUTSEL = rtcClkConfig->rtcOutSel;

    rtcCon1.B.DIV       = rtcClkConfig->clockDivider;
    rtcCon0.B.RTCEN     = rtcClkConfig->enableRtc;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->RTC.CON1.U = rtcCon1.U;
    pms->RTC.CON0.U = rtcCon0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_rtcCmpConfiguration(Ifx_PMS *pms, IfxPmsPm_RtcCmpConfig *rtcCmpConfig)
{
    Ifx_PMS_RTC_CON2 rtcCon2;

    rtcCon2.B.MSIZE0  = rtcCmpConfig->mSize0;
    rtcCon2.B.MSIZE1  = rtcCmpConfig->mSize1;
    rtcCon2.B.MSTART0 = rtcCmpConfig->mStart0;
    rtcCon2.B.MSTART1 = rtcCmpConfig->mStart1;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    pms->RTC.CON2.U = rtcCon2.U;
    pms->RTC.CMP0.U = rtcCmpConfig->cmpVal0;
    pms->RTC.CMP1.U = rtcCmpConfig->cmpVal1;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_configureDts(Ifx_PMS *pms, IfxPmsPm_DtsConfig *dtsConfig)
{
    Ifx_PMS_DTS_CON  con;
    Ifx_PMS_DTS_LIM1 limitreg1;
    Ifx_PMS_DTS_LIM2 limitreg2;

    con.U       = pms->DTS.CON.U;
    limitreg1.U = pms->DTS.LIM1.U;
    limitreg2.U = pms->DTS.LIM2.U;

    {
        con.B.EN         = dtsConfig->dtsenable;
        con.B.START      = dtsConfig->adcConversion;
        con.B.WRNEN      = dtsConfig->warning;
        con.B.PEAKDETRST = dtsConfig->peakTemp;
    }

    /* lower threshold, filter and hysteresis configuration */
    if (dtsConfig->lower != NULL_PTR)
    {
        limitreg1.B.LOWER     = dtsConfig->lower->threshold;
        limitreg1.B.LOWERHYST = dtsConfig->lower->hysteresis;
        con.B.LOWERFILT       = dtsConfig->lower->filter;
    }

    /* Upper threshold, filter and hysteresis configuration */
    if (dtsConfig->upper != NULL_PTR)
    {
        limitreg1.B.UPPER     = dtsConfig->upper->threshold;
        limitreg1.B.UPPERHYST = dtsConfig->upper->hysteresis;
        con.B.UPPERFILT       = dtsConfig->upper->filter;
    }

    /* TSD limit, filter and hysteresis configuration*/
    if (dtsConfig->tsd != NULL_PTR)
    {
        limitreg2.B.TSDLIMIT = dtsConfig->tsd->threshold;
        limitreg2.B.TSDHYST  = dtsConfig->tsd->hysteresis;
        limitreg2.B.TSDFILT  = dtsConfig->tsd->filter;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->DTS.LIM1.U = limitreg1.U;
    pms->DTS.LIM2.U = limitreg2.U;
    pms->DTS.CON.U  = con.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_copyData(void *srcAddr, void *destAddr, uint32 dataSize)
{
    uint32 *src_long  = (uint32 *)srcAddr;
    uint32 *dest_long = (uint32 *)destAddr;

    if ((src_long != NULL_PTR) && (dest_long != NULL_PTR))
    {
        /* To check if address is 4 byte aligned */
        if ((((uint32)dest_long & 0x03U) == 0u) && (((uint32)src_long & 0x03U) == 0u))
        {
            /* Transfer 4 bytes */
            while (dataSize >= 4u)
            {
                *dest_long++ = *src_long++;
                dataSize    -= 4u;
            }
        }

        uint8 *src  = (uint8 *)src_long;
        uint8 *dest = (uint8 *)dest_long;

        /* Transfer remaining data byte by byte*/
        while (dataSize--)
        {
            *dest++ = *src++;
        }
    }
}


void IfxPmsPm_initPowerDownConfig(IfxPmsPm_PowerGatingConfig *config)
{
    config->powerDown.ppu  = IfxPmsPm_PowerDown_disable;
    config->powerDown.lmu0 = IfxPmsPm_PowerDown_disable;
    config->powerDown.lmu1 = IfxPmsPm_PowerDown_disable;
    config->ppuClkDivider  = IfxPmsPm_PowerSwitchCLockDivider_0;
    config->lmuClkDivider  = IfxPmsPm_PowerSwitchCLockDivider_0;
}


void IfxPmsPm_initandEnablePowerDown(Ifx_PMS *pms, IfxPmsPm_PowerGatingConfig *config)
{
    Ifx_PMS_PD_CON0 pdCon0;
    pdCon0.U = pms->PD.CON0.U;
    /* Enable pre-divider clock to power switch logic */
    //pdCon0.B.CLKPREDIV = 1;
    /* Setting individual clock divider for the power switches of each domain */
    pdCon0.B.CLKPPU     = config->ppuClkDivider;
    pdCon0.B.CLKLMU     = config->lmuClkDivider;
    /* Enable power down of the respective domain */
    pdCon0.B.PPUPDEN_P  = 1;
    pdCon0.B.PPUPDEN    = config->powerDown.ppu;
    pdCon0.B.LMU0PDEN_P = 1;
    pdCon0.B.LMU0PDEN   = config->powerDown.lmu0;
    pdCon0.B.LMU1PDEN_P = 1;
    pdCon0.B.LMU1PDEN   = config->powerDown.lmu1;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif
    pms->PD.CON0.U = pdCon0.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif
}


boolean IfxPmsPm_powerDownTrigger(Ifx_PMS *pms, IfxPmsPm_CorePowerDomain powerDomain)
{
    Ifx_PMS_PD_CON1 pdCon1;
    boolean         powerDownSuccesss = 1;
    pdCon1.U = pms->PD.CON1.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_config);
#endif

    switch (powerDomain)
    {
    case IfxPmsPm_CorePowerDomain_ppu:

        if (pms->PD.CON0.B.PPUPDEN)
        {
            /* disabling alarm and reset trigger to avoid cold PORST when power down is triggered*/
            pms->VMONP.VDDPPURST.U         |= (1u << IFX_PMS_VMONPRST_RESETOFF_P_OFF) | (1u << IFX_PMS_VMONPRST_RESETOFF_OFF);
            pms->VMONP.VDDPPUCON.B.UVENABLE = 0;
            pms->VMONS.VDDPPUCON.B.UVMOD    = 0;

            pdCon1.B.PPUOFFREQ_P            = 1;
            pdCon1.B.PPUOFFREQ              = 1;
            powerDownSuccesss               = 0;
        }

        break;
    case IfxPmsPm_CorePowerDomain_lmu0:

        if (pms->PD.CON0.B.LMU0PDEN)
        {
            /* disabling alarm and reset trigger to avoid cold PORST when power down is triggered*/
            pms->VMONP.VDDLMU0RST.U         |= (1u << IFX_PMS_VMONPRST_RESETOFF_P_OFF) | (1u << IFX_PMS_VMONPRST_RESETOFF_OFF);
            pms->VMONP.VDDLMU0CON.B.UVENABLE = 0;
            pms->VMONS.VDDLMU0CON.B.UVMOD    = 0;

            pdCon1.B.LMU0OFFREQ_P            = 1;
            pdCon1.B.LMU0OFFREQ              = 1;
            powerDownSuccesss                = 0;
        }

        break;
    case IfxPmsPm_CorePowerDomain_lmu1:

        if (pms->PD.CON0.B.LMU1PDEN)
        {
            /* disabling alarm and reset trigger to avoid cold PORST when power down is triggered*/
            pms->VMONP.VDDLMU1RST.U         |= (1u << IFX_PMS_VMONPRST_RESETOFF_P_OFF) | (1u << IFX_PMS_VMONPRST_RESETOFF_OFF);
            pms->VMONP.VDDLMU1CON.B.UVENABLE = 0;
            pms->VMONS.VDDLMU1CON.B.UVMOD    = 0;

            pdCon1.B.LMU1OFFREQ_P            = 1;
            pdCon1.B.LMU1OFFREQ              = 1;
            powerDownSuccesss                = 0;
        }

        break;
    default:
        /* Invalid Power Domain selected */
        break;
    }

    if (!powerDownSuccesss)
    {
        pms->PD.CON1.U = pdCon1.U;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(pms->PROTE), IfxApProt_State_run);
#endif

    return powerDownSuccesss;
}


boolean IfxPmsPm_initScr(IfxPmsPm_ScrBootMode bootMode, boolean enableReset, IfxPmsPm_MemoryConfig *xram)
{
    uint8            index      = 0;
    boolean          timeExpire = FALSE;
    boolean          status     = FALSE;
    boolean          scrstatus;
    uint32           timeoutVal = IFXPMS_SCR_ENABLE_TIMEOUT;
    Ifx_PMS_SCR_CON0 scrcon0;
    /* 1. Disable Scr */
    scrcon0.U         = 0; // Reset all bits locally
    scrcon0.B.SCREN_P = 1; // SCREN can be updated.
    scrcon0.B.SCREN   = 0; // Disable SCR
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(PMS_PROTE), IfxApProt_State_config);
#endif
    PMS_SCR_CON0.U = scrcon0.U;

    /* 2. Copy the code in SCR Xram */
    if (xram != NULL_PTR)
    {
        IfxPmsPm_copyData(xram->src, xram->dest, xram->size);
        /* Copy SCR magic pattern to the end*/
        uint16 *xramptr = (uint16 *)IFXPMS_SCR_XRAM_MAGIC_PATTERN_ADDRESS;

        for (index = 0; index < 4; index++)
        {
            xramptr[index] = 0xAA55;
        }
    }

    /* 3. Configure bootmode and enable/disable reset on warm Porst*/
    scrcon0.U            = PMS_SCR_CON0.U;
    scrcon0.B.PORSTREQ_P = 1u;
    scrcon0.B.PORSTREQ   = enableReset;
    scrcon0.B.SCRCFG     = bootMode;
    scrcon0.B.SCREN_P    = 1u;  /* Enable SCR */
    scrcon0.B.SCREN      = 1u;

    PMS_SCR_CON0.U       = scrcon0.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(PMS_PROTE), IfxApProt_State_run);
#endif

    /* Wait for SCR to enable*/
    do
    {
        scrstatus = PMS_SCR_CON0.B.SCREN;

        if ((timeoutVal <= 0U) && (scrstatus != 1U))
        {
            /* Timeout happened and scr is not enabled yet*/
            timeExpire = TRUE;
            status     = TRUE;
        }

        timeoutVal--;
    } while ((scrstatus != 1U) && (timeExpire == TRUE));

    return status;
}


void IfxPmsPm_copyScrProgram(void *srcAddress, uint16 size)
{
    uint8 index = 0;

    /* Copy data from source address to SCR XRAM*/
    IfxPmsPm_copyData(srcAddress, PMS_XRAM, size);

    /* Copy SCR magic pattern to the end*/
    uint16 *xramptr = (uint16 *)IFXPMS_SCR_XRAM_MAGIC_PATTERN_ADDRESS;

    for (index = 0; index < 4; index++)
    {
        xramptr[index] = 0xAA55;
    }
}


void IfxPmsPm_initandTriggerPowerDown(Ifx_PMS *pms, IfxPmsPm_PowerGatingConfig *config)
{
    Ifx_PMS_PD_CON0 pdCon0;
    Ifx_PMS_PD_CON1 pdCon1;
    pdCon1.U = pms->PD.CON1.U;
    pdCon0.U = pms->PD.CON0.U;

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(PMS_PROTE), IfxApProt_State_config);
#endif
    /* Setting individual clock divider for the power switches of each domain */
    pdCon0.B.CLKLMU = config->lmuClkDivider;
    pdCon0.B.CLKPPU = config->ppuClkDivider;

    /* PPU */
    if (config->powerDown.ppu)
    {
        /* Enable Power Down */
        pdCon0.B.PPUPDEN_P = 1;
        pdCon0.B.PPUPDEN   = config->powerDown.ppu;

        /* disabling alarm and reset trigger to avoid cold PORST when power down is triggered*/
        pms->VMONP.VDDPPURST.U         |= (1u << IFX_PMS_VMONPRST_RESETOFF_P_OFF) | (1u << IFX_PMS_VMONPRST_RESETOFF_OFF);
        pms->VMONP.VDDPPUCON.B.UVENABLE = 0;
        pms->VMONS.VDDPPUCON.B.UVMOD    = 0;

        pdCon1.B.PPUOFFREQ_P            = 1;
        pdCon1.B.PPUOFFREQ              = 1;
    }

    /* LMU 0 */
    if (config->powerDown.lmu0)
    {
        /* disabling alarm and reset trigger to avoid cold PORST when power down is triggered*/
        pms->VMONP.VDDLMU0RST.U         |= (1u << IFX_PMS_VMONPRST_RESETOFF_P_OFF) | (1u << IFX_PMS_VMONPRST_RESETOFF_OFF);
        pms->VMONP.VDDLMU0CON.B.UVENABLE = 0;
        pms->VMONS.VDDLMU0CON.B.UVMOD    = 0;

        /* Enable Power Down */
        pdCon0.B.LMU0PDEN_P   = 1;
        pdCon0.B.LMU0PDEN     = config->powerDown.lmu0;

        pdCon1.B.LMU0OFFREQ_P = 1;
        pdCon1.B.LMU0OFFREQ   = 1;
    }

    /* LMU 1 */
    if (config->powerDown.lmu1)
    {
        /* disabling alarm and reset trigger to avoid cold PORST when power down is triggered*/
        pms->VMONP.VDDLMU1RST.U         |= (1u << IFX_PMS_VMONPRST_RESETOFF_P_OFF) | (1u << IFX_PMS_VMONPRST_RESETOFF_OFF);
        pms->VMONP.VDDLMU1CON.B.UVENABLE = 0;
        pms->VMONS.VDDLMU1CON.B.UVMOD    = 0;

        /* Enable Power Down */
        pdCon0.B.LMU1PDEN_P   = 1;
        pdCon0.B.LMU1PDEN     = config->powerDown.lmu1;

        pdCon1.B.LMU1OFFREQ_P = 1;
        pdCon1.B.LMU1OFFREQ   = 1;
    }

    pms->PD.CON0.U = pdCon0.U;
    pms->PD.CON1.U = pdCon1.U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(PMS_PROTE), IfxApProt_State_run);
#endif
}


void IfxPmsPm_configureStandbyEntries(Ifx_PMS *pms, IfxPmsPm_StandbyTriggerMode trigger)
{
    Ifx_PMS_STANDBY_CON0 stdbyCon0;
    Ifx_PMS_STANDBY_CON1 stdbyCon1;
    Ifx_SMM_PMSWCR1      pmsWcr1;

    /*Reading register */
    pmsWcr1.U   = SMM_PMSWCR1.U;
    stdbyCon1.U = pms->STANDBY.CON1.U;
    stdbyCon0.U = pms->STANDBY.CON0.U;

    switch (trigger)
    {
    case IfxPmsPm_StandbyTriggerMode_software:
        pmsWcr1.B.STBYEVEN    = 1;
        pmsWcr1.B.STBYEV      = IfxPmsPm_StandbyTriggerMode_software;
        stdbyCon1.B.SWESRSBEN = 1;
        break;
    case IfxPmsPm_StandbyTriggerMode_hardware_esr1:
        /* Standby entry triggered by NMI event*/
        pmsWcr1.B.STBYEVEN    = 1;
        pmsWcr1.B.STBYEV      = IfxPmsPm_StandbyTriggerMode_hardware_esr1;
        stdbyCon1.B.SWESRSBEN = 1;
        break;
    case IfxPmsPm_StandbyTriggerMode_hardware_esr2:
        /* Standby entry triggered on ESR2 event */
        stdbyCon0.B.ESR2SBEN = 1;
        break;
    case IfxPmsPm_StandbyTriggerMode_hardware_undervoltage_vddext:
        /* Standby entry trigger on vddext under voltage event */
        stdbyCon0.B.VDDEXTSBEN = 1;
        break;
    case IfxPmsPm_StandbyTriggerMode_hardware_undervoltage_vdd:
        /* Standby entry trigger on vdd under voltage event */
        stdbyCon1.B.VDDSBEN = 1;
        break;
    default:
        /* Invalid Trigger selected */
        break;
    }

    /* Writing Register back */
    SMM_PMSWCR1.U       = pmsWcr1.U;
    pms->STANDBY.CON1.U = stdbyCon1.U;
    pms->STANDBY.CON0.U = stdbyCon0.U;
}
