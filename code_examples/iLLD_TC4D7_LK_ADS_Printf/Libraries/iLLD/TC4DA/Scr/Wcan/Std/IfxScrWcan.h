/**
 * \file IfxScrWcan.h
 * \brief SCR WCAN basic functionality
 * \ingroup IfxLld_ScrWcan
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_ScrWcan_Std_Enumerations Enumerations
 * \ingroup IfxLld_ScrWcan_Std
 * \defgroup IfxLld_ScrWcan_Std_DataStructures Data structures
 * \ingroup IfxLld_ScrWcan_Std
 * \defgroup IfxLld_ScrWcan_Std_config WCAN Configuration Functionality
 * \ingroup IfxLld_ScrWcan_Std
 * \defgroup IfxLld_ScrWcan_Std_init WCAN Initialization Functionality
 * \ingroup IfxLld_ScrWcan_Std
 *
 */

#ifndef IFXSCRWCAN_H
#define IFXSCRWCAN_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxScrWcan_cfg.h"
#include "_Reg/IfxScr_bf.h"
#include "_Reg/IfxScr_reg.h"
#include "_Utilities/Ifx_Assert.h"
/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_ScrWcan_Std_Enumerations
 * \{ */

/** \brief WCAN Interrupt sources
 */

typedef enum
{
    IfxScrWcan_InterruptEvent_timeout = 0,       /**< \brief Interrupt on CAN timeout */
    IfxScrWcan_InterruptEvent_syserr  = 1,       /**< \brief Interrupt on System error */
    IfxScrWcan_InterruptEvent_wuf     = 2,       /**< \brief Interrupt on wakeup frame */
    IfxScrWcan_InterruptEvent_wup     = 3,       /**< \brief Interrupt on wakeup pattern */
}IfxScrWcan_InterruptEvent;

/** \brief Enumeration for Wcan Baudrate Prescalar
 * f_WCAN = f_pclk/BRP. Scaling factor to determin 1bit quanta
 */
typedef enum
{
    IfxScrWcan_PrescalerDiv_1 = 0,                  /**< \brief Division by 1 */
    IfxScrWcan_PrescalerDiv_2 = 1,                  /**< \brief Division by 2 */
    IfxScrWcan_PrescalerDiv_4 = 2,                  /**< \brief Division by 4 */
    IfxScrWcan_PrescalerDiv_8 = 3                   /**< \brief Division by 8 */
}IfxScrWcan_PrescalerDiv;

/** \brief Enumeration for Wcan Receiver input
 */
typedef enum
{
    IfxScrWcan_Receiver_rxda = 0,                    /**< \brief Receiver Input WCANRXDA is selected */
    IfxScrWcan_Receiver_rxdb = 1,                    /**< \brief Receiver Input WCANRXDB is selected */
    IfxScrWcan_Receiver_rxdc = 2,                    /**< \brief Receiver Input WCANRXDC is selected */
    IfxScrWcan_Receiver_rxdd = 3,                    /**< \brief Receiver Input WCANRXDD is selected */
    IfxScrWcan_Receiver_rxde = 4,                    /**< \brief Receiver Input WCANRXDE is selected */
    IfxScrWcan_Receiver_rxdf = 5,                    /**< \brief Receiver Input WCANRXDF is selected */
    IfxScrWcan_Receiver_rxdg = 6,                    /**< \brief Receiver Input WCANRXDG is selected */
    IfxScrWcan_Receiver_rxdh = 7,                    /**< \brief Receiver Input WCANRXDH is selected */
    IfxScrWcan_Receiver_rxdi = 8,                    /**< \brief Receiver Input WCANRXDI is selected */
    IfxScrWcan_Receiver_rxdj = 9                     /**< \brief Receiver Input WCANRXDJ is selected */
}IfxScrWcan_Receiver;

/** \brief Enumeration for CAN FD filter time to detect dominant bit field
 */
typedef enum
{
    IfxScrWcan_FilterTime_13 = 0,                      /**< \brief Filter time  130ns */
    IfxScrWcan_FilterTime_25 = 1,                      /**< \brief Filter time  250ns */
    IfxScrWcan_FilterTime_48 = 2,                      /**< \brief Filter time  480ns */
    IfxScrWcan_FilterTime_90 = 3                       /**< \brief Filter time  900ns */
}IfxScrWcan_FilterTime;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_ScrWcan_Std_DataStructures
 * \{ */
/** \brief WCAN baudrate configuration structure
 * NOTE:Baudrates are set from the entries of table baudrateLookup[4]
 */
typedef struct _IfxScrWcan_BaudrateConfig
{
    IfxScrWcan_PrescalerDiv prescaler;   /* Clock divider for f_CAN i.e f_CAN/(2^baudrate) */
    uint8                   bitTq;       /* Number of time quantas in a single bit period */
    uint8                   samplePoint; /* Sample Point Position(in % of bit time - must be from 67.5 to 90)*/
}IfxScrWcan_BaudrateConfig;

/** \brief WCAN configuration structure
 * ASSUMPTION:CDR is always enabled. Hence enabling it in initModule() as the ITS strongly recommends it.
 */
typedef struct
{
    uint8  canVersion;                               /* CAN version used.OPtions are IfxScrWcan_CanVersion_standard and IfxScrWcan_CanVersion_extended */
    uint32 idFilter;                                 /* CAN message ID to be filtered for WUF detection. For Standard CAN messages, it's 11 bit and for extended it's 29 bit */
    uint32 idFilterMask;                             /* CAN message ID mask. To indicate which bits in message ID must be used for matching for WUF detection */
    uint8  dataLength;                               /* Length of data to be matched for WUF detection */
    uint8  dataFilter[8];                            /* Data to be matched for WUF detection */
    uint8  baudrate;                                 /* Baudrate for CAN bus Options are:
                                                      *          IfxScrWcan_Baudrate_1Mbps,
                                                      *          IfxScrWcan_Baudrate_500kbps,
                                                      *          IfxScrWcan_Baudrate_250bps,
                                                      *          IfxScrWcan_Baudrate_125kbps
                                                      */
    IfxScrWcan_Receiver receiverInput;               /* Wcan receiver input */
    boolean             enableWufInterrupt;          /* Enable Interrupt triggering on WUF detection */
    boolean             enableWupInterrupt;          /* Enable Interrupt triggering on WUP detection */
    boolean             enableSysErrorInterrupt;     /* Enable Interrupt triggering on System Error detection */
    boolean             enableTimeoutInterrupt;      /* Enable Interrupt triggering on CAN Timeout */
}IfxScrWcan_Config;

/** \} */

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/

/*
 * \brief WCAN baud rate table for standard baud rates used by OEMs(as recommended in the ITS)
 * All values are for f_pclk=20MHz
 * */

IFX_EXTERN IFX_CONST IfxScrWcan_BaudrateConfig baudrateLookup[4];

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_ScrWcan_Std_config
 * \{ */

/** \brief Disables the Wakeup functionality.
 * This API is to be mandatorily called before calling IfxScrWcan_setFilterMessageId(),IfxScrWcan_setFilterMessageIdMask(uint32 idMask,uint8 canVersion) and IfxScrWcan_setFilterData()
 * \return None
 */

IFX_INLINE void IfxScrWcan_disableSelectiveWakeup(void);

/** \brief Enables the Wakeup functionality.
 * This API is may be called before calling IfxScrWcan_setFilterMessageId(),IfxScrWcan_setFilterMessageIdMask(uint32 idMask,uint8 canVersion) and IfxScrWcan_setFilterData()
 * \return None
 */

IFX_INLINE void IfxScrWcan_enableSelectiveWakeup(void);

/** \brief Enables the Wakeup functionality.
 * This checks if the Selective Wakeup facility is activated.Following conditions are to be satisfied for this to happen:
 * WCAN_CFG.WCAN_EN = 1b
 * WCAN_CFG.CCE = 0b
 * WCAN_INTESTAT0.SWACK = 1b
 * WCAN_INTESTAT0.MODE = 0b
 * fEVR_OSC is switched on
 * \return None
 */

IFX_INLINE boolean IfxScrWcan_isSelectiveWakeupActivated(void);

/** \brief Configures the Message ID of the CAN message to be sniffed based on the CAN version.
 * Call to IfxScrWcan_disableSelectiveWakeup() is mandatory before calling this.
 *  \param idFilter Message ID of the CAN message to be filtered
 * \param canVersion Flavour of CAN protocol.Options are IfxScrWcan_CanVersion_standard and IfxScrWcan_CanVersion_extended
 * \return None
 */

IFX_INLINE void IfxScrWcan_setFilterMessageId(uint32 idFilter, uint8 canVersion);

/** \brief Configures the mask for Message ID of the CAN message to be sniffed based on the CAN version.This mask determines which bit in the ID must be used for comparison.
 * Call to IfxScrWcan_disableSelectiveWakeup() is mandatory before calling this.
 * \param idMask Mask for Message ID of the CAN message to be filtered
 * \param canVersion Flavour of CAN protocol.Options are IfxScrWcan_CanVersion_standard and IfxScrWcan_CanVersion_extended
 * \return None
 */

IFX_INLINE void IfxScrWcan_setFilterMessageIdMask(uint32 idMask, uint8 canVersion);

/** \brief Configures the data and data length of the CAN message to be sniffed based on the CAN version
 *  Call to IfxScrWcan_disableSelectiveWakeup() is mandatory before calling this.
 *  \param data Pointer to array containing data of CAN message to be filtered
 * \param dataLength Length of data(in bytes)
 * \return None
 */

IFX_INLINE void IfxScrWcan_setFilterData(uint8 *data, uint8 dataLength);

/** \brief Enable interrupt for the specified event
 *  \param event Event for which interrupt trigger is to be enabled
 * \return None
 */

IFX_INLINE void IfxScrWcan_enableInterrupt(IfxScrWcan_InterruptEvent event);

/** \brief Disable interrupt for the specified event
 *  \param event Event for which interrupt trigger is to be disabled
 * \return None
 */

IFX_INLINE void IfxScrWcan_disableInterrupt(IfxScrWcan_InterruptEvent event);

/** \brief Enable CAN FD tolerant
 * \return None
 */

IFX_INLINE void IfxScrWcan_enableCanFdTolerant(void);

/** \brief Disable CAN FD tolerant
 * \return None
 */

IFX_INLINE void IfxScrWcan_disableCanFdTolerant(void);

/** \brief Function to set CAN FD filter time.
 * \param time Filter time to detect dominant bitfield in FD phase
 * \return None
 */
IFX_INLINE void IfxScrWcan_setCanFdFilterTime(IfxScrWcan_FilterTime time);

/** \brief Function to disable error count for CAN FD frame.
 * \return None
 */
IFX_INLINE void IfxScrWcan_disableCanFdErrorCount(void);

/** \brief Function to clear error counter
 * \return None
 */
IFX_INLINE void IfxScrWcan_clearErrorCount(void);

/** \} */

/** \addtogroup IfxLld_ScrWcan_Std_init
 * \{ */
/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configure the module according to the values in configuration structure wcanConfig
 * \param wcanConfig WCAN configuration structure
 * \return None
 */

IFX_EXTERN void IfxScrWcan_initModule(IfxScrWcan_Config *wcanConfig);

/** \brief Configures baud rate for WCAN
 * \param baudrate Baud rate to be set.Options are:
 * IfxScrWcan_Baudrate_1Mbps
 * IfxScrWcan_Baudrate_500kbps
 * IfxScrWcan_Baudrate_250kbps
 * IfxScrWcan_Baudrate_125kbps
 * \return None
 */

IFX_EXTERN void IfxScrWcan_setBaudrate(uint8 baudrate);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScrWcan_disableSelectiveWakeup(void)
{
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_CFG.U &= ~(1u << IFX_SCR_WCAN_CFG_SELWK_EN_OFF);     /* Disabling the protocol handler SELWK_EN=1 */
}


IFX_INLINE void IfxScrWcan_enableSelectiveWakeup(void)
{
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_CFG.U |= (1u << IFX_SCR_WCAN_CFG_SELWK_EN_OFF);     /* Enabling the protocol handler SELWK_EN=1 */
}


IFX_INLINE boolean IfxScrWcan_isSelectiveWakeupActivated(void)
{
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;
    return (boolean)((SCR_WCAN_INTESTAT1.U & (1u << IFX_SCR_WCAN_INTESTAT1_SWKSET_OFF)) >> IFX_SCR_WCAN_INTESTAT1_SWKSET_OFF);
}


IFX_INLINE void IfxScrWcan_setFilterMessageId(uint32 idFilter, uint8 canVersion)
{
    /* Setting the ID and IDE for the CAN message to be filtered */
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x02u;

    if (canVersion == IfxScrWcan_CanVersion_standard)
    {
        /* For Standard CAN messages, Bits 0 to 17 are don't care and bits 18 to 28 contain the 11 bit ID */
        SCR_WCAN_ID2_CTRL.U = (uint8)(idFilter << 2u);
        SCR_WCAN_ID3_CTRL.U = (uint8)(((idFilter >> 4u) & 0xFCU) | canVersion);     /* Shift of 8-2(due to it starting from 18th bit) -2() */
    }
    else if (canVersion == IfxScrWcan_CanVersion_extended)
    {
        SCR_WCAN_ID0_CTRL.U = (uint8)(idFilter);
        SCR_WCAN_ID1_CTRL.U = (uint8)(idFilter >> 8u);
        SCR_WCAN_ID2_CTRL.U = (uint8)(idFilter >> 16u);
        SCR_WCAN_ID3_CTRL.U = (uint8)(((idFilter >> 22u) & 0xFCU) | canVersion);
    }
}


IFX_INLINE void IfxScrWcan_setFilterMessageIdMask(uint32 idMask, uint8 canVersion)
{
    /* Setting the ID, ID mask and IDE for the CAN message to be filtered */

    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x02u;

    if (canVersion == IfxScrWcan_CanVersion_standard)
    {
        /* For Standard CAN messages, Bits 0 to 17 are don't care and bits 18 to 28 contain the 11 bit ID */
        SCR_WCAN_MASK_ID2_CTRL.U = (uint8)(idMask << 2u);
        SCR_WCAN_MASK_ID3_CTRL.U = (uint8)(idMask >> 4u);      /* Shift of 8-2(due to it starting from 18th bit) -2() */
    }
    else if (canVersion == IfxScrWcan_CanVersion_extended)
    {
        SCR_WCAN_MASK_ID0_CTRL.U = (uint8)(idMask);
        SCR_WCAN_MASK_ID1_CTRL.U = (uint8)(idMask >> 8u);
        SCR_WCAN_MASK_ID2_CTRL.U = (uint8)(idMask >> 16u);
        SCR_WCAN_MASK_ID3_CTRL.U = (uint8)(idMask >> 22u);
    }

    SCR_WCAN_ID3_CTRL.U = (uint8)((SCR_WCAN_ID3_CTRL.U & 0xFEU) | canVersion);
}


IFX_INLINE void IfxScrWcan_setFilterData(uint8 *data, uint8 dataLength)
{
    if (dataLength > 8u)
    {
        dataLength = 8u;
    }

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (data != NULL_PTR));
    /* Setting data for the CAN messages to be filtered according to data length */
    SCR_WCAN_PAGE.U = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x03u;

    if (data != NULL_PTR)
    {
        for (uint8 i = 0; i <= dataLength; ++i)
        {
            volatile uint8 *dataCtrlAddr = (volatile uint8 *)&SCR_WCAN_DATA0_CTRL;
            *(dataCtrlAddr + i) = data[i];
        }
    }

    /* Setting the data length for the message to be filtered */
    SCR_WCAN_PAGE.U     = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;
    SCR_WCAN_DLC_CTRL.U = dataLength;
}


IFX_INLINE void IfxScrWcan_enableInterrupt(IfxScrWcan_InterruptEvent event)
{
    SCR_WCAN_PAGE.U     = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_INTMRSLT.U = SCR_WCAN_INTMRSLT.U | (1 << event);
}


IFX_INLINE void IfxScrWcan_disableInterrupt(IfxScrWcan_InterruptEvent event)
{
    SCR_WCAN_PAGE.U     = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_INTMRSLT.U = SCR_WCAN_INTMRSLT.U & (~(1 << event));
}


IFX_INLINE void IfxScrWcan_enableCanFdTolerant(void)
{
    SCR_WCAN_PAGE.U     = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_FD_CTRL.U |= (1u << IFX_SCR_WCAN_FD_CTRL_FDEN_OFF);
}


IFX_INLINE void IfxScrWcan_disableCanFdTolerant(void)
{
    SCR_WCAN_PAGE.U     = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_FD_CTRL.U &= ~(1u << IFX_SCR_WCAN_FD_CTRL_FDEN_OFF);
}


IFX_INLINE void IfxScrWcan_setCanFdFilterTime(IfxScrWcan_FilterTime time)
{
    SCR_WCAN_PAGE.U    = (SCR_WCAN_PAGE.U & (uint8)0xF8U);
    SCR_WCAN_FD_CTRL.U = (SCR_WCAN_FD_CTRL.U & ~(IFX_SCR_WCAN_FD_CTRL_FDFILT_MSK << IFX_SCR_WCAN_FD_CTRL_FDFILT_OFF)) | (time << IFX_SCR_WCAN_FD_CTRL_FDEN_OFF);
}


IFX_INLINE void IfxScrWcan_disableCanFdErrorCount(void)
{
    SCR_WCAN_PAGE.U       = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;
    SCR_WCAN_FRMERRCNT.U &= ~(1u << IFX_SCR_WCAN_FRMERRCNT_FDEC_DIS_OFF);
}


IFX_INLINE void IfxScrWcan_clearErrorCount(void)
{
    SCR_WCAN_PAGE.U       = (SCR_WCAN_PAGE.U & (uint8)0xF8U) | 0x01u;
    SCR_WCAN_FRMERRCNT.U |= (1u << IFX_SCR_WCAN_FRMERRCNT_ECNTCLR_OFF);
}


#endif /* IFXSCRWCAN_H */
