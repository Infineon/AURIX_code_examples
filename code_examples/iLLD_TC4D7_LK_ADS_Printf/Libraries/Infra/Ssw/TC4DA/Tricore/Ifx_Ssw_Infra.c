/**
 * \file Ifx_Ssw_Infra.c
 * \brief Startup Software support functions.
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include "Ifx_Cfg.h"
#include "Ifx_Ssw_Infra.h"

/******************************************************************************/
/*-------------------------Infrastructure Functions---------------------------*/
/******************************************************************************/

IFX_SSW_WEAK void hardware_init_hook(void)
{}

IFX_SSW_WEAK void software_init_hook(void)
{}

unsigned short Ifx_Ssw_getCpuWatchdogPassword(Ifx_WTU_WDTCPU *watchdog)
{
    return Ifx_Ssw_getCpuWatchdogPasswordInline(watchdog);
}


unsigned short Ifx_Ssw_getSystemWatchdogPassword(void)
{
    return Ifx_Ssw_getSystemWatchdogPasswordInline();
}


unsigned short Ifx_Ssw_getSecurityWatchdogPassword(void)
{
    return Ifx_Ssw_getSecurityWatchdogPasswordInline();
}


void Ifx_Ssw_serviceCpuWatchdog(Ifx_WTU_WDTCPU *watchdog, unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;

    /* Read Config_0 register and clear wtu_ctrlb variable */
    wtu_ctrla.U = watchdog->CTRLA.U; /*wtu->CTRLA.U;*/

    if (wtu_ctrla.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;

        if (watchdog->STAT.B.TC == 1U)
        {
            wtu_ctrla.B.TCVI = ~(watchdog->STAT.B.TIM);
        }

        /* Password ready. Store it to WDT_CTRLA to unprotect the register */
        watchdog->CTRLA.U = wtu_ctrla.U;
    }

    wtu_ctrla.B.LCK   = 1;
    watchdog->CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_serviceSystemWatchdog(unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;

    /* Read Config_0 register and clear wtu_ctrlb variable */
    wtu_ctrla.U = MODULE_WTU.WDTSYS.CTRLA.U; /*wtu->CTRLA.U;*/

    if (wtu_ctrla.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;

        if (MODULE_WTU.WDTSYS.STAT.B.TC == 1U)
        {
            wtu_ctrla.B.TCVI = ~(MODULE_WTU.WDTSYS.STAT.B.TIM);
        }

        /* Password ready. Store it to WDT_CTRLA to unprotect the register */
        MODULE_WTU.WDTSYS.CTRLA.U = wtu_ctrla.U;
    }

    wtu_ctrla.B.LCK           = 1;
    MODULE_WTU.WDTSYS.CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_disableCpuWatchdog(Ifx_WTU_WDTCPU *watchdog, unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;
    Ifx_WTU_CTRLB wtu_ctrlb;
    wtu_ctrla.U = watchdog->CTRLA.U;
    wtu_ctrlb.U = watchdog->CTRLB.U;

    if (watchdog->CTRLA.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;
    }

    /* Password ready. Store it to WDT_CTRLA to unprotect the register */
    watchdog->CTRLA.U = wtu_ctrla.U;

    wtu_ctrlb.B.DR    = 1;                                //Set DR bit in Config_1 register

    watchdog->CTRLB.U = wtu_ctrlb.U;

    wtu_ctrla.B.LCK   = 1;

    watchdog->CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_enableCpuWatchdog(Ifx_WTU_WDTCPU *watchdog, unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;
    Ifx_WTU_CTRLB wtu_ctrlb;
    wtu_ctrla.U = watchdog->CTRLA.U;
    wtu_ctrlb.U = watchdog->CTRLB.U;

    if (watchdog->CTRLA.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;
    }

    /* Password ready. Store it to WDT_CTRLA to unprotect the register */
    watchdog->CTRLA.U = wtu_ctrla.U;

    wtu_ctrlb.B.DR    = 0;                                //Set DR bit in Config_1 register

    watchdog->CTRLB.U = wtu_ctrlb.U;

    wtu_ctrla.B.LCK   = 1;

    watchdog->CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_disableSystemWatchdog(unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;
    Ifx_WTU_CTRLB wtu_ctrlb;
    wtu_ctrla.U = MODULE_WTU.WDTSYS.CTRLA.U;
    wtu_ctrlb.U = MODULE_WTU.WDTSYS.CTRLB.U;

    if (MODULE_WTU.WDTSYS.CTRLA.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;
    }

    /* Password ready. Store it to WDT_CTRLA to unprotect the register */
    MODULE_WTU.WDTSYS.CTRLA.U = wtu_ctrla.U;

    wtu_ctrlb.B.DR            = 1; //Set DR bit in Config_1 register

    MODULE_WTU.WDTSYS.CTRLB.U = wtu_ctrlb.U;
    /* LCK bit to be set once after the register CTRLA/CTRLB are written */
    wtu_ctrla.B.LCK           = 1;

    MODULE_WTU.WDTSYS.CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_enableSystemWatchdog(unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;
    Ifx_WTU_CTRLB wtu_ctrlb;
    wtu_ctrla.U = MODULE_WTU.WDTSYS.CTRLA.U;
    wtu_ctrlb.U = MODULE_WTU.WDTSYS.CTRLB.U;

    if (MODULE_WTU.WDTSYS.CTRLA.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;
    }

    /* Password ready. Store it to WDT_CTRLA to unprotect the register */
    MODULE_WTU.WDTSYS.CTRLA.U = wtu_ctrla.U;

    wtu_ctrlb.B.DR            = 0; //Set DR bit in Config_1 register

    MODULE_WTU.WDTSYS.CTRLB.U = wtu_ctrlb.U;
    /* LCK bit to be set once after the register CTRLA/CTRLB are written */
    wtu_ctrla.B.LCK           = 1;

    MODULE_WTU.WDTSYS.CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_changeCpuWatchdogReload(Ifx_WTU_WDTCPU *watchdog, unsigned int password, unsigned int reload)
{
    /* Read Config_0 register */
    Ifx_WTU_CTRLA wtu_ctrla;
    Ifx_WTU_CTRLB wtu_ctrlb;
    wtu_ctrla.U = watchdog->CTRLA.U;
    wtu_ctrlb.U = watchdog->CTRLB.U;

    if (wtu_ctrla.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;

        /* Password ready. Store it to WDT_CTRLA to unprotect the register */
        watchdog->CTRLA.U = wtu_ctrla.U;
    }

    /* Set new Reload value and LCK bit in Config_0 register */
    wtu_ctrlb.B.TIMR  = reload;
    watchdog->CTRLA.U = wtu_ctrla.U;

    /* LCK bit to be set once after the register CTRLA/CTRLB are written */
    wtu_ctrla.B.LCK   = 1;
    watchdog->CTRLB.U = wtu_ctrlb.U;
    watchdog->CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_changeSystemWatchdogReload(unsigned int password, unsigned int reload)
{
    /* Initialize pointer to Safety Watchdog */
    Ifx_WTU_WDTSYS *wdt = &MODULE_WTU.WDTSYS;

    /* Read Config_0 register */
    Ifx_WTU_CTRLA   wtu_ctrla;
    Ifx_WTU_CTRLB   wtu_ctrlb;
    wtu_ctrla.U = wdt->CTRLA.U;
    wtu_ctrlb.U = wdt->CTRLB.U;

    if (wtu_ctrla.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;

        /* Password ready. Store it to WDT_CTRLA to unprotect the register */
        wdt->CTRLA.U = wtu_ctrla.U;
    }

    /* Set new Reload value and LCK bit in Config_0 register */
    wtu_ctrlb.B.TIMR = reload;
    wdt->CTRLA.U     = wtu_ctrla.U;

    /* LCK bit to be set once after the register CTRLA/CTRLB are written */
    wtu_ctrla.B.LCK = 1;
    wdt->CTRLB.U    = wtu_ctrlb.U;
    wdt->CTRLA.U    = wtu_ctrla.U;
}


void Ifx_Ssw_disableSecurityWatchdog(unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;
    Ifx_WTU_CTRLB wtu_ctrlb;
    wtu_ctrla.U = MODULE_WTU.WDTSEC.CTRLA.U;
    wtu_ctrlb.U = MODULE_WTU.WDTSEC.CTRLB.U;

    if (MODULE_WTU.WDTSEC.CTRLA.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;
    }

    /* Password ready. Store it to WDT_CTRLA to unprotect the register */
    MODULE_WTU.WDTSEC.CTRLA.U = wtu_ctrla.U;

    wtu_ctrlb.B.DR            = 1; //Set DR bit in Config_1 register

    MODULE_WTU.WDTSEC.CTRLB.U = wtu_ctrlb.U;
    /* LCK bit to be set once after the register CTRLA/CTRLB are written */
    wtu_ctrla.B.LCK           = 1;

    MODULE_WTU.WDTSEC.CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_enableSecurityWatchdog(unsigned int password)
{
    Ifx_WTU_CTRLA wtu_ctrla;
    Ifx_WTU_CTRLB wtu_ctrlb;
    wtu_ctrla.U = MODULE_WTU.WDTSEC.CTRLA.U;
    wtu_ctrlb.U = MODULE_WTU.WDTSEC.CTRLB.U;

    if (MODULE_WTU.WDTSEC.CTRLA.B.LCK)
    {
        /* see Table 1 (Password Access Bit Pattern Requirements) */
        wtu_ctrla.B.LCK = 0;
        wtu_ctrla.B.PW  = password;
    }

    /* Password ready. Store it to WDT_CTRLA to unprotect the register */
    MODULE_WTU.WDTSEC.CTRLA.U = wtu_ctrla.U;

    wtu_ctrlb.B.DR            = 0; //Set DR bit in Config_1 register

    MODULE_WTU.WDTSEC.CTRLB.U = wtu_ctrlb.U;
    /* LCK bit to be set once after the register CTRLA/CTRLB are written */
    wtu_ctrla.B.LCK           = 1;

    MODULE_WTU.WDTSEC.CTRLA.U = wtu_ctrla.U;
}


void Ifx_Ssw_startCore(Ifx_CPU *cpu, unsigned int programCounter)
{
    volatile Ifx_CPU_PC      *pc;
    volatile Ifx_CPU_BOOTCON *bootcon;

    pc       = &cpu->HRA_PC;
    pc->B.PC = (unsigned int)programCounter >> 1U;

    bootcon  = &cpu->HRA_BOOTCON;

    /* release boot halt mode if required */
    if (bootcon->B.BHALT)
    {
        bootcon->B.BHALT = 0U;
    }
}


void Ifx_Ssw_setCpu0Idle(void)
{
    SMM_PMCSR0.B.REQSLP = 0x1;
}


unsigned int Ifx_Ssw_getStmFrequency(void)
{
    unsigned int oscFreq    = IFX_CFG_SSW_XTAL_FREQUENCY;
    unsigned int sourcefreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
    unsigned int insel      = CLOCK_OSCCON.B.INSEL;

    if (insel == 2U)
    {
        oscFreq = IFX_CFG_SSW_SYSCLK_PIN_FREQUENCY;
    }
    else if (insel == 1U)
    {
        oscFreq = IFX_CFG_SSW_XTAL_FREQUENCY;
    }
    else
    {
        oscFreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
    }

    if (CLOCK_CCUSTAT.B.CLKSELS == 0U)
    {
        sourcefreq = (oscFreq * (CLOCK_SYSPLLCON0.B.NDIV + 1)) / ((CLOCK_SYSPLLCON0.B.PDIV + 1) * ((CLOCK_SYSPLLCON1.B.K2DIV + 1))) + 0.5;
    }
    else if (CLOCK_CCUSTAT.B.CLKSELS == 2U)
    {
        sourcefreq = Ifx_Ssw_getRampFrequency();
    }
    else
    {
        sourcefreq = IFX_CFG_SSW_EVR_OSC_FREQUENCY;
    }

    return sourcefreq / CLOCK_SYSCCUCON0.B.STMDIV;
}


unsigned int stmCount;

void Ifx_Ssw_delay(void)
{
    unsigned int stmCountBegin = (unsigned int)CPU0_STM_ABS.U;       /* it is necessary to get this value to have minimum 100uS delay in subsequent CPU start */

    stmCount = (unsigned int)(Ifx_Ssw_getStmFrequency() * IFX_CFG_SSW_STARTCPU_WAIT_TIME_IN_SECONDS);

    while ((unsigned int)(CPU0_STM_ABS.U - stmCountBegin) < stmCount)
    {
        /* There is no need to check overflow of the STM timer.
         * When counter after overflow subtracted with counter before overflow,
         * the subtraction result will be as expected, as long as both are unsigned 32 bits
         * eg: stmCountBegin= 0xFFFFFFFE (before overflow)
         *     stmCountNow = 0x00000002 (before overflow)
         *     diff= stmCountNow - stmCountBegin = 4 as expected.*/
    }
}


void Ifx_Ssw_doCppInit(void)
{
    Ifx_Ssw_C_InitInline();

#ifdef __TASKING__
    extern void _main(void); /* cpp initialization */
    _main();
#elif defined(__HIGHTEC__) && !defined(__clang__)
    extern void _init(void); /* cpp initialization */
    _init();
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
    extern void _init(void); /* cpp initialization */
    _init();
#elif defined(__HIGHTEC__) && defined(__clang__)
    /* cpp initialization */
    extern void __libc_init_array(void);
    extern void __libc_fini_array(void);
    extern int  atexit(void (*func)(void));
    atexit(__libc_fini_array);
    __libc_init_array();
#elif defined(__ghs__)
    extern void _main(void); /* cpp initialization */
    _main();
#elif defined(__DCC__)
    /* Cpp Init part of the init_main called in C Init Inline */
#endif
}


void Ifx_Ssw_doCppExit(int status)
{
#ifdef __TASKING__
    extern void _doexit(void); /* cpp deinitialization */
    _doexit();
#elif defined(__HIGHTEC__) && !defined(__clang__)
    extern void exit(int);     /* cpp deinitialization */
    exit(status);
#elif defined(__GNUC__) && !defined(__HIGHTEC__)
    extern void exit(int);     /* cpp deinitialization */
    exit(status);
#elif defined(__HIGHTEC__) && defined(__clang__)
    extern void exit(int);     /* cpp deinitialization */
    exit(status);
#elif __ghs__
    extern void exit(int);     /* cpp deinitialization */
    exit(0);
#elif defined(__DCC__)
    extern void exit(int);     /* cpp deinitialization */
    exit(0);
#endif
}


void Ifx_Ssw_PmicSetVcore1v(void)
{
    /* Initialize clock, pins and QSPI module */
    {
        /* Select clock source used for the QSPI clock generation  */
        Ifx_CLOCK_PERCCUCON0 perccucon0Reg;
        perccucon0Reg.U            = MODULE_CLOCK.PERCCUCON0.U;
        perccucon0Reg.B.QSPIDIV    = 1U;
        perccucon0Reg.B.CLKSELQSPI = 1U;
        MODULE_CLOCK.PERCCUCON0.U  = perccucon0Reg.U;
    }

    /* Pin configuration */
    IFX_CFG_SSW_SET_PORT_MTSR(IFX_CFG_SSW_MODULE_QSPI_MTSR_PORT, IFX_CFG_SSW_MODULE_QSPI_MTSR_PIN, IFX_CFG_SSW_MODULE_QSPI_MTSR_ALTSEL);
    IFX_CFG_SSW_SET_PORT_MRST(IFX_CFG_SSW_MODULE_QSPI_MRST_PORT, IFX_CFG_SSW_MODULE_QSPI_MRST_PIN, IFX_CFG_SSW_MODULE_QSPI_MRST_ALTSEL);
    IFX_CFG_SSW_SET_PORT_SCLK(IFX_CFG_SSW_MODULE_QSPI_SCLK_PORT, IFX_CFG_SSW_MODULE_QSPI_SCLK_PIN, IFX_CFG_SSW_MODULE_QSPI_SCLK_ALTSEL);
    IFX_CFG_SSW_SET_PORT_SLSO(IFX_CFG_SSW_MODULE_QSPI_SLSO_PORT, IFX_CFG_SSW_MODULE_QSPI_SLSO_PIN, IFX_CFG_SSW_MODULE_QSPI_SLSO_ALTSEL);

    /* QSPI module configuration */
    /* Note: It is assumed that this function is called before PROT is locked the first time. */
    /* Enable QSPI module */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.CLC.B.DISR = 0U;

    {
        unsigned int initError         = 0U;
        unsigned int timeoutCycleCount = IFX_CFG_SSW_QSPI_CLOCK_ENABLE_TIMEOUT_COUNT;

        while (0U != IFX_CFG_SSW_MODULE_QSPI_PMIC.CLC.B.DISS)    /* Wait until module is enabled*/
        {
            IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        if (initError)
        {
            Ifx_Ssw_debug();
        }
    }

    /* Configure QSPI */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.PISEL.B.MRIS = IFX_CFG_SSW_QSPI_MRIS;

    {
        Ifx_QSPI_GLOBALCON globalcon;
        globalcon.U                              = 0U;
        globalcon.B.EXPECT                       = 0xFU; /* 15 */ /* 2^(EXPECT+6) : timeout for expect phase in Tqspi */
        globalcon.B.EN                           = 0x1U; /* 0 : PAUSE requested, 1 : RUN requested */
        globalcon.B.CLKSEL                       = 0x1U;
        IFX_CFG_SSW_MODULE_QSPI_PMIC.GLOBALCON.U = globalcon.U;
    }

    {
        Ifx_QSPI_GLOBALCON1 globalcon1;
        globalcon1.U                              = 0U;
        globalcon1.B.TXEN                         = 0x0U; /* TX Interrupt Event Disable */
        globalcon1.B.RXEN                         = 0x0U; /* RX Interrupt Event Disable */
        globalcon1.B.TXFIFOINT                    = 0x1U;
        globalcon1.B.RXFIFOINT                    = 0x1U;
        globalcon1.B.TXFM                         = 0x1U; /* TXFIFO Mode = Single Move Mode */
        globalcon1.B.RXFM                         = 0x1U; /* RXFIFO Mode = Single Move Mode */
        IFX_CFG_SSW_MODULE_QSPI_PMIC.GLOBALCON1.U = globalcon1.U;
    }

    /* Channel configuration */
    {
        /* BACON */
        Ifx_QSPI_BACONENTRY bacon;
        bacon.U                                   = 0U;
        bacon.B.CS                                = IFX_CFG_SSW_QSPI_SLSO;
        bacon.B.DL                                = 31U; /* Data length : 32 */
        bacon.B.BYTE                              = 0U;  /* Data length in bits */
        bacon.B.MSB                               = 1U;  /* Shift MSB first */
        bacon.B.UINT                              = 0U;  /* User interrupt disabled*/
        bacon.B.PARTYP                            = 0U;  /* Even parity */
        bacon.B.TRAIL                             = 0U;  /* Trailing delay 1 unit*/
        bacon.B.TPRE                              = 0U;  /* Prescalar for trailing delay*/
        bacon.B.LEAD                              = 6U;  /* Leading delay length : 7units*/
        bacon.B.LPRE                              = 2U;  /* Prescalar for leading delay*/
        bacon.B.IDLE                              = 6U;  /* Idle delay 7 units*/
        bacon.B.IPRE                              = 2U;  /* Prescalar for Idle delay*/
        bacon.B.LAST                              = 1U;  /* Last word in a frame */
        IFX_CFG_SSW_MODULE_QSPI_PMIC.BACONENTRY.U = bacon.U;
    }

    /* Timing parameter is derived based on 1M baud */
    /* ECON */
    {
        Ifx_QSPI_ECON econ;
        econ.U                                                         = 0U;
        econ.B.Q                                                       = 24U;
        econ.B.A                                                       = 3U;
        econ.B.B                                                       = 3U;
        econ.B.C                                                       = 1U;
        econ.B.CPOL                                                    = 0U; /* Clock polarity */
        econ.B.CPH                                                     = 1U; /* Data sampled on falling edge */
        econ.B.PAREN                                                   = 0U; /* Disable parity */
        IFX_CFG_SSW_MODULE_QSPI_PMIC.ECON[IFX_CFG_SSW_QSPI_SLSO % 8].U = econ.U;
    }

    /* Slave select output configuration */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.SSOC.B.OEN = 1 << IFX_CFG_SSW_QSPI_SLSO;

    /* Send QSPI messages to unlock TLF registers, adjust core voltage and to lock TLF registers */

    /* Unlock TLF registers */
    /* Write data into the DATAENTRY register */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.DATAENTRY[0].U = IFX_SSW_PMIC_DISABLE_PROTECTION;

    /* Adjust TLF core voltage */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.DATAENTRY[0].U = IFX_SSW_PMIC_CORE_VOLTAGE_1V; /* DEVCFG0.VCORE_SEL = 0b010100 => 1V for TLF38885QKVSx */

    /* Lock TLF registers */
    /* Write data into the DATAENTRY register */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.DATAENTRY[0].U = IFX_SSW_PMIC_ENABLE_PROTECTION;

    /* Reset QSPI kernel after transfer is done */
    {
        unsigned int initError         = 0U;
        unsigned int timeoutCycleCount = IFX_CFG_SSW_QSPI_FIFO_EMPTY_TIMEOUT_COUNT;

        /* Wait until TX FIFO buffer is empty and PHASE is back to WAIT state */
        while (IFX_CFG_SSW_MODULE_QSPI_PMIC.STATUS.B.TXFIFOLEVEL > 0U || IFX_CFG_SSW_MODULE_QSPI_PMIC.STATUS.B.PHASE != 0U)
        {
            IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        if (initError)
        {
            Ifx_Ssw_debug();
        }
    }

    /* Note: It is assumed that this function is called before PROT is locked the first time. */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.CTRLA.B.KRST = 1U;           /* Only if both Kernel reset bits are set a reset is executed */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.CTRLB.B.KRST = 1U;

    {
        unsigned int initError         = 0U;
        unsigned int timeoutCycleCount = IFX_CFG_SSW_QSPI_KERNEL_RESET_TIMEOUT_COUNT;

        while (1U != IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.STAT.B.KRST)    /* Wait until reset is executed */
        {
            IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        if (initError)
        {
            Ifx_Ssw_debug();
        }
    }

    IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.CTRLB.B.STATCLR = 1U;        /* Clear Kernel reset status bit */
}


void Ifx_Ssw_PmicSetVcore0_95v(void)
{
    /* Initialize clock, pins and QSPI module */
    {
        /* Select clock source used for the QSPI clock generation  */
        Ifx_CLOCK_PERCCUCON0 perccucon0Reg;
        perccucon0Reg.U            = MODULE_CLOCK.PERCCUCON0.U;
        perccucon0Reg.B.QSPIDIV    = 1U;
        perccucon0Reg.B.CLKSELQSPI = 1U;
        MODULE_CLOCK.PERCCUCON0.U  = perccucon0Reg.U;
    }

    /* Pin configuration */
    IFX_CFG_SSW_SET_PORT_MTSR(IFX_CFG_SSW_MODULE_QSPI_MTSR_PORT, IFX_CFG_SSW_MODULE_QSPI_MTSR_PIN, IFX_CFG_SSW_MODULE_QSPI_MTSR_ALTSEL);
    IFX_CFG_SSW_SET_PORT_MRST(IFX_CFG_SSW_MODULE_QSPI_MRST_PORT, IFX_CFG_SSW_MODULE_QSPI_MRST_PIN, IFX_CFG_SSW_MODULE_QSPI_MRST_ALTSEL);
    IFX_CFG_SSW_SET_PORT_SCLK(IFX_CFG_SSW_MODULE_QSPI_SCLK_PORT, IFX_CFG_SSW_MODULE_QSPI_SCLK_PIN, IFX_CFG_SSW_MODULE_QSPI_SCLK_ALTSEL);
    IFX_CFG_SSW_SET_PORT_SLSO(IFX_CFG_SSW_MODULE_QSPI_SLSO_PORT, IFX_CFG_SSW_MODULE_QSPI_SLSO_PIN, IFX_CFG_SSW_MODULE_QSPI_SLSO_ALTSEL);

    /* QSPI module configuration */
    /* Note: It is assumed that this function is called before PROT is locked the first time. */
    /* Enable QSPI module */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.CLC.B.DISR = 0U;

    {
        unsigned int initError         = 0U;
        unsigned int timeoutCycleCount = IFX_CFG_SSW_QSPI_CLOCK_ENABLE_TIMEOUT_COUNT;

        while (0U != IFX_CFG_SSW_MODULE_QSPI_PMIC.CLC.B.DISS)    /* Wait until module is enabled*/
        {
            IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        if (initError)
        {
            Ifx_Ssw_debug();
        }
    }

    /* Configure QSPI */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.PISEL.B.MRIS = IFX_CFG_SSW_QSPI_MRIS;

    {
        Ifx_QSPI_GLOBALCON globalcon;
        globalcon.U                              = 0U;
        globalcon.B.EXPECT                       = 0xFU; /* 15 */ /* 2^(EXPECT+6) : timeout for expect phase in Tqspi */
        globalcon.B.EN                           = 0x1U; /* 0 : PAUSE requested, 1 : RUN requested */
        globalcon.B.CLKSEL                       = 0x1U;
        IFX_CFG_SSW_MODULE_QSPI_PMIC.GLOBALCON.U = globalcon.U;
    }

    {
        Ifx_QSPI_GLOBALCON1 globalcon1;
        globalcon1.U                              = 0U;
        globalcon1.B.TXEN                         = 0x0U; /* TX Interrupt Event Disable */
        globalcon1.B.RXEN                         = 0x0U; /* RX Interrupt Event Disable */
        globalcon1.B.TXFIFOINT                    = 0x1U;
        globalcon1.B.RXFIFOINT                    = 0x1U;
        globalcon1.B.TXFM                         = 0x1U; /* TXFIFO Mode = Single Move Mode */
        globalcon1.B.RXFM                         = 0x1U; /* RXFIFO Mode = Single Move Mode */
        IFX_CFG_SSW_MODULE_QSPI_PMIC.GLOBALCON1.U = globalcon1.U;
    }

    /* Channel configuration */
    {
        /* BACON */
        Ifx_QSPI_BACONENTRY bacon;
        bacon.U                                   = 0U;
        bacon.B.CS                                = IFX_CFG_SSW_QSPI_SLSO;
        bacon.B.DL                                = 31U; /* Data length : 32 */
        bacon.B.BYTE                              = 0U;  /* Data length in bits */
        bacon.B.MSB                               = 1U;  /* Shift MSB first */
        bacon.B.UINT                              = 0U;  /* User interrupt disabled*/
        bacon.B.PARTYP                            = 0U;  /* Even parity */
        bacon.B.TRAIL                             = 0U;  /* Trailing delay 1 unit*/
        bacon.B.TPRE                              = 0U;  /* Prescalar for trailing delay*/
        bacon.B.LEAD                              = 6U;  /* Leading delay length : 7units*/
        bacon.B.LPRE                              = 2U;  /* Prescalar for leading delay*/
        bacon.B.IDLE                              = 6U;  /* Idle delay 7 units*/
        bacon.B.IPRE                              = 2U;  /* Prescalar for Idle delay*/
        bacon.B.LAST                              = 1U;  /* Last word in a frame */
        IFX_CFG_SSW_MODULE_QSPI_PMIC.BACONENTRY.U = bacon.U;
    }

    /* Timing parameter is derived based on 1M baud */
    /* ECON */
    {
        Ifx_QSPI_ECON econ;
        econ.U                                                         = 0U;
        econ.B.Q                                                       = 24U;
        econ.B.A                                                       = 3U;
        econ.B.B                                                       = 3U;
        econ.B.C                                                       = 1U;
        econ.B.CPOL                                                    = 0U; /* Clock polarity */
        econ.B.CPH                                                     = 1U; /* Data sampled on falling edge */
        econ.B.PAREN                                                   = 0U; /* Disable parity */
        IFX_CFG_SSW_MODULE_QSPI_PMIC.ECON[IFX_CFG_SSW_QSPI_SLSO % 8].U = econ.U;
    }

    /* Slave select output configuration */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.SSOC.B.OEN = 1 << IFX_CFG_SSW_QSPI_SLSO;

    /* Send QSPI messages to unlock TLF registers, adjust core voltage and to lock TLF registers */

    /* Unlock TLF registers */
    /* Write data into the DATAENTRY register */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.DATAENTRY[0].U = IFX_SSW_PMIC_DISABLE_PROTECTION;

    /* Adjust TLF core voltage */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.DATAENTRY[0].U = IFX_SSW_PMIC_CORE_VOLTAGE_0_95V; /* DEVCFG0.VCORE_SEL = 0b011000 => 0.95V => 1V for TLF38885QKVSx */

    /* Lock TLF registers */
    /* Write data into the DATAENTRY register */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.DATAENTRY[0].U = IFX_SSW_PMIC_ENABLE_PROTECTION;

    /* Reset QSPI kernel after transfer is done */
    {
        unsigned int initError         = 0U;
        unsigned int timeoutCycleCount = IFX_CFG_SSW_QSPI_FIFO_EMPTY_TIMEOUT_COUNT;

        /* Wait until TX FIFO buffer is empty and PHASE is back to WAIT state */
        while (IFX_CFG_SSW_MODULE_QSPI_PMIC.STATUS.B.TXFIFOLEVEL > 0U || IFX_CFG_SSW_MODULE_QSPI_PMIC.STATUS.B.PHASE != 0U)
        {
            IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        if (initError)
        {
            Ifx_Ssw_debug();
        }
    }

    /* Note: It is assumed that this function is called before PROT is locked the first time. */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.CTRLA.B.KRST = 1U;           /* Only if both Kernel reset bits are set a reset is executed */
    IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.CTRLB.B.KRST = 1U;

    {
        unsigned int initError         = 0U;
        unsigned int timeoutCycleCount = IFX_CFG_SSW_QSPI_KERNEL_RESET_TIMEOUT_COUNT;

        while (1U != IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.STAT.B.KRST)    /* Wait until reset is executed */
        {
            IFX_CFG_SSW_LOOP_TIMEOUT_CHECK(timeoutCycleCount, initError);
        }

        if (initError)
        {
            Ifx_Ssw_debug();
        }
    }

    IFX_CFG_SSW_MODULE_QSPI_PMIC.RST.CTRLB.B.STATCLR = 1U;        /* Clear Kernel reset status bit */
}


void IfxSsw_clearSram(Ifx_VMT *vmt, unsigned int ssh)
{
    unsigned int mask;

    /*Enable module*/
    if (vmt->CLC.B.DISS == 1)
    {
        vmt->CLC.B.DISR = 0u;
    }

    /* Enables the MBIST Shell of the given SRAM */
    vmt->MC[ssh].ALMSRCS.B.MISCE = 0;
    vmt->MC[ssh].ALMSRCS.B.OPENE = 0;
    mask                         = 1 << (ssh & 0x1f);
    vmt->MEMTEST.U              |= mask;

    while ((vmt->MEMSTAT.U & mask) != 0)
    {}

    /* start init operation */
    unsigned int mcontrolMask = 0x4000;                                                                                      /* set USERED flag */
    vmt->MC[ssh].MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF); /* START = SRAM_CLR = 1 */
    vmt->MC[ssh].MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_SRAM_CLR_OFF);

    /* wait for the end of the fill operation */
    while (!((vmt->MEMDONE.U & mask) != 0))
    {
        Ifx_Ssw_NOP();
    }

    /* configure MBIST for single read opeation */
    vmt->MC[ssh].MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);
    vmt->MC[ssh].CONFIG0.U  = (1 << IFX_VMT_MC_CONFIG0_NUMACCS_OFF) | (1 << IFX_VMT_MC_CONFIG0_ACCSTYPE_OFF); /* 1 read access */
    /* ensure that linear scrambling is used */
    vmt->MC[ssh].CONFIG1.U  = 0;
    /* Set the address to be read (RAEN = 0) */
    vmt->MC[ssh].RANGE.U    = 0x0000;

    /* Start operation */
    vmt->MC[ssh].MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF) | (1 << IFX_VMT_MC_MCONTROL_START_OFF);
    vmt->MC[ssh].MCONTROL.U = mcontrolMask | (1 << IFX_VMT_MC_MCONTROL_DIR_OFF);

    /* wait for the end of the fill operation */
    while (!((vmt->MEMDONE.U & mask) != 0))
    {
        Ifx_Ssw_NOP();
    }

    /* Note: a SMU alarm will be flagged HERE if the wrong ECC has been written! */
    vmt->MEMTEST.U &= ~mask;

    while ((vmt->MEMSTAT.U & mask) != 0)
    {
        Ifx_Ssw_NOP();
    }

    /*Enable Error Reporting  */
    vmt->MC[ssh].ALMSRCS.B.MISCE = 1;
    vmt->MC[ssh].ALMSRCS.B.OPENE = 1;

    /* for auto-init memories: wait for the end of the clear operation */
    while ((vmt->MEMSTAT.U & mask) != 0)
    {
        Ifx_Ssw_NOP();
    }
}
