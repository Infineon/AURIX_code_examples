/**********************************************************************************************************************
 * \file LMU_MPU.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "LMU_MPU.h"

/*********************************************************************************************************************/
/*----------------------------------------------Function Implementations---------------------------------------------*/
/*********************************************************************************************************************/
/* Functions for LMU MPU are implemented for the following aspects:
 - Access enable/disable to the LMU memory.
 - Defining protection ranges.
 - Enable/Disable read/write access to ranges.

 * Note: The LMU Registers, are provided by IfxLmu_regdef.h library.

 * Make sure to enable accessing, and define protection ranges before calling enable/disable read/write functions.
 *
 * -----------Functions for access enabling/disabling to LMU0 ------------------*/
/* The ACCEN0/ACCEN1 registers are used to implement LMU access enable/disable.
 * The ACCEN0/ACCEN1 allows the LMU0 control registers to be protected from write accesses by untrusted masters.
 * The ACCEN0/ACCEN1 controls access for transactions to registers with the on chip bus master TAG ID.
 * ENn(n=0-31)in ACCEN0, and ENn(n=32-63)in ACCEN1.
 */
void enable_LMU0_access(Ifx_TagID tagId)
{
    MODULE_LMU0.ACCEN0.U |= (tagId & 0x00000000FFFFFFFF);
    MODULE_LMU0.ACCEN1.U |= (tagId & 0xFFFFFFFF00000000) >> 32;
}

void disable_LMU0_access(Ifx_TagID tagId)
{
    MODULE_LMU0.ACCEN0.U &= ~(tagId & 0x00000000FFFFFFFF);
    MODULE_LMU0.ACCEN1.U &= ~(tagId & 0xFFFFFFFF00000000) >> 32;
}

/*-----------Functions for defining protection range-----------------*/
/* Protection of LMU SRAM contents:
 * 16 programmable address regions can be protected.
 * Each address range has a programmable list of bus masters permitted read or write access based on the Unique
 * master Tag ID.
 *
 * Each region is defined using six registers:
 * RGNLAx (x=0-15) to define the lower address of the region, RGNUAx (x=0-15) to define the upper address of the
   region
 * Two registers RGNACCENWAx (x=0-15) and RGNACCENWBx (x=0-15), to individually select the master tags
   permitted write access to the defined address range.
 * Two registers RGNACCENRAx (x=0-15) and RGNACCENRBx (x=0-15) to individually select the master tags
   permitted read access to the defined address range.
 *
 *-----------Function that defines LMU0 protection range------------*/
/* Protection ranges of LMU0 are defined by the Lower address of the region, and the Upper address of the region.
 * The registers, RGNLAx (x=0-15) define the lower address of the region of LMU0.
 * The registers, RGNUAx (x=0-15) define the Upper address of the region of LMU0.
 */
void define_LMU0_bus_protection_range(uint32 lowerBoundAddress, uint32 upperBoundAddress, Ifx_LMU_RGN_IDX range)
{
    MODULE_LMU0.RGN[range].LA.U = lowerBoundAddress;
    MODULE_LMU0.RGN[range].UA.U = upperBoundAddress;
}

/* ----------Functions for enable/disable LMU0 read access ----------*/
/* Make sure to define protection ranges before calling this function.
 * Note: The protection scheme is based on the use of SRI tags to identify the master attempting the access
  (TAG ID based protection), that Indicates which masters are allowed to reach and access to the region.
 *
 * Each region of LMU0 may be enabled for reads/writes on a per bus master basis using the master Tag ID.
 * Two registers RGNACCENRAx (x=0-15) and RGNACCENRBx (x=0-15) to individually select the master tags
 * permitted read access to the defined address range.
 * Note: The LMU Registers, are provided by IfxLmu_regdef.h library.
 */
void enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX range, Ifx_TagID tagId)
{
    MODULE_LMU0.RGNACCEN[range].RA.U |= (tagId & 0x00000000FFFFFFFF);
    MODULE_LMU0.RGNACCEN[range].RB.U |= (tagId & 0xFFFFFFFF00000000) >> 32;
}

void disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX range, Ifx_TagID tagId)
{
    MODULE_LMU0.RGNACCEN[range].RA.U &= ~(tagId & 0x00000000FFFFFFFF);
    MODULE_LMU0.RGNACCEN[range].RB.U &= ~(tagId & 0xFFFFFFFF00000000) >> 32;
}

/* ----------Functions for enable/disable LMU0 write access ----------*/
/* Make sure to define protection ranges before calling this function.
 * Note: The protection scheme is based on the use of SRI tags to identify the master attempting the access
  (TAG ID based protection), that Indicates which masters are allowed to reach and access to the region.
 *
 * Two registers RGNACCENWAx (x=0-15) and RGNACCENWBx (x=0-15), to individually select the master tags
 * permitted write access to the defined address range.
 * Note: The LMU Registers, can be found in the IfxLmu_regdef.h library.
 */
void enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX range, Ifx_TagID tagId)
{
    MODULE_LMU0.RGN[range].ACCENA.U |= (tagId & 0x00000000FFFFFFFF);
    MODULE_LMU0.RGN[range].ACCENB.U |= (tagId & 0xFFFFFFFF00000000) >> 32;
}

void disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX range, Ifx_TagID tagId)
{
    MODULE_LMU0.RGN[range].ACCENA.U &= ~(tagId & 0x00000000FFFFFFFF);
    MODULE_LMU0.RGN[range].ACCENB.U &= ~(tagId & 0xFFFFFFFF00000000) >> 32;
}
