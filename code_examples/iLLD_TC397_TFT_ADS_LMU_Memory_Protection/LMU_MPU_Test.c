/**********************************************************************************************************************
 * \file LMU_MPU_Test.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 * 
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of 
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and 
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all 
 * derivative works of the Software, unless such copies or derivative works are solely in the form of 
 * machine-executable object code generated by a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE 
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN 
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "LMU_MPU_Test.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
/* LEDs */
#define ledOn(LED)             IfxPort_setPinLow(LED)
#define ledOff(LED)            IfxPort_setPinHigh(LED)

/* To concatenate Core number to Ifx_TagID_CPU. Generate TagId by Core number */
#define TEST_CORE_TAG_(CORE)        Ifx_TagID_CPU ##CORE
#define TEST_CORE_TAG(CORE)         TEST_CORE_TAG_(CORE)

#define TEST_CORE_CONFIG_TAG        TEST_CORE_TAG(TEST_CORE_CONFIG)
#define TEST_CORE_EXECUTE_TAG       TEST_CORE_TAG(TEST_CORE_EXECUTE)

/*********************************************************************************************************************/
/**----------------------------------------------------variables--------------------------------------------------- **/
/*********************************************************************************************************************/
/* Define an array of integers
 * Forcing this vector to place in LMU memory
 * LMU0 Address Range non-cached: 0xB0040000 up to 0xB007FFFF */
uint8 LMU_Array[ALL_REGION_SIZE] __at(0xB0040000);

volatile uint8  Test_Number = 0;                                    /* To choose Test1, Test2, Test3, Test4 and Test5*/

volatile uint32 Test_Error_Count = 0;            /* Counting errors when non-protected element in LMU0 has been read */

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
/* Function to initialize the port pins that drive the LEDs */
void Test_LED_init(void)
{
    /* Initialization of the LED port pins */
    IfxPort_setPinModeOutput(LED_SUCCESS, IfxPort_OutputMode_pushPull, IfxPort_OutputIdx_general);

    /* Switch OFF the LED (low-level active) */
    ledOff(LED_SUCCESS);
}

/**
 * Test Examples:
 * Please refer to the README.md, which is explained completely all Test scenarios.
 *
 * "Configuration" and "Execute" has been done for all Tests on LMU memories.
 *
 * "Access" means that, the access of the CPU Execute to the target region.
 *
 * TEST_1                     1 -> Access: Yes       Write: Success             Read: Success (No Trap)
 * TEST_2                     2 -> Access: No        Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_3_NON_OVERLAP         3 -> Access: No        Write: Silently ignored    Read: Expect to Trap (Class:4 Tin:2)
 * TEST_4_OVERLAP             4 -> Access: Yes       Write: Success             Read: Success (No Trap)
 * TEST_5 (Test for Alarm))   5 -> Write only        write: ALM7[15] is triggered when the CPU writes the area other
 *                                                   than the write protection area.
 *
 *
 * Test3 and Test4 Overlap Regions:
 * 0xB0040000 up to 0xB004003F
 * ----------------------------------------------------------------------------
 * |         Region0         |   Region2  | Region3 |..........|  Region 15   |
 * ----------------------------------------------------------------------------
 * |Non-overlap |      Region 1 (overlap) |
 * ----------------------------------------
 *              0xB0040020 up to 0xB004003F
 *
 */


/* Test1 Configuration for LMU0 */
/* Full Access (Region 0 and Region 1 can access by CPU0 and CPU1).*/
void Test1_configuration(void)
{
    Test_Number = TEST_1;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    /* access be configuration LMU */
    enable_LMU0_access((Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Configure LMU memory protection for DLMU0
     * 16 read and write protected regions of LMU0 with enables for reads and writes on a per bus master basis.
     * All the sixteen regions will cover all the addressing space of the LMU.
     *
     * Rules for LMU0 memory protection range configuration:
     * Protection ranges of LMU are defined by the Lower address of the region, and the Upper address of the region.
     * After enabling the LMU Memory Protection, access to an address 'x' will be allowed only if:
     * lowerBoundAddress <= x < upperBoundAddress and the master tag of the access is enabled.
     * If a address space is not covered by a region, the access will not be granted to any master.
     */

    /* Define the Protection Range 0: from 0xB0040000 up to 0xB004001F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 0],
                 (uint32) &LMU_Array[REGION_SIZE * 1], Ifx_LMU_RGN_IDX_0);

    /* Define the Protection Range 1: from 0xB0040020 up to 0xB004003F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 1],
                 (uint32) &LMU_Array[REGION_SIZE * 2], Ifx_LMU_RGN_IDX_1);

    /* Define the Protection Range 2: from 0xB0040040 up to 0xB004005F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 2],
                 (uint32) &LMU_Array[REGION_SIZE * 3], Ifx_LMU_RGN_IDX_2);

    /* Define the Protection Range 3: from 0xB0040060 up to 0xB004007F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 3],
                 (uint32) &LMU_Array[REGION_SIZE * 4], Ifx_LMU_RGN_IDX_3);

    /* Define the Protection Range 4: from 0xB0040080 up to 0xB004009F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 4],
                 (uint32) &LMU_Array[REGION_SIZE * 5], Ifx_LMU_RGN_IDX_4);

    /* Define the Protection Range 5: from 0xB00400A0 up to 0xB00400BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 5],
                 (uint32) &LMU_Array[REGION_SIZE * 6], Ifx_LMU_RGN_IDX_5);

    /* Define the Protection Range 6: from 0xB00400C0 up to 0xB00400DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 6],
                 (uint32) &LMU_Array[REGION_SIZE * 7], Ifx_LMU_RGN_IDX_6);

    /* Define the Protection Range 7: from 0xB00400E0 up to 0xB00400FF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 7],
                 (uint32) &LMU_Array[REGION_SIZE * 8], Ifx_LMU_RGN_IDX_7);

    /* Define the Protection Range 8: from 0xB0040100 up to 0xB004011F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 8],
                 (uint32) &LMU_Array[REGION_SIZE * 9], Ifx_LMU_RGN_IDX_8);

    /* Define the Protection Range 9: from 0xB0040120 up to 0xB004013F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 9],
                (uint32) &LMU_Array[REGION_SIZE * 10], Ifx_LMU_RGN_IDX_9);

    /* Define the Protection Range 10: from 0xB0040140 up to 0xB004015F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 10],
                (uint32) &LMU_Array[REGION_SIZE * 11], Ifx_LMU_RGN_IDX_10);

    /* Define the Protection Range 11: from 0xB0040160 up to 0xB004017F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 11],
                (uint32) &LMU_Array[REGION_SIZE * 12], Ifx_LMU_RGN_IDX_11);

    /* Define the Protection Range 12: from 0xB0040180 up to 0xB004019F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 12],
                (uint32) &LMU_Array[REGION_SIZE * 13], Ifx_LMU_RGN_IDX_12);

    /* Define the Protection Range 13: from 0xB00401A0 up to 0xB00401BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 13],
                (uint32) &LMU_Array[REGION_SIZE * 14], Ifx_LMU_RGN_IDX_13);

    /* Define the Protection Range 14: from 0xB00401C0 up to 0xB00401DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 14],
                (uint32) &LMU_Array[REGION_SIZE * 15], Ifx_LMU_RGN_IDX_14);

    /* Define the Protection Range 15: from 0xB00401E0 up to the end of LMU0 memory (0xB007FFFF) */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 15],
                                  (uint32) 0xB007FFFF, Ifx_LMU_RGN_IDX_15);

    /* Enable read and write access of Core0 and Core1 to the Protection Range 0
       and Protection Range 1 in the LMU0 Local Memory */

    /* Enable read access of Core0 to the protection range 0. */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable read access of Core1 to the protection range 0. */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Enable read access of Core0 to the protection range 1. */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable read access of Core1 to the protection range 1. */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Enable write access of Core0 to the protection range 0. */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable write access of Core1 to the protection range 0. */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Enable write access of Core0 to the protection range 1. */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable write access of Core1 to the protection range 1. */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);

    /* Waiting phase in order to not interfere with the pipelining process which is reported
     * as a problem in setting of the protection change. These are performed right after setting
     * the Safety ENDINIT that closes the change of the registers handling the regions definition.
     */
    waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));
}

/* Test1 Execute for LMU0 */
/* Full Access (Region 0 and Region 1 can access by CPU0 and CPU1).*/
void Test1_execute(void)
{
    Test_Number = TEST_1;

    Test_Error_Count = 0;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        LMU_Array[i] = (uint8) i;
    }

    /*-------Read range 0 and range 1 and compare with the write pattern (read & verify)----- */

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read. */
        if (LMU_Array[i] != (uint8) i)
        {
            Test_Error_Count++;
        }
    }
    /* Check Error */
    if (Test_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
    }
    else if (Test_Error_Count)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
    }
}

/* Test2 Configuration for LMU0 */
/* Test2 : Non-Overlap Regions
 *  (Region 0 and Region 1 are non-verlap): CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1
 */
void Test2_configuration(void)
{
    Test_Number = TEST_2;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    enable_LMU0_access((Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Define the Protection Range 0: from 0xB0040000 up to 0xB004001F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 0],
                 (uint32) &LMU_Array[REGION_SIZE * 1], Ifx_LMU_RGN_IDX_0);

    /* Define the Protection Range 1: from 0xB0040020 up to 0xB004003F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 1],
                 (uint32) &LMU_Array[REGION_SIZE * 2], Ifx_LMU_RGN_IDX_1);

    /* Define the Protection Range 2: from 0xB0040040 up to 0xB004005F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 2],
                 (uint32) &LMU_Array[REGION_SIZE * 3], Ifx_LMU_RGN_IDX_2);

    /* Define the Protection Range 3: from 0xB0040060 up to 0xB004007F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 3],
                 (uint32) &LMU_Array[REGION_SIZE * 4], Ifx_LMU_RGN_IDX_3);

    /* Define the Protection Range 4: from 0xB0040080 up to 0xB004009F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 4],
                 (uint32) &LMU_Array[REGION_SIZE * 5], Ifx_LMU_RGN_IDX_4);

    /* Define the Protection Range 5: from 0xB00400A0 up to 0xB00400BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 5],
                 (uint32) &LMU_Array[REGION_SIZE * 6], Ifx_LMU_RGN_IDX_5);

    /* Define the Protection Range 6: from 0xB00400C0 up to 0xB00400DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 6],
                 (uint32) &LMU_Array[REGION_SIZE * 7], Ifx_LMU_RGN_IDX_6);

    /* Define the Protection Range 7: from 0xB00400E0 up to 0xB00400FF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 7],
                 (uint32) &LMU_Array[REGION_SIZE * 8], Ifx_LMU_RGN_IDX_7);

    /* Define the Protection Range 8: from 0xB0040100 up to 0xB004011F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 8],
                 (uint32) &LMU_Array[REGION_SIZE * 9], Ifx_LMU_RGN_IDX_8);

    /* Define the Protection Range 9: from 0xB0040120 up to 0xB004013F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 9],
                (uint32) &LMU_Array[REGION_SIZE * 10], Ifx_LMU_RGN_IDX_9);

    /* Define the Protection Range 10: from 0xB0040140 up to 0xB004015F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 10],
                (uint32) &LMU_Array[REGION_SIZE * 11], Ifx_LMU_RGN_IDX_10);

    /* Define the Protection Range 11: from 0xB0040160 up to 0xB004017F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 11],
                (uint32) &LMU_Array[REGION_SIZE * 12], Ifx_LMU_RGN_IDX_11);

    /* Define the Protection Range 12: from 0xB0040180 up to 0xB004019F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 12],
                (uint32) &LMU_Array[REGION_SIZE * 13], Ifx_LMU_RGN_IDX_12);

    /* Define the Protection Range 13: from 0xB00401A0 up to 0xB00401BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 13],
                (uint32) &LMU_Array[REGION_SIZE * 14], Ifx_LMU_RGN_IDX_13);

    /* Define the Protection Range 14: from 0xB00401C0 up to 0xB00401DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 14],
                (uint32) &LMU_Array[REGION_SIZE * 15], Ifx_LMU_RGN_IDX_14);

    /* Define the Protection Range 15: from 0xB00401E0 up to the end of LMU0 memory (0xB007FFFF) */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 15],
                                  (uint32) 0xB007FFFF, Ifx_LMU_RGN_IDX_15);

    /* Enable read access of Core0 to Range 0 of LMU0 */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not read access of Core1 to Range 0 of LMU0 */
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not read access of Core0 to Range 1 of LMU0 ----*/
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not read access of Core1 to Range 1 of LMU0 ----*/
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Enable write access of Core0 to Range 0 of LMU0 ----*/
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not write access of Core1 to Range 0 of LMU0 ----*/
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not write access of Core0 to Range 1 of LMU0 ----*/
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not write access of Core1 to Range 1 of LMU0 ----*/
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);

    /* Waiting phase in order to not interfere with the pipelining process which is reported
     * as a problem in setting of the protection change. These are performed right after setting
     * the Safety ENDINIT that closes the change of the registers handling the regions definition.
     */
    waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));
}

/* Test2 Execute for LMU0 */
/* Test2 : Non-Overlap Regions
 * (Region 0 and Region 1 are non-verlap): CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1
 */
void Test2_execute(void)
{
    Test_Number = TEST_2;

    /* Fill the range 0 and rang 1 with the following write pattern (write phase)*/
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        LMU_Array[i] = (uint8) (i + 5);
    }

    /*-------Read range 0 and range 1 and compare with the write pattern (read & verify)----- */

     Test_Error_Count = 0;

     /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read. */
        if (LMU_Array[i] == (uint8) (i + 5))
        {
            Test_Error_Count++;
        }
    }
    /* Check Error */
    if (Test_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
    }
    else if (Test_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
    }
}

/* Test3 Configuration for LMU0
 * Test3 : Overlap Regions:
 * (Region 0 and Region 1 are overlap, and test has been done for access to non-overlap part):
 *  CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 */
void Test3_configuration(void)
{
    Test_Number = TEST_3;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    enable_LMU0_access((Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Define the Protection Range 0: from 0xB0040000 up to 0xB004003F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 0],
                 (uint32) &LMU_Array[REGION_SIZE * 2], Ifx_LMU_RGN_IDX_0);

    /* Define the Protection Range 1: from 0xB0040020 up to 0xB004003F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 1],
                 (uint32) &LMU_Array[REGION_SIZE * 2], Ifx_LMU_RGN_IDX_1);

    /* Define the Protection Range 2: from 0xB0040040 up to 0xB004005F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 2],
                 (uint32) &LMU_Array[REGION_SIZE * 3], Ifx_LMU_RGN_IDX_2);

    /* Define the Protection Range 3: from 0xB0040060 up to 0xB004007F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 3],
                 (uint32) &LMU_Array[REGION_SIZE * 4], Ifx_LMU_RGN_IDX_3);

    /* Define the Protection Range 4: from 0xB0040080 up to 0xB004009F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 4],
                 (uint32) &LMU_Array[REGION_SIZE * 5], Ifx_LMU_RGN_IDX_4);

    /* Define the Protection Range 5: from 0xB00400A0 up to 0xB00400BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 5],
                 (uint32) &LMU_Array[REGION_SIZE * 6], Ifx_LMU_RGN_IDX_5);

    /* Define the Protection Range 6: from 0xB00400C0 up to 0xB00400DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 6],
                 (uint32) &LMU_Array[REGION_SIZE * 7], Ifx_LMU_RGN_IDX_6);

    /* Define the Protection Range 7: from 0xB00400E0 up to 0xB00400FF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 7],
                 (uint32) &LMU_Array[REGION_SIZE * 8], Ifx_LMU_RGN_IDX_7);

    /* Define the Protection Range 8: from 0xB0040100 up to 0xB004011F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 8],
                 (uint32) &LMU_Array[REGION_SIZE * 9], Ifx_LMU_RGN_IDX_8);

    /* Define the Protection Range 9: from 0xB0040120 up to 0xB004013F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 9],
                (uint32) &LMU_Array[REGION_SIZE * 10], Ifx_LMU_RGN_IDX_9);

    /* Define the Protection Range 10: from 0xB0040140 up to 0xB004015F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 10],
                (uint32) &LMU_Array[REGION_SIZE * 11], Ifx_LMU_RGN_IDX_10);

    /* Define the Protection Range 11: from 0xB0040160 up to 0xB004017F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 11],
                (uint32) &LMU_Array[REGION_SIZE * 12], Ifx_LMU_RGN_IDX_11);

    /* Define the Protection Range 12: from 0xB0040180 up to 0xB004019F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 12],
                (uint32) &LMU_Array[REGION_SIZE * 13], Ifx_LMU_RGN_IDX_12);

    /* Define the Protection Range 13: from 0xB00401A0 up to 0xB00401BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 13],
                (uint32) &LMU_Array[REGION_SIZE * 14], Ifx_LMU_RGN_IDX_13);

    /* Define the Protection Range 14: from 0xB00401C0 up to 0xB00401DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 14],
                (uint32) &LMU_Array[REGION_SIZE * 15], Ifx_LMU_RGN_IDX_14);

    /* Define the Protection Range 15: from 0xB00401E0 up to the end of LMU0 memory (0xB007FFFF) */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 15],
                                  (uint32) 0xB007FFFF, Ifx_LMU_RGN_IDX_15);

    /* Enable read access of Core0 to Range 0 of LMU0 */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not read access of Core1 to Range 0 of LMU0 */
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not read access of Core0 to Range 1 of LMU0 */
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable read access of Core1 to Range 1 of LMU0 */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Enable write access of Core0 to Range 0 of LMU0 */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not write access of Core1 to Range 0 of LMU0 */
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not write access of Core0 to Range 1 of LMU0 */
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable write access of Core1 to Range 1 of LMU0 */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);

    /* Waiting phase in order to not interfere with the pipelining process which is reported
     * as a problem in setting of the protection change. These are performed right after setting
     * the Safety ENDINIT that closes the change of the registers handling the regions definition.
     */
    waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));
}

/* Test3 Execute for LMU0
 * Test3 : Overlap Regions:
 * (Region 0 and Region 1 are overlap, and test has been done for access to non-overlap part):
 * CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 */
void Test3_execute(void)
{
    Test_Number = TEST_3;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 1; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        LMU_Array[i] = (uint8) (i + 7);
    }

    /*-------Read range 0 and range 1 and compare with the write pattern (read & verify)----- */

    Test_Error_Count = 0;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = 0; i < REGION_SIZE * 1; i++)
    {
        /* Check whether the non-protected element has been read. */
        if (LMU_Array[i] == (uint8) (i + 7))
        {
            Test_Error_Count++;
        }
    }

    /* Check Error */
    if (Test_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
    }
    else if (Test_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
    }
}

/* Test4 Configuration for LMU0
 * Test4 : Overlap Regions
 * (Region 0 and Region 1 are overlap, and test has been done for access to overlap part):
   CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 */
void Test4_configuration(void)
{
    Test_Number = TEST_4;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    enable_LMU0_access((Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Define the Protection Range 0: from 0xB0040000 up to 0xB004003F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 0],
                 (uint32) &LMU_Array[REGION_SIZE * 2], Ifx_LMU_RGN_IDX_0);

    /* Define the Protection Range 1: from 0xB0040020 up to 0xB004003F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 1],
                 (uint32) &LMU_Array[REGION_SIZE * 2], Ifx_LMU_RGN_IDX_1);

    /* Define the Protection Range 2: from 0xB0040040 up to 0xB004005F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 2],
                 (uint32) &LMU_Array[REGION_SIZE * 3], Ifx_LMU_RGN_IDX_2);

    /* Define the Protection Range 3: from 0xB0040060 up to 0xB004007F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 3],
                 (uint32) &LMU_Array[REGION_SIZE * 4], Ifx_LMU_RGN_IDX_3);

    /* Define the Protection Range 4: from 0xB0040080 up to 0xB004009F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 4],
                 (uint32) &LMU_Array[REGION_SIZE * 5], Ifx_LMU_RGN_IDX_4);

    /* Define the Protection Range 5: from 0xB00400A0 up to 0xB00400BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 5],
                 (uint32) &LMU_Array[REGION_SIZE * 6], Ifx_LMU_RGN_IDX_5);

    /* Define the Protection Range 6: from 0xB00400C0 up to 0xB00400DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 6],
                 (uint32) &LMU_Array[REGION_SIZE * 7], Ifx_LMU_RGN_IDX_6);

    /* Define the Protection Range 7: from 0xB00400E0 up to 0xB00400FF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 7],
                 (uint32) &LMU_Array[REGION_SIZE * 8], Ifx_LMU_RGN_IDX_7);

    /* Define the Protection Range 8: from 0xB0040100 up to 0xB004011F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 8],
                 (uint32) &LMU_Array[REGION_SIZE * 9], Ifx_LMU_RGN_IDX_8);

    /* Define the Protection Range 9: from 0xB0040120 up to 0xB004013F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 9],
                (uint32) &LMU_Array[REGION_SIZE * 10], Ifx_LMU_RGN_IDX_9);

    /* Define the Protection Range 10: from 0xB0040140 up to 0xB004015F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 10],
                (uint32) &LMU_Array[REGION_SIZE * 11], Ifx_LMU_RGN_IDX_10);

    /* Define the Protection Range 11: from 0xB0040160 up to 0xB004017F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 11],
                (uint32) &LMU_Array[REGION_SIZE * 12], Ifx_LMU_RGN_IDX_11);

    /* Define the Protection Range 12: from 0xB0040180 up to 0xB004019F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 12],
                (uint32) &LMU_Array[REGION_SIZE * 13], Ifx_LMU_RGN_IDX_12);

    /* Define the Protection Range 13: from 0xB00401A0 up to 0xB00401BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 13],
                (uint32) &LMU_Array[REGION_SIZE * 14], Ifx_LMU_RGN_IDX_13);

    /* Define the Protection Range 14: from 0xB00401C0 up to 0xB00401DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 14],
                (uint32) &LMU_Array[REGION_SIZE * 15], Ifx_LMU_RGN_IDX_14);

    /* Define the Protection Range 15: from 0xB00401E0 up to the end of LMU0 memory (0xB007FFFF) */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 15],
                                  (uint32) 0xB007FFFF, Ifx_LMU_RGN_IDX_15);

    /* Enable read access of Core0 to the protection range 0 of LMU0 */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not read access of Core1 to Range 0 of LMU0 */
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not read access of Core0 to Range 1 of LMU0 */
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable read access of Core1 to the protection range 1. */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Enable write access of Core0 to the protection range 0. */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not write access of Core1 to Range 0 of LMU0 */
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not write access of Core0 to Range 1 of LMU0 */
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Enable write access of Core1 to the protection range 1. */
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);

    /* Waiting phase in order to not interfere with the pipelining process which is reported
     * as a problem in setting of the protection change. These are performed right after setting
     * the Safety ENDINIT that closes the change of the registers handling the regions definition.
     */
    waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));
}
/* Test4 Execute for LMU0
 * Test4 : Overlap Regions
 * (Region 0 and Region 1 are overlap, and test has been done for access to overlap part):
   CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 -> R1
 */
void Test4_execute(void)
{
    Test_Number = TEST_4;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = REGION_SIZE; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        LMU_Array[i] = (uint8) (i + 7);
    }

    /*-------Read range 0 and range 1 and compare with the write pattern (read & verify)----- */

    Test_Error_Count = 0;

    /* Make a read access to the range 0 and range 1. */
    for (uint32 i = REGION_SIZE; i < REGION_SIZE * 2; i++)
    {
        /* Check whether the non-protected element has been read. */
        if (LMU_Array[i] != (uint8) (i + 7))
        {
            Test_Error_Count++;
        }
    }
    /* Check Error */
    if (Test_Error_Count == 0)
    {
        /* Turn on the LED SUCCESS to indicate protected elements have been successfully read. */
        ledOn(LED_SUCCESS);
    }
    else if (Test_Error_Count != 0)
    {
        /* Turn off the LED SUCCESS to indicate non-protected elements tried to be read. */
        ledOff(LED_SUCCESS);
    }
}

/* Test 5 : TEST for Alarm triggering.
 * ALM7[15] raises when the CPU writes the area other than the write protection area.
 * (Configuration is the same as Test2):
 * Non-Overlap Regions (Region 0 and Region 1 are non-verlap): CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1
 */
void Test5_configuration(void)
{
    Test_Number = TEST_5;

    /* All safety protection registers are protected from modification by the safety_endinit signal.    */
    /* Clear Safety ENDINIT protection for modification of the configuration registers */
    uint16 safetyWdtPw = IfxScuWdt_getSafetyWatchdogPassword();
    IfxScuWdt_clearSafetyEndinit(safetyWdtPw);

    enable_LMU0_access((Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Define the Protection Range 0: from 0xB0040000 up to 0xB004001F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 0],
                 (uint32) &LMU_Array[REGION_SIZE * 1], Ifx_LMU_RGN_IDX_0);

    /* Define the Protection Range 1: from 0xB0040020 up to 0xB004003F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 1],
                 (uint32) &LMU_Array[REGION_SIZE * 2], Ifx_LMU_RGN_IDX_1);

    /* Define the Protection Range 2: from 0xB0040040 up to 0xB004005F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 2],
                 (uint32) &LMU_Array[REGION_SIZE * 3], Ifx_LMU_RGN_IDX_2);

    /* Define the Protection Range 3: from 0xB0040060 up to 0xB004007F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 3],
                 (uint32) &LMU_Array[REGION_SIZE * 4], Ifx_LMU_RGN_IDX_3);

    /* Define the Protection Range 4: from 0xB0040080 up to 0xB004009F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 4],
                 (uint32) &LMU_Array[REGION_SIZE * 5], Ifx_LMU_RGN_IDX_4);

    /* Define the Protection Range 5: from 0xB00400A0 up to 0xB00400BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 5],
                 (uint32) &LMU_Array[REGION_SIZE * 6], Ifx_LMU_RGN_IDX_5);

    /* Define the Protection Range 6: from 0xB00400C0 up to 0xB00400DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 6],
                 (uint32) &LMU_Array[REGION_SIZE * 7], Ifx_LMU_RGN_IDX_6);

    /* Define the Protection Range 7: from 0xB00400E0 up to 0xB00400FF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 7],
                 (uint32) &LMU_Array[REGION_SIZE * 8], Ifx_LMU_RGN_IDX_7);

    /* Define the Protection Range 8: from 0xB0040100 up to 0xB004011F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 8],
                 (uint32) &LMU_Array[REGION_SIZE * 9], Ifx_LMU_RGN_IDX_8);

    /* Define the Protection Range 9: from 0xB0040120 up to 0xB004013F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 9],
                (uint32) &LMU_Array[REGION_SIZE * 10], Ifx_LMU_RGN_IDX_9);

    /* Define the Protection Range 10: from 0xB0040140 up to 0xB004015F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 10],
                (uint32) &LMU_Array[REGION_SIZE * 11], Ifx_LMU_RGN_IDX_10);

    /* Define the Protection Range 11: from 0xB0040160 up to 0xB004017F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 11],
                (uint32) &LMU_Array[REGION_SIZE * 12], Ifx_LMU_RGN_IDX_11);

    /* Define the Protection Range 12: from 0xB0040180 up to 0xB004019F */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 12],
                (uint32) &LMU_Array[REGION_SIZE * 13], Ifx_LMU_RGN_IDX_12);

    /* Define the Protection Range 13: from 0xB00401A0 up to 0xB00401BF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 13],
                (uint32) &LMU_Array[REGION_SIZE * 14], Ifx_LMU_RGN_IDX_13);

    /* Define the Protection Range 14: from 0xB00401C0 up to 0xB00401DF */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 14],
                (uint32) &LMU_Array[REGION_SIZE * 15], Ifx_LMU_RGN_IDX_14);

    /* Define the Protection Range 15: from 0xB00401E0 up to the end of LMU0 memory (0xB007FFFF) */
    define_LMU0_bus_protection_range((uint32) &LMU_Array[REGION_SIZE * 15],
                                  (uint32) 0xB007FFFF, Ifx_LMU_RGN_IDX_15);

    /* Enable read access of Core0 to Range 0 of LMU0 */
    enable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not read access of Core1 to Range 0 of LMU0 */
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not read access of Core0 to Range 1 of LMU0 ----*/
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not read access of Core1 to Range 1 of LMU0 ----*/
    disable_LMU0_read_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Enable write access of Core0 to Range 0 of LMU0 ----*/
    enable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not write access of Core1 to Range 0 of LMU0 ----*/
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_0, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Not write access of Core0 to Range 1 of LMU0 ----*/
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_CONFIG_TAG);

    /* Not write access of Core1 to Range 1 of LMU0 ----*/
    disable_LMU0_write_protection_range(Ifx_LMU_RGN_IDX_1, (Ifx_TagID) TEST_CORE_EXECUTE_TAG);

    /* Restore back the write-protection for registers */
    IfxScuWdt_setSafetyEndinit(safetyWdtPw);

    /* Waiting phase in order to not interfere with the pipelining process which is reported
     * as a problem in setting of the protection change. These are performed right after setting
     * the Safety ENDINIT that closes the change of the registers handling the regions definition.
     */
    waitTime(IfxStm_getTicksFromMilliseconds(BSP_DEFAULT_TIMER, WAIT_TIME));
}

/* Test 5 : TEST for Alarm triggering.
 * ALM7[15] raises when the CPU writes the area other than the write protection area.
 * (Configuration is the same as Test2):
 * Non-Overlap Regions (Region 0 and Region 1 are non-verlap): CPU0 -> R0, CPU0 !-> R1, CPU1 !-> R0, CPU1 !-> R1
 */
void Test5_execute(void)
{
    Test_Number = TEST_5;

    /* Fill the range 0 and rang 1 with the following write pattern */
    for (uint32 i = 0; i < REGION_SIZE * 2; i++)
    {
        /* Initialize data with incrementing values. It is useful for testing. */
        LMU_Array[i] = (uint8) (i + 5);
    }
}
