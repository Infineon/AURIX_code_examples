/**********************************************************************************************************************
 * \file GTM_ATOM_CLLC_Converter_PWM.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "GTM_ATOM_CLLC_Converter_PWM.h"
#include "Ifx_Types.h"
#include "IfxGtm_Pwm.h"
#include "IfxPort.h"
#include "IfxPort_Pinmap.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define NUM_OF_CHANNELS       (4u)                                    /* Number of PWM complementary pairs           */
#define PWM_FREQUENCY_MIN     (50.0e3)                                /* Lower Bound of PWM frequency in [Hz]        */
#define PWM_FREQUENCY_DEFAULT (100.0e3)                               /* Default PWM Frequency                       */
#define PWM_FREQUENCY_MAX     (250.0e3)                               /* Upper Bound of PWM frequency in [Hz]        */
#define DEAD_TIME             (200e-9f)                               /* Default Dead Time for High and Low Switches */
#define CTRL_LOOP_PRIORITY    (21u)                                   /* Interrupt Priority of the Control Loop      */

/* High-voltage side (Primary) */
#define HVHV_PRI_PWM_T1      &IfxGtm_ATOM0_0_TOUT0_P02_0_OUT          /* Pin which will be driven by the PWM, P02.0  */
#define HVHV_PRI_PWM_T2      &IfxGtm_ATOM0_0N_TOUT7_P02_7_OUT         /* Pin which will be driven by the PWM, P02.7  */
#define HVHV_PRI_PWM_T3      &IfxGtm_ATOM0_1_TOUT1_P02_1_OUT          /* Pin which will be driven by the PWM, P02.1  */
#define HVHV_PRI_PWM_T4      &IfxGtm_ATOM0_1N_TOUT4_P02_4_OUT         /* Pin which will be driven by the PWM, P02.4  */
/* Low-voltage side (Secondary) */
#define HVHV_SEC_PWM_T1      &IfxGtm_ATOM0_2_TOUT2_P02_2_OUT          /* Pin which will be driven by the PWM, P02.2  */
#define HVHV_SEC_PWM_T2      &IfxGtm_ATOM0_2N_TOUT5_P02_5_OUT         /* Pin which will be driven by the PWM, P02.5  */
#define HVHV_SEC_PWM_T3      &IfxGtm_ATOM0_3_TOUT3_P02_3_OUT          /* Pin which will be driven by the PWM, P02.3  */
#define HVHV_SEC_PWM_T4      &IfxGtm_ATOM0_3N_TOUT6_P02_6_OUT         /* Pin which will be driven by the PWM, P02.6  */

/*********************************************************************************************************************/
/*---------------------------------------------------Enumerations----------------------------------------------------*/
/*********************************************************************************************************************/

/* Runtime States */
typedef enum
{
    Paused = 0x0u,   /* Paused State     */
    Run    = 0x1u    /* Switching State  */
} RunTimeState;

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* Runtime Handle */
typedef struct
{
    IfxGtm_Pwm               pwm;                           /* PWM Driver handle                                     */
    IfxGtm_Pwm_Channel       channels[NUM_OF_CHANNELS];     /* Array containing channel data after configuration     */
    float32                  dutyCycles[NUM_OF_CHANNELS];   /* Duty Cycle values to hold                             */
    float32                  phases[NUM_OF_CHANNELS];       /* Phase Shift values to hold                            */
    IfxGtm_Pwm_DeadTime      deadTimes[NUM_OF_CHANNELS];    /* Dead Time values to hold                              */
    RunTimeState             rtState;                       /* Flag to pause runtime update                          */
    /* Inner displacement angle of the primary bridge (HB1, HB2) in radians */
    float32                  primaryDisplacementAngle;
    /* Outer displacement angle between the primary and the secondary bridges (HB1, HB3) in radians */
    float32                  secondaryDisplacementAngle;
    float32                  frequency;                     /* PWM switching frequency in Hz                         */
} GtmAtomCLLC;

IFX_STATIC GtmAtomCLLC g_gtmAtomCLLC;

/*********************************************************************************************************************/
/*-----------------------------------------------Function Prototypes-------------------------------------------------*/
/*********************************************************************************************************************/
static void dutyEventFunction(void *data);             /* Callback function for ATOM CHO for CCU1 Event              */
void updateGtmAtomCLLCPhaseAndFrequency(void);         /* Function to set the phase and frequency of the PWM signals */

/*********************************************************************************************************************/
/*--------------------------------------------Function Implementations-----------------------------------------------*/
/*********************************************************************************************************************/
/* Macro to define Control Loop Interrupt Service Routine */
IFX_INTERRUPT(controlLoopISR, 0, CTRL_LOOP_PRIORITY);

/* Interrupt Service Routine of ATOM CH0 */
void controlLoopISR(void)
{
    dutyEventFunction(NULL_PTR);
}

/* Callback function for the Event ATOM CH0 CC1 Event*/
void dutyEventFunction(void *data)
{
    updateGtmAtomCLLCPhaseAndFrequency();
}

/* Callback function for the Event ATOM CH0 CC0 Event*/
void periodEvent(void *data)
{

}

/* This function initializes the ATOM */
void initGtmAtomCLLC(void)
{
    IfxGtm_Pwm_Config config;                                 /* Main PWM configuration structure                   */
    IfxGtm_Pwm_ChannelConfig channelConfig[NUM_OF_CHANNELS];  /* Array containing configuration for PWM Channels    */
    IfxGtm_Pwm_DtmConfig dtmConfig[NUM_OF_CHANNELS];          /* Array Containing Dead Time Values for PWM Channels */
    IfxGtm_Pwm_OutputConfig output[NUM_OF_CHANNELS];          /* Array Containing configuration of Output Pins      */
    IfxGtm_Pwm_InterruptConfig interruptConfig;               /* Interrupt Configuration of Master Channel          */

    /* 1. Default values of control structure */
    g_gtmAtomCLLC.primaryDisplacementAngle   = 0.0f;
    g_gtmAtomCLLC.secondaryDisplacementAngle = 0.0f;
    g_gtmAtomCLLC.frequency = PWM_FREQUENCY_DEFAULT;

    /* Configuration of PWM variables
     * Neither application (in most of the cases) nor the PWM driver need configuration variables post initialization.
     * Hence it is recommended to define such variables within the function (STACK).
     * Alternatively such structures could also be initialized (element-wise) as constant (in ROM)
     */

    /* 2. Configuration structure initialization
     * If the configuration structure is located in the RAM, the initConfig API would be handy to initialize the
     * elements to their default values
     */
    IfxGtm_Pwm_initConfig(&config, &MODULE_GTM);

    /* 3. Output configuration */
    /* CH0 configurations */
    output[0].pin                   = (IfxGtm_Pwm_ToutMap*)HVHV_PRI_PWM_T1;     /* HVLV Primary PWM High-side (T1)   */
    output[0].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVHV_PRI_PWM_T2;     /* HVLV Primary PWM Low-side (T2)    */
    output[0].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[0].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[0].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[0].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH1 configurations */
    output[1].pin                   = (IfxGtm_Pwm_ToutMap*)HVHV_PRI_PWM_T3;     /* HVLV Primary PWM High-side (T3)   */
    output[1].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVHV_PRI_PWM_T4;     /* HVLV Primary PWM Low-side (T4)    */
    output[1].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[1].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[1].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[1].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH2 configurations */
    output[2].pin                   = (IfxGtm_Pwm_ToutMap*)HVHV_SEC_PWM_T1;     /* HVLV Secondary PWM High-side (T1) */
    output[2].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVHV_SEC_PWM_T2;     /* HVLV Secondary PWM Low-side (T2)  */
    output[2].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[2].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[2].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[2].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* CH3 configurations */
    output[3].pin                   = (IfxGtm_Pwm_ToutMap*)HVHV_SEC_PWM_T3;     /* HVLV Secondary PWM High-side (T3) */
    output[3].complementaryPin      = (IfxGtm_Pwm_ToutMap*)HVHV_SEC_PWM_T4;     /* HVLV Secondary PWM Low-side (T4)  */
    output[3].polarity              = Ifx_ActiveState_high;                     /* Polarity of High-Side             */
    output[3].complementaryPolarity = Ifx_ActiveState_low;                      /* Polarity of Low-Side              */
    output[3].outputMode            = IfxPort_OutputMode_pushPull;              /* Output mode                       */
    output[3].padDriver             = IfxPort_PadDriver_cmosAutomotiveSpeed1;   /* Pad driver                        */

    /* 4. Dead-time configuration */
    dtmConfig[0].deadTime.rising    = DEAD_TIME;              /* HVLV Primary Rising Dead time in seconds  (T1,T2)   */
    dtmConfig[0].deadTime.falling   = DEAD_TIME;              /* HVLV Primary Falling Dead time in seconds (T1,T2)   */

    dtmConfig[1].deadTime.rising    = DEAD_TIME;              /* HVLV Primary Rising Dead time in seconds  (T3,T4)   */
    dtmConfig[1].deadTime.falling   = DEAD_TIME;              /* HVLV Primary Falling Dead time in seconds (T3,T4)   */

    dtmConfig[2].deadTime.rising    = DEAD_TIME;              /* HVLV Secondary Rising Dead time in seconds (T1,T2)  */
    dtmConfig[2].deadTime.falling   = DEAD_TIME;              /* HVLV Secondary Falling Dead time in seconds (T1,T2) */

    dtmConfig[3].deadTime.rising    = DEAD_TIME;              /* HVLV Secondary Rising Dead time in seconds  (T3,T4) */
    dtmConfig[3].deadTime.falling   = DEAD_TIME;              /* HVLV Secondary Falling Dead time in seconds (T3,T4) */


    /* 5. Interrupt configuration */
    interruptConfig.mode          = IfxGtm_IrqMode_pulseNotify;    /* IRQ mode of interrupt                          */
    interruptConfig.isrProvider   = IfxSrc_Tos_cpu0;               /* Type of Service                                */
    interruptConfig.priority      = CTRL_LOOP_PRIORITY;            /* Interrupt priority                             */
    interruptConfig.periodEvent   = NULL_PTR;                      /* Callback function pointer for CC0 Event        */
    interruptConfig.dutyEvent     = &dutyEventFunction;            /* Callback function pointer for CC1 Event        */

    /* 6. Channel configuration */
    /* Base channel - CH0 configuration (HV_1) */
    channelConfig[0].timerCh      = IfxGtm_Pwm_SubModule_Ch_0; /* Atom channel index to be used for base channel     */
    channelConfig[0].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi);
                                                                * only for edge aligned sync channels)               */
    channelConfig[0].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[0].dtm          = &dtmConfig[0];             /* Attach Dead time configuration for this channel    */
    channelConfig[0].output       = &output[0];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[0].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[0].interrupt    = &interruptConfig;          /* Attach Interrupt configuration for this channel    */

    /* Sync channel CH1 configuration (HV_2) */
    channelConfig[1].timerCh      = IfxGtm_Pwm_SubModule_Ch_1; /* Atom channel index to be used for sync channel     */
    channelConfig[1].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi;
                                                                * only for edge aligned sync channels)               */
    channelConfig[1].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[1].dtm          = &dtmConfig[1];             /* Attach Dead time configuration for this channel    */
    channelConfig[1].output       = &output[1];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[1].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[1].interrupt    = NULL_PTR;                  /* Interrupt configuration for this channel           */

    /* Sync channel CH2 configuration (LV_1) */
    channelConfig[2].timerCh      = IfxGtm_Pwm_SubModule_Ch_2;/* Atom channel index to be used for sync channel     */
    channelConfig[2].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi;
     * only for edge aligned sync channels)               */
    channelConfig[2].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[2].dtm          = &dtmConfig[2];             /* Attach Dead time configuration for this channel    */
    channelConfig[2].output       = &output[2];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[2].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[2].interrupt    = NULL_PTR;                  /* Interrupt configuration for this channel           */

    /* Sync channel CH3 configuration (LV_2) */
    channelConfig[3].timerCh      = IfxGtm_Pwm_SubModule_Ch_3;/* Atom channel index to be used for sync channel     */
    channelConfig[3].phase        = 0.0f;                      /* Phase shift in radians (range: 0.0 .. 2pi;
     * only for edge aligned sync channels)               */
    channelConfig[3].duty         = 50.0f;                     /* PWM duty in % (range: 0.0 .. 100.0)                */
    channelConfig[3].dtm          = &dtmConfig[3];             /* Attach Dead time configuration for this channel    */
    channelConfig[3].output       = &output[3];                /* Attach Pin connections and polarities for this ch. */
    channelConfig[3].mscOut       = NULL_PTR;                  /* MSC configuration for this channel                 */
    channelConfig[3].interrupt    = NULL_PTR;                  /* Interrupt configuration for this channel           */

    /* 7. Overall configurations */
    config.cluster                = IfxGtm_Cluster_0;                  /* Cluster                                    */
    config.subModule              = IfxGtm_Pwm_SubModule_atom;         /* Sub module                                 */
    config.alignment              = IfxGtm_Pwm_Alignment_edge;         /* Alignment                                  */
    config.syncStart              = TRUE;                              /* Start all channels after init              */
    config.numChannels            = NUM_OF_CHANNELS;                   /* Number of channels configured              */
    config.channels               = &channelConfig[0];                 /* Attach Channel configuration               */
    config.frequency              = g_gtmAtomCLLC.frequency;           /* PWM frequency                              */
    config.clockSource.atom       = IfxGtm_Cmu_Clk_0;                  /* Clock source for ATOM                      */
    config.dtmClockSource         = IfxGtm_Dtm_ClockSource_cmuClock0;  /* Clock source for DTM                       */
    config.syncUpdateEnabled      = TRUE;                              /* TRUE: Update compare registers from shadow
                                                                        * at the end of period                       */

    /* 8.  Enable GTM and CMU */
    if(!IfxGtm_isEnabled(&MODULE_GTM))
    {
        float32 frequency;
        /* Enable GTM, it is necessary if the GTM is not initialized earlier */
        IfxGtm_enable(&MODULE_GTM);
        frequency = IfxGtm_Cmu_getModuleFrequency(&MODULE_GTM);
        /* Set the global clock frequency to the max */
        IfxGtm_Cmu_setGclkFrequency(&MODULE_GTM, frequency);
        /* Set the CMU CLK0 */
        IfxGtm_Cmu_setClkFrequency(&MODULE_GTM, IfxGtm_Cmu_Clk_0, frequency);
        /* Enable the CMU clock */
        IfxGtm_Cmu_enableClocks(&MODULE_GTM, IFXGTM_CMU_CLKEN_CLK0);
    }

    /* 9. Call the init function */
    IfxGtm_Pwm_init(&g_gtmAtomCLLC.pwm, &g_gtmAtomCLLC.channels[0], &config);

    /* 10. Store the current duty values, dead times and phases for runtime calls */
    g_gtmAtomCLLC.dutyCycles[0] = channelConfig[0].duty;
    g_gtmAtomCLLC.dutyCycles[1] = channelConfig[1].duty;
    g_gtmAtomCLLC.dutyCycles[2] = channelConfig[2].duty;
    g_gtmAtomCLLC.dutyCycles[3] = channelConfig[3].duty;
    g_gtmAtomCLLC.deadTimes[0] = channelConfig[0].dtm->deadTime;
    g_gtmAtomCLLC.deadTimes[1] = channelConfig[1].dtm->deadTime;
    g_gtmAtomCLLC.deadTimes[2] = channelConfig[2].dtm->deadTime;
    g_gtmAtomCLLC.deadTimes[3] = channelConfig[3].dtm->deadTime;
    g_gtmAtomCLLC.phases[0] = channelConfig[0].phase;
    g_gtmAtomCLLC.phases[1] = channelConfig[1].phase;
    g_gtmAtomCLLC.phases[2] = channelConfig[2].phase;
    g_gtmAtomCLLC.phases[3] = channelConfig[3].phase;

    g_gtmAtomCLLC.rtState = Paused;
}

/* Function to set the phase and frequency of the PWM signals */
void updateGtmAtomCLLCPhaseAndFrequency(void)
{
    if(g_gtmAtomCLLC.rtState == Run)
    {
        /* Check the validity of displacement ratios */
        if(g_gtmAtomCLLC.primaryDisplacementAngle < 0.0f)
        {
            g_gtmAtomCLLC.primaryDisplacementAngle = 0.0f;
        }

        if(g_gtmAtomCLLC.primaryDisplacementAngle > IFX_PI)
        {
            g_gtmAtomCLLC.primaryDisplacementAngle = IFX_PI;
        }

        if(g_gtmAtomCLLC.secondaryDisplacementAngle < 0.0f)
        {
            g_gtmAtomCLLC.secondaryDisplacementAngle = 0.0f;
        }

        if(g_gtmAtomCLLC.secondaryDisplacementAngle > IFX_PI)
        {
            g_gtmAtomCLLC.secondaryDisplacementAngle = IFX_PI;
        }

        /* Check the validity of the resonant frequency */
        if(g_gtmAtomCLLC.frequency < PWM_FREQUENCY_MIN)
        {
            g_gtmAtomCLLC.frequency = PWM_FREQUENCY_MIN;
        }

        if(g_gtmAtomCLLC.frequency > PWM_FREQUENCY_MAX)
        {
            g_gtmAtomCLLC.frequency = PWM_FREQUENCY_MAX;
        }

        /* Calculate shift phases */
        /* Phase of HVLV_PRI_PWM_T1, HVLV_PRI_PWM_T2 */
        g_gtmAtomCLLC.phases[0] = 0.0f;
        /* Phase of HVLV_PRI_PWM_T3, HVLV_PRI_PWM_T4 */
        g_gtmAtomCLLC.phases[1] = g_gtmAtomCLLC.primaryDisplacementAngle + IFX_PI;
        /* Phase of HVLV_SEC_PWM_T1, HVLV_SEC_PWM_T2 */
        g_gtmAtomCLLC.phases[2] = g_gtmAtomCLLC.secondaryDisplacementAngle;
        /* Phase of HVLV_SEC_PWM_T3, HVLV_SEC_PWM_T4 */
        g_gtmAtomCLLC.phases[3] = g_gtmAtomCLLC.secondaryDisplacementAngle + IFX_PI;

        /* Update the iLLD Framework regarding frequency and phase shift */
        IfxGtm_Pwm_updateChannelsPhase(&g_gtmAtomCLLC.pwm, (float32*)&g_gtmAtomCLLC.phases[0]);
        IfxGtm_Pwm_updateFrequency(&g_gtmAtomCLLC.pwm, g_gtmAtomCLLC.frequency);
    }
}
