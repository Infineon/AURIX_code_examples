/**
 * \file IfxPcieCap.h
 * \brief PCIE  basic functionality
 * \ingroup IfxLld_Pcie
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Pcie_Std_Cap Cap Basic Functionality
 * \ingroup IfxLld_Pcie_Std
 * \defgroup IfxLld_Pcie_Std_Cap_Enumerations Enumerations
 * \ingroup IfxLld_Pcie_Std_Cap
 * \defgroup IfxLld_Pcie_Std_Cap_Structures Structures
 * \ingroup IfxLld_Pcie_Std_Cap
 * \defgroup IfxLld_Pcie_Std_Cap_Functions Functions
 * \ingroup IfxLld_Pcie_Std_Cap
 */

#ifndef IFXPCIECAP_H
#define IFXPCIECAP_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxPcie_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief PCI Capability list offset for Bridges, EP and RC
 */
#define IFXPCIECAP_PCI_CAPABILITY_LIST_OFFSET                 (0x34)

/** \brief PCI Capability list offset for cardbus
 */
#define IFXPCIECAP_PCI_CAPABILITY_CB_LIST_OFFSET              (0x14)

/** \brief Capability ID
 */
#define IFXPCIECAP_PCI_CAP_LIST_ID                            (0)

/** \brief Power Management
 */
#define IFXPCIECAP_PCI_CAP_ID_PM                              (0x01)

/** \brief Message Signalled Interrupts
 */
#define IFXPCIECAP_PCI_CAP_ID_MSI                             (0x05)

/** \brief PCI-X
 */
#define IFXPCIECAP_PCI_CAP_ID_PCIE                            (0x10)

/** \brief Message Signalled Interrupts
 */
#define IFXPCIECAP_PCI_CAP_ID_MSIX                            (0x11)

/** \brief Device control status offset in PCIe capability register
 */
#define IFXPCIECAP_PCI_EXPRESS_DEV_CONTROL_STATUS_OFFSET      (0x08)

/** \brief PCIE capability root capability offset for RC
 */
#define IFXPCIECAP_PCI_EXPRESS_ROOT_CONTROL_CAPABILITY_OFFSET (0x1c)

/** \brief PCI Power management capability ID
 */
#define IFXPCIECAP_PCI_CAP_ID_PM                              (0x01)

/** \brief AER Extended Capability ID
 */
#define IFXPCIECAP_EXTENDED_CAP_ID_AER                        (0x0001u)

/** \brief LTR Extended Capability ID
 */
#define IFXPCIECAP_EXTENDED_CAP_ID_LTR                        (0x0018u)

/** \brief VSEC Extended Capability ID
 */
#define IFXPCIECAP_EXTENDED_CAP_ID_VSEC                       (0x000Bu)

/** \brief SN Extended Capability ID
 */
#define IFXPCIECAP_EXTENDED_CAP_ID_SN                         (0x0003u)

/** \brief SPCIE Extended Capability ID
 */
#define IFXPCIECAP_EXTENDED_CAP_ID_SPCIE                      (0x0019u)

/** \brief PTM Extended Capability ID
 */
#define IFXPCIECAP_EXTENDED_CAP_ID_PTM                        (0x001Fu)

/** \brief PCI Extended capability Advanced Error Reporting Capability ID
 */
#define IFXPCIECAP_PCI_EXT_CAP_ID_ERR                         (0x01)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Std_Cap_Enumerations
 * \{ */
/** \brief List of AER capabilities
 */
typedef enum
{
    IfxPcieCap_AerCapabilities_none = -1,  /**< \brief None */
    IfxPcieCap_AerCapabilities_ecrcGen,    /**< \brief ECRC Gen */
    IfxPcieCap_AerCapabilities_ecrcCheck,  /**< \brief ECRC check */
    IfxPcieCap_AerCapabilities_mulHdrRec,  /**< \brief Multiple Header Recording */
    IfxPcieCap_AerCapabilities_count       /**< \brief None */
} IfxPcieCap_AerCapabilities;

/** \brief Types of errors in AER
 */
typedef enum
{
    IfxPcieCap_AerErrorType_uncorrectable,  /**< \brief Uncorrectable Errors */
    IfxPcieCap_AerErrorType_correctable     /**< \brief Correctable Errors */
} IfxPcieCap_AerErrorType;

/** \brief LTR latency Scale
 */
typedef enum
{
    IfxPcieCap_LtrLatencyScale_1ns,        /**< \brief 1NS scale */
    IfxPcieCap_LtrLatencyScale_32ns,       /**< \brief 32NS scale */
    IfxPcieCap_LtrLatencyScale_1024ns,     /**< \brief 1024NS scale */
    IfxPcieCap_LtrLatencyScale_32768ns,    /**< \brief 32768NS scale */
    IfxPcieCap_LtrLatencyScale_1048576ns,  /**< \brief 1048576NS scale */
    IfxPcieCap_LtrLatencyScale_33554432ns  /**< \brief 33554432NS scale */
} IfxPcieCap_LtrLatencyScale;

/** \brief LTR latency type
 */
typedef enum
{
    IfxPcieCap_LtrLatencyType_snoop,   /**< \brief Snoop Latency */
    IfxPcieCap_LtrLatencyType_noSnoop  /**< \brief No Snoop Latency */
} IfxPcieCap_LtrLatencyType;

/** \brief OBFF Capability
 */
typedef enum
{
    IfxPcieCap_ObffCapability_None,  /**< \brief OBFF not supported */
    IfxPcieCap_ObffCapability_Msg,   /**< \brief OBFF using Message */
    IfxPcieCap_ObffCapability_Wake,  /**< \brief OBFF using WAKE signalling */
    IfxPcieCap_ObffCapability_Both   /**< \brief OBFF using WAKE signalling and MessGE */
} IfxPcieCap_ObffCapability;

/** \brief OBFF Type
 */
typedef enum
{
    IfxPcieCap_ObffType_None,     /**< \brief Disable OBFF */
    IfxPcieCap_ObffType_MsgVarA,  /**< \brief OBFF Message Variation A */
    IfxPcieCap_ObffType_MsgVarB,  /**< \brief OBFF Message Variation B */
    IfxPcieCap_ObffType_Wake      /**< \brief OBFF using WAKE signalling */
} IfxPcieCap_ObffType;

/** \brief ASPM Link state
 */
typedef enum
{
    IfxPcieCap_PcieAspmLevel_Disabled,     /**< \brief ASPM Link level disabled */
    IfxPcieCap_PcieAspmLevel_l0sEntryEn,   /**< \brief enables the Transmitter to enter L0s. If L0s is supported, the Receiver must be capable of entering L0s even when the Transmitter is disabled from entering L0s (00b or 10b). */
    IfxPcieCap_PcieAspmLevel_l1EntryEn,    /**< \brief L1 state entry enable */
    IfxPcieCap_PcieAspmLevel_l0sL1EntryEn  /**< \brief L0s and L1 Entry enable */
} IfxPcieCap_PcieAspmLevel;

/** \brief Enumeration containing the power states
 */
typedef enum
{
    IfxPcieCap_PmPwrState_none = -1,  /**< \brief Unknown State */
    IfxPcieCap_PmPwrState_d0,         /**< \brief D0 State */
    IfxPcieCap_PmPwrState_d1,         /**< \brief D1 State */
    IfxPcieCap_PmPwrState_d2,         /**< \brief D2 State */
    IfxPcieCap_PmPwrState_d3Hot,      /**< \brief D3 State */
    IfxPcieCap_PmPwrState_d3Cold      /**< \brief D3 State */
} IfxPcieCap_PmPwrState;

/** \brief RAS DES CRC Error Injection Type
 */
typedef enum
{
    IfxPcieCap_RasDesCrcErrorType_none = -1,      /**< \brief No Error */
    IfxPcieCap_RasDesCrcErrorType_txLcrc,         /**< \brief LCRC Error */
    IfxPcieCap_RasDesCrcErrorType_txAckNakDllp,   /**< \brief 16 Bit CRC Error Injection of ACK/NAK DLLP */
    IfxPcieCap_RasDesCrcErrorType_txFcDllp,       /**< \brief 16 Bit CRC Error Injection of Update FC DLLP */
    IfxPcieCap_RasDesCrcErrorType_txEcrc,         /**< \brief ECRC Error */
    IfxPcieCap_RasDesCrcErrorType_txFcrc,         /**< \brief FCRC Error 128/130B */
    IfxPcieCap_RasDesCrcErrorType_txParityTsos,   /**< \brief Parity Error for TSOS */
    IfxPcieCap_RasDesCrcErrorType_txParityskPos,  /**< \brief Parity Error for SKPOS */
    IfxPcieCap_RasDesCrcErrorType_rxLcrc = 8,     /**< \brief LCRC Error for Rx */
    IfxPcieCap_RasDesCrcErrorType_rxEcrc = 11     /**< \brief ECRC Error for Rx */
} IfxPcieCap_RasDesCrcErrorType;

/** \brief RAS DES DLLP Error Type
 */
typedef enum
{
    IfxPcieCap_RasDesDllpErrorType_none = -1,     /**< \brief No Error */
    IfxPcieCap_RasDesDllpErrorType_ackNakDllp,    /**< \brief ACK/NAK DLLP Transmission */
    IfxPcieCap_RasDesDllpErrorType_fcDllp,        /**< \brief Update FC DLLP Transmission */
    IfxPcieCap_RasDesDllpErrorType_alwaysNakDllp  /**< \brief Update NAK DLLP Transmission */
} IfxPcieCap_RasDesDllpErrorType;

/** \brief RAS DES Error Injection Type
 */
typedef enum
{
    IfxPcieCap_RasDesErrorType_none = -1,   /**< \brief No Error */
    IfxPcieCap_RasDesErrorType_crc,         /**< \brief CRC Error */
    IfxPcieCap_RasDesErrorType_seqNum,      /**< \brief Seq Number Error */
    IfxPcieCap_RasDesErrorType_dllp,        /**< \brief DLLP Error */
    IfxPcieCap_RasDesErrorType_symbol,      /**< \brief Symbol Error */
    IfxPcieCap_RasDesErrorType_fcCredit,    /**< \brief FC Credit Error */
    IfxPcieCap_RasDesErrorType_tlpInsert,   /**< \brief TLP Insertion Error */
    IfxPcieCap_RasDesErrorType_tlpSpecific  /**< \brief Specific TLP Error */
} IfxPcieCap_RasDesErrorType;

/** \brief RAS DES Update FC for FC Error Injection
 */
typedef enum
{
    IfxPcieCap_RasDesFcType_none = -1,          /**< \brief No Error */
    IfxPcieCap_RasDesFcType_postedTlpHdr,       /**< \brief Posted TLP Header Credit Val Control */
    IfxPcieCap_RasDesFcType_nonPostedTlpHdr,    /**< \brief Non Posted TLP Header Credit Val Control */
    IfxPcieCap_RasDesFcType_cmplTlpHdr,         /**< \brief Completion TLP Header Credit Val Control */
    IfxPcieCap_RasDesFcType_postedTlpData = 4,  /**< \brief Posted TLP Data Credit Val Control */
    IfxPcieCap_RasDesFcType_nonPostedTlpData,   /**< \brief Non Posted TLP Data Credit Val Control */
    IfxPcieCap_RasDesFcType_cmplTlpData         /**< \brief Completion TLP Data Credit Val Control */
} IfxPcieCap_RasDesFcType;

/** \brief RAS DES Sequence Number Error Injection Type
 */
typedef enum
{
    IfxPcieCap_RasDesSeqErrorType_none = -1,  /**< \brief No Error */
    IfxPcieCap_RasDesSeqErrorType_tlp,        /**< \brief TLP Insertion */
    IfxPcieCap_RasDesSeqErrorType_ackNakDllp  /**< \brief ACK/NAK DLLP Insertion */
} IfxPcieCap_RasDesSeqErrorType;

/** \brief RAS DES Sym Error Type
 */
typedef enum
{
    IfxPcieCap_RasDesSymErrorType_none = -1,      /**< \brief No Error */
    IfxPcieCap_RasDesSymErrorType_128b130Invert,  /**< \brief Change Sync Header for 128/130B encoding */
    IfxPcieCap_RasDesSymErrorType_comPadTs1,      /**< \brief COM/PAD TS1 Order Set */
    IfxPcieCap_RasDesSymErrorType_comPadTs2,      /**< \brief COM/PAD TS2 Order Set */
    IfxPcieCap_RasDesSymErrorType_comFts,         /**< \brief COM/FTS Order Set */
    IfxPcieCap_RasDesSymErrorType_comIdl,         /**< \brief E-Idle Order Set */
    IfxPcieCap_RasDesSymErrorType_endEdb,         /**< \brief END/EDB Symbol */
    IfxPcieCap_RasDesSymErrorType_stpSdp,         /**< \brief STP/SDB Symbol */
    IfxPcieCap_RasDesSymErrorType_comSkp          /**< \brief SKP Order Set */
} IfxPcieCap_RasDesSymErrorType;

/** \brief RAS DES TLP type for TLP Insertion Error
 */
typedef enum
{
    IfxPcieCap_RasDesTlpInsertType_none = -1,      /**< \brief No Error */
    IfxPcieCap_RasDesTlpInsertType_duplicateDllp,  /**< \brief Duplicate DLLP */
    IfxPcieCap_RasDesTlpInsertType_nullifiedTlp    /**< \brief Nullified TLP */
} IfxPcieCap_RasDesTlpInsertType;

/** \brief RASDP Error Injection Type
 */
typedef enum
{
    IfxPcieCap_RasDpErrorType_none,  /**< \brief No Error */
    IfxPcieCap_RasDpErrorType_1Bit,  /**< \brief 1 Bit Error */
    IfxPcieCap_RasDpErrorType_2Bit   /**< \brief 2 Bit Error */
} IfxPcieCap_RasDpErrorType;

/** \brief List of capability Ids
 */
typedef enum
{
    IfxPcieCap_pcieCapId_pciCapId = 0,    /**< \brief Pci cap Ids */
    IfxPcieCap_pcieCapId_pmc      = 0x01, /**< \brief Power management capability Id */
    IfxPcieCap_pcieCapId_agp      = 0x02, /**< \brief AGP capability */
    IfxPcieCap_pcieCapId_vpd      = 0x03, /**< \brief Virtual Product data offset */
    IfxPcieCap_pcieCapId_slotId   = 0x04, /**< \brief slot Id capability */
    IfxPcieCap_pcieCapId_msi      = 0x05, /**< \brief MSI capability */
    IfxPcieCap_pcieCapId_cshwp    = 0x06, /**< \brief Compact PCI Hot swap */
    IfxPcieCap_pcieCapId_pcix     = 0x07, /**< \brief PCIX capability */
    IfxPcieCap_pcieCapId_ht       = 0x08, /**< \brief HyperTransport Capability */
    IfxPcieCap_pcieCapId_vendor   = 0x09, /**< \brief Vendor specific capability */
    IfxPcieCap_pcieCapId_dbg      = 0x0a, /**< \brief Debug port capabilty */
    IfxPcieCap_pcieCapId_ccrc     = 0x0b, /**< \brief Compact PCI Central Resource control */
    IfxPcieCap_pcieCapId_shpc     = 0x0c, /**< \brief PCI standard Hot plug controller capability */
    IfxPcieCap_pcieCapId_ssvId    = 0x0d, /**< \brief Bridge subsystem vendor/device ID capability */
    IfxPcieCap_pcieCapId_agp3     = 0x0e, /**< \brief AGP Target PCI-PCI bridge */
    IfxPcieCap_pcieCapId_secDev   = 0x0f, /**< \brief Secure device */
    IfxPcieCap_pcieCapId_pciex    = 0x10, /**< \brief PCI Express capability */
    IfxPcieCap_pcieCapId_msix     = 0x11, /**< \brief MSI-x capability */
    IfxPcieCap_pcieCapId_sata     = 0x12, /**< \brief SATA data configuration */
    IfxPcieCap_pcieCapId_af       = 0x13  /**< \brief PCIe advance features */
} IfxPcieCap_pcieCapId;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Std_Cap_Structures
 * \{ */
/** \brief PCIE AER Capability Control Bits
 */
typedef struct
{
    uint32 firstErrorPointer : 5;             /**< \brief 0:4 First Error Pointer */
    uint32 eCRCGenCapable : 1;                /**< \brief 5:5 ECRC Generation Capable */
    uint32 eCRCGenEnable : 1;                 /**< \brief 6:6 ECRC Generation Enable */
    uint32 eCRCCheckCapable : 1;              /**< \brief 7:7 ECRC Check Capable */
    uint32 eCRCCheckEnable : 1;               /**< \brief 8:8 ECRC Check Enable */
    uint32 multipleHeaderRecCapable : 1;      /**< \brief 9:9 Multiple Header Recording Capable */
    uint32 multipleHeaderRecEnable : 1;       /**< \brief 10:10 Multiple Header Recording Enable */
    uint32 tlpPrefixLogPresent : 1;           /**< \brief 11:11 TLP Prefix Log Present */
    uint32 completionTimeoutPrefix : 1;       /**< \brief 12:12 Completion Timeout Prefix/Header Log Capable */
    uint32 reserved_13 : 18;                  /**< \brief 13:31 Reserved */
} IfxPcieCap_AerCapCtrlBits;

/** \brief PCIE AER Capability Correctable Error Bits
 */
typedef struct
{
    uint32 receiverError : 1;             /**< \brief 0:0 Receiver Error Status */
    uint32 rsvdZ_1 : 5;                   /**< \brief 1:5 RsvdZ */
    uint32 badTLP : 1;                    /**< \brief 6:6 Bad TLP Status */
    uint32 badDLLP : 1;                   /**< \brief 7:7 Bad DLLP Status */
    uint32 replayNumRollover : 1;         /**< \brief 8:8 REPLAY_NUM Rollover Status */
    uint32 rsvdZ_9 : 3;                   /**< \brief 9:11 RsvdZ */
    uint32 replayTimerTimeout : 1;        /**< \brief 12:12 Replay Timer Timeout Status */
    uint32 advisoryNonFatalErr : 1;       /**< \brief 13:13 Advisory Non-Fatal Error Status */
    uint32 correctedInternalErr : 1;      /**< \brief 14:14 Corrected Internal Error Status */
    uint32 headerLogOverflow : 1;         /**< \brief 15:15 Header Log Overflow Status */
    uint32 rsvd16 : 16;                   /**< \brief 16:31 RsvdZ */
} IfxPcieCap_CorrErrorBits;

/** \brief Device Capabilities 2 Bits
 */
typedef struct
{
    uint32 cmplToRange : 4;         /**< \brief Completion Timeout Ranges supported */
    uint32 cmplToDisable : 1;       /**< \brief Completion Timeout Disable supported */
    uint32 ariFwd : 1;              /**< \brief ARI Forwarding supported */
    uint32 atomOpRout : 1;          /**< \brief Atomic Op Routing supported */
    uint32 atomOpCmpl32 : 1;        /**< \brief Atomic Op 32 Bit Completion */
    uint32 atomOpCmpl64 : 1;        /**< \brief Atomic Op 64 Bit Completion */
    uint32 casCmpl128 : 1;          /**< \brief 128 Bit Bit CAS completer supported */
    uint32 roPrDisable : 1;         /**< \brief No RO enabled PR-PR Passing */
    uint32 ltr : 1;                 /**< \brief LTR Mechanism supported */
    uint32 tphCmpl : 2;             /**< \brief TPH Completer supported */
    uint32 lnSysCls : 2;            /**< \brief LN System CLS */
    uint32 tagCmpl10 : 1;           /**< \brief 10 Bit Tag Completer supported */
    uint32 tagReq10 : 1;            /**< \brief 10 Bit Tag Requester supported */
    uint32 obff : 2;                /**< \brief OBFF supported */
    uint32 extendedFmt : 1;         /**< \brief Extended FMT field supported */
    uint32 endTlpPrefix : 1;        /**< \brief End-End TLP Prefix supported */
    uint32 maxEndTlpPrefix : 2;     /**< \brief Max End-End TLP Prefix */
    uint32 emrPwrRed : 2;           /**< \brief Emergency Power Reduction */
    uint32 emrPwrInit : 1;          /**< \brief Emergency Power Reduction Init Req */
    uint32 reserved_27 : 4;         /**< \brief reserved */
    uint32 frs : 1;                 /**< \brief FRS supported */
} IfxPcieCap_DeviceCap2_Bits;

/** \brief Device Capabilities Bits
 */
typedef struct
{
    uint32 payloadSize : 3;           /**< \brief max payload size */
    uint32 phantomFunc : 2;           /**< \brief phantom functions */
    uint32 extendedTag : 1;           /**< \brief extended tag supported */
    uint32 l0Latency : 3;             /**< \brief EndPoint L0 acceptable latency */
    uint32 l1Latency : 3;             /**< \brief EndPoint L1 acceptable latency */
    uint32 reserved_12 : 3;           /**< \brief undefined */
    uint32 roleErrorRpt : 1;          /**< \brief Role based error Reporting */
    uint32 errCorrCap : 1;            /**< \brief ERR_CORR subclass capable */
    uint32 reserved_17 : 1;           /**< \brief reserved */
    uint32 slotPwrLimit : 8;          /**< \brief Slot Power Limit Value */
    uint32 slotPwrLimitScale : 2;     /**< \brief Slot Power Limit Scale */
    uint32 funcResetCap : 1;          /**< \brief Function Level Reset Capable */
    uint32 reserved_29 : 3;           /**< \brief Reserved */
} IfxPcieCap_DeviceCap_Bits;

/** \brief Device Control 2 Bits
 */
typedef struct
{
    uint16 cmplToVal : 4;         /**< \brief Completion Timeout Value */
    uint16 cmplToDisable : 1;     /**< \brief Completion Timeout Disable */
    uint16 ariFwd : 1;            /**< \brief ARI Forwarding Enable */
    uint16 atomOpReq : 1;         /**< \brief Atomic Operation Requester Enable */
    uint16 atomOpEgrBlk : 1;      /**< \brief Atomic Operation Egress Blocking */
    uint16 idoReq : 1;            /**< \brief IDO Requester Enable */
    uint16 idoCmpl : 1;           /**< \brief IDO Completion Enable */
    uint16 ltr : 1;               /**< \brief LTR Mechanism Enable */
    uint16 emrPwrRed : 1;         /**< \brief Emergency Power Reduction Request */
    uint16 tagReq10 : 1;          /**< \brief 10 Bit Tag Requester Enable */
    uint16 obff : 2;              /**< \brief OBFF Enable */
    uint16 endTlpPrefix : 1;      /**< \brief End-End TLP Prefix Blocking */
} IfxPcieCap_DeviceCtrl2_Bits;

/** \brief Device Control Bits
 */
typedef struct
{
    uint16 corrError : 1;           /**< \brief Report Correctable Errors */
    uint16 nonFatalError : 1;       /**< \brief Report Non Fatal Errors */
    uint16 fatalError : 1;          /**< \brief Report Fatal Errors */
    uint16 unsupportedReq : 1;      /**< \brief Report unsupported Request */
    uint16 relaxedOrdering : 1;     /**< \brief Enable Relaxed ordering */
    uint16 payloadSize : 3;         /**< \brief Max Payload Size */
    uint16 extendedTag : 1;         /**< \brief Extended Tag Field Enable */
    uint16 phantomFunc : 1;         /**< \brief Phantom Functions Enable */
    uint16 auxPwrPm : 1;            /**< \brief AUX Power PM Enable */
    uint16 noSnoop : 1;             /**< \brief No Snoop Enable */
    uint16 readReqSize : 3;         /**< \brief Max Read Request Size */
    uint16 resetRetry : 1;          /**< \brief Enable Retry / function Level Reset */
} IfxPcieCap_DeviceCtrl_Bits;

/** \brief Devce Status Bits
 */
typedef struct
{
    uint16 corrError : 1;          /**< \brief Correctable Error Detected */
    uint16 nonFatalError : 1;      /**< \brief Non Fatal Error Detected */
    uint16 fatalError : 1;         /**< \brief Fatal Error Detected */
    uint16 unsupportedReq : 1;     /**< \brief Unsupported Request Detected */
    uint16 auxPower : 1;           /**< \brief AUX Power Detected */
    uint16 txPending : 1;          /**< \brief Transactions Pending */
    uint16 pwrReduction : 1;       /**< \brief Emergency Power Reduction Detected */
    uint16 reserved_7 : 9;         /**< \brief reserved */
} IfxPcieCap_DeviceStatus_Bits;

/** \brief PCIE AER Error Source ID Bits
 */
typedef struct
{
    uint32 errCorr : 16;            /**< \brief 0:15 ERR_COR Source ID */
    uint32 fatalNonFatal : 16;      /**< \brief 16:31; FATAL/NONFATAL source ID */
} IfxPcieCap_ErrorSourceIdBits;

/** \brief PCIE Extended Capability Header Bits
 */
typedef struct
{
    uint32 capId : 16;          /**< \brief Capability ID */
    uint32 capVersion : 4;      /**< \brief Capability Versions */
    uint32 capOffset : 12;      /**< \brief Next capability Offset */
} IfxPcieCap_ExtendedCapHeaderBits;

/** \brief Link Capabilities 2 Bits
 */
typedef struct
{
    uint32 reserved_0 : 1;      /**< \brief reserved */
    uint32 linkSpeeds : 7;      /**< \brief Link Speeds supported */
    uint32 crossLink : 1;       /**< \brief Cross Link supported */
    uint32 reserved_9 : 22;     /**< \brief reserved */
    uint32 drs : 1;             /**< \brief DRS Supported */
} IfxPcieCap_LinkCap2_Bits;

/** \brief Link Capabilities Bits
 */
typedef struct
{
    uint32 maxLinkSpeed : 4;        /**< \brief Max Link Speed */
    uint32 maxLinkWidth : 6;        /**< \brief Max Link Width */
    uint32 aspmSupport : 2;         /**< \brief ASPM Support */
    uint32 l0ExitLatency : 3;       /**< \brief L0 state exit latency */
    uint32 l1ExitLatency : 3;       /**< \brief L1 state exit latency */
    uint32 clockPm : 1;             /**< \brief Clock Power Management */
    uint32 sDownError : 1;          /**< \brief Surprise Down Error Reporting */
    uint32 dataLinkActive : 1;      /**< \brief Data Link Layer active Reporting */
    uint32 linkBwNotifyCap : 1;     /**< \brief Link Bandwidth Notification capability */
    uint32 aspmCompliance : 1;      /**< \brief ASPM Optionality compliance */
    uint32 reserved_23 : 1;         /**< \brief reserved */
    uint32 port : 8;                /**< \brief Port number */
} IfxPcieCap_LinkCap_Bits;

/** \brief Link Control 2 Bits
 */
typedef struct
{
    uint16 tarLinkSpeed : 4;        /**< \brief Target Link Speed */
    uint16 enterCompl : 1;          /**< \brief Enter compliance */
    uint16 hwAutoSpDisable : 1;     /**< \brief HW Autonomous Speed Disable */
    uint16 selDem : 1;              /**< \brief Selectable De-emphasis */
    uint16 txMargin : 3;            /**< \brief Transmit margin */
    uint16 enterModCompl : 1;       /**< \brief Enter Modified compliance */
    uint16 complSos : 1;            /**< \brief Compliance SOS */
    uint16 complPreset : 4;         /**< \brief Compliance Preset */
} IfxPcieCap_LinkCtrl2_Bits;

/** \brief Link Control Bits
 */
typedef struct
{
    uint16 aspmCtrl : 2;                /**< \brief ASPM Control */
    uint16 reserved_2 : 1;              /**< \brief reserved */
    uint16 readCmplBd : 1;              /**< \brief Read Completion boundary */
    uint16 linkDisable : 1;             /**< \brief Link Disable */
    uint16 retrainLink : 1;             /**< \brief Retain Link */
    uint16 commonClkConfig : 1;         /**< \brief Common Clock Configuration */
    uint16 extendedSync : 1;            /**< \brief Extended Sync */
    uint16 clockPm : 1;                 /**< \brief Clock Power Management */
    uint16 hwAutoWidthDisable : 1;      /**< \brief HW Autonomous Width Disable */
    uint16 linkBwManInterrupt : 1;      /**< \brief Link Bandwidth Management Interrupt Enable */
    uint16 linkBwAutoInterrupt : 1;     /**< \brief Link Bandwidth Autonomous Interrupt Enable */
    uint16 reserved_12 : 2;             /**< \brief reserved */
    uint16 drsSignalCtrl : 2;           /**< \brief DRS Signal Control */
} IfxPcieCap_LinkCtrl_Bits;

/** \brief Link Status 2 Bits
 */
typedef struct
{
    uint16 demLevel : 1;       /**< \brief De-emphasis Level */
    uint16 eq8gtscmpl : 1;     /**< \brief Equalization 8GT/s complete */
    uint16 eq8gtsp1 : 1;       /**< \brief Equalization 8 GT/s phase 1 */
    uint16 eq8gtsp2 : 1;       /**< \brief Equalization 8 GT/s phase 2 */
    uint16 eq8gtsp3 : 1;       /**< \brief Equalization 8 GT/s phase 3 */
    uint16 linkEqReq : 1;      /**< \brief Link Equalization Request 8GT/s */
    uint16 reserved_6 : 6;     /**< \brief reserved */
    uint16 dspComp : 3;        /**< \brief Downstream Component Presence */
    uint16 drs : 1;            /**< \brief DRS message received */
} IfxPcieCap_LinkStatus2_Bits;

/** \brief Link Status Bits
 */
typedef struct
{
    uint16 linkSpeed : 4;            /**< \brief Current Link Speed */
    uint16 linkWidth : 6;            /**< \brief Negotiated Link Width */
    uint16 reserved_10 : 1;          /**< \brief reserved */
    uint16 linkTraining : 1;         /**< \brief Link Training */
    uint16 slotClockCfg : 1;         /**< \brief Slot Clock Configuration */
    uint16 dataLinkActive : 1;       /**< \brief Data Link Layer active */
    uint16 linkBwManStatus : 1;      /**< \brief Link Bandwidth Management Status */
    uint16 linkBwAutoStatus : 1;     /**< \brief Link Bandwidth Autonomous Status */
} IfxPcieCap_LinkStatus_Bits;

/** \brief MSI Message Control Bits
 */
typedef struct
{
    uint16 msiEnable : 1;              /**< \brief MSI enable */
    uint16 multiMsgCapable : 3;        /**< \brief Multiple Message Capable */
    uint16 multiMsgEnable : 3;         /**< \brief Multiple Message Enable */
    uint16 cap64Bit : 1;               /**< \brief 64 bit capable */
    uint16 vectorMaskCapable : 1;      /**< \brief Per vector mask */
    uint16 reserved_9 : 7;             /**< \brief Reserved */
} IfxPcieCap_MsiMSgCtrlBits;

/** \brief MSIx Message Control Bits
 */
typedef struct
{
    uint16 tableSize : 11;       /**< \brief Number of entries N-1 */
    uint16 reserved_11 : 3;      /**< \brief reserved */
    uint16 funcMask : 1;         /**< \brief Global Mask */
    uint16 msixEnable : 1;       /**< \brief Enable MSI X */
} IfxPcieCap_MsixMsgCtrl_Bits;

/** \brief PCIE capabilities register Bits
 */
typedef struct
{
    uint16 version : 4;         /**< \brief capability version */
    uint16 type : 4;            /**< \brief device/port type */
    uint16 slot : 1;            /**< \brief slot implemented */
    uint16 intMsgNo : 5;        /**< \brief interrupt message number */
    uint16 reserved_14 : 2;     /**< \brief reserved */
} IfxPcieCap_PcieCapReg_Bits;

/** \brief PMC Register Bits
 */
typedef struct
{
    uint16 version : 3;        /**< \brief Version */
    uint16 pmeClk : 1;         /**< \brief Hardwire to 0 for PCIE */
    uint16 ireadyD0 : 1;       /**< \brief Immediate Readiness on D0 */
    uint16 dsi : 1;            /**< \brief Device Specific Init */
    uint16 auxCurr : 3;        /**< \brief AUX Current */
    uint16 d1Support : 1;      /**< \brief D1 supported */
    uint16 d2Support : 1;      /**< \brief D2 supported */
    uint16 pmeSupport : 5;     /**< \brief PME Support States */
} IfxPcieCap_PmcReg_Bits;

/** \brief PMC Status Control Register Bits
 */
typedef struct
{
    uint16 pwrState : 2;       /**< \brief Power State */
    uint16 reserved_2 : 1;     /**< \brief Reserved */
    uint16 noSoftRst : 1;      /**< \brief No Soft Reset */
    uint16 reserved_4 : 4;     /**< \brief Reserved */
    uint16 pme : 1;            /**< \brief PME is enabled */
    uint16 dataSel : 4;        /**< \brief Data Select */
    uint16 dataScale : 2;      /**< \brief Data Scale */
    uint16 pmeStatus : 1;      /**< \brief PME Status */
} IfxPcieCap_PmcsrReg_Bits;

/** \brief PCIE PTM Capability Register Bits
 */
typedef struct
{
    uint32 ptmReqCapable : 1;            /**< \brief 0:0 PTM Requester Capable */
    uint32 ptmRespCapable : 1;           /**< \brief 1:1 PTM Responder Capable */
    uint32 ptmRootCapable : 1;           /**< \brief 1:1 PTM Root Capable */
    uint32 eptmCapable : 1;              /**< \brief 1:1 EPTM Capable */
    uint32 reserved_4 : 4;               /**< \brief 4:7 Reserved */
    uint32 localClkGranularity : 8;      /**< \brief 8:15 Local Clock Granularity */
    uint32 reserved_16 : 16;             /**< \brief 16:31 Reserved */
} IfxPcieCap_PtmCapabilityRegBits;

/** \brief Root Capabilities Bits
 */
typedef struct
{
    uint16 crsSwVisible : 1;     /**< \brief CRS Software Visibility Enable */
    uint16 reserved_1 : 15;      /**< \brief reserved */
} IfxPcieCap_RootCap_Bits;

/** \brief Root Control Bits
 */
typedef struct
{
    uint16 sysErrCorr : 1;         /**< \brief System Error on Correctable Errors */
    uint16 sysErrNonFatal : 1;     /**< \brief System Error on Non Fatal Errors */
    uint16 sysErrFatal : 1;        /**< \brief System Error on Fatal Errors */
    uint16 pmeInterrupt : 1;       /**< \brief PM Interrupt Enable */
    uint16 crsSwVisible : 1;       /**< \brief CRS Software Visibility Enable */
    uint16 reserved_5 : 11;        /**< \brief reserved */
} IfxPcieCap_RootCtrl_Bits;

/** \brief PCIE AER Root Error Command Bits
 */
typedef struct
{
    uint32 corrErrReportEn : 1;          /**< \brief 0:0 Correctable Error Reporting Enable */
    uint32 nonFatalErrReportEn : 1;      /**< \brief 1:1 Non-Fatal Error Reporting Enable */
    uint32 fatalErrReportEn : 1;         /**< \brief 2:2 Fatal Error Reporting Enable */
    uint32 reserved_3 : 29;              /**< \brief 3:31 Reserved */
} IfxPcieCap_RootErrorCmdBits;

/** \brief PCIE AER Root Error Status Bits
 */
typedef struct
{
    uint32 errCorr : 1;                    /**< \brief 0:0 ERR_COR Received */
    uint32 multipleerrCorr : 1;            /**< \brief 1:1; Multiple ERR_COR Received */
    uint32 fatalNonFatal : 1;              /**< \brief 2:2 ERR_FATAL/NONFATAL Received */
    uint32 multipleFatalNonFatal : 1;      /**< \brief 3:3 Multiple ERR_FATAL/NONFATAL Received */
    uint32 firstUncorrFatal : 1;           /**< \brief 4:4 First Uncorrectable Fatal */
    uint32 nonFatalErrorMsg : 1;           /**< \brief 5:5 Non-Fatal Error Messages Received */
    uint32 fatalErrorMsg : 1;              /**< \brief 6:6 Fatal Error Messages Received */
    uint32 errCorrSubclass : 2;            /**< \brief 7:8 ERR_COR Subclass */
    uint32 reserved_9 : 18;                /**< \brief 9:26 RsvdZ */
    uint32 aerIntMsgNum : 5;               /**< \brief 27:31 Advanced Error Interrupt Message Number */
} IfxPcieCap_RootErrorStatusBits;

/** \brief Root Status Bits
 */
typedef struct
{
    uint32 pmeReqId : 16;        /**< \brief PME Requester Id */
    uint32 pmeStatus : 1;        /**< \brief PME Status */
    uint32 pmePending : 1;       /**< \brief PME Pending */
    uint32 reserved_18 : 14;     /**< \brief reserved */
} IfxPcieCap_RootStatus_Bits;

/** \brief Slot Capabilities Bits
 */
typedef struct
{
    uint32 attnButton : 1;            /**< \brief Attention button Present */
    uint32 pwrController : 1;         /**< \brief Power Controller Present */
    uint32 mrlSensor : 1;             /**< \brief MRL Sensor Present */
    uint32 attnIndicator : 1;         /**< \brief Attention Indicator Present */
    uint32 pwrIndicator : 1;          /**< \brief Power Indicator Present */
    uint32 hotPlugSurprise : 1;       /**< \brief Hot Plug Surprise */
    uint32 hotPlugCap : 1;            /**< \brief Hot Plug Capable */
    uint32 slotPwrLimit : 8;          /**< \brief Slot Power Limit Value */
    uint32 slotPwrLimitScale : 2;     /**< \brief Slow Power Limit Scale */
    uint32 emLock : 1;                /**< \brief Electromechanical Interlock Present */
    uint32 noCmdComplete : 1;         /**< \brief No Command Complete Support */
    uint32 physicalSlot : 13;         /**< \brief Physical Slot Number */
} IfxPcieCap_SlotCap_Bits;

/** \brief Slot Control Bits
 */
typedef struct
{
    uint16 attnButton : 1;               /**< \brief Attention Button Pressed Enable */
    uint16 pwrFaultDetect : 1;           /**< \brief Power Fault Detected Enable */
    uint16 mrlSensorChange : 1;          /**< \brief MRL Sensor Changed Enable */
    uint16 presenceDetectChange : 1;     /**< \brief Present Detect Changed Enable */
    uint16 cmdCompleteInterrupt : 1;     /**< \brief Command complete Interrupt Enable */
    uint16 hotPlugInterrupt : 1;         /**< \brief Hot Plug Interrupt Enable */
    uint16 attnIndicatorCtrl : 2;        /**< \brief Attention Indicator Control */
    uint16 pwrIndicatorCtrl : 2;         /**< \brief Power Indicator Control */
    uint16 pwrControllerCtrl : 1;        /**< \brief Power Controller Control */
    uint16 emLockCtrl : 1;               /**< \brief Electromechanical Interlock Control */
    uint16 dataLinkStateChange : 1;      /**< \brief Data Link Layer State Changed */
    uint16 autoSlotPwrLimit : 1;         /**< \brief Auto Slot Power Limit Enable */
    uint16 inBandPdDisable : 1;          /**< \brief In Band PD Disable */
    uint16 reserved_15 : 1;              /**< \brief reserved */
} IfxPcieCap_SlotCtrl_Bits;

/** \brief Slot Status Bits
 */
typedef struct
{
    uint16 attnButton : 1;               /**< \brief Attention Button Pressed */
    uint16 pwrFaultDetect : 1;           /**< \brief Power Fault Detected */
    uint16 mrlSensorChange : 1;          /**< \brief MRL Sensor Changed */
    uint16 presenceDetectChange : 1;     /**< \brief Presence Detect Changed */
    uint16 cmdComplete : 1;              /**< \brief Command Completed */
    uint16 mrlSensorState : 1;           /**< \brief MRL Sensor State */
    uint16 presenceDetectState : 1;      /**< \brief Present Detect State */
    uint16 emLock : 1;                   /**< \brief Electromechanical Interlock Status */
    uint16 dataLinkStateChange : 1;      /**< \brief Data Link Layer State Changed */
    uint16 reserved_9 : 7;               /**< \brief reserved */
} IfxPcieCap_SlotStatus_Bits;

/** \brief PCIE Snoop Latency Register Bits
 */
typedef struct
{
    uint16 latencyVal : 10;       /**< \brief 0:9 Latency Value */
    uint16 latencyScale : 3;      /**< \brief 10:12 Latency Scale */
    uint16 reserved_3 : 2;        /**< \brief 13:14 Reserved */
    uint16 requirement : 1;       /**< \brief 13:14 Requirement */
} IfxPcieCap_SnoopLatencyBits;

/** \brief PCIE AER Capability Uncorrectable Error Bits
 */
typedef struct
{
    uint32 undefined : 1;                     /**< \brief 0:0 Undefined */
    uint32 reserved_1 : 3;                    /**< \brief 1:3 Reserved */
    uint32 dataLink : 1;                      /**< \brief 4:4 Undefined */
    uint32 surpriseDown : 1;                  /**< \brief 5:5 Surprise Down */
    uint32 reserved_6 : 6;                    /**< \brief 6:11 Reserved */
    uint32 poisonedTLP : 1;                   /**< \brief 12:12 Poisoned TLP Received */
    uint32 flowControl : 1;                   /**< \brief 13:13 Flow Control Protocol Error Status */
    uint32 completionTimeout : 1;             /**< \brief 14:14 Completion Timeout Status */
    uint32 completerAbort : 1;                /**< \brief 15:15 Completer Abort Status */
    uint32 unexpectedCompletion : 1;          /**< \brief 16:16 Unexpected Completion Status */
    uint32 receiverOverflow : 1;              /**< \brief 17:17 Receiver Overflow Status */
    uint32 malformedTLP : 1;                  /**< \brief 18:18 Malformed TLP Status */
    uint32 ecrcErr : 1;                       /**< \brief 19:19 ECRC Error Status */
    uint32 unsupportedReq : 1;                /**< \brief 20:20 Unsupported Request Error Status */
    uint32 acsViolation : 1;                  /**< \brief 21:21 ACS Violation Status */
    uint32 uncorrInternalErr : 1;             /**< \brief 22:22 Uncorrectable Internal Error Status */
    uint32 mcBlockedTLP : 1;                  /**< \brief 23:23 MC Blocked TLP Status */
    uint32 atomicOpEgressBlocked : 1;         /**< \brief 24:24 AtomicOp Egress Blocked Status */
    uint32 tlpPrefixBlocked : 1;              /**< \brief 25:25 TLP Prefix Blocked Error Status */
    uint32 poisonedTlpEgressBlocked : 1;      /**< \brief 26:26 Poisoned TLP Egress Blocked Status */
    uint32 reserved_27 : 5;                   /**< \brief 27:31 Reserved */
} IfxPcieCap_UncorrErrorBits;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Cap_Structures
 * \{ */
/** \brief PCIE AER Capability Control
 */
typedef union
{
    uint32                    U;       /**< \brief Word */
    IfxPcieCap_AerCapCtrlBits B;       /**< \brief Bits */
} IfxPcieCap_AerCapCtrl;

/** \brief PCIE AER Capability Correctable Error
 */
typedef union
{
    uint32                   U;       /**< \brief Word */
    IfxPcieCap_CorrErrorBits B;       /**< \brief Bits */
} IfxPcieCap_CorrError;

/** \brief Device Capabilities
 */
typedef union
{
    volatile IfxPcieCap_DeviceCap_Bits B;       /**< \brief Bits */
    uint32                             U;       /**< \brief Word */
} IfxPcieCap_DeviceCap;

/** \brief Device Capabilities 2
 */
typedef union
{
    volatile IfxPcieCap_DeviceCap2_Bits B;       /**< \brief Bits */
    uint32                              U;       /**< \brief Word */
} IfxPcieCap_DeviceCap2;

/** \brief Device Control
 */
typedef union
{
    volatile IfxPcieCap_DeviceCtrl_Bits B;       /**< \brief Bits */
    uint16                              U;       /**< \brief Word */
} IfxPcieCap_DeviceCtrl;

/** \brief Device Control 2
 */
typedef union
{
    volatile IfxPcieCap_DeviceCtrl2_Bits B;       /**< \brief Bits */
    uint16                               U;       /**< \brief Word */
} IfxPcieCap_DeviceCtrl2;

/** \brief Devce Status
 */
typedef union
{
    volatile IfxPcieCap_DeviceStatus_Bits B;       /**< \brief Bits */
    uint16                                U;       /**< \brief Word */
} IfxPcieCap_DeviceStatus;

/** \brief PCIE AER Error Source ID
 */
typedef union
{
    uint32                       U;       /**< \brief Word */
    IfxPcieCap_ErrorSourceIdBits B;       /**< \brief Bits */
} IfxPcieCap_ErrorSourceId;

/** \brief PCIE Extended Capability Header
 */
typedef union
{
    uint32                           U;       /**< \brief Word */
    IfxPcieCap_ExtendedCapHeaderBits B;       /**< \brief Bits */
} IfxPcieCap_ExtendedCapHeader;

/** \brief Link Capabilities
 */
typedef union
{
    volatile IfxPcieCap_LinkCap_Bits B;       /**< \brief Bits */
    uint32                           U;       /**< \brief Word */
} IfxPcieCap_LinkCap;

/** \brief Link Capabilities 2
 */
typedef union
{
    volatile IfxPcieCap_LinkCap2_Bits B;       /**< \brief Bits */
    uint32                            U;       /**< \brief Word */
} IfxPcieCap_LinkCap2;

/** \brief Link Control
 */
typedef union
{
    volatile IfxPcieCap_LinkCtrl_Bits B;       /**< \brief Bits */
    uint16                            U;       /**< \brief Word */
} IfxPcieCap_LinkCtrl;

/** \brief Link Control 2
 */
typedef union
{
    volatile IfxPcieCap_LinkCtrl2_Bits B;       /**< \brief Bits */
    uint16                             U;       /**< \brief Word */
} IfxPcieCap_LinkCtrl2;

/** \brief Link Status
 */
typedef union
{
    volatile IfxPcieCap_LinkStatus_Bits B;       /**< \brief Bits */
    uint16                              U;       /**< \brief Word */
} IfxPcieCap_LinkStatus;

/** \brief Link Status 2
 */
typedef union
{
    volatile IfxPcieCap_LinkStatus2_Bits B;       /**< \brief Bits */
    uint16                               U;       /**< \brief Word */
} IfxPcieCap_LinkStatus2;

/** \brief MSI Message Control
 */
typedef union
{
    volatile IfxPcieCap_MsiMSgCtrlBits B;       /**< \brief Message control bits */
    uint16                             U;       /**< \brief word access */
} IfxPcieCap_MsiMsgCtrl;

/** \brief MSIX Message Control
 */
typedef union
{
    volatile IfxPcieCap_MsixMsgCtrl_Bits B;       /**< \brief Message control bits */
    uint16                               U;       /**< \brief word access */
} IfxPcieCap_MsixMsgCtrl;

/** \brief PCIE capabilities register
 */
typedef union
{
    volatile IfxPcieCap_PcieCapReg_Bits B;       /**< \brief Bits */
    uint16                              U;       /**< \brief Word */
} IfxPcieCap_PcieCapReg;

/** \brief PMC Register
 */
typedef union
{
    volatile IfxPcieCap_PmcReg_Bits B;       /**< \brief Bits */
    uint16                          U;       /**< \brief Word */
} IfxPcieCap_PmcReg;

/** \brief PMC Status Control Register
 */
typedef union
{
    volatile IfxPcieCap_PmcsrReg_Bits B;       /**< \brief Bits */
    uint16                            U;       /**< \brief Word */
} IfxPcieCap_PmcsrReg;

/** \brief PCIE PTM Capability Register
 */
typedef union
{
    uint32                          U;       /**< \brief Word */
    IfxPcieCap_PtmCapabilityRegBits B;       /**< \brief Bits */
} IfxPcieCap_PtmCapabilityReg;

/** \brief PCIE PTM Control Register
 */
typedef union
{
    uint32                          U;       /**< \brief Word */
    IfxPcieCap_PtmCapabilityRegBits B;       /**< \brief Bits */
} IfxPcieCap_PtmControlReg;

/** \brief Root Capabilities
 */
typedef union
{
    volatile IfxPcieCap_RootCap_Bits B;       /**< \brief Bits */
    uint16                           U;       /**< \brief Word */
} IfxPcieCap_RootCap;

/** \brief Root Control
 */
typedef union
{
    volatile IfxPcieCap_RootCtrl_Bits B;       /**< \brief Bits */
    uint16                            U;       /**< \brief Word */
} IfxPcieCap_RootCtrl;

/** \brief PCIE AER Root Error Command
 */
typedef union
{
    uint32                      U;       /**< \brief Word */
    IfxPcieCap_RootErrorCmdBits B;       /**< \brief Bits */
} IfxPcieCap_RootErrorCmd;

/** \brief PCIE AER Root Error Status
 */
typedef union
{
    uint32                         U;       /**< \brief Word */
    IfxPcieCap_RootErrorStatusBits B;       /**< \brief Bits */
} IfxPcieCap_RootErrorStatus;

/** \brief Root Status
 */
typedef union
{
    volatile IfxPcieCap_RootStatus_Bits B;       /**< \brief Bits */
    uint32                              U;       /**< \brief Word */
} IfxPcieCap_RootStatus;

/** \brief Slot Capabilities
 */
typedef union
{
    volatile IfxPcieCap_SlotCap_Bits B;       /**< \brief Bits */
    uint32                           U;       /**< \brief Word */
} IfxPcieCap_SlotCap;

/** \brief Slot Control
 */
typedef union
{
    volatile IfxPcieCap_SlotCtrl_Bits B;       /**< \brief Bits */
    uint16                            U;       /**< \brief Word */
} IfxPcieCap_SlotCtrl;

/** \brief Slot Status
 */
typedef union
{
    volatile IfxPcieCap_SlotStatus_Bits B;       /**< \brief Bits */
    uint16                              U;       /**< \brief Word */
} IfxPcieCap_SlotStatus;

/** \brief PCIE Snoop Latency Register
 */
typedef union
{
    uint16                      U;       /**< \brief Word */
    IfxPcieCap_SnoopLatencyBits B;       /**< \brief Bits */
} IfxPcieCap_SnoopLatency;

/** \brief PCIE AER Capability Uncorrectable Error
 */
typedef union
{
    uint32                     U;       /**< \brief Word */
    IfxPcieCap_UncorrErrorBits B;       /**< \brief Bits */
} IfxPcieCap_UncorrError;

/** \brief PCIE Vendor Specific Header Bits
 */
typedef struct
{
    uint32 vsecId : 16;          /**< \brief Capability ID */
    uint32 vsecRev : 4;          /**< \brief Capability Versions */
    uint32 vsecLength : 12;      /**< \brief VSEC length in bytes, including header */
} IfxPcieCap_VendorSpecHeaderBits;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Cap_Structures
 * \{ */
/** \brief PCIE AER Capability Header
 */
typedef struct
{
    IfxPcieCap_ExtendedCapHeader header;                    /**< \brief Header */
    IfxPcieCap_UncorrError       uncorrErrorStatus;         /**< \brief Uncorrectable Error Status */
    IfxPcieCap_UncorrError       uncorrErrorMask;           /**< \brief Uncorrectable Error Mask */
    IfxPcieCap_UncorrError       uncorrErrorSeverity;       /**< \brief Uncorrectable Error Severity */
    IfxPcieCap_CorrError         corrErrorStatus;           /**< \brief Correctable Error Status */
    IfxPcieCap_CorrError         corrErrorMask;             /**< \brief Correctable Error Mask */
    IfxPcieCap_AerCapCtrl        capControl;                /**< \brief Capability Control */
    uint32                       tlpHeaderLog[4];           /**< \brief TLP Header Log */
    IfxPcieCap_RootErrorCmd      rootErrorCmd;              /**< \brief Root Error Command */
    IfxPcieCap_RootErrorStatus   rootErrorStatus;           /**< \brief Root Error Status */
    IfxPcieCap_ErrorSourceId     errorSourceId;             /**< \brief Error Source Identification */
    uint32                       tlpPrefixLog[4];           /**< \brief TLP Prefix Log */
} IfxPcieCap_AerCap;

/** \brief PCIE LTR capability
 */
typedef struct
{
    IfxPcieCap_ExtendedCapHeader header;                  /**< \brief Header */
    IfxPcieCap_SnoopLatency      maxSnoopLatency;         /**< \brief MAX Snoop Latency Register */
    IfxPcieCap_SnoopLatency      maxNoSnoopLatency;       /**< \brief MAX No Snoop Latency Register */
} IfxPcieCap_LtrCap;

/** \brief PCIE LTR Message payload
 */
typedef struct
{
    IfxPcieCap_SnoopLatency maxSnoopLatency;         /**< \brief MAX Snoop Latency Register */
    IfxPcieCap_SnoopLatency maxNoSnoopLatency;       /**< \brief MAX No Snoop Latency Register */
} IfxPcieCap_LtrMessage;

/** \brief MSI Capability
 */
typedef struct
{
    volatile uint8                 capId;               /**< \brief capability ID */
    volatile uint8                 nextCapOffset;       /**< \brief next capability offset */
    volatile IfxPcieCap_MsiMsgCtrl msgControl;          /**< \brief Message control */
    volatile uint32                msiAddress;          /**< \brief Message address lower */
    volatile uint32                cap02h;              /**< \brief MSI capability offset 02H */
    volatile uint32                cap03h;              /**< \brief MSI capability offset 03H */
    volatile uint32                cap04h;              /**< \brief MSI capability offset 04H */
    volatile uint32                cap05h;              /**< \brief MSI capability offset 05H */
} IfxPcieCap_MsiCap;

/** \brief MSI Capability 32 Bit Address
 */
typedef struct
{
    volatile uint8                 capId;                  /**< \brief capability ID */
    volatile uint8                 nextCapOffset;          /**< \brief next capability offset */
    volatile IfxPcieCap_MsiMsgCtrl msgControl;             /**< \brief Message control */
    volatile uint32                msiAddress;             /**< \brief Message address lower */
    volatile uint16                data;                   /**< \brief Message Data */
    volatile uint8                 reserved_dw2[14];       /**< \brief Reserved */
} IfxPcieCap_MsiCap32Bit;

/** \brief MSI Capability 32 Bit Address Per vector mask
 */
typedef struct
{
    volatile uint8                 capId;                 /**< \brief capability ID */
    volatile uint8                 nextCapOffset;         /**< \brief next capability offset */
    volatile IfxPcieCap_MsiMsgCtrl msgControl;            /**< \brief Message control */
    volatile uint32                msiAddress;            /**< \brief Message address lower */
    volatile uint16                data;                  /**< \brief Message Data */
    volatile uint8                 reserved_dw2[2];       /**< \brief Reserved */
    volatile uint32                maskBits;              /**< \brief Mask Bits */
    volatile uint32                pendingBits;           /**< \brief Pending Bits */
    volatile uint8                 reserved_dw5[4];       /**< \brief Reserved */
} IfxPcieCap_MsiCap32BitMask;

/** \brief MSI Capability 64 Bit
 */
typedef struct
{
    volatile uint8                 capId;                  /**< \brief capability ID */
    volatile uint8                 nextCapOffset;          /**< \brief next capability offset */
    volatile IfxPcieCap_MsiMsgCtrl msgControl;             /**< \brief Message control */
    volatile uint32                msiAddress;             /**< \brief Message address lower */
    volatile uint32                msiAddressUpper;        /**< \brief Message address Upper */
    volatile uint16                data;                   /**< \brief Message Data */
    volatile uint8                 reserved_dw3[10];       /**< \brief Reserved */
} IfxPcieCap_MsiCap64Bit;

/** \brief MSI Capability 64 Bit Vector Mask
 */
typedef struct
{
    volatile uint8                 capId;                 /**< \brief capability ID */
    volatile uint8                 nextCapOffset;         /**< \brief next capability offset */
    volatile IfxPcieCap_MsiMsgCtrl msgControl;            /**< \brief Message control */
    volatile uint32                msiAddress;            /**< \brief Message address lower */
    volatile uint32                msiAddressUpper;       /**< \brief Message address Upper */
    volatile uint16                data;                  /**< \brief Message Data */
    volatile uint8                 reserved_dw3[2];       /**< \brief Reserved */
    volatile uint32                maskBits;              /**< \brief Mask Bits */
    volatile uint32                pendingBits;           /**< \brief Pending Bits */
} IfxPcieCap_MsiCap64BitMask;

/** \brief MSIx Capability
 */
typedef struct
{
    uint8                  capId;               /**< \brief capability ID */
    uint8                  nextCapOffset;       /**< \brief next capability offset */
    IfxPcieCap_MsixMsgCtrl msgControl;          /**< \brief Message control */
    uint32                 tableOffset;         /**< \brief Table offset */
    uint32                 pbaOffset;           /**< \brief Table offset */
} IfxPcieCap_MsixCap;

typedef struct
{
    uint32 lowerAddress;       /**< \brief Lower Address */
    uint32 upperAddress;       /**< \brief Upper Address */
    uint32 data;               /**< \brief Data */
    uint32 vectorCtrl;         /**< \brief Vector Control */
} IfxPcieCap_MsixTableEntry;

/** \brief PCIE capability
 */
typedef struct
{
    uint8                   capId;                  /**< \brief capability ID 00 */
    uint8                   nextCapOffset;          /**< \brief next capability offset 01 */
    IfxPcieCap_PcieCapReg   pcieCapReg;             /**< \brief PCIE capabilities register 02 */
    IfxPcieCap_DeviceCap    deviceCap;              /**< \brief Device Capabilities 04 */
    IfxPcieCap_DeviceCtrl   deviceCtrl;             /**< \brief Device Control 08 */
    IfxPcieCap_DeviceStatus deviceStatus;           /**< \brief Device Status 0A */
    IfxPcieCap_LinkCap      linkCap;                /**< \brief Link Capabilities 0C */
    IfxPcieCap_LinkCtrl     linkCtrl;               /**< \brief Link Control 10 */
    IfxPcieCap_LinkStatus   linkStatus;             /**< \brief Link Status 12 */
    IfxPcieCap_SlotCap      slotCap;                /**< \brief Slot Capabilities 14 */
    IfxPcieCap_SlotCtrl     slotCtrl;               /**< \brief Slot Control 18 */
    IfxPcieCap_SlotStatus   slotStatus;             /**< \brief Slot Status 1A */
    IfxPcieCap_RootCtrl     rootCtrl;               /**< \brief Root Control 1C */
    IfxPcieCap_RootCap      rootCap;                /**< \brief Root Capabilities 1E */
    IfxPcieCap_RootStatus   rootStatus;             /**< \brief Root Status 20 */
    IfxPcieCap_DeviceCap2   deviceCap2;             /**< \brief Device Capabilities 24 */
    IfxPcieCap_DeviceCtrl2  deviceCtrl2;            /**< \brief Device Control 28 */
    uint8                   reserved_2Ah[2];        /**< \brief Reserved 2A */
    IfxPcieCap_LinkCap2     linkCap2;               /**< \brief Link Capabilities 2C */
    IfxPcieCap_LinkCtrl2    linkCtrl2;              /**< \brief Link Control 30 */
    IfxPcieCap_LinkStatus2  linkStatus2;            /**< \brief Link Status 32 */
    uint8                   reserved_34h[12];       /**< \brief Reserved 34 */
} IfxPcieCap_PcieCap;

/** \brief Power management capability
 */
typedef struct
{
    volatile uint8               pm_id;               /**< \brief PM ID */
    volatile uint8               pm_cap_offset;       /**< \brief PM capability offset */
    volatile IfxPcieCap_PmcReg   pmc;                 /**< \brief PMC Register */
    volatile IfxPcieCap_PmcsrReg pmcsr;               /**< \brief PMC Status Control Register */
    volatile uint8               reserved_06h;        /**< \brief Reserved */
    volatile uint8               data;                /**< \brief Data */
} IfxPcieCap_PmCap;

/** \brief PCIE PTM capability
 */
typedef struct
{
    IfxPcieCap_ExtendedCapHeader header;           /**< \brief Header */
    IfxPcieCap_PtmCapabilityReg  ptmCapReg;        /**< \brief PTM Capability Register */
    IfxPcieCap_PtmControlReg     ptmCtrlReg;       /**< \brief PTM Control Register */
} IfxPcieCap_PtmCap;

/** \brief PCIE PTM Control Register Bits
 */
typedef struct
{
    uint32 ptmEnable : 1;           /**< \brief 0:0 PTM Enable */
    uint32 rootSelect : 1;          /**< \brief 1:1 Root Select */
    uint32 reserved_2 : 6;          /**< \brief 2:7 Reserved */
    uint32 effGranularity : 8;      /**< \brief 8:15 Effective Granularity */
    uint32 reserved_16 : 16;        /**< \brief 16:31 Reserved */
} IfxPcieCap_PtmControlRegBits;

/** \brief PCIE SN capability
 */
typedef struct
{
    IfxPcieCap_ExtendedCapHeader header;             /**< \brief Header */
    uint32                       serialNoLow;        /**< \brief 64Bit Serial Number Low DW */
    uint32                       serialNoHigh;       /**< \brief 64Bit Serial Number High DW */
} IfxPcieCap_SnCap;

/** \brief PCIE Vendor Specific Header
 */
typedef union
{
    uint32                          U;       /**< \brief Word */
    IfxPcieCap_VendorSpecHeaderBits B;       /**< \brief Bits */
} IfxPcieCap_VendorSpecHeader;

/** \} */

/** \addtogroup IfxLld_Pcie_Std_Cap_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Get the Table BIR and offset from MSIX cap pointer
 * \param capPtr Pointer to MSIX capability
 * \param tableOffset pointer to the table offset value
 * \param barIndex pointer to the bar Index value
 * \return None
 */
IFX_EXTERN void IfxPcieCap_getMsixTableBaseOffset(IfxPcieCap_MsixCap *capPtr, uint32 *tableOffset, uint8 *barIndex);

/** \brief Enable MSIX
 * \param capPtr Pointer to MSIX capability
 * \return None
 */
IFX_EXTERN void IfxPcieCap_enableMsix(IfxPcieCap_MsixCap *capPtr);

/** \brief Enable MSI
 * \param capPtr Pointer to MSI capability
 * \return None
 */
IFX_EXTERN void IfxPcieCap_enableMsi(IfxPcieCap_MsiCap *capPtr);

/** \brief Check if MSIX interrupt vector is masked or not
 * \param capPtr Pointer to the MSIX capability
 * \param tableAddr Ptr to MSIX table entry
 * \return Return TRUE if vector is masked
 */
IFX_EXTERN boolean IfxPcieCap_isMsixVectorMasked(IfxPcieCap_MsixCap *capPtr, IfxPcieCap_MsixTableEntry *tableAddr);

/** \brief Get the number of configured Table Entries in MSIx
 * \param capPtr Pointer to the MSIX capability
 * \param tableAddr Ptr to MSIX table first entry
 * \return Return the number of valid (unmasked) entries
 */
IFX_EXTERN uint8 IfxPcieCap_getNumMsixInterrupt(IfxPcieCap_MsixCap *capPtr, IfxPcieCap_MsixTableEntry *tableAddr);

/** \brief Get Power state of device
 * \param pciePmCap Pointer to PM Capability
 * \return Get the device state
 */
IFX_EXTERN IfxPcieCap_PmPwrState IfxPcieCap_getPwrState(IfxPcieCap_PmCap *pciePmCap);

/** \brief Set the device power state
 * \param pciePmCap Ptr to Power management capability of device
 * \param pwrState Device power state
 * \return TRUE: Setting device state successful
 * FALSE: Device state not set
 */
IFX_EXTERN boolean IfxPcieCap_setPwrState(IfxPcieCap_PmCap *pciePmCap, IfxPcieCap_PmPwrState pwrState);

/** \brief Check if the power state is supported by device
 * \param pciePmCap Ptr to Power management capability of device
 * \param pwrState Device power state
 * \return TRUE: Power State is supported
 * FALSE: Power state is not supported
 */
IFX_EXTERN boolean IfxPcieCap_isPwrStateSupported(IfxPcieCap_PmCap *pciePmCap, IfxPcieCap_PmPwrState pwrState);

/** \brief Enable/Disable the active power management of a device
 * \param pciePmCap Ptr to Power management capability of device
 * \param enable Enable/disable
 * \return None
 */
IFX_EXTERN void IfxPcieCap_setPmeActive(IfxPcieCap_PmCap *pciePmCap, boolean enable);

/** \brief Set the ASPM link state
 * \param pcieCap Ptr to pcie cap reg ptr
 * \param aspmLevel ASPM level
 * \return None
 */
IFX_EXTERN void IfxPcieCap_setAspmLnkState(IfxPcieCap_PcieCap *pcieCap, IfxPcieCap_PcieAspmLevel aspmLevel);

/** \brief Set the link retraining
 * \param pcieCap Ptr to pcie cap reg ptr
 * \return None
 */
IFX_EXTERN void IfxPcieCap_setLnkRetrain(IfxPcieCap_PcieCap *pcieCap);

/** \brief Set the AER Capability Enable for sub-capabilities
 * \param aerCap Ptr to AER cap header
 * \param capability the AER Capability that needs to be enabled/disable
 * \param enable if TRUE: enable. if FALSE: disable.
 * \return status of capability enable
 */
IFX_EXTERN boolean IfxPcieCap_setAerCapability(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerCapabilities capability, boolean enable);

/** \brief Get the AER Capability for sub-capabilities
 * \param aerCap Ptr to AER cap header
 * \param capability the AER Capability that needs to be enabled/disable
 * \return TRUE: capability is supported. FALSE: not supported.
 */
IFX_EXTERN boolean IfxPcieCap_getAerCapabilitySupport(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerCapabilities capability);

/** \brief Get Pending Errors for an AER sub-type
 * \param aerCap Ptr to AER cap header
 * \param errorType Type of the error
 * \param mask mask for getting status (1 << "POS" means that the "POS" interrupt will not be retrieved)
 * \return uint32: Error status bits
 */
IFX_EXTERN uint32 IfxPcieCap_getAerPendingErrors(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, uint32 mask);

/** \brief Set a mask for the AER error
 * \param aerCap Ptr to AER cap header
 * \param errorType Type of the error
 * \param mask mask for getting status (1 << "POS" means that the "POS" interrupt will not be retrieved)
 * \return None
 */
IFX_EXTERN void IfxPcieCap_serAerErrorMask(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, uint32 mask);

/** \brief Get TLP Header Log in case of error
 * \param aerCap Ptr to AER cap header
 * \param errorType Type of the error
 * \param headerPtr Pointer to the object to which header must be stored.
 * \return None
 */
IFX_EXTERN void IfxPcieCap_getAerTLPHeaderLog(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, void *headerPtr);

/** \brief Get TLP Prefix in case of error
 * \param aerCap Ptr to AER cap header
 * \param errorType Type of the error
 * \param prefixPtr Pointer to the object to which Prfix must be stored.
 * \return None
 */
IFX_EXTERN void IfxPcieCap_getAerTLPPrefix(IfxPcieCap_AerCap *aerCap, IfxPcieCap_AerErrorType errorType, void *prefixPtr);

/** \brief Set RASDP Auto Link Down
 * \param rasdpSFR Ptr to RASDP SFR capability structure
 * \param enabled if TRUE: Auto Link down is enabled
 * \return None
 */
IFX_EXTERN void IfxPcieCap_setRasDpAutoLinkDown(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, boolean enabled);

/** \brief Exit the RASDP error mode
 * \param rasdpSFR Ptr to RASDP SFR capability structure
 * \return None
 */
IFX_EXTERN void IfxPcieCap_exitRasDpErrorMode(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR);

/** \brief Disable Mask for RASDP error protection
 * \param rasdpSFR Ptr to RASDP SFR capability structure
 * \param disableMask mask for disable ( 1 << "POS" means that error at "POS" is disabled )
 * \return None
 */
IFX_EXTERN void IfxPcieCap_disableRasDpErrorProt(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, uint32 disableMask);

/** \brief Get RAM Address where error was detected
 * \param rasdpSFR Ptr to RASDP SFR capability structure
 * \param errorType type of error
 * \return none
 */
IFX_EXTERN uint32 IfxPcieCap_getRasDpRamErrorAddr(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, IfxPcieCap_AerErrorType errorType);

/** \brief Get RAM ID where error was detected
 * \param rasdpSFR Ptr to RASDP SFR capability structure
 * \param errorType type of error
 * \return none
 */
IFX_EXTERN uint32 IfxPcieCap_getRasDpRamErrorIndex(Ifx_PCIE_DSP_VSECRASCAP *rasdpSFR, IfxPcieCap_AerErrorType errorType);

/** \brief Enable RAS DES Error Injection for a type of Error
 * \param rasdesSFR Ptr to RAS DES SFR capability structure
 * \param errorType type of error to be injected.
 * \return None
 */
IFX_EXTERN void IfxPcieCap_enableRasDesErrorInjection(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesErrorType errorType);

/** \brief Configure RAS DES Error Injection for CRC
 * \param rasdesSFR Ptr to RAS DES SFR capability structure
 * \param errorType type of error to be injected.
 * \param count count of errors to be injected
 * \return None
 */
IFX_EXTERN void IfxPcieCap_configureRasDesCrcError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesCrcErrorType errorType, uint8 count);

/** \brief Configure RAS DES Error Injection for SEQ number
 * \param rasdesSFR Ptr to RAS DES SFR capability structure
 * \param errorType type of error to be injected.
 * \param badSeqNum bad Sequence Number
 * \param count count of errors to be injected
 * \return None
 */
IFX_EXTERN void IfxPcieCap_configureRasDesSeqError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesSeqErrorType errorType, uint32 badSeqNum, uint8 count);

/** \brief Configure RAS DES Error Injection for DLLP
 * \param rasdesSFR Ptr to RAS DES SFR capability structure
 * \param errorType type of error to be injected.
 * \param count count of errors to be injected
 * \return None
 */
IFX_EXTERN void IfxPcieCap_configureRasDesDllpError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesDllpErrorType errorType, uint8 count);

/** \brief Configure RAS DES Error Injection for Symbol
 * \param rasdesSFR Ptr to RAS DES SFR capability structure
 * \param errorType type of error to be injected.
 * \param count count of errors to be injected
 * \return None
 */
IFX_EXTERN void IfxPcieCap_configureRasDesSymError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesSymErrorType errorType, uint8 count);

/** \brief Configure RAS DES Error Injection for FC Credit
 * \param rasdesSFR Ptr to RAS DES SFR capability structure
 * \param fcType type of FC
 * \param badFcValue Bad FC value
 * \param vcNum VC number
 * \param count count of errors to be injected
 * \return None
 */
IFX_EXTERN void IfxPcieCap_configureRasDesFcError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesFcType fcType, uint32 badFcValue, uint8 vcNum, uint8 count);

/** \brief Configure RAS DES Error Injection for Symbol
 * \param rasdesSFR Ptr to RAS DES SFR capability structure
 * \param tlpType type of wrong TLP to be inserted
 * \param count count of errors to be injected
 * \return None
 */
IFX_EXTERN void IfxPcieCap_configureRasDesTlpInsertError(Ifx_PCIE_DSP_RASDESCAP *rasdesSFR, IfxPcieCap_RasDesTlpInsertType tlpType, uint8 count);

/** \brief set Enable for LTR capability
 * \param pcieCapPtr Ptr to PCIE capability structure
 * \param ltrEnable if TRUE: Enable LTR. if FALSE: disable LTR
 * \return None
 */
IFX_EXTERN void IfxPcieCap_setLtrEnable(IfxPcieCap_PcieCap *pcieCapPtr, boolean ltrEnable);

/** \brief set is LTR capability enabled for device?
 * \param pcieCapPtr Ptr to PCIE capability structure
 * \return if TRUE: Enable LTR. if FALSE: disable LTR
 */
IFX_EXTERN boolean IfxPcieCap_isLtrEnabled(IfxPcieCap_PcieCap *pcieCapPtr);

/** \brief set is LTR capability supported in the device?
 * \param pcieCapPtr Ptr to PCIE capability structure
 * \return if TRUE: Enable LTR. if FALSE: disable LTR
 */
IFX_EXTERN boolean IfxPcieCap_isLtrSupported(IfxPcieCap_PcieCap *pcieCapPtr);

/** \brief configure the LTR MAX latencies for Snoop and No snoop
 * \param ltrCapPtr Ptr to LTR capability structure
 * \param noSnoopLatency latency value for No Snoop
 * \param noSnoopScale Scale of latency for No Snoop
 * \param snoopLatency latency value for  Snoop
 * \param snoopScale Scale of latency for Snoop
 * \return None
 */
IFX_EXTERN void IfxPcieCap_setLtrMaxLatencies(IfxPcieCap_LtrCap *ltrCapPtr, uint16 noSnoopLatency, IfxPcieCap_LtrLatencyScale noSnoopScale, uint16 snoopLatency, IfxPcieCap_LtrLatencyScale snoopScale);

/** \brief set the OBFF Capability Enable with the intended type
 * \param pcieCapPtr Ptr to PCIE capability structure
 * \param obffType the Type of OBFF to be enabled
 * \return None
 */
IFX_EXTERN void IfxPcieCap_setObffEnable(IfxPcieCap_PcieCap *pcieCapPtr, IfxPcieCap_ObffType obffType);

/** \brief Get OBFF Capability
 * \param pcieCapPtr Ptr to PCIE capability structure
 * \return IfxPcieCap_ObffCapability OBFF Capability for the device
 */
IFX_EXTERN IfxPcieCap_ObffCapability IfxPcieCap_GetObffCapability(IfxPcieCap_PcieCap *pcieCapPtr);

/** \brief Get OBFF Type which is enabled for the device
 * \param pcieCapPtr Ptr to PCIE capability structure
 * \return IfxPcieCap_ObffType Type of OBFF enabled for the device
 */
IFX_EXTERN IfxPcieCap_ObffType IfxPcieCap_GetObffType(IfxPcieCap_PcieCap *pcieCapPtr);

/** \} */

#endif /* IFXPCIECAP_H */
