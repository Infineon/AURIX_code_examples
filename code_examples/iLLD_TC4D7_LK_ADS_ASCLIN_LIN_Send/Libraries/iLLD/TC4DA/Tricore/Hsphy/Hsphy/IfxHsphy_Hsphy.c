/**
 * \file IfxHsphy_Hsphy.c
 * \brief HSPHY HSPHY details
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxHsphy_Hsphy.h"

/******************************************************************************/
/*-----------------------Exported Variables/Constants-------------------------*/
/******************************************************************************/

IFX_CONST IfxHsphy_Hsphy_phyConfig IfxHsphy_Hsphy_configLookUpTbl[] = {
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_pcie,      IfxHsphy_TrgtDevice_pcie,  0, IfxHsphy_TrgtDeviceSpeed_8G,            NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P1G,          NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P1G_125mbps,  NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps, NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_1G,            NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_2P5G,          NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_5G,            NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_usxsgmii,  IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_5G,            NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_miiPads,   IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P1G,          NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_miiPads,   IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P01G,         NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_rmiiPads,  IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P1G,          NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_rmiiPads,  IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P01G,         NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_rgmiiPads, IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P1G,          NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_rgmiiPads, IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_1G,            NULL_PTR},
    {IfxHsphy_PhyIndex_0,    IfxHsphy_PadNativeInterface_rgmiiPads, IfxHsphy_TrgtDevice_xgmac, 0, IfxHsphy_TrgtDeviceSpeed_0P01G,         NULL_PTR},
    {IfxHsphy_PhyIndex_none, IfxHsphy_PadNativeInterface_xspiPads,  IfxHsphy_TrgtDevice_xspi,  0, IfxHsphy_TrgtDeviceSpeed_0P4G,          NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_0P1G,          NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_0P1G_125mbps,  NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps, NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_1G,            NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_2P5G,          NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_sgmii,     IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_5G,            NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_sgbt,      IfxHsphy_TrgtDevice_trace, 0, IfxHsphy_TrgtDeviceSpeed_1G,            NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_usxsgmii,  IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_5G,            NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_miiPads,   IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_0P1G,          NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_miiPads,   IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_0P01G,         NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_rmiiPads,  IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_0P1G,          NULL_PTR},
    {IfxHsphy_PhyIndex_1,    IfxHsphy_PadNativeInterface_rmiiPads,  IfxHsphy_TrgtDevice_xgmac, 1, IfxHsphy_TrgtDeviceSpeed_0P01G,         NULL_PTR},
    {IfxHsphy_PhyIndex_2,    IfxHsphy_PadNativeInterface_pcie,      IfxHsphy_TrgtDevice_pcie,  1, IfxHsphy_TrgtDeviceSpeed_8G,            NULL_PTR},
    {IfxHsphy_PhyIndex_2,    IfxHsphy_PadNativeInterface_sgbt,      IfxHsphy_TrgtDevice_trace, 0, IfxHsphy_TrgtDeviceSpeed_1G,            NULL_PTR}
};

IFX_CONST IfxHsphy_GethXpcsParams  IfxHsphy_Hsphy_defaultConfig[IFXHSPHY_NUM_OF_PHY] = {
    {IfxHsphy_XpcsIndex_0, IfxHsphy_XpcsRefClk_100Mhz, IfxHsphy_EthIndex_0},
    {IfxHsphy_XpcsIndex_1, IfxHsphy_XpcsRefClk_100Mhz, IfxHsphy_EthIndex_1}
};

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

IfxHsphy_status IfxHsphy_Hsphy_initModule(IfxHsphy_Hsphy *hsphy, IfxHsphy_Hsphy_Cfg *config)
{
    IfxHsphy_status                retval = IfxHsphy_status_success;
    uint8                          index  = 0;
    const IfxHsphy_GethXpcsParams *xpcsConfig;
    IfxHsphy_Geth_RgmiiCfg        *rgmiiConfig;
    IfxHsphy_Geth_MiiCfg          *miiConfig;
    IfxHsphy_Geth_RmiiCfg         *rmiiConfig;
    IfxHsphy_Xspi_XspiCfg         *xspiConfig;
    uint32                         timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8                          timeOutError      = 0U;

    Ifx_HSPHY                     *hsphySFR          = config->hsphySFR;
    hsphy->hsphySFR = hsphySFR;
    boolean                        relvalCheck       = FALSE;

    /* Check the validity of correction for module. Lookup if it is a valid config for chipset */
    for (index = 0; index < IFXHSPHY_NUM_OF_PHY; index++)
    {
        retval &= IfxHsphy_Hsphy_phyInit(hsphy->hsphyData[index], &config->phyConfig[index]);

        if (retval == FALSE)
        {
            return IfxHsphy_status_invalidConfigError;
        }
    }

    /* Enable module */
    relvalCheck = IfxHsphy_enableModule(hsphySFR);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_status_timeOutError;
    }

    relvalCheck = IfxHsphy_resetModule(hsphySFR);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_status_timeOutError;
    }

    for (index = 0; index < IFXHSPHY_NUM_OF_PHY; index++)
    {
        if ((hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_xspiPads) && (hsphy->hsphyData[index]->hsphyCfg.cfgData != NULL_PTR))
        {
            // Init and HSPHY configuration for XSPI
            xspiConfig  = (IfxHsphy_Xspi_XspiCfg *)hsphy->hsphyData[index]->hsphyCfg.cfgData;
            relvalCheck = IfxHsphy_Xspi_xspiInit(hsphy->hsphySFR, xspiConfig);

            if (relvalCheck == TRUE)
            {
                return IfxHsphy_status_timeOutError;
            }

            if (xspiConfig->xspiPins != NULL_PTR)
            {
                IfxHsphy_Xspi_setXspiPins(hsphy->hsphySFR, xspiConfig);
            }

            return IfxHsphy_status_success;
        }
    }

    for (index = 0; index < IFXHSPHY_NUM_OF_PHY; index++)
    {
        hsphySFR->PHY[hsphy->hsphyData[index]->hsphyCfg.phyIdx].CTRL1.B.PWRDWN = 0;
        hsphySFR->PHY[hsphy->hsphyData[index]->hsphyCfg.phyIdx].CTRL1.B.RST    = 0;
        relvalCheck                                                            = IfxHsphy_selFunction(hsphySFR, hsphy->hsphyData[index]->hsphyCfg.phyIdx, hsphy->hsphyData[index]->hsphyCfg.trgtDevice);

        if (relvalCheck == FALSE)
        {
            return IfxHsphy_status_invalidConfigError;
        }

        relvalCheck = IfxHsphy_setPhyRefClockSel(hsphySFR, hsphy->hsphyData[index]->hsphyCfg.phyIdx, hsphy->hsphyData[index]->hsphyCfg.trgtDevice);

        if (relvalCheck == FALSE)
        {
            return IfxHsphy_status_invalidConfigError;
        }

        if ((hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_sgmii) && (hsphy->hsphyData[index]->hsphyCfg.cfgData != NULL_PTR))
        {
            //Get the data of XPCS from cfgData
            xpcsConfig  = (const IfxHsphy_GethXpcsParams *)(hsphy->hsphyData[index]->hsphyCfg.cfgData);
            IfxHsphy_EthIndex ethIndex = xpcsConfig->ethIdx;
            relvalCheck = IfxHsphy_resetXpcs(hsphy->hsphySFR, xpcsConfig);

            if (relvalCheck == TRUE)
            {
                return IfxHsphy_status_timeOutError;
            }

            while (hsphy->hsphySFR->XPCS[xpcsConfig->xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerGood)
            {
                IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
            }

            if (timeOutError == TRUE)
            {
                return IfxHsphy_status_timeOutError;
            }

            hsphy->hsphySFR->ETH[ethIndex].B.EPR = IfxHsphy_EthCtrlExtPhySel_sgmii;
            IfxHsphy_Geth_SgmiiSpeedConfigStatus relvalCheck_sgmii;
            relvalCheck_sgmii                    = IfxHsphy_Geth_setSgmiiSpeedMode(hsphy->hsphySFR, hsphy->hsphyData[index]->hsphyCfg.deviceSpeed, xpcsConfig);

            if (relvalCheck_sgmii != IfxHsphy_Geth_SgmiiSpeedConfigStatus_success)
            {
                if (relvalCheck_sgmii == IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError)
                {
                    return IfxHsphy_status_timeOutError;
                }
                else
                {
                    return IfxHsphy_status_invalidConfigError;
                }
            }
        }
        else if ((hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_usxsgmii) && (hsphy->hsphyData[index]->hsphyCfg.cfgData != NULL_PTR))
        {
            // USXGMII configuration.
            xpcsConfig  = (const IfxHsphy_GethXpcsParams *)hsphy->hsphyData[index]->hsphyCfg.cfgData;
            IfxHsphy_EthIndex ethIndex = xpcsConfig->ethIdx;
            relvalCheck = IfxHsphy_resetXpcs(hsphy->hsphySFR, xpcsConfig);

            if (relvalCheck == TRUE)
            {
                return IfxHsphy_status_timeOutError;
            }

            timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;

            while (hsphy->hsphySFR->XPCS[xpcsConfig->xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerGood)
            {
                IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
            }

            if (timeOutError == TRUE)
            {
                return IfxHsphy_status_timeOutError;
            }

            hsphy->hsphySFR->ETH[ethIndex].B.EPR = IfxHsphy_EthCtrlExtPhySel_usxgmii;
            relvalCheck                          = IfxHsphy_Geth_setUsxgmiiSpeedMode(hsphy->hsphySFR, hsphy->hsphyData[index]->hsphyCfg.deviceSpeed, xpcsConfig);

            if (relvalCheck == TRUE)
            {
                return IfxHsphy_status_timeOutError;
            }
        }

        else if ((hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_rgmiiPads) && (hsphy->hsphyData[index]->hsphyCfg.cfgData != NULL_PTR))
        {
            // PAD configuration.
            rgmiiConfig                          = (IfxHsphy_Geth_RgmiiCfg *)hsphy->hsphyData[index]->hsphyCfg.cfgData;
            IfxHsphy_EthIndex ethIndex = rgmiiConfig->ethIdx;
            hsphy->hsphySFR->ETH[ethIndex].B.EPR = IfxHsphy_EthCtrlExtPhySel_rgmii;
            relvalCheck                          = IfxHsphy_Geth_rgmiiInit(hsphy->hsphySFR, rgmiiConfig);

            if (relvalCheck == TRUE)
            {
                return IfxHsphy_status_timeOutError;
            }

            if (rgmiiConfig->rgmiiPins != NULL_PTR)
            {
                IfxHsphy_Geth_setRgmiiPins(hsphy->hsphySFR, ethIndex, rgmiiConfig);
            }
        }

        else if ((hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_miiPads) && (hsphy->hsphyData[index]->hsphyCfg.cfgData != NULL_PTR))
        {
            // PAD configuration.
            miiConfig                            = (IfxHsphy_Geth_MiiCfg *)hsphy->hsphyData[index]->hsphyCfg.cfgData;
            IfxHsphy_EthIndex ethIndex = miiConfig->ethIdx;
            hsphy->hsphySFR->ETH[ethIndex].B.EPR = IfxHsphy_EthCtrlExtPhySel_mii;

            // TODO: Check do we need any initializations for MII
            if (miiConfig->miiPins != NULL_PTR)
            {
                IfxHsphy_Geth_setMiiPins(hsphy->hsphySFR, ethIndex, miiConfig);
            }
        }

        else if ((hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_rmiiPads) && (hsphy->hsphyData[index]->hsphyCfg.cfgData != NULL_PTR))
        {
            // PAD configuration.
            rmiiConfig                           = (IfxHsphy_Geth_RmiiCfg *)hsphy->hsphyData[index]->hsphyCfg.cfgData;
            IfxHsphy_EthIndex ethIndex = rmiiConfig->ethIdx;
            hsphy->hsphySFR->ETH[ethIndex].B.EPR = IfxHsphy_EthCtrlExtPhySel_rmii;
            hsphy->hsphySFR->CMNCFG.B.FSR        = 1;
            // TODO: Check do we need any initializations for RMII

            if (rmiiConfig->rmiiPins != NULL_PTR)
            {
                IfxHsphy_Geth_setRmiiPins(hsphy->hsphySFR, ethIndex, rmiiConfig);
            }
        }
        else if (hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_pcie)
        {
            retval = IfxHsphy_status_success;
        }
        else
        {
            retval = IfxHsphy_status_invalidConfigError;
        }

        if ((hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_sgmii) || (hsphy->hsphyData[index]->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_usxsgmii))
        {
            relvalCheck = IfxHsphy_Hsphy_initDone(IfxHsphy_getHsphyIndex(hsphy->hsphySFR), hsphy->hsphyData[index]->hsphyCfg.phyIdx);

            if (relvalCheck == FALSE)
            {
                return IfxHsphy_status_failure;
            }
        }
    }     // End of for loop

    return retval;
}


void IfxHsphy_Hsphy_initModuleConfig(Ifx_HSPHY *hsphy, IfxHsphy_Hsphy_Cfg *config)
{
    IfxHsphy_Hsphy_Cfg defaultConfig = {
        .hsphySFR     = NULL_PTR,
        .phyConfig[0] = {           // Config the PHY[0] to use the xspi
            .phyIdx        = IfxHsphy_PhyIndex_0,
            .padInterface  = IfxHsphy_PadNativeInterface_sgmii,
            .trgtDevice    = IfxHsphy_TrgtDevice_xgmac,
            .trgtDeviceIdx = 0,
            .deviceSpeed   = IfxHsphy_TrgtDeviceSpeed_2P5G,
            .cfgData       = &IfxHsphy_Hsphy_defaultConfig[0],
        },
        .phyConfig[1] = {           // config the PHY[1] to use the Geth with 1gbps speed
            .phyIdx        = IfxHsphy_PhyIndex_1,
            .padInterface  = IfxHsphy_PadNativeInterface_sgmii,
            .trgtDevice    = IfxHsphy_TrgtDevice_xgmac,
            .trgtDeviceIdx = 1,
            .deviceSpeed   = IfxHsphy_TrgtDeviceSpeed_2P5G,
            .cfgData       = &IfxHsphy_Hsphy_defaultConfig[1],
        },
        .phyConfig[2] = {           // config the PHY[2] to use the Pcie
            .phyIdx        = IfxHsphy_PhyIndex_2,
            .padInterface  = IfxHsphy_PadNativeInterface_pcie,
            .trgtDevice    = IfxHsphy_TrgtDevice_pcie,
            .trgtDeviceIdx = 1,
            .deviceSpeed   = IfxHsphy_TrgtDeviceSpeed_8G,
            .cfgData       = NULL_PTR,
        }
    };

    *config          = defaultConfig; /*Default Config*/
    config->hsphySFR = hsphy;         /*Module Pointer*/
}


boolean IfxHsphy_Hsphy_initDone(IfxHsphy_hsphyIndex hsphyIdx, IfxHsphy_PhyIndex phyIndex)
{
    boolean    retval            = TRUE;
    Ifx_HSPHY *HsphySfr          = IfxHsphy_getHsphyAddress(hsphyIdx);
    uint32     timeoutCycleCount = 0U;
    uint8      timeOutError      = 0U;

    timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;

    //Check if the Phy is read and wait till it gets ready
    while (IfxHsphy_isPhyReady(HsphySfr, phyIndex) != TRUE)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    retval &= IfxHsphy_setExtLdDone(HsphySfr, phyIndex);
    return (retval && (boolean)(!(timeOutError)));
}


boolean IfxHsphy_Hsphy_phyInit(IfxHsphy_Hsphy_phyData *hsphyData, IfxHsphy_Hsphy_phyConfig *phyConfig)
{
    // Check for lookup and get more connection parameters

    boolean retval       = FALSE;
    uint8   index        = 0;
    uint8   numOfEntries = (sizeof(IfxHsphy_Hsphy_configLookUpTbl) / sizeof(IfxHsphy_Hsphy_phyConfig));

    for (index = 0; index < numOfEntries; index++)
    {
        if (
            (phyConfig->phyIdx == IfxHsphy_Hsphy_configLookUpTbl[index].phyIdx) &&
            (phyConfig->padInterface == IfxHsphy_Hsphy_configLookUpTbl[index].padInterface) &&
            (phyConfig->trgtDevice == IfxHsphy_Hsphy_configLookUpTbl[index].trgtDevice) &&
            (phyConfig->trgtDeviceIdx == IfxHsphy_Hsphy_configLookUpTbl[index].trgtDeviceIdx) &&
            (phyConfig->deviceSpeed == IfxHsphy_Hsphy_configLookUpTbl[index].deviceSpeed)
            )
        {
            retval = TRUE;
            break;
        }
    }

    if (retval != FALSE)
    {
        //index has the value to get more parameters
        hsphyData->hsphyCfg.phyIdx        = phyConfig->phyIdx;
        hsphyData->hsphyCfg.padInterface  = phyConfig->padInterface;
        hsphyData->hsphyCfg.trgtDevice    = phyConfig->trgtDevice;
        hsphyData->hsphyCfg.trgtDeviceIdx = phyConfig->trgtDeviceIdx;
        hsphyData->hsphyCfg.deviceSpeed   = phyConfig->deviceSpeed;

        //cfg data
        if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_sgmii)
        {
            hsphyData->hsphyCfg.cfgData = (const IfxHsphy_GethXpcsParams *)phyConfig->cfgData;
        }
        else if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_usxsgmii)
        {
            hsphyData->hsphyCfg.cfgData = (const IfxHsphy_GethXpcsParams *)phyConfig->cfgData;
        }
        else if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_pcie)
        {
            hsphyData->hsphyCfg.cfgData = phyConfig->cfgData;
        }
        else if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_sgbt)
        {
            hsphyData->hsphyCfg.cfgData = phyConfig->cfgData;
        }
        else if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_rgmiiPads)
        {
            hsphyData->hsphyCfg.cfgData = (IfxHsphy_Geth_RgmiiCfg *)phyConfig->cfgData;
        }
        else if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_rmiiPads)
        {
            hsphyData->hsphyCfg.cfgData = (IfxHsphy_Geth_RmiiCfg *)phyConfig->cfgData;
        }
        else if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_miiPads)
        {
            hsphyData->hsphyCfg.cfgData = (IfxHsphy_Geth_MiiCfg *)phyConfig->cfgData;
        }
        else if (hsphyData->hsphyCfg.padInterface == IfxHsphy_PadNativeInterface_xspiPads)
        {
            hsphyData->hsphyCfg.cfgData = (IfxHsphy_Xspi_XspiCfg *)phyConfig->cfgData;
        }
        else
        {
            retval = FALSE;
        }
    }

    return retval;
}
