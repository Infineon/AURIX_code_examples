/**
 * \file IfxLeth_Eth.h
 * \brief LETH ETH details
 * \ingroup IfxLld_Leth
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Leth_Usage How to use the Leth Interface driver?
 * \ingroup IfxLld_Leth
 *
 * This section describes basic usage of LETH APIs in loopback mode. This sequence needs to be enhanced for Silicon users.
 *
 * \section IfxLld_Leth_SinglePort Leth Selectable Single Port with 1 channel/queue.
 *
 * \code
 * #include "IfxClock.h"
 * #include "IfxLeth.h"
 * #include <Leth/Eth/IfxLeth_Eth.h>
 * #include <Cpu/Std/IfxCpu.h>
 * #include <Vmt/Std/IfxVmt.h>
 *
 * #define IFXLETH_MAX_TX_BUFFER_SIZE 128 // bytes
 * #define IFXLETH_MAX_RX_BUFFER_SIZE 128 // bytes
 * #define IFXLETH_HEADER_LENGTH 14 // words
 * #define IFXLETH_NUM_PACKETS 1  // number of packets to be transmitted
 *
 * #define IFXLETH_MAX_CLOCK 200000000
 *
 * IfxLeth_Eth leth;
 * IfxLeth_PortIndex port_index = IfxLeth_PortIndex_0;
 *
 * __attribute__ ((aligned(64))) uint8 channel0TxBuffer1[IFXLETH_MAX_TX_DESCRIPTORS][IFXLETH_MAX_TX_BUFFER_SIZE];
 * __attribute__ ((aligned(64))) uint8 channel0RxBuffer1[IFXLETH_MAX_RX_DESCRIPTORS][IFXLETH_MAX_RX_BUFFER_SIZE];
 *
 *
 * float lethFreq = 0;
 * int result_global = 0;
 * int BasicSinglePort_Leth_internal_loopback(void)
 * {
 *     int result = 0;
 *
 *     //Application to do: Use VMT APIs to clear SRAMs. Not needed for VP. Mandatory for other platforms.
 *
 *     IfxLeth_Eth_SinglePortConfig     config;
 *
 *     //Clock Dividers
 *     //Optional: If not taken care in Start up S/w
 *     if(IfxClock_getLethFrequency()!= IFXLETH_MAX_CLOCK)
 *     {
 *      lethFreq = IfxClock_setLethFrequency(IFXLETH_MAX_CLOCK);
 *     }
 *
 *
 *     IfxLeth_Eth_singlePortInitConfig(&config, &MODULE_LETH0);
 *     config.enableLoopback = TRUE;
 *     config.txConfigChannel0.txBuffer1StartAddress = (uint32 *) IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), &channel0TxBuffer1[0][0]);
 *     config.rxConfigChannel0.rxBuffer1StartAddress = (uint32 *) IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), &channel0RxBuffer1[0][0]);
 *
 *
 *     //Init module
 *     IfxLeth_Eth_singlePortInit(&leth, port_index, &config);
 *
 *     //Init module done
 *
 *
 *    //clib_ver_printf("Start Rx");
 *     IfxLeth_Eth_startReceiver(&leth, port_index, IfxLeth_RxDmaChannel_0);
 *
 *     result = 0;
 *     uint32 packet;
 *     uint32 payloadLength = IFXLETH_MAX_TX_BUFFER_SIZE - IFXLETH_HEADER_LENGTH; //Application can increase payload/packet length as required.
 *     for (packet = 0; packet < IFXLETH_NUM_PACKETS; ++packet)
 *     {
 *
 *     IfxLeth_Eth_writeHeader( &channel0TxBuffer1[packet][0], (uint8 *)&(config.macAddress[0]), (uint8 *)&(config.macAddress[0]), payloadLength);
 *
 *
 *       for(unsigned int i = IFXLETH_HEADER_LENGTH; i < IFXLETH_MAX_TX_BUFFER_SIZE; ++i)
 *       {
 *        channel0TxBuffer1[packet][i] = (uint8)(i - 13 + packet);
 *        channel0RxBuffer1[packet][i] = 0xff;
 *       }
 *
 *      IfxLeth_Eth_sendTransmitBuffer(&leth, port_index, IFXLETH_MAX_TX_BUFFER_SIZE, IfxLeth_TxDmaChannel_0); //Here we are using packet length same as buffer size. Packet length can be higher and multiple descriptors will be used. Get appropriate buffer address using IfxLeth_Eth_getTransmitBuffer and IfxLeth_Eth_getReceiveBuffer.
 *
 *
 *       //wait until data is received
 *       while (IfxLeth_Eth_isRxDataAvailable(&leth, IfxLeth_RxDmaChannel_0) != TRUE) {};
 *
 *       result = 0;
 *       IfxLeth_Eth_shuffleRxDescriptor(&leth, IfxLeth_RxDmaChannel_0); //Re-initialize descriptors
 *
 *       // Optional data comparison
 *       // for (unsigned int i = 0; i < IFXLETH_MAX_TX_BUFFER_SIZE; ++i)
 *       //{
 *       // if(channel0RxBuffer1[packet][i] != channel0TxBuffer1[packet][i])
 *       // {
 *       //	  result++;
 *       //	  result_global++;
 *       // }
 *       //}
 *     }
 *
 *     //Alternately we can also use IfxLeth_Eth_getTransmitBuffer and IfxLeth_Eth_getReceiveBuffer to get the correct buffer addresses.
 *     uint8 loopCount = 1;
 *     uint8 *pTxBuf = NULL_PTR;
 *     uint8 *pRxBuf = NULL_PTR;
 *
 *     while(loopCount)
 *     {
 *      while( (pTxBuf=IfxLeth_Eth_getTransmitBuffer(&leth, IfxLeth_TxDmaChannel_0)) == NULL_PTR);
 *
 *      IfxLeth_Eth_writeHeader(pTxBuf, (uint8 *)&(config.macAddress[0]), (uint8 *)&(config.macAddress[0]), payloadLength);
 *
 *      {
 *              int i;
 *
 *          for(i=0; i<payloadLength; ++i) {
 *          pTxBuf[i+IFXLETH_HEADER_LENGTH] = (uint8)i;
 *          }
 *      }
 *
 *      // send packet
 *      IfxLeth_Eth_sendTransmitBuffer(&leth, port_index, (payloadLength+IFXLETH_HEADER_LENGTH), IfxLeth_TxDmaChannel_0);
 *
 *      //wait until data is received
 *      while (IfxLeth_Eth_isRxDataAvailable(&leth, IfxLeth_RxDmaChannel_0) != TRUE) {};
 *
 *      pRxBuf = (uint8*)IfxLeth_Eth_getReceiveBuffer(&leth, IfxLeth_RxDmaChannel_0); //Will point to correct Rx Buffer
 *
 *          result = 0;
 *         IfxLeth_Eth_shuffleRxDescriptor(&leth, IfxLeth_RxDmaChannel_0); //Re-initialize descriptors
 *      loopCount--;
 *
 *      //Optional: Compare contents of buffers pointed by pTxBuf and pRxBuf
 *     }
 *
 *     return result;
 * }
 * \endcode
 *
 * \defgroup IfxLld_Leth_Eth ETH
 * \ingroup IfxLld_Leth
 * \defgroup IfxLld_Leth_Eth_DataStructures DataStructures
 * \ingroup IfxLld_Leth_Eth
 * \defgroup IfxLld_Leth_Eth_Variables Variables
 * \ingroup IfxLld_Leth_Eth
 * \defgroup IfxLld_Leth_Eth_Interface_Functions Eth Interface layer APIs
 * \ingroup IfxLld_Leth_Eth
 * \defgroup IfxLld_Leth_Eth_Bridge_Functions Bridge APIs
 * \ingroup IfxLld_Leth_Eth
 */

#ifndef IFXLETH_ET_H
#define IFXLETH_ET_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Leth/Std/IfxLeth.h"
#include "_Utilities/Ifx_Assert.h"
#include "IfxPort_reg.h"
#include "IfxPort_bf.h"

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Leth_Eth_DataStructures
 * \{ */
/** \brief MTL Rx Queue Configuration
 */
typedef struct
{
    boolean              enable;                                /**< \brief Enable the Rx Queue. Default is Generic mode. Also set enableAudioVideoBridge to TRUE for AVB mode. */
    uint8                rxQueueSize;                           /**< \brief Size of Rx Queue in MTL. Size = (Value+1)*256 Bytes. Range of Value: 0-31 */
    IfxLeth_RxDmaChannel rxDmaChannelMap;                       /**< \brief Mapped DMA Channel of Rx Queue */
    boolean              rxQueueOverflowInterruptEnabled;       /**< \brief Enable/Disable Rx Queue Overflow Interrupt */
    IfxLeth_QueueMode    mode;                                  /**< \brief Enable the Tx Queue in Generic or AV mode. Default is Generic mode. */
} IfxLeth_Eth_RxQueueConfig;

/** \brief MTL Tx Queue Configuration
 */
typedef struct
{
    boolean           enable;                                 /**< \brief Enable the Tx Queue. Default is Generic mode. */
    uint8             txQueueSize;                            /**< \brief Size of Tx Queue in MTL. Size = (Value+1)*256 Bytes. Range of Value: 0-63 */
    boolean           txQueueUnderflowInterruptEnabled;       /**< \brief Enable/Disable Tx Queue Underflow Interrupt */
    IfxLeth_QueueMode mode;                                   /**< \brief Enable the Tx Queue in Generic or AV mode. Default is Generic mode. */
} IfxLeth_Eth_TxQueueConfig;

/** \} */

/** \addtogroup IfxLld_Leth_Eth_DataStructures
 * \{ */
/** \brief Configuration Structure for the Bridge initialization
 */
typedef struct
{
    boolean enable;                                               /**< \brief Enable S/w configuration of Forwarding Features. TRUE: Forwarding features are configured, FALSE: Forwarding features are not configured */
    uint16  maxPacketLength;                                      /**< \brief Maximum Packet Length for the Port-to-Port Forwarding Traffic. The maximum value of this field is 0x7FFF */
    boolean disableErrorInjectForAllRxPacketErrorTypes;           /**< \brief Disable ATI Error Injection in the Forwarding Port for all Rx Packet Error types in the ingress port. - FALSE: ATI Error Injection Enabled, TRUE: ATI Error Injection Disabled */
    boolean enableErrorInjectForRxWithPayloadChecksumError;       /**< \brief ATI Error Injection Disable/Enable for packets with Payload Checksum Error - FALSE: Disabled, TRUE: Enabled */
    boolean enableErrorInjectForRxWithIpHeaderError;              /**< \brief ATI Error Injection Disable/Enable for packets with IP Header Error - FALSE: Disabled, TRUE: Enabled */
    boolean enableErrorInjectForGiantPackets;                     /**< \brief ATI Error Injection Disable/Enable for Giant packets - FALSE: Disabled, TRUE: Enabled */
    boolean enableErrorInjectForGoodRuntPackets;                  /**< \brief ATI Error Injection Disable/Enable for Good Runt packets - FALSE: Disabled, TRUE: Enabled */
    uint8   txBurstLength;                                        /**< \brief Transmit Programmable Burst Length. These bits indicate the maximum number of beats to be transferred in one ATI/ARI data transfer in the forwarding path. Valid values: 1, 2, 4, 8, 16, or 32 */
    uint8   enablePortForwardingPaths[IFXLETH_NUM_PORTS];         /**< \brief Indicates whether any of the TxQ[(tx queues in device -1):0] is a forwarding path. Set corresponding bit to 1 to enable forwarding path and also configure the port map in forwardPortMapForTxQueue i */
    uint8   forwardPortMapForTxQueue0[IFXLETH_NUM_PORTS];         /**< \brief Indicates the port number of the RxC to which TxQ0 connection is mapped as forwarding path. Valid range: 0 to (Max number of Ports - 1) */
    uint8   forwardPortMapForTxQueue1[IFXLETH_NUM_PORTS];         /**< \brief Indicates the port number of the RxC to which TxQ1 connection is mapped as forwarding path. Valid range: 0 to (Max number of Ports - 1) */
    uint8   forwardPortMapForTxQueue2[IFXLETH_NUM_PORTS];         /**< \brief Indicates the port number of the RxC to which TxQ2 connection is mapped as forwarding path. Valid range: 0 to (Max number of Ports - 1) */
    uint8   forwardPortMapForTxQueue3[IFXLETH_NUM_PORTS];         /**< \brief Indicates the port number of the RxC to which TxQ3 connection is mapped as forwarding path. Valid range: 0 to (Max number of Ports - 1) */
    uint8   forwardPortMapForTxQueue4[IFXLETH_NUM_PORTS];         /**< \brief Indicates the port number of the RxC to which TxQ4 connection is mapped as forwarding path. Valid range: 0 to (Max number of Ports - 1) */
    uint8   portTxWrrWeight[IFXLETH_NUM_PORTS];                   /**< \brief Indicates the weight and used as the number of data transfer cycles allocated to Port i in one arbitration cycle of the Tx WRR Arbiter in the forwarding path. Default vaule 0x40. */
    uint8   portRxWrrWeight[IFXLETH_NUM_PORTS];                   /**< \brief Indicates the weight and used as the number of interleaved PBL burst allocated to Port i in one arbitration cycle of the Rx WRR Arbiter in the forwarding path. Default vaule 0x40. */
} IfxLeth_Eth_BridgeForwardingConfig;

/** \brief Port Specific Configuration Structure as part of Bridge initialization
 * Contains TxQ and RxC enable configurations and mapping configurations of a Port
 */
typedef struct
{
    IfxLeth_TxQRxCEnableConfig enableTxQueuesAndRxChannels;          /**< \brief Port's enable configurations for TxQs and RxCs */
    IfxLeth_BridgeTxQueueMap   txMap[IFXLETH_NUM_TX_QUEUES];         /**< \brief Tx Queue Map */
    IfxLeth_BridgeRxCMap       rxMap[IFXLETH_NUM_RX_CHANNELS];       /**< \brief RxC Map */
} IfxLeth_Eth_Bridge_PortConfig;

/** \brief Configuration Structure for the MAC initialization
 */
typedef struct
{
    uint8                macAddress[6];                  /**< \brief MAC address for the ethernet, should be unique in the network. Here it configures MAC Address 0 */
    boolean              enableLoopback;                 /**< \brief Set to enable Mac Loopback, application must provide clock to Rx pin */
    boolean              duplexMode;                     /**< \brief 1: Full duplex, 0: Half duplex */
    boolean              disableCrcCheck;                /**< \brief 1: Disable CRC Checking for Received Packets, 0: Enable CRC Checking for Received Packets */
    IfxLeth_RxDmaChannel channelSelectMacAddress0;       /**< \brief DMA Channel Select for MAC Address 0 */
} IfxLeth_Eth_MacConfig;

/** \brief Configuration Structure for the DMA initialization
 */
typedef struct
{
    IfxLeth_Eth_TxQueueConfig txQueue[IFXLETH_NUM_TX_QUEUES];       /**< \brief Tx queue configurations of selected queues */
    IfxLeth_Eth_RxQueueConfig rxQueue[IFXLETH_NUM_RX_QUEUES];       /**< \brief Rx queue configurations of selected queues */
} IfxLeth_Eth_MtlConfig;

/** \brief Configuration structure for LETH nodes for multi channel
 */
typedef struct
{
    IfxLeth_InterruptConfig dmaTx[IFXLETH_NUM_TX_CHANNELS];       /**< \brief Interrupt config for Tx DMA channels */
    IfxLeth_InterruptConfig dmaRx[IFXLETH_NUM_RX_CHANNELS];       /**< \brief Interrupt config for Rx DMA channels */
} IfxLeth_Eth_MultiChannelInterruptConfig;

/** \brief Configuration structure for DMA rx channel
 */
typedef struct
{
    IfxLeth_RxDescrList   *rxDescrList;                  /**< \brief Pointer to RX descriptors in RAM. Descriptor must be at 32 bit aligned address. */
    uint32                *rxBuffer1StartAddress;        /**< \brief Start address of Rx Buffer 1 */
    uint16                 rxBuffer1Size;                /**< \brief Size of Rx Buffer 1 */
    boolean                channelEnable;                /**< \brief Rx DMA channel enable. Set to TRUE to configure the corresponding channel */
    IfxLeth_RxDmaChannel   channelId;                    /**< \brief Rx DMA channel Index */
    IfxLeth_DmaBurstLength maxBurstLength;               /**< \brief Maximum burst length of the channel */
} IfxLeth_Eth_RxChannelConfig;

/** \brief Configuration sturcture for DMA tx channel
 */
typedef struct
{
    IfxLeth_TxDescrList   *txDescrList;                  /**< \brief pointer to TX descriptors RAM. Note: The descriptor address from the start to the end of the ring must not cross the 4GB boundary. */
    uint32                *txBuffer1StartAddress;        /**< \brief Start address of Tx Buffer 1 */
    uint16                 txBuffer1Size;                /**< \brief Size of Tx Buffer 1 */
    boolean                channelEnable;                /**< \brief Tx DMA channel enable. Set to TRUE to configure the corresponding channel */
    IfxLeth_TxDmaChannel   channelId;                    /**< \brief Tx DMA channel Index */
    IfxLeth_DmaBurstLength maxBurstLength;               /**< \brief Maximum burst length of the channel */
    boolean                enableOSF;                    /**< \brief Enable/Disable Operate on Second Packet. 0:Disable, 1:Enable */
} IfxLeth_Eth_TxChannelConfig;

/** \} */

/** \addtogroup IfxLld_Leth_Eth_DataStructures
 * \{ */
/** \brief Configuration Structure for the Bridge initialization
 */
typedef struct
{
    IfxLeth_BridgePortMode             mode;                                /**< \brief Bridge Port Mode */
    IfxLeth_Eth_Bridge_PortConfig      portConfig[IFXLETH_NUM_PORTS];       /**< \brief Individual Port Specific Configuration */
    IfxLeth_Eth_BridgeForwardingConfig forwardingConfig;                    /**< \brief Configuration for forwarding features */
} IfxLeth_Eth_BridgeConfig;

/** \brief Configuration Structure for the DMA initialization
 */
typedef struct
{
    boolean                                 addressAlignedBeatsEnabled;               /**< \brief True: Enable/ False: Disable Address Aligned Burst Transfers */
    IfxLeth_Eth_TxChannelConfig             txChannel[IFXLETH_NUM_TX_CHANNELS];       /**< \brief Tx Channels configurations of selected Channels */
    IfxLeth_Eth_RxChannelConfig             rxChannel[IFXLETH_NUM_RX_CHANNELS];       /**< \brief Rx Channels configurations of selected Channels */
    IfxLeth_Eth_MultiChannelInterruptConfig interrupt;                                /**< \brief Interrupt Configuration structure for multi channel */
} IfxLeth_Eth_DmaConfig;

/** \brief Configure struct for the MMC counter
 * Refer the Ifx_LETH_PORT_CORE_MMC_CONTROL SFR's for more info
 */
typedef struct
{
    boolean counterReset;                       /**< \brief Parameter to enable the MMC counter reset */
    boolean counterStopRollover;                /**< \brief parameter to enable MMC counter stop roll over */
    boolean counterResetOnRead;                 /**< \brief parameter MMC counter enable reset on read */
    boolean counterPreset;                      /**< \brief parameter to configure Counters Preset */
    boolean counterFullHalfPreset;              /**< \brief parameter to configure full half Counters Preset */
    boolean counterUpdateBroadcastPacket;       /**< \brief parameter to configure Update MMC Counters for Dropped Broadcast Packets */
} IfxLeth_Eth_MmcControlConfig;

/** \brief Config struct for MMC Interrupt Enable and Mask
 * Refer the MMC_TRANSMIT_INTERRUPT_ENABLE,MMC_RECEIVE_INTERRUPT_ENABLE,MMC_FPE_TX_INTERRUPT_MASK,MMC_FPE_RX_INTERRUPT_MASK for more info
 */
typedef struct
{
    Ifx_LETH_PORT_CORE_MMC_RX_INTERRUPT          rxInterruptEnable;        /**< \brief Parameter to configure the RX interrupt enable */
    Ifx_LETH_PORT_CORE_MMC_RX_INTERRUPT_MASK     rxInterruptMask;          /**< \brief Parameter to configure the RX interrupt Mask */
    Ifx_LETH_PORT_CORE_MMC_TX_INTERRUPT          txInterruptEnable;        /**< \brief Parameter to configure the TX interrupt enable */
    Ifx_LETH_PORT_CORE_MMC_TX_INTERRUPT_MASK     txInterruptMask;          /**< \brief Parameter to configure the TX interrupt Mask */
    Ifx_LETH_PORT_CORE_MMC_IPC_RX_INTERRUPT_MASK rxIpcInterruptMask;       /**< \brief Parameter to configure the ICP RX interrupt Mask */
    Ifx_LETH_PORT_CORE_MMC_IPC_RX_INTERRUPT      rxIpcInterrupt;           /**< \brief Parameter to configure the ICP RX interrupt */
} IfxLeth_Eth_MmcInterruptConfig;

/** \brief Configuration Structure for the Port initialization (1 MAC + 1 MTL per PORT)
 */
typedef struct
{
    boolean               enable;                 /**< \brief Set to TRUE to enable the port */
    IfxLeth_PhyInterface  phyInterfaceMode;       /**< \brief External Phy Interface Mode */
    IfxLeth_Eth_MacConfig mac;                    /**< \brief Configuration Structure for the the MAC initialization */
    IfxLeth_Eth_MtlConfig mtl;                    /**< \brief Configuration Structure for the MTL initialization */
} IfxLeth_Eth_PortConfig;

/** \brief Handle structure for DMA Rx channel
 */
typedef struct
{
    IfxLeth_RxDmaChannel      channelId;           /**< \brief Rx DMA channel Index */
    IfxLeth_RxDescrList      *rxDescrList;         /**< \brief pointer to Rx descriptors RAM */
    volatile IfxLeth_RxDescr *rxDescrPtr;          /**< \brief Pointer to Rx Descriptor (current descriptor) */
    uint32                    rxCount;             /**< \brief Number of frames received */
    uint32                    buffer1Address;      /**< \brief Rx Buffer 1 Address. Stored during call of IfxLeth_Eth_initReceiveDescriptors or IfxLeth_Eth_singlePortInit in case of single port */
    uint32                    bufferSize;          /**< \brief Size of Rx Buffer. Stored during call of IfxLeth_Eth_initReceiveDescriptors or IfxLeth_Eth_singlePortInit in case of single port */
} IfxLeth_Eth_RxChannel;

/** \brief Configuration structure for LETH nodes for single channel
 */
typedef struct
{
    IfxLeth_InterruptConfig dmaTx0;       /**< \brief Interrupt config for Tx DMA channel 0 */
    IfxLeth_InterruptConfig dmaRx0;       /**< \brief Interrupt config for Rx DMA channel 0 */
    IfxLeth_InterruptConfig mtl;          /**< \brief Interrupt config for MTL */
} IfxLeth_Eth_SingleChannelInterruptConfig;

/** \brief handle structure for DMA Tx channel
 */
typedef struct
{
    IfxLeth_TxDmaChannel      channelId;           /**< \brief Tx DMA channel Index */
    IfxLeth_TxDescrList      *txDescrList;         /**< \brief pointer to Tx descriptors RAM */
    volatile IfxLeth_TxDescr *txDescrPtr;          /**< \brief Pointer to Tx Descriptor (current descriptor) */
    uint32                    txCount;             /**< \brief Number of frames transmitted */
    uint32                    buffer1Address;      /**< \brief Tx Buffer 1 Address. Stored during call of IfxLeth_Eth_initReceiveDescriptors */
    uint32                    txBuf1Size;          /**< \brief configured tx buffer 1 size */
} IfxLeth_Eth_TxChannel;

/** \} */

/** \addtogroup IfxLld_Leth_Eth_DataStructures
 * \{ */
/** \brief Configuration Structure for the Module initialization
 */
typedef struct
{
    Ifx_LETH                *lethSFR;                       /**< \brief Pointer to LETH register base address */
    IfxLeth_Eth_PortConfig   port[IFXLETH_NUM_PORTS];       /**< \brief Configuration Structure for the Port initialization (1 MAC + 1 MTL per PORT) */
    IfxLeth_InterruptConfig  interrupt;                     /**< \brief Interrupt Configuration structure for all ports (mac interrupts) */
    IfxLeth_Eth_DmaConfig    dma;                           /**< \brief Configuration Structure for the DMA initialization */
    IfxLeth_Eth_BridgeConfig bridge;                        /**< \brief Configuration Structure for the Bridge initialization */
} IfxLeth_Eth_Config;

/** \brief Configuration Structure for the MDIO initialization
 */
typedef struct
{
    boolean                      skipAddrPacket;            /**< \brief TRUE : Skip address field in MDIO clause 45 frame, FALSE : Address field is send in MDIO clause 45 frame */
    boolean                      backToBackTransc;          /**< \brief TRUE : Back to back transfer of MDIO frame, FALSE : Disable BTB transfer Note: Applicable only if parameter "mdioTrailClkCycles > 0" */
    boolean                      preambleSuppression;       /**< \brief TRUE : Preamble value of 32bit 1's is suppressed an only 1 bit of preamble is tx, FALSE : 32bits of 1's are tx as preamble */
    boolean                      registerAccessType;        /**< \brief TRUE : XCVR registers access through MDIO serial interface, FALSE : MDIO register space is for 10BASE-T1S (PLCA/PMA/PCS) registers */
    IfxLeth_MdioAppClockRangeSel appClockRangeSel;          /**< \brief Clock range selection to configure MDC freq */
    IfxLeth_MdioTrailClkCycles   trailClkCycles;            /**< \brief To configure number of trailing clock cycles post MDIO transaction */
} IfxLeth_Eth_MdioConfig;

/** \brief MMC configure structure
 * Refer the IfxLeth_Eth_MmcInterruptConfig and IfxLeth_Eth_MmcControlConfig structures for details
 */
typedef struct
{
    IfxLeth_Eth_MmcControlConfig   controlConfig;         /**< \brief Parameter to configure MMC control struct */
    IfxLeth_Eth_MmcInterruptConfig interruptConfig;       /**< \brief parameter to configure the mmc Interrupt struct */
} IfxLeth_Eth_MmcConfig;

/** \brief structure to store the MMC counter register's read value
 * Refer to MMC counter registers in IfxLeth_regdef.h file for more info
 */
typedef struct
{
    uint32 txOctetCountGoodBad;                    /**< \brief counter value for Tx Octet Count Good Bad  and High */
    uint32 txPacketCountGoodBad;                   /**< \brief counter value for Tx Packet Count Good Bad */
    uint32 txBroadcastPacketsGood;                 /**< \brief counter value for Tx Broadcast Packets Good */
    uint32 txMulticastPacketsGood;                 /**< \brief counter value for Tx Multicast Packets Good */
    uint32 tx64OctetsPacketsGoodBad;               /**< \brief counter value for Tx 64Octets Packets Good Bad */
    uint32 tx65to127OctetsPacketsGoodBad;          /**< \brief counter value for Tx 65To127Octets Packets Good Bad */
    uint32 tx128to255OctetsPacketsGoodBad;         /**< \brief counter value for Tx 128To255Octets Packets Good Bad */
    uint32 tx256to511OctetsPacketsGoodBad;         /**< \brief counter value for Tx 256To511Octets Packets Good Bad */
    uint32 tx512to1023OctetsPacketsGoodBad;        /**< \brief counter value for Tx 512To1023Octets Packets Good Bad */
    uint32 tx1024toMaxOctetsPacketsGoodBad;        /**< \brief counter value for Tx 1024ToMaxOctets Packets Good Bad */
    uint32 txUnicastPacketsGoodBad;                /**< \brief counter value for Tx Unicast Packets Good Bad */
    uint32 txMulticastPacketsGoodBad;              /**< \brief counter value for Tx Multicast Packets Good Bad */
    uint32 txBroadcastPacketsGoodBad;              /**< \brief counter value for Tx Broadcast Packets Good Bad */
    uint32 txUnderflowErrorPackets;                /**< \brief counter value for Underflow Error Packets */
    uint32 txSingleCollisonGoodPockets;            /**< \brief Tx Single Collision Good Packets */
    uint32 txMultipleCollisionGoodPackets;         /**< \brief counter value for Tx Multiple Collision Good Packets */
    uint32 txDeferredPackets;                      /**< \brief counter value for Tx Deferred Packets */
    uint32 txLateCollisionPackets;                 /**< \brief counter value for Tx Late Collision Packets */
    uint32 txExcessiveCollisionPackets;            /**< \brief counter value for Tx Excessive Collision Packets */
    uint32 txCarrierErrorPackets;                  /**< \brief counter value for Tx Carrier Error Packets */
    uint32 txOctetCountGood;                       /**< \brief counter value for Tx Octet Count Good  and High */
    uint32 txPacketCountGood;                      /**< \brief counter value for Tx Packet Count Good */
    uint32 txExcessiveDeferralError;               /**< \brief counter value for Tx Excessive Deferral Error */
    uint32 txPausePackets;                         /**< \brief counter value for Tx Pause Packets */
    uint32 txVlanPacketsGood;                      /**< \brief counter value for Tx VLAN Packets Good */
    uint32 txOsizePacketsGood;                     /**< \brief Tx OSize Packets Good */
    uint32 rxPacketCountGoodBad;                   /**< \brief counter value for Rx Packet Count Good Bad */
    uint32 rxOctetCountGoodBad;                    /**< \brief counter value for Rx Octet Count Good Bad Low and High */
    uint32 rxOctetCountGood;                       /**< \brief counter value for Rx Octet Count Good Low and High */
    uint32 rxBroadcastPacketsGood;                 /**< \brief counter value for Rx Broadcast Packets Good */
    uint32 rxMulticastPacketsGood;                 /**< \brief counter value for Rx Multicast Packets Good */
    uint32 rxCrcErrorPackets;                      /**< \brief counter value for Rx CRC Error Packets */
    uint32 rxAlignmentErrorPackets;                /**< \brief Rx Alignment Error Packets */
    uint32 rxRuntErrorPackets;                     /**< \brief counter value for Rx Runt Error Packets */
    uint32 rxJabberErrorPackets;                   /**< \brief counter value for Rx Jabber Error Packets */
    uint32 rxUndersizePacketsGood;                 /**< \brief counter value for Rx Undersize Packets Good */
    uint32 rxOversizePacketsGood;                  /**< \brief counter value for Rx Oversize Packets Good */
    uint32 rx64OctetsPacketsGoodBad;               /**< \brief counter value for Rx 64Octets Packets Good Bad */
    uint32 rx65to127OctetsPacketsGoodBad;          /**< \brief counter value for Rx 65To127Octets Packets Good Bad */
    uint32 rx128to255OctetsPacketsGoodBad;         /**< \brief counter value for Rx 128To255Octets Packets Good Bad */
    uint32 rx256to511OctetsPacketsGoodBad;         /**< \brief counter value for Rx 256To511Octets Packets Good Bad */
    uint32 rx512to1023OctetsPacketsGoodBad;        /**< \brief counter value for Rx 512To1023Octets Packets Good Bad */
    uint32 rx1024toMaxOctetsGoodBad;               /**< \brief counter value for Rx 1024ToMaxOctets Packets Good Bad */
    uint32 rxUnicastPacketsGood;                   /**< \brief counter value for Rx Unicast Packets Good */
    uint32 rxLengthErrorPackets;                   /**< \brief counter value for Rx Length Error Packets */
    uint32 rxOutOfRangeTypePackets;                /**< \brief counter value for Rx OutofRange Packets */
    uint32 rxPausePackets;                         /**< \brief counter value for Rx Pause Packets */
    uint32 rxFifoOverflowPackets;                  /**< \brief counter value for Rx FIFOOverflow Packets */
    uint32 rxVlanPacketsGoodBad;                   /**< \brief counter value for Rx VLAN Packets Good Bad */
    uint32 rxWatchdogErrorPackets;                 /**< \brief counter value for Rx Watchdog Error Packets */
    uint32 receiveErrorPackets;                    /**< \brief Rx Receive Error Packets */
    uint32 rxControlPacketsGood;                   /**< \brief Rx Control Packets Good */
    uint32 rxIpV4GoodPackets;                      /**< \brief counter value for RxIPv4 Good Packets */
    uint32 rxIpV4HeaderErrorPackets;               /**< \brief counter value for RxIPv4 Header Error Packets */
    uint32 rxIpV4NoPayloadPackets;                 /**< \brief counter value for RxIPv4 No Payload Packets */
    uint32 rxIpV4FragmentedPackets;                /**< \brief counter value for RxIPv4 Fragmented Packets */
    uint32 rxIpV4UdpChecksumDisabledPackets;       /**< \brief counter value for RxIPv4 UDP Checksum Disabled Packets */
    uint32 rxIpV6GoodPackets;                      /**< \brief counter value for RxIPv6 Good Packets */
    uint32 rxIpV6HeaderErrorPackets;               /**< \brief counter value for RxIPv6 Header Error Packets */
    uint32 rxIpV6NoPayloadPackets;                 /**< \brief counter value for RxIPv6 No Payload Packets */
    uint32 rxUdpRxUdpGoodPackets;                  /**< \brief counter value for RxUDP Good Packets */
    uint32 rxUdpErrorPackets;                      /**< \brief counter value for RxUDP Error Packets */
    uint32 rxTcpGoodPackets;                       /**< \brief counter value for RxTCP Good Packets */
    uint32 rxTcpErrorPackets;                      /**< \brief counter value for RxTCP Error Packets */
    uint32 rxIcmpGoodPackets;                      /**< \brief counter value for RxICMP Good Packets */
    uint32 rxIcmpErrorPackets;                     /**< \brief counter value for RxICMP Error Packets */
    uint32 rxIpV4GoodOctets;                       /**< \brief counter value for RxIPv4 Good Octets */
    uint32 rxIpV4HeaderErrorOctets;                /**< \brief counter value for RxIPv4 Header Error Octets */
    uint32 rxIpV4NoPayloadOctets;                  /**< \brief counter value for RxIPv4 No Payload Octets */
    uint32 rxIpV4FragmentedOctets;                 /**< \brief counter value for RxIPv4 Fragmented Octets */
    uint32 rxIpV4UdpChecksumDisableOctets;         /**< \brief counter value for RxIPv4 UDP Checksum Disable Octets */
    uint32 rxIpV6GoodOctets;                       /**< \brief counter value for RxIPv6 Good Octets */
    uint32 rxIpV6HeaderErrorOctets;                /**< \brief counter value for RxIPv6 Header Error Octets */
    uint32 rxIpV6NopayloadOctets;                  /**< \brief counter value for RxIPv6 No Payload Octets */
    uint32 rxUdpGoodOctets;                        /**< \brief counter value for RxUDP Good Octets */
    uint32 rxUdpErrorOctets;                       /**< \brief counter value for RxUDP Error Octets */
    uint32 rxTcpGoodOctets;                        /**< \brief counter value for RxTCP Good Octets */
    uint32 rxTcpErrorOctets;                       /**< \brief counter value for RxTCP Error Octets */
    uint32 rxIcmpGoodOctets;                       /**< \brief counter value for RxICMP Good Octets */
    uint32 rxIcmpErrorOctets;                      /**< \brief counter value for RxICMP Error Octets */
} IfxLeth_Eth_MmcCounters;

/** \brief LETH Single port Scenario Configuration Structure
 */
typedef struct
{
    Ifx_LETH                                *lethSFR;                                /**< \brief Pointer to LETH register base address. Keeping for compatibility. */
    IfxLeth_PhyInterface                     interface;                              /**< \brief Phy Interface and Speed in Mbps */
    uint8                                    macAddress[6];                          /**< \brief MAC address for the ethernet, should be unique in the network. Here it configures MAC Address 0 */
    boolean                                  enableLoopback;                         /**< \brief Set to enable Mac Loopback, application must provide clock to Rx pin */
    boolean                                  duplexMode;                             /**< \brief 1: Full duplex, 0: Half duplex */
    boolean                                  disableCrcCheck;                        /**< \brief 1: Disable CRC Checking for Received Packets, 0: Enable CRC Checking for Received Packets */
    uint8                                    txQueueSize;                            /**< \brief Size of Tx Queue in MTL. Size = (Value+1)*256 Bytes. Range of Value: 0-63 */
    uint8                                    rxQueueSize;                            /**< \brief Size of Rx Queue in MTL. Size = (Value+1)*256 Bytes. Range of Value: 0-31 */
    IfxLeth_Eth_TxChannelConfig              txConfigChannel0;                       /**< \brief Tx Channel 0 Config */
    IfxLeth_Eth_RxChannelConfig              rxConfigChannel0;                       /**< \brief Rx Channel 0 Config */
    IfxLeth_Eth_SingleChannelInterruptConfig interruptConfig;                        /**< \brief Interrupt configuration for 1 channel */
    boolean                                  txQueueUnderflowInterruptEnabled;       /**< \brief Enable/Disable Tx Queue Underflow Interrupt */
    boolean                                  rxQueueOverflowInterruptEnabled;        /**< \brief Enable/Disable Rx Queue Overflow Interrupt */
    boolean                                  enableOSF;                              /**< \brief Enable/Disable Operate on Second Packet. 0:Disable, 1:Enable */
} IfxLeth_Eth_SinglePortConfig;

/** \brief Configuration Structure for the MTL Tx Queue Priority Configuration
 */
typedef struct
{
    IfxLeth_AvAlgorithm  algo;                  /**< \brief MTL Tx Queue AV algorithm selection */
    uint8                quantumWeight;         /**< \brief Used In SP mode, Weight for WRR algorithm. Value indicates fraction of the bandwidth allocated to queue. Refer to MTL_TXQ1_QUANTUM_WEIGHT.B.ISCQW */
    boolean              creditControl;         /**< \brief Used In CBS mode, True: Credit Control is enabled, False: Credit Control is disabled */
    IfxLeth_CbsSlotCount slotCount;             /**< \brief Used In CBS mode, Number of slots in CBS algorithm */
    uint16               sendSlopeCredit;       /**< \brief Used In CBS mode, Send Slope Credit Value in CBS algorithm. Refer to MTL_TXQ1_SENDSLOPECREDIT.B.SSC */
    uint32               hiCredit;              /**< \brief Used In CBS mode, Max Credit Value in CBS algorithm. Refer to MTL_TXQ1_HICREDIT.B.HC */
    uint32               loCredit;              /**< \brief Used In CBS mode, Min Credit Value in CBS algorithm. Refer to MTL_TXQ1_LOCREDIT.B.LC */
    uint32               idleSlopeCredit;       /**< \brief Used In CBS mode, Idle Slope Credit Value in CBS algorithm. Refer to MTL_TXQ1_QUANTUM_WEIGHT.B.ISCQW */
} IfxLeth_Eth_TxQueuePriorityConfig;

/** \} */

/** \brief LETH driver Handle
 */
typedef struct
{
    Ifx_LETH             *lethSFR;                                  /**< \brief Pointer to LETH register base address. Keeping for compatibility. */
    IfxLeth_Eth_TxChannel txChannel[IFXLETH_NUM_TX_CHANNELS];       /**< \brief Tx Channels handle of selected Channels */
    IfxLeth_Eth_RxChannel rxChannel[IFXLETH_NUM_RX_CHANNELS];       /**< \brief Rx Channels handle of selected Channels */
} IfxLeth_Eth;

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the pointer to current RX descriptor
 * \param leth LETH driver Handle
 * \param channelId Rx channel Id
 * \return pointer to base RX descriptor in the list
 *
 * \code
 *    // IfxLeth_Eth leth; // assumed to be defined globally
 *
 *    IfxLeth_RxDescr  *descr = IfxLeth_Eth_getActualRxDescriptor(&leth, IfxLeth_RxDmaChannel_0);
 *    \endcode
 */
IFX_INLINE volatile IfxLeth_RxDescr *IfxLeth_Eth_getActualRxDescriptor(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId);

/** \brief Returns the pointer to current TX descriptor
 * \param leth LETH driver Handle
 * \param channelId Tx channel Id
 * \return pointer to base TX descriptor in the list
 *
 * \code
 *    // IfxLeth_Eth leth; // assumed to be defined globally
 *
 *    IfxLeth_TxDescr *descr = IfxLeth_Eth_getActualTxDescriptor(&leth, IfxLeth_TxDmaChannel_0);
 *    \endcode
 */
IFX_INLINE volatile IfxLeth_TxDescr *IfxLeth_Eth_getActualTxDescriptor(IfxLeth_Eth *leth, IfxLeth_TxDmaChannel channelId);

/** \brief Checks whether RX data is available
 * \param leth LETH driver Handle
 * \param channelId Rx channel Id
 * \return TRUE : RX data available
 * FALSE: if Rx data not available
 *
 * \code
 * // IfxLeth_Eth leth; // assumed to be defined globally
 *
 * boolean status = IfxLeth_Eth_isRxDataAvailable(&leth, IfxLeth_RxDmaChannel_0);
 * \endcode
 */
IFX_INLINE boolean IfxLeth_Eth_isRxDataAvailable(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId);

/** \brief Returns the pointer to base TX descriptor in the list
 * \param leth LETH driver Handle
 * \param channelId Tx channel Id
 * \return pointer to base TX descriptor in the list
 *
 * \code
 *    // IfxLeth_Eth leth; // assumed to be defined globally
 *
 *    IfxLeth_TxDescr *descr = IfxLeth_Eth_getBaseTxDescriptor(&leth, IfxLeth_TxDmaChannel_0);
 *    \endcode
 */
IFX_INLINE volatile IfxLeth_TxDescr *IfxLeth_Eth_getBaseTxDescriptor(IfxLeth_Eth *leth, IfxLeth_TxDmaChannel channelId);

/** \brief Returns the pointer to base RX descriptor in the list
 * \param leth LETH driver Handle
 * \param channelId Rx channel Id
 * \return pointer to base RX descriptor in the list
 *
 * \code
 * // IfxLeth_Eth leth; // assumed to be defined globally
 *
 * IfxLeth_RxDescr *descr = IfxLeth_Eth_getBaseRxDescriptor(&leth, IfxLeth_RxDmaChannel_0);
 * \endcode
 */
IFX_INLINE volatile IfxLeth_RxDescr *IfxLeth_Eth_getBaseRxDescriptor(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief writes the header format into buffer
 * \param txBuffer pointer to tx buffer
 * \param destinationAddress pointer to destination address
 * \param sourceAddress pointer to source address
 * \param payloadLength size of the payload
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_writeHeader(uint8 *txBuffer, uint8 *destinationAddress, uint8 *sourceAddress, uint32 payloadLength);

/** \brief Start the Receiver functions of MAC and selected channel of DMA
 * \param portIndex Index of Port
 * \param channelId Rx channel Id
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_startReceiver(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_RxDmaChannel channelId);

/** \brief Start the Transmitter functions of MAC and selected channel of DMA
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_startTransmitter(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_TxDmaChannel channelId);

/** \brief Initialises the config structure with default values for single channel
 *   \code
 *   IfxLeth_Eth_SinglePortConfig config;
 *   IfxLeth_Eth_singlePortInitConfig(&config, &MODULE_LETH0);
 *   \endcode
 *
 *   By default Port0 (DMA (Tx0 & RX0), MTL (TXQ0 &RXQ0)) is enabled and bridge is configured to IfxLeth_BridgePortMode_singlePort0 mode.
 * \param config Configuration Structure for the Single Port Single Channel module initialization
 * \param lethSFR Pointer to LETH register base address
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_singlePortInitConfig(IfxLeth_Eth_SinglePortConfig *config, Ifx_LETH *lethSFR);

/** \brief Initialises LETH for any given Single Port, single DMA channel 0 configuration
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param config single port configuration
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_singlePortInit(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_Eth_SinglePortConfig *config);

/** \brief Initialises the Tx descriptors of a single channel
 * \param leth LETH driver Handle
 * \param config Tx channel configuration
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initTransmitDescriptors(IfxLeth_Eth *leth, IfxLeth_Eth_TxChannelConfig *config);

/** \brief Initialises the Rx descriptors of a single channel
 * \param leth LETH driver Handle
 * \param config Rx channel configuration
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initReceiveDescriptors(IfxLeth_Eth *leth, IfxLeth_Eth_RxChannelConfig *config);

/** \brief Updates the current Tx descriptor pointer in the handle to next Tx descriptor
 *  \code
 *      // IfxLeth_Eth leth; // assumed to be defined globally
 *
 *      IfxLeth_Eth_shuffleTxDescriptor(&leth, IfxLeth_TxDmaChannel_0);
 *      \endcode
 * \param leth LETH driver Handle
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_shuffleTxDescriptor(IfxLeth_Eth *leth, IfxLeth_TxDmaChannel channelId);

/** \brief Updates the current Rx descriptor pointer in the handle to next Rx descriptor
 *   \code
 *      // IfxLeth_Eth leth; // assumed to be defined globally
 *
 *      IfxLeth_Eth_shuffleRxDescriptor(&leth, IfxLeth_RxDmaChannel_0);
 *      \endcode
 * \param leth LETH driver Handle
 * \param channelId Rx channel Id
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_shuffleRxDescriptor(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId);

/** \brief Transmits a frame from a single channel
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param packetLength Length of the packet to be transmitted in bytes
 * \param channelId Tx channel Id
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_sendTransmitBuffer(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, uint32 packetLength, IfxLeth_TxDmaChannel channelId);

/** \brief Configures the MAC core
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure for the MAC initialization
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_configureMacCore(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_Eth_MacConfig *config);

/** \brief Configures all the DMA Channels and initializes the DMA
 * \param leth LETH driver Handle
 * \param config Configuration Structure for the DMA initialization
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_configureDMA(IfxLeth_Eth *leth, IfxLeth_Eth_DmaConfig *config);

/** \brief Configures the MTL
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure for the MTL initialization
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_configureMTL(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_Eth_MtlConfig *config);

/** \brief Configures the Bridge
 *   \code
 *      // IfxLeth_Eth leth; // assumed to be defined globally
 *      IfxLeth_Eth_Config config;
 *
 *      IfxLeth_Eth_initModuleConfig(&config, &MODULE_LETH0);
 *      //Update bridge parameters as required using config.bridge .
 *
 *      //Single Port Config:
 *
 *      config.bridge.mode = IfxLeth_BridgePortMode_singlePort0; //Use any of the available port. In single port mode, interface from DMA connects to selected port's MTL interface directly.
 *
 *      IfxLeth_Eth_initModule(&leth, &config); // Bridge init is part of IfxLeth_Eth_initModule.
 *
 *        //Multi Port Config:
 *
 *        //If you want to connect DMA TX0, RX0 to port 0 and DMA TX1, RX1 to port 1. Example scenario in comments.
 *
 *        config.bridge.mode = IfxLeth_BridgePortMode_multiPort;
 *
 *        //Additional mapping is required in multiport mode to each port.
 *        config.bridge.portConfig[0].enableTxQueuesAndRxChannels.txQueues = 1;   // Bridge P0 TXQ0 -> Port 0 MTL TX0 -> Port0 MAC
 *        config.bridge.portConfig[0].enableTxQueuesAndRxChannels.rxChannels = 1; // Port0 MAC -> Port 0 MTL RX0 -> Bridge P0 RXC0
 *        config.bridge.portConfig[0].txMap[0].IfxLeth_BridgeTxQueueMap_TxDma0;   // DMA TX0 -> Bridge P0 TXQ0
 *        config.bridge.portConfig[0].rxMap[0].IfxLeth_BridgeRxCMap_RxDma0;       // Bridge P0 RXC0 -> DMA RX0
 *
 *        config.bridge.portConfig[1].enableTxQueuesAndRxChannels.txQueues = 1;   // Bridge P1 TXQ0 -> Port 1 MTL TX0 -> Port1 MAC
 *        config.bridge.portConfig[1].enableTxQueuesAndRxChannels.rxChannels = 1; // Port1 MAC -> Port 1 MTL RX0 -> Bridge P1 RXC0
 *        config.bridge.portConfig[1].txMap[0].IfxLeth_BridgeTxQueueMap_TxDma1;   // DMA TX1 -> Bridge P1 TXQ0
 *        config.bridge.portConfig[1].rxMap[0].IfxLeth_BridgeRxCMap_RxDma1;       // Bridge P1 RXC0 -> DMA RX1
 *
 *        IfxLeth_Eth_initModule(&leth, &config); // Bridge init is part of IfxLeth_Eth_initModule.
 *
 *      //For Stand-alone bridge init.
 *
 *      IfxLeth_Eth_BridgeConfig bridgeConfig;
 *      IfxLeth_Eth_initBridgeConfig(&bridgeConfig);
 *
 *      //Update bridgeConfig parameters as required similar to above example.
 *
 *      IfxLeth_Eth_initBridge(&leth, &bridgeConfig);
 *
 *      \endcode
 * \param leth LETH driver Handle
 * \param config Configuration Structure for the Bridge initialisation
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initBridge(IfxLeth_Eth *leth, IfxLeth_Eth_BridgeConfig *config);

/** \brief Initializes the bridge configuration structure with default values
 *   \code
 *      \\For stand-alone bridge init
 *      IfxLeth_Eth_BridgeConfig config;
 *      IfxLeth_Eth_initBridgeConfig(&config);
 *      \\Default configuration is Single Port Mode using Port 0
 *      \endcode
 * \param config Configuration Structure for the Bridge initialization
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initBridgeConfig(IfxLeth_Eth_BridgeConfig *config);

/** \brief Initialises the config structure with default values
 *   \code
 *   IfxLeth_Eth_Config config;
 *   IfxLeth_Eth_initModuleConfig(&config, &MODULE_LETH0);
 *   \endcode
 *
 *   By default Port0 is enabled and bridge is configured to IfxLeth_BridgePortMode_singlePort0 mode.
 * \param config Configuration Structure for the Module initialisation
 * \param lethSFR Pointer to LETH register base address
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initModuleConfig(IfxLeth_Eth_Config *config, Ifx_LETH *lethSFR);

/** \brief Initialises the Leth Module with given configuration
 *   \code
 *   // IfxLeth_Eth leth; // assumed to be defined globally
 *   IfxLeth_Eth_Config config;
 *
 *   IfxLeth_Eth_initModuleConfig(&config, &MODULE_LETH0);
 *   // Change config parameters if required as per application use case.
 *   IfxLeth_Eth_initModule(&leth, &config);
 *   \endcode
 * \param leth LETH driver Handle
 * \param config Configuration Structure for the Module initialisation
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initModule(IfxLeth_Eth *leth, IfxLeth_Eth_Config *config);

/** \brief Gets receive buffer\n
 * \param leth LETH driver Handle
 * \param channelId Rx channel Id
 * \return retval NULL_PTR no received frame
 * retval !NULL_PTR a frame has been received
 *
 * \code
 * // IfxLeth_Eth leth; // assumed to be defined globally
 *
 * uint8 *pRxBuf = (uint8*)IfxLeth_Eth_getReceiveBuffer(&leth, IfxLeth_RxDmaChannel_0);
 *
 * // Call IfxLeth_Eth_shuffleRxDescriptor(&leth, IfxLeth_RxDmaChannel_0); after receiving data from the given rx channel.
 * \endcode
 */
IFX_EXTERN void *IfxLeth_Eth_getReceiveBuffer(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId);

/** \brief Get the transmit buffer pointer of current descriptor
 * \param leth LETH driver Handle
 * \param channelId Tx channel Id
 * \return retval NULL_PTR no free transmit buffer is available
 * retval !NULL_PTR a free transmit buffer is available
 */
IFX_EXTERN void *IfxLeth_Eth_getTransmitBuffer(IfxLeth_Eth *leth, IfxLeth_TxDmaChannel channelId);

/** \brief Init for MDIO clause 22 and 45 frame format
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param config Configuration Structure for the MDIO init
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initMdio(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_Eth_MdioConfig *config);

/** \brief Configures the MDIO clause 22 write
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param phyAddress Phy address within the device
 * \param regAddress Register address in the PHY to which write is to be performed
 * \param data Data write to be performed on the register address in regAddress param
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_mdio_write_clause22(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 regAddress, uint16 data);

/** \brief Configures the MDIO clause 22 read
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param phyAddress Phy address within the device
 * \param regAddress Register address in the PHY to which read is to be performed
 * \return data data read for the specified address
 */
IFX_EXTERN uint16 IfxLeth_Eth_mdio_read_clause22(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 regAddress);

/** \brief Configures the MDIO clause 45 write
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param phyAddress Phy address within the device
 * \param devAddress device address
 * \param regAddress Register address in the PHY to which read is to be performed
 * \param data Data write to be performed on the register address in addr param
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_mdio_write_clause45(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, uint16 data);

/** \brief Configures the MDIO clause 45 read
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param phyAddress Phy address within the device
 * \param devAddress device address
 * \param regAddress Register address in the PHY to which read is to be performed
 * \param opMode Specify the MDIO read modes i.e. Read only & Post Read Increment addr mode
 * \return data data read for the specified address
 */
IFX_EXTERN uint16 IfxLeth_Eth_mdio_read_clause45(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, uint8 phyAddress, uint8 devAddress, uint16 regAddress, IfxLeth_MdioClause45ReadMode opMode);

/** \brief API for MMC Initialization
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param mmcConfig to configure the MMC control and interrupt register's
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_initMmc(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_Eth_MmcConfig *mmcConfig);

/** \brief API to read the values of all MMC counters. The API will also clear all the MMC interrupt status bits if reset on read MMC_CONTROL.B.RSTONRD = 1 is enabled
 *   \code
 *          // To freeze the MMC counter register to there current value
 *          IfxLeth_Eth_enableMmcCounterFreeze(LethSFR, IfxLeth_PortIndex_0, TRUE);
 *
 *          //variable to store the MMC counter register read values
 *          IfxLeth_Eth_MmcCounters mmcCounter;
 *
 *          //Invoke the below API to populate the MMC counter values into the "mmcCounter" Variable
 *          IfxLeth_Eth_readMmcCounters(leth, IfxLeth_PortIndex_0, &mmcCounter);
 *
 *          //If the parameter "counterResetOnRead" is configured as TRUE before invoking the mmc init API i.e IfxLeth_Eth_initMmc() :
 *              //counter are cleared by default
 *
 *          //Else the below API needs to be invoked explicitly i.e IfxLeth_Eth_resetMmcCounter()
 *              IfxLeth_Eth_resetMmcCounter(lethSFR, IfxLeth_PortIndex_0);
 *
 *
 *      \endcode
 * \param leth LETH driver Handle
 * \param portIndex port index
 * \param mmcCounters pointer reference for counter values
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_readMmcCounters(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_Eth_MmcCounters *mmcCounters);

/** \brief Configure MTL Tx Queue Priority for given queue and port
 * \param leth LETH driver Handle
 * \param portIndex Index of Port
 * \param txQueueIndex MTL Tx Queue Index
 * \param config Configuration Structure for Tx Queue Priority
 * \return None
 */
IFX_EXTERN void IfxLeth_Eth_configureTxQueuePriority(IfxLeth_Eth *leth, IfxLeth_PortIndex portIndex, IfxLeth_TxMtlQueue txQueueIndex, IfxLeth_Eth_TxQueuePriorityConfig *config);
/** \addtogroup IfxLld_Leth_Eth_Variables
 * \{ */

/******************************************************************************/
/*-------------------Global Exported Variables/Constants----------------------*/
/******************************************************************************/
/** \brief Actual Rx descriptor lists of all available Rx channels
 */
IFX_EXTERN IFX_ALIGN(8) IfxLeth_RxDescrList IfxLeth_Eth_rxDescrList[IFXLETH_NUM_RX_CHANNELS];

/** \brief Actual Tx descriptor lists of all available Tx channels
 */
IFX_EXTERN IFX_ALIGN(8) IfxLeth_TxDescrList IfxLeth_Eth_txDescrList[IFXLETH_NUM_TX_CHANNELS];

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE volatile IfxLeth_RxDescr *IfxLeth_Eth_getActualRxDescriptor(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId)
{
    return leth->rxChannel[channelId].rxDescrPtr;
}


IFX_INLINE volatile IfxLeth_TxDescr *IfxLeth_Eth_getActualTxDescriptor(IfxLeth_Eth *leth, IfxLeth_TxDmaChannel channelId)
{
    return leth->txChannel[channelId].txDescrPtr;
}


IFX_INLINE boolean IfxLeth_Eth_isRxDataAvailable(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId)
{
    return IfxLeth_Eth_getActualRxDescriptor(leth, channelId)->RDES3.R.OWN == 0;
}


IFX_INLINE volatile IfxLeth_TxDescr *IfxLeth_Eth_getBaseTxDescriptor(IfxLeth_Eth *leth, IfxLeth_TxDmaChannel channelId)
{
    return leth->txChannel[channelId].txDescrList->descr;
}


IFX_INLINE volatile IfxLeth_RxDescr *IfxLeth_Eth_getBaseRxDescriptor(IfxLeth_Eth *leth, IfxLeth_RxDmaChannel channelId)
{
    return leth->rxChannel[channelId].rxDescrList->descr;
}


#endif /* IFXLETH_ET_H */
