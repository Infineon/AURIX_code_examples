/**
 * \file IfxAdc.h
 * \brief ADC  basic functionality
 * \ingroup IfxLld_Adc
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * STD layer for ADC functionality
 *
 * PROT usage of ADC
 *
 *  Steps:
 *  Declare a global
 *  typedef struct
 *  {
 *     IfxApProt_ProtConfig proteConfig;        //brief PROTE configurations
 *     IfxApProt_ProtConfig protseConfig;       //brief PROTSE Configuration
 *     IfxApApu_ApuConfig   apuConfig;         //brief APU Configurations
 *  }IfxAdc_ApConfig
 *
 *  IfxAdc_ApConfig apConfig
 *
 *  Initialize the IfxAdc_ApConfig structure with default values
 *  IfxApProt_initConfig(&apConfig.proteConfig)
 *  IfxApProt_initConfig(&apConfig.protseConfig)
 *  IfxApApu_initConfig(&apConfig.apuConfig)
 *  Modify the PROTE, PROTSE and APU configuration as per the need.
 *
 *  Initialize PROTSE
 *  IfxAdc_initProtSE(&MODULE_ADC, &apConfig.protseConfig)
 *
 *  Initialize the PROTE
 *  IfxAdc_initProtE(&MODULE_ADC, &apConfig.proteConfig, IfxAdc_ProtE_0)
 *
 *  Change the APU assignment for ADC resources if needed, by default it is
 *  assigned to APU0.
 *  Assign Global resources of ADC,DSADC,EXMOD and CDSP to APU0-15
 *  IfxAdc_initGlobalResource(&MODULE_ADC, IfxAdc_GlobalResource_adc, IfxAdc_Apu_1)
 *  IfxAdc_initTmadcResource(&MODULE_ADC, IfxAdc_TmadcModule_0, IfxAdc_Apu_1)
 *  IfxAdc_initFccResource(&MODULE_ADC, IfxAdc_FccModule_0, IfxAdc_Apu_1)
 *  IfxAdc_initDsadcResource(&MODULE_ADC, IfxAdc_DsadcChannel_0, IfxAdc_Apu_1)
 *  IfxAdc_initExmodResource(&MODULE_ADC, IfxAdc_Exmod_0, IfxAdc_Apu_1)
 *  IfxAdc_initCdspResource(&MODULE_ADC, IfxAdc_CdspCore_0, IfxAdc_Apu_1)
 *
 *  Initialize the APU to enable Read and write access for master tag id.
 *  IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_ADC.PROTSE, IfxApProt_State_config)
 *  IfxAdc_configureAccessToAdcModule(&MODULE_ADC, &apConfig.apuConfig, IfxAdc_Apu_0)
 *  IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_ADC.PROTSE, IfxApProt_State_run)
 *
 * \defgroup IfxLld_Adc_Std_Enum Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Dsadc_Enum Dsadc Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Tmadc_Enum Tmadc_Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Fcc_Enum Fcc Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Cdsp_Enum Cdsp Enumerations
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Data_Structures Data Structures
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Module_Adc Adc Functionality
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Tmadc Tmadc Functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Fcc Fcc functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Dsadc Dsadc Functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Prot_Apu Prot and Apu functions
 * \ingroup IfxLld_Adc_Std
 * \defgroup IfxLld_Adc_Std_Cdsp cdsp Functions
 * \ingroup IfxLld_Adc_Std
 */

#ifndef IFXADC_H
#define IFXADC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxAdc_cfg.h"
#include "_PinMap/IfxAdc_PinMap.h"
#if !defined(IFX_ILLD_PPU_USAGE)
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#endif
#if defined(IFX_ILLD_PPU_USAGE)
#include "Cpu/Std/IfxPpu_Intrinsics.h"
#endif
#include "IfxAdc_reg.h"
#include "IfxAdc_bf.h"
#include "Src/Std/IfxSrc.h"
#include "Ap/Std/IfxApApu.h"
#include "Ap/Std/IfxApProt.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief macro to determine if startup calibration for TMADC is required or not.
 */
#ifndef IFXADC_TMADC_ENABLE_STARTUPCAL
#define IFXADC_TMADC_ENABLE_STARTUPCAL (0)
#endif

/** \brief MACRO to set the trigger configuration in the register
 */
#define IFXADC_WRITETRIGCFG(reg, delayCount, mode, trigSel) \
    (reg.U = (uint32)((uint32)(delayCount << 16u) |         \
                      (uint32)(mode << 6u) |                \
                      (uint32)(trigSel)))

/** \brief MACRO to set the APU assignment in the resource allocation register
 */
#define IFXADC_SETRESALLOCCFG(reg, resourceId, apuId)                                    \
    (reg.U = (uint32)((reg.U & ~(IFX_ADC_RESALLOC_GLOB_GLOB_MSK << (resourceId * 4u))) | \
                      (uint32)(apuId << (resourceId * 4u))))

/** \brief Macro for monitor channel offset
 */
#define IFXADC_TMADC_MCH_OFFSET (16U)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Std_Enum
 * \{ */
/** \brief Enumeration for Access Protection unit
 */
typedef enum
{
    IfxAdc_Apu_0,     /**< \brief APU  0  */
    IfxAdc_Apu_1,     /**< \brief APU  1  */
    IfxAdc_Apu_2,     /**< \brief APU  2  */
    IfxAdc_Apu_3,     /**< \brief APU  3  */
    IfxAdc_Apu_4,     /**< \brief APU  4  */
    IfxAdc_Apu_5,     /**< \brief APU  5  */
    IfxAdc_Apu_6,     /**< \brief APU  6  */
    IfxAdc_Apu_7,     /**< \brief APU  7  */
    IfxAdc_Apu_8,     /**< \brief APU  8  */
    IfxAdc_Apu_9,     /**< \brief APU  9  */
    IfxAdc_Apu_10,    /**< \brief APU  10  */
    IfxAdc_Apu_11,    /**< \brief APU  11  */
    IfxAdc_Apu_12,    /**< \brief APU  12  */
    IfxAdc_Apu_13,    /**< \brief APU  13  */
    IfxAdc_Apu_14,    /**< \brief APU  14  */
    IfxAdc_Apu_15     /**< \brief APU  15  */
} IfxAdc_Apu;

/** \brief Enumeration for Global resources of ADC, DSADC and CDSP
 */
typedef enum
{
    IfxAdc_GlobalResource_adc,    /**< \brief ADC Global */
    IfxAdc_GlobalResource_dsadc,  /**< \brief Global parts of Dsadc and Exmod */
    IfxAdc_GlobalResource_cdsp    /**< \brief Global parts of Cdsp */
} IfxAdc_GlobalResource;

/** \brief Enumeration for PROTE
 */
typedef enum
{
    IfxAdc_ProtE_0,     /**< \brief PROTE  0  */
    IfxAdc_ProtE_1,     /**< \brief PROTE  1  */
    IfxAdc_ProtE_2,     /**< \brief PROTE  2  */
    IfxAdc_ProtE_3,     /**< \brief PROTE  3  */
    IfxAdc_ProtE_4,     /**< \brief PROTE  4  */
    IfxAdc_ProtE_5,     /**< \brief PROTE  5  */
    IfxAdc_ProtE_6,     /**< \brief PROTE  6  */
    IfxAdc_ProtE_7,     /**< \brief PROTE  7  */
    IfxAdc_ProtE_8,     /**< \brief PROTE  8  */
    IfxAdc_ProtE_9,     /**< \brief PROTE  9  */
    IfxAdc_ProtE_10,    /**< \brief PROTE  10  */
    IfxAdc_ProtE_11,    /**< \brief PROTE  11  */
    IfxAdc_ProtE_12,    /**< \brief PROTE  12  */
    IfxAdc_ProtE_13,    /**< \brief PROTE  13  */
    IfxAdc_ProtE_14,    /**< \brief PROTE  14  */
    IfxAdc_ProtE_15     /**< \brief PROTE  15  */
} IfxAdc_ProtE;

/** \brief Enumeration describing the status of an operation
 */
typedef enum
{
    IfxAdc_Status_success = 0,  /**< \brief operation successful */
    IfxAdc_Status_failure = 1   /**< \brief operation failed */
} IfxAdc_Status;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Dsadc_Enum
 * \{ */
/** \} */

/** \addtogroup IfxLld_Adc_Std_Tmadc_Enum
 * \{ */
/** \brief Enumeration describing the mode of comparision for boundary check of TMADC
 */
typedef enum
{
    IfxAdc_TmadcBoundaryCmpMode_disable    = 0,  /**< \brief boundary check is disabled */
    IfxAdc_TmadcBoundaryCmpMode_upperBound = 1,  /**< \brief upper bound is checked */
    IfxAdc_TmadcBoundaryCmpMode_lowerBound = 2,  /**< \brief lower Bound is checked */
    IfxAdc_TmadcBoundaryCmpMode_bothBound  = 3   /**< \brief both Bounds checked */
} IfxAdc_TmadcBoundaryCmpMode;

/** \brief Enmieration describing TMADC boundary registers available
 */
typedef enum
{
    IfxAdc_TmadcBoundaryReg_0 = 0,  /**< \brief boundary reg 0 */
    IfxAdc_TmadcBoundaryReg_1 = 1   /**< \brief boundary reg 1 */
} IfxAdc_TmadcBoundaryReg;

/** \brief EMUX coding scheme.
 */
typedef enum
{
    IfxAdc_TmadcEmuxCodingScheme_binary = 0,  /**< \brief EMUX channel selection lines are binary coded */
    IfxAdc_TmadcEmuxCodingScheme_gray   = 1   /**< \brief EMUX channel selection lines are gray coded */
} IfxAdc_TmadcEmuxCodingScheme;

/** \brief Enumeration for TMADC event operation for service request
 */
typedef enum
{
    IfxAdc_TmadcEventOp_orLogicWithoutWfc = 0,  /**< \brief Service request generation on each event */
    IfxAdc_TmadcEventOp_orLogicWithWfc    = 1,  /**< \brief Service request generation on first event */
    IfxAdc_TmadcEventOp_andLogic          = 2   /**< \brief Service request generation on occurrence of all event */
} IfxAdc_TmadcEventOp;

/** \brief Enumeration for TMADC event selection for service request
 */
typedef enum
{
    IfxAdc_TmadcEventSel_disable  = 0, /**< \brief Disable service request */
    IfxAdc_TmadcEventSel_error    = 1, /**< \brief Service request on error event */
    IfxAdc_TmadcEventSel_result   = 2, /**< \brief Service request on result event */
    IfxAdc_TmadcEventSel_boundary = 3  /**< \brief Service request on boundary event */
} IfxAdc_TmadcEventSel;

/** \brief Enumeration for TMADC Global service request
 */
typedef enum
{
    IfxAdc_TmadcGlobalServReq_0,     /**< \brief Global service request0  */
    IfxAdc_TmadcGlobalServReq_1,     /**< \brief Global service request1  */
    IfxAdc_TmadcGlobalServReq_2,     /**< \brief Global service request2  */
    IfxAdc_TmadcGlobalServReq_3      /**< \brief Global service request3  */
} IfxAdc_TmadcGlobalServReq;

/** \brief Enumeration holding monitor channel numbers
 */
typedef enum
{
    IfxAdc_TmadcMonitorChannel_0 = 0,  /**< \brief Monitor channel 0 */
    IfxAdc_TmadcMonitorChannel_1 = 1   /**< \brief Monitor channel 1 */
} IfxAdc_TmadcMonitorChannel;

/** \brief Enumeration describing monitor channel input mux selection
 */
typedef enum
{
    IfxAdc_TmadcMonitorChannelInput_coreSupply   = 0,  /**< \brief Core (0,1) Supply voltage (VDDK0,VDDK1). (MCH1 --> Core0, MCH0 --> Core1) */
    IfxAdc_TmadcMonitorChannelInput_otherModules = 1,  /**< \brief Supply voltages from other modules (PMS,TMADC or DSADC) */
    IfxAdc_TmadcMonitorChannelInput_vssm         = 2,  /**< \brief VSSM */
    IfxAdc_TmadcMonitorChannelInput_csd          = 3   /**< \brief CSD monitor channel */
} IfxAdc_TmadcMonitorChannelInput;

/** \brief Enumeration describing operating modes of a TMADC channel
 */
typedef enum
{
    IfxAdc_TmadcOpMode_oneShot    = 0, /**< \brief one shot conversion */
    IfxAdc_TmadcOpMode_continuous = 1  /**< \brief continuous conversion with auto trigger */
} IfxAdc_TmadcOpMode;

/** \brief Enumeration describing output supervisor multiplexer selection
 */
typedef enum
{
    IfxAdc_TmadcOutputSupervisorMux_noConnection = 0,  /**< \brief No connection */
    IfxAdc_TmadcOutputSupervisorMux_vddk0        = 1,  /**< \brief Core-0 comparator supply voltage (VDDK0) */
    IfxAdc_TmadcOutputSupervisorMux_vddk1        = 2,  /**< \brief Core-1 comparator supply voltage (VDDK1) */
    IfxAdc_TmadcOutputSupervisorMux_vssm         = 3   /**< \brief Vssm */
} IfxAdc_TmadcOutputSupervisorMux;

/** \brief Enumeration holding TMADC result register numbers
 */
typedef enum
{
    IfxAdc_TmadcResultReg_0,     /**< \brief result register 0  */
    IfxAdc_TmadcResultReg_1,     /**< \brief result register 1  */
    IfxAdc_TmadcResultReg_2,     /**< \brief result register 2  */
    IfxAdc_TmadcResultReg_3,     /**< \brief result register 3  */
    IfxAdc_TmadcResultReg_4,     /**< \brief result register 4  */
    IfxAdc_TmadcResultReg_5,     /**< \brief result register 5  */
    IfxAdc_TmadcResultReg_6,     /**< \brief result register 6  */
    IfxAdc_TmadcResultReg_7,     /**< \brief result register 7  */
    IfxAdc_TmadcResultReg_8,     /**< \brief result register 8  */
    IfxAdc_TmadcResultReg_9,     /**< \brief result register 9  */
    IfxAdc_TmadcResultReg_10,    /**< \brief result register 10  */
    IfxAdc_TmadcResultReg_11,    /**< \brief result register 11  */
    IfxAdc_TmadcResultReg_12,    /**< \brief result register 12  */
    IfxAdc_TmadcResultReg_13,    /**< \brief result register 13  */
    IfxAdc_TmadcResultReg_14,    /**< \brief result register 14  */
    IfxAdc_TmadcResultReg_15,    /**< \brief result register 15  */
    IfxAdc_TmadcResultReg_count  /**< \brief Number of IfxAdc_TmadcResultReg of TMADC */
} IfxAdc_TmadcResultReg;

/** \brief Enumeration describing the Tmadc SAR Cores
 */
typedef enum
{
    IfxAdc_TmadcSarCore_0,     /**< \brief sar core0  */
    IfxAdc_TmadcSarCore_1      /**< \brief sar core1  */
} IfxAdc_TmadcSarCore;

/** \brief Enumeration for TMADC service request
 */
typedef enum
{
    IfxAdc_TmadcServReq_none = -1, /**< \brief Service request disable */
    IfxAdc_TmadcServReq_0,         /**< \brief Service request 0  */
    IfxAdc_TmadcServReq_1,         /**< \brief Service request 1  */
    IfxAdc_TmadcServReq_2,         /**< \brief Service request 2  */
    IfxAdc_TmadcServReq_3,         /**< \brief Service request 3  */
    IfxAdc_TmadcServReq_4,         /**< \brief Service request 4  */
    IfxAdc_TmadcServReq_5,         /**< \brief Service request 5  */
    IfxAdc_TmadcServReq_6          /**< \brief Service request 6  */
} IfxAdc_TmadcServReq;

/** \brief Enumeration for suspend modes of Tmadc
 */
typedef enum
{
    IfxAdc_TmadcSuspendMode_dsiable         = 0,  /**< \brief Suspend mode disable */
    IfxAdc_TmadcSuspendMode_hard            = 1,  /**< \brief Module immediately goes to suspend state */
    IfxAdc_TmadcSuspendMode_soft_activeConv = 2,  /**< \brief Module goes to suspend state after completing active conversions */
    IfxAdc_TmadcSuspendMode_soft_holdConv   = 3   /**< \brief Module goes to suspend state after completing conversions for all channels in hold state */
} IfxAdc_TmadcSuspendMode;

/** \brief Edge selection for TMADC hardware trigger
 */
typedef enum
{
    IfxAdc_TmadcTriggerMode_disable     = 0,  /**< \brief trigger is disabled */
    IfxAdc_TmadcTriggerMode_risingEdge  = 1,  /**< \brief rising edge of trigger selected */
    IfxAdc_TmadcTriggerMode_fallingEdge = 2,  /**< \brief Falling edge of trigger */
    IfxAdc_TmadcTriggerMode_bothEdge    = 3   /**< \brief both Edges selected */
} IfxAdc_TmadcTriggerMode;

/** \brief Enumeration holding Hardware Trigger mux selection
 */
typedef enum
{
    IfxAdc_TmadcTriggerMuxSel_0 = 0,      /**< \brief trigger mux selection 0  */
    IfxAdc_TmadcTriggerMuxSel_1,          /**< \brief trigger mux selection 1  */
    IfxAdc_TmadcTriggerMuxSel_2,          /**< \brief trigger mux selection 2  */
    IfxAdc_TmadcTriggerMuxSel_3,          /**< \brief trigger mux selection 3  */
    IfxAdc_TmadcTriggerMuxSel_4,          /**< \brief trigger mux selection 4  */
    IfxAdc_TmadcTriggerMuxSel_5,          /**< \brief trigger mux selection 5  */
    IfxAdc_TmadcTriggerMuxSel_6,          /**< \brief trigger mux selection 6  */
    IfxAdc_TmadcTriggerMuxSel_7,          /**< \brief trigger mux selection 7  */
    IfxAdc_TmadcTriggerMuxSel_8,          /**< \brief trigger mux selection 8  */
    IfxAdc_TmadcTriggerMuxSel_9,          /**< \brief trigger mux selection 9  */
    IfxAdc_TmadcTriggerMuxSel_10,         /**< \brief trigger mux selection 10  */
    IfxAdc_TmadcTriggerMuxSel_11,         /**< \brief trigger mux selection 11  */
    IfxAdc_TmadcTriggerMuxSel_12,         /**< \brief trigger mux selection 12  */
    IfxAdc_TmadcTriggerMuxSel_13,         /**< \brief trigger mux selection 13  */
    IfxAdc_TmadcTriggerMuxSel_14,         /**< \brief trigger mux selection 14  */
    IfxAdc_TmadcTriggerMuxSel_15,         /**< \brief trigger mux selection 15  */
    IfxAdc_TmadcTriggerMuxSel_16,         /**< \brief trigger mux selection 16  */
    IfxAdc_TmadcTriggerMuxSel_17,         /**< \brief trigger mux selection 17  */
    IfxAdc_TmadcTriggerMuxSel_18,         /**< \brief trigger mux selection 18  */
    IfxAdc_TmadcTriggerMuxSel_19,         /**< \brief trigger mux selection 19  */
    IfxAdc_TmadcTriggerMuxSel_20,         /**< \brief trigger mux selection 20  */
    IfxAdc_TmadcTriggerMuxSel_21,         /**< \brief trigger mux selection 21  */
    IfxAdc_TmadcTriggerMuxSel_22,         /**< \brief trigger mux selection 22  */
    IfxAdc_TmadcTriggerMuxSel_23,         /**< \brief trigger mux selection 23  */
    IfxAdc_TmadcTriggerMuxSel_24,         /**< \brief trigger mux selection 24  */
    IfxAdc_TmadcTriggerMuxSel_25,         /**< \brief trigger mux selection 25  */
    IfxAdc_TmadcTriggerMuxSel_26,         /**< \brief trigger mux selection 26  */
    IfxAdc_TmadcTriggerMuxSel_27,         /**< \brief trigger mux selection 27  */
    IfxAdc_TmadcTriggerMuxSel_28,         /**< \brief trigger mux selection 28  */
    IfxAdc_TmadcTriggerMuxSel_29,         /**< \brief trigger mux selection 29  */
    IfxAdc_TmadcTriggerMuxSel_30,         /**< \brief trigger mux selection 30  */
    IfxAdc_TmadcTriggerMuxSel_31,         /**< \brief trigger mux selection 31  */
    IfxAdc_TmadcTriggerMuxSel_32,         /**< \brief trigger mux selection 32  */
    IfxAdc_TmadcTriggerMuxSel_33,         /**< \brief trigger mux selection 33  */
    IfxAdc_TmadcTriggerMuxSel_34,         /**< \brief trigger mux selection 34  */
    IfxAdc_TmadcTriggerMuxSel_35,         /**< \brief trigger mux selection 35  */
    IfxAdc_TmadcTriggerMuxSel_36,         /**< \brief trigger mux selection 36  */
    IfxAdc_TmadcTriggerMuxSel_37,         /**< \brief trigger mux selection 37  */
    IfxAdc_TmadcTriggerMuxSel_38,         /**< \brief trigger mux selection 38  */
    IfxAdc_TmadcTriggerMuxSel_39,         /**< \brief trigger mux selection 39  */
    IfxAdc_TmadcTriggerMuxSel_40,         /**< \brief trigger mux selection 40  */
    IfxAdc_TmadcTriggerMuxSel_41,         /**< \brief trigger mux selection 41  */
    IfxAdc_TmadcTriggerMuxSel_42,         /**< \brief trigger mux selection 42  */
    IfxAdc_TmadcTriggerMuxSel_43,         /**< \brief trigger mux selection 43  */
    IfxAdc_TmadcTriggerMuxSel_44,         /**< \brief trigger mux selection 44  */
    IfxAdc_TmadcTriggerMuxSel_45,         /**< \brief trigger mux selection 45  */
    IfxAdc_TmadcTriggerMuxSel_46,         /**< \brief trigger mux selection 46  */
    IfxAdc_TmadcTriggerMuxSel_47,         /**< \brief trigger mux selection 47  */
    IfxAdc_TmadcTriggerMuxSel_48,         /**< \brief trigger mux selection 48  */
    IfxAdc_TmadcTriggerMuxSel_49,         /**< \brief trigger mux selection 49  */
    IfxAdc_TmadcTriggerMuxSel_50,         /**< \brief trigger mux selection 50  */
    IfxAdc_TmadcTriggerMuxSel_51,         /**< \brief trigger mux selection 51  */
    IfxAdc_TmadcTriggerMuxSel_52,         /**< \brief trigger mux selection 52  */
    IfxAdc_TmadcTriggerMuxSel_53,         /**< \brief trigger mux selection 53  */
    IfxAdc_TmadcTriggerMuxSel_54,         /**< \brief trigger mux selection 54  */
    IfxAdc_TmadcTriggerMuxSel_55,         /**< \brief trigger mux selection 55  */
    IfxAdc_TmadcTriggerMuxSel_56,         /**< \brief trigger mux selection 56  */
    IfxAdc_TmadcTriggerMuxSel_57,         /**< \brief trigger mux selection 57  */
    IfxAdc_TmadcTriggerMuxSel_58,         /**< \brief trigger mux selection 58  */
    IfxAdc_TmadcTriggerMuxSel_59,         /**< \brief trigger mux selection 59  */
    IfxAdc_TmadcTriggerMuxSel_60,         /**< \brief trigger mux selection 60  */
    IfxAdc_TmadcTriggerMuxSel_61,         /**< \brief trigger mux selection 61  */
    IfxAdc_TmadcTriggerMuxSel_62,         /**< \brief trigger mux selection 62  */
    IfxAdc_TmadcTriggerMuxSel_63,         /**< \brief trigger mux selection 63  */
    IfxAdc_TmadcTriggerMuxSel_count       /**< \brief Number of IfxAdc_TmadcTriggerMuxSel items */
} IfxAdc_TmadcTriggerMuxSel;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Fcc_Enum
 * \{ */
/** \} */

/** \addtogroup IfxLld_Adc_Std_Cdsp_Enum
 * \{ */
/** \brief Enumeration describing the mode of comparision for boundary check of CDSP
 */
typedef enum
{
    IfxAdc_CdspBoundaryCmpMode_disable    = 0,  /**< \brief boundary check is disabled */
    IfxAdc_CdspBoundaryCmpMode_upperBound = 1,  /**< \brief upper bound is checked */
    IfxAdc_CdspBoundaryCmpMode_lowerBound = 2,  /**< \brief lower Bound is checked */
    IfxAdc_CdspBoundaryCmpMode_bothBound  = 3   /**< \brief both Bounds checked */
} IfxAdc_CdspBoundaryCmpMode;

/** \brief Enumeration for Boundary service request (CDSP_DSPa_BNDCFG.SR2CFG)
 */
typedef enum
{
    IfxAdc_CdspBoundaryServReq_insideBoundary  = 0, /**< \brief Generate service request when result inside boundary band */
    IfxAdc_CdspBoundaryServReq_outsideBoundary = 1  /**< \brief Generate service request when result outside boundary band */
} IfxAdc_CdspBoundaryServReq;

/** \brief Configuration of Data Read width (CDSP_DSPa_DSPCFG.DRM)
 */
typedef enum
{
    IfxAdc_CdspDataReadWidth_16Bit = 0,  /**< \brief 16 BIt */
    IfxAdc_CdspDataReadWidth_32Bit = 2   /**< \brief 32 Bit */
} IfxAdc_CdspDataReadWidth;

/** \brief Enumeration for CDSP error flag.
 */
typedef enum
{
    IfxAdc_CdspError_read             = 0,  /**< \brief Read error flag */
    IfxAdc_CdspError_write            = 1,  /**< \brief Write error flag */
    IfxAdc_CdspError_srvReqTrigger    = 2,  /**< \brief Service request trigger error flag */
    IfxAdc_CdspError_timestampTrigger = 4,  /**< \brief Time-stamp trigger error flag */
    IfxAdc_CdspError_softwareTrigger  = 5,  /**< \brief Software trigger error */
    IfxAdc_CdspError_boundaryTrigger  = 6   /**< \brief Boundary request trigger error */
} IfxAdc_CdspError;

/** \brief FIFO fill level for service request generation
 */
typedef enum
{
    IfxAdc_CdspFifoSrLevel_1,     /**< \brief SRLVL 1  */
    IfxAdc_CdspFifoSrLevel_2,     /**< \brief SRLVL 2  */
    IfxAdc_CdspFifoSrLevel_3,     /**< \brief SRLVL 3  */
    IfxAdc_CdspFifoSrLevel_4      /**< \brief SRLVL 4  */
} IfxAdc_CdspFifoSrLevel;

/** \brief Enumeration describing CDSP input selection
 */
typedef enum
{
    IfxAdc_CdspInput_dsadc0     = 0,   /**< \brief Dsadc0 */
    IfxAdc_CdspInput_dsadc1     = 1,   /**< \brief Dsadc1 */
    IfxAdc_CdspInput_dsadc2     = 2,   /**< \brief Dsadc2 */
    IfxAdc_CdspInput_dsadc3     = 3,   /**< \brief Dsadc3 */
    IfxAdc_CdspInput_dsadc4     = 4,   /**< \brief Dsadc4 */
    IfxAdc_CdspInput_dsadc5     = 5,   /**< \brief Dsadc5 */
    IfxAdc_CdspInput_dsadc6     = 6,   /**< \brief Dsadc6 */
    IfxAdc_CdspInput_dsadc7     = 7,   /**< \brief Dsadc7 */
    IfxAdc_CdspInput_dsadc8     = 8,   /**< \brief Dsadc8 */
    IfxAdc_CdspInput_dsadc9     = 9,   /**< \brief Dsadc9 */
    IfxAdc_CdspInput_dsadc10    = 10,  /**< \brief Dsadc10 */
    IfxAdc_CdspInput_dsadc11    = 11,  /**< \brief Dsadc11 */
    IfxAdc_CdspInput_dsadc12    = 12,  /**< \brief Dsadc12 */
    IfxAdc_CdspInput_dsadc13    = 13,  /**< \brief Dsadc13 */
    IfxAdc_CdspInput_exmod0     = 14,  /**< \brief Exmod0 */
    IfxAdc_CdspInput_exmod1     = 15,  /**< \brief Exmod1 */
    IfxAdc_CdspInput_exmod2     = 16,  /**< \brief Exmod2 */
    IfxAdc_CdspInput_exmod3     = 17,  /**< \brief Exmod3 */
    IfxAdc_CdspInput_exmod4     = 18,  /**< \brief Exmod3 */
    IfxAdc_CdspInput_exmod5     = 19,  /**< \brief Exmod3 */
    IfxAdc_CdspInput_exmod6     = 20,  /**< \brief Exmod3 */
    IfxAdc_CdspInput_exmod7     = 21,  /**< \brief Exmod3 */
    IfxAdc_CdspInput_carmag     = 22,  /**< \brief Carrier Signal of Dsadc */
    IfxAdc_CdspInput_tmadc0Res0 = 23,  /**< \brief TMADC0 Res0 */
    IfxAdc_CdspInput_tmadc0Res1 = 24,  /**< \brief TMADC0 Res1 */
    IfxAdc_CdspInput_tmadc1Res0 = 25,  /**< \brief TMADC0 Res0 */
    IfxAdc_CdspInput_tmadc1Res1 = 26,  /**< \brief TMADC1 Res1 */
    IfxAdc_CdspInput_tmadc2Res0 = 27,  /**< \brief TMADC2 Res0 */
    IfxAdc_CdspInput_tmadc2Res1 = 28,  /**< \brief TMADC2 Res1 */
    IfxAdc_CdspInput_tmadc3Res0 = 29,  /**< \brief TMADC3 Res0 */
    IfxAdc_CdspInput_tmadc3Res1 = 30,  /**< \brief TMADC3 Res1 */
    IfxAdc_CdspInput_tmadc4Res0 = 31,  /**< \brief TMADC4 Res0 */
    IfxAdc_CdspInput_tmadc4Res1 = 32,  /**< \brief TMADC0 Res1 */
    IfxAdc_CdspInput_tmadc5Res0 = 33,  /**< \brief TMADC5 Res0 */
    IfxAdc_CdspInput_tmadc5Res1 = 34,  /**< \brief TMADC5 Res1 */
    IfxAdc_CdspInput_tmadc6Res0 = 35,  /**< \brief TMADC6 Res0 */
    IfxAdc_CdspInput_tmadc6Res1 = 36,  /**< \brief TMADC5 Res1 */
    IfxAdc_CdspInput_tmadc7Res0 = 37,  /**< \brief TMADC7 Res0 */
    IfxAdc_CdspInput_tmadc7Res1 = 38,  /**< \brief TMADC7 Res1 */
    IfxAdc_CdspInput_gp0        = 252, /**< \brief General Purpose Register 0 */
    IfxAdc_CdspInput_gp1        = 253, /**< \brief General Purpose Register 1 */
    IfxAdc_CdspInput_gp2        = 254, /**< \brief General Purpose Register 2 */
    IfxAdc_CdspInput_gp3        = 255  /**< \brief General Purpose Register 3 */
} IfxAdc_CdspInput;

/** \brief Enumeration describing CDSP monitor selection.
 * CDSP_DSPa_DSPCFG.HSIMON
 */
typedef enum
{
    IfxAdc_CdspInputMonitor_dsadc0     = 0,   /**< \brief Dsadc0 */
    IfxAdc_CdspInputMonitor_dsadc1     = 1,   /**< \brief Dsadc1 */
    IfxAdc_CdspInputMonitor_dsadc2     = 2,   /**< \brief Dsadc2 */
    IfxAdc_CdspInputMonitor_dsadc3     = 3,   /**< \brief Dsadc3 */
    IfxAdc_CdspInputMonitor_dsadc4     = 4,   /**< \brief Dsadc4 */
    IfxAdc_CdspInputMonitor_dsadc5     = 5,   /**< \brief Dsadc5 */
    IfxAdc_CdspInputMonitor_dsadc6     = 6,   /**< \brief Dsadc6 */
    IfxAdc_CdspInputMonitor_dsadc7     = 7,   /**< \brief Dsadc7 */
    IfxAdc_CdspInputMonitor_dsadc8     = 8,   /**< \brief Dsadc8 */
    IfxAdc_CdspInputMonitor_dsadc9     = 9,   /**< \brief Dsadc9 */
    IfxAdc_CdspInputMonitor_dsadc10    = 10,  /**< \brief Dsadc10 */
    IfxAdc_CdspInputMonitor_dsadc11    = 11,  /**< \brief Dsadc11 */
    IfxAdc_CdspInputMonitor_dsadc12    = 12,  /**< \brief Dsadc12 */
    IfxAdc_CdspInputMonitor_dsadc13    = 13,  /**< \brief Dsadc13 */
    IfxAdc_CdspInputMonitor_exmod0     = 14,  /**< \brief Exmod0 */
    IfxAdc_CdspInputMonitor_exmod1     = 15,  /**< \brief Exmod1 */
    IfxAdc_CdspInputMonitor_exmod2     = 16,  /**< \brief Exmod2 */
    IfxAdc_CdspInputMonitor_exmod3     = 17,  /**< \brief Exmod3 */
    IfxAdc_CdspInputMonitor_exmod4     = 18,  /**< \brief Exmod3 */
    IfxAdc_CdspInputMonitor_exmod5     = 19,  /**< \brief Exmod3 */
    IfxAdc_CdspInputMonitor_exmod6     = 20,  /**< \brief Exmod3 */
    IfxAdc_CdspInputMonitor_exmod7     = 21,  /**< \brief Exmod3 */
    IfxAdc_CdspInputMonitor_carmag     = 22,  /**< \brief Carrier Signal of Dsadc */
    IfxAdc_CdspInputMonitor_tmadc0Res0 = 23,  /**< \brief TMADC0 Res0 */
    IfxAdc_CdspInputMonitor_tmadc0Res1 = 24,  /**< \brief TMADC0 Res1 */
    IfxAdc_CdspInputMonitor_tmadc1Res0 = 25,  /**< \brief TMADC0 Res0 */
    IfxAdc_CdspInputMonitor_tmadc1Res1 = 26,  /**< \brief TMADC1 Res1 */
    IfxAdc_CdspInputMonitor_tmadc2Res0 = 27,  /**< \brief TMADC2 Res0 */
    IfxAdc_CdspInputMonitor_tmadc2Res1 = 28,  /**< \brief TMADC2 Res1 */
    IfxAdc_CdspInputMonitor_tmadc3Res0 = 29,  /**< \brief TMADC3 Res0 */
    IfxAdc_CdspInputMonitor_tmadc3Res1 = 30,  /**< \brief TMADC3 Res1 */
    IfxAdc_CdspInputMonitor_tmadc4Res0 = 31,  /**< \brief TMADC4 Res0 */
    IfxAdc_CdspInputMonitor_tmadc4Res1 = 32,  /**< \brief TMADC0 Res1 */
    IfxAdc_CdspInputMonitor_tmadc5Res0 = 33,  /**< \brief TMADC5 Res0 */
    IfxAdc_CdspInputMonitor_tmadc5Res1 = 34,  /**< \brief TMADC5 Res1 */
    IfxAdc_CdspInputMonitor_tmadc6Res0 = 35,  /**< \brief TMADC6 Res0 */
    IfxAdc_CdspInputMonitor_tmadc6Res1 = 36,  /**< \brief TMADC5 Res1 */
    IfxAdc_CdspInputMonitor_tmadc7Res0 = 37,  /**< \brief TMADC7 Res0 */
    IfxAdc_CdspInputMonitor_tmadc7Res1 = 38,  /**< \brief TMADC7 Res1 */
    IfxAdc_CdspInputMonitor_gp0        = 252, /**< \brief General Purpose Register 0 */
    IfxAdc_CdspInputMonitor_gp1        = 253, /**< \brief General Purpose Register 1 */
    IfxAdc_CdspInputMonitor_gp2        = 254, /**< \brief General Purpose Register 2 */
    IfxAdc_CdspInputMonitor_gp3        = 255  /**< \brief General Purpose Register 3 */
} IfxAdc_CdspInputMonitor;

/** \brief Select the bits to be accumulated in Integrator [INTCFG.ISC]
 */
typedef enum
{
    IfxAdc_CdspIntegratorShift_bits4To20,     /**< \brief Select bits 4 to 20  */
    IfxAdc_CdspIntegratorShift_bits5To21,     /**< \brief Select bits 5 to 21  */
    IfxAdc_CdspIntegratorShift_bits6To22,     /**< \brief Select bits 6 to 22  */
    IfxAdc_CdspIntegratorShift_bits7To23,     /**< \brief Select bits 7 to 23  */
    IfxAdc_CdspIntegratorShift_bits8To24,     /**< \brief Select bits 8 to 24  */
    IfxAdc_CdspIntegratorShift_bits9To25      /**< \brief Select bits 9 to 25  */
} IfxAdc_CdspIntegratorShift;

/** \brief Enumeration for Cdsp Result register
 */
typedef enum
{
    IfxAdc_CdspResultReg_0,     /**< \brief CDSP Result register0  */
    IfxAdc_CdspResultReg_1,     /**< \brief CDSP Result register1  */
    IfxAdc_CdspResultReg_2      /**< \brief CDSP Result register2  */
} IfxAdc_CdspResultReg;

/** \brief Enumeration for Cdsp Service request
 */
typedef enum
{
    IfxAdc_CdspServiceReq_result = 0,  /**< \brief Service request for result */
    IfxAdc_CdspServiceReq_event  = 1,  /**< \brief Service request for timestamp/wakeup event */
    IfxAdc_CdspServiceReq_alarm  = 2   /**< \brief Service request for limit checking */
} IfxAdc_CdspServiceReq;

/** \brief Enumeration for CDSP software mode
 */
typedef enum
{
    IfxAdc_CdspSoftwareMode_0 = 0,  /**< \brief Software results transmitted to the result registers. To be used for filter chains without integrator */
    IfxAdc_CdspSoftwareMode_1 = 1,  /**< \brief Software results transmitted to the result registers as generated upon write access to RES1.  To be used for filter chain with integrator */
    IfxAdc_CdspSoftwareMode_2 = 2   /**< \brief Software results transmitted to result registers as generated, INTIVAL updates blocked */
} IfxAdc_CdspSoftwareMode;

/** \brief Edge selection for CDSP software trigger
 */
typedef enum
{
    IfxAdc_CdspSoftwareTriggerMode_deactivated          = 0,  /**< \brief No trigger edge selected, trigger controlled software function deactivated */
    IfxAdc_CdspSoftwareTriggerMode_activateOnRisingEdge = 1,  /**< \brief Rising trigger edge selected to (re)activate the trigger controlled software function */
    IfxAdc_CdspSoftwareTriggerMode_activateOnFallEdge   = 2,  /**< \brief Falling trigger edge selected to (re)activate the trigger controlled software function */
    IfxAdc_CdspSoftwareTriggerMode_activated            = 3   /**< \brief No trigger edge selected, trigger controlled software function activated. */
} IfxAdc_CdspSoftwareTriggerMode;

/** \brief Enumeration for CDSP software Integrator window control
 */
typedef enum
{
    IfxAdc_CdspSoftwareWindowControl_internal = 0,  /**< \brief Trigger controlled software function will be stopped automatically */
    IfxAdc_CdspSoftwareWindowControl_external = 1   /**< \brief Trigger controlled software function will be stopped by the inverse activation trigger edge */
} IfxAdc_CdspSoftwareWindowControl;

/** \brief CDSP service request 0 configuration
 */
typedef enum
{
    IfxAdc_CdspSrvReq0_never    = 0,  /**< \brief Never raise Service Request */
    IfxAdc_CdspSrvReq0_gateHigh = 1,  /**< \brief Raise when gate HIGH */
    IfxAdc_CdspSrvReq0_gateLow  = 2,  /**< \brief Raise when gate LOW */
    IfxAdc_CdspSrvReq0_always   = 3   /**< \brief Raise always */
} IfxAdc_CdspSrvReq0;

/** \brief Enumeration holding CDSP service request 1 selection
 */
typedef enum
{
    IfxAdc_CdspSrvReq1_never     = 0,  /**< \brief Never raise Service Request */
    IfxAdc_CdspSrvReq1_timestamp = 1,  /**< \brief SR1 occurs when timestamp is generated */
    IfxAdc_CdspSrvReq1_wakeupErr = 2,  /**< \brief SR1 occurs when a wakeup error occurs or core is in halt state */
    IfxAdc_CdspSrvReq1_always    = 3   /**< \brief SR1 is generated on timestamp generation, wakeup error or system halt */
} IfxAdc_CdspSrvReq1;

/** \brief Enumeration for suspend modes of Cdsp
 */
typedef enum
{
    IfxAdc_CdspSuspendMode_disable   = 0, /**< \brief Suspend mode disable */
    IfxAdc_CdspSuspendMode_hard      = 1, /**< \brief Module immediately goes to suspend state */
    IfxAdc_CdspSuspendMode_soft      = 2, /**< \brief Module goes to suspend state after processing the current sample */
    IfxAdc_CdspSuspendMode_soft_res0 = 3  /**< \brief Module goes to suspend state after after generating the final output in RES0 */
} IfxAdc_CdspSuspendMode;

/** \brief Enumeration for CDSP timestamp clock
 */
typedef enum
{
    IfxAdc_CdspTimestampClock_div4  = 0,  /**< \brief Timestamp clock fts = fadc/4 */
    IfxAdc_CdspTimestampClock_div8  = 1,  /**< \brief Timestamp clock fts = fadc/8 */
    IfxAdc_CdspTimestampClock_div16 = 2,  /**< \brief Timestamp clock fts = fadc/16 */
    IfxAdc_CdspTimestampClock_div32 = 3   /**< \brief Timestamp clock fts = fadc/32 */
} IfxAdc_CdspTimestampClock;

/** \brief Edge selection for CDSP trigger
 */
typedef enum
{
    IfxAdc_CdspTriggerMode_disable     = 0,  /**< \brief trigger is disabled */
    IfxAdc_CdspTriggerMode_risingEdge  = 1,  /**< \brief rising edge of trigger selected */
    IfxAdc_CdspTriggerMode_fallingEdge = 2,  /**< \brief Falling edge of trigger */
    IfxAdc_CdspTriggerMode_bothEdge    = 3   /**< \brief both Edges selected */
} IfxAdc_CdspTriggerMode;

/** \brief Enumeration Cdsp trigger selection
 */
typedef enum
{
    IfxAdc_CdspTriggerSel_0,     /**< \brief trigger selection 0  */
    IfxAdc_CdspTriggerSel_1,     /**< \brief trigger selection 1  */
    IfxAdc_CdspTriggerSel_2,     /**< \brief trigger selection 2  */
    IfxAdc_CdspTriggerSel_3,     /**< \brief trigger selection 3  */
    IfxAdc_CdspTriggerSel_4,     /**< \brief trigger selection 4  */
    IfxAdc_CdspTriggerSel_5,     /**< \brief trigger selection 5  */
    IfxAdc_CdspTriggerSel_6,     /**< \brief trigger selection 6  */
    IfxAdc_CdspTriggerSel_7,     /**< \brief trigger selection 7  */
    IfxAdc_CdspTriggerSel_8,     /**< \brief trigger selection 8  */
    IfxAdc_CdspTriggerSel_9,     /**< \brief trigger selection 9  */
    IfxAdc_CdspTriggerSel_10,    /**< \brief trigger selection 10  */
    IfxAdc_CdspTriggerSel_11,    /**< \brief trigger selection 11  */
    IfxAdc_CdspTriggerSel_12,    /**< \brief trigger selection 12  */
    IfxAdc_CdspTriggerSel_13,    /**< \brief trigger selection 13  */
    IfxAdc_CdspTriggerSel_14,    /**< \brief trigger selection 14  */
    IfxAdc_CdspTriggerSel_15,    /**< \brief trigger selection 15  */
    IfxAdc_CdspTriggerSel_16,    /**< \brief trigger selection 16  */
    IfxAdc_CdspTriggerSel_17,    /**< \brief trigger selection 17  */
    IfxAdc_CdspTriggerSel_18,    /**< \brief trigger selection 18  */
    IfxAdc_CdspTriggerSel_19,    /**< \brief trigger selection 19  */
    IfxAdc_CdspTriggerSel_20,    /**< \brief trigger selection 20  */
    IfxAdc_CdspTriggerSel_21,    /**< \brief trigger selection 21  */
    IfxAdc_CdspTriggerSel_22,    /**< \brief trigger selection 22  */
    IfxAdc_CdspTriggerSel_23,    /**< \brief trigger selection 23  */
    IfxAdc_CdspTriggerSel_24,    /**< \brief trigger selection 24  */
    IfxAdc_CdspTriggerSel_25,    /**< \brief trigger selection 25  */
    IfxAdc_CdspTriggerSel_26,    /**< \brief trigger selection 26  */
    IfxAdc_CdspTriggerSel_27,    /**< \brief trigger selection 27  */
    IfxAdc_CdspTriggerSel_28,    /**< \brief trigger selection 28  */
    IfxAdc_CdspTriggerSel_29,    /**< \brief trigger selection 29  */
    IfxAdc_CdspTriggerSel_30,    /**< \brief trigger selection 30  */
    IfxAdc_CdspTriggerSel_31,    /**< \brief trigger selection 31  */
    IfxAdc_CdspTriggerSel_32,    /**< \brief trigger selection 32  */
    IfxAdc_CdspTriggerSel_33,    /**< \brief trigger selection 33  */
    IfxAdc_CdspTriggerSel_34,    /**< \brief trigger selection 34  */
    IfxAdc_CdspTriggerSel_35,    /**< \brief trigger selection 35  */
    IfxAdc_CdspTriggerSel_36,    /**< \brief trigger selection 36  */
    IfxAdc_CdspTriggerSel_37,    /**< \brief trigger selection 37  */
    IfxAdc_CdspTriggerSel_38,    /**< \brief trigger selection 38  */
    IfxAdc_CdspTriggerSel_39,    /**< \brief trigger selection 39  */
    IfxAdc_CdspTriggerSel_40,    /**< \brief trigger selection 40  */
    IfxAdc_CdspTriggerSel_41,    /**< \brief trigger selection 41  */
    IfxAdc_CdspTriggerSel_42,    /**< \brief trigger selection 42  */
    IfxAdc_CdspTriggerSel_43,    /**< \brief trigger selection 43  */
    IfxAdc_CdspTriggerSel_44,    /**< \brief trigger selection 44  */
    IfxAdc_CdspTriggerSel_45,    /**< \brief trigger selection 45  */
    IfxAdc_CdspTriggerSel_46,    /**< \brief trigger selection 46  */
    IfxAdc_CdspTriggerSel_47,    /**< \brief trigger selection 47  */
    IfxAdc_CdspTriggerSel_48,    /**< \brief trigger selection 48  */
    IfxAdc_CdspTriggerSel_49,    /**< \brief trigger selection 49  */
    IfxAdc_CdspTriggerSel_50,    /**< \brief trigger selection 50  */
    IfxAdc_CdspTriggerSel_51,    /**< \brief trigger selection 51  */
    IfxAdc_CdspTriggerSel_52,    /**< \brief trigger selection 52  */
    IfxAdc_CdspTriggerSel_53,    /**< \brief trigger selection 53  */
    IfxAdc_CdspTriggerSel_54,    /**< \brief trigger selection 54  */
    IfxAdc_CdspTriggerSel_55,    /**< \brief trigger selection 55  */
    IfxAdc_CdspTriggerSel_56,    /**< \brief trigger selection 56  */
    IfxAdc_CdspTriggerSel_57,    /**< \brief trigger selection 57  */
    IfxAdc_CdspTriggerSel_58,    /**< \brief trigger selection 58  */
    IfxAdc_CdspTriggerSel_59,    /**< \brief trigger selection 59  */
    IfxAdc_CdspTriggerSel_60,    /**< \brief trigger selection 60  */
    IfxAdc_CdspTriggerSel_61,    /**< \brief trigger selection 61  */
    IfxAdc_CdspTriggerSel_62,    /**< \brief trigger selection 62  */
    IfxAdc_CdspTriggerSel_63,    /**< \brief trigger selection 63  */
    IfxAdc_CdspTriggerSel_count  /**< \brief Number of IfxAdc_CdspTriggerSel items */
} IfxAdc_CdspTriggerSel;

/** \} */

/** \addtogroup IfxLld_Adc_Std_Module_Adc
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enables the clock connection to ADC module
 * \param modSFR Pointer to the ADC SFR structure
 * \return None
 */
IFX_INLINE void IfxAdc_enableModule(Ifx_ADC *modSFR);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Tmadc
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Trigger a channel for conversion
 * \param tmSFR Pointer to the module SFR
 * \param channelSet Set of channels to be triggered. (All channels corresponding to bit positions set to 1 shall be triggered)
 * \return None
 */
IFX_INLINE void IfxAdc_triggerTmadcChannelSet(Ifx_ADC_TMADC *tmSFR, uint16 channelSet);

/** \brief Trigger a channel for conversion
 * \param tmSFR Pointer to the module SFR
 * \param channelId Channel to be triggered
 * \return None
 */
IFX_INLINE void IfxAdc_triggerTmadcChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcChannel channelId);

/** \brief Function that accepts the Sampling Time in NS and returns the sampling time configuration value to be written into the CHSTC register.
 * \param sampleTimeNs Sampling time of channel in NS
 * \return Sampling Time (ST) value to be written into CHSTCy register
 */
IFX_INLINE uint16 IfxAdc_getTmadcSamplingTimeValue(const float32 sampleTimeNs);

/** \brief Checks if the result is available in the result register
 * \param tmadc Pointer to the module SFR
 * \param resultRegNum result Register number
 * \return TRUE: result available
 * FALSE: result unavailable
 */
IFX_INLINE boolean IfxAdc_isTmadcResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum);

/** \brief Clears the result flag of the requested result register
 * \param tmadc Pointer to the module SFR
 * \param resultRegNum result Register number
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum);

/** \brief Function that accepts the delay Time in NS and returns the delay time configuration value to be written into the CHSTC register.
 * \param delayNS trigger delay of channel in NS
 * \return trigger delay (TD) value to be written into CHSTCy register
 */
IFX_INLINE uint16 IfxAdc_getTmadcTriggerDelayValue(const float32 delayNS);

/** \brief Function to set Tmadc module to run state
 * \param tmadc Pointer to tmadc module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_runTmadcModule(Ifx_ADC_TMADC *tmadc);

/** \brief Function to set Tmadc module to config state
 * \param tmadc Pointer to tmadc module sfr
 * \return None
 */
IFX_INLINE void IfxAdc_stopTmadcModule(Ifx_ADC_TMADC *tmadc);

/** \brief Function to configure a tmadc analog input pin
 * \param tmadcpin tmadc analog input Pin which should be configured
 * \param pinMode the pin input mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initTmadcPin(const IfxAdc_TmadcCh_In *tmadcpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Function to configure external multiplexer pin
 * \param emuxPin the external multiplexer Pin which should be configured
 * \param pinMode pin output mode which should be configured
 * \param padDriver pad driver mode which should be configured
 * \return None
 */
IFX_INLINE void IfxAdc_initTmadcEmuxCtrlPin(const IfxAdc_Emuxctrl_Out *emuxPin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver);

/** \brief Enables the clock connection to Tmadc module
 * \param moduleId Module Id for Tmadc
 * \return None
 */
IFX_INLINE void IfxAdc_enableTmadcModule(IfxAdc_TmadcModule moduleId);

/** \brief Disables the clock connection to Tmadc module
 * \param moduleId Module Id for Tmadc
 * \return None
 */
IFX_INLINE void IfxAdc_disableTmadcModule(IfxAdc_TmadcModule moduleId);

/** \brief Read Tmadc result
 * \param moduleId Module Id for Tmadc
 * \param resultReg Result register of TMADC
 * \return Returns result
 */
IFX_INLINE sint16 IfxAdc_readTmadcResult(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg);

/** \brief Read timestamp value.
 * \param moduleId Module Id for Tmadc
 * \param resultReg Result register of TMADC
 * \return Returns timestamp
 */
IFX_INLINE uint16 IfxAdc_readTmadcTimestamp(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg);

/** \brief Checks if the result is available for the monitor channel in the result register
 * \param tmadc Pointer to the tmadc module SFR
 * \param channel monitor channel number
 * \return TRUE: result available
 * FALSE: result unavailable
 */
IFX_INLINE boolean IfxAdc_isTmadcMonitorChannelResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel);

/** \brief Clears the result flag of the monitor channel result
 * \param tmadc Pointer to the module SFR
 * \param channel monitor channel number
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcMonitorChannelResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel);

/** \brief API to get trigger error number
 * \param tmadc Pointer to the module SFR
 * \param channel channel number
 * \return Trigger error number
 */
IFX_INLINE uint8 IfxAdc_getTmadcTriggerErrorNumber(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Checks if the hardware trigger is ignored.
 * \param tmadc Pointer to tmadc module sfr
 * \param channel channel id
 * \return TRUE: Hardware trigger is ignored
 * FALSE: No error
 */
IFX_INLINE boolean IfxAdc_isTmadcHwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Checks if the software trigger is ignored.
 * \param tmadc Pointer to tmadc module sfr
 * \param channel channel id
 * \return TRUE: Software trigger is ignored
 * FALSE: No error
 */
IFX_INLINE boolean IfxAdc_isTmadcSwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Get boundary flag output
 * \param tmadc Pointer to tmadc module sfr
 * \param boundaryReg Boundary register selection
 * \return TRUE: Boundary flag high
 * FALSE: Boundary flag low
 */
IFX_INLINE boolean IfxAdc_getTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcBoundaryReg boundaryReg);

/** \brief Check if error event occured on the channel.
 * \param tmadc Pointer to tmadc module sfr
 * \param channel channel id
 * \return TRUE: Error event occured on this channel
 * FALSE: No error event on the channel
 */
IFX_INLINE boolean IfxAdc_isTmadcErrorEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Check if boundary event occured on the channel.
 * \param tmadc Pointer to tmadc module sfr
 * \param resultReg Result register
 * \return TRUE: Boundary check successful
 * FALSE: Boundary check failure
 */
IFX_INLINE boolean IfxAdc_isTmadcBoundaryEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg);

/** \brief Clear result event flag
 * \param tmadc Pointer to tmadc module sfr
 * \param channel Channel id
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcErrorFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel);

/** \brief Clear boundary event flag
 * \param tmadc Pointer to tmadc module sfr
 * \param resultReg Result register
 * \return None
 */
IFX_INLINE void IfxAdc_clearTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg);

/** \brief Trigger a monitor channel for conversion
 * \param tmSFR Pointer to the module SFR
 * \param channelId Monitor Channel to be triggered
 * \return None
 */
IFX_INLINE void IfxAdc_triggerTmadcMonitorChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcMonitorChannel channelId);

/** \brief Function to configure TMADC event for service request node
 * \param tmSFR Pointer to the module SFR
 * \param srvNode Service request node selection
 * \param event Event selection for node
 * \return None
 */
IFX_INLINE void IfxAdc_configureTmadcEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcEventSel event);

/** \brief Function to enable event for the TMADC channel or result register.
 *  If service request node is configured for result/boundary event then channel id
 *  corresponds to the result register enum. If node is configured for result/boundary event
 *  then each bit in the bit field corresponds to the result register.
 * \param tmSFR Pointer to the module SFR
 * \param srvNode Service request node selection
 * \param channelId Channel id
 * \return None
 */
IFX_INLINE void IfxAdc_enableTmadcChannelEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcChannel channelId);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to suspend instances of Tmadc
 * \param moduleId Tmadc module id
 * \param mode Tmadc suspend mode
 * \return None
 */
IFX_EXTERN void IfxAdc_suspendTmadcModule(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcSuspendMode mode);

/** \brief Returns the SRC pointer for TMADC event
 * \param moduleId Tmadc module id
 * \param node Tmadc service request node
 * \return Returens SRC pointer for give node.
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxAdc_getTmadcSrcPointer(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcServReq node);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Prot_Apu
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize PROTE
 * \param adc ADC module pointer
 * \param config PROT configuration
 * \param id PROTE register
 * \return status of the PROT initialization
 */
IFX_INLINE IfxApProt_Status IfxAdc_initProtE(Ifx_ADC *adc, IfxApProt_ProtConfig *config, IfxAdc_ProtE id);

/** \brief Function to initialize PROTSE
 * \param adc ADC module pointer
 * \param config PROT configuration
 * \return status of the PROT initialization
 */
IFX_INLINE IfxApProt_Status IfxAdc_initProtSE(Ifx_ADC *adc, IfxApProt_ProtConfig *config);

/** \brief Function to set APU assignment for Tmadc resource
 * \param adc ADC module pointer
 * \param moduleId Tmadc module id
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initTmadcResource(Ifx_ADC *adc, IfxAdc_TmadcModule moduleId, IfxAdc_Apu apuId);

/** \brief Function to set APU assignment for Global resource
 * \param adc ADC module pointer
 * \param resourceId Options for Global adc, dsadc and cdsp
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initGlobalResource(Ifx_ADC *adc, IfxAdc_GlobalResource resourceId, IfxAdc_Apu apuId);

/** \brief Function to set APU assignment for CDSP resource
 * \param adc ADC module pointer
 * \param cdspId Cdsp core id
 * \param apuId APU id
 * \return None
 */
IFX_INLINE void IfxAdc_initCdspResource(Ifx_ADC *adc, IfxAdc_CdspCore cdspId, IfxAdc_Apu apuId);

/** \} */

/** \addtogroup IfxLld_Adc_Std_Cdsp
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to enable DSP clock
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_enableCdspClock(IfxAdc_CdspCore coreId);

/** \brief Function to get the sleep status of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return TRUE --> DSP core is in sleep mode
 */
IFX_INLINE boolean IfxAdc_getCdspCoreSleepStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to clear wakeup error.
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspWakeupError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to get the wakeup error event
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp Core
 * \return Returns Cdsp wakeup error event status for Cdsp core
 */
IFX_INLINE boolean IfxAdc_getCdspWakeupErrorStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to run DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp Core
 * \return None
 */
IFX_INLINE void IfxAdc_runCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Get the result flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId DSP core
 * \param reg DSP core result register
 * \return TRUE: result event occurred
 */
IFX_INLINE boolean IfxAdc_getCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg);

/** \brief Get FIFO fill level of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return Returns FIFO fill level
 */
IFX_INLINE uint8 IfxAdc_getCdspFifoFillLevel(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Enable clock for global part of CDSP
 * \return None
 */
IFX_INLINE void IfxAdc_enableCdspGlobal(void);

/** \brief Function to reset Cdsp core. (Module Reset)
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_resetCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to halt Cdsp core.
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_haltCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to copy data from source address to destination address
 * \param srcAddr source address
 * \param destAddr Destination address
 * \param size Data size to be transfered.
 * \return None
 */
IFX_INLINE void IfxAdc_loadCdspMemory(void *srcAddr, void *destAddr, uint16 size);

/** \brief Clear the result event flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \param reg DSP core result register
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg);

/** \brief Function to get the halt status of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return TRUE --> DSP core is in halt state
 */
IFX_INLINE boolean IfxAdc_getCdspCoreHaltStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Function to get boundary event flag
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return TRUE --> Boundary Event occured
 */
IFX_INLINE boolean IfxAdc_getCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Clear the boundary event flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId);

/** \brief Clear the boundary event flag of DSP core
 * \param cdsp Pointer to cdsp module sfr
 * \param coreId Dsp core
 * \param error Error selection
 * \return None
 */
IFX_INLINE void IfxAdc_clearCdspError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspError error);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to suspend Cdsp core
 * \param coreId Dsp core
 * \param mode Cdsp suspend mode
 * \return None
 */
IFX_EXTERN void IfxAdc_suspendCdspCore(IfxAdc_CdspCore coreId, IfxAdc_CdspSuspendMode mode);

/** \brief Returns the SRC pointer for CDSP event
 * \param coreId Dsp core
 * \param node CDSP Service request node
 * \return Returns SRC pointer for service request node of DSP core
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxAdc_getCdspSrcPointer(IfxAdc_CdspCore coreId, uint8 node);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Configures access to all masters to all the ADC in the device
 * \param apConfig pointer to configuration structure
 * \return None
 */
IFX_EXTERN void IfxAdc_configureAccessToAdc(IfxApApu_ApuConfig *apConfig);

/** \brief Configures access to requested master to the specified ADC in the device
 * \param adc ADC module
 * \param apuConfig pointer to configuration structure
 * \param apuId ADC Apu's
 * \return None
 */
IFX_EXTERN void IfxAdc_configureAccessToAdcModule(Ifx_ADC *adc, IfxApApu_ApuConfig *apuConfig, IfxAdc_Apu apuId);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxAdc_enableModule(Ifx_ADC *modSFR)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_ADC.PROTE[0], IfxApProt_State_config);
#endif
    modSFR->CLC.B.DISR = 0U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&MODULE_ADC.PROTE[0], IfxApProt_State_run);
#endif

    while (modSFR->CLC.B.DISS == 1U)
    {
        /* wait until module is enabled */
    }
}


IFX_INLINE void IfxAdc_triggerTmadcChannelSet(Ifx_ADC_TMADC *tmSFR, uint16 channelSet)
{
    tmSFR->SWTRCFG.B.SCHSEL = channelSet;
}


IFX_INLINE void IfxAdc_triggerTmadcChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcChannel channelId)
{
    tmSFR->SWTRCFG.B.SCHSEL = (uint16)(1 << channelId);
}


IFX_INLINE uint16 IfxAdc_getTmadcSamplingTimeValue(const float32 sampleTimeNs)
{
    uint16 stVal;
    uint32 reqSampleTime = (uint32)(sampleTimeNs * 10U);

    for (stVal = 0; stVal < 0xFFFF; stVal++)
    {
        if ((uint32)(125 * (stVal + 1)) >= reqSampleTime)
        {
            break; /* break out. stVal value has matched sampling time */
        }
    }

    if (stVal < 3U)
    {
        stVal = 3U;
    }

    return stVal;
}


IFX_INLINE boolean IfxAdc_isTmadcResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum)
{
    uint32 resultEvent = tmadc->RESF.B.RESEV;

    return (resultEvent & ((uint32)1 << resultRegNum)) != (uint32)0;
}


IFX_INLINE void IfxAdc_clearTmadcResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultRegNum)
{
    tmadc->RESFCLR.B.RESEVCLR = ((uint32)1 << resultRegNum);
}


IFX_INLINE uint16 IfxAdc_getTmadcTriggerDelayValue(const float32 delayNS)
{
    uint16 delayVal;
    uint32 reqDelay = (uint32)(delayNS * 10U);

    for (delayVal = 0; delayVal < 0xFFFF; delayVal++)
    {
        if ((uint32)(125 * (delayVal + 1)) >= reqDelay)
        {
            break; /* break out. stVal value has matched sampling time */
        }
    }

    return delayVal;
}


IFX_INLINE void IfxAdc_runTmadcModule(Ifx_ADC_TMADC *tmadc)
{
    tmadc->MODCFG.B.RUN = 1u;
}


IFX_INLINE void IfxAdc_stopTmadcModule(Ifx_ADC_TMADC *tmadc)
{
    tmadc->MODCFG.B.RUN = 0u;
}


IFX_INLINE void IfxAdc_enableCdspClock(IfxAdc_CdspCore coreId)
{
    uint32 offset = coreId + IFX_ADC_CLKEN_CDSP_CDSPEN_OFF;
    Ifx__imaskldmst((void *)&MODULE_ADC.CLKEN.CDSP.U, 1u, offset, 1u);
}


IFX_INLINE boolean IfxAdc_getCdspCoreSleepStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if ((cdsp->SLPST.U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_clearCdspWakeupError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    Ifx__imaskldmst((void *)&cdsp->WUERRCL.U, 1u, coreId, 1u);
}


IFX_INLINE boolean IfxAdc_getCdspWakeupErrorStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if ((cdsp->WUERREV.U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_runCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    Ifx__imaskldmst((void *)&cdsp->GLOBRCD.U, 1u, coreId, 1u);

    while (((cdsp->GLOBRSD.U >> coreId) & 0x1u) != 1u)
    {
        /* Wait for core to run */
    }
}


IFX_INLINE boolean IfxAdc_getCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg)
{
    boolean event = FALSE;

    if ((cdsp->RESEV[reg].U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE uint8 IfxAdc_getCdspFifoFillLevel(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    return (uint8)(cdsp->DSP[coreId].DSPST.B.FILL);
}


IFX_INLINE void IfxAdc_initTmadcPin(const IfxAdc_TmadcCh_In *tmadcpin, IfxPort_InputMode pinMode, IfxPort_PadDriver padDriver)
{
    if ((tmadcpin != NULL_PTR) && (tmadcpin->pin.port != NULL_PTR))
    {
        IfxPort_setPinModeInput(tmadcpin->pin.port, tmadcpin->pin.pinIndex, pinMode);
        IfxPort_setPinPadDriver(tmadcpin->pin.port, tmadcpin->pin.pinIndex, padDriver);
        IfxPort_setPinFunctionMode(tmadcpin->pin.port, tmadcpin->pin.pinIndex, IfxPort_PinFunctionMode_analog);
    }
}


IFX_INLINE void IfxAdc_initTmadcEmuxCtrlPin(const IfxAdc_Emuxctrl_Out *emuxPin, IfxPort_OutputMode pinMode, IfxPort_PadDriver padDriver)
{
    if ((emuxPin != NULL_PTR) && (emuxPin->pin.port != NULL_PTR))
    {
        IfxPort_setPinModeOutput(emuxPin->pin.port, emuxPin->pin.pinIndex, pinMode, emuxPin->select);
        IfxPort_setPinPadDriver(emuxPin->pin.port, emuxPin->pin.pinIndex, padDriver);
    }
}


IFX_INLINE IfxApProt_Status IfxAdc_initProtE(Ifx_ADC *adc, IfxApProt_ProtConfig *config, IfxAdc_ProtE id)
{
    return IfxApProt_init((Ifx_PROT_PROT *)&adc->PROTE[id], config);
}


IFX_INLINE IfxApProt_Status IfxAdc_initProtSE(Ifx_ADC *adc, IfxApProt_ProtConfig *config)
{
    return IfxApProt_init((Ifx_PROT_PROT *)&adc->PROTSE, config);
}


IFX_INLINE void IfxAdc_initTmadcResource(Ifx_ADC *adc, IfxAdc_TmadcModule moduleId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);
    IFXADC_SETRESALLOCCFG(adc->RESALLOC.TMADC, moduleId, apuId);
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_initGlobalResource(Ifx_ADC *adc, IfxAdc_GlobalResource resourceId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);
    IFXADC_SETRESALLOCCFG(adc->RESALLOC.GLOB, resourceId, apuId);
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_initCdspResource(Ifx_ADC *adc, IfxAdc_CdspCore cdspId, IfxAdc_Apu apuId)
{
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_config);
#if IFXADC_NUM_CDSP_CORES > 8U

    if (cdspId < IfxAdc_CdspCore_8)
#endif
    {
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPA, cdspId, apuId);
    }

#if IFXADC_NUM_CDSP_CORES > 16U
    else if (cdspId < IfxAdc_CdspCore_16)
    {
        cdspId = (IfxAdc_CdspCore)(cdspId - IfxAdc_CdspCore_8);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPB, cdspId, apuId);
    }
#elif IFXADC_NUM_CDSP_CORES == 12U
    else
    {
        cdspId = (IfxAdc_CdspCore)(cdspId - IfxAdc_CdspCore_8);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPB, cdspId, apuId);
    }
#endif
#if IFXADC_NUM_CDSP_CORES > 16U
    else
    {
        cdspId = (IfxAdc_CdspCore)(cdspId - IfxAdc_CdspCore_16);
        IFXADC_SETRESALLOCCFG(adc->RESALLOC.CDSPC, cdspId, apuId);
    }
#endif
    IfxApProt_setState((Ifx_PROT_PROT *)&adc->PROTSE, IfxApProt_State_run);
}


IFX_INLINE void IfxAdc_enableTmadcModule(IfxAdc_TmadcModule moduleId)
{
    Ifx__imaskldmst((void *)&MODULE_ADC.CLKEN.TMADC.U, 1u, moduleId, 1u);
}


IFX_INLINE void IfxAdc_disableTmadcModule(IfxAdc_TmadcModule moduleId)
{
    Ifx__imaskldmst((void *)&MODULE_ADC.CLKEN.TMADC.U, 0u, moduleId, 1u);
}


IFX_INLINE void IfxAdc_enableCdspGlobal(void)
{
    Ifx__imaskldmst((void *)&MODULE_ADC.CLKEN.CDSP.U, 1u, IFX_ADC_CLKEN_CDSP_CDSPGL_OFF, 1u);
}


IFX_INLINE void IfxAdc_resetCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    Ifx__imaskldmst((void *)&cdsp->GLOBRD.U, 1u, coreId, 1u);
}


IFX_INLINE void IfxAdc_haltCdspCore(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    Ifx__imaskldmst((void *)&cdsp->GLOBHCD.U, 1u, coreId, 1u);

    /* Wait for core to go in halt state */
    while (!(cdsp->GLOBHSTD.U & (1u << coreId)))
    {}
}


IFX_INLINE void IfxAdc_loadCdspMemory(void *srcAddr, void *destAddr, uint16 size)
{
    if ((srcAddr != NULL_PTR) && (destAddr != NULL_PTR))
    {
        uint32 *src_long  = (uint32 *)srcAddr;
        uint32 *dest_long = (uint32 *)destAddr;

        /* To check if address is 4 byte aligned */
        if (!((uint32)src_long & 0x03U) && !((uint32)dest_long & 0x03U))
        {
            /* Transfer 4 bytes */
            while (size >= 4u)
            {
                *dest_long++ = *src_long++;
                size        -= 4u;
            }

            /* 8 bit access not allowed in ICCM and DCCM.
             * hence clearing and Writing valid data in word.
             */
            if (size != 0u)
            {
                uint32 src_data = *src_long;

                /* Reading 32 bit data from source address
                 * Extract only required data and clear remaining bytes.
                 */
                src_data   = src_data & ~(0xFFFFFFU << (size * 8));
                *dest_long = src_data;
            }
        }
    }
}


IFX_INLINE void IfxAdc_clearCdspResultEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspResultReg reg)
{
    cdsp->RESEVCLR[reg].B.RESEVCLR = (1u << coreId);
}


IFX_INLINE boolean IfxAdc_getCdspCoreHaltStatus(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if ((cdsp->GLOBHSTD.U & (1u << coreId)) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE sint16 IfxAdc_readTmadcResult(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg)
{
    return (sint16)(MODULE_ADC.TMADC[moduleId].AW0.RES[resultReg].B.RESULT);
}


IFX_INLINE uint16 IfxAdc_readTmadcTimestamp(IfxAdc_TmadcModule moduleId, IfxAdc_TmadcResultReg resultReg)
{
    return (uint16)(MODULE_ADC.TMADC[moduleId].AW0.TS[resultReg].B.TIMESTAMP);
}


IFX_INLINE boolean IfxAdc_isTmadcMonitorChannelResultAvailable(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel)
{
    uint32 resultEvent = tmadc->RESF.B.RESEV;
    uint8  shift       = channel + IFXADC_TMADC_MCH_OFFSET;
    return (resultEvent & ((uint32)1 << shift)) != (uint32)0;
}


IFX_INLINE void IfxAdc_clearTmadcMonitorChannelResultFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcMonitorChannel channel)
{
    tmadc->RESFCLR.B.RESEVCLR = ((uint32)1 << (channel + IFXADC_TMADC_MCH_OFFSET));
}


IFX_INLINE uint8 IfxAdc_getTmadcTriggerErrorNumber(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return tmadc->CH[channel].STAT.B.TRENR;
}


IFX_INLINE boolean IfxAdc_isTmadcHwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return tmadc->CH[channel].STAT.B.HWTRE;
}


IFX_INLINE boolean IfxAdc_isTmadcSwTriggerIgnored(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return tmadc->CH[channel].STAT.B.SWTRE;
}


IFX_INLINE boolean IfxAdc_getTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcBoundaryReg boundaryReg)
{
    return tmadc->BFL[boundaryReg].STAT.B.BFL;
}


IFX_INLINE boolean IfxAdc_isTmadcErrorEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    return (tmadc->ERRF.U & (1u << channel)) != 0u;
}


IFX_INLINE boolean IfxAdc_isTmadcBoundaryEventOccured(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg)
{
    return (tmadc->BNDF.U & (1u << resultReg)) != 0u;
}


IFX_INLINE void IfxAdc_clearTmadcErrorFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcChannel channel)
{
    tmadc->ERRFCLR.U = (1u << channel);
}


IFX_INLINE void IfxAdc_clearTmadcBoundaryFlag(Ifx_ADC_TMADC *tmadc, IfxAdc_TmadcResultReg resultReg)
{
    tmadc->BNDFCLR.U = (1u << resultReg);
}


IFX_INLINE void IfxAdc_triggerTmadcMonitorChannel(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcMonitorChannel channelId)
{
    uint8 shift = (channelId + IFXADC_TMADC_MCH_OFFSET);
    tmSFR->SWTRCFG.B.SCHSEL = (1u << shift);
}


IFX_INLINE void IfxAdc_configureTmadcEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcEventSel event)
{
    if (srvNode != IfxAdc_TmadcServReq_none)
    {
        tmSFR->SR[srvNode].CFG.B.EVSEL = event;
    }
}


IFX_INLINE void IfxAdc_enableTmadcChannelEvent(Ifx_ADC_TMADC *tmSFR, IfxAdc_TmadcServReq srvNode, IfxAdc_TmadcChannel channelId)
{
    if (srvNode != IfxAdc_TmadcServReq_none)
    {
        tmSFR->SR[srvNode].CFG.B.EVEN |= (1u << channelId);
    }
}


IFX_INLINE boolean IfxAdc_getCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    boolean event = FALSE;

    if (((cdsp->BNDCF.U >> coreId) & 1u) != 0u)
    {
        event = TRUE;
    }

    return event;
}


IFX_INLINE void IfxAdc_clearCdspBoundaryEvent(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId)
{
    Ifx__imaskldmst((void *)&cdsp->BNDCFCL.U, 1u, coreId, 1u);
}


IFX_INLINE void IfxAdc_clearCdspError(Ifx_ADC_CDSP *cdsp, IfxAdc_CdspCore coreId, IfxAdc_CdspError error)
{
    cdsp->DSP[coreId].CHERRCL.U = (1u << error);
}


#endif /* IFXADC_H */
