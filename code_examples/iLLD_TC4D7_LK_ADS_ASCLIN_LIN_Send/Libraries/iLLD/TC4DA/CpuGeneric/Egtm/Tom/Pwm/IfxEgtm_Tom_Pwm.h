/**
 * \file IfxEgtm_Tom_Pwm.h
 * \brief EGTM PWM details
 * \ingroup IfxLld_Egtm
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Egtm_Tom_Pwm_Usage How to use the EGTM TOM PWM Driver
 * \ingroup IfxLld_Egtm_Tom_Pwm
 *
 * This interface allows to generate PWM signal using TOM submodule of eGTM. User can configure the required frequency and duty cycle of the signal.
 *
 * Functionalities provided:
 *     -# Users can choose cluster and channel number of TOM
 *     -# Period and duty cycle can be provided in ticks
 *     -# Signal level during duty cycle can be configured
 *     -# Interrupt can be generated at CCU0 (period event) and/or CCU1 (duty event) match
 *     -# PWM can be routed to Pin using TOUT
 *     -# Channel can be connected to MSC
 *     -# CM0/CM1 registers can be updated with SR0/SR1 at end of period (synchronousUpdateEnabled)
 *     -# Users can choose to start PWM at end of init (immediateStartEnabled)
 *
 * \section Preparation Preparation
 * \subsection Include Include Files
 *
 * Include following header file into your C code:
 * \code
 *     #include "Egtm/Tom/Pwm/IfxEgtm_Tom_Pwm.h"
 * \endcode
 *
 * \subsection Variables Variables
 * Define global variables if necessary
 *
 *     \code
 *     // Pointer to SFR
 *     Ifx_EGTM *egtm = &MODULE_EGTM;
 *
 *     // Interrupt priority
 *     #define TOM0_CH0_PRIO 20
 *     \endcode
 *
 * \subsection Interrupts Interrupts
 * Define Interrupts if needed
 *
 * \code
 * IFX_INTERRUPT(TOM0Ch0_ISR, 0, TOM0_CH0_PRIO)
 * {
 *     // user code
 * }
 * \endcode
 *
 * \subsection Initialization Initialization
 *
 *     \code
 *     // 1. [Optional] Install interrupt handlers
 *     IfxCpu_Irq_installInterruptHandler(TOM0Ch0_ISR, TOM0_CH0_PRIO);
 *
 *     // 2. Enable eGTM clocks
 *     {
 *         float32 frequency = IfxEgtm_Cmu_getModuleFrequency(egtm);
 *
 *         // Enables the EGTM
 *         IfxEgtm_enable(egtm);
 *
 *         // Set the global clock frequency to the max
 *         IfxEgtm_Cmu_setGclkFrequency(egtm, frequency);
 *
 *         // Set the CMU CLK0
 *         IfxEgtm_Cmu_setClkFrequency(egtm, IfxEgtm_Cmu_Clk_0, frequency);
 *
 *         // FXCLK: used by TOM and CLK0: used by TOM
 *         IfxEgtm_Cmu_enableClocks(egtm, IFXEGTM_CMU_CLKEN_FXCLK | IFXEGTM_CMU_CLKEN_CLK0);
 *     }
 *
 *     // 3. Instantiate variables
 *     IfxEgtm_Tom_Pwm_Config tomConfig; // Configuration structure
 *     IfxEgtm_Tom_Pwm_Driver tomHandle; // Handle
 *     IfxEgtm_MscOut           mscOut;     // MSC connection structure
 *
 *     // 4. Initialize with default values
 *     IfxEgtm_Tom_Pwm_initConfig(&tomConfig, egtm);
 *
 *     // 5. Manual Configuration
 *     tomConfig.cluster      = IfxEgtm_Cluster_0;     // TOM Cluster
 *     tomConfig.tomChannel  = IfxEgtm_Tom_Ch_0;       // TOM Channel
 *     tomConfig.period       = 20;                    // Period in ticks
 *     tomConfig.dutyCycle    = 10;                    // Duty cycle in ticks
 *     tomConfig.signalLevel  = Ifx_ActiveState_high;  // Choose signal level during duty
 *     tomConfig.synchronousUpdateEnabled   = TRUE;    // Update CM0/CM1 registers from Shadow at end of period
 *     tomConfig.immediateStartEnabled      = TRUE;    // Start PWM at end of init
 *
 *     // 6. [Optional] Interrupt configuration
 *     tomConfig.interrupt.ccu0Enabled = TRUE;
 *     tomConfig.interrupt.isrPriority = TOM0_CH0_PRIO;
 *
 *     // 7. [Optional] Output Pin connection
 *     tomConfig.pin.outputPin  = &IfxEgtm_TOM0_0_TOUT0_P02_0_OUT;
 *     tomConfig.pin.outputMode = IfxPort_OutputMode_pushPull;
 *     tomConfig.pin.padDriver  = IfxPort_PadDriver_cmosAutomotiveSpeed1;
 *
 *     // 8. [Optional] MSC Connection: Configure the structure mscOut as per the requirement.
 *     // During the Pwm init, Msc connection will be established with the configured channel by API call to IfxGtm_ConnectToMsc.
 *     mscOut.mscSet       = IfxEgtm_Cfg_MscSet_0;
 *     mscOut.mscSetSignal = IfxEgtm_Cfg_MscSetSignal_0;
 *     mscOut.mscModule    = IfxEgtm_Cfg_MscModule_0;
 *     mscOut.mscAltIn     = IfxEgtm_MscAltInput_low;
 *     tomConfig.mscOut   = &mscOut;                  // Attach to config
 *
 *     // 9. Call the init functions
 *     IfxEgtm_Tom_Pwm_init(&tomHandle, &tomConfig);
 *     \endcode
 *
 * TOM will be now generating a PWM signal on the selected port pin while generating selected interrupt according to above configured period and duty cycle.
 *
 * \subsection RunTime Run Time APIs
 *
 * To start the PWM, the following API can be called if channel was not started in init
 *
 *     \code
 *     // Start PWM immediately
 *     IfxEgtm_Tom_Pwm_start(&tomHandle, TRUE);
 *     \endcode
 *
 * To stop the PWM, call this API
 *
 *     \code
 *     // Stop PWM immediately
 *     IfxEgtm_Tom_Pwm_stop(&tomHandle, TRUE);
 *     \endcode
 *
 * \defgroup IfxLld_Egtm_Tom_Pwm Tom PWM Interface Driver
 * \ingroup IfxLld_Egtm_Tom
 * \defgroup IfxLld_Egtm_Tom_Pwm_Structures TOM PWM Structures
 * \ingroup IfxLld_Egtm_Tom_Pwm
 * \defgroup IfxLld_Egtm_Tom_Pwm_Functions TOM Pwm Functions
 * \ingroup IfxLld_Egtm_Tom_Pwm
 */

#ifndef IFXEGTM_TOM_PWM_H
#define IFXEGTM_TOM_PWM_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_PinMap/IfxEgtm_PinMap.h"
#include "Egtm/Std/IfxEgtm_Tom.h"
#include "Egtm/Std/IfxEgtm_Cmu.h"
#include "Egtm/Std/IfxEgtm_Dtm.h"

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Egtm_Tom_Pwm_Structures
 * \{ */
/** \brief configuration structure for interrupts
 */
typedef struct
{
    boolean         ccu0Enabled;       /**< \brief Enable/Disable choice for CCU0 trigger interrupt */
    boolean         ccu1Enabled;       /**< \brief Enable/Disable choice for CCU1 trigger interrupt */
    IfxEgtm_IrqMode mode;              /**< \brief IRQ mode of interrupt */
    IfxSrc_Tos      isrProvider;       /**< \brief Type of Service for Ccu0/1 interrupt */
    Ifx_Priority    isrPriority;       /**< \brief Priority for Ccu0/1 interrupt */
    IfxSrc_VmId     vmId;              /**< \brief Virtual machine interrupt service provider */
} IfxEgtm_Tom_Pwm_Interrupt;

/** \brief configuration structure for output pin
 */
typedef struct
{
    IfxEgtm_Tom_ToutMap *outputPin;        /**< \brief Output pin */
    IfxPort_OutputMode   outputMode;       /**< \brief Output mode */
    IfxPort_PadDriver    padDriver;        /**< \brief Pad driver */
} IfxEgtm_Tom_Pwm_pin;

/** \} */

/** \addtogroup IfxLld_Egtm_Tom_Pwm_Structures
 * \{ */
/** \brief Configuration structure
 */
typedef struct
{
    Ifx_EGTM                 *egtm;                           /**< \brief Pointer to EGTM module */
    IfxEgtm_Cluster           cluster;                        /**< \brief Cluster of TOM channel to be used */
    IfxEgtm_Tom_Ch            tomChannel;                     /**< \brief TOM channel to be used for PWM */
    IfxEgtm_Tom_Ch_ClkSrc     clock;                          /**< \brief Clock source for selected TOM channel */
    Ifx_ActiveState           signalLevel;                    /**< \brief Signal Level when duty is active */
    uint16                    period;                         /**< \brief Period in ticks (TOM only supports 16 bits) */
    uint16                    dutyCycle;                      /**< \brief Duty Cycle in ticks (TOM only supports 16 bits) */
    IfxEgtm_Tom_Pwm_Interrupt interrupt;                      /**< \brief Configuration structure for interrupt */
    IfxEgtm_Tom_Pwm_pin       pin;                            /**< \brief Configuration structure for output pin */
    IfxEgtm_MscOut           *mscOut;                         /**< \brief MSC configuration */
    IfxEgtm_Dtm_ClockSource   dtmClockSource;                 /**< \brief DTM clock source */
    boolean                   oneShotModeEnabled;             /**< \brief Enable/Disable the one shot mode (Currently, has no effect) */
    boolean                   synchronousUpdateEnabled;       /**< \brief Synchronous or Asynchronous update. TRUE: Update compare registers from shadow at the end of period */
    boolean                   immediateStartEnabled;          /**< \brief Enable/disable immediate start of PWM. TRUE: Start channel at end of init */
} IfxEgtm_Tom_Pwm_Config;

/** \brief Driver Handle
 */
typedef struct
{
    Ifx_EGTM             *egtm;                           /**< \brief Pointer to EGTM module */
    IfxEgtm_Cluster       clsIndex;                       /**< \brief Index of the CLS object used */
    IfxEgtm_Tom_Ch        tomChannel;                     /**< \brief TOM channel used for the timer */
    Ifx_EGTM_CLS_TOM     *tom;                            /**< \brief Pointer to the TOM object */
    Ifx_EGTM_CLS_TOM_TGC *tgc[IFXEGTM_TOM_NUM_TGC];       /**< \brief Pointer to the TGC object */
} IfxEgtm_Tom_Pwm_Driver;

/** \} */

/** \addtogroup IfxLld_Egtm_Tom_Pwm_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initializes a TOM channel to generate PWM signal
 * \param driver TOM Handle
 * \param config Configuration structure for TOM PWM
 * \return Initialization status: TRUE on success else FALSE
 */
IFX_EXTERN boolean IfxEgtm_Tom_Pwm_init(IfxEgtm_Tom_Pwm_Driver *driver, const IfxEgtm_Tom_Pwm_Config *config);

/** \brief Initializes the configuration structure to default values
 * \param config This parameter is initialized by the function
 * \param egtm Pointer to EGTM module (SFR)
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tom_Pwm_initConfig(IfxEgtm_Tom_Pwm_Config *config, Ifx_EGTM *egtm);

/** \brief starts the PWM generation from the configured channel
 * \param driver handle for the PWM device
 * \param immediate immediate start or not
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tom_Pwm_start(IfxEgtm_Tom_Pwm_Driver *driver, boolean immediate);

/** \brief Stops the PWM generation from the configured channel
 * \param driver handle for the PWM device
 * \param immediate immediate start or not.
 * \return None
 */
IFX_EXTERN void IfxEgtm_Tom_Pwm_stop(IfxEgtm_Tom_Pwm_Driver *driver, boolean immediate);

/** \} */

#endif /* IFXEGTM_TOM_PWM_H */
