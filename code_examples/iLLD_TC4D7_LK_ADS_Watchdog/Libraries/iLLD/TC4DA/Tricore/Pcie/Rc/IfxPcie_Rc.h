/**
 * \file IfxPcie_Rc.h
 * \brief PCIE RC details
 * \ingroup IfxLld_Pcie
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Pcie_Rc_Usage How to use the RC Interface layer?
 * \ingroup IfxLld_Pcie
 *
 * \section IfxLld_Pcie_Rc_Overview Overview
 *
 * PCIe devices can be of various types such as Endpoint (EP), Root Complex (RC), or a bridge.
 * Aurix TC49x can be configured either as a RC or EP and this documentation describes how to use the device as a RC.
 *
 * \subsection IfxLld_Pcie_Rc_Overview_Func Functionalities Provided
 * The RC interface layer supports the following functionalities:
 *     -# Configuration of RC controller parameters, memory regions
 *     -# Finding and enumerating endpoints or bridges using depth first search
 *     -# Probe memories and capabilites of all devices
 *     -# Optionally configuring endpoints and bridges based on static configuration
 *     -# Optionally provide access to endpoint and bridge memories as local memory pointers (if ATU is enabled)
 *     -# Reception of all (remote, message, error, and power management) interrupts supported by Aurix
 *     -# Generating remote trigger interrupt to Aurix endpoints
 *
 * \subsection IfxLld_Pcie_Rc_Overview_Init Module Initialization
 *
 * Module Initialization can be done by two methods:
 *     -# By calling the IfxPcie_Rc_init() function.
 *     -# By calling the functions inside IfxPcie_Rc_init() individually.
 *         - Step 1: Call IfxPcie_Rc_initModule()
 *             - Initializes the RC module. Following steps are performed:
 *                 -# Enable Module and set device mode as RC
 *                 -# Perform Kernel reset
 *                 -# Setup HSPHY for PCIe and get clock
 *                 -# Configure RC Config Header parameters such as Device ID, Local memory base, etc.
 *                 -# Probe RC capabilities
 *                 -# Configure RC for interrupt reception
 *         - Step 2: Call IfxPcie_Rc_initLink() to enable link training
 *         - Step 3: Call IfxPcie_Rc_initTopology() to discover and perform enumeration of all devices on topology
 *         - Step 4: Call IfxPcie_Rc_enableEndPoints() to enable end points
 *         - Step 5: Call IfxPcie_Rc_initInterrupts() to configure endpoints or bridges to send interrupts to RC
 *         - Step 6: Call IfxPcieLib_Device_freeAtuRegion() to free the ATU being used by RC for configuring devices
 *
 *
 * \section IfxLld_Pcie_Rc_Topology Topology Discovery
 *
 * RC uses depth first search for enumerating PCIe devices. Users can limit the topology by changing macros described in later section.
 * Users can also give configuration for devices if known devices are to be connected.
 * This configuration can be used for mapping PCIe devices to local memory using Address Translation Units (ATU).
 * If configuration is not provided, users also have the ability to do this mapping later by calling IfxPcie_Rc_mapLocalMemory() function.
 *
 * For each device that the RC encounters, it does the following:
 *     -# Configures ECAM ATU for configuring device using IfxPcie_Rc_mapLocalMemory()
 *     -# Allocates the necessary Bar memories on wire using IfxPcie_Rc_allocateBarMemories()
 *     -# Maps the wire address to PCIe local memory if device configuration is passed using IfxPcie_Rc_mapLocalMemory()
 *     -# Probes device capabilities using IfxPcieLib_Cap_probeCapabilities()
 *     -# Sets PME Active if capability is present using IfxPcieCap_setPmeActive()
 *     -# Sets the primary, secondary, and subordinate bus of bridges
 *     -# Keeps track of upstraeam bridge of all EPs
 *
 * \subsection IfxLld_Pcie_Rc_M1 Configuration Macros
 *
 * These macros can be defined to limit the topology discovery to user defined limits.
 * This can be useful when user already expects a certain topology and wants to save time spent in enumeration by RC.
 *
 * <table>
 * <caption id="multi_row">Pre compile configuration for topology</caption>
 * <tr><th>Macro                      <th>Default Value <th>Description
 * <tr><td>IFXPCIE_CFG_MAX_NUM_OF_BUS <td>6             <td>Set the max number of buses in topology<BR>
 *                                                          Note: Subordinate bus is calculated adding Primary bus and max number of bus
 * <tr><td>IFXPCIE_CFG_MAX_NUM_OF_DEV <td>3             <td>Set max number of devices per bus
 * <tr><td>IFXPCIE_CFG_MAX_NUM_OF_FUN <td>2             <td>Set max number of functions per device
 * <tr><td>IFXPCIE_CFG_RC_PRIMARY_BUS <td>0             <td>Sets the primary bus of RC.
 * </table>
 *
 * In the following table, some other macros that allow configuration limits are mentioned along with their recommended values.
 *
 * <table>
 * <caption id="multi_row">Pre compile configuration for RC controller</caption>
 * <tr><th>Macro                               <th>Recommended Value   <th>Description
 * <tr><td>IFXPCIE_CFG_WIRE_MEM_BASE           <td>0x00000000u         <td>Wire Memory Base of PCIE Topology
 * <tr><td>IFXPCIE_CFG_WIRE_MEM_LIMIT          <td>0xFBFFFFFFu         <td>Wire Memory Limit of PCIE Topology
 * <tr><td>IFXPCIE_CFG_MSI_RECEPTION_ADDRESS   <td>0xFFFFFFFCu         <td>MSI Reception Address
 * <tr><td>IFXPCIE_CFG_PREFETCH_WIRE_MEM_BASE  <td>0x0000000100000000u <td>Pre-fetch Wire Memory Base of PCIE Topology
 * <tr><td>IFXPCIE_CFG_PREFETCH_WIRE_MEM_LIMIT <td>0xFFFBFFFFFFFFFFFFu <td>Pre-fetch Wire Memory Limit of PCIE Topology
 * <tr><td>IFXPCIE_CFG_ECAM_ATU_INDEX          <td>0                   <td>ECAM ATU Outbound Region (This region will be locked for configuration access)
 * </table>
 *
 * Pcie driver is meant to be used with multiple platforms. Following macros enable special features that are required for specific platforms
 * <table>
 * <caption id="multi_row">Platform specific macros</caption>
 * <tr><th>Macro                      <th>Default Value <th>Description
 * <tr><td>IFXPCIE_CFG_RTL_VIP        <td>1             <td>Enable this when interacting with Cadence VIP on RTL
 * <tr><td>IFXPCIE_CFG_ENABLE_PHY     <td>1             <td>Enable this when physical layer is available (RTL, Hardware)
 * </table>
 *
 * \section IfxLld_Pcie_Rc_Code Coding example
 *
 * \subsection IfxLld_Pcie_Rc_Step1 STEP 1: Configure HSPHY
 * This needs to be done in all cases (except VP) for PCIe to use PHY.\n
 * For more details, refer to the documentaion of HSPHY iLLD code.\n
 *
 * In this section, we will do the following:
 *     - Include HSPHY interface (see below: #0)
 *     - Instantiate Variables (see below: #1)
 *     - Initialize and configure HSPHY configuration structure (see below: #2)
 *     - Initialize HSPHY (see below: #3)
 *
 *     \code
 *
 *     //=====================================
 *     // 0. Include HSPHY Interface
 *     //=====================================
 *
 *     #include <Hsphy/Hsphy/IfxHsphy_Hsphy.h>
 *
 *     //=====================================
 *     // 1. Variable Instantiation
 *     //=====================================
 *
 *     IfxHsphy_Hsphy          hsphy;
 *     IfxHsphy_Hsphy_Cfg      phy_config;
 *     IfxHsphy_Hsphy_phyData  hsphyData0;
 *     IfxHsphy_Hsphy_phyData  hsphyData1;
 *
 *     //=====================================
 *     // 2. Configure HSPHY
 *     //=====================================
 *
 *     // 2.1 Assign default values to config structure
 *     IfxHsphy_Hsphy_initModuleConfig(&MODULE_HSPHY,&phy_config);
 *
 *     // 2.2 Configure PHY for PCIE
 *     phy_config.phyConfig[0].phyIdx        = IfxHsphy_PhyIndex_0;
 *     phy_config.phyConfig[0].padInterface  = IfxHsphy_PadNativeInterface_pcie;
 *     phy_config.phyConfig[0].trgtDevice    = IfxHsphy_TrgtDevice_pcie;
 *     phy_config.phyConfig[0].trgtDeviceIdx = IfxPcie_Index_0;
 *     phy_config.phyConfig[0].deviceSpeed   = IfxHsphy_TrgtDeviceSpeed_8G;
 *
 *     // 2.3 Configure PHY for MII
 *     phy_config.phyConfig[1].phyIdx        = IfxHsphy_PhyIndex_1;
 *     phy_config.phyConfig[1].padInterface  = IfxHsphy_PadNativeInterface_sgbt;
 *     phy_config.phyConfig[1].trgtDevice    = IfxHsphy_TrgtDevice_trace;
 *     phy_config.phyConfig[1].trgtDeviceIdx = 0;
 *     phy_config.phyConfig[1].deviceSpeed   = IfxHsphy_TrgtDeviceSpeed_1G;
 *
 *     hsphy.hsphyData[0] = &hsphyData0;
 *     hsphy.hsphyData[1] = &hsphyData1;
 *
 *     //=====================================
 *     // 3. Initialize HSPHY
 *     //=====================================
 *
 *     // 3.1 Init HSPHY for PCIE
 *     IfxHsphy_Hsphy_initModule(&hsphy, &phy_config);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pcie_Rc_Step2 STEP 2: Initialize RC configuration structure
 *
 * In this section, we will do the following:
 *     - Include RC interface (see below: #0)
 *     - Instantiate Variables (see below: #1)
 *     - Initialize RC configuration structure (see below: #2)
 *
 *     \code
 *
 *     //=====================================
 *     // 0. Include RC Interface
 *     //=====================================
 *
 *     #include "Pcie/Rc/IfxPcie_Rc.h"
 *
 *     //=====================================
 *     // 1. Variable Instantiation
 *     //=====================================
 *
 *     // 1.1 Instantiate Config structure
 *     IfxPcie_Rc_Config config;
 *     // 1.2 Instantiate Module Handle
 *     IfxPcie_Rc rc;
 *     // 1.3 Instantiate other variables
 *     IfxPcie_Status status;
 *
 *     //=====================================
 *     // 2. Config structure initialization
 *     //=====================================
 *
 *     // 2.1 Assign default values to config structure members
 *     IfxPcie_Rc_initConfig(&MODULE_PCIE_DSP, &config);
 *
 *     \endcode
 *
 * \subsection IfxLld_Pcie_Rc_Step3 STEP 3: Manually configure RC
 *
 * In this section, we will do the following:
 *     - Configure RC for known/unknown EP (see below: #3.1)
 *     - Configure other variables (see below: #3.2)
 *
 * Next, choose either option 1 or 2.\n
 * <b>[Option 1]</b> Configure known Endpoint\n
 * This step is needed if a known EP exists in the topology and user wants to allocate local memory for accessing it's bar regions.
 * Similar step is required for bridges (\ref IfxPcie_Rc_BridgeCfg data structure)
 *
 *     \code
 *     //=====================================
 *     // 3.1 [Option 1] Configure RC for known EP
 *     //=====================================
 *
 *     IfxPcie_Rc_EndPointCfg endPointCfg;
 *
 *     endPointCfg.epFunction.deviceId     = 0xCCDD;                  // Device ID of EP
 *     endPointCfg.epFunction.vendorId     = 0xAABB;                  // Vendor ID of EP
 *     endPointCfg.barRegion[0].mapToLocal = TRUE;                    // Map local memory of RC to EP's bar 0
 *     endPointCfg.barRegion[0].atuRegion  = IfxPcie_AtuRegion_1;     // Assign ATU region for BAR0
 *     endPointCfg.barRegion[1].mapToLocal = TRUE;
 *     endPointCfg.barRegion[1].atuRegion  = IfxPcie_AtuRegion_2;
 *     endPointCfg.barRegion[2].mapToLocal = FALSE;                   // Don't map to local memory (E.g. If DMA is to be used instead of ATU)
 *     endPointCfg.barRegion[3].mapToLocal = TRUE;
 *     endPointCfg.barRegion[3].atuRegion  = IfxPcie_AtuRegion_4;
 *     endPointCfg.barRegion[4].mapToLocal = TRUE;
 *     endPointCfg.barRegion[4].atuRegion  = IfxPcie_AtuRegion_5;
 *     endPointCfg.barRegion[5].mapToLocal = TRUE;
 *     endPointCfg.barRegion[5].atuRegion  = IfxPcie_AtuRegion_6;
 *
 *     config.endPointCfg                  = &endPointCfg;     // Pointer to end point configuration
 *     config.numEndPoints                 = 1u;               // Number of devices for which configuration has been provided
 *     config.numBridges                   = 0u;               // Number of Bridges for which configuration has been provided
 *     \endcode
 *
 * <b>[Option 2]</b> Configure unknown Endpoint\n
 *     \code
 *     //=====================================
 *     // 3.1 [Option 2] Alternate configuration RC for unknown EP
 *     //=====================================
 *
 *     // Manually change configuration
 *     config.numEndPoints                 = 0u;               // Number of devices for which configuration has been provided
 *     config.numBridges                   = 0u;               // Number of Bridges for which configuration has been provided
 *
 *     \endcode
 *
 * Complete the configuration
 *
 *     \code
 *     //=====================================
 *     // 3.2 Configure other variables
 *     //=====================================
 *     config.hsphySFR                     = &MODULE_HSPHY;    // Pointer to PCIe HSPHY registers
 *     config.rootComplex.deviceId         = 0xBBAA;           // Root Complex device configuration (Device ID)
 *     config.rootComplex.vendorId         = 0x4321;           // Root Complex device configuration (Vendor ID)
 *     config.drsSupport                   = FALSE;            // DRS Support present in topology
 *     \endcode
 *
 * \subsection IfxLld_Pcie_Rc_Step4 STEP 4: Initialize RC
 * In this section, we will do the following:
 *     - Initialize RC (see below: #4)
 *
 *     \code
 *     //=====================================
 *     // 4. Initialize RC
 *     //=====================================
 *
 *     // 4.1 Initialize RC with above configuration
 *     status = IfxPcie_Rc_init(&rc, &config);
 *
 *     // Aurix device is now active as RC
 *     \endcode
 *
 * At this point the root complex handle provides:
 *     -# List of all endpoints and bridges which are enumerated
 *         - rc.numEndPoints (Number of endpoints enumerated)
 *         - rc.numBridges (Number of bridges enumerated)
 *         - rc.endpoint[deviceIndex] (Enumerated endpoint details)
 *         - rc.bridge[deviceIndex] (Enumerated bridge details)
 *     -# Pointers to capabilites stored inside these structure members
 *         - rc.rootComplex.capabilities.msi
 *         - rc.rootComplex.capabilities.msix
 *         - rc.rootComplex.capabilities.pcie
 *         - rc.rootComplex.capabilities.pmc
 *         - rc.rootComplex.capabilities.extendedCap
 *
 * \subsection IfxLld_Pcie_Rc_Step5 STEP 5: Post initialization
 *
 * In this section, we will do the following:
 *     - Try to get device index of enumerated device in the topology (see below: #5)
 *     - Get configuration access to device and then free the access (see below: #6)
 *     - Get access to memory regions of a device (see below: #7)
 *     - Map any memory region to local memory of RC if not already done (see below: #7.3)
 *     - Configure inbound ATU for TLP reception (see below: #8)
 *
 *     \code
 *     boolean status;
 *     uint32* configHeader, localMemoryPtr;
 *     uint8 memRegions, barIndex, memIndex;
 *     uint64 wireMemBase, memSize;
 *     uint32 localMemBase;
 *     uint8 deviceId = 0xCCDD;
 *     uint8 vendorId = 0xAABB;
 *     IfxPcieDevice_Type deviceType = IfxPcieDevice_Type_endpoint;
 *
 *     //=====================================
 *     // 5. Getting index of enumerated devices
 *     //=====================================
 *     // If you have statically configured a device, you can get the device index using the following API
 *     // Pass handle, device Id, vendor Id and device type. Refer API documentation for more info
 *     deviceIndex = IfxPcie_Rc_getEnumeratedDeviceIndex(&rc, deviceId, vendorId, deviceType);
 *
 *     //=====================================
 *     // 6. Using configuration accesses after enumeration
 *     //=====================================
 *     // Note: One ATU (defined by IFXPCIE_CFG_ECAM_ATU_INDEX) is always used for configuration.
 *
 *     // 6.1 To get access to this ATU after RC initialization, call the following function:
 *     // Returns base address of config structure of device after configuring ATU
 *     // If Null pointer is returned, it means that the ATU region is locked.
 *     configHeader = IfxPcie_Rc_getConfigAccess(&rc, deviceIndex, deviceType);
 *
 *     // 6.2 Free configuration access
 *     status = IfxPcie_Rc_freeConfigAccess(&rc, deviceIndex, deviceType);
 *
 *     //=====================================
 *     // 7. Get access to memory regions
 *     //=====================================
 *
 *     // 7.1 Get number of memory regions
 *     memRegions = IfxPcie_Rc_getNumMemRegions(&rc, deviceIndex, deviceType);
 *
 *     // 7.2 Get bar wire address of Bar 1 of device 0
 *     barIndex = 1;
 *     wireMemBase = IfxPcie_Rc_getBarWireAddress(&rc, deviceIndex, barIndex, deviceType);
 *
 *     // 7.3 [Optional] Map Bar 1 to local memory if configuration was not provided to init() function
 *     // Note: Memory index can be different from bar index
 *     // Eg. If only bar 0, 1, 3, and 5 are active of EP, the bars will have memory index as 0, 1, 2, 3 respectively
 *     memIndex = 1;
 *     status = IfxPcie_Rc_mapLocalMemory(&rc, deviceIndex, memIndex, IfxPcie_AtuRegion_1, deviceType)
 *
 *     // 7.4 Get local address assigned to bar 1
 *     localMemoryPtr = IfxPcie_Rc_getBarLocalAddress(&rc, deviceIndex, barIndex, deviceType);
 *
 *     // 7.5 Get size of bar memory region
 *     memSize = IfxPcie_Rc_getBarMemRegionSize(&rc, deviceIndex, barIndex, deviceType);
 *
 *     //=====================================
 *     // 8. Configure Inbound ATU
 *     //=====================================
 *     // Inbound ATU needs to be configured separately to receive TLP
 *     // E.g. Use LMU as reception address
 *     localMemBase = 0xB0300000;
 *
 *     status = IfxPcie_Rc_configureInBoundAtu(&rc, wireMemBase, localMemBase, memSize, IfxPcie_AtuRegion_1);
 *
 *     // Now TLPs coming to wireMemBase is mapped to localMemBase for inbound TLPs
 *     // wireMemBase should be greater than IFXPCIE_CFG_WIRE_MEM_LIMIT
 *     \endcode
 *
 * <b>Using Aurix capabilites</b>\n
 * RC interface deals only with initialization/enumeration.\n
 * For using other capabilites, refer Pcie/Std/IfxPcieCap.* for more APIs\n
 *
 * <b>Using DMA</b>\n
 * To use DMA, refer to Pcie/Lib/Dma/IfxPcieLib_Dma.* files for APIs and documentation.\n
 * Note: Before using DMA, perform the initialization of Aurix device in RC/EP mode.
 *
 * \subsection IfxLld_Pcie_Rc_TLP Send TLP from RC to EP
 *
 * In this section, we will do the following:
 *     - Send a TLP to selected device index by writing to local address that will be translated by ATU (see below: #8)
 *
 *     \code
 *     //=====================================
 *     // 8. Send TLP
 *     //=====================================
 *     uint32* localMemoryPtr; // Local address of EP memory region
 *     uint8 deviceIndex = 0;  // Device Index
 *     uint8 memIndex    = 1;  // Memory index of EP
 *
 *     // Note: IfxPcie_Rc_getLocalAddress accepts memory index instead of bar index!
 *     localMemoryPtr = IfxPcie_Rc_getLocalAddress(&rc, deviceIndex, memIndex, IfxPcieDevice_Type_endpoint);
 *
 *     // Send Data by simply writing to address
 *     *localMemoryPtr = 0xAABBCCDD;
 *     \endcode
 *
 * \defgroup IfxLld_Pcie_Rc RC
 * \ingroup IfxLld_Pcie
 * \defgroup IfxLld_Pcie_Rc_Enumerations Enumerations
 * \ingroup IfxLld_Pcie_Rc
 * \defgroup IfxLld_Pcie_Rc_Structures Structures
 * \ingroup IfxLld_Pcie_Rc
 * \defgroup IfxLld_Pcie_Rc_Functions Functions
 * \ingroup IfxLld_Pcie_Rc
 */

#ifndef IFXPCIE_RC_H
#define IFXPCIE_RC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Pcie/Std/IfxPcie.h"
#include "Pcie/Std/IfxPcieRc.h"
#include "Pcie/Lib/Device/IfxPcieLib_Device.h"
#include "Pcie/Lib/Cap/IfxPcieLib_Cap.h"
#include "Pcie/Lib/Dma/IfxPcieLib_Dma.h"
#include "Pcie/Ep/IfxPcie_Ep.h"
#include "Hsphy/Std/IfxHsphy.h"
#include "Port/Std/IfxPort.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Use this index for a non-configured EP
 */
#define IFXPCIE_RC_NULL_CFG_INDEX ((uint8)0xFFu)

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Rc_Enumerations
 * \{ */
/** \brief PCIE RC states
 */
typedef enum
{
    IfxPcie_Rc_State_uknown = -1,
    IfxPcie_Rc_State_enabled,
    IfxPcie_Rc_State_initialized,
    IfxPcie_Rc_State_linkUp,
    IfxPcie_Rc_State_enumerated,
    IfxPcie_Rc_State_error,
    IfxPcie_Rc_State_configError
} IfxPcie_Rc_State;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Pcie_Rc_Structures
 * \{ */
/** \brief Remote Interrupt Handle from RC
 */
typedef struct
{
    IfxPcie_IntVector intVector;           /**< \brief Interrupt Vector to IR */
    uint32            mask;                /**< \brief Initial Mask. 1<<pos: mask interrupt #"pos" (ignored for INTx) */
    uint32            pendingBits;         /**< \brief Pending INTR. 1<<pos: Interrupt Pending @ #"pos" (ignored for INTx) */
    uint8             numInterrupts;       /**< \brief Number of MSI(x) Interrupts (ignored for INTx) */
} IfxPcie_Rc_RemoteIntVector;

/** \} */

/** \addtogroup IfxLld_Pcie_Rc_Structures
 * \{ */
/** \brief EP Interrupt Handle
 */
typedef struct
{
    IfxPcie_Rc_RemoteIntVector intVector[IFXPCIE_CFG_MAX_NUM_EP_INTVECTORS];       /**< \brief Array of Interrupt Vectors for this EP */
    uint8                      numVectors;                                         /**< \brief Number of Interrupts to IR. For MSI: limited to 1 */
} IfxPcie_Rc_FunctionInt;

/** \brief EP Memory Handle from RC
 */
typedef struct
{
    IfxPcieLib_Device_Mem functionMem;        /**< \brief EP Device Memory Parameters */
    uint32                localMemBase;       /**< \brief Start address of the memory (in local memory) */
    IfxPcie_AtuRegion     atuRegion;          /**< \brief Dedicated ATU region index for this memory */
} IfxPcie_Rc_Mem;

/** \brief Remote Interrupt Configuration from RC
 */
typedef struct
{
    IfxPcieLib_Device_IntNodeCfg node;                /**< \brief Interrupt Vector Node Configuration */
    IfxPcie_MsiInterrupt         numInterrupts;       /**< \brief Number of Interrupts (if Applicable more than 1) */
    uint32                       initialMask;         /**< \brief Initial Mask. 1<<pos: mask interrupt #"pos" (ignored for INTx) */
} IfxPcie_Rc_RemoteIntVectorCfg;

/** \} */

/** \addtogroup IfxLld_Pcie_Rc_Structures
 * \{ */
/** \brief Bridge Handle from RC
 */
typedef struct
{
    IfxPcieLib_Device_Bridge bridgeFunction;                                   /**< \brief End Point Function Handle */
    IfxPcie_Rc_FunctionInt   interrupt;                                        /**< \brief Interrupt Handle */
    IfxPcie_Rc_Mem           memRegion[IFXPCIE_CFG_MAX_NUM_BRIDGE_BARS];       /**< \brief Memory Regions */
    uint8                    numMemRegions;                                    /**< \brief Number of memory regions */
    uint8                    numVectors;                                       /**< \brief Number of Interrupts to IR. For MSI: limited to 1 */
    uint8                    configIndex;                                      /**< \brief Index of Bridge configured by user */
} IfxPcie_Rc_Bridge;

/** \brief EP Interrupt Vector Configuration
 */
typedef struct
{
    IfxPcie_Rc_RemoteIntVectorCfg intVector[IFXPCIE_CFG_MAX_NUM_EP_INTVECTORS];       /**< \brief Array of Interrupt Vectors for this EP */
    uint8                         numVectors;                                         /**< \brief Number of Interrupts to IR. For MSI: limited to 1 */
} IfxPcie_Rc_FunctionIntCfg;

/** \brief EP Memory Configuration from RC
 */
typedef struct
{
    boolean           mapToLocal;       /**< \brief Memory Region is enabled */
    IfxPcie_AtuRegion atuRegion;        /**< \brief Dedicated ATU region index for this memory */
} IfxPcie_Rc_MemCfg;

/** \} */

/** \addtogroup IfxLld_Pcie_Rc_Structures
 * \{ */
/** \brief RC Address Space Handle
 */
typedef struct
{
    uint32 wireMemBase;                /**< \brief Start address of the PCIE memory free area */
    uint32 wireMemLimit;               /**< \brief End address of PCIE memory topology */
    uint64 wireMemPrefetchBase;        /**< \brief Start address of the PCIE memory Prefetch free area */
    uint64 wireMemPrefetchLimit;       /**< \brief End address of PCIE memory Prefetch topology */
    uint32 localConfigBase;            /**< \brief Start address of Config space in SOC Bus (outbound) */
    uint32 localConfigLimit;           /**< \brief End address of Config space in SOC Bus (outbound) */
    uint32 localMemBase;               /**< \brief Start address of PCIE free area space in SOC Bus */
    uint32 localMemLimit;              /**< \brief size of PCIE space in SOC Bus */
} IfxPcie_Rc_AddressSpace;

/** \brief RC Address Space Configuration
 */
typedef struct
{
    uint64 wireMemPrefetchBase;        /**< \brief Start address of the PCIE memory Prefetch space */
    uint64 wireMemPrefetchLimit;       /**< \brief End address of the PCIE memory Prefetch space */
    uint32 wireMemBase;                /**< \brief Start address of the PCIE memory space */
    uint32 wireMemLimit;               /**< \brief End address of the PCIE memory space */
    uint32 localMemBase;               /**< \brief Start address of PCIE space in SOC Bus (outbound) */
    uint32 localMemLimit;              /**< \brief End address of PCIE space in SOC Bus (outbound) */
    uint32 localConfigBase;            /**< \brief Start address of Config space in SOC Bus (outbound) */
} IfxPcie_Rc_AddressSpaceCfg;

/** \brief Bridge configuration from RC
 */
typedef struct
{
    IfxPcieLib_Device_FunctionCfg bridgeFunction;                                   /**< \brief Protocol EP Function Config */
    IfxPcie_Rc_FunctionIntCfg     interrupt;                                        /**< \brief Interrupt Configuration */
    IfxPcie_Rc_MemCfg             barRegion[IFXPCIE_CFG_MAX_NUM_BRIDGE_BARS];       /**< \brief Memory Regions Config */
} IfxPcie_Rc_BridgeCfg;

/** \brief End Point Handle from RC
 */
typedef struct
{
    IfxPcieLib_Device_EndPoint epFunction;                                   /**< \brief End Point Function Handle */
    IfxPcie_Rc_Bridge         *upStreamBridgePtr;                            /**< \brief Pointer to upstream Bridge */
    IfxPcie_Rc_FunctionInt     interrupt;                                    /**< \brief Interrupt Handle */
    IfxPcie_Rc_Mem             memRegion[IFXPCIE_CFG_MAX_NUM_EP_BARS];       /**< \brief Memory Regions */
    uint8                      numMemRegions;                                /**< \brief Number of memory regions */
    uint8                      numVectors;                                   /**< \brief Number of Interrupts to IR. For MSI: limited to 1 */
    uint8                      configIndex;                                  /**< \brief Index of EP configured by user */
} IfxPcie_Rc_EndPoint;

/** \brief EP configuration from RC
 */
typedef struct
{
    IfxPcieLib_Device_FunctionCfg epFunction;                                   /**< \brief Protocol EP Function Config */
    IfxPcie_Rc_FunctionIntCfg     interrupt;                                    /**< \brief Interrupt Configuration */
    IfxPcie_Rc_MemCfg             barRegion[IFXPCIE_CFG_MAX_NUM_EP_BARS];       /**< \brief Memory Regions Config */
} IfxPcie_Rc_EndPointCfg;

/** \brief Interrupt Configuration
 */
typedef struct
{
    IfxPcie_InterruptType        remoteIntType;        /**< \brief Type of Remote Interrupt */
    IfxPcie_PmeInterrupt         pmeIntEnable;         /**< \brief Power Management Interrupt Enable Mask */
    IfxPcie_ErrorInterrupt       errorIntEnable;       /**< \brief Error Management Interrupt Enable Mask */
    IfxPcieLib_Device_IntNodeCfg errorIntnode;         /**< \brief General Error Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg aerIntnode;           /**< \brief AER Error Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg pmeIntNode;           /**< \brief PME Interrupt Node configuration */
    IfxPcieLib_Device_IntNodeCfg linkIntNode;          /**< \brief Link Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg msgIntnode;           /**< \brief Message Interrupt node configuration */
    IfxPcieLib_Device_IntNodeCfg miscIntnode;          /**< \brief Miscellaneous Interrupt node configuration */
} IfxPcie_Rc_InterruptCfg;

/** \} */

/** \addtogroup IfxLld_Pcie_Rc_Structures
 * \{ */
/** \brief RC Handle
 */
typedef struct
{
    Ifx_PCIE_DSP                 *pcieSFR;                                  /**< \brief Pointer to PCIe RC registers */
    Ifx_HSPHY                    *hsphySFR;                                 /**< \brief Pointer to PCIe HSPHY registers */
    IfxPcie_Index                 index;                                    /**< \brief Index of the PCIE */
    IfxPcie_Rc_EndPoint           endPoint[IFXPCIE_CFG_MAX_NUM_EP];         /**< \brief list of End Point Functions connected to topology */
    IfxPcie_Rc_Bridge             bridge[IFXPCIE_CFG_MAX_NUM_BRIDGE];       /**< \brief list of Bridges connected to topology */
    IfxPcieLib_Device_RootComplex rootComplex;                              /**< \brief pointer to the RC device parameters */
    IfxPcie_Rc_AddressSpace       addressSpace;                             /**< \brief PCIE topology address space */
    IfxPcieLib_Device_Atu         atu;                                      /**< \brief ATU Handle */
    uint8                         numEndPoints;                             /**< \brief Number of End Points enumerated */
    uint8                         numBridges;                               /**< \brief Number of Bridges enumerated */
    IfxPcie_InterruptType         interruptType;                            /**< \brief Type of Interrupt in the System */
    IfxPcie_Rc_State              state;                                    /**< \brief Current State of the RC device */
} IfxPcie_Rc;

/** \brief RC Configuration
 */
typedef struct
{
    Ifx_PCIE_DSP                    *pcieSFR;            /**< \brief Pointer to PCIe RC registers */
    Ifx_HSPHY                       *hsphySFR;           /**< \brief Pointer to PCIe HSPHY registers */
    IfxPcie_Index                    index;              /**< \brief Index of the PCIE */
    IfxPcie_Rc_AddressSpaceCfg       addressSpace;       /**< \brief PCIE topology address space */
    IfxPcieLib_Device_RootComplexCfg rootComplex;        /**< \brief Root Complex device configuration */
    IfxPcie_Rc_EndPointCfg          *endPointCfg;        /**< \brief Pointer to End Point configurations */
    IfxPcie_Rc_BridgeCfg            *bridgeCfg;          /**< \brief Pointer to Bridge Configurations */
    IfxPcie_Rc_InterruptCfg          interrupt;          /**< \brief Interrupt Configuration */
    uint8                            numEndPoints;       /**< \brief Number of Known EP to be configured */
    uint8                            numBridges;         /**< \brief Number of Known Bridges to be configured */
    boolean                          drsSupport;         /**< \brief DRS Support present in topology */
    IfxPcieRc_LaneWidth              LaneWidth;          /**< \brief Lane width of the connection */
} IfxPcie_Rc_Config;

/** \brief Topology Information for Enumeration
 */
typedef struct
{
    uint8              busUnderBridge;           /**< \brief Bus under this bridge */
    uint8              deviceUnderBus;           /**< \brief Device */
    uint8              functionUnderDevice;      /**< \brief Function */
    uint8              subordinateBus;           /**< \brief Current Subordinate Bus */
    IfxPcie_Rc_Bridge *bridgePtr;                /**< \brief Pointer to Bridge device (NULL if RC) */
} IfxPcie_Rc_TopologyInfo;

/** \} */

/** \addtogroup IfxLld_Pcie_Rc_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief initialize the PCIE Root Complex Device Configuration with default values
 * \param pcieSFR Pointer to the PCIE DSP module SFR
 * \param config Pointer to the RC device configuration
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_initConfig(Ifx_PCIE_DSP *pcieSFR, IfxPcie_Rc_Config *config);

/** \brief Initialize the RC
 * \param rcHandle Pointer to the RC device handle
 * \param config RC config
 * \return success: Initialization successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_init(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config);

/** \brief initialize the PCIE Root Complex Device, prior to Link and Topology.
 * \param rcHandle Pointer to the RC device handle
 * \param config Pointer to the RC device configuration
 * \return TRUE: Initialization successful
 * FALSE: Initialization not successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_initModule(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config);

/** \brief initialize the PCIE Link Training.
 * \param rcHandle Pointer to the RC device handle
 * \param config RC config
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_initLink(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config);

/** \brief initialize the PCIE Topology, and all end points from Root Complex.
 * \param rcHandle Pointer to the RC device handle
 * \param config Pointer to the RC device configuration
 * \return TRUE: Initialization successful
 * FALSE: Initialization not successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_initTopology(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config);

/** \brief Initialize the Interrupts to system
 * \param rcHandle Pointer to the RC device handle
 * \param config RC config
 * \return Status of Interrupt Initialization
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_initInterrupts(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config);

/** \brief Initialize the RC Interrupts
 * \param rcHandle Pointer to the RC device handle
 * \param config RC config
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_enableInterrupts(IfxPcie_Rc *rcHandle, IfxPcie_Rc_Config *config);

/** \brief configure the memory limit for the RC device
 * \param rcHandle pointer to the RC object
 * \param addrCfg address space configuration
 * \return None
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_configureMemoryLimits(IfxPcie_Rc *rcHandle, IfxPcie_Rc_AddressSpaceCfg *addrCfg);

/** \brief Add a Bridge to the Topology
 * \param rcHandle pointer to the RC object
 * \param bridgeIndex Index of bridge
 * \param bridgeCfgPtr Pointer to the Bridge configuration
 * \param numBridges Number of bridges configured
 * \param bridgeInfoPtr Pointer to topology information
 * \return IfxPcie_Status
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_addBridge(IfxPcie_Rc *rcHandle, uint8 bridgeIndex, IfxPcie_Rc_BridgeCfg *bridgeCfgPtr, uint8 numBridges, IfxPcie_Rc_TopologyInfo *bridgeInfoPtr);

/** \brief Update upstream bridge with new subordinates
 * \param rcHandle pointer to the RC object
 * \param bridgeInfoPtr Pointer to topology information
 * \param tempSubBus current subordinate bus
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_updateUpstreamBridge(IfxPcie_Rc *rcHandle, IfxPcie_Rc_TopologyInfo *bridgeInfoPtr, uint8 tempSubBus);

/** \brief Add an End Point to the Topology
 * \param rcHandle pointer to the RC object
 * \param epIndex Index of EP Device
 * \param epCfgPtr pointer to the EP Config
 * \param numEndPoints number of end points
 * \param bridgeInfoPtr Pointer to topology information
 * \return IfxPcie_Status
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_addEndPoint(IfxPcie_Rc *rcHandle, uint8 epIndex, IfxPcie_Rc_EndPointCfg *epCfgPtr, uint8 numEndPoints, IfxPcie_Rc_TopologyInfo *bridgeInfoPtr);

/** \brief configure the Bar Memories of Device Functions from RC
 * \param rcHandle pointer to the RC object
 * \param devIndex Index of the device
 * \param memCfgPtr pointer to the BAR region Config
 * \param devType Type of device
 * \return IfxPcie_Status
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_allocateBarMemories(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_MemCfg *memCfgPtr, IfxPcieDevice_Type devType);

/** \brief configure the ATU for configuration access (ECAM)
 * \param rcHandle pointer to the RC object
 * \param busNum bus number
 * \param deviceNum device number
 * \param funcNum function number
 * \param devType type of device
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_configureEcamAtu(IfxPcie_Rc *rcHandle, uint8 busNum, uint8 deviceNum, uint8 funcNum, IfxPcieDevice_Type devType);

/** \brief Configure Memory ATU
 * NOTE: Pre-condition: local memories are mapped.
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param memIndex index to memory region in device
 * \param region ATU outbound region
 * \param devType Type of device
 * \return TRUE: Initialization successful
 * FALSE: Initialization not successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_configureMemAtu(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcie_AtuRegion region, IfxPcieDevice_Type devType);

/** \brief Map a device memory to local memory, using ATU
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param memIndex index to memory region in device
 * \param region ATU outbound region
 * \param devType Type of device
 * \return TRUE: Initialization successful
 * FALSE: Initialization not successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_mapLocalMemory(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcie_AtuRegion region, IfxPcieDevice_Type devType);

/** \brief Initialize the interrupts from EP
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the EP device
 * \param intCfg pointer to the interrupt  Configuration
 * \param devType type of device
 * \return Success: Initialization successful
 * failure: initialization failed due to error
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_initFunctionInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_FunctionIntCfg *intCfg, IfxPcieDevice_Type devType);

/** \brief Initialize the MSI Interrupt from a Function
 * NOTE: MSI supports ONLY one interrupt vector from one function
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param intVectCfg pointer to the Interrupt Vector Configuration
 * \param devType device Type
 * \return Success: Initialization successful
 * failure: initialization failed due to error
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_initMsiInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_RemoteIntVectorCfg *intVectCfg, IfxPcieDevice_Type devType);

/** \brief Initialize the MSIX Interrupt from a function
 * NOTE: MSIX supports more than one interrupt vector from one function
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the function
 * \param intCfg pointer to the Interrupt Configuration
 * \param devType device Type
 * \return Success: Initialization successful
 * failure: initialization failed due to error
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_initMsixInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_FunctionIntCfg *intCfg, IfxPcieDevice_Type devType);

/** \brief Initialize the Legacy Interrupts from a function
 * NOTE: INTX support is provided from remote interrupt vectors 4 - 7
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param intVectCfg pointer to the Interrupt Vector Configuration
 * \param devType Type of device
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_initLegacyInterrupt(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcie_Rc_RemoteIntVectorCfg *intVectCfg, IfxPcieDevice_Type devType);

/** \brief Trigger an interrupt to Aurix as an EP
 * NOTE: This feature is only for Aurix EP devices.
 * Pre-requisite: BAR0 area must be mapped to a local address.
 * \param rcHandle Pointer to the RC device handle
 * \param epIndex index to the function
 * \param triggerIndex Index of the trigger (max 31)
 * \return Success: Interrupt Trigger successful
 * failure: Trigger failed due to error
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_generateAurixEpTrigger(IfxPcie_Rc *rcHandle, uint8 epIndex, uint8 triggerIndex);

/** \brief Check the status of Interrupt Trigger to EP
 * NOTE: This feature is only for Aurix EP devices.
 * Pre-requisite: BAR0 area must be mapped to a local address.
 * \param rcHandle Pointer to the RC device handle
 * \param epIndex index to the function
 * \param triggerIndex Index of the trigger (max 31)
 * \return TRUE: Interrupt Trigger set at EP side
 * FALSE: Interrupt Trigger not set as EP side
 */
IFX_EXTERN boolean IfxPcie_Rc_getAurixEpTriggerStatus(IfxPcie_Rc *rcHandle, uint8 epIndex, uint8 triggerIndex);

/** \brief Enable all enumerated end points
 * \param rcHandle Pointer to the RC device handle
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_enableEndPoints(IfxPcie_Rc *rcHandle);

/** \brief Check if Config access is granted for EP device
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index of the device
 * \param type type of the device
 * \return TRUE: config access is granted
 * FALSE: Config access is not granted
 */
IFX_EXTERN boolean IfxPcie_Rc_isConfigAccessEnabled(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type type);

/** \brief Get config access to the End Point
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index of the device
 * \param type type of the device
 * \return Config Header Address
 * NULL_PTR: Config Access cannot be granted. ATU Region is locked
 */
IFX_EXTERN uint32 *IfxPcie_Rc_getConfigAccess(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type type);

/** \brief Free Config Access for this EP
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index of the device
 * \param type type of the device
 * \return TRUE: Config access freed.
 * FALSE: Config Access cannot be freed, device mismatch
 */
IFX_EXTERN boolean IfxPcie_Rc_freeConfigAccess(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type type);

/** \brief Get local address
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index of the device
 * \param memIndex index to memory region in EP device
 * \param devType type of device
 * \return local memory address pointer
 */
IFX_EXTERN uint32 *IfxPcie_Rc_getLocalAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcieDevice_Type devType);

/** \brief Get local address of EP BAR Region
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param barIndex EP BAR index
 * \param devType type of device
 * \return local memory address pointer
 */
IFX_EXTERN uint32 *IfxPcie_Rc_getBarLocalAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 barIndex, IfxPcieDevice_Type devType);

/** \brief Get Wire address
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index of the device
 * \param memIndex index to memory region in EP device
 * \param devType type of device
 * \return wire memory address
 */
IFX_EXTERN uint64 IfxPcie_Rc_getWireAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcieDevice_Type devType);

/** \brief Get Wire address of EP BAR Region
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param barIndex EP BAR index
 * \param devType type of device
 * \return wire memory address
 */
IFX_EXTERN uint64 IfxPcie_Rc_getBarWireAddress(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 barIndex, IfxPcieDevice_Type devType);

/** \brief Get Index of enumerated device using device ID, vendor ID
 * \param rcHandle Pointer to the RC device handle
 * \param deviceId Device ID
 * \param vendorId Vendor ID
 * \param devType type of device
 * \return the Device index of the enumerated device
 * if none / conflicting - returns 0xFF
 */
IFX_EXTERN uint8 IfxPcie_Rc_getEnumeratedDeviceIndex(IfxPcie_Rc *rcHandle, uint16 deviceId, uint16 vendorId, IfxPcieDevice_Type devType);

/** \brief Get number of memory regions
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param devType type of device
 * \return number of memory regions
 * if none / EP index not valid - returns 0
 */
IFX_EXTERN uint8 IfxPcie_Rc_getNumMemRegions(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type devType);

/** \brief Get Memory Region Size
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param memIndex index to memory region in device
 * \param devType type of device
 * \return Memory Region Size
 */
IFX_EXTERN uint64 IfxPcie_Rc_getMemRegionSize(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 memIndex, IfxPcieDevice_Type devType);

/** \brief Get Memory Region Size corresponding to BAR index
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param barIndex index to BAR in device
 * \param devType type of device
 * \return Memory Region Size
 */
IFX_EXTERN uint64 IfxPcie_Rc_getBarMemRegionSize(IfxPcie_Rc *rcHandle, uint8 devIndex, uint8 barIndex, IfxPcieDevice_Type devType);

/** \brief Configure Memory ATU for InBound Transactions
 * \param rcHandle Pointer to the EP device handle
 * \param wireMemBase Base address of wire memory (NOTE: 64 Bit)
 * \param localMemBase Base address of local memory
 * \param size size of the region
 * \param region ATU outbound region
 * \return Success: configuration successful
 * Failure: Configuration not successful
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_configureInBoundAtu(IfxPcie_Rc *rcHandle, uint64 wireMemBase, uint32 localMemBase, uint32 size, IfxPcie_AtuRegion region);

/** \brief Get capability pointer
 * \param rcHandle Pointer to the RC device Handle
 * \param capId capability ID
 * \param extendedCap if TRUE: User is requesting an extended Capability
 * \return void *pointer to the capability
 * returns NULL_PTR, if no capability found.
 */
IFX_EXTERN void *IfxPcie_Rc_getCapabilityPtr(IfxPcie_Rc *rcHandle, uint16 capId, boolean extendedCap);

/** \brief Get capability pointer
 * \param rcHandle Pointer to the RC device Handle
 * \param devIndex index to the function
 * \param capId capability ID
 * \param extendedCap if TRUE: User is requesting an extended Capability
 * \param devType Type of device
 * \return void *pointer to the capability
 * returns NULL_PTR, if no capability found.
 */
IFX_EXTERN void *IfxPcie_Rc_getDeviceCapabilityPtr(IfxPcie_Rc *rcHandle, uint8 devIndex, uint16 capId, boolean extendedCap, IfxPcieDevice_Type devType);

/** \brief Trigger Hot Reset for upstream (EP/Brige) port
 * \param rcHandle Pointer to the RC device Handle
 * \return None
 */
IFX_EXTERN void IfxPcie_Rc_triggerHotReset(IfxPcie_Rc *rcHandle);

/** \brief Get the current power state of the device.
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param devType type of device
 * \return Power state of the device
 */
IFX_EXTERN IfxPcieCap_PmPwrState IfxPcie_Rc_getDevicePowerState(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieDevice_Type devType);

/** \brief Set the current power state of the device.
 * \param rcHandle Pointer to the RC device handle
 * \param devIndex index to the device
 * \param pwrState power state to set the device into
 * \param devType type of device
 * \return Status of operation
 */
IFX_EXTERN IfxPcie_Status IfxPcie_Rc_setDevicePowerState(IfxPcie_Rc *rcHandle, uint8 devIndex, IfxPcieCap_PmPwrState pwrState, IfxPcieDevice_Type devType);

/** \} */

#endif /* IFXPCIE_RC_H */
