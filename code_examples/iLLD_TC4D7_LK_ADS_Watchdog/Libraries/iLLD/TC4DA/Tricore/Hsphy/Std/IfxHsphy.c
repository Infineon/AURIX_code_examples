/**
 * \file IfxHsphy.c
 * \brief HSPHY  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxHsphy.h"

/******************************************************************************/
/*-----------------------Exported Variables/Constants-------------------------*/
/******************************************************************************/

IFX_CONST uint32 IfxHsphy_Sgmii_paramConfig[IfxHsphy_SgmiiSpeed_max][IfxHsphy_XpcsRefClk_max][IfxHsphy_SgmiiParamIndex_maxParamIndex] = {
    {
        {50,  3, 0, 12, 2, 10, 0,   1000, 10, 1, 0, 0, 2, 2, 177, 1, 1, 15, 0}, /* Parameter values for 25MHz SGMII 0P1G mode */
        {125, 2, 0, 12, 2, 12, 0,   1000, 16, 1, 0, 0, 2, 2, 177, 1, 1, 15, 0}, /* Parameter values for 40MHz SGMII 0P1G mode */
        {50,  3, 0, 12, 2, 12, 0,   1000, 20, 2, 0, 0, 2, 2, 177, 1, 1, 15, 0} /* Parameter values for 100MHz SGMII 0P1G mode */
    },                                                                          /* values for SGMII 0P1G 125mbps mode */
    {
        {50,  1, 0, 12, 2, 10, 0,   1000, 10, 1, 0, 0, 2, 2, 161, 1, 1, 15, 0}, /* Parameter values for 25MHz SGMII 1G mode */
        {125, 0, 0, 12, 2, 12, 0,   1000, 16, 1, 0, 0, 2, 2, 161, 1, 1, 15, 0}, /* Parameter values for 40MHz SGMII 1G mode */
        {100, 0, 0, 12, 2, 12, 0,   1000, 20, 2, 0, 0, 2, 2, 161, 1, 1, 15, 0} /* Parameter values for 100MHz SGMII 1G mode */
    },                                                                          /* values for SGMII 1G 1.25gbps mode. */
    {
        {125, 0, 0, 12, 2, 10, 0,   1000, 8,  1, 0, 0, 1, 1, 96,  1, 1, 15, 0}, /* Parameter values for 25MHz SGMII 2P5G mode */
        {39,  1, 0, 4,  2, 8,  260, 1016, 13, 1, 0, 0, 1, 1, 96,  1, 1, 15, 1}, /* Parameter values for 40MHz SGMII 2P5G mode */
        {125, 0, 0, 7,  2, 14, 0,   1000, 16, 2, 0, 0, 1, 1, 96,  1, 1, 15, 1} /* Parameter values for 100MHz SGMII 2P5G mode */
    },                                                                          /* values for SGMII 2P5G 3.125gbps mode. */

    {
        {125, 0, 0, 5,  2, 10, 0,   1000, 8,  1, 0, 0, 0, 0, 2,   1, 1, 15, 0}, /*  Parameter values for 25MHz SGMII 5G mode */
        {39,  1, 0, 4,  2, 8,  260, 1016, 13, 1, 0, 0, 0, 0, 0,   1, 1, 15, 1}, /*  Parameter values for 40MHz SGMII 5G mode */
        {125, 0, 0, 7,  2, 14, 0,   1000, 16, 2, 0, 0, 0, 0, 0,   1, 1, 15, 1} /*  Parameter values for 100MHz SGMII 5G mode */
    },                                                                          /* values for SGMII 5G mode. */
    {
        {50,  1, 0, 12, 2, 10, 0,   1000, 10, 1, 0, 0, 2, 2, 161, 1, 1, 15, 0}, /* Parameter values for 25MHz SGMII 100M 1.25gbps mode */
        {125, 2, 0, 12, 2, 12, 0,   1000, 16, 1, 0, 0, 2, 2, 161, 1, 1, 15, 0}, /* Parameter values for 40MHz SGMII 100M 1.25gbps mode */
        {50,  3, 0, 12, 2, 12, 0,   1000, 20, 2, 0, 0, 2, 2, 161, 1, 1, 15, 0}  /* Parameter values for 100MHz SGMII 100M 1.25gbps mode */
    },                                                                          /* values for SGMII 100M 1.25gbps mode. */
    {
        {50,  3, 0, 12, 2, 10, 0,   1000, 10, 1, 0, 0, 2, 2, 177, 1, 1, 15, 0}, /* Parameter values for 25MHz SGMII 100M 125mbps  mode */
        {125, 2, 0, 12, 2, 12, 0,   1000, 16, 1, 0, 0, 2, 2, 177, 1, 1, 15, 0}, /* Parameter values for 40MHz SGMII 100M 125mbps mode */
        {50,  3, 0, 12, 2, 12, 0,   1000, 20, 2, 0, 0, 2, 2, 177, 1, 1, 15, 0}  /* Parameter values for 100MHz SGMII 100M 125mbps mode */
        /* values for SGMII 100M 125mbps mode. */
    }
};

IFX_CONST uint32 IfxHsphy_Sgmii_refClkConfig[IfxHsphy_XpcsRefClk_max][IfxHsphy_SgmiiRefClkBits_max] = {
    {0, 0, 0}, /* parameter values for 25Mhz frequency selection */
    {1, 0, 1}, /* parameter values for 40Mhz frequency selection */
    {1, 1, 1}  /* parameter values for 100Mhz frequency selection */
};

IFX_CONST uint32 IfxHsphy_Usxgmii_paramConfig[][IfxHsphy_XpcsRefClk_max][IfxHsphy_UsxgmiiParamIndex_maxParamIndex] = {
    {
        {103, 3, 1, 12, 2,  10, 390, 1031, 10, 1, 1, 1, 1, 0, 163, 3, 3, 12, 1}, /* Parameter values for 25MHz USXGMII 5G mode */
        {1,   3, 1, 12, 11, 10, 636, 1031, 16, 1, 1, 1, 1, 0, 163, 3, 3, 12, 1}, /* Parameter values for 40MHz USXGMII 5G mode */
        {103, 3, 1, 12, 10, 10, 390, 1031, 20, 2, 1, 1, 1, 0, 163, 3, 3, 12, 1} /* Parameter values for 100MHz USXGMII 5G mode */
    }                                                                            /* values for USXGMII 5G 5.15625gbps mode. */
};

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

boolean IfxHsphy_enableModule(Ifx_HSPHY *hsphyRegPtr)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(hsphyRegPtr->PROTE), IfxApProt_State_config);
#endif

    if (IfxHsphy_isModuleEnabled(hsphyRegPtr) != 1) /* if module is not enabled already */
    {
        hsphyRegPtr->CLC.B.DISR = 0U;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(hsphyRegPtr->PROTE), IfxApProt_State_run);
#endif

    while (IfxHsphy_isModuleEnabled(hsphyRegPtr) == FALSE)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return (boolean)timeOutError;
}


Ifx_HSPHY *IfxHsphy_getHsphyAddress(IfxHsphy_hsphyIndex hsphy)
{
    Ifx_HSPHY *module;

    if (hsphy < IFXHSPHY_NUM_MODULES)
    {
        module = (Ifx_HSPHY *)(IfxHsphy_cfg_hsphyIndexMap[hsphy].module);
    }
    else
    {
        module = NULL_PTR;
    }

    return module;
}


IfxHsphy_hsphyIndex IfxHsphy_getHsphyIndex(Ifx_HSPHY *hsphyRegPtr)
{
    uint32              index;
    IfxHsphy_hsphyIndex result;

    result = IfxHsphy_hsphyIndex_none;

    for (index = 0; index < IFXHSPHY_NUM_MODULES; index++)
    {
        if (IfxHsphy_cfg_hsphyIndexMap[index].module == hsphyRegPtr)
        {
            result = (IfxHsphy_hsphyIndex)IfxHsphy_cfg_hsphyIndexMap[index].index;
            break;
        }
    }

    return result;
}


boolean IfxHsphy_resetModule(Ifx_HSPHY *hsphyRegPtr)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(hsphyRegPtr->PROTE), IfxApProt_State_config);
#endif

    hsphyRegPtr->RST.CTRLA.B.KRST = 1;
    hsphyRegPtr->RST.CTRLB.B.KRST = 1;

    while (0 == hsphyRegPtr->RST.STAT.B.KRST)    /* Wait until reset is executed */
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    hsphyRegPtr->RST.CTRLB.B.STATCLR = 1;        /* Clear Kernel reset status bit */

    while (hsphyRegPtr->RST.STAT.B.KRST == 1)    /* Wait until reset is released */
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(hsphyRegPtr->PROTE), IfxApProt_State_run);
#endif
    return (boolean)timeOutError;
}


boolean IfxHsphy_setPhyRefClockSel(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_PhyIndex phyIndex, IfxHsphy_TrgtDevice device)
{
    boolean ret = TRUE;

    if (phyIndex == IfxHsphy_PhyIndex_0)
    {
        if (device == IfxHsphy_TrgtDevice_pcie)
        {
            //PCIE
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.PRS = 1; /* 0b1, IFXHSPHY_PHY0_REFCLKSEL_PAD */
        }
        else if (device == IfxHsphy_TrgtDevice_xgmac)
        {
            //XGMAC
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.PRS = 0; /* 0b0, IFXHSPHY_PHY0_REFCLKSEL_ALT */
        }
        else
        {
            ret = FALSE;
        }
    }

    if (phyIndex == IfxHsphy_PhyIndex_1)
    {
        if ((device == IfxHsphy_TrgtDevice_xgmac) || (device == IfxHsphy_TrgtDevice_trace))
        {
            //XGMAC or TRACE
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.PRS = 0; /* 0b0, IFXHSPHY_PHY1_REFCLKSEL_ALT */
        }
        else
        {
            ret = FALSE;
        }
    }

    if (phyIndex == IfxHsphy_PhyIndex_2)
    {
        if (device == IfxHsphy_TrgtDevice_pcie)
        {
            //PCIE
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.PRS = 1; /* 0b1, IFXHSPHY_PHY2_REFCLKSEL_PAD */
        }
        else if (device == IfxHsphy_TrgtDevice_trace)
        {
            //TPCS
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.PRS = 0; /* 0b0, IFXHSPHY_PHY2_REFCLKSEL_ALT */
        }
        else
        {
            ret = FALSE;
        }
    }

    return ret;
}


boolean IfxHsphy_selFunction(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_PhyIndex phyIndex, IfxHsphy_TrgtDevice device)
{
    boolean ret = TRUE;

    if (phyIndex == IfxHsphy_PhyIndex_0)
    {
        if (device == IfxHsphy_TrgtDevice_pcie)
        {
            //PCIE
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.FSP = 1;
        }
        else if (device == IfxHsphy_TrgtDevice_xgmac)
        {
            //XGMAC
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.FSP = 0;
        }
        else
        {
            ret = FALSE;
        }
    }

    if (phyIndex == IfxHsphy_PhyIndex_1)
    {
        if (device == IfxHsphy_TrgtDevice_xgmac)
        {
            //XGMAC
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.FSP = 0;
        }
        else if (device == IfxHsphy_TrgtDevice_trace)
        {
            //TPCS
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.FSP = 1;
        }
        else
        {
            ret = FALSE;
        }
    }

    if (phyIndex == IfxHsphy_PhyIndex_2)
    {
        if (device == IfxHsphy_TrgtDevice_pcie)
        {
            //PCIE
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.FSP = 0;
        }
        else if (device == IfxHsphy_TrgtDevice_trace)
        {
            //TPCS
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.FSP = 1;
        }
        else
        {
            ret = FALSE;
        }
    }

    return ret;
}


boolean IfxHsphy_isPhyReady(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_PhyIndex phyIndex)
{
    boolean ret = TRUE;

    if ((phyIndex == IfxHsphy_PhyIndex_0) || (phyIndex == IfxHsphy_PhyIndex_1) || (phyIndex == IfxHsphy_PhyIndex_2))
    {
        //Check if the PHY is ready by checking if SRAM loading start.
        ret = (hsphyRegPtr->PHY[phyIndex].CTRL1.B.INITDONE == 1);
    }
    else
    {
        ret = FALSE;
    }

    return ret;
}


boolean IfxHsphy_setExtLdDone(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_PhyIndex phyIndex)
{
    boolean ret = TRUE;

    if ((phyIndex == IfxHsphy_PhyIndex_0) || (phyIndex == IfxHsphy_PhyIndex_1) || (phyIndex == IfxHsphy_PhyIndex_2))
    {
        //Check if the PHY is ready by checking if SRAM loading start.
        if (hsphyRegPtr->PHY[phyIndex].CTRL1.B.EXTLDDONE != 1)
        {
            hsphyRegPtr->PHY[phyIndex].CTRL1.B.EXTLDDONE = 1;
        }

        ret = TRUE;
    }
    else
    {
        ret = FALSE;
    }

    return ret;
}


void IfxHsphy_initApConfig(IfxHsphy_ApConfig *config)
{
    IfxApProt_initConfig(&config->proteConfig);
    IfxApProt_initConfig(&config->protseConfig);
    IfxApApu_initConfig(&config->apuGlobalConfig);
    IfxApApu_initConfig(&config->apuCh0Config);
    IfxApApu_initConfig(&config->apuCh1Config);
}


void IfxHsphy_initAp(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_ApConfig *config)
{
    /* Initialize the PROTs */
    IfxApProt_init((Ifx_PROT_PROT *)&hsphyRegPtr->PROTE, &config->proteConfig);
    IfxApProt_init((Ifx_PROT_PROT *)&hsphyRegPtr->PROTSE, &config->protseConfig);

    /* Change the state to CONFIG, Configure APU and set PROT state back to RUN */
    /* Initialize the APU */
    IfxApProt_setState((Ifx_PROT_PROT *)&hsphyRegPtr->PROTSE, IfxApProt_State_config);

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&hsphyRegPtr->ACCENGLB, &config->apuGlobalConfig);

    IfxApApu_init((Ifx_ACCEN_ACCEN *)&hsphyRegPtr->ACCENCH[0], &config->apuCh0Config);
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&hsphyRegPtr->ACCENCH[1], &config->apuCh1Config);

    IfxApProt_setState((Ifx_PROT_PROT *)&hsphyRegPtr->PROTSE, IfxApProt_State_run);
}


void IfxHsphy_disableModule(Ifx_HSPHY *hsphyRegPtr)
{
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(hsphyRegPtr->PROTE), IfxApProt_State_config);
#endif

    hsphyRegPtr->CLC.B.DISR = 1;        /* set the disable request */

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&(hsphyRegPtr->PROTE), IfxApProt_State_run);
#endif
}


boolean IfxHsphy_sgmiiMpllDisable(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_XpcsIndex xpcsIndex)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
    //Disable MPLL
    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_MPLL_CMN_CTRL.B.MPLL_EN_0 = 0;
    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX_REQ_0        = 1;

    while (1 == hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX_REQ_0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;

    while (1 == hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_STS.B.TX_ACK_0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return (boolean)timeOutError;
}


boolean IfxHsphy_sgmiiMpllEnable(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_XpcsIndex xpcsIndex)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
    //Enable/Bring-up MPLL in 1.25Gb/s rate
    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_MPLL_CMN_CTRL.B.MPLL_EN_0 = 1;
    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX_REQ_0        = 1;

    while (1 == hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX_REQ_0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;

    while (1 == hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_STS.B.TX_ACK_0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_RX_GENCTRL2.B.RX_REQ_0 = 1;

    timeoutCycleCount                                                        = IFXHSPHY_MAX_TIMEOUT;

    while (1 == hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_RX_GENCTRL2.B.RX_REQ_0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;

    while (1 == hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_STS.B.RX_ACK_0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return (boolean)timeOutError;
}


boolean IfxHsphy_sgmiiXpcsDataPathInit(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_XpcsIndex xpcsIndex)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
    //Initialize XPCS data path
    hsphyRegPtr->XPCS[xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.INIT = 1;

    while (hsphyRegPtr->XPCS[xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.INIT == 1)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 0;
    hsphyRegPtr->XPCS[xpcsIndex].PCS.SR_XS_CTRL1.B.LPM                               = 1; //power down the DWC_xpcs
    timeoutCycleCount                                                                = IFXHSPHY_MAX_TIMEOUT;

    while (hsphyRegPtr->XPCS[xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerDown)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    hsphyRegPtr->XPCS[xpcsIndex].PCS.SR_XS_CTRL1.U &= (uint32)(~((1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_LPM_OFF) | (1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_RST_OFF)));      //power up the DWC_xpcs

    timeoutCycleCount                               = IFXHSPHY_MAX_TIMEOUT;

    while (hsphyRegPtr->XPCS[xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerGood)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    hsphyRegPtr->XPCS[xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 1;
    return (boolean)timeOutError;
}


boolean IfxHsphy_resetXpcs(Ifx_HSPHY *hsphyRegPtr, const IfxHsphy_GethXpcsParams *xpcs)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.DIG_CTRL1.B.VR_RST = 0;

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.DIG_CTRL1.B.VR_RST = 1;

    while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_SRAM.B.INIT_DN != 1)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return TRUE;
    }

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_SRAM.B.EXT_LD_DN = 1;

    timeoutCycleCount                                                            = IFXHSPHY_MAX_TIMEOUT;

    while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL1.B.RST == 1)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return (boolean)timeOutError;
}


IfxHsphy_Geth_SgmiiSpeedConfigStatus IfxHsphy_Geth_setSgmiiSpeedMode(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_TrgtDeviceSpeed trgtSpeed, const IfxHsphy_GethXpcsParams *xpcs)
{
    uint32              timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8               timeOutError      = 0U;
    IfxHsphy_SgmiiSpeed sgmiiSpeed        = IfxHsphy_SgmiiSpeed_1G;
    boolean             relvalCheck;

    relvalCheck = IfxHsphy_sgmiiMpllDisable(hsphyRegPtr, xpcs->xpcsIndex);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    if ((trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G) || (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps) || (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_125mbps))
    {
        /* Set XPCS in 100M mode */
        if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G)
        {
            sgmiiSpeed = IfxHsphy_SgmiiSpeed_0P1G;
        }
        /* SGMII 100M 1.25gbps mode */
        else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps)
        {
            sgmiiSpeed = IfxHsphy_SgmiiSpeed_0P1G_1P25gbps;
        }
        /* SGMII 100M 125mbps mode */
        else
        {
            sgmiiSpeed = IfxHsphy_SgmiiSpeed_0P1G_125mbps;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL                  = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_10GBASE_X);

        if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps)
        {
            hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6  = 0;
            hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13 = 1;
        }

        if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_125mbps)
        {
            hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.DIG_CTRL1.B.EN_100M = 1;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 0;
    }
    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_1G)
    {
        //Set XPCS in 1G mode
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 1;
        sgmiiSpeed                                                                         = IfxHsphy_SgmiiSpeed_1G;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL                  = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_10GBASE_X);
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6                                  = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13                                 = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 0;
    }

    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_2P5G)
    {
        //Set XPCS in 2.5G mode
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 1;
        sgmiiSpeed                                                                         = IfxHsphy_SgmiiSpeed_2P5G;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL                  = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_10GBASE_X);
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.EN_2_5G_MODE              = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6                                  = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13                                 = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_RST_0 = 0;
    }

    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_5G)
    {
        //Set XPCS in 5G mode
        sgmiiSpeed                                                        = IfxHsphy_SgmiiSpeed_5G;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL2.B.PCS_TYPE_SEL = IFXHSPHY_SET_FIELD_VALUE(XPCS_PCS_SR_XS_CTRL2, PCS_TYPE_SEL, IfxHsphy_PcsTypeSel_2P5GBASE_X);
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.SR_CTRL1.B.SS13            = 0;
    }
    else
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_invalidConfigError;
    }

    //config the ref freq selected
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_REF_CLK_CTRL.B.REF_MPLLA_DIV2 = IfxHsphy_Sgmii_refClkConfig[xpcs->xpcsRefClk][IfxHsphy_SgmiiRefClkBits_refMpllaDiv2];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_REF_CLK_CTRL.B.REF_CLK_DIV2   = IfxHsphy_Sgmii_refClkConfig[xpcs->xpcsRefClk][IfxHsphy_SgmiiRefClkBits_refClKDiv2];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_REF_CLK_CTRL.B.REF_RANGE      = IfxHsphy_Sgmii_refClkConfig[xpcs->xpcsRefClk][IfxHsphy_SgmiiRefClkBits_refRange];

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST                           = 1;

    while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST != 0)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL0.B.MPLLA_MULTIPLIER        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaMultiplier];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_TX_CLK_DIV        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaTxClkDiv];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_DIV16P5_CLK_EN    = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaDiv16P5ClkEnable];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_PROP                      = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_cpProp];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_INT                       = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_cpInt];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL7.B.CP_PROP_GS                   = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_cpPropGs];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_MPLLA_CTRL1.B.MPLLA_FRACN_CTRL            = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_mpllaFrancCtrl];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_VCO_CAL_LD0.B.VCO_LD_VAL_0        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_vcoLdVal_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_VCO_CAL_REF0.B.VCO_REF_LD_0               = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_vcoRefLd_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_MISC_CTRL2.B.SUP_MISC                 = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_supMisc];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_DIV16P5_CLK_EN_0 = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rxDiv16P5ClkEn_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_GENCTRL4.B.RX_125MHZ_CLK_EN_0      = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx125MhzClkEn_0];

    if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G)
    {
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_CDR_CTRL.B.CDR_TRACK_EN_0 = 0;
    }
    else if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_0P1G_1P25gbps)
    {
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_CDR_CTRL.B.CDR_TRACK_EN_0 = 1;
    }
    else
    {
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_CDR_CTRL.B.CDR_TRACK_EN_0 = 0;
    }

    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_RATE_CTRL.B.TX0_RATE    = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_tx0Rate];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_RATE_CTRL.B.RX0_RATE    = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx0Rate];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_MISC_CTRL0.B.RX0_MISC       = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx0Misc];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX0_WIDTH        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_tx0Width];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_RX_GENCTRL2.B.RX0_WIDTH        = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_rx0Width];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_BOOST_CTRL.B.TX0_IBOOST = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_tx0Iboost];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.VBOOST_EN_0  = IfxHsphy_Sgmii_paramConfig[sgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_SgmiiParamIndex_vBoostEn_0];
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.AFE_EN_0         = 0;
    hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.DFE_EN_0         = 0;
    relvalCheck                                                                            = IfxHsphy_sgmiiMpllEnable(hsphyRegPtr, xpcs->xpcsIndex);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    relvalCheck = IfxHsphy_sgmiiXpcsDataPathInit(hsphyRegPtr, xpcs->xpcsIndex);

    if (relvalCheck == TRUE)
    {
        return IfxHsphy_Geth_SgmiiSpeedConfigStatus_timeOutError;
    }

    return IfxHsphy_Geth_SgmiiSpeedConfigStatus_success;
}


boolean IfxHsphy_Geth_setUsxgmiiSpeedMode(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_TrgtDeviceSpeed trgtSpeed, const IfxHsphy_GethXpcsParams *xpcs)
{
    uint32                timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8                 timeOutError      = 0U;
    IfxHsphy_UsxgmiiSpeed usxgmiiSpeed      = (IfxHsphy_UsxgmiiSpeed)1;
    boolean               relvalCheck;

    if (trgtSpeed == IfxHsphy_TrgtDeviceSpeed_5G)
    {
        relvalCheck = IfxHsphy_sgmiiMpllDisable(hsphyRegPtr, xpcs->xpcsIndex); //need to change the func name specific to serial 100M

        if (relvalCheck == TRUE)
        {
            return TRUE;
        }

        usxgmiiSpeed                                                     = (IfxHsphy_UsxgmiiSpeed)0;

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.USXG_EN = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_KR_CTRL.B.USXG_MODE = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST  = 1;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.VR_RST != 0)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        if (timeOutError == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL0.B.MPLLA_MULTIPLIER        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaMultiplier];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_TX_CLK_DIV        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaTxClkDiv];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_MPLLA_CTRL2.B.MPLLA_DIV16P5_CLK_EN    = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaDiv16P5ClkEnable];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_PROP                      = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_cpProp];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL6.B.CP_INT                       = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_cpInt];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_8G_MPLLA_CTRL7.B.CP_PROP_GS                   = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_cpPropGs];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_MPLLA_CTRL1.B.MPLLA_FRACN_CTRL            = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_mpllaFrancCtrl];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_VCO_CAL_LD0.B.VCO_LD_VAL_0        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_vcoLdVal_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_VCO_CAL_REF0.B.VCO_REF_LD_0               = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_vcoRefLd_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_MISC_CTRL2.B.SUP_MISC                 = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_supMisc];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_GENCTRL1.B.RX_DIV16P5_CLK_EN_0 = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rxDiv16P5ClkEn_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_GENCTRL4.B.RX_125MHZ_CLK_EN_0      = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx125MhzClkEn_0];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_RATE_CTRL.B.TX0_RATE           = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_tx0Rate];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_RX_RATE_CTRL.B.RX0_RATE           = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx0Rate];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_16G_25G_RX_MISC_CTRL0.B.RX0_MISC              = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx0Misc];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_TX_GENCTRL2.B.TX0_WIDTH               = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_tx0Width];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_RX_GENCTRL2.B.RX0_WIDTH               = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_rx0Width];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_BOOST_CTRL.B.TX0_IBOOST        = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_tx0Iboost];
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.VBOOST_EN_0         = IfxHsphy_Usxgmii_paramConfig[usxgmiiSpeed][xpcs->xpcsRefClk][IfxHsphy_UsxgmiiParamIndex_vBoostEn_0];

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.AFE_EN_0                = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_AFE_DFE_EN_CTRL.B.DFE_EN_0                = 1;

        relvalCheck                                                                                   = IfxHsphy_sgmiiMpllEnable(hsphyRegPtr, xpcs->xpcsIndex); //need to change the func name specific to serial 100M

        if (relvalCheck == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.INIT = 1;

        timeoutCycleCount                                             = IFXHSPHY_MAX_TIMEOUT;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.INIT == 1)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL1.B.LPM                               = 1; //power down the DWC_xpcs

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerDown)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        if (timeOutError == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.SR_XS_CTRL1.U &= (uint32)(~((1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_LPM_OFF) | (1 << IFX_HSPHY_XPCS_PCS_SR_XS_CTRL1_RST_OFF)));      //power up the DWC_xpcs

        timeoutCycleCount                                     = IFXHSPHY_MAX_TIMEOUT;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_STS.B.PSEQ_STATE != IfxHsphy_XpcsPowerUpSeqState_powerGood)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }

        if (timeOutError == TRUE)
        {
            return TRUE;
        }

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PMA.VR_XS_MP_12G_16G_25G_TX_GENCTRL1.B.TX_CLK_RDY_0 = 1;

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS5                                      = 1;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS6                                      = 0;
        hsphyRegPtr->XPCS[xpcs->xpcsIndex].MII.CTRL.B.SS13                                     = 1;

        //delay of 100ns to be added

        hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.USRA_RST = 1;

        timeoutCycleCount                                                 = IFXHSPHY_MAX_TIMEOUT;

        while (hsphyRegPtr->XPCS[xpcs->xpcsIndex].PCS.VR_XS_DIG_CTRL1.B.USRA_RST != 0)
        {
            IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
        }
    }

    return (boolean)timeOutError;
}


boolean IfxHsphy_Geth_rgmiiInit(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_Geth_RgmiiCfg *config)
{
    //Module is enabled in the IfxHsphy_enableModule()
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
    hsphyRegPtr->CMNCFG.B.FSR     = 1;                            //To select 1:RGMII pads for XGMAC1,0:RGMII pads for XSPI
    hsphyRegPtr->DLL.CFG.B.PEN3VX = config->dllCfg.dllOutputVolt; //Depending on the desired voltage of operation set 1 or 0

    if (config->dllCfg.dllOutputVolt == IfxHsphy_DllOutputVoltage_1P8V)
    {
        hsphyRegPtr->DLL.CFG.B.PMODE = config->dllCfg.dllCfgPmodeClock;
    }
    else
    {
        hsphyRegPtr->DLL.CFG.B.PMODE = config->dllCfg.dllCfgPmodePads;
    }

    //FMODE is set to 0 if output freqmax req is less than 166MHz freq allowed for RGMII is 125MHz
    hsphyRegPtr->DLL.CFG.B.FMODE    = 0;
    hsphyRegPtr->DLL.CFG.B.REFCLKSE = config->dllCfg.dllRefClkSel;

    hsphyRegPtr->DLL.CFG.B.TXCFG    = config->dllCfg.txClkSkew;
    hsphyRegPtr->DLL.CFG.B.RXCFG    = config->dllCfg.rxClkSkew;

    hsphyRegPtr->DLL.CFG.B.POWER    = 1;         //Switch on the DLL power

    hsphyRegPtr->DLL.CFG.B.TXEN     = 1;         // to enable/disable TX clk
    hsphyRegPtr->DLL.CFG.B.RXEN     = 1;         // to enable/disable RX clk

    while (hsphyRegPtr->DLL.CFG.B.LOCKSTAT != 1) //polling to check the lock status
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return (boolean)timeOutError;
}


void IfxHsphy_Geth_setupRmiiOutputPins(Ifx_HSPHY *hsphyRegPtr, const IfxHsphy_Geth_RmiiPins *rmiiPins)
{
    IFX_UNUSED_PARAMETER(hsphyRegPtr);
    IfxPort_OutputMode mode       = IfxPort_OutputMode_pushPull;
    IfxPort_PadDriver  speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    if (rmiiPins != NULL_PTR)
    {
        if (rmiiPins->mdc != NULL_PTR)
        {
            IfxGeth_Mdc_Out *mdc = rmiiPins->mdc;
            IfxPort_resetPinControllerSelection(mdc->pin.port, mdc->pin.pinIndex);
            IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, mode, mdc->select);
            IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, speedGrade);
        }

        if (rmiiPins->txEn != NULL_PTR)
        {
            IfxGeth_Txen_Out *txen = rmiiPins->txEn;
            IfxPort_resetPinControllerSelection(txen->pin.port, txen->pin.pinIndex);
            IfxPort_setPinModeOutput(txen->pin.port, txen->pin.pinIndex, mode, txen->select);
            IfxPort_setPinPadDriver(txen->pin.port, txen->pin.pinIndex, speedGrade);
        }

        if (rmiiPins->txd0 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd0 = rmiiPins->txd0;
            IfxPort_resetPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
            IfxPort_setPinModeOutput(txd0->pin.port, txd0->pin.pinIndex, mode, txd0->select);
            IfxPort_setPinPadDriver(txd0->pin.port, txd0->pin.pinIndex, speedGrade);
        }

        if (rmiiPins->txd1 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd1 = rmiiPins->txd1;
            IfxPort_resetPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
            IfxPort_setPinModeOutput(txd1->pin.port, txd1->pin.pinIndex, mode, txd1->select);
            IfxPort_setPinPadDriver(txd1->pin.port, txd1->pin.pinIndex, speedGrade);
        }
    }
}


boolean IfxHsphy_Xspi_xspiInit(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_Xspi_XspiCfg *config)
{
    uint32 timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    uint8  timeOutError      = 0U;
    hsphyRegPtr->CMNCFG.B.FSR     = 0;
    hsphyRegPtr->DLL.CFG.B.PEN3VX = config->dllCfg.dllOutputVolt;

    if (config->dllCfg.dllOutputVolt == IfxHsphy_DllOutputVoltage_1P8V)
    {
        hsphyRegPtr->DLL.CFG.B.PMODE = config->dllCfg.dllCfgPmodeClock;
    }
    else
    {
        hsphyRegPtr->DLL.CFG.B.PMODE = config->dllCfg.dllCfgPmodePads;
    }

    hsphyRegPtr->DLL.CFG.B.REFCLKSE = 1; // PLL clock frequency

    // Depending on the interface frequency update the FMODE
    hsphyRegPtr->DLL.CFG.B.FMODE = config->dllCfg.dllFreqMode;

    hsphyRegPtr->DLL.CFG.B.TXCFG = config->dllCfg.txClkSkew;
    hsphyRegPtr->DLL.CFG.B.RXCFG = config->dllCfg.rxClkSkew;
    hsphyRegPtr->DLL.CFG.B.POWER = 1;            //Switch on the DLL power

    hsphyRegPtr->DLL.CFG.B.TXEN  = 1;            //enables the TX clock
    hsphyRegPtr->DLL.CFG.B.RXEN  = 1;            //enables the RX clock

    while (hsphyRegPtr->DLL.CFG.B.LOCKSTAT != 1) //poll until the LOCKSTAT is set
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return (boolean)timeOutError;
}


void IfxHsphy_Xspi_setXspiPins(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_Xspi_XspiCfg *config)
{
    const IfxHsphy_Xspi_XspiPins *pins       = config->xspiPins;
    IfxPort_PadDriver             speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed3;
    IfxPort_OutputMode            mode       = IfxPort_OutputMode_pushPull;

    if (pins != NULL_PTR)
    {
        if (pins->clk != NULL_PTR)
        {
            IfxXspi_Clk_Out *clk = pins->clk;

            if ((clk->pin.port == &MODULE_P16) && (clk->pin.pinIndex == 0) && (config->dllCfg.dllOutputVolt == IfxHsphy_DllOutputVoltage_3V))
            {
                /* For XSPI 3v mode the PCSR bit for P16_0 should be set to 0. */
                IfxPort_resetPinControllerSelection(clk->pin.port, clk->pin.pinIndex);
            }
            else
            {
                /* For XSPI 1.8v mode the PCSR for P16_0 should be set to 1 and the inverted clock gets generated inside the High speed Pads. */
                IfxPort_setPinControllerSelection(clk->pin.port, clk->pin.pinIndex);
            }

            IfxPort_setPinModeOutput(clk->pin.port, clk->pin.pinIndex, mode, clk->select);
            IfxPort_setPinPadDriver(clk->pin.port, clk->pin.pinIndex, speedGrade);
        }

        if (pins->clk_n != NULL_PTR)
        {
            IfxXspi_Clk_Out *clk_n = pins->clk_n;

            if ((clk_n->pin.port == &MODULE_P16) && (clk_n->pin.pinIndex == 0) && (config->dllCfg.dllOutputVolt == IfxHsphy_DllOutputVoltage_3V))
            {
                IfxPort_resetPinControllerSelection(clk_n->pin.port, clk_n->pin.pinIndex);
            }
            else
            {
                IfxPort_setPinControllerSelection(clk_n->pin.port, clk_n->pin.pinIndex);
            }

            IfxPort_setPinModeOutput(clk_n->pin.port, clk_n->pin.pinIndex, mode, clk_n->select);
            IfxPort_setPinPadDriver(clk_n->pin.port, clk_n->pin.pinIndex, speedGrade);
        }

        if (pins->cs != NULL_PTR)
        {
            IfxXspi_Cs_Out *cs = pins->cs;
            IfxPort_setPinControllerSelection(cs->pin.port, cs->pin.pinIndex);
            IfxPort_setPinModeOutput(cs->pin.port, cs->pin.pinIndex, mode, cs->select);
            IfxPort_setPinPadDriver(cs->pin.port, cs->pin.pinIndex, speedGrade);
        }

        if (pins->txd0 != NULL_PTR)
        {
            IfxXspi_Txd0_InOut *txd0 = pins->txd0;
            IfxPort_setPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
            IfxPort_setPinModeOutput(txd0->pin.port, txd0->pin.pinIndex, mode, txd0->outSelect);
            IfxPort_setPinPadDriver(txd0->pin.port, txd0->pin.pinIndex, speedGrade);
        }

        if (pins->txd1 != NULL_PTR)
        {
            IfxXspi_Txd1_InOut *txd1 = pins->txd1;
            IfxPort_setPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
            IfxPort_setPinModeOutput(txd1->pin.port, txd1->pin.pinIndex, mode, txd1->outSelect);
            IfxPort_setPinPadDriver(txd1->pin.port, txd1->pin.pinIndex, speedGrade);
        }

        if (pins->txd2 != NULL_PTR)
        {
            IfxXspi_Txd2_InOut *txd2 = pins->txd2;
            IfxPort_setPinControllerSelection(txd2->pin.port, txd2->pin.pinIndex);
            IfxPort_setPinModeOutput(txd2->pin.port, txd2->pin.pinIndex, mode, txd2->outSelect);
            IfxPort_setPinPadDriver(txd2->pin.port, txd2->pin.pinIndex, speedGrade);
        }

        if (pins->txd3 != NULL_PTR)
        {
            IfxXspi_Txd3_InOut *txd3 = pins->txd3;
            IfxPort_setPinControllerSelection(txd3->pin.port, txd3->pin.pinIndex);
            IfxPort_setPinModeOutput(txd3->pin.port, txd3->pin.pinIndex, mode, txd3->outSelect);
            IfxPort_setPinPadDriver(txd3->pin.port, txd3->pin.pinIndex, speedGrade);
        }

        if (pins->txd4 != NULL_PTR)
        {
            IfxXspi_Txd4_InOut *txd4 = pins->txd4;
            IfxPort_setPinControllerSelection(txd4->pin.port, txd4->pin.pinIndex);
            IfxPort_setPinModeOutput(txd4->pin.port, txd4->pin.pinIndex, mode, txd4->outSelect);
            IfxPort_setPinPadDriver(txd4->pin.port, txd4->pin.pinIndex, speedGrade);
        }

        if (pins->txd5 != NULL_PTR)
        {
            IfxXspi_Txd5_InOut *txd5 = pins->txd5;
            IfxPort_setPinControllerSelection(txd5->pin.port, txd5->pin.pinIndex);
            IfxPort_setPinModeOutput(txd5->pin.port, txd5->pin.pinIndex, mode, txd5->outSelect);
            IfxPort_setPinPadDriver(txd5->pin.port, txd5->pin.pinIndex, speedGrade);
        }

        if (pins->txd6 != NULL_PTR)
        {
            IfxXspi_Txd6_InOut *txd6 = pins->txd6;
            IfxPort_setPinControllerSelection(txd6->pin.port, txd6->pin.pinIndex);
            IfxPort_setPinModeOutput(txd6->pin.port, txd6->pin.pinIndex, mode, txd6->outSelect);
            IfxPort_setPinPadDriver(txd6->pin.port, txd6->pin.pinIndex, speedGrade);
        }

        if (pins->txd7 != NULL_PTR)
        {
            IfxXspi_Txd7_InOut *txd7 = pins->txd7;
            IfxPort_setPinControllerSelection(txd7->pin.port, txd7->pin.pinIndex);
            IfxPort_setPinModeOutput(txd7->pin.port, txd7->pin.pinIndex, mode, txd7->outSelect);
            IfxPort_setPinPadDriver(txd7->pin.port, txd7->pin.pinIndex, speedGrade);
        }

        if (pins->txdm != NULL_PTR)
        {
            IfxXspi_Dm_InOut *txdm = pins->txdm;
            IfxPort_setPinControllerSelection(txdm->pin.port, txdm->pin.pinIndex);
            IfxPort_setPinModeOutput(txdm->pin.port, txdm->pin.pinIndex, mode, txdm->outSelect);
            IfxPort_setPinPadDriver(txdm->pin.port, txdm->pin.pinIndex, speedGrade);
        }
    }
}


void IfxHsphy_Geth_setupRgmiiOutputPins(Ifx_HSPHY *hsphyRegPtr, const IfxHsphy_Geth_RgmiiPins *rgmiiPins)
{
    IFX_UNUSED_PARAMETER(hsphyRegPtr);
    IfxPort_OutputMode mode       = IfxPort_OutputMode_pushPull;
    IfxPort_PadDriver  speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed3;

    if (rgmiiPins != NULL_PTR)
    {
        if (rgmiiPins->mdc != NULL_PTR)
        {
            IfxGeth_Mdc_Out *mdc = rgmiiPins->mdc;
            IfxPort_setPinControllerSelection(mdc->pin.port, mdc->pin.pinIndex);
            IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, mode, mdc->select);
            IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->txClk != NULL_PTR)
        {
            IfxGeth_Txclk_Out *txClk = rgmiiPins->txClk;
            IfxPort_setPinControllerSelection(txClk->pin.port, txClk->pin.pinIndex);
            IfxPort_setPinModeOutput(txClk->pin.port, txClk->pin.pinIndex, mode, txClk->select);
            IfxPort_setPinPadDriver(txClk->pin.port, txClk->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->txCtl != NULL_PTR)
        {
            IfxGeth_Txctl_Out *txCtl = rgmiiPins->txCtl;
            IfxPort_setPinControllerSelection(txCtl->pin.port, txCtl->pin.pinIndex);
            IfxPort_setPinModeOutput(txCtl->pin.port, txCtl->pin.pinIndex, mode, txCtl->select);
            IfxPort_setPinPadDriver(txCtl->pin.port, txCtl->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->txd0 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd0 = rgmiiPins->txd0;
            IfxPort_setPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
            IfxPort_setPinModeOutput(txd0->pin.port, txd0->pin.pinIndex, mode, txd0->select);
            IfxPort_setPinPadDriver(txd0->pin.port, txd0->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->txd1 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd1 = rgmiiPins->txd1;
            IfxPort_setPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
            IfxPort_setPinModeOutput(txd1->pin.port, txd1->pin.pinIndex, mode, txd1->select);
            IfxPort_setPinPadDriver(txd1->pin.port, txd1->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->txd2 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd2 = rgmiiPins->txd2;
            IfxPort_setPinControllerSelection(txd2->pin.port, txd2->pin.pinIndex);
            IfxPort_setPinModeOutput(txd2->pin.port, txd2->pin.pinIndex, mode, txd2->select);
            IfxPort_setPinPadDriver(txd2->pin.port, txd2->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->txd3 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd3 = rgmiiPins->txd3;
            IfxPort_setPinControllerSelection(txd3->pin.port, txd3->pin.pinIndex);
            IfxPort_setPinModeOutput(txd3->pin.port, txd3->pin.pinIndex, mode, txd3->select);
            IfxPort_setPinPadDriver(txd3->pin.port, txd3->pin.pinIndex, speedGrade);
        }
    }
}


void IfxHsphy_Geth_setupMiiOutputPins(Ifx_HSPHY *hsphyRegPtr, const IfxHsphy_Geth_MiiPins *miiPins)
{
    IFX_UNUSED_PARAMETER(hsphyRegPtr);
    IfxPort_OutputMode mode       = IfxPort_OutputMode_pushPull;
    IfxPort_PadDriver  speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    // The IfxPort_setPinControllerSelection() API call is disabled  for TXD0, TXD1 and TXEN because if enabled data cant be passed to port.
    //The IfxPort_resetPinControllerSelection() solves this issues Proper programming seq to be confirmed

    if (miiPins != NULL_PTR)
    {
        if (miiPins->txEn != NULL_PTR)
        {
            IfxGeth_Txen_Out *txEn = miiPins->txEn;
            //IfxPort_setPinControllerSelection(txEn->pin.port, txEn->pin.pinIndex);
            IfxPort_resetPinControllerSelection(txEn->pin.port, txEn->pin.pinIndex);
            IfxPort_setPinModeOutput(txEn->pin.port, txEn->pin.pinIndex, mode, txEn->select);
            IfxPort_setPinPadDriver(txEn->pin.port, txEn->pin.pinIndex, speedGrade);
        }

        if (miiPins->txEr != NULL_PTR)
        {
            IfxGeth_Txer_Out *txEr = miiPins->txEr;
            IfxPort_resetPinControllerSelection(txEr->pin.port, txEr->pin.pinIndex);
            IfxPort_setPinModeOutput(txEr->pin.port, txEr->pin.pinIndex, mode, txEr->select);
            IfxPort_setPinPadDriver(txEr->pin.port, txEr->pin.pinIndex, speedGrade);
        }

        if (miiPins->txd0 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd0 = miiPins->txd0;
            //IfxPort_setPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
            IfxPort_resetPinControllerSelection(txd0->pin.port, txd0->pin.pinIndex);
            IfxPort_setPinModeOutput(txd0->pin.port, txd0->pin.pinIndex, mode, txd0->select);
            IfxPort_setPinPadDriver(txd0->pin.port, txd0->pin.pinIndex, speedGrade);
        }

        if (miiPins->txd1 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd1 = miiPins->txd1;
            //IfxPort_setPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
            IfxPort_resetPinControllerSelection(txd1->pin.port, txd1->pin.pinIndex);
            IfxPort_setPinModeOutput(txd1->pin.port, txd1->pin.pinIndex, mode, txd1->select);
            IfxPort_setPinPadDriver(txd1->pin.port, txd1->pin.pinIndex, speedGrade);
        }

        if (miiPins->txd2 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd2 = miiPins->txd2;
            IfxPort_resetPinControllerSelection(txd2->pin.port, txd2->pin.pinIndex);
            IfxPort_setPinModeOutput(txd2->pin.port, txd2->pin.pinIndex, mode, txd2->select);
            IfxPort_setPinPadDriver(txd2->pin.port, txd2->pin.pinIndex, speedGrade);
        }

        if (miiPins->txd3 != NULL_PTR)
        {
            IfxGeth_Txd_Out *txd3 = miiPins->txd3;
            IfxPort_resetPinControllerSelection(txd3->pin.port, txd3->pin.pinIndex);
            IfxPort_setPinModeOutput(txd3->pin.port, txd3->pin.pinIndex, mode, txd3->select);
            IfxPort_setPinPadDriver(txd3->pin.port, txd3->pin.pinIndex, speedGrade);
        }

        if (miiPins->mdc != NULL_PTR)
        {
            IfxGeth_Mdc_Out *mdc = miiPins->mdc;
            IfxPort_resetPinControllerSelection(mdc->pin.port, mdc->pin.pinIndex);
            IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, mode, mdc->select);
            IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, speedGrade);
        }
    }
}


boolean IfxHsphy_Phy_readMDIORegister(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_PhyIndex phyIdx, uint32 regAddr, uint32 *pdata)
{
    Ifx_HSPHY_PHYREG_CTRL phyControlRegister;
    phyControlRegister.U               = 0;
    phyControlRegister.B.ADDR          = (Ifx_UReg_32Bit)(regAddr << 1);
    phyControlRegister.B.TYP           = 0x01;
    phyControlRegister.B.ACT           = 0x01;
    hsphyRegPtr->PHYREG[phyIdx].CTRL.U = phyControlRegister.U;

    uint32  timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    boolean timeOutError      = FALSE;

    while (hsphyRegPtr->PHYREG[phyIdx].CTRL.B.ACT == 1)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    if (timeOutError == 0)
    {
        Ifx_HSPHY_PHYREG_DATA phyDataRegister;
        phyDataRegister.U = 0;
        phyDataRegister.U = hsphyRegPtr->PHYREG[phyIdx].DATA.U;
        *(pdata)          = phyDataRegister.B.DATA;
    }

    return timeOutError;
}


boolean IfxHsphy_Phy_writeMDIORegister(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_PhyIndex phyIdx, uint32 regAddr, uint32 data)
{
    Ifx_HSPHY_PHYREG_DATA phyDataRegister;
    phyDataRegister.U                  = 0;
    phyDataRegister.B.DATA             = data;
    hsphyRegPtr->PHYREG[phyIdx].DATA.U = phyDataRegister.U;

    Ifx_HSPHY_PHYREG_CTRL phyControlRegister;
    phyControlRegister.U               = 0;
    phyControlRegister.B.ADDR          = (Ifx_UReg_32Bit)(regAddr << 1);
    phyControlRegister.B.TYP           = 0x02;
    phyControlRegister.B.ACT           = 0x01;
    hsphyRegPtr->PHYREG[phyIdx].CTRL.U = phyControlRegister.U;

    uint32  timeoutCycleCount = IFXHSPHY_MAX_TIMEOUT;
    boolean timeOutError      = FALSE;

    while (hsphyRegPtr->PHYREG[phyIdx].CTRL.B.ACT == 1)
    {
        IFXHSPHY_LOOP_TIMEOUT_CHECK(timeoutCycleCount, timeOutError);
    }

    return timeOutError;
}


void IfxHsphy_Geth_setupPpsOutputPin(Ifx_HSPHY *hsphyRegPtr, IfxGeth_Pps_Out *ppsPin)
{
    IFX_UNUSED_PARAMETER(hsphyRegPtr);
    IfxPort_OutputMode mode       = IfxPort_OutputMode_pushPull;
    IfxPort_PadDriver  speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed3;
    IfxPort_setPinControllerSelection(ppsPin->pin.port, ppsPin->pin.pinIndex);
    IfxPort_setPinModeOutput(ppsPin->pin.port, ppsPin->pin.pinIndex, mode, ppsPin->select);

    IfxPort_setPinPadDriver(ppsPin->pin.port, ppsPin->pin.pinIndex, speedGrade);
}


void IfxHsphy_Geth_setMdioOnlyPins(Ifx_HSPHY *hsphyRegPtr, const IfxHsphy_Geth_MdioPins *mdioPins)
{
    IfxPort_InputMode  inOutMode  = IfxPort_InputMode_noPullDevice;
    IfxPort_OutputMode outputMode = IfxPort_OutputMode_pushPull;
    IfxPort_PadDriver  speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed3;

    if (mdioPins->mdc != NULL_PTR)
    {
        IfxGeth_Mdc_Out *mdc = mdioPins->mdc;
        IfxPort_setPinControllerSelection(mdc->pin.port, mdc->pin.pinIndex);
        IfxPort_setPinModeOutput(mdc->pin.port, mdc->pin.pinIndex, outputMode, mdc->select);
        IfxPort_setPinPadDriver(mdc->pin.port, mdc->pin.pinIndex, speedGrade);
    }

    IfxGeth_Mdio_InOut *mdio = mdioPins->mdio;

    if (mdioPins->mdio != NULL_PTR)
    {
        IfxPort_setPinControllerSelection(mdio->pin.port, mdio->pin.pinIndex);
        IfxPort_setPinModeInput(mdio->pin.port, mdio->pin.pinIndex, inOutMode);
        IfxPort_setPinPadDriver(mdio->pin.port, mdio->pin.pinIndex, speedGrade);

        hsphyRegPtr->ETH[mdioPins->portIndex].B.MDIO   = mdio->inSelect;
        hsphyRegPtr->ETH[mdioPins->portIndex].B.MDIOEN = 1;
    }
}


void IfxHsphy_configureAccessToHsphy(IfxApApu_ApuConfig *apConfig)
{
    uint8 i = 0;
    IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_HSPHY.ACCENGLB, apConfig);

    for (i = 0; i < IFXHSPHY_NUM_OF_PHY; i++)
    {
        IfxApApu_init((Ifx_ACCEN_ACCEN *)&MODULE_HSPHY.ACCENCH[i], apConfig);
    }
}


void IfxHsphy_Geth_setRgmiiPins(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_EthIndex ethIndex, IfxHsphy_Geth_RgmiiCfg *config)
{
    IfxHsphy_Geth_setupRgmiiInputPins(hsphyRegPtr, ethIndex, config->rgmiiPins);
    IfxHsphy_Geth_setupRgmiiOutputPins(hsphyRegPtr, config->rgmiiPins);
}


void IfxHsphy_Geth_setMiiPins(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_EthIndex ethIndex, IfxHsphy_Geth_MiiCfg *config)
{
    IfxHsphy_Geth_setupMiiInputPins(hsphyRegPtr, ethIndex, config->miiPins);
    IfxHsphy_Geth_setupMiiOutputPins(hsphyRegPtr, config->miiPins);
}


void IfxHsphy_Geth_setRmiiPins(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_EthIndex ethIndex, IfxHsphy_Geth_RmiiCfg *config)
{
    IfxHsphy_Geth_setupRmiiInputPins(hsphyRegPtr, ethIndex, config->rmiiPins);
    IfxHsphy_Geth_setupRmiiOutputPins(hsphyRegPtr, config->rmiiPins);
}


void IfxHsphy_Geth_setupRmiiInputPins(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_EthIndex ethIndex, const IfxHsphy_Geth_RmiiPins *rmiiPins)
{
    IfxPort_InputMode mode       = IfxPort_InputMode_noPullDevice;
    IfxPort_PadDriver speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    if (rmiiPins != NULL_PTR)
    {
        IfxGeth_Crsdv_In  *crsDiv = rmiiPins->crsDiv;
        IfxGeth_Refclk_In *refClk = rmiiPins->refClk;
        IfxGeth_Rxd_In    *rxd0   = rmiiPins->rxd0;
        IfxGeth_Rxd_In    *rxd1   = rmiiPins->rxd1;

        if (rmiiPins->crsDiv != NULL_PTR)
        {
            hsphyRegPtr->ETH[ethIndex].B.RXCTL = crsDiv->select;
            IfxPort_resetPinControllerSelection(crsDiv->pin.port, crsDiv->pin.pinIndex);
            IfxPort_setPinModeInput(crsDiv->pin.port, crsDiv->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(crsDiv->pin.port, crsDiv->pin.pinIndex, speedGrade);
        }

        if (rmiiPins->refClk != NULL_PTR)
        {
            hsphyRegPtr->ETH[ethIndex].B.RXCLK = refClk->select;
            IfxPort_resetPinControllerSelection(refClk->pin.port, refClk->pin.pinIndex);
            IfxPort_setPinModeInput(refClk->pin.port, refClk->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(refClk->pin.port, refClk->pin.pinIndex, speedGrade);
        }

        if (rmiiPins->rxd0 != NULL_PTR)
        {
            hsphyRegPtr->ETH[ethIndex].B.RXD0 = rxd0->select;
            IfxPort_resetPinControllerSelection(rxd0->pin.port, rxd0->pin.pinIndex);
            IfxPort_setPinModeInput(rxd0->pin.port, rxd0->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd0->pin.port, rxd0->pin.pinIndex, speedGrade);
        }

        if (rmiiPins->rxd1 != NULL_PTR)
        {
            hsphyRegPtr->ETH[ethIndex].B.RXD1 = rxd1->select;
            IfxPort_resetPinControllerSelection(rxd1->pin.port, rxd1->pin.pinIndex);
            IfxPort_setPinModeInput(rxd1->pin.port, rxd1->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd1->pin.port, rxd1->pin.pinIndex, speedGrade);
        }

        if (rmiiPins->mdio != NULL_PTR)
        {
            IfxGeth_Mdio_InOut *mdio = rmiiPins->mdio;
            hsphyRegPtr->ETH[ethIndex].B.MDIO = mdio->inSelect;
            IfxPort_resetPinControllerSelection(mdio->pin.port, mdio->pin.pinIndex);
            IfxPort_setPinModeInput(mdio->pin.port, mdio->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(mdio->pin.port, mdio->pin.pinIndex, speedGrade);
        }
    }
}


void IfxHsphy_Geth_setupRgmiiInputPins(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_EthIndex ethIndex, const IfxHsphy_Geth_RgmiiPins *rgmiiPins)
{
    IfxPort_InputMode mode       = IfxPort_InputMode_noPullDevice;
    IfxPort_PadDriver speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed3;

    //hsphyRegPtr->CTRL.ETH.B.RXCLK = rxClk->select;
    //hsphyRegPtr->CTRL.ETH.B.RXCTL = rxCtl->select;
    //hsphyRegPtr->CTRL.ETH.B.RXD0  = rxd0->select;
    //hsphyRegPtr->CTRL.ETH.B.RXD1  = rxd1->select;
    //hsphyRegPtr->CTRL.ETH.B.RXD2  = rxd2->select;
    //hsphyRegPtr->CTRL.ETH.B.RXD3  = rxd3->select;

    if (rgmiiPins != NULL_PTR)
    {
        if (rgmiiPins->rxClk != NULL_PTR)
        {
            IfxGeth_Rxclk_In *rxClk = rgmiiPins->rxClk;
            IfxPort_setPinControllerSelection(rxClk->pin.port, rxClk->pin.pinIndex);
            IfxPort_setPinModeInput(rxClk->pin.port, rxClk->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxClk->pin.port, rxClk->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->rxCtl != NULL_PTR)
        {
            IfxGeth_Rxctl_In *rxCtl = rgmiiPins->rxCtl;
            IfxPort_setPinControllerSelection(rxCtl->pin.port, rxCtl->pin.pinIndex);
            IfxPort_setPinModeInput(rxCtl->pin.port, rxCtl->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxCtl->pin.port, rxCtl->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->rxd0 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd0 = rgmiiPins->rxd0;
            IfxPort_setPinControllerSelection(rxd0->pin.port, rxd0->pin.pinIndex);
            IfxPort_setPinModeInput(rxd0->pin.port, rxd0->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd0->pin.port, rxd0->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->rxd1 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd1 = rgmiiPins->rxd1;
            IfxPort_setPinControllerSelection(rxd1->pin.port, rxd1->pin.pinIndex);
            IfxPort_setPinModeInput(rxd1->pin.port, rxd1->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd1->pin.port, rxd1->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->rxd2 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd2 = rgmiiPins->rxd2;
            IfxPort_setPinControllerSelection(rxd2->pin.port, rxd2->pin.pinIndex);
            IfxPort_setPinModeInput(rxd2->pin.port, rxd2->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd2->pin.port, rxd2->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->rxd3 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd3 = rgmiiPins->rxd3;
            IfxPort_setPinControllerSelection(rxd3->pin.port, rxd3->pin.pinIndex);
            IfxPort_setPinModeInput(rxd3->pin.port, rxd3->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd3->pin.port, rxd3->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->grefClk != NULL_PTR)
        {
            IfxGeth_Grefclk_In *grefClk = rgmiiPins->grefClk;

            /* As per input from SOCV testing: For RGMII using the internal PERPLL and external gref as a reference clock the PCSR should be set to 0. */
            IfxPort_resetPinControllerSelection(grefClk->pin.port, grefClk->pin.pinIndex);

            IfxPort_setPinModeInput(grefClk->pin.port, grefClk->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(grefClk->pin.port, grefClk->pin.pinIndex, speedGrade);
        }

        if (rgmiiPins->mdio != NULL_PTR)
        {
            IfxGeth_Mdio_InOut *mdio = rgmiiPins->mdio;
            hsphyRegPtr->ETH[ethIndex].B.MDIO = mdio->inSelect;
            IfxPort_setPinControllerSelection(mdio->pin.port, mdio->pin.pinIndex);
            IfxPort_setPinModeInput(mdio->pin.port, mdio->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(mdio->pin.port, mdio->pin.pinIndex, speedGrade);
        }
    }
}


void IfxHsphy_Geth_setupMiiInputPins(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_EthIndex ethIndex, const IfxHsphy_Geth_MiiPins *miiPins)
{
    IfxPort_InputMode mode       = IfxPort_InputMode_noPullDevice;
    IfxPort_PadDriver speedGrade = IfxPort_PadDriver_cmosAutomotiveSpeed1;

    if (miiPins != NULL_PTR)
    {
        if (miiPins->crs != NULL_PTR)
        {
            IfxGeth_Crs_In *crs = miiPins->crs;
            hsphyRegPtr->ETH[ethIndex].B.CRS = crs->select;
            IfxPort_resetPinControllerSelection(crs->pin.port, crs->pin.pinIndex);
            IfxPort_setPinModeInput(crs->pin.port, crs->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(crs->pin.port, crs->pin.pinIndex, speedGrade);
        }

        if (miiPins->col != NULL_PTR)
        {
            IfxGeth_Col_In *col = miiPins->col;
            hsphyRegPtr->ETH[ethIndex].B.COL = col->select;
            IfxPort_resetPinControllerSelection(col->pin.port, col->pin.pinIndex);
            IfxPort_setPinModeInput(col->pin.port, col->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(col->pin.port, col->pin.pinIndex, speedGrade);
        }

        if (miiPins->txClk != NULL_PTR)
        {
            IfxGeth_Txclk_In *txClk = miiPins->txClk;
            hsphyRegPtr->ETH[ethIndex].B.TXCLK = txClk->select;
            IfxPort_resetPinControllerSelection(txClk->pin.port, txClk->pin.pinIndex);
            IfxPort_setPinModeInput(txClk->pin.port, txClk->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(txClk->pin.port, txClk->pin.pinIndex, speedGrade);
        }

        if (miiPins->rxClk != NULL_PTR)
        {
            IfxGeth_Rxclk_In *rxClk = miiPins->rxClk;
            hsphyRegPtr->ETH[ethIndex].B.RXCLK = rxClk->select;
            IfxPort_resetPinControllerSelection(rxClk->pin.port, rxClk->pin.pinIndex);
            IfxPort_setPinModeInput(rxClk->pin.port, rxClk->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxClk->pin.port, rxClk->pin.pinIndex, speedGrade);
        }

        if (miiPins->rxDv != NULL_PTR)
        {
            IfxGeth_Rxdv_In *rxDv = miiPins->rxDv;
            hsphyRegPtr->ETH[ethIndex].B.RXCTL = rxDv->select;
            IfxPort_resetPinControllerSelection(rxDv->pin.port, rxDv->pin.pinIndex);
            IfxPort_setPinModeInput(rxDv->pin.port, rxDv->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxDv->pin.port, rxDv->pin.pinIndex, speedGrade);
        }

        if (miiPins->rxEr != NULL_PTR)
        {
            IfxGeth_Rxer_In *rxEr = miiPins->rxEr;
            hsphyRegPtr->ETH[ethIndex].B.RXER = rxEr->select;
            IfxPort_resetPinControllerSelection(rxEr->pin.port, rxEr->pin.pinIndex);
            IfxPort_setPinModeInput(rxEr->pin.port, rxEr->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxEr->pin.port, rxEr->pin.pinIndex, speedGrade);
        }

        if (miiPins->rxd0 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd0 = miiPins->rxd0;
            hsphyRegPtr->ETH[ethIndex].B.RXD0 = rxd0->select;
            IfxPort_resetPinControllerSelection(rxd0->pin.port, rxd0->pin.pinIndex);
            IfxPort_setPinModeInput(rxd0->pin.port, rxd0->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd0->pin.port, rxd0->pin.pinIndex, speedGrade);
        }

        if (miiPins->rxd1 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd1 = miiPins->rxd1;
            hsphyRegPtr->ETH[ethIndex].B.RXD1 = rxd1->select;
            IfxPort_resetPinControllerSelection(rxd1->pin.port, rxd1->pin.pinIndex);
            IfxPort_setPinModeInput(rxd1->pin.port, rxd1->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd1->pin.port, rxd1->pin.pinIndex, speedGrade);
        }

        if (miiPins->rxd2 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd2 = miiPins->rxd2;
            hsphyRegPtr->ETH[ethIndex].B.RXD2 = rxd2->select;
            IfxPort_resetPinControllerSelection(rxd2->pin.port, rxd2->pin.pinIndex);
            IfxPort_setPinModeInput(rxd2->pin.port, rxd2->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd2->pin.port, rxd2->pin.pinIndex, speedGrade);
        }

        if (miiPins->rxd3 != NULL_PTR)
        {
            IfxGeth_Rxd_In *rxd3 = miiPins->rxd3;
            hsphyRegPtr->ETH[ethIndex].B.RXD3 = rxd3->select;
            IfxPort_resetPinControllerSelection(rxd3->pin.port, rxd3->pin.pinIndex);
            IfxPort_setPinModeInput(rxd3->pin.port, rxd3->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(rxd3->pin.port, rxd3->pin.pinIndex, speedGrade);
        }

        if (miiPins->mdio != NULL_PTR)
        {
            IfxGeth_Mdio_InOut *mdio = miiPins->mdio;
            hsphyRegPtr->ETH[ethIndex].B.MDIO = mdio->inSelect;
            IfxPort_resetPinControllerSelection(mdio->pin.port, mdio->pin.pinIndex);
            IfxPort_setPinModeInput(mdio->pin.port, mdio->pin.pinIndex, mode);
            IfxPort_setPinPadDriver(mdio->pin.port, mdio->pin.pinIndex, speedGrade);
        }
    }
}


void IfxHsphy_Geth_setMdioPinsEnable(Ifx_HSPHY *hsphyRegPtr, IfxHsphy_EthIndex ethIndex, boolean *mdioEnable)
{
    hsphyRegPtr->ETH[ethIndex].B.MDIOEN = 1;
}
