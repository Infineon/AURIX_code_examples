/**********************************************************************************************************************
 * \file IfxSpu_Init.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include <IfxSpu0_Init.h>

IFX_INTERRUPT(ISR_spu0_attn, ISR_VECTAB_CPU0, ISR_PRIORITY_SPU0_INT);
IFX_INTERRUPT(ISR_spu0_err, ISR_VECTAB_CPU0, ISR_PRIORITY_SPU0_ERR);

void IfxSpu_Wnd_init(void *cmem_wnd, uint32 N, const void *wnd, boolean highres, boolean complex);
volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerInt(Ifx_SPU *spu);
volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerErr(Ifx_SPU *spu);

void Spu0_init(void)
 {
    Radar *rdr = &g_rdr;
    rdr->spu0  = &MODULE_SPU0;
    rdr->cmem0 = (SPU_Cmem0_Map_t*) IFXSPU_CONFIG_RAM0_BASE;


    /* Enable SPU & activate linked list finished interrupt */
    IfxSpu_ModuleConfig spu_cfg;
    IfxSpu_initModuleConfig(&spu_cfg);
    spu_cfg.clockDivisionRatio = IfxSpu_ClockDivisionRatio_unity;
    spu_cfg.interrupt.linkedListEnd = TRUE;

    uint16 passwd = IfxScuWdt_getCpuWatchdogPassword();
    IfxScuWdt_clearCpuEndinit(passwd);
        IfxSpu_initModule(rdr->spu0, &spu_cfg);
    IfxScuWdt_setCpuEndinit(passwd);

    /* Clear CFGRAM using MTU */
    Mtu_Spu0Init();

    /* Activate SPU ATTN and ERR interrupts */
    volatile Ifx_SRC_SRCR* src;
    src = IfxSpu_getSrcPointerInt(rdr->spu0);
    IfxSrc_init(src, IfxSrc_Tos_cpu0, ISR_PRIORITY_SPU0_INT);
    IfxSrc_enable(src);

    src = IfxSpu_getSrcPointerErr(rdr->spu0);
    IfxSrc_init(src, IfxSrc_Tos_cpu0, ISR_PRIORITY_SPU0_ERR);
    IfxSrc_enable(src);
 }

 void Spu0_cfg_init(void)
 {
     Radar * rdr = &g_rdr;

     IfxSpu_SlotConfig cfg[NUM_CONFIG_SLOTS];

     /* Copy input windowing data to CFGRAM */
     IfxSpu_Wnd_init(rdr->cmem0->rWndw, RADAR_NUM_SAMPLES, &rWnd_Hann[0], FALSE, FALSE);
     IfxSpu_Wnd_init(rdr->cmem0->dWndw, RADAR_NUM_RAMPS, &dWnd_Hann[0], FALSE, FALSE);


     /* set up configuration slots */
     IfxSpu0_Cfg1_rangeFFT     (&cfg[0],     1, rdr->spu0);  /* slotNr is 1-based [1-128] */
     IfxSpu0_Cfg2_dopplerFFT   (&cfg[1],     2, rdr->spu0);
     IfxSpu0_Cfg3_rLclMax      (&cfg[2],     3, rdr->spu0);


     /* set up Linked list sequence of SPU configurations */
     IfxSpu_CtrlConfig ctrlcfg;
     ctrlcfg.mode                 = IfxSpu_TriggerMode_internal;
     ctrlcfg.clkDiv             = IfxSpu_ClockDivisionRatio_unity;
     ctrlcfg.trigger             = FALSE;
     ctrlcfg.attentionRequest     = FALSE;
     ctrlcfg.crossTrigger        = FALSE;

     IfxSpu_setupConfigSequence(rdr->spu0, 1, 2, &ctrlcfg);
     IfxSpu_setupConfigSequence(rdr->spu0, 2, 3, &ctrlcfg);
     IfxSpu_setupConfigSequence(rdr->spu0, 3, 0, &ctrlcfg);
 }

 /******************************************************************************
 * Brief:   The  routine void IfxSpu_Wnd_init(void *cmem_wnd, uint32 N,
 *                           const void *wnd, boolean highres, boolean complex)
 * Details: This routine initializes the SPU and pre-initializes the CFGRAM
 ******************************************************************************
 */
void IfxSpu_Wnd_init(void *cmem_wnd, uint32 N, const void *wnd, boolean highres, boolean complex)
{
    /* NOTE: CMEM MUST BE WRITTEN IN 32-BIT CHUNKS! */
    uint32  ix;
    uint32  iy;
    uint32 *out = cmem_wnd;
    const uint32 *in  = wnd;

    if (highres==TRUE && complex==FALSE)
    {
        iy = N;
    }
    else if (highres==TRUE && complex==TRUE)
    {
        iy = N<<1;
    }
    else if (highres==FALSE && complex==TRUE)
    {
        iy = N;
    }
    else
    {
        iy = N>>1;
    }

    for (ix=0;ix<iy;ix++)
    {
        *out++ = *in++;
    }
}


/*
 ******************************************************************************
 * Brief:   void IfxCombineBitmaps (void)
 * Details: This routine combines the range- and the doppler-detection bitmap
 * into a single detection bitmap, overwriting the range detection bitmap.
 ******************************************************************************
 */
void IfxCombineBitmaps (void)
{
    uint32 ix, iy, iz, ic;
    uint32 map, rWord, mask;

    Radar *rdr = &g_rdr;
    /* Doppler Dimension coarse */
    for (ic=0;ic<RADAR_NUM_DOPPLER_BINS/32;ic++)
    {
        /* Doppler Dimension fine */
        for (ix=0;ix<32;ix++)
        {
            /* Range Dimension coarse */
            for (iz=0;iz<RADAR_NUM_RANGE_GATES/32;iz++)
            {
                rWord = 0;
                /* Range Dimension fine */
                for (iy=0;iy<32;iy++){
                    map = rdr->emem->lclMaxVMap[iy+(iz*32)][ic];
                    mask = (1<<ix);
                    rWord |= (((map & mask) >> ix) << iy);
                }
                rdr->emem->lclMaxRMap[ix+(ic*32)][iz] &= rWord;
            }
        }
    }
}


 /*
  ******************************************************************************
  * Brief:   volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerInt(Ifx_SPU *spu)
  * Details: This routine returns the address of SPU attn interrupt service node
  ******************************************************************************
  */
 volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerInt(Ifx_SPU *spu)
 {
     return &MODULE_SRC.SPU.SPU[IfxSpu_getIndex(spu)].INT;
 }

 /*
  ******************************************************************************
  * Brief:   volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerErr(Ifx_SPU *spu)
  * Details: This routine returns the address of SPU err interrupt service node
  ******************************************************************************
  */
 volatile Ifx_SRC_SRCR *IfxSpu_getSrcPointerErr(Ifx_SPU *spu)
 {
     return &MODULE_SRC.SPU.SPU[IfxSpu_getIndex(spu)].ERR;
 }

 /*
  ******************************************************************************
  * Brief:   The routine void ISR_spu0_lld(void)
  * Details: This routine is the ISR for SPU0 linked list done event
  ******************************************************************************
  */
 void ISR_spu0_attn()
 {
     Radar *rdr = &g_rdr;

     IfxCombineBitmaps();

     /* Indicate that processing has finished by incrementing spuOk */
     rdr->spuOk++;
 }

 /*
  ******************************************************************************
  * Brief:   The routine void ISR_spu0_err(void)
  * Details: This routine is the ISR for SPU0 error event
  ******************************************************************************
  */
 void ISR_spu0_err()
 {
     __debug();
 }
