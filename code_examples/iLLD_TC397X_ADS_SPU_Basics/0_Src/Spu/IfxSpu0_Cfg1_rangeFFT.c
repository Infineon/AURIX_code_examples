/**********************************************************************************************************************
 * \file IfxSpu_Cfg1_rangeFFT.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include <0_Src/Appl_Cfg/IfxRadar_cfg.h>
#include <IfxSpu0_Init.h>
#include "IfxEmem_cfg.h"
#include "IfxSpu_cfg.h"

IfxSpu_ConfigSlot *IfxSpu0_Cfg1_rangeFFT(IfxSpu_SlotConfig *cfg, uint32 slotNr, Ifx_SPU *spu)
{
    IfxSpu_ConfigSlot* slot = IfxSpu_getConfigSlot(spu, slotNr);

    /** ------------ GLOBAL ------------ */
    /* PASS MODE */
    IfxSpu_setPassMode(slot, IfxSpu_PassMode_single);

    /* INPUT SOURCE */
    uint32 bin_size_bytes = sizeof(sint16);
    cfg->input.dataSource             = IfxSpu_DataSource_emem;
    cfg->input.rm.baseAddress         = IFX_OFFSETOF(SPU_Emem_Map_t, rangeMap.adc_raw[0]);
    cfg->input.rm.dataFormat         = IfxSpu_RM_InputDataFormat_real16Bit;

    cfg->input.rm.antennaMapping     = IfxSpu_RM_AntennaMapping_default;
    cfg->input.rm.addressingMode     = IfxSpu_RM_AddressingMode_linear;
    cfg->input.rm.processingMode     = IfxSpu_RM_ProcessingMode_default;
    cfg->input.rm.numBlocks         = (uint8)(IFXEMEM_BUS_SIZE / bin_size_bytes);

    cfg->input.rm.binLoopRepeat       = RADAR_NUM_SAMPLES;
    cfg->input.rm.innerLoopRepeat     = RADAR_NUM_RX;
    cfg->input.rm.outerLoopRepeat     = RADAR_NUM_RAMPS;

    cfg->input.rm.binLoopOffset       = bin_size_bytes;
    cfg->input.rm.innerLoopOffset     = bin_size_bytes * RADAR_NUM_SAMPLES;
    cfg->input.rm.outerLoopOffset     = bin_size_bytes * RADAR_NUM_SAMPLES * RADAR_NUM_RX;
    IfxSpu_setupInput(slot, &cfg->input);

    /* LOCAL MAX */
    IfxSpu_setupLocalMax(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* BIN REJECTION */
    cfg->binrej.mode                 = IfxSpu_BinRejection_Mode_reject;
    cfg->binrej.numAllowedBins         = RADAR_NUM_RANGE_GATES;
    cfg->binrej.thresholdEnabled     = FALSE;
    cfg->binrej.thresholdValue         = 0xFFFFu;
    cfg->binrej.leftJustify         = FALSE;
    IfxSpu_setupBinRejection(slot, &cfg->binrej);

    /* NCI WEIGHTS */
    IfxSpu_setupNciWeights(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* MAGNITUDE */
    IfxSpu_setupMagnitude(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */

    /* CFAR (CA/GOS) */
    IfxSpu_setupCfarCA(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    IfxSpu_setupCfarGOS(slot, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */


    /** ------------ PASS 0 ------------ */
    {
        IfxSpu_PassId passId         = IfxSpu_PassId_0;
        IfxSpu_PassConfig* pcfg0     = &cfg->pass[passId];

        /* MATH1 */
        pcfg0->math1.loaderExponent          = 32-RADAR_NUM_ADC_BITS; /*alignment when reformatting input data to 32bit*/
        pcfg0->math1.numDropFirstSamples     = 0;
        pcfg0->math1.numDropLastSamples      = 0;
        pcfg0->math1.numPadFrontSamples      = 0;
        pcfg0->math1.window.enabled          = TRUE;
        pcfg0->math1.window.baseAddress      = IFX_OFFSETOF(SPU_Cmem0_Map_t, rWndw);
        pcfg0->math1.window.dataFormat       = IfxSpu_WindowDataFormat_real16;
        pcfg0->math1.phaseShift              = IfxSpu_PhaseShift_0;
        for(uint32 antNr=0; antNr<RADAR_NUM_RX; antNr++)
        {
            pcfg0->math1.window.antennaOffsets[antNr] = 0;
        }
        IfxSpu_setupMath1(slot, passId, &pcfg0->math1);

        /* FFT */
        pcfg0->fft.enabled      = TRUE;
        pcfg0->fft.inversed     = FALSE;
        pcfg0->fft.size         = IfxSpu_getSizeCode(RADAR_FFT1_LEN);
        pcfg0->fft.dataFormat   = IfxSpu_FftDataFormat_complex32Bit;
        pcfg0->fft.exponent     = 0;
        pcfg0->fft.forceToReal  = FALSE;
        IfxSpu_setupFft(slot, passId, &pcfg0->fft);

        /* FFT OUTPUT */
        pcfg0->fftOut.enabled         = TRUE;
        pcfg0->fftOut.baseAddress     = IFX_OFFSETOF(SPU_Emem_Map_t, rangeMap.rMap);
        pcfg0->fftOut.format         = IfxSpu_ODP_Format_complex16Bit;
        pcfg0->fftOut.exponent         = 16;
        pcfg0->fftOut.inPlace         = TRUE;
        IfxSpu_setupFftOutput(slot, passId, &pcfg0->fftOut);

        /* MATH2 */
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);
        IfxSpu_setupCfar(slot, passId, NULL_PTR);
        IfxSpu_setupLog2PowerSummation(slot, passId, NULL_PTR);
        IfxSpu_setupNci(slot, passId, NULL_PTR);
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR);
        IfxSpu_setupSummation(slot, passId, NULL_PTR);

    }

    /** ------------ PASS 1 ------------ */
    {
        IfxSpu_PassId passId = IfxSpu_PassId_1;

        /* Due to mirrored registers, the alternate pass uses same configuration as main pass */
        IfxSpu_setupMath1(slot, passId, &cfg->pass[0].math1);
        IfxSpu_setupFft(slot, passId, &cfg->pass[0].fft);

        IfxSpu_setupFftOutput(slot, passId, NULL_PTR);
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupNci(slot, passId, NULL_PTR);                /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupCfar(slot, passId, NULL_PTR);               /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    }

    return slot;
}
