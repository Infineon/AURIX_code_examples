/**********************************************************************************************************************
 * \file IfxSpu0_Cfg3_rLclMax.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

#include <0_Src/Appl_Cfg/IfxRadar_cfg.h>
#include <IfxSpu0_Init.h>
#include "IfxEmem_cfg.h"
#include "IfxSpu_cfg.h"

IfxSpu_ConfigSlot *IfxSpu0_Cfg3_rLclMax(IfxSpu_SlotConfig *cfg, uint32 slotNr, Ifx_SPU *spu)
{
    uint32             antNr;
    IfxSpu_ConfigSlot *slot = IfxSpu_getConfigSlot(spu, slotNr);


    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, &(rspu_cmem_map->slots[slotNr - 1]) == slot);

    /* GLOBAL */
    {
        /* PASS SETTINGS */
        IfxSpu_setPassMode(slot, IfxSpu_PassMode_single);

        /* INPUT SOURCE */
        uint32 inputBinSize;
        inputBinSize = sizeof(csint16);

        cfg->input.dataSource      = IfxSpu_DataSource_emem;
        cfg->input.rm.baseAddress  = IFX_OFFSETOF(SPU_Emem_Map_t, rdMap[0]);
        cfg->input.rm.dataFormat   = IfxSpu_RM_InputDataFormat_complex16Bit;

        cfg->input.rm.antennaMapping  = IfxSpu_RM_AntennaMapping_innerLoopRepeat;
        cfg->input.rm.addressingMode  = IfxSpu_RM_AddressingMode_transpose;
        cfg->input.rm.processingMode  = IfxSpu_RM_ProcessingMode_integration;
        cfg->input.rm.numBlocks       = (uint8)(IFXEMEM_BUS_SIZE / inputBinSize);
        cfg->input.rm.binLoopRepeat   = RADAR_NUM_RANGE_GATES;
        cfg->input.rm.innerLoopRepeat = RADAR_NUM_RX;
        cfg->input.rm.outerLoopRepeat = RADAR_NUM_DOPPLER_BINS;
        cfg->input.rm.binLoopOffset   = inputBinSize * RADAR_NUM_DOPPLER_BINS * RADAR_NUM_RX;
        cfg->input.rm.innerLoopOffset = inputBinSize * RADAR_NUM_DOPPLER_BINS;
        cfg->input.rm.outerLoopOffset = inputBinSize;

        IfxSpu_setupInput(slot, &cfg->input);

        /* LOCAL MAX */
        cfg->localMax.combinedMode   = IfxSpu_LocalMax_CombinedMode_and;
        cfg->localMax.leftJustify    = TRUE;
        cfg->localMax.localMaxMode   = IfxSpu_LocalMax_Mode_under;
        cfg->localMax.thresholdMode  = IfxSpu_LocalMax_ThresholdMode_under;
        cfg->localMax.thresholdValue = 0xFFF;
        cfg->localMax.windowWidth    = IfxSpu_LocalMax_WindowWidth_five;
        IfxSpu_setupLocalMax(slot, &cfg->localMax); /* disabled with passing NULL_PTR */

        /* BIN-REJECTION */
        IfxSpu_setupBinRejection(slot, NULL_PTR);

        /* NCI weights */
        IfxSpu_setupNciWeights(slot, NULL_PTR); /* set to default (ONEs) by passing NULL_PTR */

        /* Magnitude approx. */
        cfg->magnitude.alpha = 0xF2B3; /* 0.948059448969 */
        cfg->magnitude.beta  = 0x6488; /* 0.392699081699 */
        IfxSpu_setupMagnitude(slot, &cfg->magnitude);
    }

    /* FIRST PASS */
    {
        IfxSpu_PassId      passId = IfxSpu_PassId_0;
        IfxSpu_PassConfig *pcfg   = &cfg->pass[passId];

        /* MATH 1 */
        pcfg->math1.loaderExponent      = 16;
        pcfg->math1.numDropFirstSamples = 0;
        pcfg->math1.numDropLastSamples  = 0;
        pcfg->math1.numPadFrontSamples  = 0;
        pcfg->math1.window.enabled      = FALSE;
        pcfg->math1.window.dataFormat   = IfxSpu_WindowDataFormat_real16;
        pcfg->math1.window.baseAddress  = 0;
        for (antNr = 0; antNr < RADAR_NUM_RX; antNr++)
        {
            pcfg->math1.window.antennaOffsets[antNr] = 0;
        }

        pcfg->math1.phaseShift = IfxSpu_PhaseShift_0;
        IfxSpu_setupMath1(slot, passId, &pcfg->math1);

        /* FFT ENGINE UNLOADER */
        pcfg->fft.enabled     = FALSE;
        pcfg->fft.inversed    = FALSE;
        pcfg->fft.size        = IfxSpu_getSizeCode(RADAR_FFT1_LEN);
        pcfg->fft.dataFormat  = IfxSpu_FftDataFormat_complex32Bit;
        pcfg->fft.exponent    = 0;
        pcfg->fft.forceToReal = FALSE;
        IfxSpu_setupFft(slot, passId, &pcfg->fft);

        /* FFT OUTPUT */
        pcfg->fftOut.enabled       = FALSE;
        pcfg->fftOut.baseAddress   = 0;
        pcfg->fftOut.format        = IfxSpu_ODP_Format_complex16Bit;
        pcfg->fftOut.exponent      = 16;
        pcfg->fftOut.inPlace       = FALSE;
        IfxSpu_setupFftOutput(slot, passId, &pcfg->fftOut);

        /* HISTOGRAM */
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */

        /* NON-COHERENT INTEGRATION */
        pcfg->nci.baseAddress      = 0;
        pcfg->nci.enabled          = TRUE;
        pcfg->nci.outputFormat     = IfxSpu_NCI_OutputFormat_off;
        pcfg->nci.scalingFactor    = IfxSpu_NCI_ScalingFactor_off;
        IfxSpu_setupNci(slot, passId, &pcfg->nci);

        /* SUMMATION */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */

        /* LOG2 POWER */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */

        /* CFAR */
        /* GOS CFAR */
        IfxSpu_setupCfarGOS(slot, NULL_PTR);
        /* CA CFAR */
        IfxSpu_setupCfarCA(slot, NULL_PTR);
        /* COMMON CFAR */
        pcfg->cfar.baseAddress = IFX_OFFSETOF(SPU_Emem_Map_t, lclMaxRMap[0]);
        pcfg->cfar.mode        = IfxSpu_CFAR_Mode_localMaxNci;
        IfxSpu_setupCfar(slot, passId, &pcfg->cfar);

        /* STATISTICS */
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    }

    /* SECOND PASS */
    {
        IfxSpu_PassId      passId = IfxSpu_PassId_1;

        /* Due to mirrored registers, the alternate pass uses same configuration as main pass */
        IfxSpu_setupMath1(slot, passId, &cfg->pass[0].math1);
        IfxSpu_setupFft(slot, passId, &cfg->pass[0].fft);

        IfxSpu_setupFftOutput(slot, passId, NULL_PTR);
        IfxSpu_setupHistogram(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupNci(slot, passId, NULL_PTR);                /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSummation(slot, passId, NULL_PTR);          /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupPowerChannel(slot, passId, NULL_PTR);       /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupCfar(slot, passId, NULL_PTR);               /* set to default (disabled) by passing NULL_PTR */
        IfxSpu_setupSidebandStatistics(slot, passId, NULL_PTR); /* set to default (disabled) by passing NULL_PTR */
    }

    return slot;
}
