/**********************************************************************************************************************
 * \file main.c
 * \copyright Copyright (C) Infineon Technologies AG 2019
 *
 * Use of this file is subject to the terms of use agreed between (i) you or the company in which ordinary course of
 * business you are acting and (ii) Infineon Technologies AG or its licensees. If and as long as no such terms of use
 * are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization obtaining a copy of the software and
 * accompanying documentation covered by this license (the "Software") to use, reproduce, display, distribute, execute,
 * and transmit the Software, and to prepare derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including the above license grant, this restriction
 * and the following disclaimer, must be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are solely in the form of
 * machine-executable object code generated by a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 * WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN
 * CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *********************************************************************************************************************/

/*********************************************************************************************************************/
/*-----------------------------------------------------Includes------------------------------------------------------*/
/*********************************************************************************************************************/
#include "scr_io_sdcc.h"
#include "scr_irq_sdcc.h"
#include "scr_rtc_sdcc.h"
#include "scr_scu_sdcc.h"
#include "scr_sfr_sdcc.h"
#include "scr_wdt_sdcc.h"
#include "scr_common.h"
#include "../AppBsp_Conf.h"

/*********************************************************************************************************************/
/*------------------------------------------------------Macros-------------------------------------------------------*/
/*********************************************************************************************************************/
#define RTC_INTERVAL_1S             FALSE
#define WAIT_TC_STANDBY_MODE        FALSE

/*********************************************************************************************************************/
/*-------------------------------------------------Global variables--------------------------------------------------*/
/*********************************************************************************************************************/

/* XRAM memory for TriCore <-> SCR data exchange.
 * - Size and structure need to be aligned with section '.xdata' in scr.ld
 *
 * ATTENTION: The compiler does not reserve any space for variables declared in this way (they are implemented with
 *            an equate in the assembler). Thus it is left to the programmer to make sure there are no overlaps with
 *            other variables that are declared without the absolute address!
 */
__xdata volatile uint8 __at (XRAM_EXCHANGE_OFFSET) g_exchangeBytes[4];

/* Place global helper variables in internal data memory */
__data volatile uint8 g_debugCounter;

/* Place flags which need fast access (like from ISR) in the bit-addressable internal data memory (16 bytes of RAM
 * that occupy addresses from 20h to 2Fh).
 */
__bit g_disabledHF;     /* Global HF mode flag (TRUE = HF disabled, FALSE = HF enabled) */

/*********************************************************************************************************************/
/*------------------------------------------------Function Prototypes------------------------------------------------*/
/*********************************************************************************************************************/
void rtcIsrHandler(void) __interrupt (XINTR13);

/*********************************************************************************************************************/
/*---------------------------------------------Function Implementations----------------------------------------------*/
/*********************************************************************************************************************/
void main(void)
{
    /* Enable access to non-mapped (standard) special function register area */
    SCR_SYSCON0 = 0;
    /* Disable watchdog timer, to ensure it will not disrupt the idle mode */
    SCR_WDT_CON = 0;

    /* Initialize the dummy counter for debug purpose */
    g_debugCounter = 0;
    /* Set HF mode flag to enabled (default after reset) */
    g_disabledHF = FALSE;

    /* Initialize the TC shared memory locations for the RTC overflow.
     * May be overwritten from the TriCore(TM) for change of the RTC period */
#if RTC_INTERVAL_1S
    /* Counter setting for 1s@70kHz */
    g_exchangeBytes[3] = 0x00;
    g_exchangeBytes[2] = 0x01;
    g_exchangeBytes[1] = 0x11;
    g_exchangeBytes[0] = 0x70;
#else
    /* Counter setting for 0.2s@70kHz */
    g_exchangeBytes[3] = 0x00;
    g_exchangeBytes[2] = 0x00;
    g_exchangeBytes[1] = 0x36;
    g_exchangeBytes[0] = 0xB0;
#endif /* RTC_INTERVAL_1S */

#if USE_KIT_A2G_TC375_LITE
    /* Enable available pins
       P33.0 - P33.6, P33.9 - P33.13 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.1 to P01.5 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 );

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 (P33.4) as output, push-pull */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (connect to button 1) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;

    /* Errata SCR_TC.021
     * - RTC not counting after reset if P33.10 is high.
     * - Device: TC37xEXT
     * - Marking/Step: (E)ES-AA)
     * 
     * Clear P01.2 (P33.10) to ensure a low level at the beginning, otherwise
     * it is possible that the RTC will not start.
     */
    SCR_SET_IO_PAGE(MOD_PAGE_0);
    SCR_IO_P01_OUT &= (~ScrIoPin2);
    /* Set P01.2 (P33.10) as output, push-pull */
    SCR_SET_IO_PAGE(MOD_PAGE_1);
    SCR_IO_P01_IOCR2 = ScrPortMode_outputPushPullGeneral;
    /* ~Errata SCR_TC.021 */
#endif /* USE_KIT_A2G_TC375_LITE */

#if USE_KIT_A2G_TC397_5V_TFT
    /* Enable available pins
       P33.0 - P33.6, P33.10 - P33.12 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.6 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6);
    /* Enable P01.2 to P01.4 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin2 | ScrIoPin3 | ScrIoPin4);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 (P33.4) as output, push-pull */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, pull up (external switch) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputPullUp;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_A2G_TC397_5V_TFT */

#if USE_KIT_TC397_TRB
    /* Enable available pins 
       P33.0 - P33.7, P34.1, P33.11 - P33.15 */
    SCR_SET_IO_PAGE(MOD_PAGE_2);
    /* Enable P00.0 to P00.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P00_PDISC = ~(ScrIoPin0 | ScrIoPin1 | ScrIoPin2 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);
    /* Enable P01.0, P01.3 to P01.7 (0 = enabled, 1 = disabled) */
    SCR_IO_P01_PDISC = ~(ScrIoPin0 | ScrIoPin3 | ScrIoPin4 | ScrIoPin5 | ScrIoPin6 | ScrIoPin7);

    SCR_SET_IO_PAGE(MOD_PAGE_0);
    /* Initialize P00.4 (P33.4) out to 1 (LED off) */
    SCR_IO_P00_OUT = ScrIoPin4;

    SCR_SET_IO_PAGE(MOD_PAGE_1);
    /* Set P00.4 / P33.4 as output, push-pull (LED D302) */
    SCR_IO_P00_IOCR4 = ScrPortMode_outputPushPullGeneral;
    /* Set P01.3 (P33.11) as input, no pull up (S202) */
    SCR_IO_P01_IOCR3 = ScrPortMode_inputNoPullDevice;
    /* Set P01.4 (P33.12) as input, pull up (PINB) */
    SCR_IO_P01_IOCR4 = ScrPortMode_inputPullUp;
#endif /* USE_KIT_TC397_TRB */

    /* Enable 20MHz clock to SCR */
    Scr_set_fsys(DIV5);

#if WAIT_TC_STANDBY_MODE
    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    while(!Scr_is_in_standby()); /* Wait until TC enters standby mode */
#endif /* WAIT_TC_STANDBY_MODE */

    /*** Initialize interrupts ***/
    SCR_SET_SCU_PAGE(MOD_PAGE_1);
    /* Disable request: all except RTC and OCDS */
    SCR_SCU_PMCON1 = (LIN_DIS_MASK | WDT_DIS_MASK | WCAN_DIS_MASK | T2CCU_DIS_MASK | SSC_DIS_MASK);
    /* Clear all NMI service request flags. I.e. FNMIWKP */
    SCR_SCU_NMISR = 0x0;

    /* Reset all interrupts */
    SCR_SET_SCU_PAGE(MOD_PAGE_0);
    SCR_SCU_IRCON0 = 0;
    SCR_SCU_IRCON1 = 0;
    SCR_SCU_IRCON2 = 0;

    /* Interrupt enable register 1:
     *  XINTR13 - interrupt node enable (RTC interrupt).
     */
    SCR_IEN1 = 0x80;
    /* Interrupt enable register 0:
     *  EA - Global Interrupt Mask set.
     */
    SCR_IEN0_EA = 1;
    /*** ~Initialize interrupts ***/

    /*** Initialize RTC ***/
    Scr_set_count_registers(0);
    /* Set RTC overflow setting with the shared data from the TC */
    SCR_RTC_CR3 = g_exchangeBytes[3];
    SCR_RTC_CR2 = g_exchangeBytes[2];
    SCR_RTC_CR1 = g_exchangeBytes[1];
    SCR_RTC_CR0 = g_exchangeBytes[0];
    /*** ~Initialize RTC ***/

    /* Enable Real-Time clock compare interrupt, 9-bit prescaler is bypassed, 70 kHz clock is selected */
    SCR_RTC_CON = (ECRTC_MASK | RTPBYP_MASK);

    while(1)
    {
        /* Check if HF clock is enabled in the application */
        if(!g_disabledHF)
        {
            /* Periodic update of RTC overflow setting with the shared data from the TC */
            SCR_RTC_CR3 = g_exchangeBytes[3];
            SCR_RTC_CR2 = g_exchangeBytes[2];
            SCR_RTC_CR1 = g_exchangeBytes[1];
            SCR_RTC_CR0 = g_exchangeBytes[0];

            /*** Do all tasks if HFclock is ready ***/

            /*** Disable HF clock when all tasks are complete ***/

            /* Trigger LF mode */
            Scr_set_fsys_70kHz();
            /* Set HF mode flag to disabled */
            g_disabledHF = TRUE;

            /* Start Real-Time clock operation */
            Scr_start_rtc();
        }
    }
}

/* RTC Interrupt Service Routine (using SCR Interrupt Node 13)  */
void rtcIsrHandler(void) __interrupt (XINTR13)
{
    SCR_SET_SCU_PAGE_STNR1(MOD_PAGE_0); /* Store current SCU page and switch to page 0 */
    SCR_SET_IO_PAGE_STNR1(MOD_PAGE_0);  /* Store current IO page and switch to page 0 */
    /* Clear compare match flag set by hardware */
    SCR_RTC_CON &= (~CFRTC_MASK);

    /* Share the dummy counter with TC via SCRINTEXCHG, counter for debug purpose */
    g_debugCounter = SCR_SCU_SCRINTEXCHG;
    g_debugCounter += 1;
    SCR_SCU_SCRINTEXCHG = g_debugCounter;

    /* Check if the HF clock is disabled in the application */
    if(g_disabledHF)
    {
        /* Stop Real-Time clock operation
         * Not necessary, but depends on the application */
        Scr_stop_rtc();

        /* Enable 20MHz clock to SCR */
        Scr_set_fsys(DIV5);

        /* Set HF mode flag to enabled */
        g_disabledHF = FALSE;

        /* Toggle P00.4 (LED) */
        SCR_IO_P00_OMTR = ScrIoPin4;

        if(0 == (SCR_IO_P01_IN & ScrIoPin3))
        {
            /* Software Wake-Up from Standby Mode */
            SCR_SET_SCU_PAGE(MOD_PAGE_1);
            SCR_SCU_STDBYWKP = SCRWKP_MASK;
        }
    }

    SCR_RESTORE_IO_PAGE_STNR1();    /* Restore previous IO page */
    SCR_RESTORE_SCU_PAGE_STNR1();   /* Restore previous SCU page */
}
