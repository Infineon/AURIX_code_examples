/**
 * \file IfxFlash.h
 * \brief FLASH  basic functionality
 * \ingroup IfxLld_Flash
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Flash_Std_Enumerations Enumerations
 * \ingroup IfxLld_Flash_Std
 * \defgroup IfxLld_Flash_Std_CommandSequence CommandSequence Functions
 * \ingroup IfxLld_Flash_Std
 * \defgroup IfxLld_Flash_Std_ErrorTracking Error Tracking Functions
 * \ingroup IfxLld_Flash_Std
 */

#ifndef IFXFLAS_H
#define IFXFLAS_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxFlash_cfg.h"
#include "Cpu/Std/IfxCpu_Intrinsics.h"
#include "_Utilities/Ifx_Assert.h"
#include "IfxDmu_reg.h"
#include "IfxFsi_reg.h"

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/

/** \brief Enumeration describing the host command interface error
 */
typedef enum
{
    IfxFlash_Error_address       = 0,  /**< \brief SRI bus address error */
    IfxFlash_Error_sequence      = 1,  /**< \brief Command Sequence error */
    IfxFlash_Error_protection    = 2,  /**< \brief Protection error */
    IfxFlash_Error_abort         = 4,  /**< \brief Abort error */
    IfxFlash_Error_clear         = 5,  /**< \brief Clear error */
    IfxFlash_Error_programVerify = 6,  /**< \brief Program Verify error */
    IfxFlash_Error_eraseVerify   = 7,  /**< \brief Erase Verify error */
    IfxFlash_Error_operation     = 16, /**< \brief Operation error */
    IfxFlash_Error_original      = 17  /**< \brief Original error */
} IfxFlash_Error;

/** \brief Enumeration describing the status of an operation
 */
typedef enum
{
    IfxFlash_Status_success = 0,  /**< \brief operation successful */
    IfxFlash_Status_failure = 1   /**< \brief operation failed */
} IfxFlash_Status;

/** \addtogroup IfxLld_Flash_Std_CommandSequence
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Performs the "Clear Status" sequence. Operation and error flags are cleared.
 * \param flash selects the flash (PMU) module
 * \return None
 */
IFX_INLINE void IfxFlash_clearStatus(uint32 flash);

/** \brief Performs the sequence for entering program page mode
 * \param pageAddr pageAddr specifies the page being written - the command sequence will be varied accordingly
 * \return 0 on success, != 0 if invalid or not available page is selected
 *
 * Usage Example:
 * \code
 *
 * unsigned int pageAddr = IFXFLASH_DFLASH_START + page*IFXFLASH_DFLASH_PAGE_LENGTH;
 *
 * // enter page mode
 * IfxFlash_enterPageMode(pageAddr);
 *
 * \endcode
 * \see IfxFlash_writePage()
 *
 */
IFX_INLINE uint8 IfxFlash_enterPageMode(uint32 pageAddr);

/** \brief Performs the erase sequence for n  sectors in program or data flash
 * \param sectorAddr sector address
 * \param numSector the no.of sectors to be erased
 * \return None
 *
 * Usage Example:
 * \code
 *
 *  unsigned int sector_addr = IfxFlash_pFlashTableLog[sector].start;
 *  IfxFlash_clearStatus(0);
 *  IfxFlash_eraseMultipleSectors(sector_addr,2);
 *
 *  while(!IfxFlash_isRequestReceived()); // Wait until request acknowledged
 *  while(!IfxFlash_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *   if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection) || \
 *    IfxFlash_isErrorDetected(IfxFlash_Error_programVerify) || IfxFlash_isErrorDetected(IfxFlash_Error_eraseVerify) || \
 *    IfxFlash_isErrorDetected(IfxFlash_Error_operation))
 *    {
 *     //Error handling
 *    }
 *    IfxFlash_clearStatus(0);
 *
 * \endcode
 *
 */
IFX_INLINE void IfxFlash_eraseMultipleSectors(uint32 sectorAddr, uint32 numSector);

/** \brief Performs the erase sequence for a sector in program or data flash.
 * \param sectorAddr sector address
 * \return None
 *
 * Usage Example:
 * \code
 *
 *  unsigned int sector_addr = IfxFlash_pFlashTableLog[sector].start;
 *  IfxFlash_clearStatus(0);
 *  IfxFlash_eraseSector(sector_addr);
 *
 *  while(!IfxFlash_isRequestReceived()); // Wait until request acknowledged
 *  while(!IfxFlash_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *   if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection) || \
 *    IfxFlash_isErrorDetected(IfxFlash_Error_programVerify) || IfxFlash_isErrorDetected(IfxFlash_Error_eraseVerify) || \
 *    IfxFlash_isErrorDetected(IfxFlash_Error_operation))
 *    {
 *     //Error handling
 *    }
 *    IfxFlash_clearStatus(0);
 *
 * \endcode
 *
 */
IFX_INLINE void IfxFlash_eraseSector(uint32 sectorAddr);

/** \brief Performs the "Erase Verify" sequence for multiple sectors
 * \param sectorAddr sector address which should be verified
 * \param numSector no.of sectors to be operated on
 * \return None
 */
IFX_INLINE void IfxFlash_eraseVerifyMultipleSectors(uint32 sectorAddr, uint32 numSector);

/** \brief Performs the "Erase Verify" sequence
 * \param sectorAddr sector address which should be verified
 * \return None
 */
IFX_INLINE void IfxFlash_eraseVerifySector(uint32 sectorAddr);

/** \brief performs a load page sequence with a single 64bit access
 * \param pageAddr pageAddr start address of page which should be programmed
 * \param wordL Lower Address word
 * \param wordU Upper address word
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // load 64bit into assembly buffer of program flash
 * IfxFlash_loadPage(IFXFLASH_PFLASH_START, 0x55555555, 0xaaaaaaaa);
 *
 * // load 64bit into assembly buffer of data flash
 * IfxFlash_loadPage(0XAF000000, 0x55555555, 0xaaaaaaaa);
 * \endcode
 * \see IfxFlash_writePage()
 *
 */
IFX_INLINE void IfxFlash_loadPage(uint32 pageAddr, uint32 wordL, uint32 wordU);

/** \brief performs a load page sequence with two 32bit accesses
 * \param pageAddr pageAddr start address of page which should be programmed
 * \param wordL Lower Address word
 * \param wordU Upper Address word
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // load 2*32bit into assembly buffer of program flash
 * IfxFlash_loadPage2X32(IFXFLASH_PFLASH_START, 0x55555555, 0xaaaaaaaa);
 *
 * // load 2*32bit into assembly buffer of data flash
 * IfxFlash_loadPage2X32(0XAF000000, 0x55555555, 0xaaaaaaaa);
 * \endcode
 * \see IfxFlash_writePage()
 *
 */
IFX_INLINE void IfxFlash_loadPage2X32(uint32 pageAddr, uint32 wordL, uint32 wordU);

/** \brief reset to read mode
 * \param flash flash selects the flash (PMU) module
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // reset to read mode
 *  IfxFlash_resetToRead(0);
 *
 * \endcode
 *
 */
IFX_INLINE void IfxFlash_resetToRead(uint32 flash);

/** \brief Performs the "Resume Protection" sequence
 * This command clears all DMU_GP_HOST_PROTECT (Host Command Interface) and enables again the Flash protection as it was configured.
 * \param flash selects the flash (PMU) module
 * \return None
 */
IFX_INLINE void IfxFlash_resumeProtection(uint32 flash);

/** \brief Performs the "Suspend Resume" sequence for multiple sectors.
 * A suspended command may be resumed. The arguments sectorAddr of the Resume NVM operation must be identical to the arguments of the suspended command
 * \param sectorAddr sector address
 * \param numSector the no.of sectors  to be operated on
 * \return None
 */
IFX_INLINE void IfxFlash_suspendResumeMultipleSectors(uint32 sectorAddr, uint32 numSector);

/** \brief Performs the "Suspend Resume" sequence.
 * A suspended command may be resumed. The arguments sectorAddr of the Resume NVM operation must be
 * identical to the arguments of the suspended command
 * \param sectorAddr sector address which should be resumed
 * \return None
 */
IFX_INLINE void IfxFlash_suspendResumeSector(uint32 sectorAddr);

/** \brief The function issues command sequence for User Content count.The result of this function is dependent on the difference of the number of logic 1 bits in the selected pages at the  erase-verify condition (N_dv) and at the selected control gate voltage (N_pv). Calling this function with different control gate voltages allows calculation of the Vth distribution
 * \param wordAddr word address
 * \return None
 */
IFX_INLINE void IfxFlash_userContentCount(uint32 wordAddr);

/** \brief The function issues command sequence for User Margin Count. The result of this function is the number of logic 1 bits in the selected pages at the selected reference current. Calling this function with different reference currents allows calculation of the cell current distribution.
 * \param wordAddr word address
 * \return None
 */
IFX_INLINE void IfxFlash_userMarginCount(uint32 wordAddr);

/** \brief The function issues command sequence for User Vth Count.The result of this function is the number of logic 1 bits in the selected pages at the selected control gate voltage. Calling this function with different control gate voltages allows calculation of the Vth distribution.
 * \param wordAddr word address
 * \return None
 */
IFX_INLINE void IfxFlash_userVthCount(uint32 wordAddr);

/** \brief Performs the "Verify Erased Block (page)" sequence. This command verifies if one page addressed by "PA" is correctly erased, i.e. contain 0 data and ECC bits
 * \param pageAddr page address which should be verified
 * \return None
 *
 * Usage Example:
 *
 *  \code
 *
 *  uint32 pageAddr = IFXFLASH_DFLASH_START;
 *  IfxFlash_verifyErasedPage(pageAddr);
 *
 *  while(!IfxFlash_isRequestReceived()); // Wait until request acknowledged
 *  while(!IfxFlash_isRequestExecuted()); // Wait until request done
 *
 *   if(IfxFlash_isErrorDetected(IfxFlash_Error_eraseVerify) || IfxFlash_isErrorDetected(IfxFlash_Error_sequence))
 *  {
 *    //Error handling
 *  }
 *  IfxFlash_clearStatus(0);
 *  \endcode
 *
 *  \see IfxFlash_eraseSector()
 *
 */
IFX_INLINE void IfxFlash_verifyErasedPage(uint32 pageAddr);

/** \brief Performs the "Verify Erased WL" sequence.This command verifies if one word line addressed by "WA" is correctly erased, i.e. contain 0 data and ECC bits
 * \param wordLineAddr word line address which should be verified
 * \return None
 */
IFX_INLINE void IfxFlash_verifyErasedWordLine(uint32 wordLineAddr);

/** \brief Performs the "Write Burst" sequence, similar to write page but performs a burst transfer instead of page.Make sure the appropriate amount of data is loaded using load page command
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 *  \code
 *    unsigned int pageAddr = IFXFLASH_DFLASH_START + page*IFXFLASH_DFLASH_PAGE_LENGTH;
 *    boolean pageStatus;
 *      //Clear status commands to clear flags
 *      IfxFlash_clearStatus(0);
 *      //Enter Page Mode
 *      IfxFlash_enterPageMode(pageAddr);
 *      do
 *      {
 *          pageStatus = IfxFlash_isDflashInPageMode();
 *      }while(pageStatus != TRUE);
 *
 *      if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection))
 *   {
 *   }
 *      // Repeat load page util page filled
 *       for(uint8 index =0; index < 4; index+=2)
 *   {
 *     IfxFlash_loadPage(pageAddr, (index), (index+1));
 *   }
 *
 *      //Write Page
 *      IfxFlash_clearStatus(0);
 *      IfxFlash_writeBurst(pageAddr);
 *
 *   while(!IfxFlash_isRequestReceived()); // Wait until request acknowledged
 *   while(!IfxFlash_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *    if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlashCsrm_Error_protectionError) || \
 *     IfxFlash_isErrorDetected(IfxFlash_Error_operation) || IfxFlash_isErrorDetected(IfxFlashCsrm_Error_programVerifyError))
 *     {
 *      //Error handling
 *     }
 *     IfxFlash_clearStatus(0);
 *  \endcode
 *
 */
IFX_INLINE void IfxFlash_writeBurst(uint32 pageAddr);

/** \brief Performs the "Write Burst once" sequence. The command starts the programming process for an aligned group of pages as the normal "Write Burst" does. But before programming it checks if the pages are erased. If the page is not erased (allowing correctable errors) the command fails with PVER and EVER.
 * The command is only supported for PFlash. On sectors with "write-once" protection only this write command can be applied.
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 * \code
 *
 * // program the second page of the first sector of the Program Flash
 * IfxFlash_writeBurstOnce(0xa0000100);
 *
 * \endcode
 * \see IfxFlash_writeBurst()
 *
 */
IFX_INLINE void IfxFlash_writeBurstOnce(uint32 pageAddr);

/** \brief Performs the "Write Page" sequence
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 *  \code
 *    unsigned int pageAddr = IFXFLASH_DFLASH_START + page*IFXFLASH_DFLASH_PAGE_LENGTH;
 *    boolean pageStatus;
 *      //Clear status commands to clear flags
 *      IfxFlash_clearStatus(0);
 *      //Enter Page Mode
 *      IfxFlash_enterPageMode(pageAddr);
 *      do
 *      {
 *          pageStatus = IfxFlash_isDflashInPageMode();
 *      }while(pageStatus != TRUE);
 *
 *      if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection))
 *   {
 *   }
 *      // Repeat load page util page filled
 *   IfxFlash_loadPage(pageAddr, 0x55555555, 0xaaaaaaaa);
 *
 *      //Write Page
 *      IfxFlash_clearStatus(0);
 *      IfxFlash_writePage(pageAddr);
 *
 *   while(!IfxFlash_isRequestReceived()); // Wait until request acknowledged
 *   while(!IfxFlash_isRequestExecuted()); // Wait until request done
 *
 *   //Error Checks
 *    if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection) || \
 *     IfxFlash_isErrorDetected(IfxFlash_Error_operation) || IfxFlash_isErrorDetected(IfxFlash_Error_programVerify))
 *     {
 *      //Error handling
 *     }
 *     IfxFlash_clearStatus(0);
 *  \endcode
 *
 */
IFX_INLINE void IfxFlash_writePage(uint32 pageAddr);

/** \brief Performs the "Write Page Once" sequence, similar to write page but performs a program verify after writing.
 * \param pageAddr start address of page which should be programmed
 * \return None
 *
 * Usage Example:
 * \code
 *   unsigned int pageAddr = IFXFLASH_DFLASH_START + page*IFXFLASH_DFLASH_PAGE_LENGTH;
 *   boolean pageStatus;
 *  //Clear status commands to clear flags
 *  IfxFlashCsrm_clearStatus(0);
 *  //Enter Page Mode
 *  IfxFlash_enterPageMode(pageAddr);
 *  do
 *  {
 *      pageStatus = IfxFlash_isDflashInPageMode();
 *  }while(pageStatus != TRUE);
 *
 *  if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection))
 *  {
 *  }
 *  // Repeat load page util page filled
 *  IfxFlash_loadPage(pageAddr, 0x55555555, 0xaaaaaaaa);
 *
 *  //Write Page
 *  IfxFlash_clearStatus(0);
 *  IfxFlash_writePageOnce(pageAddr);
 *
 *  while(!IfxFlash_isRequestReceived()); // Wait until request acknowledged
 *  while(!IfxFlash_isRequestExecuted()); // Wait until request done
 *
 *  //Error Checks
 *   if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection) || \
 *    IfxFlash_isErrorDetected(IfxFlash_Error_operation) || IfxFlash_isErrorDetected(IfxFlash_Error_programVerify))
 *    {
 *     //Error handling
 *    }
 *    IfxFlash_clearStatus(0);
 *
 * \endcode
 *
 * \see IfxFlash_writePage()
 *
 */
IFX_INLINE void IfxFlash_writePageOnce(uint32 pageAddr);

/** \brief Function performs Replace Logical Sector operation that enables the replacement of a logical sector with hard fails with an available redundant logical sector. It can be used if a sector fails during an erase or program.
 * The number of available free redundant sectors can be retrieved by using the Count Free Redundant Sectors command
 * \param pageAddr start address of page which should be programmed
 * \return None
 */
IFX_INLINE void IfxFlash_replaceLogicalSector(uint32 pageAddr);

/** \brief Function returns the number of free redundant sectors in a Bank.
 * \param flashType selects the flash type
 * \return Number of free redundant sector.
 */
IFX_INLINE uint8 IfxFlash_countFreeRedundantSector(IfxFlash_FlashType flashType);

/** \brief Function to move the banks to other command interface.It is only possible to move all PFLASH HOST banks together but not a subset of it.
 * A command interface can only move those banks to other command interface which belong to the interface executing move command.
 * Security banks cannot be moved
 * \param bankselect Bank selection.
 * 0000 0FFF --> all HOST PFLASH banks selected
 * 0001 0000 --> HOST DFLash bank selected
 * 0001 0FFF --> HOST PFLASH bank and HOST DFLASH selected
 * \return None
 *
 * Usage Example:
 *  \code
 *
 *  uint32 bankSel = 0u;
 *  //All host pflash bank(0x0FFF)
 *  bankSel = 0x0FFF;
 *  IfxFlash_reallocateBank(bankSel);
 *  if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence) || IfxFlash_isErrorDetected(IfxFlash_Error_protection))
 *   {
 *     //Error handling
 *   }
 *   //Reallocation of the memory can be confirmed using MODULE_DMU.GP.BKALLOC.U
 *  \endcode
 *
 */
IFX_INLINE void IfxFlash_reallocateBank(uint32 bankselect);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief The password protection of the selected UCB (if this UCB offers this feature) is temporarily disabled. The command fails by setting PROER when any of the supplied PWs does not match. In this case until the next application reset all further calls of "Disable Protection" fail with PROER independent of the supplied password.
 * \param flash selects the flash (PMU) module
 * \param ucb selects the user configuration block (0 for UCB0, 1 for UCB1, 5 for UCB_HSMC)
 * \param password password pointer to an array of 8 words
 * \return None
 */
IFX_EXTERN void IfxFlash_disableWriteProtection(uint32 flash, IfxFlash_UcbType ucb, uint32 *password);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief This function will wait till all the flash banks are out of busy state
 * \return Return 0 on success.Success means none of the flash banks are in busy state.
 */
IFX_INLINE boolean IfxFlash_waitUnbusyAll(void);

/** \brief Polls the selected status flag in flash status register until it turns to 0
 * \param flash selects the flash (PMU) module
 * \param flashType selects the flash type
 * \return 0 on success, != 0 if invalid or not available page is selected
 *
 * Usage Example:
 * \code
 *
 * // wait until data flash 0 is unbusy
 *  IfxFlash_waitUnbusy(0, IfxFlash_FlashType_D0);
 *
 * \endcode
 *
 */
IFX_INLINE uint8 IfxFlash_waitUnbusy(uint32 flash, IfxFlash_FlashType flashType);

/** \brief Function set the banks or subset of bank to sleep state.
 * The command interface can only set to sleep those banks which are allocated to the command channel.
 * If all banks of both command interfaces are set to sleep then the NVM will enter a deep sleep state.
 * \param bankselect Bansk selection
 * \return None
 *
 * Usage Example:
 *  \code
 *  uint32 bankSel = 0u;
 *  // DFlash selected to go to sleep state
 *  bankSel = (1u << IfxFlashCsrm_FlashType_DHost);
 *  IfxFlash_sleepBank(bankSel);
 *  if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence))
 *   {
 *     //Error handling
 *   }
 *  \endcode
 *
 */
IFX_INLINE void IfxFlash_sleepBank(uint32 bankselect);

/** \brief Function to wakeup the banks or subset of banks.
 * The command interface can only wakeup those banks which are allocated to the command channel.
 * \param bankselect Bank selection
 * \return None
 *
 * Usage Example:
 *  \code
 *  uint32 bankSel = 0u;
 *  //DFlash selected to go to sleep state
 *  bankSel = (1u << IfxFlashCsrm_FlashType_DHost);
 *  IfxFlash_wakeupBank(bankSel);
 *  if(IfxFlash_isErrorDetected(IfxFlash_Error_sequence))
 *   {
 *     //Error handling
 *   }
 *  \endcode
 *
 */
IFX_INLINE void IfxFlash_wakeupBank(uint32 bankselect);

/** \brief Function to get flash bank from address.
 * \param address Address of PFLASH/DFLASH
 * \return Flash Bank to which given address belongs
 */
IFX_INLINE IfxFlash_FlashType IfxFlash_getBankFromAddress(uint32 address);

/** \brief Function to check if bank is allocated to Host command interface or Csrm command interface
 * \param flash Flash bank selection
 * \return Returns
 * IfxFlash_Status_failure - Flash not allocated to host
 * IfxFlash_Status_success - Flash allocated to host
 */
IFX_INLINE IfxFlash_Status IfxFlash_isBankAllocatedToHost(IfxFlash_FlashType flash);

/** \brief Function to check if address provided belongs to bank allocated to Host command interface.
 * \param pageAddr Address of PFLASH/DFLASH
 * \return Return
 * IfxFlash_Status_failure - Invalid address or address belongs to Flash bank which is  not allocated to host
 * IfxFlash_Status_success - Address belongs to Flash bank allocated to host
 */
IFX_INLINE IfxFlash_Status IfxFlash_isAddressBelongToHostBank(uint32 pageAddr);

/** \brief Function to check if host Pflash in page mode
 * \return True --> Host Pflash in page mode
 *  False --> Host Pflash not in page mode
 */
IFX_INLINE boolean IfxFlash_isPflashInPageMode(void);

/** \brief Function to check if host Dflash in page mode
 * \return True --> Host Dflash in page mode
 *  False --> Host Dflash not in page mode
 */
IFX_INLINE boolean IfxFlash_isDflashInPageMode(void);

/** \brief Function to check if requested host command interface error detected
 * \param error Error type
 * \return True --> Requested error was detected
 *  False --> Requested error was not detected
 */
IFX_INLINE boolean IfxFlash_isErrorDetected(IfxFlash_Error error);

/** \brief Function to check if command sequence request received
 * \return True --> Request received
 *  False --> No request received
 */
IFX_INLINE boolean IfxFlash_isRequestReceived(void);

/** \brief Function to check if requested command sequence executed.
 * \return True --> Request execution done
 * False --> No request executed
 */
IFX_INLINE boolean IfxFlash_isRequestExecuted(void);

/** \brief Function to get error's occured during execution of NVM operation.
 * \return Returns error status
 */
IFX_INLINE uint32 IfxFlash_getCommandInterfaceError(void);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxFlash_clearStatus(uint32 flash)
{
    IFX_UNUSED_PARAMETER(flash);
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0x5554);

    *addr1 = 0xFA;

    __dsync();
}


IFX_INLINE uint8 IfxFlash_enterPageMode(uint32 pageAddr)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0x5554);
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(pageAddr) == IfxFlash_Status_success));

    if (((pageAddr >= IFXFLASH_PFLASH_P00_START) && (pageAddr <= IFXFLASH_PFLASH_P51_END)))    // program flash
    {
        *addr1 = 0x50;
        return 0;
    }

    else if (((pageAddr >= IFXFLASH_DFLASH_START) && (pageAddr <= IFXFLASH_DFLASH_END)) || \
             ((pageAddr >= IFXFLASH_UCB0_START) && (pageAddr <= IFXFLASH_UCB0_END))) // data flash
    {
        *addr1 = 0x5D;
        return 0;
    }

    __dsync();

    return 1; // invalid flash address
}


IFX_INLINE void IfxFlash_eraseMultipleSectors(uint32 sectorAddr, uint32 numSector)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(sectorAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = numSector;
    *addr3 = 0x80;
    *addr4 = 0x50;

    __dsync();
}


IFX_INLINE void IfxFlash_eraseSector(uint32 sectorAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(sectorAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = 1;
    *addr3 = 0x80;
    *addr4 = 0x50;

    __dsync();
}


IFX_INLINE void IfxFlash_eraseVerifyMultipleSectors(uint32 sectorAddr, uint32 numSector)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(sectorAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = numSector;
    *addr3 = 0x80;
    *addr4 = 0x5F;

    __dsync();
}


IFX_INLINE void IfxFlash_eraseVerifySector(uint32 sectorAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(sectorAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = 1;
    *addr3 = 0x80;
    *addr4 = 0x5F;

    __dsync();
}


IFX_INLINE void IfxFlash_loadPage(uint32 pageAddr, uint32 wordL, uint32 wordU)
{
    IFX_UNUSED_PARAMETER(pageAddr);
    uint64 *addr1 = (uint64 *)(IFXFLASH_CMD_BASE_ADDRESS | 0x55f0);

    __st64_lu(addr1, wordL, wordU);

    __dsync();
}


IFX_INLINE void IfxFlash_loadPage2X32(uint32 pageAddr, uint32 wordL, uint32 wordU)
{
    IFX_UNUSED_PARAMETER(pageAddr);

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0x55f4);

    *addr1 = wordL;
    *addr1 = wordU;

    __dsync();
}


IFX_INLINE void IfxFlash_resetToRead(uint32 flash)
{
    IFX_UNUSED_PARAMETER(flash);
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0x5554);
    *addr1 = 0xf0;

    __dsync();
}


IFX_INLINE void IfxFlash_resumeProtection(uint32 flash)
{
    IFX_UNUSED_PARAMETER(flash);

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0x5554);

    *addr1 = 0xF5;

    __dsync();
}


IFX_INLINE void IfxFlash_suspendResumeMultipleSectors(uint32 sectorAddr, uint32 numSector)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(sectorAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = numSector;
    *addr3 = 0x70;
    *addr4 = 0xCC;

    __dsync();
}


IFX_INLINE void IfxFlash_suspendResumeSector(uint32 sectorAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(sectorAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = sectorAddr;
    *addr2 = 1;
    *addr3 = 0x70;
    *addr4 = 0xCC;

    __dsync();
}


IFX_INLINE void IfxFlash_userContentCount(uint32 wordAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(wordAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordAddr;
    *addr2 = 0x00;
    *addr3 = 0x60;
    *addr4 = 0x14;

    __dsync();
}


IFX_INLINE void IfxFlash_userMarginCount(uint32 wordAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(wordAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordAddr;
    *addr2 = 0x00;
    *addr3 = 0x60;
    *addr4 = 0x11;

    __dsync();
}


IFX_INLINE void IfxFlash_userVthCount(uint32 wordAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(wordAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordAddr;
    *addr2 = 0x00;
    *addr3 = 0x60;
    *addr4 = 0x12;

    __dsync();
}


IFX_INLINE void IfxFlash_verifyErasedPage(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(pageAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 00;
    *addr3 = 0x80;
    *addr4 = 0x56;

    __dsync();
}


IFX_INLINE void IfxFlash_verifyErasedWordLine(uint32 wordLineAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(wordLineAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = wordLineAddr;
    *addr2 = 00;
    *addr3 = 0x80;
    *addr4 = 0x58;

    __dsync();
}


IFX_INLINE void IfxFlash_writeBurst(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(pageAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xa6;

    __dsync();
}


IFX_INLINE void IfxFlash_writeBurstOnce(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(pageAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xa4;

    __dsync();
}


IFX_INLINE void IfxFlash_writePage(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(pageAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xaa;

    __dsync();
}


IFX_INLINE void IfxFlash_writePageOnce(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(pageAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xa8;

    __dsync();
}


IFX_INLINE boolean IfxFlash_waitUnbusyAll(void)
{
    while (DMU_HCI_STATUS.U & IFXFLASH_MASK_FLASH_BANK_STATUS)
    {}

    __dsync();
    return 0;
}


IFX_INLINE void IfxFlash_replaceLogicalSector(uint32 pageAddr)
{
    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (IfxFlash_isAddressBelongToHostBank(pageAddr) == IfxFlash_Status_success));

    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa50);
    volatile uint32 *addr2 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa58);
    volatile uint32 *addr3 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);
    volatile uint32 *addr4 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaa8);

    *addr1 = pageAddr;
    *addr2 = 0x00;
    *addr3 = 0xa0;
    *addr4 = 0xac;

    __dsync();
}


IFX_INLINE uint8 IfxFlash_countFreeRedundantSector(IfxFlash_FlashType flashType)
{
    uint32           bankSel = (1u << flashType);

    volatile uint32 *addr1   = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaC0);

    *addr1 = bankSel;

    __dsync();

    return (uint8)MODULE_FSI_HOST.COMM0.U;
}


IFX_INLINE void IfxFlash_reallocateBank(uint32 bankselect)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa90);

    *addr1 = bankselect;

    __dsync();
}


IFX_INLINE uint8 IfxFlash_waitUnbusy(uint32 flash, IfxFlash_FlashType flashType)
{
    if (flash == 0)
    {
        while (DMU_HCI_STATUS.U & (1 << flashType))
        {}
    }
    else
    {
        return 1;    /*invalid flash selected */
    }

    __dsync();
    return 0;
}


IFX_INLINE void IfxFlash_sleepBank(uint32 bankselect)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaa00);

    *addr1 = bankselect;

    __dsync();
}


IFX_INLINE void IfxFlash_wakeupBank(uint32 bankselect)
{
    volatile uint32 *addr1 = (volatile uint32 *)(IFXFLASH_CMD_BASE_ADDRESS | 0xaaF0);

    *addr1 = bankselect;

    __dsync();
}


IFX_INLINE IfxFlash_FlashType IfxFlash_getBankFromAddress(uint32 address)
{
    IfxFlash_FlashType flash = IfxFlash_FlashType_Invalid;
    uint8              index = 0U;
    uint32             localPageAddr;
    uint32             size  = 0u;

    if ((address >= IFXFLASH_PFLASH_P00_START) && (address <= IFXFLASH_PFLASH_P51_END)) /* Program Flash */
    {
        localPageAddr = address - IFXFLASH_PFLASH_P00_START;

        for (index = 1U; index <= IFXFLASH_PFLASH_BANKS; index++)
        {
            size += IfxFlash_flashSize[index - 1U];

            if (localPageAddr < size)
            {
                flash = (IfxFlash_FlashType)(index - 1U);
                break;
            }
        }
    }

    else if (((address >= IFXFLASH_DFLASH_START) && (address <= IFXFLASH_DFLASH_END)) || \
             ((address >= IFXFLASH_UCB0_START) && (address <= IFXFLASH_UCB0_END))) // data flash
    {
        flash = IfxFlash_FlashType_DHost;
    }
    else
    {
        flash = IfxFlash_FlashType_Invalid;
    }

    return flash;
}


IFX_INLINE IfxFlash_Status IfxFlash_isBankAllocatedToHost(IfxFlash_FlashType flash)
{
    return (MODULE_DMU.GP.BKALLOC.U & (1U << flash)) ? IfxFlash_Status_failure : IfxFlash_Status_success;
}


IFX_INLINE IfxFlash_Status IfxFlash_isAddressBelongToHostBank(uint32 pageAddr)
{
    IfxFlash_Status    status = IfxFlash_Status_failure;
    IfxFlash_FlashType flash  = IfxFlash_getBankFromAddress(pageAddr);

    if (flash != IfxFlash_FlashType_Invalid)
    {
        status = IfxFlash_isBankAllocatedToHost(flash);
    }

    return status;
}


IFX_INLINE boolean IfxFlash_isPflashInPageMode(void)
{
    return (boolean)MODULE_DMU.HCI.STATUS.B.PFPAGE;
}


IFX_INLINE boolean IfxFlash_isDflashInPageMode(void)
{
    return (boolean)MODULE_DMU.HCI.STATUS.B.DFPAGE;
}


IFX_INLINE boolean IfxFlash_isErrorDetected(IfxFlash_Error error)
{
    boolean errStatus = FALSE;

    if (((MODULE_DMU.HCI.ERR.U >> error) & 0x1) != 0u)
    {
        errStatus = TRUE;
    }

    return errStatus;
}


IFX_INLINE boolean IfxFlash_isRequestReceived(void)
{
    return (boolean)MODULE_DMU.HCI.STATUS.B.REQACK;
}


IFX_INLINE boolean IfxFlash_isRequestExecuted(void)
{
    return (boolean)MODULE_DMU.HCI.STATUS.B.REQDONE;
}


IFX_INLINE uint32 IfxFlash_getCommandInterfaceError(void)
{
    return MODULE_DMU.HCI.ERR.U;
}


#endif /* IFXFLAS_H */
