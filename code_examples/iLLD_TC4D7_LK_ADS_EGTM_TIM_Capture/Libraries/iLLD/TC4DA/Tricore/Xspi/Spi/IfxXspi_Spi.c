/**
 * \file IfxXspi_Spi.c
 * \brief XSPI SPI details
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2025 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxXspi_Spi.h"

/** \addtogroup IfxLld_Xspi_Spi_CommunicationFunctions
 * \{ */

/******************************************************************************/
/*-----------------------Private Function Prototypes--------------------------*/
/******************************************************************************/

/** \brief Write data up to 8 bits
 * \param xspi pointer to XSPI registers
 * \param txData data pointer to transmit data
 * \param txCount pointer to transmit count
 * \return None
 */
IFX_STATIC void IfxXspi_Spi_write8(Ifx_XSPI *xspi, uint8 *txData, uint32 *txCount);

/** \brief Write data up to 16 bits
 * \param xspi pointer to XSPI registers
 * \param txData data pointer to transmit data
 * \param txCount pointer to transmit count
 * \return None
 */
IFX_STATIC void IfxXspi_Spi_write16(Ifx_XSPI *xspi, uint16 *txData, uint32 *txCount);

/** \brief Write data up to 32 bits
 * \param xspi pointer to XSPI registers
 * \param txData data pointer to transmit data
 * \param txCount pointer to transmit count
 * \return None
 */
IFX_STATIC void IfxXspi_Spi_write32(Ifx_XSPI *xspi, uint32 *txData, uint32 *txCount);

/** \} */

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

IfxXspi_Status IfxXspi_Spi_initModule(IfxXspi_Spi *xspi, const IfxXspi_Spi_Config *config)
{
    Ifx_XSPI      *xspiSFR = config->xspi;                      /* pointer to XSPI Registers*/
    IfxXspi_Status status  = IfxXspi_Status_noError;

    xspi->xspi = xspiSFR;                                       /* adding register pointer to module handler*/

#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&xspiSFR->PROTE, IfxApProt_State_config);
#endif
    xspiSFR->CLC.B.DISR = 0;
#if (IFX_PROT_ENABLED == 1U)
    IfxApProt_setState((Ifx_PROT_PROT *)&xspiSFR->PROTE, IfxApProt_State_run);
#endif

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI*/

    /* Configuring Control Register 0 */
    {
        Ifx_XSPI_CTRLR0 ctrlr0;
        ctrlr0.U                 = xspiSFR->CTRLR0.U;

        ctrlr0.B.FRF             = 0;                                   /* Selects which serial protocol transfers the data 0:spi */
        //ctrlr0.B.CFS              = config->control.controlFrameSize;		/* Control Frame Size*/
        ctrlr0.B.SPI_FRF         = config->control.spiFrameFormat;      /* Frame Format for Transmission */
        ctrlr0.B.TMOD            = config->control.transferMode;        /* TMOD (Selects the mode of transfer for serial communication)*/
        ctrlr0.B.SPI_HYPERBUS_EN = config->control.hyperbusEnable;      /* Hyperbus*/
        ctrlr0.B.DFS             = config->control.dataFrameSize;       /* Data Frame Size*/
        ctrlr0.B.SRL             = config->control.loopBack;            /* Shift Register Loop (LoopBack)*/
        ctrlr0.B.SSTE            = config->control.slaveSelectToggle;   /* Slave Select Toggle*/
        ctrlr0.B.SCPOL           = config->control.clockPolarity;       /* ClockPolarity*/
        ctrlr0.B.SCPH            = config->control.clockPhase;          /* ClockPhase*/
        ctrlr0.B.CLK_LOOP_EN     = config->control.clockLoopBack;       /* Clock Loop back */
        xspiSFR->CTRLR0.U        = ctrlr0.U;
    }
    xspiSFR->CTRLR1.B.NDF = config->control.numberOfDataFrames;

    /* Configuring SPI_CTRLR0 - SPI Control Register */
    {
        Ifx_XSPI_SPI_CTRLR0 spi_ctrlr0;
        spi_ctrlr0.U                  = xspiSFR->SPI_CTRLR0.U;

        spi_ctrlr0.B.CLK_STRETCH_EN   = config->enhancedControl.clockStretchEnable;         /* Clock Stretching */
        spi_ctrlr0.B.SPI_RXDS_EN      = config->enhancedControl.spiRxdsEnable;              /* rxds signaling during address and command phase of Hypebus transfer */
        spi_ctrlr0.B.SPI_DM_EN        = config->enhancedControl.spiDataMaskEnable;          /* SPI data mask enable */
        spi_ctrlr0.B.SPI_RXDS_EN      = config->enhancedControl.spiRxdsEnable;              /* Read data strobe enable */
        spi_ctrlr0.B.INST_DDR_EN      = config->enhancedControl.instDdrEnable;              /* Instruction DDR Enable(enable Dual-data rate transfer for Instruction phase) */
        spi_ctrlr0.B.SPI_DDR_EN       = config->enhancedControl.spiDdrEnable;               /* SPI DDR Enable(enable Dual-data rate transfers) */
        spi_ctrlr0.B.WAIT_CYCLES      = config->enhancedControl.waitCycles;                 /* Wait cycles in Dual/Quad/Octal mode */
        spi_ctrlr0.B.INST_L           = config->enhancedControl.instLength;                 /* Length of Instruction */
        spi_ctrlr0.B.ADDR_L           = config->enhancedControl.addressLength;              /* Length of Address */
        spi_ctrlr0.B.TRANS_TYPE       = config->enhancedControl.transferFormat;             /* Address and instruction transfer format */

        xspiSFR->SPI_CTRLR0.U         = spi_ctrlr0.U;

        xspiSFR->DDR_DRIVE_EDGE.B.TDE = config->enhancedControl.ddrTxDriveEdge;     /* DDR Transmit Drive Edge */
    }

    {
        // Fsclk_out =	Fssi_clk/SCKDVwhere SCKDV is any even value between 2 and 65534
        xspiSFR->BAUDR.B.SCKDV = (IfxClock_getXspiFrequency() / config->timing.baudrate);   /* Configuring Baud Rate Select */

        /* Configuring RX Sample Delay Register */
        //xspiSFR->RX_SAMPLE_DELAY.U.RSD    = config.baudrate.rxDataSampleDelay;	/* Receive Data (rxd) Sample Delay */
        //xspiSFR->RX_SAMPLE_DELAY.B.SE     = config.baudrate.rxeDataSamplingEdge;	/* Receive Data (rxd) Sampling Edge */
    }

    {
        /* Configuring Transmit FIFO Threshold Level */
        xspiSFR->TXFTLR.B.TXFTHR = config->fifoControl.transferStartFifoLevel;      /* Transfer start FIFO level */
        xspiSFR->TXFTLR.B.TFT    = config->fifoControl.txFifoThreshold;             /* Transmit Fifo Bus Threshold */

        /* Configuring Receive FIFO Threshold Level */
        xspiSFR->RXFTLR.B.RFT = config->fifoControl.rxFifoThreshold;
    }

    {
        /* Configuring Interrupt Mask Register */
        Ifx_XSPI_IMR imr;
        imr.U          = xspiSFR->IMR.U;

        imr.B.DONEM    = config->interruptConfig.interruptMask.doneInterruptMask;                   /**<\Done Interrupt Mask*/
        imr.B.TXUIM    = config->interruptConfig.interruptMask.txFifoUnderFlowInterruptMask;        /**<\Transmit FIFO Underflow Interrupt Mask*/
        imr.B.RXFIM    = config->interruptConfig.interruptMask.rxFifoFullInterruptMask;             /**<\Receive FIFO Full Interrupt Mask*/
        imr.B.RXOIM    = config->interruptConfig.interruptMask.rxFifoOverFlowInterruptMask;         /**<\Receive FIFO Overflow Interrupt Mask*/
        imr.B.RXUIM    = config->interruptConfig.interruptMask.rxFifoUnderFlowInterruptMask;        /**<\Receive FIFO Underflow Interrupt Mask*/
        imr.B.TXOIM    = config->interruptConfig.interruptMask.txFifoOverFlowInterruptMask;         /**<\Transmit FIFO Overflow Interrupt Mask*/
        imr.B.TXEIM    = config->interruptConfig.interruptMask.txFifoEmptyInterruptMask;            /**<\Transmit FIFO Empty Interrupt Mask*/

        xspiSFR->IMR.U = imr.U;
    }

    {
        /* Configuring DMA */

        Ifx_XSPI_DMACR dmacr;
        dmacr.U          = xspiSFR->DMACR.U;

        dmacr.B.IDMAE    = config->dmaConfig->internalDmaEnable;    /**<\ DMA Enable*/
        dmacr.B.AINC     = config->dmaConfig->addressIncrement;     /**<\ Address Increment (increment the AXI address on every transfer)*/
        dmacr.B.TDMAE    = config->dmaConfig->txFifoDmaEnable;      /**<\ Transmit Fifo DMA Enable*/
        dmacr.B.RDMAE    = config->dmaConfig->rxFifoDmaEnable;      /**<\ Receive Fifo DMA Enable*/
        dmacr.B.ATW      = config->dmaConfig->transferwidth;        /**<\ AXI transfer width for DMA transfers*/
        dmacr.B.ACACHE   = 0;
        dmacr.B.APROT    = 0;
        dmacr.B.AID      = 0;

        xspiSFR->DMACR.U = dmacr.U;

        /* Configuring Source and Destination Burst Length */
        xspiSFR->AXIAWLEN.B.AWLEN = config->dmaConfig->destinationBurstLength;
        xspiSFR->AXIARLEN.B.ARLEN = config->dmaConfig->sourceBurstLength;
    }

    /* initialising the interrupts */
    if ((config->interruptConfig.fifoPriority != 0) || (config->interruptConfig.fifoIntTypeOfService == IfxSrc_Tos_dma0) || (config->interruptConfig.fifoIntTypeOfService == IfxSrc_Tos_dma1))
    {
        volatile Ifx_SRC_SRCR *src = (volatile Ifx_SRC_SRCR *)IfxXspi_getSrcPointerFifo(xspiSFR);
        IfxSrc_init(src, config->interruptConfig.fifoIntTypeOfService, config->interruptConfig.fifoPriority, config->interruptConfig.vmId);
        IfxSrc_enable(src);
    }

    if ((config->interruptConfig.errorPriority != 0))
    {
        volatile Ifx_SRC_SRCR *src = IfxXspi_getSrcPointerError(xspiSFR);
        IfxSrc_init(src, config->interruptConfig.errorIntTypeOfService, config->interruptConfig.errorPriority, config->interruptConfig.vmId);
        IfxSrc_enable(src);
    }

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;        /* Enable DWC_SSI*/
    return status;
}


void IfxXspi_Spi_initModuleConfig(IfxXspi_Spi_Config *config, Ifx_XSPI *xspi)
{
    IfxXspi_Spi_DmaConfig    dmaDefaultConfig = {
        .txFifoDmaEnable        = 0,
        .rxFifoDmaEnable        = 0,
        .internalDmaEnable      = 0,
        .addressIncrement       = 0,
        .destinationBurstLength = 0,
        .sourceBurstLength      = 0,
        .dmaTxDataLevel         = 0,
        .dmaRxDataLevel         = 0,
        .transferwidth          = IfxXspi_TransferWidth_1,
    };
    const IfxXspi_Spi_Config defaultConfig = {
        .xspi    = NULL_PTR,

        .control = {
//					.frameFormat        = 0,										/*Selects which serial protocol transfers the data*/
            .spiFrameFormat     = IfxXspi_SpiFrameFormat_Std,                       /*Frame Format for Transmission */
            .transferMode       = IfxXspi_TransferMode_TxRx,                        /*TMOD (Selects the mode of transfer for serial communication)*/
            .dataFrameSize      = IfxXspi_DataframeSize_32,                         /*Data Frame Size*/
            .controlFrameSize   = 1,                                                /*Control Frame Size*/
            .numberOfDataFrames = 2,                                                /*Number of Data Frames*/
            .loopBack           = IfxXspi_ShiftRegisterLoop_NormalMode,             /*Shift Register Loop (LoopBack)*/
            .slaveSelectToggle  = IfxXspi_SlaveSelectToggle_Disable,                /*Slave Select Toggle*/
            .clockPolarity      = IfxXspi_ClockPolarity_InactiveHigh,               /*ClockPolarity*/
            .clockPhase         = IfxXspi_ClockPhase_StartBit,                      /*ClockPhase*/
            .hyperbusEnable     = IfxXspi_Hyperbus_Disable,                         /*Hyperbus*/
            .clockLoopBack      = IfxXspi_ClockLoopBack_Disable
        },

        .timing                                           = {
            .baudrate           = 100000.0f,                /*value of the required baudrate*/
            .rxDataSampleDelay  = 0,                        /*Receive Data (rxd) Sample Delay*/
            .rxDataSamplingEdge = 0                         /*Receive Data (rxd) Sampling Edge*/
        },

        .fifoControl                                      = {
            .transferStartFifoLevel = 1,                    /*Transmit start Fifo Level*/
            .txFifoThreshold        = 1,                    /*Transmit Fifo Bus Threshold*/
            .rxFifoThreshold        = 1,                    /*Receive Fifo Bus Threshold*/
        },

        .interruptConfig                                  = {
            .fifoPriority                                 = 0,               /*xSPI FIFO  Service Request 0*/
            .errorPriority                                = 0,               /*xSPI Interface Error Service Request*/
            .vmId                                         = IfxSrc_VmId_0,   /* vmId index */
            .fifoIntTypeOfService                         = IfxSrc_Tos_cpu0, /* Fifo type of interrupt service */
            .errorIntTypeOfService                        = IfxSrc_Tos_cpu0, /* Error type of interrupt service */
            .interruptMask.doneInterruptMask              = IfxXspi_InterruptMask_UnMask,
            .interruptMask.errorInterruptMask             = IfxXspi_InterruptMask_UnMask,
            .interruptMask.txFifoUnderFlowInterruptMask   = IfxXspi_InterruptMask_UnMask,
            .interruptMask.xipRxFifoOverFlowInterruptMask = IfxXspi_InterruptMask_UnMask,
            .interruptMask.multiMasterInterruptMask       = IfxXspi_InterruptMask_UnMask,
            .interruptMask.rxFifoFullInterruptMask        = IfxXspi_InterruptMask_UnMask,
            .interruptMask.rxFifoOverFlowInterruptMask    = IfxXspi_InterruptMask_UnMask,
            .interruptMask.rxFifoUnderFlowInterruptMask   = IfxXspi_InterruptMask_UnMask,
            .interruptMask.txFifoOverFlowInterruptMask    = IfxXspi_InterruptMask_UnMask,
            .interruptMask.txFifoEmptyInterruptMask       = IfxXspi_InterruptMask_UnMask,
        },

        .dmaConfig       = &dmaDefaultConfig,

        .enhancedControl = {
            .clockStretchEnable  = 1,                                           /*No Clock Stretch Enable */
            .spiRxdsSignalEnable = 0,                                           /*No rxds signaling during address and command phase of Hypebus transfer*/
            .spiDataMaskEnable   = 0,                                           /*No data mask enable bit*/
            .spiRxdsEnable       = 0,                                           /*No Read data strobe bit enable*/
            .instDdrEnable       = 0,                                           /*No Instruction DDR bit Enable*/
            .spiDdrEnable        = 0,                                           /*No SPI DDR Enable*/
            .waitCycles          = 0,                                           /*Wait cycles in Dual/Quad/Octal mode*/
            .ddrTxDriveEdge      = 0,                                           /*DDR Transmit Drive Edge*/
            .instLength          = IfxXspi_InstructionLength_L4,                /*Length of Instruction*/
            .addressLength       = IfxXspi_AddressLength_L4,                    /*Length of Address*/
            .transferFormat      = IfxXspi_TransferFormat_TT0,                  /*Address and instruction transfer format*/
        }
    };

    *config      = defaultConfig; /*Default Config*/
    config->xspi = xspi;          /*Module Pointer*/
}


IfxXspi_Spi_Status IfxXspi_Spi_dmaExchange(IfxXspi_Spi *xspi, IfxXspi_Spi_DmaJobConfig *dmaJob)
{
    IfxXspi_Spi_Status status = {0};

    IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, xspi->xspi->CTRLR0.B.SPI_FRF != IfxXspi_SpiFrameFormat_Std);

    if (xspi->transferInProgress == 0)
    {
        xspi->transferInProgress        = 1;                        /* setting transfer in progress status */

        xspi->xspi->SSIENR.B.SSIC_EN    = IfxXspi_Dwc_Mode_Disable; /* Enable DWC_SSI*/
        xspi->xspi->CTRLR0.B.TMOD       = dmaJob->transferMode;

        xspi->xspi->DMACR.B.IDMAE       = IfxXspi_Dwc_Mode_Enable;
        xspi->xspi->SPI_CTRLR0.B.INST_L = dmaJob->instLength;

        switch (dmaJob->transferMode)
        {
        case IfxXspi_TransferMode_TxRx:
            // DMA transfer not applicable for TX_AND_RX mode.
            break;

        case IfxXspi_TransferMode_Rx:
        case IfxXspi_TransferMode_EepromRead:

            // for Rx only , should we send a dummy byte i.e write dummy byte to DR?
            xspi->xspi->CTRLR1.B.NDF             = dmaJob->numberOfDataFrames;
            xspi->xspi->DMACR.B.AINC             = dmaJob->addressIncrement;
            xspi->xspi->AXIAR0.U                 = (uint32)dmaJob->data;
            xspi->xspi->SPIAR.B.SDAR             = dmaJob->spiDeviceAddress;
            xspi->xspi->SPIDR.B.SPI_INST         = dmaJob->SpiInstruction;
            xspi->xspi->SPI_CTRLR0.B.WAIT_CYCLES = dmaJob->waitCycles;
            xspi->xspi->SPI_CTRLR0.B.ADDR_L      = dmaJob->addressLength;
#if IFXXSPI_INTERRUPT_CFG
            // configure intr masks
            xspi->xspi->IMR.B.RXFIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXUIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXOIM = IfxXspi_InterruptMask_Mask;

            xspi->xspi->IMR.B.TXOIM = 0;
            xspi->xspi->IMR.B.TXEIM = 0;
            xspi->xspi->IMR.B.TXUIM = 0;
#endif
            break;

        case IfxXspi_TransferMode_Tx:
            xspi->xspi->CTRLR1.B.NDF             = dmaJob->numberOfDataFrames;
            xspi->xspi->DMACR.B.AINC             = dmaJob->addressIncrement;
            xspi->xspi->AXIAR0.U                 = (uint32)dmaJob->data;
            xspi->xspi->SPIAR.B.SDAR             = dmaJob->spiDeviceAddress;
            xspi->xspi->SPIDR.B.SPI_INST         = dmaJob->SpiInstruction;
            xspi->xspi->SPI_CTRLR0.B.WAIT_CYCLES = dmaJob->waitCycles;
            xspi->xspi->SPI_CTRLR0.B.ADDR_L      = dmaJob->addressLength;
#if IFXXSPI_INTERRUPT_CFG
            /* Configure interrupts */
            xspi->xspi->IMR.B.TXOIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXFIM = 0;
            xspi->xspi->IMR.B.RXUIM = 0;
            xspi->xspi->IMR.B.RXOIM = 0;
#endif
            break;
        }

        xspi->xspi->SER.B.SER        = dmaJob->slaveSelectEnable; //slave select
        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;   /* Enable DWC_SSI*/
    }

    return status;
}


void IfxXspi_Spi_fillTxBuffer(IfxXspi_Spi *xspi)
{
    Ifx_XSPI        *xspiSFR     = xspi->xspi;
    IfxXspi_Spi_Job *job         = &xspi->job;
    uint32           i;
    uint32           prev_count  = 0;
    uint32           prev_count1 = 0;
    uint32           count;

    if (job->txpending)
    {
        if (job->txdata != NULL_PTR)
        {
            while ((job->txpending != 0) || ((xspiSFR->CTRLR0.B.TMOD == IfxXspi_TransferMode_TxRx) && (job->rxpending != 0)))
            {
                /* transmit section */
                if ((xspiSFR->SR.B.TFNF == 1) && (job->txpending != 0))
                {
                    count          = (uint32)(16 - xspiSFR->TXFLR.B.TXTFL);
                    count          = __min(job->txpending, count);
                    job->txpending = job->txpending - count;

                    if (xspiSFR->CTRLR0.B.DFS <= 8)
                    {
                        IfxXspi_write8(xspiSFR, &(((uint8 *)job->txdata)[prev_count]), count);
                    }
                    else if (xspiSFR->CTRLR0.B.DFS <= 16)
                    {
                        IfxXspi_write16(xspiSFR, &(((uint16 *)job->txdata)[prev_count]), count);               /* 16 bit DataframeSize per transfer*/
                    }
                    else
                    {
                        IfxXspi_write32(xspiSFR, &(((uint32 *)job->txdata)[prev_count]), count);               /* 32 bit DataframeSize per transfer*/
                    }

                    prev_count = prev_count + count;
                }

                /* receive section */
                if ((xspiSFR->CTRLR0.B.TMOD == IfxXspi_TransferMode_TxRx) && (job->rxpending != 0))
                {
                    if (xspiSFR->SR.B.RFNE == 1)
                    {
                        uint32 count1 = (uint32)(xspiSFR->RXFLR.B.RXTFL); /* get the readable count of Rx fifo */
                        count1         = __min(job->rxpending, count1);
                        job->rxpending = job->rxpending - count1;
                        uint8 *rx = (uint8 *)(xspi->job.rxdata);

                        while (count1 != 0)
                        {
                            rx[prev_count1] = (uint8)(xspiSFR->DR[0].U & 0xFF);
                            count1--;
                            prev_count1++;
                        }
                    }
                }
            }
        }
        else
        {
            count = job->txpending;

            for (i = 0; i < count; i++)
            {
                xspiSFR->DR[0].U = (~0);
            }
        }

        while ((xspiSFR->SR.B.TFE == 0) || (xspiSFR->SR.B.BUSY == 1))
        {}

        if (xspiSFR->CTRLR0.B.TMOD == IfxXspi_TransferMode_TxRx)
        {
            xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI for Tx only */
        }

        if ((xspi->xspi->CTRLR0.B.TMOD == IfxXspi_TransferMode_Tx) && (job->txpending == 0))
        {
            xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI for Tx only */
        }
    }
}


boolean IfxXspi_Spi_exchange(IfxXspi_Spi *xspi, IfxXspi_Spi_CpuJobConfig *jobConfig)
{
    boolean status = 0;

    if (xspi->transferInProgress == 0)
    {
        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable; /* Disable DWC_SSI*/

        xspi->transferInProgress     = 1;                        /* setting transfer in progress status */
        xspi->job.txdata             = jobConfig->txdata;        /* data to be transmitted */
        xspi->job.txpending          = jobConfig->txcount;       /* count of Tx data */
        xspi->job.rxdata             = jobConfig->rxdata;        /* empty buffer to receive data */
        xspi->job.rxpending          = jobConfig->rxcount;       /* count of Rx data */
        xspi->xspi->CTRLR0.B.TMOD    = jobConfig->transferMode;

        // clear intr on completion A read from this register clears the ssi_txo_intr/ssi_txu_intr interrupt
        {
            status  = xspi->xspi->TXEICR.B.TXEICR; //Clear Transmit FIFO Overflow/Underflow Interrupt.
            status |= xspi->xspi->RXOICR.B.RXOICR;
            status |= xspi->xspi->RXUICR.B.RXUICR;
            status |= xspi->xspi->AXIECR.B.AXIECR; //AXI Master Error Interrupt Clear Register
            status |= xspi->xspi->DONECR.B.DONECR; //Transfer Done Clear Interrupt Clear Register
        }

        switch (jobConfig->transferMode)
        {
        case IfxXspi_TransferMode_TxRx:
            xspi->xspi->IMR.B.RXFIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXUIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXOIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXOIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->CTRLR1.B.NDF = jobConfig->txcount;      //  here both tx and rx count are equal
            xspi->job.rxpending      = xspi->job.txpending;

            break;

        case IfxXspi_TransferMode_Rx:
            xspi->xspi->IMR.B.RXFIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXUIM  = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.RXOIM  = IfxXspi_InterruptMask_Mask;

            xspi->xspi->IMR.B.TXOIM  = 0;
            xspi->xspi->IMR.B.TXEIM  = 0;
            xspi->xspi->IMR.B.TXUIM  = 0;

            xspi->xspi->CTRLR1.B.NDF = jobConfig->rxcount;

            break;

        case IfxXspi_TransferMode_Tx:
            xspi->xspi->IMR.B.TXOIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM = IfxXspi_InterruptMask_Mask;

            xspi->xspi->IMR.B.RXFIM = 0;
            xspi->xspi->IMR.B.RXUIM = 0;
            xspi->xspi->IMR.B.RXOIM = 0;
            break;

        case IfxXspi_TransferMode_EepromRead:
            //send op code and address (as tx data) + dummy bytes to be added to tx buffer.. TBD
            // First Tx opcode, address and dummy bytes. so enable corresponding intr
            xspi->xspi->IMR.B.TXOIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXEIM = IfxXspi_InterruptMask_Mask;
            xspi->xspi->IMR.B.TXUIM = IfxXspi_InterruptMask_Mask;

#ifdef FOR_XSPI_SILICON
            xspi->xspi->CTRLR1.B.NDF             = jobConfig->rxcount - 1;
            xspi->xspi->SPI_CTRLR0.B.SPI_RXDS_EN = 0;
#else
            xspi->xspi->CTRLR1.B.NDF             = jobConfig->rxcount;
            xspi->xspi->SPI_CTRLR0.B.SPI_RXDS_EN = 1;
#endif

            break;
        }

        /* Enhanced SPI config */
        if (xspi->xspi->CTRLR0.B.SPI_FRF != IfxXspi_SpiFrameFormat_Std)
        {
            xspi->xspi->SPI_CTRLR0.B.WAIT_CYCLES = jobConfig->waitCycles;
            xspi->xspi->SPI_CTRLR0.B.ADDR_L      = jobConfig->addressLength;
            xspi->xspi->SPI_CTRLR0.B.INST_L      = jobConfig->instructionLength;
        }

        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable; /* Enable DWC_SSI*/
        xspi->xspi->SER.B.SER        = jobConfig->slaveSelectEnable;

        if (jobConfig->transferMode != IfxXspi_TransferMode_Rx)
        {
            IfxXspi_Spi_fillTxBuffer(xspi);
        }
        else
        {
            xspi->xspi->DR[0].U = 0xFFFFFFFFU;
        }
    }
    else
    {
        status = 1;
    }

    return status;
}


void IfxXspi_Spi_read(IfxXspi_Spi *xspi)
{
    Ifx_XSPI        *xspiSFR    = xspi->xspi;                               /* getting the pointer to XSPI registers from module handler */
    IfxXspi_Spi_Job *job        = &xspi->job;                               /* getting the rxJob structure from module handler */
    uint32           prev_count = 0;

    while ((job->rxpending > 0) && (job->rxdata != NULL_PTR))
    {
        if (xspiSFR->SR.B.RFNE == 1)
        {
            uint32 count = (uint32)(xspiSFR->RXFLR.B.RXTFL); /* get the readable count of Rx fifo */
            count          = __min(job->rxpending, count);   /* check for the end of the data */

            job->rxpending = job->rxpending - count;         /* discount the current reading count from job pending */

            /* read data up to the count based on the out width */
            if (xspiSFR->CTRLR0.B.DFS <= 8)
            {
                IfxXspi_read8(xspiSFR, job->rxdata, count);                  /* reading from Rx FIFO */
                job->rxdata = &(((uint8 *)job->rxdata)[prev_count + count]); /* pointing to the remaining data */
            }
            else if (xspiSFR->CTRLR0.B.DFS <= 16)
            {
                IfxXspi_read16(xspiSFR, job->rxdata, count);                  /* reading from Rx FIFO */
                job->rxdata = &(((uint16 *)job->rxdata)[prev_count + count]); /* pointing to the remaining data */
            }
            else
            {
                IfxXspi_read32(xspiSFR, job->rxdata, count);    /* 32 bit DataframeSize per transfer*/
                job->rxdata = &(((uint32 *)job->rxdata)[prev_count + count]);
            }

            prev_count = prev_count + count;
        }
    }

    if (job->rxpending == 0)
    {
        xspi->transferInProgress  = 0;                              /* clearing the transfer in progress status */
        xspi->xspi->SER.B.SER     = IfxXspi_SlaveSelectEnable_none; // disable Slave select
        xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* disable DWC_SSI*/
    }
}


uint32 IfxXspi_Spi_isrReceive(IfxXspi_Spi *xspi)
{
    volatile uint32 status;
    IfxXspi_Spi_read(xspi);

    // clear intr on completion A read from this register clears the ssi_txo_intr/ssi_txu_intr interrupt
    status  = xspi->xspi->TXEICR.B.TXEICR; //Clear Transmit FIFO Overflow/Underflow Interrupt.
    status |= xspi->xspi->RXOICR.B.RXOICR;
    status |= xspi->xspi->RXUICR.B.RXUICR;
    status |= xspi->xspi->AXIECR.B.AXIECR; //AXI Master Error Interrupt Clear Register
    status |= xspi->xspi->DONECR.B.DONECR; //Transfer Done Clear Interrupt Clear Register

    return status;
}


void IfxXspi_Spi_getRawInterruptStatus(IfxXspi_Spi *xspi, IfxXspi_Spi_RawInterruptStatus *rawInterruptStatus)
{
    rawInterruptStatus->errorInterruptRawStatus             = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.AXIES;
    rawInterruptStatus->doneInterruptRawStatus              = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.DONES;
    rawInterruptStatus->txFifoUnderFlowInterruptRawStatus   = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.TXUIS;
    rawInterruptStatus->xipRxFifoOverFlowInterruptRawStatus = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.XRXOIS;
    rawInterruptStatus->rxFifoFullInterruptRawStatus        = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.RXFIS;
    rawInterruptStatus->rxFifoOverFlowInterruptRawStatus    = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.RXOIS;
    rawInterruptStatus->rxFifoUnderFlowInterruptRawStatus   = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.RXUIS;
    rawInterruptStatus->txFifoOverFlowInterruptRawStatus    = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.TXOIS;
    rawInterruptStatus->txFifoEmptyInterruptRawStatus       = (IfxXspi_InterruptStatus)xspi->xspi->ISR.B.TXEIS;
}


void IfxXspi_Spi_isrTransmit(IfxXspi_Spi *xspi)
{
    //transmit FIFO empty interrupt request
    IfxXspi_Spi_fillTxBuffer(xspi);

    if (xspi->xspi->CTRLR0.B.TMOD == IfxXspi_TransferMode_EepromRead)
    {
        // receive intr are enabled, afer transmit of opcode, address and dummy bytes.
        xspi->xspi->IMR.B.RXFIM = IfxXspi_InterruptMask_Mask;
        xspi->xspi->IMR.B.RXUIM = IfxXspi_InterruptMask_Mask;
        xspi->xspi->IMR.B.RXOIM = IfxXspi_InterruptMask_Mask;
    }

    // clear intr on completion on Txonly FIXME tbd
}


uint32 IfxXspi_Spi_isrDmaReceive(IfxXspi_Spi *xspi)
{
    volatile uint32 status = 0;
    xspi->transferInProgress     = 0;                              /* clearing the transfer in progress status */
    xspi->xspi->SER.B.SER        = IfxXspi_SlaveSelectEnable_none; // disable Slave select
    xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* disable DWC_SSI*/

    // clear intr on completion A read from this register clears the ssi_txo_intr/ssi_txu_intr interrupt
    status  = xspi->xspi->TXEICR.B.TXEICR;                         //Clear Transmit FIFO Overflow/Underflow Interrupt.
    status |= xspi->xspi->RXOICR.B.RXOICR;
    status |= xspi->xspi->RXUICR.B.RXUICR;
    status |= xspi->xspi->AXIECR.B.AXIECR;                         //AXI Master Error Interrupt Clear Register
    status |= xspi->xspi->DONECR.B.DONECR;                         //Transfer Done Clear Interrupt Clear Register

    return status;
}


void IfxXspi_Spi_isrDmaTransmit(IfxXspi_Spi *xspi)
{
    /* TX only and job complete, disable SSIC  */
    if (xspi->xspi->CTRLR0.B.TMOD == IfxXspi_TransferMode_Tx)
    {
        xspi->xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;        /* Disable DWC_SSI for Tx only */
    }

    // clear intr on completion FIXME tbd
}


IfxXspi_BusStatus IfxXspi_Spi_getstatus(IfxXspi_Spi *xspi)
{
    IfxXspi_BusStatus status;

    if ((xspi->transferInProgress != 0) && (xspi->xspi->SR.B.BUSY != 0))
    {
        status = IfxXspi_BusStatus_busy;
    }
    else if ((xspi->xspi->SR.B.TXE == 1) || (xspi->xspi->SR.B.DCOL == 1))
    {
        status = IfxXspi_BusStatus_error;
    }
    else
    {
        status = IfxXspi_BusStatus_idle;
    }

    return status;
}


boolean IfxXspi_Spi_triggerXipTransfer(IfxXspi_Spi *xspi, IfxXspi_Spi_XipConfig *config)
{
    Ifx_XSPI       *xspiSFR = xspi->xspi;

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI*/
    Ifx_XSPI_CTRLR0 ctrlr0;
    ctrlr0.U                  = xspiSFR->CTRLR0.U;

    ctrlr0.B.DFS              = config->dataFrameSize;

    xspiSFR->CTRLR0.U         = ctrlr0.U;

    Ifx_XSPI_SPI_CTRLR0 spi_ctrlr0;
    spi_ctrlr0.U                 = xspiSFR->SPI_CTRLR0.U;
    spi_ctrlr0.B.INST_L          = config->instLength;
    spi_ctrlr0.B.XIP_INST_EN     = config->instructionPhaseEnable;

    spi_ctrlr0.B.XIP_PREFETCH_EN = config->xipPreFetchInstEnable;

    if (config->xipModeBitEnable == TRUE)
    {
        spi_ctrlr0.B.XIP_MD_BIT_EN = config->xipModeBitEnable;
        spi_ctrlr0.B.XIP_MBL       = config->xipModeBitLen;

        Ifx_XSPI_XIP_MODE_BITS xipModeBitReg;
        xipModeBitReg.U             = 0;
        xipModeBitReg.B.XIP_MD_BITS = config->xipModeBitsValue;
        xspiSFR->XIP.MODE_BITS.U    = xipModeBitReg.U;
    }

    xspiSFR->SPI_CTRLR0.U = spi_ctrlr0.U;

    Ifx_XSPI_XIP_WRAP_INST xip_wrap_inst;
    xip_wrap_inst.U           = xspiSFR->XIP.WRAP_INST.U;
    xip_wrap_inst.B.WRAP_INST = config->wrapInstruction;
    xspiSFR->XIP.WRAP_INST.U  = xip_wrap_inst.U;

    Ifx_XSPI_XIP_INCR_INST xip_incr_inst;
    xip_incr_inst.U           = xspiSFR->XIP.INCR_INST.U;
    xip_incr_inst.B.INCR_INST = config->wrapInstruction;
    xspiSFR->XIP.INCR_INST.U  = xip_incr_inst.U;

    if (config->contTransfer == IfxXspi_XipContTransfer_Enable)
    {
        Ifx_XSPI_XIP_CNT_TIME_OUT xip_cnt_time_out;
        xip_cnt_time_out.U                          = xspiSFR->XIP.CNT_TIME_OUT.U;
        xip_cnt_time_out.B.XTOC                     = config->counterTimeOut;
        xspiSFR->XIP.CNT_TIME_OUT.U                 = xip_cnt_time_out.U;

        xspiSFR->SPI_CTRLR0.B.XIP_DFS_HC            = config->xipFixDfs;
        xspiSFR->SPI_CTRLR0.B.SSIC_XIP_CONT_XFER_EN = IfxXspi_XipContTransfer_Enable;
    }

    Ifx_XSPI_SER ser;
    ser.U                     = xspiSFR->SER.U;
    ser.B.SER                 = config->slaveSelectEnable;
    xspiSFR->SER.U            = ser.U;

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;       /* Enable DWC_SSI*/
    return 0;
}


void IfxXspi_Spi_transferInit(Ifx_XSPI *xspi, IfxXspi_Spi_initTransferConfig *config)
{
    Ifx_XSPI *xspiSFR = &MODULE_XSPI0;                                  /* pointer to XSPI Registers*/

    xspiSFR->CLC.B.DISR = 0;

    while (xspiSFR->CLC.B.DISS == 1)                                    /* wait as long disabled */

    {}

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable;   /* Disable DWC_SSI*/

    xspiSFR->BAUDR.B.SCKDV                = config->xspiClkDivder;

    xspiSFR->CTRLR0.B.SPI_HYPERBUS_EN     = config->hyperbusEnable;     /* enable Hyperbus */
    xspiSFR->CTRLR0.B.SPI_FRF             = config->spiFrameFormat;     /* octal frame format */

    xspiSFR->SPI_CTRLR0.B.TRANS_TYPE      = config->transferFormat;     /* Address in octal */
    xspiSFR->SPI_CTRLR0.B.ADDR_L          = config->addrLength;         /* 4?b1100 (address length of 48 bits) */
    xspiSFR->SPI_CTRLR0.B.INST_L          = config->instructionLength;  /* no instruction phase */
    xspiSFR->SPI_CTRLR0.B.SPI_DDR_EN      = config->spiDdrEnable;       /* Address to be sent on octal-DDR mode */

    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_EN     = 1;                          /*  enable read data strobe to sample incoming data */
    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = 0;

    /* If the SPI_CTRLR0.RXDS_SIG_EN bit is set to 0 or if the rxds level is 0 during CA phase, the number of wait cycles */
    /* Is fixed to the programmed value in the SPI_CTRLR0.WAIT_CYCLES bit-field. */

    xspiSFR->CTRLR0.B.TMOD    = config->transferMode;
    xspiSFR->CTRLR0.B.DFS     = config->dataFrameSize;

    xspiSFR->SER.B.SER        = config->slaveSelectEnable;      /* CS0 gets activated when data transfer is started */

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;        /* Enable DWC_SSI*/
}


boolean IfxXspi_Spi_hyperbus_write_address_data(IfxXspi_Spi_ReadWriteConfig *config, uint32 address, uint16 data)
{
    Ifx_XSPI *xspiSFR = &MODULE_XSPI0;                              /* pointer to XSPI Registers*/
    uint32    Temp_proov;
    uint8     waitCycle_Temp;
    uint8     sckdv_temp = 0;

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable; /* Disable DWC_SSI*/

    xspiSFR->DMACR.B.IDMAE                = 0;

    xspiSFR->CTRLR0.B.TMOD                = config->transMode;

    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = config->rxdsEnable;

    xspiSFR->CTRLR1.B.NDF                 = config->numOfDataFrames;

    waitCycle_Temp                        = xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES;
    xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES     = config->waitCycle;      /* Wait cycles depending on memory requirement */

    if (config->enableAsymBaudrate == IfxXspi_Dwc_Mode_Enable)
    {
        sckdv_temp             = xspiSFR->BAUDR.B.SCKDV;
        xspiSFR->BAUDR.B.SCKDV = (IfxClock_getXspiFrequency() / config->buadrate);
    }

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;            /* Enable DWC_SSI*/
    /* Load FIFO */

    Temp_proov       = IFXXSPI_WRITE_CMD_VALUE | (address & IFXXSPI_WRITE_CMD_MASK) >> IFXXSPI_WRITE_SHIFT;
    xspiSFR->DR[0].U = Temp_proov;
    Temp_proov       = IFXXSPI_WRITE_ADDR_VALUE | (address & IFXXSPI_WRITE_ADDR_MASK);
    xspiSFR->DR[0].U = Temp_proov;
    xspiSFR->DR[0].U = data;

    while ((xspiSFR->SR.B.TFE == 0) || (xspiSFR->SR.B.BUSY == 1))
    {}

/* restore wait cycle & SCKDV*/
    xspiSFR->SSIENR.B.SSIC_EN         = IfxXspi_Dwc_Mode_Disable;     /* Disable DWC_SSI*/
    xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES = waitCycle_Temp;

    if (config->enableAsymBaudrate == IfxXspi_Dwc_Mode_Enable)
    {
        xspiSFR->BAUDR.B.SCKDV = sckdv_temp;
    }

    xspiSFR->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;             /* Enable DWC_SSI*/

    return TRUE;
}


boolean IfxXspi_Spi_hyperbus_read_address_data(IfxXspi_Spi_ReadWriteConfig *config, uint32 address, uint16 *data)
{
    Ifx_XSPI *xspiSFR = &MODULE_XSPI0;                           /* pointer to XSPI Registers*/
    uint32    Temp_proov;
    boolean   status  = TRUE;
    uint8     waitCycle_Temp;

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable; /* Disable DWC_SSI*/

    xspiSFR->DMACR.B.IDMAE                = 0;

    xspiSFR->CTRLR0.B.TMOD                = config->transMode;

    xspiSFR->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = config->rxdsEnable;

    xspiSFR->CTRLR1.B.NDF                 = config->numOfDataFrames; /*  here both tx and rx count are equal */

    waitCycle_Temp                        = xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES;
    xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES     = config->waitCycle;       /* Wait cycles depending on memory requirement */

    xspiSFR->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Enable; /* Enable DWC_SSI*/
                                                                     /* Load FIFO  */

    Temp_proov       = IFXXSPI_READ_CMD_VALUE | (address & IFXXSPI_READ_CMD_MASK) >> IFXXSPI_READ_SHIFT;
    xspiSFR->DR[0].U = Temp_proov;

    Temp_proov       = IFXXSPI_READ_ADDR_VALUE | (address & IFXXSPI_READ_ADDR_MASK);
    xspiSFR->DR[0].U = Temp_proov;

    while ((xspiSFR->SR.B.TFE == 0) || (xspiSFR->SR.B.RFNE == 0))
    {}

    if (xspiSFR->SR.B.RFNE == 1)
    {
        uint32 count = (uint32)(xspiSFR->RXFLR.B.RXTFL);            /* get the readable count of Rx fifo */

        if (count == 0)
        {
            status = FALSE;
        }

        *data = xspiSFR->DR[0].U & 0xFFFF;
    }

    /* restore wait cycle */
    xspiSFR->SSIENR.B.SSIC_EN         = IfxXspi_Dwc_Mode_Disable;    /* Disable DWC_SSI*/
    xspiSFR->SPI_CTRLR0.B.WAIT_CYCLES = waitCycle_Temp;
    xspiSFR->SSIENR.B.SSIC_EN         = IfxXspi_Dwc_Mode_Enable;     /* Enable DWC_SSI*/

    return status;
}


IfxXspi_Status IfxXspi_Spi_stdDataExchange(Ifx_XSPI *xspi, IfxXspi_Spi_StdModeConfig *config)
{
    uint16         txCount      = config->nosOfDataFramesTransmit, rxCount = config->nosOfDataFramesReceive, tx_index = 0, rx_index = 0;
    uint32         actual_rxCount;
    IfxXspi_Status status       = IfxXspi_Status_success;
    uint16         temp_rxCount = rxCount;

    xspi->SSIENR.B.SSIC_EN         = IfxXspi_Dwc_Mode_Disable;
    xspi->CTRLR0.B.DFS             = config->dataFrameSize;                     //Configure Nos of data frames to transmit on MOSI line
    xspi->CTRLR0.B.SCPH            = config->clockPhase;
    xspi->CTRLR0.B.SCPOL           = config->clockPolarity;
    xspi->CTRLR0.B.TMOD            = IfxXspi_TransferMode_TxRx;
    xspi->SPI_CTRLR0.B.WAIT_CYCLES = config->waitCycles;                        //Configure Nos of data frames to receive on MISO line
    xspi->CTRLR0.B.SRL             = 0;
    xspi->CTRLR0.B.SSTE            = 0;
    xspi->CTRLR0.B.SPI_FRF         = IfxXspi_SpiFrameFormat_Std;
    xspi->CTRLR0.B.SPI_HYPERBUS_EN = 0;
    xspi->BAUDR.B.SCKDV            = config->xspiClkDivder;
    xspi->CTRLR1.B.NDF             = config->nosOfDataFramesTransmit;
    xspi->TXFTLR.B.TXFTHR          = config->txFifoThreshLevel;
    xspi->SER.B.SER                = config->slaveSelectEnable;
    xspi->SSIENR.B.SSIC_EN         = IfxXspi_Dwc_Mode_Enable;

    while (txCount--)
    {
        xspi->DR[0].U = config->txData[tx_index];
        tx_index      = tx_index + 1;
    }

    while (rxCount--)
    {
        xspi->DR[0].U = 0;      //Dummy write to DR register to hold CLK for rxCount dataFrames to receive
    }

    while ((xspi->SR.B.TFE == 0) || (xspi->SR.B.BUSY == 1) || (xspi->SR.B.RFNE == 0))
    {}

    if (xspi->SR.B.RFNE == 1)
    {
        actual_rxCount = (uint32)(xspi->RXFLR.B.RXTFL);

        if (actual_rxCount != temp_rxCount)
        {
            status = IfxXspi_Status_failure;        // Expected receive data frame count and actual count are different
        }

        while (actual_rxCount != 0)
        {
            config->rxData[rx_index++] = xspi->DR[0].U & 0xFFFF;
            actual_rxCount--;
        }
    }

    return status;
}


IfxXspi_Status IfxXspi_Spi_enhancedDataTransmit(Ifx_XSPI *xspi, IfxXspi_Spi_EnhancedModeConfig *config)
{
    IfxXspi_Status             status = IfxXspi_Status_success;
    IfxXspi_Spi_bufferPointers txData;
    uint32                     txCount;

    uint8                      dfs_temp         = 0;
    uint8                      sckdv_temp       = 0;
    uint8                      dfs_restore      = FALSE;
    uint8                      offset;
    uint8                      txFifoStartLevel = 0;
    /*
     * calculate txCount
     */
    txCount                = config->dataCount;

    txData.u8ptr           = config->txData;

    xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;            /* Disable DWC_SSI*/
    xspi->CTRLR0.B.TMOD    = IfxXspi_TransferMode_Tx;
    xspi->DMACR.B.IDMAE    = IfxXspi_Dwc_Mode_Disable;

#if (IFXXSPI_UM_RECOMMENDATION >= 1)

    /* UM Recommendation: Some of the devices require instruction and address only transfer (without data phase).
     * This can be achieved by skipping the address phase, and transmitting the address as data to the  device.
     * For this, SPI_CTRLR0.ADDR_L should be programmed to 0, and CTRLR0.DFS should be programmed with the required length.
     */
    if ((config->instructionLength != IfxXspi_InstructionLength_L0) && (config->addrLength != IfxXspi_AddressLength_L0))
    {
        if (config->dataCount == 0)
        {
            if (config->addrLength > IfxXspi_AddressLength_L32)
            {
                return IfxXspi_Status_configurationError;
            }

            dfs_restore        = TRUE;
            dfs_temp           = xspi->CTRLR0.B.DFS;
            xspi->CTRLR0.B.DFS = (config->addrLength * 4) - 1;
            txCount            = 1;
            txData.u8ptr       = (uint8 *)&(config->address);
            config->addrLength = IfxXspi_AddressLength_L0;
        }
    }

#endif

#if (IFXXSPI_COMPUTE_TXSTARTFIFO >= 1)
    /* Check if clock stretching is disabled
     * if disabled then we have to program the tx start fifo level
     * to ensure that dataphase is reached
     */
    offset = 0;

    if (xspi->SPI_CTRLR0.B.CLK_STRETCH_EN == IfxXspi_Dwc_Mode_Disable)
    {
        if (txCount != 0)
        {
            if (config->instructionLength != IfxXspi_InstructionLength_L0)
            {
                offset++;
            }

            if (config->addrLength != IfxXspi_AddressLength_L0)
            {
                offset++;

                if (config->addrLength > IfxXspi_AddressLength_L32)
                {
                    offset++;
                }
            }

            offset                = offset + (txCount - 1);
            txFifoStartLevel      = __min(offset, 15);
            xspi->TXFTLR.B.TXFTHR = txFifoStartLevel;
        }
        else
        {
            xspi->TXFTLR.B.TXFTHR = 0;
        }
    }
    else
    {
        xspi->TXFTLR.B.TXFTHR = 0;
    }

#endif

    /* Switch to different baudrate for write */
    if (config->enableAsymBaudrate == IfxXspi_Dwc_Mode_Enable)
    {
        sckdv_temp          = xspi->BAUDR.B.SCKDV;
        xspi->BAUDR.B.SCKDV = (IfxClock_getXspiFrequency() / config->buadrate);
    }

    xspi->CTRLR1.B.NDF                 = txCount;
    xspi->SPI_CTRLR0.B.INST_L          = config->instructionLength;
    xspi->SPI_CTRLR0.B.ADDR_L          = config->addrLength;
    xspi->SPI_CTRLR0.B.WAIT_CYCLES     = config->waitCycles;
    xspi->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = config->spiRxdsSignalEnable;
    xspi->SER.B.SER                    = config->slaveSelectEnable;
    xspi->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Enable;  /* Enable DWC_SSI*/

    /* push instruction to TX FIFO if applicable */
    if (config->instructionLength != IfxXspi_InstructionLength_L0)
    {
        xspi->DR[0].U = config->instruction;
    }

    /* push address to TX FIFO if applicable */
    if (config->addrLength != IfxXspi_AddressLength_L0)
    {
        uint32 *addrPtr = (uint32 *)&config->address;
        xspi->DR[0].U = addrPtr[0];

        if (config->addrLength > IfxXspi_AddressLength_L32)
        {
            xspi->DR[0].U = addrPtr[1];
        }
    }

    /* transmit section */
    if (xspi->CTRLR0.B.DFS <= 8)
    {
        IfxXspi_Spi_write8(xspi, txData.u8ptr, &txCount);
    }
    else if (xspi->CTRLR0.B.DFS <= 16)
    {
        IfxXspi_Spi_write16(xspi, txData.u16ptr, &txCount);               /* 16 bit DataframeSize per transfer*/
    }
    else
    {
        IfxXspi_Spi_write32(xspi, txData.u32ptr, &txCount);               /* 32 bit DataframeSize per transfer*/
    }

    while (xspi->SR.B.TFE == 0)
    {}

    while (xspi->SR.B.BUSY == 1)
    {}

    xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;            /* Enable DWC_SSI*/
#if (IFXXSPI_UM_RECOMMENDATION >= 1)

    if (dfs_restore == TRUE)
    {
        xspi->CTRLR0.B.DFS = dfs_temp;
    }

#endif

    /* restore original baudrate */
    if (config->enableAsymBaudrate == IfxXspi_Dwc_Mode_Enable)
    {
        xspi->BAUDR.B.SCKDV = sckdv_temp;
    }

    xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable;            /* Enable DWC_SSI*/

    return status;
}


IfxXspi_Status IfxXspi_Spi_enhancedDataReceive(Ifx_XSPI *xspi, IfxXspi_Spi_EnhancedModeConfig *config)
{
    IfxXspi_Status             status     = IfxXspi_Status_success;
    IfxXspi_Spi_bufferPointers rxData;
    uint32                     prev_count = 0;
    uint32                     count      = 0;

    rxData.u8ptr = config->rxData;

    /*
     * calculate txCount (assumed data frame size is 8bit)
     */
    xspi->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable;  /* Disable DWC_SSI*/
    xspi->CTRLR0.B.TMOD                = IfxXspi_TransferMode_Rx;
    xspi->DMACR.B.IDMAE                = IfxXspi_Dwc_Mode_Disable;

    xspi->SPI_CTRLR0.B.INST_L          = config->instructionLength;
    xspi->SPI_CTRLR0.B.ADDR_L          = config->addrLength;

    xspi->SPI_CTRLR0.B.WAIT_CYCLES     = config->waitCycles;
    xspi->CTRLR1.B.NDF                 = config->dataCount - 1;
    xspi->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = config->spiRxdsSignalEnable;

    xspi->SER.B.SER                    = config->slaveSelectEnable;
    xspi->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Enable;  /* Enable DWC_SSI*/

    if (config->instructionLength != IfxXspi_InstructionLength_L0)
    {
        xspi->DR[0].U = config->instruction;
    }

    if (config->addrLength != IfxXspi_AddressLength_L0)
    {
        uint32 *addrPtr = (uint32 *)&config->address;
        xspi->DR[0].U = addrPtr[0];

        if (config->addrLength > IfxXspi_AddressLength_L32)
        {
            xspi->DR[0].U = addrPtr[1];
        }
    }

    prev_count = 0;

    while (config->dataCount != 0)
    {
        if (xspi->SR.B.RFNE == 1)
        {
            count             = xspi->RXFLR.B.RXTFL;
            count             = __min(config->dataCount, count);
            config->dataCount = config->dataCount - count;

            /* read data up to the count based on the out width */
            if (xspi->CTRLR0.B.DFS <= 8)
            {
                IfxXspi_read8(xspi, &rxData.u8ptr[prev_count], count);                  /* reading from Rx FIFO */
            }
            else if (xspi->CTRLR0.B.DFS <= 16)
            {
                IfxXspi_read16(xspi, &rxData.u16ptr[prev_count], count);                  /* reading from Rx FIFO */
            }
            else
            {
                IfxXspi_read32(xspi, &rxData.u32ptr[prev_count], count);    /* 32 bit DataframeSize per transfer*/
            }

            prev_count = prev_count + count;
        }
    }

    return status;
}


void IfxXspi_Spi_enableClockStretch(Ifx_XSPI *xspi, boolean enableClockStretch)
{
    if (enableClockStretch == TRUE)
    {
        xspi->SPI_CTRLR0.B.CLK_STRETCH_EN = 1;
    }
    else
    {
        xspi->SPI_CTRLR0.B.CLK_STRETCH_EN = 0;
    }
}


void IfxXspi_Spi_xipDataRead(Ifx_XSPI *xspi, IfxXspi_Spi_XipModeConfig *config)
{
    xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Disable;                      //Disable DWC_SSI

    // Configure access to XIP regions
    xspi->RGN[0].ACCEN.RGNLA.U = IFXXSPI_XIP_REGION0_LOWER;
    xspi->RGN[0].ACCEN.RGNUA.U = IFXXSPI_XIP_REGION0_UPPER;
    xspi->RGN[1].ACCEN.RGNLA.U = IFXXSPI_XIP_REGION1_LOWER;
    xspi->RGN[1].ACCEN.RGNUA.U = IFXXSPI_XIP_REGION1_UPPER;

    xspi->RGN[0].ACCEN.RDA.U   = 0xFFFFFFFF;
    xspi->RGN[0].ACCEN.RDB.U   = 0xFFFFFFFF;
    xspi->RGN[0].ACCEN.WRA.U   = 0xFFFFFFFF;
    xspi->RGN[0].ACCEN.WRB.U   = 0xFFFFFFFF;
    xspi->RGN[0].ACCEN.VM.U    = 0xFFFFFFFF;
    xspi->RGN[0].ACCEN.PRS.U   = 0xFFFFFFFF;

    xspi->RGN[1].ACCEN.RDA.U   = 0xFFFFFFFF;
    xspi->RGN[1].ACCEN.RDB.U   = 0xFFFFFFFF;
    xspi->RGN[1].ACCEN.WRA.U   = 0xFFFFFFFF;
    xspi->RGN[1].ACCEN.WRB.U   = 0xFFFFFFFF;
    xspi->RGN[1].ACCEN.VM.U    = 0xFFFFFFFF;
    xspi->RGN[1].ACCEN.PRS.U   = 0xFFFFFFFF;

    //XSPI basic Init
    xspi->CTRLR1.B.NDF             = config->numberOfDataFrames;
    xspi->CTRLR0.B.DFS             = config->dataFrameSize;
    xspi->CTRLR0.B.FRF             = 0;
    xspi->CTRLR0.B.SCPH            = config->clockPhase;
    xspi->CTRLR0.B.SCPOL           = config->clockPolarity;
    xspi->CTRLR0.B.TMOD            = IfxXspi_TransferMode_Rx;
    xspi->CTRLR0.B.SRL             = 0;
    xspi->CTRLR0.B.SSTE            = 0;
    xspi->CTRLR0.B.SPI_FRF         = config->spiFrameFormat;
    xspi->CTRLR0.B.SPI_HYPERBUS_EN = config->hyperbusEnable;
    xspi->SPI_CTRLR0.B.WAIT_CYCLES = config->waitCycles;
    xspi->SPI_CTRLR0.B.TRANS_TYPE  = config->transferFormat;             //inst and addr will be send as mode specify in spi_frf
    xspi->SPI_CTRLR0.B.ADDR_L      = config->addrLength;
    xspi->SPI_CTRLR0.B.INST_L      = config->instructionLength;
    xspi->SPI_CTRLR0.B.SPI_DDR_EN  = config->spiDdrEnable;
    xspi->SPI_CTRLR0.B.INST_DDR_EN = config->spiInstDdrEnable;
    xspi->SPI_CTRLR0.B.SPI_RXDS_EN = config->spiReadDataStrobeEnable;              //capture using data strobe
    xspi->DMACR.B.IDMAE            = 0;
    xspi->BAUDR.B.SCKDV            = config->xspiClkDivder;
    xspi->SER.B.SER                = config->slaveSelectEnable;

    // xSPI eXecute in place configuration
    xspi->SPI_CTRLR0.B.XIP_MD_BIT_EN         = config->xipModeBitsEnable;
    xspi->SPI_CTRLR0.B.SSIC_XIP_CONT_XFER_EN = config->xipContinuousTransfer;
    xspi->SPI_CTRLR0.B.XIP_DFS_HC            = config->xipDataFrameSizeEnable;
    xspi->SPI_CTRLR0.B.XIP_INST_EN           = config->xipInstFrameEnable;
    xspi->SPI_CTRLR0.B.XIP_MBL               = config->xipBitLen;
    xspi->SPI_CTRLR0.B.XIP_PREFETCH_EN       = config->xipPreFetchEnable;
    xspi->XIP.CNT_TIME_OUT.B.XTOC            = config->xipTimeoutValue;
    xspi->XIP.INCR_INST.B.INCR_INST          = config->xipIncrInstruction;
    xspi->XIP.WRAP_INST.B.WRAP_INST          = config->xipWrapInstruction;
    xspi->XIP.MODE_BITS.B.XIP_MD_BITS        = config->xipModeBitsValue;
    xspi->SPI_CTRLR0.B.SPI_RXDS_SIG_EN       = config->rxdsEnable;

    xspi->SSIENR.B.SSIC_EN                   = IfxXspi_Dwc_Mode_Enable;

    while (xspi->SR.B.BUSY == 1)
    {}
}


void IfxXspi_Spi_setXspiGpioPins(Ifx_XSPI *xspi, IfxXspi_Spi_GpioPins *pins)
{
    xspi->CLC.B.DISR = 0;

    while (xspi->CLC.B.DISS == 1)           // wait as long module is disabled
    {}

    xspi->CTRLR2.B.PORTSEL = pins->selPort; // selects GPIO pad as xSPI data, CS, CLK pins
    /*
     * // As per UM these bits should be set for DQ0-3 lines, when these bits are set the communication does not work
     * P20_PCSRSEL.B.PCSR3 = 1;
     * P20_PCSRSEL.B.PCSR9 = 1;
     * P20_PCSRSEL.B.PCSR6 = 1;
     * P15_PCSRSEL.B.PCSR2 = 1;
     */

    if (pins->clk != NULL_PTR)
    {
        pins->clk->pin.port->PADCFG[pins->clk->pin.pinIndex].DRVCFG.B.MODE  = 0xF;      //xSPI clk pin
        pins->clk->pin.port->PADCFG[pins->clk->pin.pinIndex].DRVCFG.B.PD    = 0x2;
        pins->clk->pin.port->PADCFG[pins->clk->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->clk->pin.port->PADCFG[pins->clk->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->clk->pin.port->PADCFG[pins->clk->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->clk->pin.port->PADCFG[pins->clk->pin.pinIndex].DRVCFG.B.DIR   = 1;
    }

    if (pins->cs != NULL_PTR)
    {
        pins->cs->pin.port->PADCFG[pins->cs->pin.pinIndex].DRVCFG.B.MODE  = 0xF;        //xSPI cs pin
        pins->cs->pin.port->PADCFG[pins->cs->pin.pinIndex].DRVCFG.B.PD    = 0x2;
        pins->cs->pin.port->PADCFG[pins->cs->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->cs->pin.port->PADCFG[pins->cs->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->cs->pin.port->PADCFG[pins->cs->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->cs->pin.port->PADCFG[pins->cs->pin.pinIndex].DRVCFG.B.DIR   = 1;
    }

    if (pins->txd0 != NULL_PTR)
    {
        pins->txd0->pin.port->PADCFG[pins->txd0->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd0 pin
        pins->txd0->pin.port->PADCFG[pins->txd0->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd0->pin.port->PADCFG[pins->txd0->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd0->pin.port->PADCFG[pins->txd0->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd0->pin.port->PADCFG[pins->txd0->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd0->pin.port->PADCFG[pins->txd0->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }

    if (pins->txd1 != NULL_PTR)
    {
        pins->txd1->pin.port->PADCFG[pins->txd1->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd1 pin
        pins->txd1->pin.port->PADCFG[pins->txd1->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd1->pin.port->PADCFG[pins->txd1->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd1->pin.port->PADCFG[pins->txd1->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd1->pin.port->PADCFG[pins->txd1->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd1->pin.port->PADCFG[pins->txd1->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }

    if (pins->txd2 != NULL_PTR)
    {
        pins->txd2->pin.port->PADCFG[pins->txd2->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd2 pin
        pins->txd2->pin.port->PADCFG[pins->txd2->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd2->pin.port->PADCFG[pins->txd2->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd2->pin.port->PADCFG[pins->txd2->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd2->pin.port->PADCFG[pins->txd2->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd2->pin.port->PADCFG[pins->txd2->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }

    if (pins->txd3 != NULL_PTR)
    {
        pins->txd3->pin.port->PADCFG[pins->txd3->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd3 pin
        pins->txd3->pin.port->PADCFG[pins->txd3->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd3->pin.port->PADCFG[pins->txd3->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd3->pin.port->PADCFG[pins->txd3->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd3->pin.port->PADCFG[pins->txd3->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd3->pin.port->PADCFG[pins->txd3->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }

    if (pins->txd4 != NULL_PTR)
    {
        pins->txd4->pin.port->PADCFG[pins->txd4->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd4 pin
        pins->txd4->pin.port->PADCFG[pins->txd4->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd4->pin.port->PADCFG[pins->txd4->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd4->pin.port->PADCFG[pins->txd4->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd4->pin.port->PADCFG[pins->txd4->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd4->pin.port->PADCFG[pins->txd4->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }

    if (pins->txd5 != NULL_PTR)
    {
        pins->txd5->pin.port->PADCFG[pins->txd5->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd5 pin
        pins->txd5->pin.port->PADCFG[pins->txd5->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd5->pin.port->PADCFG[pins->txd5->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd5->pin.port->PADCFG[pins->txd5->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd5->pin.port->PADCFG[pins->txd5->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd5->pin.port->PADCFG[pins->txd5->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }

    if (pins->txd6 != NULL_PTR)
    {
        pins->txd6->pin.port->PADCFG[pins->txd6->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd6 pin
        pins->txd6->pin.port->PADCFG[pins->txd6->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd6->pin.port->PADCFG[pins->txd6->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd6->pin.port->PADCFG[pins->txd6->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd6->pin.port->PADCFG[pins->txd6->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd6->pin.port->PADCFG[pins->txd6->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }

    if (pins->txd7 != NULL_PTR)
    {
        pins->txd7->pin.port->PADCFG[pins->txd7->pin.pinIndex].DRVCFG.B.MODE  = 0;      //xSPI txd7 pin
        pins->txd7->pin.port->PADCFG[pins->txd7->pin.pinIndex].DRVCFG.B.PD    = 0x1;
        pins->txd7->pin.port->PADCFG[pins->txd7->pin.pinIndex].DRVCFG.B.MODEX = 0x2;
        pins->txd7->pin.port->PADCFG[pins->txd7->pin.pinIndex].DRVCFG.B.PL    = 0x3;
        pins->txd7->pin.port->PADCFG[pins->txd7->pin.pinIndex].DRVCFG.B.OD    = 0;
        pins->txd7->pin.port->PADCFG[pins->txd7->pin.pinIndex].DRVCFG.B.DIR   = 0;
    }
}


IfxXspi_Status IfxXspi_Spi_dmaEnhancedDataExchange(Ifx_XSPI *xspi, IfxXspi_Spi_DmaExchangeConfig *config)
{
    IfxXspi_Status status = IfxXspi_Status_success;
    xspi->SSIENR.B.SSIC_EN             = IfxXspi_Dwc_Mode_Disable;   //Disable DWC_SSI

    xspi->CTRLR1.B.NDF                 = config->numberOfDataFrames;
    xspi->CTRLR0.B.DFS                 = config->dataFrameSize;
    xspi->CTRLR0.B.FRF                 = 0;
    xspi->CTRLR0.B.SCPH                = config->clockPhase;
    xspi->CTRLR0.B.SCPOL               = config->clockPolarity;
    xspi->CTRLR0.B.TMOD                = config->transferMode;          //DMA support TX only and RX only transfer modes
    xspi->CTRLR0.B.SRL                 = 0;
    xspi->CTRLR0.B.SSTE                = 0;
    xspi->CTRLR0.B.SPI_FRF             = config->spiFrameFormat;
    xspi->CTRLR0.B.SPI_HYPERBUS_EN     = config->hyperbusEnable;
    xspi->SPI_CTRLR0.B.WAIT_CYCLES     = config->waitCycles;
    xspi->SPI_CTRLR0.B.TRANS_TYPE      = config->transferFormat;
    xspi->SPI_CTRLR0.B.ADDR_L          = config->addrLength;
    xspi->SPI_CTRLR0.B.INST_L          = config->instructionLength;
    xspi->SPI_CTRLR0.B.SPI_DDR_EN      = config->spiDdrEnable;
    xspi->SPI_CTRLR0.B.INST_DDR_EN     = config->spiInstDdrEnable;
    xspi->SPI_CTRLR0.B.SPI_RXDS_EN     = config->spiReadDataStrobeEnable;
    xspi->SPI_CTRLR0.B.SPI_RXDS_SIG_EN = config->rxdsEnable;
    xspi->SER.B.SER                    = config->slaveSelectEnable;
    xspi->BAUDR.B.SCKDV                = config->xspiClkDivder;
    xspi->DMACR.B.IDMAE                = 1;
    xspi->DMACR.B.ATW                  = config->dmaTransferWidth;
    xspi->DMACR.B.AINC                 = config->addressIncrement;
    xspi->DMACR.B.ACACHE               = 0;
    xspi->DMACR.B.APROT                = 0;
    xspi->DMACR.B.AID                  = 0;
    xspi->SPIDR.B.SPI_INST             = config->SpiInstruction;
    xspi->SPIAR.B.SDAR                 = config->spiDeviceAddress;
    xspi->AXIAR0.B.AXIAR_0_31          = (uint32)IFXCPU_GLB_ADDR_DSPR(IfxCpu_getCoreId(), config->data);

    if (config->transferMode == IfxXspi_TransferMode_Rx)
    {
        xspi->DMACR.B.RDMAE    = 1;
        xspi->RXFTLR.B.RFT     = 0;
        xspi->AXIARLEN.B.ARLEN = config->srcBurstLength;
    }
    else if (config->transferMode == IfxXspi_TransferMode_Tx)
    {
        xspi->DMACR.B.TDMAE    = 1;
        xspi->TXFTLR.B.TXFTHR  = 0;
        xspi->AXIAWLEN.B.AWLEN = config->destBurstLength;
    }
    else
    {
        status = IfxXspi_Status_configurationError;   //Invalid configuration as xSPI Internal DMA support Only TX and Only RX in enhanced mode only
    }

    xspi->SSIENR.B.SSIC_EN = IfxXspi_Dwc_Mode_Enable; // Enable DWC_SSI

    while (xspi->SR.B.BUSY == 1)
    {}

    return status;
}


void IfxXspi_Spi_switchSpiProtocol(Ifx_XSPI *xspi, IfxXspi_Spi_spiProtocolSwitch *config)
{
    xspi->SSIENR.B.SSIC_EN         = IfxXspi_Dwc_Mode_Disable;       /* Disable DWC_SSI*/

    xspi->CTRLR0.B.SPI_FRF         = config->spiFrameFormat;
    xspi->SPI_CTRLR0.B.TRANS_TYPE  = config->transferFormat;
    xspi->SPI_CTRLR0.B.SPI_DDR_EN  = config->spiDdrEnable;
    xspi->SPI_CTRLR0.B.INST_DDR_EN = config->spiInstDdrEnable;
    xspi->SPI_CTRLR0.B.SPI_RXDS_EN = config->spiRxdsEnable;
    xspi->CTRLR0.B.DFS             = config->dataFrameSize;

    xspi->CTRLR0.B.SPI_HYPERBUS_EN = config->hyperbusEnable;
    xspi->CTRLR0.B.CLK_LOOP_EN     = config->clockLoopBack;
    xspi->BAUDR.B.SCKDV            = (IfxClock_getXspiFrequency() / config->baudrate); /* Configuring Baud Rate Select */

    xspi->DDR_DRIVE_EDGE.B.TDE     = config->ddrTxDriveEdge;                           /* DDR Transmit Drive Edge */

    xspi->RX_SAMPLE_DELAY.B.RSD    = config->rxDataSampleDelay;                        /* Receive Data (rxd) Sample Delay */
    xspi->RX_SAMPLE_DELAY.B.SE     = config->rxDataSamplingEdge;                       /* Receive Data (rxd) Sampling Edge */

    xspi->SSIENR.B.SSIC_EN         = IfxXspi_Dwc_Mode_Enable;                          /* Enable DWC_SSI*/
}


IFX_STATIC void IfxXspi_Spi_write8(Ifx_XSPI *xspi, uint8 *txData, uint32 *txCount)
{
    uint32 prev_count = 0;
    uint32 count;

    while (*txCount != 0)
    {
        if (xspi->SR.B.TFNF == 1)
        {
            count    = (uint32)(16 - xspi->TXFLR.B.TXTFL);
            count    = __min(*txCount, count);
            *txCount = *txCount - count;

            IfxXspi_write8(xspi, &txData[prev_count], count);
            prev_count = prev_count + count;
        }
    }
}


IFX_STATIC void IfxXspi_Spi_write16(Ifx_XSPI *xspi, uint16 *txData, uint32 *txCount)
{
    uint32 prev_count = 0;
    uint32 count;

    while (*txCount != 0)
    {
        if (xspi->SR.B.TFNF == 1)
        {
            count    = (uint32)(16 - xspi->TXFLR.B.TXTFL);
            count    = __min(*txCount, count);
            *txCount = *txCount - count;

            IfxXspi_write16(xspi, &txData[prev_count], count);               /* 16 bit DataframeSize per transfer*/
            prev_count = prev_count + count;
        }
    }
}


IFX_STATIC void IfxXspi_Spi_write32(Ifx_XSPI *xspi, uint32 *txData, uint32 *txCount)
{
    uint32 prev_count = 0;
    uint32 count;

    while (*txCount != 0)
    {
        if (xspi->SR.B.TFNF == 1)
        {
            count    = (uint32)(16 - xspi->TXFLR.B.TXTFL);
            count    = __min(*txCount, count);
            *txCount = *txCount - count;

            IfxXspi_write32(xspi, &txData[prev_count], count);               /* 32 bit DataframeSize per transfer*/
            prev_count = prev_count + count;
        }
    }
}
