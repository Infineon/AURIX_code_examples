/**
 * \file IfxScrCpuIrq.h
 * \brief SCR CPU  basic functionality
 * \ingroup IfxLld_Scr
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_Scr_Cpu CPU
 * \ingroup IfxLld_Scr
 * \defgroup IfxLld_Scr_Cpu_Enumerations Enumerations
 * \ingroup IfxLld_Scr_Cpu
 * \defgroup IfxLld_Scr_Cpu_Irq Irq Basic Functionality
 * \ingroup IfxLld_Scr_Cpu
 */

#ifndef IFXSCRCPUIRQ_H
#define IFXSCRCPUIRQ_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxScrCpu_cfg.h"
#include "_Reg/IfxScr_bf.h"
#include "_Reg/IfxScr_reg.h"
#include "_Utilities/Ifx_Assert.h"

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Scr_Cpu_Enumerations
 * \{ */
/** \brief List of external interrupts
 */
typedef enum
{
    IfxScrCpuIrq_ExternalInterrupt_0  = 0,   /**< \brief External Interrupt 0 */
    IfxScrCpuIrq_ExternalInterrupt_1  = 1,   /**< \brief External Interrupt 1 */
    IfxScrCpuIrq_ExternalInterrupt_2  = 2,   /**< \brief External Interrupt 2 */
    IfxScrCpuIrq_ExternalInterrupt_3  = 3,   /**< \brief External Interrupt 3 */
    IfxScrCpuIrq_ExternalInterrupt_4  = 4,   /**< \brief External Interrupt 4 */
    IfxScrCpuIrq_ExternalInterrupt_5  = 5,   /**< \brief External Interrupt 5 */
    IfxScrCpuIrq_ExternalInterrupt_6  = 6,   /**< \brief External Interrupt 6 */
    IfxScrCpuIrq_ExternalInterrupt_7  = 7,   /**< \brief External Interrupt 7 */
    IfxScrCpuIrq_ExternalInterrupt_8  = 8,   /**< \brief External Interrupt 8 */
    IfxScrCpuIrq_ExternalInterrupt_9  = 9,   /**< \brief External Interrupt 9 */
    IfxScrCpuIrq_ExternalInterrupt_10 = 10,  /**< \brief External Interrupt 10 */
    IfxScrCpuIrq_ExternalInterrupt_11 = 11,  /**< \brief External Interrupt 11 */
    IfxScrCpuIrq_ExternalInterrupt_12 = 12,  /**< \brief External Interrupt 12 */
    IfxScrCpuIrq_ExternalInterrupt_13 = 13,  /**< \brief External Interrupt 13 */
    IfxScrCpuIrq_ExternalInterrupt_14 = 14,  /**< \brief External Interrupt 14 */
    IfxScrCpuIrq_ExternalInterrupt_15 = 15   /**< \brief External Interrupt 15 */
} IfxScrCpuIrq_ExternalInterrupt;

/** \brief Options for which edge would trigger interrupt on an external pin
 */
typedef enum
{
    IfxScrCpuIrq_ExternalInterruptTriggerEdge_risingEdge          = 0, /**< \brief Low to high transition on the pin will cause interrupts */
    IfxScrCpuIrq_ExternalInterruptTriggerEdge_fallingEdge         = 1, /**< \brief High to Low transition on the pin will cause interrupts */
    IfxScrCpuIrq_ExternalInterruptTriggerEdge_bothEdge            = 2, /**< \brief Any transition on the pin will cause interrupts */
    IfxScrCpuIrq_ExternalInterruptTriggerEdge_bypassEdgeDetection = 3  /**< \brief Edge detection unit in SCU is bypassed */
} IfxScrCpuIrq_ExternalInterruptTriggerEdge;

/** \brief Trigger options(level triggered vs edge triggered) for External Interrupt 0 and ExternalInterrupt 1
 */
typedef enum
{
    IfxScrCpuIrq_ExternalInterruptTriggerType_lowLevel    = 0, /**< \brief Interrupt will be triggered by a low level assertion on pin for a specific duration */
    IfxScrCpuIrq_ExternalInterruptTriggerType_fallingEdge = 1  /**< \brief A high to low signal transition on pin will trigger an interrupt */
} IfxScrCpuIrq_ExternalInterruptTriggerType;

/** \brief List of interrupt nodes
 */
typedef enum
{
    IfxScrCpuIrq_InterruptNode_externalInterrupt0        = 0U,    /**< \brief XINTR0(External Interrupt 0) */
    IfxScrCpuIrq_InterruptNode_timer0                    = 1U,    /**< \brief XINTR1(Timer 0) */
    IfxScrCpuIrq_InterruptNode_externalInterrupt1        = 2U,    /**< \brief XINTR2(External Interrupt 1) */
    IfxScrCpuIrq_InterruptNode_timer1                    = 3U,    /**< \brief XINTR3(Timer 1) */
    IfxScrCpuIrq_InterruptNode_uart                      = 4U,    /**< \brief XINTR4(UART) */
    IfxScrCpuIrq_InterruptNode_t2ccu_lin                 = 5U,    /**< \brief XINTR5(shared by T2CCU and LIN) */
    IfxScrCpuIrq_InterruptNode_wcan                      = 6U,    /**< \brief XINTR6(WCAN) */
    IfxScrCpuIrq_InterruptNode_adc_ssc                   = 7U,    /**< \brief XINTR7(shared by ADC and SSC) */
    IfxScrCpuIrq_InterruptNode_externalInterrupt2        = 8U,    /**< \brief XINTR8(External Interrupt 2) */
    IfxScrCpuIrq_InterruptNode_externalInterrupt3_4_5_6  = 9U,    /**< \brief XINTR9(shared by External Interrupt 3,External Interrupt 4,External Interrupt 5 and External Interrupt 6) */
    IfxScrCpuIrq_InterruptNode_externalInterrupt7_8_9    = 0xAU,  /**< \brief XINTR10(shared by External Interrupt 7,External Interrupt 8 and External Interrupt 9) */
    IfxScrCpuIrq_InterruptNode_externalInterrupt10_11_12 = 0xBU,  /**< \brief XINTR11(shared by External Interrupt 10,External Interrupt 11 and External Interrupt 12) */
    IfxScrCpuIrq_InterruptNode_externalInterrupt13_14_15 = 0xCU,  /**< \brief XINTR12(shared by External Interrupt 13,External Interrupt 14 and External Interrupt 15) */
    IfxScrCpuIrq_InterruptNode_rtc                       = 0xDU   /**< \brief XINTR13(RTC) */
} IfxScrCpuIrq_InterruptNode;

typedef enum
{
    IfxScrCpuIrq_Interrupts_disable = 0,  /**< \brief Disable the Interrupt */
    IfxScrCpuIrq_Interrupts_enable  = 1   /**< \brief Enable the Interrupt */
} IfxScrCpuIrq_Interrupts;

/** \brief List of different events causing NMI in SCR
 */
typedef enum
{
    IfxScrCpuIrq_NmiSource_watchdogTimer        = 0,  /**< \brief Watchdog Timer NMI */
    IfxScrCpuIrq_NmiSource_ramDoubleBitEccError = 1,  /**< \brief RAM Double Bit ECC Error NMI */
    IfxScrCpuIrq_NmiSource_externalExtnmiPin    = 2,  /**< \brief External NMI from EXTNMI pin */
    IfxScrCpuIrq_NmiSource_ocds                 = 3,  /**< \brief OCDS NMI */
    IfxScrCpuIrq_NmiSource_mainController       = 4,  /**< \brief NMI triggereded in SCR by main controller from PMS */
    IfxScrCpuIrq_NmiSource_wakeUp               = 6   /**< \brief Wake-Up NMI */
} IfxScrCpuIrq_NmiSource;

/** \brief Priority options for interrupt nodes
 */
typedef enum
{
    IfxScrCpuIrq_Priority_0 = 0,  /**< \brief Priority 0(lowest) */
    IfxScrCpuIrq_Priority_1 = 1,  /**< \brief Priority 1 */
    IfxScrCpuIrq_Priority_2 = 2,  /**< \brief Priority 1 */
    IfxScrCpuIrq_Priority_3 = 3   /**< \brief Priority 3(highest) */
} IfxScrCpuIrq_Priority;

/** \brief List of SSC related interrupts
 */
typedef enum
{
    IfxScrCpuIrq_SscInterrupt_error            = 0,  /**< \brief SSC Error Interrupt */
    IfxScrCpuIrq_SscInterrupt_transmit         = 1,  /**< \brief SSC Transmit Interrupt */
    IfxScrCpuIrq_SscInterrupt_receive          = 2,  /**< \brief SSC Receive Interrupt */
    IfxScrCpuIrq_SscInterrupt_receiveFifoEmpty = 3,  /**< \brief SSC Receive FIFO Empty Interrupt */
    IfxScrCpuIrq_SscInterrupt_receiveFifoFull  = 4   /**< \brief SSC Receive FIFO full Interrupt */
} IfxScrCpuIrq_SscInterrupt;

/** \brief List of UART interrupts
 */
typedef enum
{
    IfxScrCpuIrq_UartInterrupt_receive  = 0, /**< \brief UART Receive Interrupt */
    IfxScrCpuIrq_UartInterrupt_transmit = 1  /**< \brief UART Transmit Interrupt */
} IfxScrCpuIrq_UartInterrupt;

typedef enum
{
    IfxScrCpuIrq_ExternalInterruptInput_a = 0,
    IfxScrCpuIrq_ExternalInterruptInput_b = 1,
    IfxScrCpuIrq_ExternalInterruptInput_c = 2,
    IfxScrCpuIrq_ExternalInterruptInput_d = 3
}IfxScrCpuIrq_ExternalInterruptInput;

/** \brief Enumeration for RTC comparator selection
 */
typedef enum
{
    IfxScrCpuIrq_RtcComparator_0 = 0,  /**< \brief RTC comparator 0 */
    IfxScrCpuIrq_RtcComparator_1 = 1   /**< \brief RTC comparator 1 */
} IfxScrCpuIrq_RtcComparator;

/** \brief Enumeration for SCR interrupt to Tricore
 */
typedef enum
{
    IfxScrCpuIrq_ScrInterrupt_0 = 0,  /**< \brief SCR interrupt 0 to main interrupt router */
    IfxScrCpuIrq_ScrInterrupt_1 = 1   /**< \brief SCR interrupt 1 to main interrupt router */
} IfxScrCpuIrq_ScrInterrupt;

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Scr_Cpu_Irq
 * \{ */
/** \brief Read 8 bit data in SCR side from the Tricore side
 * \return 8 -bit data from Tricore side to SCR side
 */
IFX_INLINE uint8 IfxScrCpuIrq_readMessageFromTricore(void);

/** \brief Send 8 bit data from SCR to Tricore
 * \param messageToTricore 8-bit data to be sent to Tricore
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_sendMessageToTricore(uint8 messageToTricore);

/**
 * \param messageToTricore Message or some event code to be passed to the main controller(to it's PMS)
 * \param messageToTricore 8-bit data to be sent to Tricore
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_triggerTricoreInterrupt(uint8 messageToTricore, IfxScrCpuIrq_ScrInterrupt intp);

/**
 * \brief Enable the interrupts globally i.e. all interrupts.
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_enableGlobalInterrupt(void);

/**\brief Disable the interrupts globally i.e. all interrupts.
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_disableGlobalInterrupt(void);

/**\brief Enable the specified interrupt node
 * \param node Interrupt node to be enabled or disabled
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_enableInterruptNode(IfxScrCpuIrq_InterruptNode node);

/**\brief Disable the specified interrupt node
 * \param node Interrupt node to be enabled or disabled
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_disableInterruptNode(IfxScrCpuIrq_InterruptNode node);

/**
 * \param node Interrupt node whose priority is to be set
 * \param priority Priority to be assigned to the node
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_setPriority(IfxScrCpuIrq_InterruptNode node, IfxScrCpuIrq_Priority priority);

/**\brief Enable interrupts for specified interrupt source
 * \param nmiSource NMI source from which interrupts is to be enabled or disabled.
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_enableNmi(IfxScrCpuIrq_NmiSource nmiSource);

/**\brief Disable interrupts for specified interrupt source
 * \param nmiSource NMI source from which interrupts is to be enabled or disabled.
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_disableNmi(IfxScrCpuIrq_NmiSource nmiSource);

/**\brief Disable all NMI interrupts sources
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_disableAllNmiSources(void);

/**\brief Function to check if NMI source enable/disable
 * \param nmiSource NMI source whose enabling is being queried
 * \return None
 */
IFX_INLINE boolean IfxScrCpuIrq_isNmiSourceEnabled(IfxScrCpuIrq_NmiSource nmiSource);

/**\brief Function to get NMI flag status
 * \param nmiSource NMI source
 * \return None
 */
IFX_INLINE boolean IfxScrCpuIrq_getNmiStatus(IfxScrCpuIrq_NmiSource nmiSource);

/**\brief Function to clear NMI status flag
 * \param nmiSource NMI source
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_clearNmiInterruptFlag(IfxScrCpuIrq_NmiSource nmiSource);

/**\brief Function to get External Interrupt Status
 * \param externalInterrupt External Interrupt selection
 * \return None
 */
IFX_INLINE boolean IfxScrCpuIrq_getExternalInterruptStatus(IfxScrCpuIrq_ExternalInterrupt externalInterrupt);

/**\brief Function to clear External Interrupt Status
 * \param externalInterrupt External Interrupt selection
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_clearExternalInterruptFlag(IfxScrCpuIrq_ExternalInterrupt externalInterrupt);

/**\brief Function to select external Interrupt trigger edge
 * \param externalInterrupt External Interrupt selection
 * \param triggerEdgeType Edge selection
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_setExternalInterruptTriggerEdgeType(IfxScrCpuIrq_ExternalInterrupt externalInterrupt, IfxScrCpuIrq_ExternalInterruptTriggerEdge triggerEdgeType);

/**\brief Function to select external Interrupt0/1 trigger edge
 * \param externalInterrupt External Interrupt selection
 * \param triggerType Selection for edge/level triggered
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_setExternalInterrupt01TriggerType(IfxScrCpuIrq_ExternalInterrupt externalInterrupt, IfxScrCpuIrq_ExternalInterruptTriggerType triggerType);

/**\brief Function to select external Interrupt input.
 * \param externalInterrupt External Interrupt selection
 * \param input Selection for external input
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_selectExternalInterruptInput(IfxScrCpuIrq_ExternalInterrupt externalInterrupt, IfxScrCpuIrq_ExternalInterruptInput input);

/**\brief Function to get SSC interrupt status
 * \param sscInterrupt ssc interrupt selection
 * \return None
 */
IFX_INLINE boolean IfxScrCpuIrq_getSscInterruptStatus(IfxScrCpuIrq_SscInterrupt sscInterrupt);

/**\brief Function to clear SSC interrupt status
 * \param sscInterrupt ssc interrupt selection
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_clearSscInterruptFlag(IfxScrCpuIrq_SscInterrupt sscInterrupt);

/**\brief Function to enable/disable SSC interrupt
 * \param sscInterrupt ssc interrupt selection
 * \param enable Enable/Disable
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_enableDisableSscInterruptSource(IfxScrCpuIrq_SscInterrupt sscInterrupt, IfxScrCpuIrq_Interrupts enable);

/**\brief Function to query SSC interrupt enable/disable
 * \param sscInterrupt ssc interrupt selection
 * \return Return Ssc interrupt source enable/disable
 */
IFX_INLINE boolean IfxScrCpuIrq_isSscInterruptSourceEnabled(IfxScrCpuIrq_SscInterrupt sscInterrupt);

/**\brief Function to enable/disable ADC comparator interrupt
 * \param enable Enable/Disable
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_enableDisableAdcCompInterrupt(IfxScrCpuIrq_Interrupts enable);

/**\brief Function to query ADC comparator interrupt enable/disable
 * \return Return True -->  Interrupt enable
 *                False --> Interrupt disable
 */
IFX_INLINE boolean IfxScrCpuIrq_isAdcCompInterruptEnabled(void);

/**\brief Function to clear ADC comparator interrupt flag
* \return None
 */
IFX_INLINE void IfxScrCpuIrq_clearAdcCompInterruptFlag(void);

/**\brief Function to enable/disable RTC compare interrupt
 * \param comp RTC comparator selection
 * \param enable Enable/Disable
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_enableDisableRtcCompareInterrupt(IfxScrCpuIrq_RtcComparator cmp, IfxScrCpuIrq_Interrupts enable);

/**\brief Function to clear RTC compare interrupt
 * \param comp RTC comparator selection
 * \return None
 */
IFX_INLINE void IfxScrCpuIrq_clearRtcCompareInterruptFlag(IfxScrCpuIrq_RtcComparator cmp);

/**\brief Function to get Uart interrupt status
 * \param uartInterrupt Rx/Tx interrupt selection
 * \return Return interrupt status for selection
 */
IFX_INLINE boolean IfxScrCpuIrq_getUartInterruptStatus(IfxScrCpuIrq_UartInterrupt uartInterrupt);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint8 IfxScrCpuIrq_readMessageFromTricore(void)
{
    /* Read the status code/message passed from Tricore */
    SCR_SYSCON0.U  = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x1))
    {}
    return (uint8)SCR_SCU_TCINTEXCHG.U;
}


IFX_INLINE void IfxScrCpuIrq_sendMessageToTricore(uint8 messageToTricore)
{
    /* Write the status code/message to be passed to Tricore*/
    SCR_SYSCON0.U         = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_SCU_PAGE.U        = (SCR_SCU_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    /* TOCHECK : Waiting for the page bit to update.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x1))
    {}
    SCR_SCU_SCRINTEXCHG.U = messageToTricore;
}


IFX_INLINE void IfxScrCpuIrq_triggerTricoreInterrupt(uint8 messageToTricore, IfxScrCpuIrq_ScrInterrupt intp)
{
    /* Setting appropriate RMAP and PAGE values for NMICON*/
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);

    /*wait for any pending acknowledgement from PMS module leading to clearing of NMICON.SCRINTTC bit without which SCRINTEXCG can't be updated*/
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);

    while ((SCR_IR_NMICON.U & (uint8)(1u << IFX_SCR_IR_NMICON_SCRINTTC0_OFF)))
    {}

    /* Write the status code/message to be passed to Tricore*/
    IfxScrCpuIrq_sendMessageToTricore(messageToTricore);

    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);

    /*Trigger the interrupt in Tricore*/
    if (intp == IfxScrCpuIrq_ScrInterrupt_0)
    {
        SCR_IR_NMICON.U = (SCR_IR_NMICON.U | (uint8)(1u << IFX_SCR_IR_NMICON_SCRINTTC0_OFF));
    }
    else
    {
        SCR_IR_NMICON.U = (SCR_IR_NMICON.U | (uint8)(1u << IFX_SCR_IR_NMICON_SCRINTTC1_OFF));
    }
}


IFX_INLINE void IfxScrCpuIrq_enableGlobalInterrupt(void)
{
    SCR_IEN0.U = (SCR_IEN0.U | ((uint8)(1u << IFX_SCR_IEN0_EA_OFF)));
}


IFX_INLINE void IfxScrCpuIrq_disableGlobalInterrupt(void)
{
    SCR_IEN0.U = (SCR_IEN0.U & (uint8)~(1u << IFX_SCR_IEN0_EA_OFF));
}


IFX_INLINE void IfxScrCpuIrq_enableInterruptNode(IfxScrCpuIrq_InterruptNode node)
{
    if (node <= IfxScrCpuIrq_InterruptNode_t2ccu_lin)
    {
        SCR_IEN0.U = ((SCR_IEN0.U & (uint8)(~(1U << node))) | ((uint8)(1U << node)));
    }
    else
    {
        node       = node - IfxScrCpuIrq_InterruptNode_wcan;
        SCR_IEN1.U = (SCR_IEN1.U & (uint8)(~(1 << node))) | (uint8)(1 << (node));
    }
}


IFX_INLINE void IfxScrCpuIrq_disableInterruptNode(IfxScrCpuIrq_InterruptNode node)
{
    if (node <= IfxScrCpuIrq_InterruptNode_t2ccu_lin)
    {
        SCR_IEN0.U = (SCR_IEN0.U & (uint8)(~(1U << node)));
    }
    else
    {
        node       = node - IfxScrCpuIrq_InterruptNode_wcan;
        SCR_IEN1.U = (SCR_IEN1.U & (uint8)(~(1U << node)));
    }
}


IFX_INLINE void IfxScrCpuIrq_setPriority(IfxScrCpuIrq_InterruptNode node, IfxScrCpuIrq_Priority priority)
{
    if (node <= IfxScrCpuIrq_InterruptNode_t2ccu_lin)
    {
        SCR_IP.U  = (SCR_IP.U & ~(1 << node)) | ((priority & 0x1) << node); //extracting 0th bit and placing it at
        SCR_IPH.U = (SCR_IPH.U & ~(1 << node)) | ((priority & 0x2) >> 1) << node;
    }
    else
    {
        node       = node - IfxScrCpuIrq_InterruptNode_wcan;
        SCR_IP1.U  = (SCR_IP1.U & ~(1 << node)) | ((priority & 0x1) << node);
        SCR_IPH1.U = (SCR_IPH1.U & ~(1 << node)) | ((priority & 0x2) >> 1) << node;
    }
}


IFX_INLINE void IfxScrCpuIrq_enableNmi(IfxScrCpuIrq_NmiSource nmiSource)
{
    /* SCU_IR_PAGE = 1 and RMAP=0 */
    SCR_SYSCON0.U   = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U   = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    SCR_IR_NMICON.U = (SCR_IR_NMICON.U | ((uint8)1U << nmiSource));
}


IFX_INLINE void IfxScrCpuIrq_disableNmi(IfxScrCpuIrq_NmiSource nmiSource)
{
    SCR_SYSCON0.U   = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U   = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    SCR_IR_NMICON.U = (SCR_IR_NMICON.U & (~((uint8)1U << nmiSource)));
}


IFX_INLINE void IfxScrCpuIrq_disableAllNmiSources(void)
{
    SCR_SYSCON0.U   = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U   = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    SCR_IR_NMICON.U = 0U;
}


IFX_INLINE boolean IfxScrCpuIrq_isNmiSourceEnabled(IfxScrCpuIrq_NmiSource nmiSource)
{
    boolean status = FALSE;
    /* Setting SYSCON0.RMAP=0 and SCR_IR_PAGE=1 values for NMICON*/
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    status        = (boolean)((SCR_IR_NMICON.U & (1 << nmiSource)) >> nmiSource);
    return status;
}


IFX_INLINE boolean IfxScrCpuIrq_getNmiStatus(IfxScrCpuIrq_NmiSource nmiSource)
{
    boolean status = FALSE;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    status        = (boolean)((SCR_IR_NMISTAT.U & (1 << nmiSource)) >> nmiSource);
    return status;
}


IFX_INLINE void IfxScrCpuIrq_clearNmiInterruptFlag(IfxScrCpuIrq_NmiSource nmiSource)
{
    SCR_SYSCON0.U    = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    SCR_IR_NMISTAT.U = (SCR_IR_NMISTAT.U & (uint8)(~(1 << nmiSource)));
}


IFX_INLINE boolean IfxScrCpuIrq_getExternalInterruptStatus(IfxScrCpuIrq_ExternalInterrupt externalInterrupt)
{
    boolean status = FALSE;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U);

    if (externalInterrupt == IfxScrCpuIrq_ExternalInterrupt_0)
    {
        status = (boolean)((SCR_T01_TCON.U & (1u << IFX_SCR_T01_TCON_IE0_OFF)) >> IFX_SCR_T01_TCON_IE0_OFF);
    }
    else if (externalInterrupt == IfxScrCpuIrq_ExternalInterrupt_1)
    {
        status = (boolean)((SCR_T01_TCON.U & (1u << IFX_SCR_T01_TCON_IE1_OFF)) >> IFX_SCR_T01_TCON_IE1_OFF);
    }
    else if ((externalInterrupt > IfxScrCpuIrq_ExternalInterrupt_1) && (externalInterrupt < IfxScrCpuIrq_ExternalInterrupt_8))
    {
        status = (boolean)((SCR_IR_CON0.U & (1u << externalInterrupt)) >> externalInterrupt);
    }
    else
    {
        status = (boolean)((SCR_IR_CON2.U & (1u << (externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_8))) >> (externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_8));
    }

    return status;
}


IFX_INLINE void IfxScrCpuIrq_clearExternalInterruptFlag(IfxScrCpuIrq_ExternalInterrupt externalInterrupt)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U);

    if (externalInterrupt == IfxScrCpuIrq_ExternalInterrupt_0)
    {
        SCR_T01_TCON.U = (SCR_T01_TCON.U & (uint8)~(1u << IFX_SCR_T01_TCON_IE0_OFF));
    }
    else if (externalInterrupt == IfxScrCpuIrq_ExternalInterrupt_1)
    {
        SCR_T01_TCON.U = (SCR_T01_TCON.U & (uint8)~(1u << IFX_SCR_T01_TCON_IE1_OFF));
    }
    else if ((externalInterrupt > IfxScrCpuIrq_ExternalInterrupt_1) && (externalInterrupt < IfxScrCpuIrq_ExternalInterrupt_8))
    {
        SCR_IR_CON0.U = (SCR_IR_CON0.U & (uint8)~(1u << externalInterrupt));
    }
    else
    {
        SCR_IR_CON2.U = (SCR_IR_CON2.U & (uint8)~(1u << (externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_8)));
    }
}


IFX_INLINE void IfxScrCpuIrq_setExternalInterruptTriggerEdgeType(IfxScrCpuIrq_ExternalInterrupt externalInterrupt, IfxScrCpuIrq_ExternalInterruptTriggerEdge triggerEdgeType)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFEU);

    if (externalInterrupt <= IfxScrCpuIrq_ExternalInterrupt_3)
    {
        SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x02u);
        SCR_IR_EXICON0.U = (SCR_IR_EXICON0.U & (uint8)(~(IFX_SCR_IR_EXICON0_EXINT0_MSK << (externalInterrupt * 2u)))) | (uint8)(triggerEdgeType << (externalInterrupt * 2u));
    }
    else if (externalInterrupt <= IfxScrCpuIrq_ExternalInterrupt_7)
    {
        SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x02u);
        SCR_IR_EXICON1.U = (SCR_IR_EXICON1.U & (uint8)(~(IFX_SCR_IR_EXICON1_EXINT4_MSK << ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_4) * 2u)))) | (uint8)(triggerEdgeType << ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_4) * 2u));
    }
    else if (externalInterrupt <= IfxScrCpuIrq_ExternalInterrupt_11)
    {
        SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x02u);
        SCR_IR_EXICON2.U = (SCR_IR_EXICON2.U & (uint8)(~(IFX_SCR_IR_EXICON2_EXINT8_MSK << ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_8) * 2u)))) | (uint8)(triggerEdgeType << ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_8) * 2u));
    }
    else
    {
        SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x03u);
        SCR_IR_EXICON3.U = (SCR_IR_EXICON3.U & (uint8)(~(IFX_SCR_IR_EXICON3_EXINT12_MSK << ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_12) * 2u)))) | (uint8)(triggerEdgeType << ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_12) * 2u));
    }
}


IFX_INLINE void IfxScrCpuIrq_setExternalInterrupt01TriggerType(IfxScrCpuIrq_ExternalInterrupt externalInterrupt, IfxScrCpuIrq_ExternalInterruptTriggerType triggerType)
{
    if (externalInterrupt == IfxScrCpuIrq_ExternalInterrupt_0)
    {
        SCR_T01_TCON.U = ((SCR_T01_TCON.U & (uint8)~(1u << IFX_SCR_T01_TCON_IT0_OFF)) | (uint8)triggerType);
    }

    else if (externalInterrupt == IfxScrCpuIrq_ExternalInterrupt_1)
    {
        SCR_T01_TCON.U = ((SCR_T01_TCON.U & (uint8)~(1u << IFX_SCR_T01_TCON_IT1_OFF)) | (uint8)(triggerType << IFX_SCR_T01_TCON_IT1_OFF));
    }
}

IFX_INLINE void IfxScrCpuIrq_selectExternalInterruptInput(IfxScrCpuIrq_ExternalInterrupt externalInterrupt, IfxScrCpuIrq_ExternalInterruptInput input)
{
	/* Set RMAP to 0 */
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFEU);
    uint8 shift = 0u;

    if (externalInterrupt <= IfxScrCpuIrq_ExternalInterrupt_2)
    {
        SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x04u);
        shift           = ((externalInterrupt * 2u) + 2u);
        SCR_IR_PISEL0.U = (SCR_IR_PISEL0.U & (uint8)(~(IFX_SCR_IR_PISEL0_EXINT0IS_MSK << shift))) | (uint8)(input << shift);
    }
    else if (externalInterrupt <= IfxScrCpuIrq_ExternalInterrupt_6)
    {
    	/* Assert error if Input EXTINTxD selected */
    	IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (input != IfxScrCpuIrq_ExternalInterruptInput_d));

    	SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x04u);
    	shift            = ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_3) * 2u);
    	SCR_IR_PISEL1.U = (SCR_IR_PISEL1.U & (uint8)(~(IFX_SCR_IR_PISEL1_EXINT3_T2CCU0CH0_IS_MSK << shift))) | (uint8)(input << shift);
    }
    else if (externalInterrupt <= IfxScrCpuIrq_ExternalInterrupt_11)
    {
    	if(externalInterrupt != IfxScrCpuIrq_ExternalInterrupt_7)
    	{
        	/* Assert error if Input EXTINTxD selected */
        	IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (input != IfxScrCpuIrq_ExternalInterruptInput_d));

        	SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x04u);
        	shift            = ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_8) * 2u);
        	SCR_IR_PISEL2.U = (SCR_IR_PISEL2.U & (uint8)(~(IFX_SCR_IR_PISEL2_EXINT8_T2CCU1CH0_IS_MSK << shift))) | (uint8)(input << shift);
    	}
    	else
    	{
        	/* Assert error if External interrupt 7 selected */
        	IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (externalInterrupt != IfxScrCpuIrq_ExternalInterrupt_7));
    	}
    }
    else
    {
    	/* Assert error if Input EXTINTxD selected */
    	IFX_ASSERT(IFX_VERBOSE_LEVEL_ERROR, (input != IfxScrCpuIrq_ExternalInterruptInput_d));

    	SCR_IR_PAGE.U    = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x05u);
    	shift            = ((externalInterrupt - IfxScrCpuIrq_ExternalInterrupt_12) * 2u);
    	SCR_IR_PISEL3.U = (SCR_IR_PISEL3.U & (uint8)(~(IFX_SCR_IR_PISEL3_EXINT12IS_MSK << shift))) | (uint8)(input << shift);
    }
}

IFX_INLINE boolean IfxScrCpuIrq_getSscInterruptStatus(IfxScrCpuIrq_SscInterrupt sscInterrupt)
{
    boolean status = FALSE;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFEU);
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U);
    status        = ((SCR_IR_CON1.U & (uint8)(1u << sscInterrupt)) >> sscInterrupt);
    return status;
}


IFX_INLINE void IfxScrCpuIrq_clearSscInterruptFlag(IfxScrCpuIrq_SscInterrupt sscInterrupt)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFEU);
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U);
    SCR_IR_CON1.U = (SCR_IR_CON1.U & ~(1u << sscInterrupt));
}


IFX_INLINE void IfxScrCpuIrq_enableDisableSscInterruptSource(IfxScrCpuIrq_SscInterrupt sscInterrupt, IfxScrCpuIrq_Interrupts enable)
{
    SCR_SYSCON0.U   = (SCR_SYSCON0.U & (uint8)(0xFE));
    SCR_IR_PAGE.U   = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    SCR_IR_MODIEN.U = (SCR_IR_MODIEN.U & (uint8)(~(1 << sscInterrupt))) | (uint8)(enable << sscInterrupt);
}


IFX_INLINE boolean IfxScrCpuIrq_isSscInterruptSourceEnabled(IfxScrCpuIrq_SscInterrupt sscInterrupt)
{
    boolean status = FALSE;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U = ((SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)0x01);
    status        = (uint8)((SCR_IR_MODIEN.U & (uint8)(1u << sscInterrupt)) >> sscInterrupt);
    return status;
}


IFX_INLINE void IfxScrCpuIrq_enableDisableAdcCompInterrupt(IfxScrCpuIrq_Interrupts enable)
{
    SCR_SYSCON0.U   = (SCR_SYSCON0.U & (uint8)(0xFE));
    SCR_IR_PAGE.U   = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);
    SCR_IR_MODIEN.U = (SCR_IR_MODIEN.U & (uint8)(~(1 << IFX_SCR_IR_MODIEN_ADCIEN_OFF))) | (uint8)(enable << IFX_SCR_IR_MODIEN_ADCIEN_OFF);
}


IFX_INLINE boolean IfxScrCpuIrq_isAdcCompInterruptEnabled(void)
{
    boolean status = FALSE;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_IR_PAGE.U = ((SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)0x01);
    status        = (uint8)((SCR_IR_MODIEN.U & (uint8)(1u << IFX_SCR_IR_MODIEN_ADCIEN_OFF)) >> IFX_SCR_IR_MODIEN_ADCIEN_OFF);
    return status;
}

IFX_INLINE void IfxScrCpuIrq_clearAdcCompInterruptFlag(void)
{
    SCR_SYSCON0.U = (SCR_SYSCON0.U & (uint8)(0xFE));
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U);
    SCR_IR_CON1.B.ADCIR = 0U;
}

IFX_INLINE void IfxScrCpuIrq_enableDisableRtcCompareInterrupt(IfxScrCpuIrq_RtcComparator cmp, IfxScrCpuIrq_Interrupts enable)
{
    SCR_SYSCON0.U = (SCR_SYSCON0.U & (uint8)(0xFE));
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U) | (uint8)(0x01);

    if (cmp == IfxScrCpuIrq_RtcComparator_0)
    {
        SCR_IR_MODIEN.U = (SCR_IR_MODIEN.U & (uint8)(~(1 << IFX_SCR_IR_MODIEN_CMP0IEN_OFF))) | (uint8)(enable << IFX_SCR_IR_MODIEN_CMP0IEN_OFF);
    }
    else
    {
        SCR_IR_MODIEN.U = (SCR_IR_MODIEN.U & (uint8)(~(1 << IFX_SCR_IR_MODIEN_CMP1IEN_OFF))) | (uint8)(enable << IFX_SCR_IR_MODIEN_CMP1IEN_OFF);
    }
}

IFX_INLINE void IfxScrCpuIrq_clearRtcCompareInterruptFlag(IfxScrCpuIrq_RtcComparator cmp)
{
    SCR_SYSCON0.U = (SCR_SYSCON0.U & (uint8)(0xFE));
    SCR_IR_PAGE.U = (SCR_IR_PAGE.U & (uint8)0xF8U);

    if(cmp == IfxScrCpuIrq_RtcComparator_0)
    {
    	SCR_IR_CON1.B.CMP0IR = 0U;
    }
    else
    {
    	SCR_IR_CON1.B.CMP1IR = 0U;
    }
}

IFX_INLINE boolean IfxScrCpuIrq_getUartInterruptStatus(IfxScrCpuIrq_UartInterrupt uartInterrupt)
{
    boolean status = FALSE;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFEU);
    status        = (uint8)((SCR_UART_SCON.U & (uint8)(1u << uartInterrupt)) >> (uartInterrupt));
    return status;
}


#endif /* IFXSCRCPUIRQ_H */
