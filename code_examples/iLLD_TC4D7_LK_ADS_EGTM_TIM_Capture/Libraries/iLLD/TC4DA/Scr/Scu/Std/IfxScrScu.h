/**
 * \file IfxScrScu.h
 * \brief SCR Clock and interrupt functionality
 * \ingroup IfxLld_Scr
 *
 * \version iLLD-TC4-v2.2.0
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * \defgroup IfxLld_Scr_Scu SCU
 * \ingroup IfxLld_Scr
 * \defgroup IfxLld_Scr_Scu_Enumerations Enum
 * \ingroup IfxLld_Scr_Scu
 * \defgroup IfxLld_Scr_Scu_DataStructures Data Structures
 * \ingroup IfxLld_Scr_Scu
 * \defgroup IfxLld_Scr_Scu_Reset Reset Functionality
 * \ingroup IfxLld_Scr_Scu
 * \defgroup IfxLld_Scr_Scu_Watchdog Watchdog Functionality
 * \ingroup IfxLld_Scr_Scu
 * \defgroup IfxLld_Scr_Scu_Power Power management Functionality
 * \ingroup IfxLld_Scr_Scu
 * \defgroup IfxLld_Scr_Scu Module Functionality
 * \ingroup IfxLld_Scr_Scu
 * \defgroup IfxLld_Scr_Scu_Pms_Rtc Pms Rtc calibration functionality
 * \ingroup IfxLld_Scr_Scu
 */

#ifndef IFXSCRSCU_H
#define IFXSCRSCU_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/
#include "Cpu/Std/Ifx_Types.h" //For AgenTiX
#include "_Impl/IfxScrScu_cfg.h"
#include "_Reg/IfxScr_bf.h"
#include "_Reg/IfxScr_reg.h"

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Scr_Scu_Enumerations
 * \{ */
/** \brief Enumeration for Clock divider values to be entered in SCU_CLK.DIV_REQ
 */

typedef enum
{
    IfxScrScu_DivideFactor_1     = 0,        /**< \brief fSYS = 100 MHz */
    IfxScrScu_DivideFactor_2     = 1,        /**< \brief fSYS = 50 MHz */
    IfxScrScu_DivideFactor_3     = 2,        /**< \brief fSYS = 33.3 MHz */
    IfxScrScu_DivideFactor_4     = 3,        /**< \brief fSYS = 25 MHz */
    IfxScrScu_DivideFactor_5     = 4,        /**< \brief fSYS = 20 MHz (default) */
    IfxScrScu_DivideFactor_8     = 5,        /**< \brief fSYS = 12.5 MHz */
    IfxScrScu_DivideFactor_10    = 6,        /**< \brief fSYS = 10 MHz */
    IfxScrScu_DivideFactor_16    = 7,        /**< \brief fSYS = 6.25 MHz */
    IfxScrScu_DivideFactor_20    = 8,        /**< \brief fSYS = 5 MHz */
    IfxScrScu_DivideFactor_32    = 9,        /**< \brief fSYS = 3.125 MHz */
    IfxScrScu_DivideFactor_50    = 0xA,      /**< \brief fSYS = 2 MHz */
    IfxScrScu_DivideFactor_80    = 0xB,      /**< \brief fSYS = 1.25 MHz */
    IfxScrScu_DivideFactor_100   = 0xC,      /**< \brief fSYS = 1 MHz */
    IfxScrScu_DivideFactor_160   = 0xD,      /**< \brief fSYS = 0.625 MHz */
    IfxScrScu_DivideFactor_200   = 0xE,      /**< \brief fSYS = 0.5 MHz */
    IfxScrScu_DivideFactor_70Khz = 0xF       /**< \brief fSYS = 70 kHz */
}IfxScrScu_DivideFactor;

/*TODO To remove since A3g HSI does not have OSCPD bit */
/** \brief Clock source for SCR to be chosen in SCU_CMCON.OSCPD
 */

typedef enum
{
    IfxScrScu_StandbyClockSource_70kHz  = 0, /**< \brief Power down 100MHz clock in standby, thus chosing the 70kHz as SCR clock */
    IfxScrScu_StandbyClockSource_100MHz = 1, /**< \brief Keep the 100MHz clock running even when Tricore enters Standby */
}IfxScrScu_StandbyClockSource;

/** \brief Types of Generated Reset sources
 */

typedef enum
{
    IfxScrScu_GeneratedReset_doubleBitECC = 0,      /**< \brief Double bit ECC generated reset */
    IfxScrScu_GeneratedReset_watchdog     = 1,      /**< \brief Watchdog timer generated reset */
    IfxScrScu_GeneratedReset_pinReset     = 2,      /**< \brief PIN Reset */
    IfxScrScu_GeneratedReset_software     = 4       /**< \brief Software timer generated reset */
}IfxScrScu_GeneratedReset;

/** \brief Types of Main Reset(i.e. SCR reset triggered from Main controller(Tricore)) sources
 */

typedef enum
{
    IfxScrScu_MainReset_smu         = 0,
    IfxScrScu_MainReset_application = 1
}IfxScrScu_MainReset;

/** \brief Enumeration for SCR modules
 */
typedef enum
{
    IfxScrScu_Module_ssc      = 0,           /**< \brief SSC module */
    IfxScrScu_Module_rtc      = 1,           /**< \brief RTC module */
    IfxScrScu_Module_wcan     = 2,           /**< \brief WCAN module */
    IfxScrScu_Module_watchdog = 3,           /**< \brief WDT module */
    IfxScrScu_Module_lin      = 4,           /**< \brief LIN module */
    IfxScrScu_Module_t2ccu0   = 5,           /**< \brief T2CCU0 module */
    IfxScrScu_Module_t2ccu1   = 6,           /**< \brief T2CCU1 module */
    IfxScrScu_Module_ocds     = 7,           /**< \brief OCDS module */
    IfxScrScu_Module_i2c      = 8            /**< \brief I2C module */
}IfxScrScu_Module;

/** \brief Enumeration for SCR debug suspend modules
 */
typedef enum
{
	IfxScrScu_SuspendModule_wdt      = 0,           /**< \brief SSC module */
	IfxScrScu_SuspendModule_rtc      = 1,           /**< \brief RTC module */
	IfxScrScu_SuspendModule_t2ccu0   = 2,           /**< \brief T2CCU0 module */
	IfxScrScu_SuspendModule_t2ccu1   = 3            /**< \brief T2CCU1 module */
}IfxScrScu_SuspendModule;

/** \brief Enumeration describing the status of an operation
 */
typedef enum
{
	IfxScrScu_Status_success = 0,  /**< \brief operation successful */
	IfxScrScu_Status_failure = 1   /**< \brief operation failed */
} IfxScrScu_Status;

/** \brief Enumeration for SCR wakeup sources
 */
typedef enum
{
    IfxScrScu_WakeupEvent_rtcCompareMatch = 0,     /**< \brief Wakeup on RTC compare match  */
    IfxScrScu_WakeupEvent_wcanWuf         = 1,     /**< \brief Wakeup on WCAN wuf event  */
    IfxScrScu_WakeupEvent_watchdog        = 2,     /**< \brief Wakeup on watchdog event  */
    IfxScrScu_WakeupEvent_ramEccError     = 3,     /**< \brief Wakeup on SRAM ECC double bit error  */
    IfxScrScu_WakeupEvent_softwareRequest = 4      /**< \brief Wakeup on software request  */
}IfxScrScu_WakeupEvent;

/** \brief Enumeration for SCR power sources
 */
typedef enum
{
    IfxScrScu_PowerSource_evr13 = 0,
    IfxScrScu_PowerSource_evr33 = 1,
    IfxScrScu_PowerSource_ext   = 2
}IfxScrScu_PowerSource;

/** \brief Clock source for Watchdog Timer to be chosen in WDT_CON.WDTCLK
 */

typedef enum
{
    IfxScrScu_WatchdogClockSource_70kHz = 0,
    IfxScrScu_WatchdogClockSource_xMHz  = 1
}IfxScrScu_WatchdogClockSource;

/** \brief Clock divider for Watchdog Timer clock source to be chosen in WDT_CON.WDTIN
 * This is only if 70kHz is not chosed as the watchdog timer clock source
 */

typedef enum
{
    IfxScrScu_WatchdogClockDivider_2   = 0,
    IfxScrScu_WatchdogClockDivider_128 = 1
}IfxScrScu_WatchdogClockDivider;

/** \brief Storage Register list to be used during auto saving of page number.
 *
 */

typedef enum
{
    IfxScrScu_StorageNumber_0  = 0, /**< \brief ST0 is selected for saving page number*/
    IfxScrScu__StorageNumber_1 = 1, /**< \brief ST1 is selected for saving page number*/
    IfxScrScu__StorageNumber_2 = 2, /**< \brief ST2 is selected for saving page number*/
    IfxScrScu__StorageNumber_3 = 3  /**< \brief ST3 is selected for saving page number*/
}IfxScrScu_StorageNumber;

/** \brief Enumeration for modes of SCR
 */
typedef enum
{
    IfxScrScu_Mode_70kHz        = 0,    /**< \brief SCR operating in 70Khz*/
    IfxScrScu_Mode_100MHz       = 1,    /**< \brief SCR operating in 100Mhz*/
    IfxScrScu_Mode_100MHzAdcomp = 2     /**< \brief SCR operating in 100Mhz and ADCOMP enabled*/
}IfxScrScu_Mode;
/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Scr_Scu_DataStructures
 * \{ */
/** \brief RTC 64 bit timer capture
 */
typedef struct
{
    uint32 lowerPart;       /**< \brief Lower 32 bit timer capture value */
    uint32 upperPart;       /**< \brief Upper 32 bit timer capture value */
} IfxScrScu_RtcTImerValue;

/** \} */

/** \addtogroup IfxLld_Scr_Scu
 * \{ */
/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to enable bit protection scheme(PASSWD.MODE = 11b)
 *  \return none
 */
IFX_INLINE void IfxScrScu_enableBitProtectionScheme(void);

/** \brief Function to disable bit protection scheme(PASSWD.MODE = 00b)
 *  \return none
 */
IFX_INLINE void IfxScrScu_disableBitProtectionScheme(void);

/** \brief Function to enable write to protected bits.
 *  \return none
 */
IFX_INLINE void IfxScrScu_enableBitProtectedWriteAccess(void);

/** \brief Function to disable write to protected bits.
 *  \return none
 */
IFX_INLINE void IfxScrScu_disableBitProtectedWriteAccess(void);

/** \brief Returns clock source used for SCR in Standby mode
 * \return  Returns clock source used for SCR in Standby mode
 */

IFX_INLINE IfxScrScu_StandbyClockSource IfxScrScu_getStandbyClockSource(void);

/** \brief Function to get clock divider status
 * \return Returns clock divider value
 */
IFX_INLINE IfxScrScu_DivideFactor IfxScrScu_getClockDivider(void);

/** \brief Sets the clock divider
 * \param divider Divider value
 * \return None
 */
IFX_INLINE void IfxScrScu_setClockDivider(IfxScrScu_DivideFactor divider);

/** \brief Function to restore the Page
 *  \return none
 */
IFX_INLINE void IfxScrScu_restorePageValue(void);

/** \brief Function to autosave the Page
 *  \return none
 */
IFX_INLINE void IfxScrScu_enableAutoSavePageValue(void);

/** \brief Function to set the storage number to save the page setting.
 *  \return none
 */
IFX_INLINE void IfxScrScu_selectPageStorageRegisters(IfxScrScu_StorageNumber stnr);

/** \addtogroup IfxLld_Scr_Scu_Reset
 * \{ */
/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Enable/Disable generated reset
 * \param generatedReset Generated reset selection
 * \param enable Enable/Disable
 * \return None
 */
IFX_INLINE void IfxScrScu_enableDisableGeneratedInterrupt(IfxScrScu_GeneratedReset generatedReset, Ifx_Functionality enable);

/** \brief Enables a particular generated reset source to reset SCR
 * \param generatedReset Generated Reset source
 * \return None
 */
IFX_INLINE void IfxScrScu_enableGeneratedReset(IfxScrScu_GeneratedReset generatedReset);

/** \brief Disables a particular generated reset source to reset SCR
 * \param generatedReset Generated Reset source
 * \return None
 */
IFX_INLINE void IfxScrScu_disableGeneratedReset(IfxScrScu_GeneratedReset generatedReset);

/** \brief Disables all generated reset sources to reset SCR
 * \return None
 */
IFX_INLINE void IfxScrScu_disableAllGeneratedReset(void);

/** \brief Triggers software reset to SCR
 * \return None
 */
IFX_INLINE void IfxScrScu_generateSoftwareReset(void);

/** \brief Queries the status of occurence of SCR reset due to particular generated reset source
 * \param generatedReset Generated Reset source
 * \return Returns whether reset has occured or not
 */
IFX_INLINE boolean IfxScrScu_hasGeneratedResetOccured(IfxScrScu_GeneratedReset generatedReset);

/** \brief Clears the reset flag for particular generated reset source
 * \param generatedReset Generated Reset source
 * \return None
 */
IFX_INLINE void IfxScrScu_clearGeneratedResetFlag(IfxScrScu_GeneratedReset generatedReset);

/** \brief Clears the reset flags for all generated reset sources
 * \return None
 */
IFX_INLINE void IfxScrScu_clearAllGeneratedResetFlags(void);

/** \brief Queries the status of occurence of SCR reset triggered by Tricore(PMS or SMU)(aka Main Reset).
 * \param mainReset Main Reset source. Options are IfxScrScu_MainReset_smu and IfxScrScu_MainReset_application(PMS)
 * \return Returns whether main reset has occured or not
 */
IFX_INLINE boolean IfxScrScu_hasMainResetOccured(IfxScrScu_MainReset mainReset);

/** \brief Clears the status flags associated with occurence of SCR reset triggered by Tricore(PMS or SMU)(aka Main Reset).
 * \param mainReset Main Reset source. Options are IfxScrScu_MainReset_smu and IfxScrScu_MainReset_application(PMS)
 * \return None
 */
IFX_INLINE void IfxScrScu_clearMainResetFlag(IfxScrScu_MainReset mainReset);

/** \brief Clears the status flags associated with all sources of Main reset(PMS and SMU).
 * \return None
 */
IFX_INLINE void IfxScrScu_clearAllMainResetFlags(void);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Scr_Scu_Power
 * \{ */

/** \brief Disable the usage of the specified module
 *  \param module Module name.Options are:
 *                IfxScrScu_Module_ssc
 *                IfxScrScu_Module_t2ccu
 *                IfxScrScu_Module_rtc
 *                IfxScrScu_Module_wcan
 *                IfxScrScu_Module_watchdog
 *                IfxScrScu_Module_lin
 *                IfxScrScu_Module_ocds
 *  \return None
 */
IFX_INLINE void IfxScrScu_disableModule(IfxScrScu_Module module);

/** \brief Disable the usage of all SCR modules
 *  \return None
 */
IFX_INLINE void IfxScrScu_disableAllModules(void);

/** \brief Enable the usage of the specified module
 *  \param module Module name.Options are:
 *                IfxScrScu_Module_ssc
 *                IfxScrScu_Module_t2ccu
 *                IfxScrScu_Module_rtc
 *                IfxScrScu_Module_wcan
 *                IfxScrScu_Module_watchdog
 *                IfxScrScu_Module_lin
 *                IfxScrScu_Module_ocds
 *  \return None
 */
IFX_INLINE void IfxScrScu_enableModule(IfxScrScu_Module module);

/** \brief Enable the usage of all SCR modules
 *  \return None
 */
IFX_INLINE void IfxScrScu_enableAllModules(void);

/** \brief Enable Tricore wakeup on the occurence of specified event
 * \param event Event Name.Options are:
 *              IfxScrScu_WakeupEvent_rtcCompareMatch
 *              IfxScrScu_WakeupEvent_wcanWuf /
 *              IfxScrScu_WakeupEvent_watchdog
 *              IfxScrScu_WakeupEvent_ramEccError
 * \return None
 */
IFX_INLINE void IfxScrScu_enableTricoreWakeupEvent(IfxScrScu_WakeupEvent event);

/** \brief Disable Tricore wakeup on the occurence of specified event
 * \param event Event Name.Options are:
 *              IfxScrScu_WakeupEvent_rtcCompareMatch
 *              IfxScrScu_WakeupEvent_wcanWuf /
 *              IfxScrScu_WakeupEvent_watchdog
 *              IfxScrScu_WakeupEvent_ramEccError
 * \return None
 */
IFX_INLINE void IfxScrScu_disableTricoreWakeupEvent(IfxScrScu_WakeupEvent event);

/** \brief Queries if Tricore side is in Standby Mode
 *  \return True --> System is in standby1 mode
 *          False --> System is in run mode
 */
IFX_INLINE boolean IfxScrScu_isTricoreInStandby(void);

/** \brief Function to get SCR state.
 *  \return none
 */
IFX_INLINE IfxScrScu_Mode IfxScrScu_getScrMode(void);

/** \brief Function to enter idle mode
 * \return none
 */
IFX_INLINE void IfxScrScu_enterIdleMode(void);

/** \brief Function to request entry to standby 0 state.
 * Note : To request entry to standby 0 state via SCR, transition should be enabled inside PMS via PMS_STANDBY_CON0.SCRSTBY0EN ='1'.
 * Transition will only take place if system is in standby 1 state.
 * \return Return
 * IfxScrScu_Status_success request successful
 * IfxScrScu_Status_failure request failed. SCR not in standby 1 state.
 */
IFX_INLINE IfxScrScu_Status IfxScrScu_requestStby1ToStby0Transititon(void);

/** \brief Function to clear wakeup flags in PMS.
 * Note : Clearing will take part only if enabled inside PMS with PMS_WAKEUP_CON0.
 * \return none
 */
IFX_INLINE void IfxScrScu_clearPmsWakeupFlags(void);

/** \brief Function to suspend module when OCDS is in monitor mode.
 *  \param module Selection of module to be suspended.
 * \return none
 */
IFX_INLINE void IfxScrScu_suspendModule(IfxScrScu_SuspendModule module);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to switch SCR state.
 *         Function is intended to be called when tricore is in stanby mode.
 * Note: 1. Transition from Standby 70Khz to Standby 100Mhz.
 *          Clock divider will be set to 20Mhz default with clock divider value 4.
 *       2. Transition from Standby 100Mhz to Standby100Mhz + ADCOMP.
 *          Clock divider value will be retained only ADCOMP will be enabled.
 *       3. Transition from Standby 100Mhz to Standby 70Khz
 *          Clock divider value will be set to 70Khz. ADCOMP will be disabled.
 * \param mode SCR mode selection
 *  \return TRUE --> Scr mode switch is successful
 *          FALSE --> SCR mode switch failed. Tricore is in Run mode
 */
IFX_INLINE boolean IfxScrScu_switchScrMode(IfxScrScu_Mode mode);

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Scr_Scu_Watchdog
 * \{ */
/** \brief Function to service watchdog
 * \param Reload value
 * \return None
 */
IFX_INLINE void IfxScrScu_serviceWatchdog(unsigned char reloadValue);

/** \brief Function to configure watchdog clock
 * \param clockSource watchdog clock source 70khz.xMhz
 * \param divider clock divider
 * \return None
 */
IFX_INLINE void IfxScrScu_configureWatchdogClock(IfxScrScu_WatchdogClockSource clockSource, IfxScrScu_WatchdogClockDivider divider);

/** \brief Function to enable watchdog timer
 * \return None
 */
IFX_INLINE void IfxScrScu_enableWatchdog(void);

/** \brief Function to disable watchdog timer
 * \return None
 */
IFX_INLINE void IfxScrScu_disableWatchdog(void);

/** \brief Function to check for watchdog overflow
 * \return True --> Watchdog overflow occured
 *         False --> Normal mode. No overflow
 */
IFX_INLINE boolean IfxScrScu_hasWatchdogOverflowOccured(void);

/** \brief Function to get watchdog counter value
 * \return Returns 16 bit watchdog counter value.
 */
IFX_INLINE uint16 IfxScrScu_getWatchdogCounterValue(void);

/** \brief Function to get watchdog counter high value
 * \return Returns 8 bit watchdog counter high value.
 */
IFX_INLINE uint8 IfxScrScu_getWatchdogCounterHighValue(void);

/** \brief Function to enable watchdog boundary
 * \return none
 */
IFX_INLINE void IfxScrScu_enableWatchdogWindowBoundary(void);

/** \brief Function to disable watchdog boundary
 * \return none
 */
IFX_INLINE void IfxScrScu_disableWatchdogWindowBoundary(void);

/** \brief Function to set watchdog boundary value
 * \return none
 */
IFX_INLINE void IfxScrScu_setWatchdogWindowBoundaryValue(uint8 boundaryValue);

/** \brief Function to configure watchdog boundary
** \param enable Functionality enable/disable
** \param boundaryValue Boundary value
* \return none
*/
IFX_INLINE void IfxScrScu_configureWatchdogWindowBoundary(Ifx_Functionality enable, unsigned char boundaryValue);

/** \brief Function to refresh watchdog timer.
 * \return none
 */
IFX_INLINE void IfxScrScu_refreshWatchdog(void);

/** \brief Function to refresh watchdog timer.
 * \return none
 */
IFX_INLINE boolean IfxScrScu_getWatchdogPrewarningStatus(void);

/** \brief Function to set watchdog reload value.
 * \return none
 */
IFX_INLINE void IfxScrScu_setWatchdogReloadValue(unsigned char reloadValue);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_Scr_Scu_Pms_Rtc
 * \{ */
/** \brief Function to Pms Rtc timer value
 * \return Upper 32 bits of PMS Rtc timer
 */
IFX_INLINE IfxScrScu_RtcTImerValue IfxScrScu_readPmsRtcTimer(void);

/** \brief Function to set PMS Rtc offset
 * \param offsetValue Signed Offset correction value for RTC trimming (PMS RTC OFFSET)
 * \return None
 */
IFX_INLINE void IfxScrScu_setPmsRtcOffset(uint16 offsetValue);

/** \brief Function to set PMS Rtc compare value
 * \param cmpValue Compare value for PMS RTC CMP1
 * \return None
 */
IFX_INLINE void IfxScrScu_setPmsRtcCompareValue(uint32 cmpValue);

/** \brief Function to set PMS Rtc Msize1 value
 * \param value value to be written in PMS_RTC_CON2.MSIZE1 bit-field.
 * \return None
 */
IFX_INLINE void IfxScrScu_setPmsRtcMsizeValue(uint8 value);

/** \brief Function to set PMS Rtc Mstart1 value
 * \param value value to be written in PMS_RTC_CON2.MSTART1 bit-field.
 * \return None
 */
IFX_INLINE void IfxScrScu_setPmsRtcMstartValue(uint8 value);

/** \brief Function to enable Pms Dts
 * \return None
 */
IFX_INLINE void IfxScrScu_enablePmsDts(void);

/** \brief Function to query Pms Dts
 * \return True PMS Dts is ready/ completed startup
 *         FALSE PMS DTS is busy or disabled
 */
IFX_INLINE boolean IfxScrScu_isPmsDtsEnabled(void);

/** \brief Function to read PMS DTS value
 * \return 12 bit PMS Dts value
 */
IFX_INLINE uint16 IfxScrScu_readPmsDtsValue(void);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to calibrate PMS Rtc
 * \param cmpValue RTC compare value to be set
 * \return None
 */
IFX_INLINE void IfxScrScu_calibratePmsRtc(uint32 cmpValue);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScrScu_enableBitProtectionScheme(void)
{
    SCR_PASSWD.U = 0xC3;
}


IFX_INLINE void IfxScrScu_disableBitProtectionScheme(void)
{
    SCR_PASSWD.U = 0xC0;
}


//Also modify the functions which are protected with Bit Protection Scheme - CMCON,RSTCON,WDTCON,RTC reg(CNT0-CNT3)

IFX_INLINE void IfxScrScu_enableDisableBitProtection(Ifx_Functionality enable)
{
    //clear PASS and MODE fields and write apt values
    if (enable == Ifx_Functionality_enable)
    {
        SCR_PASSWD.U = ((SCR_PASSWD.U & (unsigned char)(1u << IFX_SCR_PASSWD_PROTECT_S_OFF)) | (0x18 << IFX_SCR_PASSWD_PASS_OFF) | (0x3));
    }
    else
    {
        SCR_PASSWD.U = ((SCR_PASSWD.U & (unsigned char)(1u << IFX_SCR_PASSWD_PROTECT_S_OFF)) | (0x18 << IFX_SCR_PASSWD_PASS_OFF));
    }
}


IFX_INLINE void IfxScrScu_enableBitProtectedWriteAccess(void)
{
    SCR_PASSWD.U = ((SCR_PASSWD.U & (unsigned char)0x07) | (0x13 << IFX_SCR_PASSWD_PASS_OFF));
}


IFX_INLINE void IfxScrScu_disableBitProtectedWriteAccess(void)
{
    SCR_PASSWD.U = ((SCR_PASSWD.U & (unsigned char)0x07) | (0x15 << IFX_SCR_PASSWD_PASS_OFF));
}


IfxScrScu_StandbyClockSource IfxScrScu_getStandbyClockSource(void)
{
    boolean source = 0;
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (0xF8U));
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}

    if ((SCR_SCU_CLK.B.DIV_STAT & (0xFU)) == 0xFu)
    {
        source = FALSE;
    }
    else
    {
        source = TRUE;
    }

    return (IfxScrScu_StandbyClockSource)source;
}


IFX_INLINE IfxScrScu_DivideFactor IfxScrScu_getClockDivider(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (0xF8U));
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    return (IfxScrScu_DivideFactor)((SCR_SCU_CLK.U & (0xFu << IFX_SCR_SCU_CLK_DIV_STAT_OFF)) >> IFX_SCR_SCU_CLK_DIV_STAT_OFF);
}


IFX_INLINE void IfxScrScu_setClockDivider(IfxScrScu_DivideFactor divider)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (0xF8U));
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    SCR_SCU_CLK.U  = ((SCR_SCU_CLK.U & (0xFu << IFX_SCR_SCU_CLK_DIV_STAT_OFF)) | divider);

    /*Wait for the clock divider to set */
    while (!(IfxScrScu_getClockDivider() == divider))
    {}
}


IFX_INLINE void IfxScrScu_restorePageValue(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & 0x3FU) | (3U << IFX_SCR_PAGE_OP_OFF);
}


IFX_INLINE void IfxScrScu_enableAutoSavePageValue(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & 0x3FU) | (2U << IFX_SCR_PAGE_OP_OFF);
}


IFX_INLINE void IfxScrScu_selectPageStorageRegisters(IfxScrScu_StorageNumber stnr)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & 0xCFU) | (stnr << IFX_SCR_PAGE_STNR_OFF);
}

/*========================================================= RESET ===========================================================================*/

IFX_INLINE void IfxScrScu_enableDisableGeneratedInterrupt(IfxScrScu_GeneratedReset generatedReset, Ifx_Functionality enable)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (0xF8U));
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    if (generatedReset == IfxScrScu_GeneratedReset_software)
    {
        /* Enable bit protection write access */
        IfxScrScu_enableBitProtectedWriteAccess();
        SCR_SCU_RSTCON.U = (SCR_SCU_RSTCON.U & ~(1 << generatedReset)) | (enable << generatedReset);
        /* Disable bit protection write access */
        IfxScrScu_disableBitProtectedWriteAccess();
    }
    else
    {
        SCR_SCU_RSTCON.U = (SCR_SCU_RSTCON.U & ~(1 << generatedReset)) | (enable << generatedReset);
    }
}


IFX_INLINE void IfxScrScu_enableGeneratedReset(IfxScrScu_GeneratedReset generatedReset)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    if (generatedReset == IfxScrScu_GeneratedReset_software)
    {
        /* Enable bit protection write access */
        IfxScrScu_enableBitProtectedWriteAccess();
        SCR_SCU_RSTCON.U = SCR_SCU_RSTCON.U | (1U << generatedReset);
        /* Disable bit protection write access */
        IfxScrScu_disableBitProtectedWriteAccess();
    }
    else
    {
        SCR_SCU_RSTCON.U = SCR_SCU_RSTCON.U | (1U << generatedReset);
    }
}


IFX_INLINE void IfxScrScu_disableGeneratedReset(IfxScrScu_GeneratedReset generatedReset)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    if (generatedReset == IfxScrScu_GeneratedReset_software)
    {
        /* Enable bit protection write access */
        IfxScrScu_enableBitProtectedWriteAccess();
        SCR_SCU_RSTCON.U = (SCR_SCU_RSTCON.U & ~(1U << generatedReset));
        /* Disable bit protection write access */
        IfxScrScu_disableBitProtectedWriteAccess();
    }
    else
    {
        SCR_SCU_RSTCON.U = (SCR_SCU_RSTCON.U & ~(1U << generatedReset));
    }
}


IFX_INLINE void IfxScrScu_disableAllGeneratedReset(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    /* Enable bit protection write access */
    IfxScrScu_enableBitProtectedWriteAccess();
    SCR_SCU_RSTCON.U = 0;
    /* Disable bit protection write access */
    IfxScrScu_disableBitProtectedWriteAccess();
}


IFX_INLINE void IfxScrScu_generateSoftwareReset(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    /* Enable bit protection write access */
    IfxScrScu_enableBitProtectedWriteAccess();
    SCR_SCU_RSTCON.U = (SCR_SCU_RSTCON.U | (1u << IFX_SCR_SCU_RSTCON_SWRSTREQ_OFF));
    /* Disable bit protection write access */
    IfxScrScu_disableBitProtectedWriteAccess();  /* Not sure if required. As SCR will reset */
}


IFX_INLINE boolean IfxScrScu_hasGeneratedResetOccured(IfxScrScu_GeneratedReset generatedReset)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    return (boolean)((SCR_SCU_RSTSTAT.U & (unsigned char)(1 << generatedReset)) >> generatedReset);
}


IFX_INLINE void IfxScrScu_clearGeneratedResetFlag(IfxScrScu_GeneratedReset generatedReset)
{
    if (generatedReset != IfxScrScu_GeneratedReset_software)
    {
        SCR_SCU_PAGE.U    = (SCR_SCU_PAGE.U & (uint8)0xF8U);
        while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
        {}
        SCR_SCU_RSTSTAT.U = (SCR_SCU_RSTSTAT.U & (unsigned char)(~(1 << generatedReset)));
    }
}


IFX_INLINE void IfxScrScu_clearAllGeneratedResetFlags(void)
{
    SCR_SCU_PAGE.U    = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    SCR_SCU_RSTSTAT.U = 0;
}


IFX_INLINE boolean IfxScrScu_hasMainResetOccured(IfxScrScu_MainReset mainReset)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    return (boolean)((SCR_SCU_MRSTSTAT.U & (unsigned char)(1 << mainReset)) >> mainReset);
}


IFX_INLINE void IfxScrScu_clearMainResetFlag(IfxScrScu_MainReset mainReset)
{
    SCR_SCU_PAGE.U     = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    SCR_SCU_MRSTSTAT.U = (SCR_SCU_MRSTSTAT.U & (unsigned char)(~(1 << mainReset)));
}


IFX_INLINE void IfxScrScu_clearAllMainResetFlags(void)
{
    SCR_SCU_PAGE.U     = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    SCR_SCU_MRSTSTAT.U = 0;
}


/*========================================================= Power Management ===========================================================================*/

IFX_INLINE void IfxScrScu_disableModule(IfxScrScu_Module module)
{
    SCR_SCU_PAGE.U = ((SCR_SCU_PAGE.U & (0xF8U)) | (uint8)1U);
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x1))
    {}
    if (module < IfxScrScu_Module_i2c)
    {
        SCR_SCU_PMCON0.U = (SCR_SCU_PMCON0.U | (1U << module));
    }
    else
    {
        SCR_SCU_PMCON1.U = (SCR_SCU_PMCON1.U | (1U << (module - IfxScrScu_Module_i2c)));
    }
}


IFX_INLINE void IfxScrScu_disableAllModules(void)
{
    SCR_SCU_PAGE.U   = ((SCR_SCU_PAGE.U & (0xF8U)) | (uint8)1U);
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x1))
    {}
    SCR_SCU_PMCON0.U = 0xFFU;
    SCR_SCU_PMCON1.U = (1u << IFX_SCR_SCU_PMCON1_I2C_DIS_OFF);
}


IFX_INLINE void IfxScrScu_enableModule(IfxScrScu_Module module)
{
    SCR_SCU_PAGE.U = ((SCR_SCU_PAGE.U & (0xF8U)) | (uint8)1U);
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x1))
    {}
    if (module < IfxScrScu_Module_i2c)
    {
        SCR_SCU_PMCON0.U = (SCR_SCU_PMCON0.U & (uint8)(~(1U << module)));
    }
    else
    {
        SCR_SCU_PMCON1.U = (SCR_SCU_PMCON1.U & (uint8)(~(1U << (module - IfxScrScu_Module_i2c))));
    }
}


IFX_INLINE void IfxScrScu_enableAllModules(void)
{
    SCR_SCU_PAGE.U   = ((SCR_SCU_PAGE.U & (0xF8U)) | (uint8)1U);
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x1))
    {}
    SCR_SCU_PMCON0.U = 0U;
    SCR_SCU_PMCON1.U = 0U;
}


IFX_INLINE void IfxScrScu_enableTricoreWakeupEvent(IfxScrScu_WakeupEvent event)
{
    SCR_SCU_PAGE.U   = (SCR_SCU_PAGE.U & (0xF8U));
    /* TOCHECK : Waiting for the page bit to update is really needed.
     * In RTL the page value was not updated and and writing to SCRINTEXCHG caused an unexpected reset(RSTCON).
     */
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    SCR_SCU_WKPCON.U = (SCR_SCU_WKPCON.U | (1U << event));
}


IFX_INLINE void IfxScrScu_disableTricoreWakeupEvent(IfxScrScu_WakeupEvent event)
{
    SCR_SCU_PAGE.U   = (SCR_SCU_PAGE.U & (0xF8U));
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    SCR_SCU_WKPCON.U = (SCR_SCU_WKPCON.U & (uint8)(~(1 << event)));
}


IFX_INLINE boolean IfxScrScu_isTricoreInStandby(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    return (boolean)((SCR_SCU_STBY.U & (uint8)(1u << IFX_SCR_SCU_STBY_STBYSTAT_OFF)));
}


IFX_INLINE boolean IfxScrScu_switchScrMode(IfxScrScu_Mode mode)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    boolean status = FALSE;

    /* Execute if the tricore is in standby mode */
    if (SCR_SCU_STBY.U & 0x01)
    {
        if (mode == IfxScrScu_Mode_70kHz)
        {
            /* Check tricore is in standby state.if yes Disable ADCOMP. ADCOMP unit is available to SCR only during standby mode */
            if (SCR_ADCOMP_CON.U & 0x01)
            {
                SCR_ADCOMP_CON.U = (SCR_ADCOMP_CON.U & ~IFX_SCR_ADCOMP_CON_EN_REQ_MSK);
            }

            SCR_SCU_CLK.U = ((SCR_SCU_CLK.U & (0xFu << IFX_SCR_SCU_CLK_DIV_STAT_OFF)) | IfxScrScu_DivideFactor_70Khz);

            /*Wait for the clock divider to set */
            while (!(SCR_SCU_CLK.B.DIV_STAT == IfxScrScu_DivideFactor_70Khz))
            {}
        }
        else if (mode == IfxScrScu_Mode_100MHz)
        {
            /* Check tricore is in standby state.if yes Disable ADCOMP. ADCOMP unit is available to SCR only during standby mode */
            if (SCR_ADCOMP_CON.U & 0x01)
            {
                SCR_ADCOMP_CON.U = (SCR_ADCOMP_CON.U & ~IFX_SCR_ADCOMP_CON_EN_REQ_MSK);
            }

            if (SCR_SCU_CLK.B.DIV_STAT == IfxScrScu_DivideFactor_70Khz)
            {
                SCR_SCU_CLK.U = ((SCR_SCU_CLK.U & (0xFu << IFX_SCR_SCU_CLK_DIV_STAT_OFF)) | IfxScrScu_DivideFactor_5);

                /*Wait for the clock divider to set */
                while (!(SCR_SCU_CLK.B.DIV_STAT == IfxScrScu_DivideFactor_5))
                {}
            }
        }
        else
        {
            /* Check tricore is in standby state.if yes Enable ADCOMP. ADCOMP unit is available to SCR only during standby mode */
            if (!(SCR_ADCOMP_CON.U & 0x01))
            {
                SCR_ADCOMP_CON.U = (SCR_ADCOMP_CON.U | (1u << IFX_SCR_ADCOMP_CON_EN_REQ_OFF));
            }

            if (SCR_SCU_CLK.B.DIV_STAT == IfxScrScu_DivideFactor_70Khz)
            {
                SCR_SCU_CLK.U = ((SCR_SCU_CLK.U & (0xFu << IFX_SCR_SCU_CLK_DIV_STAT_OFF)) | IfxScrScu_DivideFactor_5);

                /*Wait for the clock divider to set */
                while (!(SCR_SCU_CLK.B.DIV_STAT == IfxScrScu_DivideFactor_5))
                {}
            }
        }

        status = TRUE;
    }

    return status;
}


IFX_INLINE IfxScrScu_Mode IfxScrScu_getScrMode(void)
{
    IfxScrScu_Mode mode;
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    if (SCR_SCU_CLK.B.DIV_STAT == IfxScrScu_DivideFactor_70Khz)
    {
        mode = IfxScrScu_Mode_70kHz;
    }
    else if (!(SCR_SCU_CLK.B.DIV_STAT == IfxScrScu_DivideFactor_70Khz) && (SCR_ADCOMP_CON.U & 0x01))
    {
        mode = IfxScrScu_Mode_100MHzAdcomp;
    }
    else
    {
        mode = IfxScrScu_Mode_100MHz;
    }

    return mode;
}


/*============================== Watchdog ============================*/

IFX_INLINE void IfxScrScu_serviceWatchdog(unsigned char reloadValue)
{
    SCR_WDT_REL.U = reloadValue;
    SCR_WDT_CON.U = (SCR_WDT_CON.U | (1u << IFX_SCR_WDT_CON_WDTRS_OFF));

    while (SCR_WDT_CON.U & (1u << IFX_SCR_WDT_CON_WDTRS_OFF))  // wait till it's cleared by hardware
    {}
}


IFX_INLINE void IfxScrScu_configureWatchdogClock(IfxScrScu_WatchdogClockSource clockSource, IfxScrScu_WatchdogClockDivider divider)
{
    SCR_WDT_CON.U = ((SCR_WDT_CON.U & 0xF6u) | (unsigned char)divider | (unsigned char)(clockSource << IFX_SCR_WDT_CON_WDTCLK_OFF));
}


IFX_INLINE void IfxScrScu_enableWatchdog(void)
{
    /*enable bit protection write access*/
    IfxScrScu_enableBitProtectedWriteAccess();
    SCR_WDT_CON.U = (SCR_WDT_CON.U | (1u << IFX_SCR_WDT_CON_WDTEN_OFF));
    /*disable bit protection write access*/
    IfxScrScu_disableBitProtectedWriteAccess();
}


IFX_INLINE void IfxScrScu_disableWatchdog(void)
{
    /*enable bit protection write access*/
    IfxScrScu_enableBitProtectedWriteAccess();
    SCR_WDT_CON.U = (SCR_WDT_CON.U & ~(1u << IFX_SCR_WDT_CON_WDTEN_OFF));
    /*disable bit protection write access*/
    IfxScrScu_disableBitProtectedWriteAccess();
}


IFX_INLINE boolean IfxScrScu_hasWatchdogOverflowOccured(void)
{
    return (boolean)((SCR_WDT_CON.U & (1u << IFX_SCR_WDT_CON_WDTPR_OFF)) >> IFX_SCR_WDT_CON_WDTPR_OFF);
}


IFX_INLINE uint16 IfxScrScu_getWatchdogCounterValue(void)
{
    return (uint16)((SCR_WDT_H.U << 8u) | SCR_WDT_L.U);
}


IFX_INLINE uint8 IfxScrScu_getWatchdogCounterHighValue(void)
{
    return (uint8)(SCR_WDT_H.U);
}


IFX_INLINE void IfxScrScu_enableWatchdogWindowBoundary(void)
{
    SCR_WDT_CON.U = (SCR_WDT_CON.U | 1U << IFX_SCR_WDT_CON_WINBEN_OFF);
}


IFX_INLINE void IfxScrScu_disableWatchdogWindowBoundary(void)
{
    SCR_WDT_CON.U = (SCR_WDT_CON.U & ~(1U << IFX_SCR_WDT_CON_WINBEN_OFF));
}


IFX_INLINE void IfxScrScu_setWatchdogWindowBoundaryValue(uint8 boundaryValue)
{
    SCR_WDT_WINB.U = boundaryValue;
}


IFX_INLINE void IfxScrScu_configureWatchdogWindowBoundary(Ifx_Functionality enable, unsigned char boundaryValue)
{
    if (enable == Ifx_Functionality_enable)
    {
        SCR_WDT_WINB.U = boundaryValue;
    }

    SCR_WDT_CON.U = ((SCR_WDT_CON.U & ~(1u << IFX_SCR_WDT_CON_WINBEN_OFF)) | enable << IFX_SCR_WDT_CON_WINBEN_OFF);
}


IFX_INLINE void IfxScrScu_refreshWatchdog(void)
{
    SCR_WDT_CON.U |= (1u << IFX_SCR_WDT_CON_WDTRS_OFF);
}


IFX_INLINE boolean IfxScrScu_getWatchdogPrewarningStatus(void)
{
    return (boolean)(SCR_WDT_CON.B.WDTPR);
}


IFX_INLINE void IfxScrScu_setWatchdogReloadValue(unsigned char reloadValue)
{
    SCR_WDT_REL.U = reloadValue;
}


/*========================================================= Power Management ===========================================================================*/
IFX_INLINE void IfxScrScu_enterIdleMode(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    //disable watchdog
    IfxScrScu_disableWatchdog();
    //write to PCON.IDLE to enter Idle mode
    SCR_PCON.U = (SCR_PCON.U | (unsigned char)(1u << IFX_SCR_PCON_IDLE_OFF));
}

IFX_INLINE IfxScrScu_Status IfxScrScu_requestStby1ToStby0Transititon(void)
{
	IfxScrScu_Status status = IfxScrScu_Status_failure;
    /* Check if system in standby1 state */
    if(SCR_SCU_STBY.B.STBYSTAT)
    {
        SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
        while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
        {}
    	/* Clearing wakeup up flags */
    	SCR_SCU_STBY.B.PMSWKPCLR = 1U;
    	/* Request standby 0 entry */
    	SCR_SCU_STBY.B.STBY0REQ = 1U;
    	status = IfxScrScu_Status_success;
    }
    return status;
}

IFX_INLINE void IfxScrScu_clearPmsWakeupFlags(void)
{
    SCR_SCU_PAGE.U = (SCR_SCU_PAGE.U & (uint8)0xF8U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x0))
    {}
    SCR_SCU_STBY.B.PMSWKPCLR = 1U;
}

IFX_INLINE void IfxScrScu_suspendModule(IfxScrScu_SuspendModule module)
{
	SCR_SCU_PAGE.U         = ((SCR_SCU_PAGE.U & (0xF8U)) | 7U);
	SCR_SCU_DBG_MODSUSP.U  = (1u << module);
}

/********************************************************** PMS RTC ************************************************************/

IFX_INLINE IfxScrScu_RtcTImerValue IfxScrScu_readPmsRtcTimer(void)
{
    IfxScrScu_RtcTImerValue timValue;
    SCR_SCU_PAGE.U      = ((SCR_SCU_PAGE.U & (0xF8U)) | 2U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x2))
    {}
    timValue.upperPart  = (uint32)SCR_SCU_PMSRTC_TIM39_32.U;
    timValue.upperPart |= (uint32)((uint32)SCR_SCU_PMSRTC_TIM47_40.U << 8u);
    timValue.upperPart |= (uint32)((uint32)SCR_SCU_PMSRTC_TIM55_48.U << 16u);
    timValue.upperPart |= (uint32)((uint32)SCR_SCU_PMSRTC_TIM63_56.U << 24u);

    SCR_SCU_PAGE.U      = ((SCR_SCU_PAGE.U & (0xF8U)) | 3U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x3))
    {}
    timValue.lowerPart  = (uint32)SCR_SCU_PMSRTC_TIM7_0.U;
    timValue.lowerPart |= (uint32)((uint32)SCR_SCU_PMSRTC_TIM15_8.U << 8u);
    timValue.lowerPart |= (uint32)((uint32)SCR_SCU_PMSRTC_TIM23_16.U << 16u);
    timValue.lowerPart |= (uint32)((uint32)SCR_SCU_PMSRTC_TIM31_24.U << 24u);
    return timValue;
}


IFX_INLINE void IfxScrScu_setPmsRtcOffset(uint16 offsetValue)
{
    SCR_SCU_PAGE.U              = ((SCR_SCU_PAGE.U & (0xF8U)) | 3U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x3))
    {}
    SCR_SCU_PMSRTC_OFFSET15_8.U = (uint8)(offsetValue >> 8u);
    SCR_SCU_PMSRTC_OFFSET7_0.U  = (uint8)(offsetValue);
}


IFX_INLINE void IfxScrScu_setPmsRtcCompareValue(uint32 cmpValue)
{
    SCR_SCU_PAGE.U               = ((SCR_SCU_PAGE.U & (0xF8U)) | 4U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x4))
    {}
    SCR_SCU_PMSRTC_CMP1_31_24.U  = (uint8)(cmpValue >> 24u);
    SCR_SCU_PMSRTC_CMP1_23_16.U |= (uint8)(cmpValue >> 16u);
    SCR_SCU_PMSRTC_CMP1_15_8.U  |= (uint8)(cmpValue >> 8u);
    SCR_SCU_PMSRTC_CMP1_7_0.U   |= (uint8)(cmpValue);
}


IFX_INLINE void IfxScrScu_setPmsRtcMsizeValue(uint8 value)
{
    SCR_SCU_PAGE.U          = ((SCR_SCU_PAGE.U & (0xF8U)) | 4U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x4))
    {}
    SCR_SCU_PMSRTC_MSIZE1.U = (uint8)(value & IFX_SCR_SCU_PMSRTC_MSIZE1_VAL_MSK);
}


IFX_INLINE void IfxScrScu_setPmsRtcMstartValue(uint8 value)
{
    SCR_SCU_PAGE.U           = ((SCR_SCU_PAGE.U & (0xF8U)) | 4U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x4))
    {}
    SCR_SCU_PMSRTC_MSTART1.U = (uint8)(value & IFX_SCR_SCU_PMSRTC_MSTART1_VAL_MSK);
}


IFX_INLINE void IfxScrScu_enablePmsDts(void)
{
    SCR_SCU_PAGE.U        = ((SCR_SCU_PAGE.U & (0xF8U)) | 5U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x5))
    {}
    SCR_SCU_PMSDTS_CON.U |= (1u << IFX_SCR_SCU_PMSDTS_CON_EN_START_OFF);
}

IFX_INLINE boolean IfxScrScu_isPmsDtsEnabled(void)
{
    SCR_SCU_PAGE.U = ((SCR_SCU_PAGE.U & (0xF8U)) | 5U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x5))
    {}
    return (boolean)(SCR_SCU_PMSDTS_RES11_8.B.RES_READY);
}


IFX_INLINE uint16 IfxScrScu_readPmsDtsValue(void)
{
    uint16 value;
    uint8  resh1, resl1, resh2, resl2;
    SCR_SCU_PAGE.U = ((SCR_SCU_PAGE.U & (0xF8U)) | 5U);
    while(!(SCR_SCU_PAGE.B.PAGE == 0x5))
    {}
    resh1          = SCR_SCU_PMSDTS_RES11_8.B.VAL;
    resl1          = SCR_SCU_PMSDTS_RES7_0.U;
    resh2          = SCR_SCU_PMSDTS_RES11_8.B.VAL;
    resl2          = SCR_SCU_PMSDTS_RES7_0.U;

    if (resh1 == resh2)
    {
        value = ((resh1 << 8u) | resl1);
    }
    else
    {
        value = ((resh2 << 8u) | resl2);
    }

    return value;
}


IFX_INLINE void IfxScrScu_calibratePmsRtc(uint32 cmpValue)
{
    uint16 dtsValue;

    /* Enable PMS DTS */
    if (!IfxScrScu_isPmsDtsEnabled())
    {
        IfxScrScu_enablePmsDts();
    }

    /* Read PMS Dts value */
    dtsValue = IfxScrScu_readPmsDtsValue();

    if(dtsValue)
    {
      /*Dummy statement to remove compiler warning*/
    }
    /*TODO: Algorithm for calculating trimming value. Based on that set signed offset value*/

    /* Set RTC compare value */
    IfxScrScu_setPmsRtcCompareValue(cmpValue);

    //IfxScrScu_setPmsRtcOffset(/*calculated value*/);
}


#endif /* IFXSCRSCU_H */
