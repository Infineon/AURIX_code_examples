/**
 * \file IfxLeth.h
 * \brief LETH  basic functionality
 * \ingroup IfxLld_Leth
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 *
 * \defgroup IfxLld_Leth_Std_Enumerations Enumerations
 * \ingroup IfxLld_Leth_Std
 * \defgroup IfxLld_Leth_Std_Functions Std Functions
 * \ingroup IfxLld_Leth_Std
 * \defgroup IfxLld_Leth_Std_DataStructures DataStructures
 * \ingroup IfxLld_Leth_Std
 * \defgroup IfxLld_Leth_Std_Unions Unions
 * \ingroup IfxLld_Leth_Std
 */

#ifndef IFXLET_H
#define IFXLET_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxLeth_cfg.h"
#include "_PinMap/IfxLeth_PinMap.h"
#include "Src/Std/IfxSrc.h"
#include "IfxLeth_bf.h"
#include "Ap/Std/IfxApProt.h"
#include "Ap/Std/IfxApApu.h"
#include "Cpu/Std/IfxCpu.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief Max number of TX descriptors per list. Min is 4.
 */
#ifndef IFXLETH_MAX_TX_DESCRIPTORS
#define IFXLETH_MAX_TX_DESCRIPTORS (4)
#endif

/** \brief Max number of RX descriptors per list. Min is 4.
 */
#ifndef IFXLETH_MAX_RX_DESCRIPTORS
#define IFXLETH_MAX_RX_DESCRIPTORS (4)
#endif

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Leth_Std_Enumerations
 * \{ */
/** \brief MTL Tx Queue AV algorithm
 * Definition in MTL_TXQi_ETS_CONTROL.B.AVALG, i >= 1
 */
typedef enum
{
    IfxLeth_AvAlgorithm_strict = 0,  /**< \brief Strict Priority */
    IfxLeth_AvAlgorithm_cbs    = 1   /**< \brief Credit Based Shaper */
} IfxLeth_AvAlgorithm;

/** \brief Bridge Port Mode\n
 * Definition in bits PORT_SEL and Q_CH_MAPPING_EN of Ifx_LETH_BRIDGE_ETHBR_FWD_CTRL_REG
 */
typedef enum
{
    IfxLeth_BridgePortMode_singlePort0 = 0,  /**< \brief Single Port Mode using Port 0 */
    IfxLeth_BridgePortMode_singlePort1 = 1,  /**< \brief Single Port Mode using Port 1 */
    IfxLeth_BridgePortMode_singlePort2 = 2,  /**< \brief Single Port Mode using Port 2 */
    IfxLeth_BridgePortMode_singlePort3 = 3,  /**< \brief Single Port Mode using Port 3 */
    IfxLeth_BridgePortMode_multiPort   = 4   /**< \brief Multi Port Mode, all available ports or a subset could be used */
} IfxLeth_BridgePortMode;

/** \brief LETH Port's RxC Mapping to Rx DMA Channels\n
 */
typedef enum
{
    IfxLeth_BridgeRxCMap_RxDma0 = 0,  /**< \brief Mapped to Rx Dma channel 0 */
    IfxLeth_BridgeRxCMap_RxDma1 = 1,  /**< \brief Mapped to Rx Dma channel 1 */
    IfxLeth_BridgeRxCMap_RxDma2 = 2,  /**< \brief Mapped to Rx Dma channel 2 */
    IfxLeth_BridgeRxCMap_RxDma3 = 3,  /**< \brief Mapped to Rx Dma channel 3 */
    IfxLeth_BridgeRxCMap_RxDma4 = 4,  /**< \brief Mapped to Rx Dma channel 4 */
    IfxLeth_BridgeRxCMap_RxDma5 = 5,  /**< \brief Mapped to Rx Dma channel 5 */
    IfxLeth_BridgeRxCMap_RxDma6 = 6,  /**< \brief Mapped to Rx Dma channel 6 */
    IfxLeth_BridgeRxCMap_RxDma7 = 7   /**< \brief Mapped to Rx Dma channel 7 */
} IfxLeth_BridgeRxCMap;

/** \brief Bridge RxC channels
 */
typedef enum
{
    IfxLeth_BridgeRxChannel_0 = 0,  /**< \brief Bridge RxC Channel 0 */
    IfxLeth_BridgeRxChannel_1 = 1,  /**< \brief Bridge RxC Channel 1 */
    IfxLeth_BridgeRxChannel_2 = 2,  /**< \brief Bridge RxC Channel 2 */
    IfxLeth_BridgeRxChannel_3 = 3,  /**< \brief Bridge RxC Channel 3 */
    IfxLeth_BridgeRxChannel_4 = 4,  /**< \brief Bridge RxC Channel 4 */
    IfxLeth_BridgeRxChannel_5 = 5,  /**< \brief Bridge RxC Channel 5 */
    IfxLeth_BridgeRxChannel_6 = 6,  /**< \brief Bridge RxC Channel 6 */
    IfxLeth_BridgeRxChannel_7 = 7   /**< \brief Bridge RxC Channel 7 */
} IfxLeth_BridgeRxChannel;

/** \brief LETH Port's Tx Queue Mapping to Tx DMA Channels or Rx Forward Paths\n
 */
typedef enum
{
    IfxLeth_BridgeTxQueueMap_TxDma0          = 0,  /**< \brief Mapped to Tx Dma channel 0 */
    IfxLeth_BridgeTxQueueMap_TxDma1          = 1,  /**< \brief Mapped to Tx Dma channel 1 */
    IfxLeth_BridgeTxQueueMap_TxDma2          = 2,  /**< \brief Mapped to Tx Dma channel 2 */
    IfxLeth_BridgeTxQueueMap_TxDma3          = 3,  /**< \brief Mapped to Tx Dma channel 3 */
    IfxLeth_BridgeTxQueueMap_TxDma4          = 4,  /**< \brief Mapped to Tx Dma channel 4 */
    IfxLeth_BridgeTxQueueMap_TxDma5          = 5,  /**< \brief Mapped to Tx Dma channel 5 */
    IfxLeth_BridgeTxQueueMap_TxDma6          = 6,  /**< \brief Mapped to Tx Dma channel 6 */
    IfxLeth_BridgeTxQueueMap_TxDma7          = 7,  /**< \brief Mapped to Tx Dma channel 7 */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC0 = 0,  /**< \brief Mapped to RxC 0 of other Port (in Forwarding Modes) */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC1 = 1,  /**< \brief Mapped to RxC 1 of other Port (in Forwarding Modes) */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC2 = 2,  /**< \brief Mapped to RxC 2 of other Port (in Forwarding Modes) */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC3 = 3,  /**< \brief Mapped to RxC 3 of other Port (in Forwarding Modes) */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC4 = 4,  /**< \brief Mapped to RxC 4 of other Port (in Forwarding Modes) */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC5 = 5,  /**< \brief Mapped to RxC 5 of other Port (in Forwarding Modes) */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC6 = 6,  /**< \brief Mapped to RxC 6 of other Port (in Forwarding Modes) */
    IfxLeth_BridgeTxQueueMap_ForwardPortRxC7 = 7   /**< \brief Mapped to RxC 7 of other Port (in Forwarding Modes) */
} IfxLeth_BridgeTxQueueMap;

/** \brief Slot count in CBS
 * Definition in MTL_TXQi_ETS_CONTROL.B.SLC, i >= 1
 */
typedef enum
{
    IfxLeth_CbsSlotCount_1  = 0, /**< \brief Slot Count is 1 */
    IfxLeth_CbsSlotCount_2  = 1, /**< \brief Slot Count is 2 */
    IfxLeth_CbsSlotCount_4  = 2, /**< \brief Slot Count is 4 */
    IfxLeth_CbsSlotCount_8  = 3, /**< \brief Slot Count is 8 */
    IfxLeth_CbsSlotCount_16 = 4  /**< \brief Slot Count is 16 */
} IfxLeth_CbsSlotCount;

/** \brief Programmable burst length of DMA channels\n
 * Definition in DMA_CHi_TX_CONTROL.B.TxPBL and DMA_CHi_RX_CONTROL.B.RxPBL
 */
typedef enum
{
    IfxLeth_DmaBurstLength_1  = 1,   /**< \brief maximum burst length 1 */
    IfxLeth_DmaBurstLength_2  = 2,   /**< \brief maximum burst length 2 */
    IfxLeth_DmaBurstLength_4  = 4,   /**< \brief maximum burst length 4 */
    IfxLeth_DmaBurstLength_8  = 8,   /**< \brief maximum burst length 8 */
    IfxLeth_DmaBurstLength_16 = 16,  /**< \brief maximum burst length 16 */
    IfxLeth_DmaBurstLength_32 = 32   /**< \brief maximum burst length 32 */
} IfxLeth_DmaBurstLength;

/** \brief LETH DMA channel
 */
typedef enum
{
    IfxLeth_DmaChannel_0 = 0,  /**< \brief Dma Channel 0 */
    IfxLeth_DmaChannel_1 = 1,  /**< \brief Dma Channel 1 */
    IfxLeth_DmaChannel_2 = 2,  /**< \brief Dma Channel 2 */
    IfxLeth_DmaChannel_3 = 3,  /**< \brief Dma Channel 3 */
    IfxLeth_DmaChannel_4 = 4,  /**< \brief Dma Channel 4 */
    IfxLeth_DmaChannel_5 = 5,  /**< \brief Dma Channel 5 */
    IfxLeth_DmaChannel_6 = 6,  /**< \brief Dma Channel 6 */
    IfxLeth_DmaChannel_7 = 7   /**< \brief Dma Channel 7 */
} IfxLeth_DmaChannel;

/** \brief MDC clock configuration as per CSR clock range
 * Definition in MAC_MDIO_ADDRESS.B.CR
 */
typedef enum
{
    IfxLeth_MdioAppClockRangeSel_0CrsDivider42  = 0,  /**< \brief MDC clock is derived as clk_csr/42  applicable when CSR_CLk freq is 60-100MHz {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_0CrsDivider62  = 1,  /**< \brief MDC clock is derived as clk_csr/62 applicable when CSR_CLk freq is 100-150MHZ {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_0CrsDivider16  = 2,  /**< \brief MDC clock is derived as clk_csr/16 applicable when CSR_CLk freq is 20-35MHZ {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_0CrsDivider26  = 3,  /**< \brief MDC clock is derived as clk_csr/26 applicable when CSR_CLk freq is 35-60MHZ {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_0CrsDivider102 = 4,  /**< \brief MDC clock is derived as clk_csr/102 applicable when CSR_CLk freq is 150-250MHZ {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_0CrsDivider124 = 5,  /**< \brief MDC clock is derived as clk_csr/124 applicable when CSR_CLk freq is 250-300MHZ {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_0CrsDivider204 = 6,  /**< \brief MDC clock is derived as clk_csr/204 applicable when CSR_CLk freq is 300-500MHZ {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_0CrsDivider324 = 7,  /**< \brief MDC clock is derived as clk_csr/324 applicable when CSR_CLk freq is 500-800MHZ {When MDC clock freq of 2.5MHz (standard MDC freq as per ieee 802.3) } */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider4   = 8,  /**< \brief MDC clock is derived as clk_csr/4 {When higher MDC freq greater then STD 2.5MHz freq} */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider6   = 9,  /**< \brief MDC clock is derived as clk_csr/6 {When higher MDC freq greater then STD 2.5MHz freq} */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider8   = 10, /**< \brief MDC clock is derived as clk_csr/8 {When higher MDC freq greater then STD 2.5MHz freq} */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider10  = 11, /**< \brief MDC clock is derived as clk_csr/10 {When higher MDC freq greater then STD 2.5MHz freq} */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider12  = 12, /**< \brief MDC clock is derived as clk_csr/12 {When higher MDC freq greater then STD 2.5MHz freq} */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider14  = 13, /**< \brief MDC clock is derived as clk_csr/14 {When higher MDC freq greater then STD 2.5MHz freq} */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider16  = 14, /**< \brief MDC clock is derived as clk_csr/16 {When higher MDC freq greater then STD 2.5MHz freq} */
    IfxLeth_MdioAppClockRangeSel_1CrsDivider18  = 15  /**< \brief MDC clock is derived as clk_csr/18 {When higher MDC freq greater then STD 2.5MHz freq} */
} IfxLeth_MdioAppClockRangeSel;

/** \brief Operation mode's in the clause 45 MDIO transaction
 * Definition in MAC_MDIO_ADDRESS.B.GOC_0 & MAC_MDIO_ADDRESS.B.GOC_1
 */
typedef enum
{
    IfxLeth_MdioClause45ReadMode_postReadIncAddr = 2,  /**< \brief Post read increment the address mode */
    IfxLeth_MdioClause45ReadMode_read            = 3   /**< \brief only Read mode */
} IfxLeth_MdioClause45ReadMode;

/** \brief Selects the PHY device type in use for MDIO clause 45 frame format
 * Definition in MAC_MDIO_ADDRESS.B.RDA
 */
typedef enum
{
    IfxLeth_MdioDeviceSel_Plca_Ctrl            = 0,   /**< \brief Reference to PLCA control segment of PHY device */
    IfxLeth_MdioDeviceSel_Plca_NodeCtrl        = 1,   /**< \brief Reference to PLCA Node control segment of PHY device */
    IfxLeth_MdioDeviceSel_Plca_Status          = 2,   /**< \brief Reference to PLCA status segment of PHY device */
    IfxLeth_MdioDeviceSel_Plca_Timer           = 3,   /**< \brief Reference to PLCA Timer segment of PHY device */
    IfxLeth_MdioDeviceSel_Pcs_Ctrl             = 11,  /**< \brief Reference to PCS control segment of PHY device */
    IfxLeth_MdioDeviceSel_Pcs_Status           = 12,  /**< \brief Reference to PCS status segment of PHY device */
    IfxLeth_MdioDeviceSel_Pcs_diag_1           = 13,  /**< \brief Reference to PCS diagnostic 1 segment of PHY device */
    IfxLeth_MdioDeviceSel_Pcs_diag_2           = 14,  /**< \brief Reference to PCS diagnostic 2 segment of PHY device */
    IfxLeth_MdioDeviceSel_Pcs_Jab_Timer        = 15,  /**< \brief Reference to PLC Jab Timer segment of PHY device */
    IfxLeth_MdioDeviceSel_PmaPmd_ExtendAbility = 20,  /**< \brief Reference to PMA/PMD extended ability segment of PHY device */
    IfxLeth_MdioDeviceSel_PmaPmd_Ctrl          = 21,  /**< \brief Reference to PMA/PMD control segment of PHY device */
    IfxLeth_MdioDeviceSel_Pma_Ctrl             = 22,  /**< \brief Reference to PMA control segment of PHY device */
    IfxLeth_MdioDeviceSel_Pma_Status           = 23,  /**< \brief Reference to PMA status segment of PHY device */
    IfxLeth_MdioDeviceSel_TestMode_Ctrl        = 24,  /**< \brief Reference to Test mode control segment of PHY device */
    IfxLeth_MdioDeviceSel_DebugMode            = 25   /**< \brief Reference to Debug mode segment of PHY device */
} IfxLeth_MdioDeviceSel;

/** \brief Number of trailing clock cycles post MDIO frame transaction
 * Definition in MAC_MDIO_ADDRESS.B.NTC
 */
typedef enum
{
    IfxLeth_MdioTrailClkCycles_0 = 0,  /**< \brief No trailing clock cycles attached post MDIO transaction */
    IfxLeth_MdioTrailClkCycles_1 = 1,  /**< \brief Reference to PLCA control segment of PHY device */
    IfxLeth_MdioTrailClkCycles_2 = 2,  /**< \brief 2 trailing clock cycles attached post MDIO transaction */
    IfxLeth_MdioTrailClkCycles_3 = 3,  /**< \brief 3 trailing clock cycles attached post MDIO transaction */
    IfxLeth_MdioTrailClkCycles_4 = 4,  /**< \brief 4 trailing clock cycles attached post MDIO transaction */
    IfxLeth_MdioTrailClkCycles_5 = 5,  /**< \brief 5 trailing clock cycles attached post MDIO transaction */
    IfxLeth_MdioTrailClkCycles_6 = 6,  /**< \brief 6 trailing clock cycles attached post MDIO transaction */
    IfxLeth_MdioTrailClkCycles_7 = 7   /**< \brief 7 trailing clock cycles attached post MDIO transaction */
} IfxLeth_MdioTrailClkCycles;

/** \brief Phy Interface and Speed in Mbps
 */
typedef enum
{
    IfxLeth_PhyInterface_mii_10      = 0,  /**< \brief MII with speed of 10 Mbps */
    IfxLeth_PhyInterface_mii_100     = 1,  /**< \brief MII with speed of 100 Mbps */
    IfxLeth_PhyInterface_rmii_10     = 2,  /**< \brief RMII with speed of 10 Mbps */
    IfxLeth_PhyInterface_rmii_100    = 3,  /**< \brief RMII with speed of 100 Mbps */
    IfxLeth_PhyInterface_tc14_10_NRZ = 4,  /**< \brief TC14 with speed of 10 Mbps, V1.4 Spec, Non Return to Zero encoding for RX path */
    IfxLeth_PhyInterface_tc14_10_RZ  = 5   /**< \brief TC14 with speed of 10 Mbps, V1.5 Spec, Return to Zero encoding for RX path */
} IfxLeth_PhyInterface;

/** \brief Phy Interface Config Phases
 */
typedef enum
{
    IfxLeth_PhyInterfacePhase_1 = 0,  /**< \brief Phase 1 initialization for Port Control. To be done before DMA initialization. */
    IfxLeth_PhyInterfacePhase_2 = 1   /**< \brief Phase 2 initialization for Mac Config */
} IfxLeth_PhyInterfacePhase;

/** \brief MTL Queue mode
 * Definition in MTL_TXQi_OPERATION_MODE.B.TXQEN & MAC_RXQ_CTRL0.B.RXQ0EN
 */
typedef enum
{
    IfxLeth_QueueMode_avb     = 1, /**< \brief Queue is enabled in Audio Video mode */
    IfxLeth_QueueMode_generic = 2  /**< \brief Queue is enabled in Generic mode */
} IfxLeth_QueueMode;

/** \brief Rx DMA channel
 */
typedef enum
{
    IfxLeth_RxDmaChannel_0 = 0,  /**< \brief Rx Dma Channel 0 */
    IfxLeth_RxDmaChannel_1 = 1,  /**< \brief Rx Dma Channel 1 */
    IfxLeth_RxDmaChannel_2 = 2,  /**< \brief Rx Dma Channel 2 */
    IfxLeth_RxDmaChannel_3 = 3,  /**< \brief Rx Dma Channel 3 */
    IfxLeth_RxDmaChannel_4 = 4,  /**< \brief Rx Dma Channel 4 */
    IfxLeth_RxDmaChannel_5 = 5,  /**< \brief Rx Dma Channel 5 */
    IfxLeth_RxDmaChannel_6 = 6,  /**< \brief Rx Dma Channel 6 */
    IfxLeth_RxDmaChannel_7 = 7   /**< \brief Rx Dma Channel 7 */
} IfxLeth_RxDmaChannel;

/** \brief Leth service request index
 */
typedef enum
{
    IfxLeth_ServiceRequest_DmaTx_0 = 0,   /**< \brief Service Request DMA Tx Channel 0 */
    IfxLeth_ServiceRequest_DmaTx_1 = 1,   /**< \brief Service Request DMA Tx Channel 1 */
    IfxLeth_ServiceRequest_DmaTx_2 = 2,   /**< \brief Service Request DMA Tx Channel 2 */
    IfxLeth_ServiceRequest_DmaTx_3 = 3,   /**< \brief Service Request DMA Tx Channel 3 */
    IfxLeth_ServiceRequest_DmaTx_4 = 4,   /**< \brief Service Request DMA Tx Channel 4 */
    IfxLeth_ServiceRequest_DmaTx_5 = 5,   /**< \brief Service Request DMA Tx Channel 5 */
    IfxLeth_ServiceRequest_DmaTx_6 = 6,   /**< \brief Service Request DMA Tx Channel 6 */
    IfxLeth_ServiceRequest_DmaTx_7 = 7,   /**< \brief Service Request DMA Tx Channel 7 */
    IfxLeth_ServiceRequest_DmaRx_0 = 8,   /**< \brief Service Request DMA Rx Channel 0 */
    IfxLeth_ServiceRequest_DmaRx_1 = 9,   /**< \brief Service Request DMA Rx Channel 1 */
    IfxLeth_ServiceRequest_DmaRx_2 = 10,  /**< \brief Service Request DMA Rx Channel 2 */
    IfxLeth_ServiceRequest_DmaRx_3 = 11,  /**< \brief Service Request DMA Rx Channel 3 */
    IfxLeth_ServiceRequest_DmaRx_4 = 12,  /**< \brief Service Request DMA Rx Channel 4 */
    IfxLeth_ServiceRequest_DmaRx_5 = 13,  /**< \brief Service Request DMA Rx Channel 5 */
    IfxLeth_ServiceRequest_DmaRx_6 = 14,  /**< \brief Service Request DMA Rx Channel 6 */
    IfxLeth_ServiceRequest_DmaRx_7 = 15,  /**< \brief Service Request DMA Rx Channel 7 */
    IfxLeth_ServiceRequest_Pps_0   = 16,  /**< \brief Service Request PPS 0 (Port 0 PPS 0) */
    IfxLeth_ServiceRequest_Pps_1   = 17,  /**< \brief Service Request PPS 1 (Port 1 PPS 0) */
    IfxLeth_ServiceRequest_Pps_2   = 18,  /**< \brief Service Request PPS 2 (Port 2 PPS 0) */
    IfxLeth_ServiceRequest_Pps_3   = 19,  /**< \brief Service Request PPS 3 (Port 3 PPS 0) */
    IfxLeth_ServiceRequest_Intr    = 20   /**< \brief Service Request INTR */
} IfxLeth_ServiceRequest;

/** \brief Tx DMA channel
 */
typedef enum
{
    IfxLeth_TxDmaChannel_0 = 0,  /**< \brief Tx Dma Channel 0 */
    IfxLeth_TxDmaChannel_1 = 1,  /**< \brief Tx Dma Channel 1 */
    IfxLeth_TxDmaChannel_2 = 2,  /**< \brief Tx Dma Channel 2 */
    IfxLeth_TxDmaChannel_3 = 3,  /**< \brief Tx Dma Channel 3 */
    IfxLeth_TxDmaChannel_4 = 4,  /**< \brief Tx Dma Channel 4 */
    IfxLeth_TxDmaChannel_5 = 5,  /**< \brief Tx Dma Channel 5 */
    IfxLeth_TxDmaChannel_6 = 6,  /**< \brief Tx Dma Channel 6 */
    IfxLeth_TxDmaChannel_7 = 7   /**< \brief Tx Dma Channel 7 */
} IfxLeth_TxDmaChannel;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Leth_Std_DataStructures
 * \{ */
/** \brief Bit Fields of RDES0 Context Descriptor
 */
typedef struct
{
    uint32 RTSL : 32;       /**< \brief Receive Packet Timestamp Low */
} IfxLeth_RxContextDescr0_Bits;

/** \brief Bit Fields of RDES1 Context Descriptor
 */
typedef struct
{
    uint32 RTSH : 32;       /**< \brief Receive Packet Timestamp High */
} IfxLeth_RxContextDescr1_Bits;

/** \brief Bit Fields of RDES2 Context Descriptor
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxLeth_RxContextDescr2_Bits;

/** \brief Bit Fields of RDES3 Context Descriptor
 */
typedef struct
{
    uint32 reserved_0 : 29;       /**< \brief Reserved */
    uint32 DE : 1;                /**< \brief Descriptor Error */
    uint32 CTXT : 1;              /**< \brief Receive Context Descriptor */
    uint32 OWN : 1;               /**< \brief Own Bit */
} IfxLeth_RxContextDescr3_Bits;

/** \brief Bit Fields of RDES0 in Read Format
 */
typedef struct
{
    uint32 BUF1AP : 32;       /**< \brief Header or Buffer 1 Address Pointer */
} IfxLeth_RxDescr0_RF_Bits;

/** \brief Bit Fields of RDES0 in Write back Format
 */
typedef struct
{
    uint32 OVT : 16;       /**< \brief Outer VLAN Tag */
    uint32 IVT : 16;       /**< \brief Inner VLAN Tag */
} IfxLeth_RxDescr0_WF_Bits;

/** \brief Bit Fields of RDES1 in Read Format
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxLeth_RxDescr1_RF_Bits;

/** \brief Bit Fields of RDES1 in Write back Format
 */
typedef struct
{
    uint32 PT : 3;         /**< \brief Payload Type */
    uint32 IPHE : 1;       /**< \brief IP Header Error */
    uint32 IP4 : 1;        /**< \brief IPV4 Header Present */
    uint32 IP6 : 1;        /**< \brief IPv6 header Present */
    uint32 IPCB : 1;       /**< \brief IP Checksum Bypassed */
    uint32 IPCE : 1;       /**< \brief IP Payload Error */
    uint32 PMT : 4;        /**< \brief PTP Message Type */
    uint32 PFT : 1;        /**< \brief PTP Packet Type */
    uint32 PV : 1;         /**< \brief PTP Version */
    uint32 TSA : 1;        /**< \brief Timestamp Available */
    uint32 TD : 1;         /**< \brief Timestamp Dropped */
    uint32 OPC : 16;       /**< \brief OAM Sub-Type Code, or MAC Control Packet opcode */
} IfxLeth_RxDescr1_WF_Bits;

/** \brief Bit Fields of RDES2 in Read Format
 */
typedef struct
{
    uint32 BUF2AP : 32;       /**< \brief Buffer 2 Address Pointer */
} IfxLeth_RxDescr2_RF_Bits;

/** \brief Bit Fields of RDES2 in Write back Format
 */
typedef struct
{
    uint32 HL : 10;               /**< \brief L3/L4 Header Length */
    uint32 ARPNR : 1;             /**< \brief ARP Reply Not Generated */
    uint32 reserved_11 : 3;       /**< \brief Reserved */
    uint32 ITS : 1;               /**< \brief Inner VLAN Tag Filter Status (ITS) */
    uint32 OTS : 1;               /**< \brief VLAN Filter Status */
    uint32 SAF : 1;               /**< \brief SA Address Filter Fail */
    uint32 DAF : 1;               /**< \brief Destination Address Filter Fail */
    uint32 HF : 1;                /**< \brief Hash Filter Status */
    uint32 MADRM : 8;             /**< \brief MAC Address Match or Hash Value */
    uint32 L3FM : 1;              /**< \brief Layer 3 Filter Match */
    uint32 L4FM : 1;              /**< \brief Layer 4 Filter Match */
    uint32 L3L4FM : 3;            /**< \brief Layer 3 and Layer 4 Filter Number Matched */
} IfxLeth_RxDescr2_WF_Bits;

/** \brief Bit Fields of RDES3 in Read Format
 */
typedef struct
{
    uint32 reserved_0 : 24;       /**< \brief Reserved */
    uint32 BUF1V : 1;             /**< \brief Buffer 1 Address Valid */
    uint32 BUF2V : 1;             /**< \brief Buffer 2 Address Valid */
    uint32 reserved_27 : 4;       /**< \brief Reserved */
    uint32 IOC : 1;               /**< \brief Interrupt on Completion */
    uint32 OWN : 1;               /**< \brief Own bit */
} IfxLeth_RxDescr3_RF_Bits;

/** \brief Bit Fields of RDES3 in Write back Format
 */
typedef struct
{
    uint32 PL : 15;        /**< \brief Packet Length */
    uint32 ES : 1;         /**< \brief Error Summary */
    uint32 LT : 3;         /**< \brief Length/Type Field */
    uint32 DE : 1;         /**< \brief Dribble Bit Error */
    uint32 RE : 1;         /**< \brief Receive Error */
    uint32 OE : 1;         /**< \brief Overflow Error */
    uint32 RWT : 1;        /**< \brief Receive Watchdog Timeout */
    uint32 GP : 1;         /**< \brief Giant Packet */
    uint32 CE : 1;         /**< \brief CRC Error */
    uint32 RS0V : 1;       /**< \brief Receive Status RDES0 Valid */
    uint32 RS1V : 1;       /**< \brief Receive Status RDES1 Valid */
    uint32 RS2V : 1;       /**< \brief Receive Status RDES2 Valid */
    uint32 LD : 1;         /**< \brief Last Descriptor */
    uint32 FD : 1;         /**< \brief First Descriptor */
    uint32 CTXT : 1;       /**< \brief Receive Context Descriptor */
    uint32 OWN : 1;        /**< \brief Own Bit */
} IfxLeth_RxDescr3_WF_Bits;

/** \brief Bit Fields of TDES0 Context Descriptor
 */
typedef struct
{
    uint32 TTSL : 32;       /**< \brief Transmit Packet Timestamp Low */
} IfxLeth_TxContextDescr0_Bits;

/** \brief Bit Fields of TDES1 Context Descriptor
 */
typedef struct
{
    uint32 TTSH : 32;       /**< \brief Transmit Packet Timestamp High */
} IfxLeth_TxContextDescr1_Bits;

/** \brief Bit Fields of TDES2 Context Descriptor
 */
typedef struct
{
    uint32 MSS : 14;              /**< \brief Maximum Segment Size */
    uint32 reserved_14 : 2;       /**< \brief Reserved */
    uint32 IVT : 16;              /**< \brief Inner VLAN Tag */
} IfxLeth_TxContextDescr2_Bits;

/** \brief Bit Fields of TDES3 Context Descriptor
 */
typedef struct
{
    uint32 VT : 16;               /**< \brief VLAN Tag */
    uint32 VLTV : 1;              /**< \brief VLAN Tag Valid */
    uint32 IVLTV : 1;             /**< \brief Inner VLAN Tag Valid */
    uint32 IVTIR : 2;             /**< \brief Inner VLAN Tag Insert or Replace */
    uint32 reserved_20 : 3;       /**< \brief Reserved */
    uint32 CDE : 1;               /**< \brief Context Descriptor Error */
    uint32 reserved_24 : 2;       /**< \brief Reserved */
    uint32 TCMSSV : 1;            /**< \brief One-Step Timestamp Correction Input or MSS Valid */
    uint32 OSTC : 1;              /**< \brief One-Step Timestamp Correction Enable */
    uint32 reserved_28 : 2;       /**< \brief Reserved */
    uint32 CTXT : 1;              /**< \brief Context Type */
    uint32 OWN : 1;               /**< \brief Own Bit */
} IfxLeth_TxContextDescr3_Bits;

/** \brief Bit Fields of TDES0 in Read Format
 */
typedef struct
{
    uint32 BUF1AP : 32;       /**< \brief Buffer 1 Address Pointer */
} IfxLeth_TxDescr0_RF_Bits;

/** \brief Bit Fields of TDES0 in Write-back Format
 */
typedef struct
{
    uint32 TTSL : 32;       /**< \brief Transmit Packet Timestamp Low */
} IfxLeth_TxDescr0_WF_Bits;

/** \brief Bit Fields of TDES1 in Read Format
 */
typedef struct
{
    uint32 BUF2AP : 32;       /**< \brief Buffer 2 or Buffer 1 Address Pointer */
} IfxLeth_TxDescr1_RF_Bits;

/** \brief Bit Fields of TDES1 in Write-back Format
 */
typedef struct
{
    uint32 TTSH : 32;       /**< \brief Transmit Packet Timestamp High */
} IfxLeth_TxDescr1_WF_Bits;

/** \brief Bit Fields of TDES2 in Read Format
 */
typedef struct
{
    uint32 B1L : 14;            /**< \brief Header Length or Buffer 1 Length */
    uint32 VTIR : 2;            /**< \brief VLAN Tag Insertion or Replacement */
    uint32 B2L : 14;            /**< \brief Buffer 2 Length */
    uint32 TTSE_TMWD : 1;       /**< \brief Transmit Timestamp Enable or External TSO Memory Write Enable */
    uint32 IOC : 1;             /**< \brief Interrupt on Completion */
} IfxLeth_TxDescr2_RF_Bits;

/** \brief Bit Fields of TDES2 in Write-back Format
 */
typedef struct
{
    uint32 reserved_0 : 32;       /**< \brief Reserved */
} IfxLeth_TxDescr2_WF_Bits;

/** \brief Bit Fields of TDES3 in Read Format
 */
typedef struct
{
    uint32 FL : 15;               /**< \brief Packet Length or TCP Payload Length */
    uint32 TPL : 1;               /**< \brief Reserved or TCP Payload Length */
    uint32 CIC_TPL : 2;           /**< \brief Checksum Insertion Control or TCP Payload LengthThese bits control the checksum */
    uint32 TSE : 1;               /**< \brief TCP Segmentation Enable */
    uint32 SLOTNUM_THL : 4;       /**< \brief SLOTNUM: Slot Number Control Bits in AV Mode */
    uint32 SAIC : 3;              /**< \brief SA Insertion Control */
    uint32 CPC : 2;               /**< \brief CRC Pad Control */
    uint32 LD : 1;                /**< \brief Last Descriptor */
    uint32 FD : 1;                /**< \brief First Descriptor */
    uint32 CTXT : 1;              /**< \brief Context TypeThis bit should be set to 1'b0 for normal descriptor */
    uint32 OWN : 1;               /**< \brief Own Bit */
} IfxLeth_TxDescr3_RF_Bits;

/** \brief Bit Fields of TDES3 in Write-back Format
 */
typedef struct
{
    uint32 IHE : 1;                /**< \brief IP Header Error */
    uint32 DB : 1;                 /**< \brief Deferred Bit */
    uint32 UF : 1;                 /**< \brief Underflow Error */
    uint32 ED : 1;                 /**< \brief Excessive Deferral */
    uint32 CC : 4;                 /**< \brief Collision Count */
    uint32 EC : 1;                 /**< \brief Excessive Collision */
    uint32 LC : 1;                 /**< \brief Late Collision */
    uint32 NC : 1;                 /**< \brief No Carrier */
    uint32 LOC : 1;                /**< \brief Loss of Carrier */
    uint32 PCE : 1;                /**< \brief Payload Checksum */
    uint32 FF : 1;                 /**< \brief Packet Flushed */
    uint32 JT : 1;                 /**< \brief Jabber Timeout */
    uint32 ES : 1;                 /**< \brief Error Summary */
    uint32 reserved_16 : 1;        /**< \brief Reserved */
    uint32 TTSS : 1;               /**< \brief Tx Timestamp Status */
    uint32 reserved_18 : 10;       /**< \brief Reserved */
    uint32 LD : 1;                 /**< \brief Last Descriptor */
    uint32 FD : 1;                 /**< \brief First Descriptor */
    uint32 CTXT : 1;               /**< \brief Context Type */
    uint32 OWN : 1;                /**< \brief Own bit */
} IfxLeth_TxDescr3_WF_Bits;

/** \} */

/** \addtogroup IfxLld_Leth_Std_Unions
 * \{ */
/** \brief RDES0
 */
typedef union
{
    IfxLeth_RxDescr0_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_RxDescr0_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxLeth_RxContextDescr0_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_RxDescr0;

/** \brief RDES1
 */
typedef union
{
    IfxLeth_RxDescr1_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_RxDescr1_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxLeth_RxContextDescr1_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_RxDescr1;

/** \brief RDES2
 */
typedef union
{
    IfxLeth_RxDescr2_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_RxDescr2_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxLeth_RxContextDescr2_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_RxDescr2;

/** \brief RDES3
 */
typedef union
{
    IfxLeth_RxDescr3_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_RxDescr3_WF_Bits     W;       /**< \brief Write back Format Bitfiled Access */
    IfxLeth_RxContextDescr3_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_RxDescr3;

/** \brief TDES0
 */
typedef union
{
    IfxLeth_TxDescr0_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_TxDescr0_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxLeth_TxContextDescr0_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_TxDescr0;

/** \brief TDES1
 */
typedef union
{
    IfxLeth_TxDescr1_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_TxDescr1_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxLeth_TxContextDescr1_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_TxDescr1;

/** \brief TDES2
 */
typedef union
{
    IfxLeth_TxDescr2_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_TxDescr2_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxLeth_TxContextDescr2_Bits C;       /**< \brief COntext Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_TxDescr2;

/** \brief TDES3
 */
typedef union
{
    IfxLeth_TxDescr3_RF_Bits     R;       /**< \brief Read Format Bitfiled Access */
    IfxLeth_TxDescr3_WF_Bits     W;       /**< \brief Write-back Format Bitfiled Access */
    IfxLeth_TxContextDescr3_Bits C;       /**< \brief Context Descriptor Format Bitfiled Access */
    uint32                       U;       /**< \brief Unsigned access */
} IfxLeth_TxDescr3;

/** \} */

/** \addtogroup IfxLld_Leth_Std_DataStructures
 * \{ */
/** \brief Rx Descriptor
 */
typedef struct
{
    IfxLeth_RxDescr0 RDES0;       /**< \brief Rx Descriptor DWORD 0 */
    IfxLeth_RxDescr1 RDES1;       /**< \brief Rx Descriptor DWORD 1 */
    IfxLeth_RxDescr2 RDES2;       /**< \brief Rx Descriptor DWORD 2 */
    IfxLeth_RxDescr3 RDES3;       /**< \brief Rx Descriptor DWORD 3 */
} IfxLeth_RxDescr;

/** \brief Tx Descriptor
 */
typedef struct
{
    IfxLeth_TxDescr0 TDES0;       /**< \brief Tx Descriptor DWORD 0 */
    IfxLeth_TxDescr1 TDES1;       /**< \brief Tx Descriptor DWORD 1 */
    IfxLeth_TxDescr2 TDES2;       /**< \brief Tx Descriptor DWORD 2 */
    IfxLeth_TxDescr3 TDES3;       /**< \brief Tx Descriptor DWORD 3 */
} IfxLeth_TxDescr;

/** \} */

/** \addtogroup IfxLld_Leth_Std_DataStructures
 * \{ */
/** \brief PROT and APU configuration
 */
typedef struct
{
    IfxApProt_ProtConfig proteConfig;                                 /**< \brief PROTE configurations */
    IfxApProt_ProtConfig protseConfig;                                /**< \brief PROTSE configurations */
    IfxApApu_ApuConfig   apuGlobalConfig;                             /**< \brief GLOBAL APU Configurations */
    IfxApApu_ApuConfig   apuMacConfig[IFXLETH_NUM_PORTS];             /**< \brief MACi APU Configurations */
    IfxApApu_ApuConfig   apuChConfig[IFXLETH_NUM_DMA_CHANNELS];       /**< \brief Channel i APU Configurations */
} IfxLeth_ApConfig;

/** \brief Configuration data structure of the APU
 */
typedef struct
{
    boolean         prsEnable;       /**< \brief Protection set PRS Tag ID */
    boolean         tagOff;          /**< \brief Extended tag ID offset True:TAG ID 0x3D and False :TAG ID 0x3C */
    boolean         vmEnable;        /**< \brief Virtual machine Enable True : VM Enabled False : VM disabled */
    IfxApProt_VmId  vmId;            /**< \brief Virtual machine ID */
    IfxApProt_PrsId prsId;           /**< \brief Protection set PRS ID */
} IfxLeth_DmaApuConfig;

/** \brief Interrupt configuration structure for LETH SRC nodes
 */
typedef struct
{
    Ifx_Priority priority;       /**< \brief Interrupt service priority */
    IfxSrc_Tos   provider;       /**< \brief Interrupt service provider */
    IfxSrc_VmId  vmId;           /**< \brief Virtual Machine Number */
} IfxLeth_InterruptConfig;

/** \brief leth MDC, MDIO pins only
 */
typedef struct
{
    IfxLeth_P_Out    *mdc;             /**< \brief mdc pin reference */
    IfxLeth_P_InOut  *mdio;            /**< \brief mdio pin reference */
    IfxLeth_PortIndex portIndex;       /**< \brief mdio pin reference for Porti */
} IfxLeth_MdioPins;

/** \brief leth mii pins references
 */
typedef struct
{
    IfxLeth_P_In  *crs;         /**< \brief crs pin reference for mii */
    IfxLeth_P_In  *col;         /**< \brief col pin reference for mii */
    IfxLeth_P_In  *txClk;       /**< \brief txclk pin reference for mii */
    IfxLeth_P_In  *rxClk;       /**< \brief rxclk pin reference for mii */
    IfxLeth_P_In  *rxDv;        /**< \brief rx div pin reference for mii */
    IfxLeth_P_In  *rxEr;        /**< \brief rx er pin reference for mii */
    IfxLeth_P_In  *rxd0;        /**< \brief rx d0 pin reference for mii */
    IfxLeth_P_In  *rxd1;        /**< \brief rxd1 pin reference for mii */
    IfxLeth_P_In  *rxd2;        /**< \brief rxd2 pin reference for mii */
    IfxLeth_P_In  *rxd3;        /**< \brief rxd3 pin reference for mii */
    IfxLeth_P_Out *txEn;        /**< \brief txen pin reference for mii */
    IfxLeth_P_Out *txEr;        /**< \brief txer pin reference for mii */
    IfxLeth_P_Out *txd0;        /**< \brief txd0 pin reference for mii */
    IfxLeth_P_Out *txd1;        /**< \brief txd1 pin reference for mii */
    IfxLeth_P_Out *txd2;        /**< \brief txd2 pin reference for mii */
    IfxLeth_P_Out *txd3;        /**< \brief txd3 pin reference for mii */
} IfxLeth_MiiPins;

/** \brief struct for rmii pins
 */
typedef struct
{
    IfxLeth_P_In  *crsDv;        /**< \brief crsdv pin reference for rmii */
    IfxLeth_P_In  *refClk;       /**< \brief ref clock pin reference for rmii */
    IfxLeth_P_In  *rxd0;         /**< \brief rxd0 pin reference for rmii */
    IfxLeth_P_In  *rxd1;         /**< \brief rxd1 pin reference for rmii */
    IfxLeth_P_Out *txd0;         /**< \brief txd0 pin reference for rmii */
    IfxLeth_P_Out *txd1;         /**< \brief txd1 pin reference for rmii */
    IfxLeth_P_Out *txEn;         /**< \brief txEn pin reference for rmii */
} IfxLeth_RmiiPins;

/** \brief Rx Descriptor List
 */
typedef struct
{
    volatile IfxLeth_RxDescr descr[IFXLETH_MAX_RX_DESCRIPTORS];       /**< \brief list of RX descriptors */
} IfxLeth_RxDescrList;

/** \brief leth TC14 pins references
 */
typedef struct
{
    IfxLeth_P_In  *rx;       /**< \brief rx pin reference for TC14 */
    IfxLeth_P_In  *ed;       /**< \brief ed pin reference for TC14 */
    IfxLeth_P_Out *tx;       /**< \brief tx pin reference for TC14 */
} IfxLeth_TC14Pins;

/** \brief Tx Descriptor List
 */
typedef struct
{
    volatile IfxLeth_TxDescr descr[IFXLETH_MAX_TX_DESCRIPTORS];       /**< \brief list of TX descriptors */
} IfxLeth_TxDescrList;

/** \brief Leth TXQs and RXCs Enable config
 *  Refer to PORTi_CTRL_REG Register
 */
typedef struct
{
    uint8 txQueues;         /**< \brief Enable any of the TxQ[(IFXLETH_NUM_TX_QUEUES-1):0]. (Refer to IfxLeth_cfg.h for IFXLETH_NUM_TX_QUEUES), varies in each derivative. Setting Bit n enables corresponding TxQn. Eg: Value = 1 enables TxQ0, Value = 0x1F enables TXQ0, TXQ1,... TXQ4. */
    uint8 rxChannels;       /**< \brief Enable any of the RxC[(IFXLETH_NUM_RX_CHANNELS-1):0]. (Refer to IfxLeth_cfg.h for IFXLETH_NUM_RX_CHANNELS), varies in each derivative. Setting Bit n enables corresponding RxCn. Eg: Value = 1 enables RxC0, Value = 0xFF enables RXC0, RXC1,... RXC7. */
} IfxLeth_TxQRxCEnableConfig;

/** \} */

/** \addtogroup IfxLld_Leth_Std_Functions
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns the status of whether clock for LETH module is enabled or disabled
 * \param lethSFR Pointer to LETH register base address
 * \return Status:\n
 * TRUE : if module is enabled\n
 * FALSE : if module is disabled
 */
IFX_INLINE boolean IfxLeth_isModuleEnabled(Ifx_LETH *lethSFR);

/** \brief Applies a software reset of MAC and DMA controller
 * \param lethSFR Pointer to LETH register base address
 * \return None
 */
IFX_INLINE void IfxLeth_Dma_applySoftwareReset(Ifx_LETH *lethSFR);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Disables the clock for LETH module
 * \param lethSFR Pointer to LETH register base address
 * \return None
 */
IFX_EXTERN void IfxLeth_disableModule(Ifx_LETH *lethSFR);

/** \brief Enables the clock for LETH module
 * \param lethSFR Pointer to LETH register base address
 * \return None
 */
IFX_EXTERN void IfxLeth_enableModule(Ifx_LETH *lethSFR);

/** \brief resets Leth kernel
 * \param lethSFR Pointer to LETH register base address
 * \return None
 */
IFX_EXTERN void IfxLeth_resetModule(Ifx_LETH *lethSFR);

/** \brief Initialize the PROTs and APUs with default configuration
 * \param config Configuration pointer for the Access Protection
 * \return None
 */
IFX_EXTERN void IfxLeth_initApConfig(IfxLeth_ApConfig *config);

/** \brief Initialize the PORTs and APU
 * \param lethSFR LETH module pointer
 * \param config Configuration pointer to the AP
 * \return None
 */
IFX_EXTERN void IfxLeth_initAp(Ifx_LETH *lethSFR, IfxLeth_ApConfig *config);

/** \brief Configures access to all masters to all ACCENs in LETH in the device
 * \param apConfig pointer to configuration structure.
 * \return None
 */
IFX_EXTERN void IfxLeth_configureAccessToLeth(IfxApApu_ApuConfig *apConfig);

/** \brief DMA channel bus ID APU configuration
 * \param lethSFR LETH module pointer
 * \param dmaChannelIndex DMA channel index
 * \param dmaApuConfig Configuration pointer to the DMA channel AP
 * \return None
 */
IFX_EXTERN void IfxLeth_dmaChannelBusIdConfig(Ifx_LETH *lethSFR, IfxLeth_DmaChannel dmaChannelIndex, IfxLeth_DmaApuConfig *dmaApuConfig);

/** \brief Configures RMII output pins
 * \param lethSFR LETH module pointer
 * \param rmiiPins Configuration pointer for RMII pin
 * \return None
 */
IFX_EXTERN void IfxLeth_setupRmiiOutputPins(Ifx_LETH *lethSFR, const IfxLeth_RmiiPins *rmiiPins);

/** \brief Configures RMII input pins
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param rmiiPins Configuration pointer for RMII pin
 * \return None
 */
IFX_EXTERN void IfxLeth_setupRmiiInputPins(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, const IfxLeth_RmiiPins *rmiiPins);

/** \brief Configures RMII pins
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param rmiiPins pointer for RMII pins
 * \return None
 */
IFX_EXTERN void IfxLeth_setRmiiPins(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, const IfxLeth_RmiiPins *rmiiPins);

/** \brief Configures MII input pins
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param miiPins Configuration pointer for MII pin
 * \return None
 */
IFX_EXTERN void IfxLeth_setupMiiInputPins(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, const IfxLeth_MiiPins *miiPins);

/** \brief Configures MII output pins
 * \param lethSFR LETH module pointer
 * \param miiPins Configuration pointer for MII pin
 * \return None
 */
IFX_EXTERN void IfxLeth_setupMiiOutputPins(Ifx_LETH *lethSFR, const IfxLeth_MiiPins *miiPins);

/** \brief Configures MII  pins
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param miiPins Configuration pointer for MII pin
 * \return None
 */
IFX_EXTERN void IfxLeth_setMiiPins(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, const IfxLeth_MiiPins *miiPins);

/** \brief Configures TC14  pins
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param tc14Pins Configuration pointer for TC14 pin
 * \return None
 */
IFX_EXTERN void IfxLeth_setTC14Pins(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, const IfxLeth_TC14Pins *tc14Pins);

/** \brief Set the PHY interfaces for MII, RMII, TC14 modes speed
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param phyInterface Select the LETH PHY speed
 * \param initPhase Select the initialization phase (pre dma init or mac init)
 * \return None
 */
IFX_EXTERN void IfxLeth_setPhyInterface(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, IfxLeth_PhyInterface phyInterface, IfxLeth_PhyInterfacePhase initPhase);

/** \brief Enable the clock for given port
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \return None
 */
IFX_EXTERN void IfxLeth_enablePortClock(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex);

/** \brief Returns the Src Pointer of the selected LETH service request node
 * \param serviceRequest Service Request number
 * \return pointer to Src register
 */
IFX_EXTERN volatile Ifx_SRC_SRCR *IfxLeth_getSrcPointer(IfxLeth_ServiceRequest serviceRequest);

/** \brief Initialize the LETH Port Mode in the bridge
 * \param lethSFR LETH module pointer
 * \param mode Port Mode Configuration options
 * \return None
 */
IFX_EXTERN void IfxLeth_Bridge_setPortMode(Ifx_LETH *lethSFR, IfxLeth_BridgePortMode mode);

/** \brief maps the given tx queue of corresponding port to tx dma, must be called once per tx queue for each port
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param queueNumber tx queue number
 * \param mapValue mapping value
 * \return None
 */
IFX_EXTERN void IfxLeth_Bridge_mapTxQueue(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, IfxLeth_TxMtlQueue queueNumber, IfxLeth_BridgeTxQueueMap mapValue);

/** \brief maps the given RXC of corresponding port to rx dma, must be called once per RXC for each port
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param channelNumber rx channel number in bridge
 * \param mapValue mapping value
 * \return None
 */
IFX_EXTERN void IfxLeth_Bridge_mapRxChannel(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, IfxLeth_BridgeRxChannel channelNumber, IfxLeth_BridgeRxCMap mapValue);

/** \brief enables the tx queues and rx channels of corresponding port, must be called once per each port
 * \param lethSFR LETH module pointer
 * \param portIndex LETH port index
 * \param enable config for tx queue's and rx channel's
 * \return None
 */
IFX_EXTERN void IfxLeth_Bridge_enablePortTxQueuesAndRxChannels(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, IfxLeth_TxQRxCEnableConfig enable);

/** \brief Enable/Disable the MMC Counter Register freeze. When set the MMC Counter register's are freezed and when reset the MMC Counter register's work normal
 * \param lethSFR GETH module pointer
 * \param portIndex port index
 * \param enable TRUE: Enabled, FALSE: Disabled
 * \return None
 */
IFX_EXTERN void IfxLeth_enableMmcCounterFreeze(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex, boolean enable);

/** \brief When invoked all the MMC counter register's are cleared
 * \param lethSFR LETH module pointer
 * \param portIndex port index
 * \return None
 */
IFX_EXTERN void IfxLeth_resetMmcCounter(Ifx_LETH *lethSFR, IfxLeth_PortIndex portIndex);

/** \brief API to set MDIO pins only
 * \param lethSFR leth register pointer
 * \param mdioPins API to set MDC, MDIO only pins
 * \return None
 */
IFX_EXTERN void IfxLeth_setMdioOnlyPins(Ifx_LETH *lethSFR, const IfxLeth_MdioPins *mdioPins);

/** \} */

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE boolean IfxLeth_isModuleEnabled(Ifx_LETH *lethSFR)
{
    return (lethSFR->CLC.B.DISS == 0) ? 1 : 0;
}


IFX_INLINE void IfxLeth_Dma_applySoftwareReset(Ifx_LETH *lethSFR)
{
    lethSFR->DMA.MODE.B.SWR = 1;

    /*Wait 4 CSR clock cycles before reading*/
    __nop();
    __nop();
    __nop();
    __nop();

    /* wait until reset is finished or timeout. */
    {
        uint32 timeout = 0;

        while ((lethSFR->DMA.MODE.B.SWR == 1) && (timeout < IFXLETH_MAX_TIMEOUT_VALUE))
        {
            timeout++;
        }
    }
}


#endif /* IFXLET_H */
