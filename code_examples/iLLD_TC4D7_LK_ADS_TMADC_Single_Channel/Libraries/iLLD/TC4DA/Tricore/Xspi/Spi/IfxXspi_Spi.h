/**
 * \file IfxXspi_Spi.h
 * \brief XSPI SPI details
 * \ingroup IfxLld_Xspi
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * The XSPI interface driver works only as Master
 *
 *     In the following sections it will be described, how to integrate the driver into the application framework.
 *
 *     \section IfxLld_Xspi_Preparation Preparation
 *
 *     \subsection IfxLld_Xspi_Include Include Files
 *
 *     Include following header file into your C code:
 *
 *     \code
 *         #include <Xspi/Spi/IfxXspi_Spi.h>
 *     \endcode
 *
 *     \subsection Xspi_Variables Variables
 *     \code
 *
 *     IfxXspi_Spi_Config     config;
 *
 *     \endcode
 *
 *     Declare the Xspi handle as global variable in your C code:
 *
 *       Xspi Driver needs two steps module Initialisation/configuration i.e
 *          i.      The Hsphy (which acts as the switch for xspi selection) driver module Initialisation/configuration i.e IfxHsphy_Hsphy_initModule
 *          ii.		The Xspi driver module Initialisation/configuration i.e IfxXspi_Spi_initModule
 *
 *       Please refer Hsphy documentation for Hsphy module Initialisation/configuration and xspi pin configuration
 *
 *       The module Initialisation/configuration can be done as follows. Here an example:
 *
 *     \code
 *
 *     config.control.dataFrameSize = IfxXspi_DataframeSize_8; //data frame is 8 bits, match with DMA transferwidth
 *     config.control.clockPhase= IfxXspi_ClockPhase_MiddleBit;
 *     config.control.controlFrameSize = 0;
 *     config.control.clockPolarity = IfxXspi_ClockPolarity_InactiveHigh;
 *     config.control.clockPhase = IfxXspi_ClockPhase_MiddleBit;
 *     config.fifoControl.transferStartFifoLevel = 0;
 *     config.timing.baudrate = 100000000;
 *     config.control.spiFrameFormat = IfxXspi_SpiFrameFormat_Dual;
 *     config.enhancedControl.instLength = IfxXspi_InstructionLength_L8;
 *
 *     //Xspi Pin mapping init
 *     pins.clk = &IfxXspi0_CLK_P16_1_OUT;
 *     pins.cs = &IfxXspi0_CS_P16_13_OUT;
 *     pins.txd0 = &IfxXspi0_TXD0_P16_7_INOUT;
 *     pins.txd1 = &IfxXspi0_TXD1_P16_3_INOUT;
 *     pins.txd2 = &IfxXspi0_TXD2_P16_5_INOUT;
 *     pins.txd3 = &IfxXspi0_TXD3_P16_6_INOUT;
 *     pins.txd4 = &IfxXspi0_TXD4_P16_8_INOUT;
 *     pins.txd5 = &IfxXspi0_TXD5_P16_9_INOUT;
 *     pins.txd6 = &IfxXspi0_TXD6_P16_10_INOUT;
 *     pins.txd7 = &IfxXspi0_TXD7_P16_12_INOUT;
 *     pins.txdm = &IfxXspi0_DM_P16_2_INOUT;
 *
 *     config.xspi = &MODULE_XSPI0;
 *
 *     Once the above steps are successfully done the API mentioned in the Xspi interface file can be invoked accordingly by parsing the required parameter
 *     Refer the corresponding API for details
 *
 *     IfxXspi_Spi_initModule(&xspi, &config);
 *
 *     \endcode
 *
 * \defgroup IfxLld_Xspi_Spi SPI
 * \ingroup IfxLld_Xspi
 * \defgroup IfxLld_Xspi_Spi_DataStructures Data Structures
 * \ingroup IfxLld_Xspi_Spi
 * \defgroup IfxLld_Xspi_Spi_ModuleFunctions Module Functions
 * \ingroup IfxLld_Xspi_Spi
 * \defgroup IfxLld_Xspi_Spi_InterruptFunctions Interrupt Functions
 * \ingroup IfxLld_Xspi_Spi
 * \defgroup IfxLld_Xspi_Spi_CommunicationFunctions Communication Functions
 * \ingroup IfxLld_Xspi_Spi
 */

#ifndef IFXXSPI_SPI_H
#define IFXXSPI_SPI_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Xspi/Std/IfxXspi.h"

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Xspi_Spi_DataStructures
 * \{ */
/** \brief Structure for Interrupt Mask
 */
typedef struct
{
    IfxXspi_InterruptMask doneInterruptMask;                    /**< \brief Done Interrupt Mask */
    IfxXspi_InterruptMask txFifoUnderFlowInterruptMask;         /**< \brief Transmit FIFO Underflow Interrupt Mask */
    IfxXspi_InterruptMask multiMasterInterruptMask;             /**< \brief Multi-Master Contention Interrupt Mask */
    IfxXspi_InterruptMask rxFifoFullInterruptMask;              /**< \brief Receive FIFO Full Interrupt Mask */
    IfxXspi_InterruptMask rxFifoOverFlowInterruptMask;          /**< \brief Receive FIFO Overflow Interrupt Mask */
    IfxXspi_InterruptMask rxFifoUnderFlowInterruptMask;         /**< \brief Receive FIFO Underflow Interrupt Mask */
    IfxXspi_InterruptMask txFifoOverFlowInterruptMask;          /**< \brief Transmit FIFO Overflow Interrupt Mask */
    IfxXspi_InterruptMask txFifoEmptyInterruptMask;             /**< \brief Transmit FIFO Empty Interrupt Mask */
    IfxXspi_InterruptMask xipRxFifoOverFlowInterruptMask;       /**< \brief XIP Rx FIFO OverFlowInterrupt Mask */
    IfxXspi_InterruptMask errorInterruptMask;                   /**< \brief Error Interrupt Mask */
} IfxXspi_Spi_InterruptMask;

/** \} */

/** \addtogroup IfxLld_Xspi_Spi_DataStructures
 * \{ */
/** \brief Structure for main core parameter config
 */
typedef struct
{
    uint8                      controlFrameSize;         /**< \brief Control Frame Size */
    uint16                     numberOfDataFrames;       /**< \brief Number of Data Frames */
    IfxXspi_Hyperbus           hyperbusEnable;           /**< \brief HyperBus Enable/Disable */
    IfxXspi_SpiFrameFormat     spiFrameFormat;           /**< \brief SPI Frame Format for STD,DUAL,QAUD,OCTAL */
    IfxXspi_SlaveSelectToggle  slaveSelectToggle;        /**< \brief Slave Select Toggle Enable */
    IfxXspi_ShiftRegisterLoop  loopBack;                 /**< \brief Shift Register Loop (LoopBack) Enable */
    IfxXspi_TransferMode       transferMode;             /**< \brief Transfer Mode Select Tx,Rx,Tx and Rx, EEPROM Read */
    IfxXspi_ClockPolarity      clockPolarity;            /**< \brief Clock Polarity */
    IfxXspi_ClockPhase         clockPhase;               /**< \brief Clock Phase */
    IfxXspi_DataframeSize      dataFrameSize;            /**< \brief Data Frame Size, Selects the data frame length */
    IfxXspi_SlaveOutputControl slaveOutputControl;       /**< \brief Slave output enable */
} IfxXspi_Spi_Control;

/** \brief Structure for DMA Config
 */
typedef struct
{
    boolean               txFifoDmaEnable;              /**< \brief Transmit Fifo DMA Enable */
    boolean               rxFifoDmaEnable;              /**< \brief Receive Fifo DMA Enable */
    boolean               internalDmaEnable;            /**< \brief DMA Enable */
    boolean               addressIncrement;             /**< \brief Address Increment (increment the AXI address on every transfer) */
    uint8                 destinationBurstLength;       /**< \brief Destination Burst Length */
    uint8                 sourceBurstLength;            /**< \brief Source Burst Length */
    uint16                dmaTxDataLevel;               /**< \brief Transmit Data Level */
    uint16                dmaRxDataLevel;               /**< \brief Receive Data Level */
    IfxXspi_TransferWidth transferwidth;                /**< \brief DMA Transfer Width */
} IfxXspi_Spi_DmaConfig;

/** \brief Structure for Enhanced parameter for main core  config
 */
typedef struct
{
    boolean                           clockStretchEnable;           /**< \brief Enables clock stretching capability in SPI transfer */
    boolean                           spiRxdsSignalEnable;          /**< \brief Enable rxds signaling during address and command phase of Hypebus transfer */
    boolean                           spiDataMaskEnable;            /**< \brief SPI data mask enable bit */
    boolean                           spiRxdsEnable;                /**< \brief Read data strobe enable bit */
    boolean                           instDdrEnable;                /**< \brief Instruction DDR Enable bit. This will enable Dual-data rate transfer for Instruction phase */
    boolean                           spiDdrEnable;                 /**< \brief SPI DDR Enable bit. This will enable Dual-data rate transfers in Dual/Quad/Octal frame formats of SPI */
    uint8                             waitCycles;                   /**< \brief Wait cycles in Dual/Quad/Octal mode between control frames transmit and data reception Number of SPI clock cycles */
    uint8                             ddrTxDriveEdge;               /**< \brief DDR Transmit Drive Edge */
    IfxXspi_InstructionLength         instLength;                   /**< \brief defines Length of Instruction */
    IfxXspi_AddressLength             addressLength;                /**< \brief defines Length of Address to be transmitted */
    IfxXspi_TransferFormat            transferFormat;               /**< \brief Address and instruction transfer format */
    IfxXspi_XipInstructionPhaseEnable instructionPhaseEnable;       /**< \brief Enable for XIP instruction Phase */
    IfxXspi_XipDataFrameSizeControl   dataFrameSizeControl;         /**< \brief Selection for DFS in XIP transfer */
} IfxXspi_Spi_EnhancedControl;

/** \brief Structure for Transmit and Receive FIFO Control
 */
typedef struct
{
    uint16 transferStartFifoLevel;       /**< \brief Transfer Start Fifo level */
    uint16 txFifoThreshold;              /**< \brief Transmit Fifo Bus Threshold */
    uint16 rxFifoThreshold;              /**< \brief Receive Fifo Bus Threshold */
} IfxXspi_Spi_FifoControl;

/** \brief Structure for interrupt configuration
 */
typedef struct
{
    uint16                    fifoPriority;                /**< \brief Fifo interrupt priority */
    uint16                    errorPriority;               /**< \brief Error priority */
    IfxSrc_VmId               vmId;                        /**< \brief Virtual Machine Number */
    IfxSrc_Tos                fifoIntTypeOfService;        /**< \brief Fifo type of interrupt service */
    IfxSrc_Tos                errorIntTypeOfService;       /**< \brief Error type of interrupt service */
    IfxXspi_Spi_InterruptMask interruptMask;               /**< \brief Interrupt Mask */
} IfxXspi_Spi_InterruptConfig;

/** \brief Structure for data transfer jobs
 */
typedef struct
{
    void  *txdata;          /**< \brief pointer to user data */
    void  *rxdata;          /**< \brief pointer to user data */
    uint32 txpending;       /**< \brief job remaining (count of the data) */
    uint32 rxpending;       /**< \brief job remaining (count of the data) */
} IfxXspi_Spi_Job;

/** \brief Structure for Baudrate Generation
 */
typedef struct
{
    uint32  baudrate;                 /**< \brief value of the required baudrate */
    uint8   rxDataSampleDelay;        /**< \brief Receive Data (rxd) Sample Delay */
    boolean rxDataSamplingEdge;       /**< \brief Receive Data (rxd) Sampling Edge */
} IfxXspi_Spi_Timing;

/** \} */

/** \addtogroup IfxLld_Xspi_Spi_DataStructures
 * \{ */
/** \brief Module Handle
 */
typedef struct
{
    Ifx_XSPI       *xspi;                     /**< \brief  */
    IfxXspi_Spi_Job job;                      /**< \brief structure for Tx job */
    uint8           dataWidth;                /**< \brief width of the data in bytes */
    boolean         transferInProgress;       /**< \brief status of the transfer In progress */
} IfxXspi_Spi;

/** \brief Configuration structure of the module
 */
typedef struct
{
    Ifx_XSPI                   *xspi;
    IfxXspi_Spi_Control         control;
    IfxXspi_Spi_EnhancedControl enhancedControl;
    IfxXspi_Spi_Timing          timing;
    IfxXspi_Spi_FifoControl     fifoControl;
    IfxXspi_Spi_InterruptConfig interruptConfig;
    IfxXspi_Spi_DmaConfig      *dmaConfig;
} IfxXspi_Spi_Config;

/** \brief Structure for cpu job config
 */
typedef struct
{
    void                     *txdata;                  /**< \brief pointer to user data */
    void                     *rxdata;                  /**< \brief pointer to user data */
    uint32                    txcount;                 /**< \brief job remaining (count of the data) */
    uint32                    rxcount;                 /**< \brief job remaining (count of the data) */
    uint32                    waitCycles;              /**< \brief reqd only for enhanced spi modes */
    uint32                    addressLength;           /**< \brief reqd only for enhanced spi modes */
    IfxXspi_TransferMode      transferMode;            /**< \brief Transfer Mode */
    IfxXspi_InstructionLength instructionLength;       /**< \brief Length of instruction to be transfered */
    IfxXspi_ClockPhase        clockPhase;              /**< \brief clock phase configuration */
    IfxXspi_ClockPolarity     clockPolarity;           /**< \brief clock polarity configuration */
    IfxXspi_SlaveSelectEnable slaveSelectEnable;       /**< \brief xspi transfer Slave select enable */
} IfxXspi_Spi_CpuJobConfig;

/** \brief Structure for dma job config
 */
typedef struct
{
    void                     *data;                          /**< \brief pointer to source data  AXIAR0 */
    boolean                   addressIncrement;              /**< \brief 0:  Address Increment (increment the AXI address on every transfer) */
    uint16                    numberOfDataFrames;            /**< \brief number of dataframes to send/fetch NDF */
    IfxXspi_DataframeSize     dataFrameSize;                 /**< \brief Data frame size for DMA transfer */
    IfxXspi_ClockPhase        clockPhase;                    /**< \brief Clock Phase */
    IfxXspi_ClockPolarity     clockPolarity;                 /**< \brief Clock Polarity */
    uint16                    SpiInstruction;                /**< \brief SPI_INST */
    uint32                    spiDeviceAddress;              /**< \brief SPIAR - Device Address */
    uint32                    waitCycles;                    /**< \brief number of wait cycles to received data from xSPI flash */
    IfxXspi_TransferMode      transferMode;                  /**< \brief Transfer Mode */
    IfxXspi_SlaveSelectEnable slaveSelectEnable;             /**< \brief xspi transfer Slave select enable */
    IfxXspi_Hyperbus          hyperbusEnable;                /**< \brief enables hyperbus mode */
    uint16                    xspiClkDivder;                 /**< \brief Clock divider */
    IfxXspi_SpiFrameFormat    spiFrameFormat;                /**< \brief SPI Frame Format for STD,DUAL,QAUD,OCTAL */
    IfxXspi_TransferFormat    transferFormat;                /**< \brief Address and instruction transfer format */
    IfxXspi_AddressLength     addrLength;                    /**< \brief defines Length of Address to be transmitted */
    IfxXspi_InstructionLength instructionLength;             /**< \brief defines Length of instruction to be transmitted */
    boolean                   spiDdrEnable;                  /**< \brief SPI DDR Enable bit. This will enable Dual-data rate transfers in Dual/Quad/Octal frame formats of SPI */
    boolean                   spiReadDataStrobeEnable;       /**< \brief Samples receiving data from flash on data strobe signal */
    boolean                   spiInstDdrEnable;              /**< \brief Enable Dual date rate clock during the instruction phase */
    IfxXspi_TransferWidth     dmaTransferWidth;              /**< \brief Specify the DMA data width */
    uint8                     destBurstLength;               /**< \brief Specify the DMA burst length for tx */
    uint8                     srcBurstLength;                /**< \brief Specify the DMA burst length for rx */
} IfxXspi_Spi_DmaExchangeConfig;

/** \brief Structure for dma job config
 */
typedef struct
{
    void                     *data;                     /**< \brief pointer to source data  AXIAR0 */
    boolean                   addressIncrement;         /**< \brief 0:  Address Increment (increment the AXI address on every transfer) */
    uint16                    numberOfDataFrames;       /**< \brief number of dataframes to send/fetch NDF */
    uint32                    SpiInstruction;           /**< \brief SPI_INST */
    uint32                    spiDeviceAddress;         /**< \brief SPIAR - Device Address */
    uint32                    addressLength;            /**< \brief DMA Address Length */
    uint32                    waitCycles;
    IfxXspi_TransferMode      transferMode;             /**< \brief Transfer Mode */
    IfxXspi_SlaveSelectEnable slaveSelectEnable;        /**< \brief xspi transfer Slave select enable */
} IfxXspi_Spi_DmaJobConfig;

/** \brief Structure for Enhanced mode config
 */
typedef struct
{
    uint16                    numberOfDataFrames;            /**< \brief number of dataframes to send/receive from/to slave */
    IfxXspi_DataframeSize     dataFrameSize;                 /**< \brief Data frame size for XIP transfer */
    IfxXspi_ClockPhase        clockPhase;                    /**< \brief Clock Phase */
    IfxXspi_ClockPolarity     clockPolarity;                 /**< \brief Clock Polarity */
    uint32                    waitCycles;                    /**< \brief number of wait cycles to received data from xSPI flash */
    IfxXspi_TransferFormat    transferFormat;                /**< \brief Address and instruction transfer format */
    IfxXspi_SpiFrameFormat    spiFrameFormat;                /**< \brief SPI Frame Format for STD,DUAL,QAUD,OCTAL */
    IfxXspi_AddressLength     addrLength;                    /**< \brief defines Length of Address to be transmitted */
    IfxXspi_InstructionLength instructionLength;             /**< \brief defines Length of Instruction to be transmitted */
    IfxXspi_Hyperbus          hyperbusEnable;                /**< \brief enables hyperbus mode */
    boolean                   spiDdrEnable;                  /**< \brief SPI DDR Enable bit. This will enable Dual-data rate transfers in Dual/Quad/Octal frame formats of SPI */
    boolean                   spiReadDataStrobeEnable;       /**< \brief Samples receiving data from flash on data strobe signal */
    boolean                   spiInstDdrEnable;              /**< \brief Enable Dual date rate clock during the instruction phase */
    IfxXspi_SlaveSelectEnable slaveSelectEnable;             /**< \brief xspi transfer Slave select enable */
    uint16                    xspiClkDivder;                 /**< \brief xSPI clock divider values */
    uint8                     txFifoThreshLevel;             /**< \brief TX Fifo threshold level to trigger data transmit from xSPI master */
    uint32                   *txData;                        /**< \brief Pointer to transmit data */
    uint32                   *rxData;                        /**< \brief Pointer to received data */
} IfxXspi_Spi_EnhancedModeConfig;

/** \brief xSPI GPIO pins
 */
typedef struct
{
    IfxXspi_Clk_Out    *clk;         /**< \brief clk pin sel for xspi */
    IfxXspi_Clk_Out    *clk_n;       /**< \brief Inverted clk pin sel for xspi */
    IfxXspi_Cs_Out     *cs;          /**< \brief cs pin sel for xspi */
    IfxXspi_Txd0_InOut *txd0;        /**< \brief txd0 pin sel for xspi */
    IfxXspi_Txd1_InOut *txd1;        /**< \brief txd1 pin sel for xspi */
    IfxXspi_Txd2_InOut *txd2;        /**< \brief txd2 pin sel for xspi */
    IfxXspi_Txd3_InOut *txd3;        /**< \brief txd3 pin sel for xspi */
    IfxXspi_Txd4_InOut *txd4;        /**< \brief txd4 pin sel for xspi */
    IfxXspi_Txd5_InOut *txd5;        /**< \brief txd5 pin sel for xspi */
    IfxXspi_Txd6_InOut *txd6;        /**< \brief txd6 pin sel for xspi */
    IfxXspi_Txd7_InOut *txd7;        /**< \brief txd7 pin sel for xspi */
    IfxXspi_Dm_InOut   *txdm;        /**< \brief rwds pin sel for xspi */
} IfxXspi_Spi_GpioPins;

/** \brief Structure for Interrupt Mask
 */
typedef struct
{
    IfxXspi_InterruptStatus doneInterruptStatus;                    /**< \brief Done Interrupt Status */
    IfxXspi_InterruptStatus txFifoUnderFlowInterruptStatus;         /**< \brief Transmit FIFO Underflow Interrupt Status */
    IfxXspi_InterruptStatus multiMasterInterruptStatus;             /**< \brief Multi-Master Contention Interrupt Status */
    IfxXspi_InterruptStatus rxFifoFullInterruptStatus;              /**< \brief Receive FIFO Full Interrupt Status */
    IfxXspi_InterruptStatus rxFifoOverFlowInterruptStatus;          /**< \brief Receive FIFO Overflow Interrupt Status */
    IfxXspi_InterruptStatus rxFifoUnderFlowInterruptStatus;         /**< \brief Receive FIFO Underflow Interrupt Status */
    IfxXspi_InterruptStatus txFifoOverFlowInterruptStatus;          /**< \brief Transmit FIFO Overflow Interrupt Status */
    IfxXspi_InterruptStatus txFifoEmptyInterruptStatus;             /**< \brief Transmit FIFO Empty Interrupt Status */
    IfxXspi_InterruptStatus xipRxFifoOverFlowInterruptStatus;       /**< \brief XIP Rx FIFO OverFlowInterrupt Status */
    IfxXspi_InterruptStatus errorInterruptStatus;                   /**< \brief Error Interrupt Status */
} IfxXspi_Spi_InterruptStatus;

/** \brief Structure for Raw Interrupt Mask
 */
typedef struct
{
    IfxXspi_InterruptStatus doneInterruptRawStatus;                    /**< \brief Raw Done Interrupt Status */
    IfxXspi_InterruptStatus txFifoUnderFlowInterruptRawStatus;         /**< \brief Transmit FIFO Underflow Raw Interrupt Status */
    IfxXspi_InterruptStatus multiMasterInterruptRawStatus;             /**< \brief Multi-Master Contention Raw Interrupt Status */
    IfxXspi_InterruptStatus rxFifoFullInterruptRawStatus;              /**< \brief Receive FIFO Full Raw Interrupt Status */
    IfxXspi_InterruptStatus rxFifoOverFlowInterruptRawStatus;          /**< \brief Receive FIFO Overflow Raw Interrupt Status */
    IfxXspi_InterruptStatus rxFifoUnderFlowInterruptRawStatus;         /**< \brief Receive FIFO Underflow Raw Interrupt Status */
    IfxXspi_InterruptStatus txFifoOverFlowInterruptRawStatus;          /**< \brief Transmit FIFO Overflow Raw Interrupt Status */
    IfxXspi_InterruptStatus txFifoEmptyInterruptRawStatus;             /**< \brief Transmit FIFO Empty Raw Interrupt Status */
    IfxXspi_InterruptStatus xipRxFifoOverFlowInterruptRawStatus;       /**< \brief XIP Rx FIFO OverFlow Raw Interrupt Status */
    IfxXspi_InterruptStatus errorInterruptRawStatus;                   /**< \brief Error Raw Interrupt Status */
} IfxXspi_Spi_RawInterruptStatus;

/** \brief Structure for read/write config
 */
typedef struct
{
    IfxXspi_TransferMode transMode;             /**< \brief Transfer Mode Select Tx,Rx,Tx and Rx, EEPROM Read */
    uint8                waitCycle;             /**< \brief Wait cycles in Dual/Quad/Octal mode between control frames transmit and data reception Number of SPI clock cycles */
    uint16               numOfDataFrames;       /**< \brief Number of Data Frames */
    boolean              rxdsEnable;            /**< \brief TRUE : RXDS signal is valid/enable FALSE : RXDS signal is invalid/disable */
} IfxXspi_Spi_ReadWriteConfig;

/** \brief Structure for Transmission Status(Read_Only)
 */
typedef struct
{
    uint16                completedDataFrames;       /**< \brief Completed Data frames (data frames transferred in the previous internal DMA transfer) */
    IfxXspi_Dwc_Status    xSpiBusy;                  /**< \brief SPI Busy */
    IfxXspi_DataCollision dataCollisionError;        /**< \brief Data Collision Error */
    IfxXspi_RxFifoFull    rxFifoFull;                /**< \brief Receive FIFO Full */
    IfxXspi_TxFifoEmpty   txFifoEmpty;               /**< \brief Transmit FIFO Empty */
    IfxXspi_TxFifoFull    txFifoFull;                /**< \brief Transmit FIFO Full */
    IfxXspi_RxFifoEmpty   rxFifoEmpty;               /**< \brief Receive FIFO Empty */
} IfxXspi_Spi_Status;

/** \brief Structure for Std mode config
 */
typedef struct
{
    uint16                    nosOfDataFramesTransmit;       /**< \brief number of dataframes to send/receive from/to slave */
    uint16                    nosOfDataFramesReceive;        /**< \brief number of dataframes to send/receive from/to slave */
    uint32                    waitCycles;                    /**< \brief number of wait cycles to received data from xSPI flash */
    IfxXspi_DataframeSize     dataFrameSize;                 /**< \brief Data frame size for XIP transfer */
    IfxXspi_ClockPhase        clockPhase;                    /**< \brief Clock Phase */
    IfxXspi_ClockPolarity     clockPolarity;                 /**< \brief Clock Polarity */
    uint16                    xspiClkDivder;                 /**< \brief Clock divider */
    IfxXspi_SlaveSelectEnable slaveSelectEnable;             /**< \brief xspi transfer Slave select enable */
    uint8                     txFifoThreshLevel;             /**< \brief TX Fifo threshold level to trigger data transmit from xSPI master */
    uint32                   *txData;                        /**< \brief Pointer to transmit data */
    uint32                   *rxData;                        /**< \brief Pointer to received data */
} IfxXspi_Spi_StdModeConfig;

/** \brief Structure for XIP Config
 */
typedef struct
{
    boolean                           xipPreFetchInstEnable;        /**< \brief XIP pre fetch instruction enable */
    boolean                           xipModeBitEnable;             /**< \brief XIP mode bit enable */
    boolean                           xipFixDfs;                    /**< \brief XIP continuous mode DFS fix */
    uint8                             counterTimeOut;               /**< \brief XIP time out value in terms of hclk */
    uint16                            incrInstruction;              /**< \brief Opcodes to be transfered in instruction phase of XIP transfer */
    uint16                            wrapInstruction;              /**< \brief Opcodes to be transfered in instruction phase of XIP transfer */
    uint16                            xipModeBitsValue;             /**< \brief XIP mode bit value to be Transmit */
    IfxXspi_InstructionLength         instLength;                   /**< \brief Instruction Length for XIP transfer */
    IfxXspi_DataframeSize             dataFrameSize;                /**< \brief Data frame size for XIP transfer */
    IfxXspi_XipContTransfer           contTransfer;                 /**< \brief Continous or Non continous XIP transfer */
    IfxXspi_XipInstructionPhaseEnable instructionPhaseEnable;       /**< \brief Enable for XIP instruction Phase */
    IfxXspi_XipSlaveSelectEnable      slaveSelectEnable;            /**< \brief XIP transfer slave select enable */
    IfxXspi_XipBitLength              xipModeBitLen;                /**< \brief XIP mode bit enable */
} IfxXspi_Spi_XipConfig;

/** \brief Structure for Enhanced mode config
 */
typedef struct
{
    uint16                    numberOfDataFrames;            /**< \brief number of dataframes to send/receive from/to slave */
    IfxXspi_DataframeSize     dataFrameSize;                 /**< \brief Data frame size for XIP transfer */
    IfxXspi_ClockPhase        clockPhase;                    /**< \brief clock Phase */
    IfxXspi_ClockPolarity     clockPolarity;                 /**< \brief clock Polarity */
    uint32                    waitCycles;                    /**< \brief number of wait cycles to received data from xSPI flash */
    IfxXspi_TransferFormat    transferFormat;                /**< \brief Address and instruction transfer format */
    IfxXspi_SpiFrameFormat    spiFrameFormat;                /**< \brief SPI Frame Format for STD,DUAL,QAUD,OCTAL */
    IfxXspi_Hyperbus          hyperbusEnable;                /**< \brief enables hyperbus mode */
    IfxXspi_AddressLength     addrLength;                    /**< \brief defines Length of Address to be transmitted */
    IfxXspi_InstructionLength instructionLength;             /**< \brief defines Length of Instruction to be transmitted */
    boolean                   spiDdrEnable;                  /**< \brief SPI DDR Enable bit. This will enable Dual-data rate transfers in Dual/Quad/Octal frame formats of SPI */
    boolean                   spiReadDataStrobeEnable;       /**< \brief Samples receiving data from flash on data strobe signal */
    boolean                   spiInstDdrEnable;              /**< \brief Enable Dual date rate clock during the instruction phase */
    IfxXspi_SlaveSelectEnable slaveSelectEnable;             /**< \brief xspi transfer Slave select enable */
    uint16                    xspiClkDivder;                 /**< \brief xSPI clock divider values */
    uint8                     txFifoThreshLevel;             /**< \brief TX Fifo threshold level to trigger data transmit from xSPI master */
    IfxXspi_XipMemType        readXipMemType;                /**< \brief Select the XIP cached or Non Cached memory */
    boolean                   xipModeBitsEnable;             /**< \brief Enable if the mode bits needs to be transmitted in XIP mode */
    boolean                   xipContinuousTransfer;         /**< \brief Enable if the continuous XIP transfers needs to be triggered */
    boolean                   xipDataFrameSizeEnable;        /**< \brief TRUE: DFS from CTRL0.DFS will be considered FALSE: DFS will be derived from BURST/SIZE AXI Signals */
    boolean                   xipInstFrameEnable;            /**< \brief Enables instruction fram during XIP cmd+data phase */
    IfxXspi_XipBitLength      xipBitLen;                     /**< \brief Specify the lenght of mode bits to be send if mode bits are enabled */
    boolean                   xipPreFetchEnable;             /**< \brief Enables XIP prefetch feature */
    uint8                     xipTimeoutValue;               /**< \brief Specify the timeout value for XIP continuous mode if enabled Note: 0x00 means counter is disabled */
    uint16                    xipIncrInstruction;            /**< \brief Specify INCR type instruction value to send out in XIP transfer to flash side */
    uint16                    xipWrapInstruction;            /**< \brief Specify WRAP type instruction value to send out in XIP transfer to flash side */
    uint16                    xipModeBitsValue;              /**< \brief Specify mode bit values to send out in XIP transfer to flash side */
    volatile uint32          *rxData;                        /**< \brief Pointer to receive the XIP read data from cached/Non cached XIP memory */
} IfxXspi_Spi_XipModeConfig;

/** \brief Configuration structure of the module
 */
typedef struct
{
    Ifx_XSPI                 *xspi;
    IfxXspi_Hyperbus          hyperbusEnable;
    uint16                    xspiClkDivder;
    IfxXspi_SpiFrameFormat    spiFrameFormat;
    IfxXspi_TransferFormat    transferFormat;
    IfxXspi_AddressLength     addrLength;
    IfxXspi_InstructionLength instructionLength;
    IfxXspi_SlaveSelectEnable slaveSelectEnable;       /**< \brief xspi transfer Slave select enable */
    boolean                   spiDdrEnable;            /**< \brief SPI DDR Enable bit. This will enable Dual-data rate transfers in Dual/Quad/Octal frame formats of SPI */
    IfxXspi_TransferMode      transferMode;            /**< \brief Transfer Mode */
    IfxXspi_DataframeSize     dataFrameSize;           /**< \brief Data frame size for XIP transfer */
} IfxXspi_Spi_initTransferConfig;

/** \} */

/** \addtogroup IfxLld_Xspi_Spi_ModuleFunctions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Initialises the module
 * xspi module handle
 * config predefined configuration structure of the module
 * return Status
 */
IFX_EXTERN IfxXspi_Status IfxXspi_Spi_initModule(IfxXspi_Spi *xspi, const IfxXspi_Spi_Config *config);

/** \brief Fills the configuration structure with default values
 * config predefined configuration structure of the module
 * xspi pointer to XSPI registers
 * \return None
 */
IFX_EXTERN void IfxXspi_Spi_initModuleConfig(IfxXspi_Spi_Config *config, Ifx_XSPI *xspi);

/** \brief Init the xSPI to transfer the data
 * \param xspi pointer to XSPI registers
 * \param config configuration structure of the transfer module
 * \return None
 */
IFX_EXTERN void IfxXspi_Spi_transferInit(Ifx_XSPI *xspi, IfxXspi_Spi_initTransferConfig *config);

/** \} */

/** \addtogroup IfxLld_Xspi_Spi_InterruptFunctions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief IST Receive Routine
 * Module Handle
 * \return Zero : All interrupts are cleared, Non Zero : All interrupts are not cleared
 */
IFX_EXTERN uint32 IfxXspi_Spi_isrReceive(IfxXspi_Spi *xspi);

/** \brief Module Handle
 *  Getting the Raw Interrupt Status
 * \return None
 */
IFX_EXTERN void IfxXspi_Spi_getRawInterruptStatus(IfxXspi_Spi *xspi, IfxXspi_Spi_RawInterruptStatus *rawInterruptStatus);

/** \brief ISR Transmit Routine
 *  Module Handle
 * \return None
 */
IFX_EXTERN void IfxXspi_Spi_isrTransmit(IfxXspi_Spi *xspi);

/** \brief ISR DMA Receive Routine
 *  Module Handle
 * \return Zero : All interrupts are cleared, Non Zero : All interrupts are not cleared
 */
IFX_EXTERN uint32 IfxXspi_Spi_isrDmaReceive(IfxXspi_Spi *xspi);

/** \brief ISR DMA Transmit Routine
 *  Module Handle
 * \return None
 */
IFX_EXTERN void IfxXspi_Spi_isrDmaTransmit(IfxXspi_Spi *xspi);

/** \brief Module Handle
 * Getting the status of the Bus
 */
IFX_EXTERN IfxXspi_BusStatus IfxXspi_Spi_getstatus(IfxXspi_Spi *xspi);

/** \} */

/** \addtogroup IfxLld_Xspi_Spi_CommunicationFunctions
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief DMA Exchange
 * Module Handle
 * DMA Job Config structure
 * return Status
 */
IFX_EXTERN IfxXspi_Spi_Status IfxXspi_Spi_dmaExchange(IfxXspi_Spi *xspi, IfxXspi_Spi_DmaJobConfig *dmaJob);

/** \brief Filling Tx Buffer sending data
 * \return None
 */
IFX_EXTERN void IfxXspi_Spi_fillTxBuffer(IfxXspi_Spi *xspi);

/** \brief starts the data exchange
 * Module Handle
 * Structure for cpu job config
 * return status
 */
IFX_EXTERN boolean IfxXspi_Spi_exchange(IfxXspi_Spi *xspi, IfxXspi_Spi_CpuJobConfig *jobConfig);

/** \brief Reads data from the Rx FIFO based on the outlet width
 * Module Handle
 * \return None
 */
IFX_EXTERN void IfxXspi_Spi_read(IfxXspi_Spi *xspi);

/** \brief triggers eXecute in place transfer (single / continuous mode)
 */
IFX_EXTERN boolean IfxXspi_Spi_triggerXipTransfer(IfxXspi_Spi *xspi, IfxXspi_Spi_XipConfig *config);

/** \brief Write API to send the data to xSPI flash device
 * \param config configuration structure of the transfer module
 * \param address config the address memory cell to write the data
 * \return Returns write status
 */
IFX_EXTERN boolean IfxXspi_Spi_hyperbus_write_address_data(IfxXspi_Spi_ReadWriteConfig *config, uint32 address, uint16 data);

/** \brief API to read the data received from xSPI flash device
 * \param config configuration structure of the transfer module
 * \return Returns write status
 */
IFX_EXTERN boolean IfxXspi_Spi_hyperbus_read_address_data(IfxXspi_Spi_ReadWriteConfig *config, uint32 address, uint16 *data);

/** \brief API to exchange data between xSPI flash device in Standard SPI mode
 * \param xspi xSPI SFR Module Handle
 * \param config configuration structure of the Standard transfer mode
 * \return Returns status
 */
IFX_EXTERN IfxXspi_Status IfxXspi_Spi_stdDataExchange(Ifx_XSPI *xspi, IfxXspi_Spi_StdModeConfig *config);

/** \brief API to write the data to xSPI flash device in enhanced xSPI modes (Dual/Quad/Octel)
 * \param xspi xSPI SFR Module Handle
 * \param config configuration structure of the enhanced xSPI modes
 * \return Returns None
 */
IFX_EXTERN void IfxXspi_Spi_enhancedDataTransmit(Ifx_XSPI *xspi, IfxXspi_Spi_EnhancedModeConfig *config);

/** \brief API to read the data from xSPI flash device in enhanced xSPI modes (Dual/Quad/Octel)
 * \param xspi xSPI SFR Module Handle
 * \param config configuration structure of the enhanced xSPI modes
 * \return Returns status
 */
IFX_EXTERN IfxXspi_Status IfxXspi_Spi_enhancedDataReceive(Ifx_XSPI *xspi, IfxXspi_Spi_EnhancedModeConfig *config);

/** \brief API to read the data from xSPI flash in XIP mode
 * \param xspi xSPI SFR Module Handle
 * \param config config configuration structure of the eXecute in place mode
 * \return Returns None
 */
IFX_EXTERN void IfxXspi_Spi_xipDataRead(Ifx_XSPI *xspi, IfxXspi_Spi_XipModeConfig *config);

/** \brief API set xSPI pins for GPIO pads
 * \param xspi xSPI SFR Module Handle
 * \param pins xSPI GPIO pin pointer
 * \return Returns None
 */
IFX_EXTERN void IfxXspi_Spi_setXspiGpioPins(Ifx_XSPI *xspi, IfxXspi_Spi_GpioPins *pins);

/** \brief API to exchange data between xSPI flash devices in enhanced xSPI modes (Dual/Quad/Octel)
 * \param xspi xSPI SFR Module Handle
 * \return Returns Status
 */
IFX_EXTERN IfxXspi_Status IfxXspi_Spi_dmaEnhancedDataExchange(Ifx_XSPI *xspi, IfxXspi_Spi_DmaExchangeConfig *config);

/** \} */

#endif /* IFXXSPI_SPI_H */
