/**
 * \file IfxEgtm_Tom.c
 * \brief EGTM  basic functionality
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2023 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "IfxEgtm_Tom.h"

/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

uint32 IfxEgtm_Tom_Tgc_buildFeature(uint16 enableMask, uint16 disableMask, uint8 bitfieldOffset)
{
    uint8  i;
    uint32 reg  = 0u;
    uint32 mask = (uint32)((uint32)(enableMask | ((uint32)disableMask << 16u)));

    for (i = 0u; i < IFXEGTM_TOM_NUM_TGC_CHANNELS; i++)
    {
        /* Bitfield length is 2 bits */
        uint8 shift = (i << 1u) + bitfieldOffset;

        if ((mask & 0x1u) == 0x1u)
        {
            reg |= (uint32)((uint32)IfxEgtm_FeatureControl_enable << shift);
        }

        if ((mask & 0x10000u) == 0x10000u)
        {
            reg |= (uint32)((uint32)IfxEgtm_FeatureControl_disable << shift);
        }

        mask = mask >> 1;
    }

    return reg;
}


uint32 IfxEgtm_Tom_Tgc_buildFeatureForChannel(IfxEgtm_Tom_Ch channel, boolean enabled, uint8 bitfieldOffset)
{
    uint32 reg = 0u;

    /* Bitfield length is 2 bits */
    uint8  shift = (((uint8)channel & 0x7u) << 1u) + bitfieldOffset;

    if (enabled == TRUE)
    {
        reg = (uint32)((uint32)IfxEgtm_FeatureControl_enable << shift);
    }
    else
    {
        reg = (uint32)((uint32)IfxEgtm_FeatureControl_disable << shift);
    }

    return reg;
}


float32 IfxEgtm_Tom_Ch_getFrequency(Ifx_EGTM_CLS_TOM *tom, IfxEgtm_Tom_Ch channel)
{
    float32                   frequency         = 0.0f, sourceFrequency;
    uint32                    periodTicks       = 0u;
    IfxEgtm_Tom_Ch_ResetEvent counterResetEvent = (IfxEgtm_Tom_Ch_ResetEvent)tom->CH[channel].CTRL.B.RST_CCU0;

    while ((counterResetEvent != IfxEgtm_Tom_Ch_ResetEvent_onCm0) &&
           (channel > IfxEgtm_Tom_Ch_0))       /* Counter is reset from previous channel */
    {
        channel           = (IfxEgtm_Tom_Ch)((uint8)channel - 1u);
        counterResetEvent = (IfxEgtm_Tom_Ch_ResetEvent)tom->CH[channel].CTRL.B.RST_CCU0;
    }

    if (counterResetEvent == IfxEgtm_Tom_Ch_ResetEvent_onCm0)
    {
        /* 1. Get channel input frequency */
        sourceFrequency = IfxEgtm_Tom_Ch_getClockFrequency(&MODULE_EGTM, tom, channel);

        /* 2. Calculate Period Ticks */
        if (tom->CH[channel].CTRL.B.UDMODE == 0u)  /* Channel counter running in continuous counting up mode */
        {
            periodTicks = tom->CH[channel].CM0.U;
        }
        else /* Channel counter running in continuous counting up and down mode. Therefore, multiply by 2 */
        {
            periodTicks = (tom->CH[channel].CM0.U - 1u) << 1u;
        }

        /* 3. Calculate PWM frequency */
        frequency = sourceFrequency / (float32)periodTicks;
    }

    return frequency;
}


float32 IfxEgtm_Tom_Ch_getDuty(Ifx_EGTM_CLS_TOM *tom, IfxEgtm_Tom_Ch channel)
{
    float32                   duty = 0.0f;
    uint32                    cm0Reg, cm1Reg, periodReg;
    IfxEgtm_Tom_Ch_ResetEvent counterResetEvent;

    /* 1. Read counter reset event */
    counterResetEvent = (IfxEgtm_Tom_Ch_ResetEvent)tom->CH[channel].CTRL.B.RST_CCU0;

    /* 2. Read register content */
    cm0Reg = tom->CH[channel].CM0.U;
    cm1Reg = tom->CH[channel].CM1.U;

    /* 3. Find out the period register value */
    if (counterResetEvent == IfxEgtm_Tom_Ch_ResetEvent_onCm0)  /* Period is determined by own channel */
    {
        periodReg = cm0Reg;
    }
    else    /* Period is determined by some previous channel */
    {
        uint8 tempChannel = (uint8)channel - 1u;

        while ((tempChannel > 0) &&
               (tom->CH[tempChannel].CTRL.B.RST_CCU0 != (uint8)IfxEgtm_Tom_Ch_ResetEvent_onCm0))
        {
            tempChannel--;
        }

        periodReg = tom->CH[tempChannel].CM0.U;
    }

    /* 4. Calculate Duty percentage */
    if (tom->CH[channel].CTRL.B.UDMODE == 0u)                     /* Channel counter running in continuous counting up mode */
    {
        if (counterResetEvent == IfxEgtm_Tom_Ch_ResetEvent_onCm0) /* Duty exists during CN0 = [0, CM1] */
        {
            duty = ((float32)cm1Reg / (float32)periodReg) * 100.0f;
        }
        else    /* Duty exists during CN0 = [CM0, CM1] */
        {
            if (cm1Reg > cm0Reg)
            {
                duty = ((float32)(cm1Reg - cm0Reg) / (float32)periodReg) * 100.0f;
            }
            else
            {
                duty = ((float32)(cm0Reg - cm1Reg) / (float32)periodReg) * 100.0f;
            }
        }
    }
    else  /* Channel counter running in continuous counting up and down mode */
    {
        /* Duty exists during CN0 = [CM1, CM0] */
        duty = ((float32)(periodReg - cm1Reg) / (float32)periodReg) * 100.0f;
    }

    return duty;
}
