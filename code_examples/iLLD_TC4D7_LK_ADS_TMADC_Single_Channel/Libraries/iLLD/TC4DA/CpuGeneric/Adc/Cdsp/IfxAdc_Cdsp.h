/**
 * \file IfxAdc_Cdsp.h
 * \brief ADC CDSP details
 * \ingroup IfxLld_Adc
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2024 Infineon Technologies AG. All rights reserved.
 *
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *
 * Configurable CDSP module
 *
 * Interface layer of CDSP driver provides initialization and runtime reading of result.
 *
 * \defgroup IfxLld_Adc_Cdsp_Usage How to use the CDSP Interface driver?
 * \ingroup IfxLld_Adc
 *
 *
 *  Configuration of CDSP core:
 *
 *  Configuration of the CDSP core is contained in the IfxAdc_Cdsp_DspCoreConfig structure.
 *  This configuration structure contains:
 *  1. coreId          --> DSP core Id
 *  2. cdspSFR         --> pointer to the SFR base address of CDSP module
 *  3. timestampCfg    --> Time stamp configuration
 *  4. integratorCfg   --> Integrator configuration
 *  5. bndCfg          --> Limit Checking Configuration
 *  6. triggerCfg      --> Trigger setup with all triggers
 *  7. resSrvReqCfg    --> Result service request configuration(SR0)
 *  8. eventSrvReqCfg  --> Timestamp, wakeup event service request configuration.(SR1)
 *  9. alarmSrvReqCfg  --> Alarm service request configuration.(SR2)
 *  10.inputSel        --> CDSP input selection (TMADC, DSADC and GP register)
 *  11.resultCfg       --> Result handling configuration
 *  12.memCfg          --> Memory configuration
 *  13.inputMonitor    --> Input monitor selection
 *  14.runCdspCore     --> Set TRUE to run DSP core at the end of initialization.
 *                         FALSE to run multiple core synchronously. \ref IfxAdc_Cdsp_enableMultipleCores
 *  15.filterchainSel  --> Filter chains selector
 *
 *
 *  Some of the elements are optional during configuration (triggerCfg, timestampCfg, bndCfg, integratorCfg, memCfg, resSrvReqCfg, eventSrvReqCfg, alarmSrvReqCfg).
 *  User has to initialize objects of these types and map them to the config structure, if the user desires to use these functionalities.
 *
 *  Steps to use the driver:
 *
 * \section IfxLld_Adc_Cdsp_Preparation Preparation
 * \subsection IfxLld_Adc_Cdsp_Include Include Files
 *
 * Include following header file into your C code:
 * \code
 * #include <Adc/Cdsp/IfxAdc_Cdsp.h>
 * \endcode
 *
 *
 * \subsection IfxLld_Adc_Cdsp_Interrupt Interrupt Handler Installation (without dma use)
 *
 * See also \ref IfxLld_Cpu_Irq_Usage
 *
 * Define priorities for the Interrupt handlers. This is normally done in the Ifx_IntPrioDef.h file:
 * \code
 * // priorities are normally defined in Ifx_IntPrioDef.h
 * #define IFX_INTPRIO_CDSP_SR0  1
 * #define IFX_INTPRIO_CDSP_SR1  2
 * #define IFX_INTPRIO_CDSP_SR2  3
 * \endcode
 *
 * Add the interrupt service routines to your C code:
 * \code
 * IFX_INTERRUPT(resultIsr, 0, IFX_INTPRIO_CDSP_SR0);
 * IFX_INTERRUPT(eventIsr,  0, IFX_INTPRIO_CDSP_SR1);
 * IFX_INTERRUPT(alarmIsr,  0, IFX_INTPRIO_CDSP_SR2);
 * IfxCpu_enableInterrupts();
 *
 * void resultIsr(void)
 * {
 *   // Read DSP core result
 * }
 *
 * void eventIsr(void)
 * {
 *   //TImestamp, Wakeup Error , System halt
 * }
 *
 * void alarmIsr(void)
 * {
 *   //Alarm for boundary check.
 * }
 *
 * \endcode
 *
 * \subsection IfxLld_Adc_Cdsp_Init Module Initialization
 * \code
 *      //Enable ADC module
 *      IfxAdc_enableModule(&MODULE_ADC);
 *
 *      //Declare a CDSP module structure
 *      IfxAdc_Cdsp_Config moduleConfig;
 *
 *      //Set the global configuration of CDSP to default values.
 *      IfxAdc_Cdsp_initModuleConfig(&moduleConfig, &MODULE_ADC);
 *
 *      //Declare the handle of the CDSP driver
 *      IfxAdc_Cdsp cdspHandle;
 *
 *      //Module initialization. Global clock enable and Handle update will happen in module initialization.
 *      IfxAdc_Cdsp_initModule(&cdspHandle, &moduleConfig);
 *
 *      //Declare a "config" structure of CDSP core configuration,and decide which core you desire to use:
 *      IfxAdc_Cdsp_DspCoreConfig dspConfig;
 *      IfxAdc_CdspCore myCoreId =  IfxAdc_CdspCore_0; // if you wish to use core 0
 *
 *      //Declare a handle structure of Dsp Core.
 *      IfxAdc_Cdsp_Dsp dspCore0Handle;
 *
 *      //Set the configuration to default values, using inbuilt default setting function
 *      IfxAdc_Cdsp_initDspCoreConfig(&dspConfig, &MODULE_ADC);
 *
 *      //If you wish to use the generic optional functionalities (trigger, limitChecking, Integrator), then declare objects of these types and initialize them:
 *      // Modify the configuration as per the application need
 *      //Boundary Configuration
 *      IfxAdc_Cdsp_BoundaryConfig boundaryConfig;
 *      boundaryConfig.upperBound          = 0x900; // --> Values are for illustration purpose
 *      boundaryConfig.lowerBound          = 0x400;
 *      boundaryConfig.hystEn              = FALSE;
 *      boundaryConfig.srvReqConfig        = FALSE; // Generate service request if result inside boundary band
 *      boundaryConfig.srvReqGateEnable    = FALSE; // Service request gate disabled
 *      boundaryConfig.boundaryMode        = IfxAdc_CdspBoundaryCmpMode_disable; //Boundary flag condition disabled
 *
 *      //Trigger Configuration. Timestamp and Integrator trigger configuration is set to NULL_PTR. If required follow the similar steps as boundary trigger and service trigger
 *     IfxAdc_Cdsp_ServReqTrigger srvtrigger    = {IfxAdc_CdspTriggerSel_0, 100};
 *      IfxAdc_Cdsp_Trigger bndtrigger    = {IfxAdc_CdspTriggerSel_1, IfxAdc_CdspTriggerMode_risingEdge, 150};
 *      IfxAdc_Cdsp_TriggerConfig trigCfg = {&srvtrigger, NULL_PTR, &bndtrigger, NULL_PTR};
 *
 *      //Service Request configuration for result, event and alarm
 *      IfxAdc_Cdsp_ResultSrvReq resSrvReq   = {NULL_PTR, 1, IfxSrc_Tos_cpu0, IfxSrc_VmId_0, IfxAdc_CdspSrvReq0_gateHigh};
 *      IfxAdc_Cdsp_EventSrvReq  eventSrvReq = {2, IfxSrc_Tos_cpu0, IfxSrc_VmId_0, IfxAdc_CdspSrvReq1_wakeupErr};
 *      IfxAdc_Cdsp_AlarmSrvReq alarmSrvReq  = {3, IfxSrc_Tos_cpu0, IfxSrc_VmId_0, TRUE};
 *
 *      //Memory Configuration: Refer IfxAdcCdspFw_cfg.h and IfxAdcCdspFw_cfg.c for FGA and FGB filter chain Carray.
 *      //Default ICCM and DCCM configuration for FGA and FGB filter chain is define in IfxAdcCdspFw_cfg.c file.
 *      // Provide the required filter chain ICCM and DCCM array to memory configuration.
 *      //Steps to modify the DCCM configuration.
 *      //1. Declare variable of Cdsp_UserConfig_t structure.
 *      //2. Define the IIR,FIR coefficients and other configuration of the structure as per application need.
 *      //3. Pass the address of DCCM structure to dataMemSrcAddrPtr in memory configuration.
 *      IfxAdc_Cdsp_MemoryConfig memoryCfg = {&cdspFc0IccmImage, &cdspFc0Dccm, cdspFc0IccmImageSize, cdspFc0DccmSize};
 *      //Similar to Boundary configuration, do it for other functionalities.(timestamp, Integrator and trigger configuration)
 *
 *      //Cdsp Input Selection
 *      dspConfig.coreId         = myCoreId;
 *      dspConfig.inputSel       = IfxAdc_CdspInput_gp0;
 *      dspConfig.inputMonitor   = IfxAdc_CdspInputMonitor_gp0;
 *      dspConfig.bndCfg         = &boundaryConfig;
 *      dspConfig.triggerCfg     = &trigCfg;        //Trigger configuration
 *      dspConfig.resSrvReqCfg   = &resSrvReq;      //Result Service request trigger
 *      dspConfig.eventSrvReqCfg = &eventSrvReq;    //Wakeup Error Event service request trigger
 *      dspConfig.alarmSrvReqCfg = &alarmSrvReq;    //Alarm Service request trigger
 *      dspConfig.memCfg         = &memoryCfg;      //Memory Configuration
 *
 *      //Cdsp Result Configuration
 *      dspConfig.resultCfg.disableFifo     = FALSE;
 *      dspConfig.resultCfg.enableTimeStamp = FALSE;
 *      dspConfig.resultCfg.readAsUnsigned  = FALSE;
 *      dspConfig.resultCfg.dataReadWidth   = IfxAdc_CdspDataReadWidth_16Bit;
 *      dspConfig.resultCfg.fifoSrvLevel    = IfxAdc_CdspFifoSrLevel_1;
 *      // For FFT filter use
 *     dspConfig.filterchainSel = IfxAdc_Cdsp_FilterChainSel_fc6,
 *      //Now initialize the Dsp core with your configuration
 *      IfxAdc_Cdsp_initDspCore(&dspCore0Handle, &dspConfig);
 *
 * \endcode
 *
 * The CDSP is ready for use now!
 *
 * \section IfxLld_Adc_Cdsp_ConversionResult Conversion Result
 * \code
 *       uint16 result;
 *      // If FIFO disabled result will be returned as well as updated in handle.
 *      //If FIFO enabled, first result will be returned and based on the fifo service level configuration first result along with remaining values will be updated in the result0 array in handle.
 *       result = IfxAdc_Cdsp_readDspCoreResult(&dspCore0Handle);
 *
 *       //Result 0: dspCore0Handle.result[]
 *       //Timestamp : dspCore0Handle.timestamp
 *       //API to read result from result register if FIFO disabled
 *       IfxAdc_Cdsp_Result cdspResult;
 *       cdspResult = IfxAdc_Cdsp_readResult(&dspCore0Handle);
 *       result    = cdspResult.result;
 *       timestamp = cdspResult.timestamp;
 *
 *      //API to read result from RES1 register
 *      uint32 result1, result2;
 *      result1 = IfxAdc_Cdsp_readSecondaryResult(&dspCore0Handle);
 *
 *      //API to read result from RES2 register
 *      result2 = IfxAdc_Cdsp_readTertiaryResult(&dspCore0Handle);
 *
 * \endcode
 *
 *  NOTE : Buffer size is made as enum in configuration due to limitation of DMA.
 *  When DMA is configured to fill data in circular buffer possible sizes are in power of 2.
 *
 *  \subsection IfxLld_Adc_Cdsp_Queue CDSP Linear Buffer configuration with Type of Service as CPU
 *  The conversion result in the CDSP result register is copied in software buffer on result service request event.
 *  The callback is provided on buffer full if configured.
 *
 *  Create an interrupt handler for result service request:
 *  \code
 *   // priorities are normally defined in Ifx_IntPrioDef.h
 *   #define IFX_INTPRIO_SR0 10
 *
 *  IFX_INTERRUPT(cdspResultISR, 0, IFX_INTPRIO_SR0)
 *  {
 *       //Result will be copied to software buffer. Provides a callback if software buffer gets full
 *       IfxAdc_Cdsp_resultIsr(&dspCore0Handle);
 *  }
 *  \endcode
 *
 *  Callback if software buffer gets full
 *  \code
 *   void bufferFull()
 *   {
 *       sint16 result;
 *       for(index =0; index < BUFFER_SIZE; index++)
 *       {
 *            result = (sint16)resultBuffer[index]; //use result value
 *       }
 *
 *       //New buffer or same buffer could be configured for next set of results
 *        buffcount++;
 *        IfxAdc_Cdsp_setupResultBuffer((&dspCore0Handle, (void *)bufAddr[buffcount], IfxAdc_Cdsp_BufferSize_32);
 *   }
 *  \endcode
 *
 *  Callback after result event.
 *  \code
 *   //Callback will be provided to the application after each result event if configured.
 *   void resultHandler()
 *   {
 *      // Result event callback
 *   }
 *  \endcode
 *
 *  Queue Configuration without DMA
 *  \code
 *      #define BUFFER_SIZE 16U
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer[BUFFER_SIZE];
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer1[BUFFER_SIZE];
 *
 *      static buffcount = 0U;
 *      uint32 bufAddr[] = {(uint32)&resultBuffer, (uint32)&resultBuffer1};
 *
 *     //Refer Module initialization section above for below points
 *     //1. Enable ADC module
 *     //2. Declare a CDSP module structure
 *     //3. Set the global configuration of CDSP to default values.
 *     //4. Declare the handle of the CDSP driver
 *     //5. Module initialization. Global clock enable and Handle update will happen in module initialization
 *     //6. Declare a "config" structure of CDSP core configuration
 *     //7. Declare a handle structure of Dsp Core.
 *     //8. Set the configuration to default values
 *     //9. Modify the configuration as per the application need
 *
 *
 *     //10. Result Service request configuration
 *     IfxAdc_Cdsp_ResultSrvReq resSrvReq = {resultHandler, IFX_INTPRIO_SR0, IfxSrc_Tos_cpu0, IfxSrc_VmId_0, IfxAdc_CdspSrvReq0_gateHigh}
 *
 *     //11. Queue configuration
 *     IfxAdc_Cdsp_QueueConfig queueCfg;
 *     queueCfg.dmaCfg            = NULL_PTR;
 *     queueCfg.bufferPtr         = (uint16 *)&resultBuffer;
 *     queueCfg.bufferType        = IfxAdc_Cdsp_BufferType_linear;
 *     // For FFT filter, configure the queue->size = NoOfSamples * 4u
 *     // For Example NoOfSamples = 8.
 *     // queue->size  = IfxAdc_Cdsp_BufferSize_32  ;
 *     queueCfg.size              = IfxAdc_Cdsp_BufferSize_32;
 *     queueCfg.bufferFullHandler = (IfxAdc_Cdsp_Callback)bufferFull; // BUffer full callback is needed only if ToS = CPU
 *
 *     dspConfig.resSrvReqCfg   = &resSrvReq;      //Result Service request
 *     dspConfig.queueCfg       = &queueCfg;
 *
 *     // Configure memory and other required configuration as shown in Module initialization section
 *
 *     //Initialize DSP core.
 *     IfxAdc_Cdsp_initDspCore(&dspCore0Handle, &dspConfig);
 * \endcode
 *
 * \subsection IfxLld_Adc_Cdsp_Queue CDSP Linear Buffer configuration with timestamp enabled and Type of Service as CPU
 *  The conversion result in the CDSP result register is copied in software buffer on result service request event.
 *  The callback is done if the buffer gets full.
 *
 *  Create an interrupt handler for result service request:
 *  \code
 *   // priorities are normally defined in Ifx_IntPrioDef.h
 *   #define IFX_INTPRIO_SR0 10
 *
 *  IFX_INTERRUPT(cdspResultISR, 0, IFX_INTPRIO_SR0)
 *  {
 *       //Result will be copied to software buffer. Provides a callback if software buffer gets full
 *       IfxAdc_Cdsp_resultIsr(&dspCore0Handle);
 *  }
 *  \endcode
 *
 *  Callback if software buffer gets full
 *  \code
 *   void bufferFull()
 *   {
 *       sint16 result;
 *
 *       //New buffer or same buffer could be configured for next set of results
 *        buffcount++;
 *        IfxAdc_Cdsp_setupResultBuffer(&dspCore0Handle, (void *)bufAddr[buffcount], IfxAdc_Cdsp_BufferSize_64);
 *   }
 *  \endcode
 *
 *  Callback after result event.
 *  \code
 *   //Callback will be provided to the application after each result event if configured.
 *   void resultHandler()
 *   {
 *      // Result event callback
 *   }
 *  \endcode
 *
 *  Queue Configuration without DMA
 *  \code
 *      #define NUM_RESULTS 31U
 *      #define BUFFER_SIZE (NUM_RESULTS + 1U) //Adding 1 for timestamp
 *      //Type definition for buffer type. Buffer will contain 1 timestamp and 31 results
 *      IFXADC_CDSP_RESULT_BUFFER_WITH_TS(cdsp0ResType, NUM_RESULTS)
 *
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer[BUFFER_SIZE];
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer1[BUFFER_SIZE];
 *
 *      static buffcount = 0U;
 *      uint32 bufAddr[] = {(uint32)&resultBuffer, (uint32)&resultBuffer1};
 *
 *     //Refer Module initialization section above for below points
 *     //1. Enable ADC module
 *     //2. Declare a CDSP module structure
 *     //3. Set the global configuration of CDSP to default values.
 *     //4. Declare the handle of the CDSP driver
 *     //5. Module initialization. Global clock enable and Handle update will happen in module initialization
 *     //6. Declare a "config" structure of CDSP core configuration
 *     //7. Declare a handle structure of Dsp Core.
 *     //8. Set the configuration to default values
 *     //9. Modify the configuration as per the application need
 *    // Enable the timestamp in result configuration
 *    dspConfig.resultCfg.enableTimeStamp = TRUE;
 *
 *    //Configure timestamp
 *    IfxAdc_Cdsp_TimestampConfig timestampCfg;
 *    timestampCfg.clk          = IfxAdc_CdspTimestampClock_div4;
 *    timestampCfg.startCounter = TRUE;
 *    dspConfig.timestampCfg    = &timestampCfg;
 *
 *     //10. Result Service request configuration
 *     IfxAdc_Cdsp_ResultSrvReq resSrvReq = {resultHandler, IFX_INTPRIO_SR0, IfxSrc_Tos_cpu0, IfxSrc_VmId_0, IfxAdc_CdspSrvReq0_gateHigh}
 *
 *     //11. Queue configuration
 *     IfxAdc_Cdsp_QueueConfig queueCfg;
 *     queueCfg.dmaCfg            = NULL_PTR;
 *     queueCfg.bufferPtr         = (uint16 *)&resultBuffer;
 *     queueCfg.bufferType        = IfxAdc_Cdsp_BufferType_linear;
 *     queueCfg.size              = IfxAdc_Cdsp_BufferSize_64; //size of buffer in bytes.
 *     queueCfg.bufferFullHandler = (IfxAdc_Cdsp_Callback)bufferFull; // BUffer full callback is needed only if ToS = CPU
 *
 *     dspConfig.resSrvReqCfg   = &resSrvReq;      //Result Service request
 *     dspConfig.queueCfg       = &queueCfg;
 *
 *     // Configure memory and other required configuration as shown in Module initialization section
 *
 *     //Initialize DSP core.
 *     IfxAdc_Cdsp_initDspCore(&dspCore0Handle, &dspConfig);
 *
 *
 *     // Reading result and timestamp from the buffer
 *     uint16 timestamp;
 *     sint16 results;
 *     cdsp0ResType *resPtr = (cdsp0ResType *)&resultBuffer;
 *
 *     timestamp = resPtr->timeStamp;  //use timestamp value
 *     for(uint16 index = 0U; index < BUFFER_SIZE; index++)
 *     {
 *        results = resPtr->results[index];  //use result values
 *     }
 *
 * \endcode
 *
 *
 *  \subsection IfxLld_Adc_Cdsp_Queue_Dma CDSP Queue Linear buffer configuration with DMA
 *  The conversion result in the CDSP result register is copied in software buffer on result service request event through DMA.
 *
 *  Create an interrupt handler for result service request:
 *  \code
 *   // priorities are normally defined in Ifx_IntPrioDef.h
 *   #define IFX_INTPRIO_DMA_TO_CPU     20 //DMA interrupt to CPU once the transfer is done or linear buffer is full
 *
 *  IFX_INTERRUPT(cdspDmaResultISR, 0, IFX_INTPRIO_DMA_TO_CPU)
 *  {
 *          buffcount++
 *          //Setup new buffer or same buffer for next set of results
 *          IfxAdc_Cdsp_setupResultBuffer(&dspCore0Handle, (void *)bufAddr[buffcount],  IfxAdc_Cdsp_BufferSize_32);
 *  }
 *  \endcode
 *
 * NOTE: DMA configuration is removed for time being and is under discussion.
 *
 *  Queue Configuration with DMA
 *
 *      //For FFT filter with DMA enable,
 *      //Configure, IfxAdc_Cdsp_QueueConfig queueCfg
 *      //queueCfg.size = IfxAdc_Cdsp_BufferSize_128;  //Number of sample size
 *      //queueCfg.bufferType = IfxAdc_Cdsp_BufferType_linear;
 * Note : IfxAdc_Cdsp_BufferType_circular is not supported in FFT filter.
 *
 *  \code
 *      #define BUFFER_SIZE 16
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer[BUFFER_SIZE];
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer1[BUFFER_SIZE];
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer2[BUFFER_SIZE];
 *
 *      uint32 bufAddr[] = {(uint32)&resultBuffer, (uint32)&resultBuffer1, (uint32)&resultBuffer2};
 *      static uint32 buffcount = 0;
 *
 *     //Refer Module initialization section above for below points
 *     //1. Enable ADC module
 *     //2. Declare a CDSP module structure
 *     //3. Set the global configuration of CDSP to default values.
 *     //4. Declare the handle of the CDSP driver
 *     //5. Module initialization. Global clock enable and Handle update will happen in module initialization
 *     //6. Declare a "config" structure of CDSP core configuration
 *     //7. Declare a handle structure of Dsp Core.
 *     //8. Set the configuration to default values
 *     //9. Modify the configuration as per the application need
 *
 *     //10. Result Service request configuration
 *     IfxAdc_Cdsp_ResultSrvReq resSrvReq = {NULL_PTR, IfxDma_ChannelId_1, IfxSrc_Tos_dma0, IfxSrc_VmId_0, IfxAdc_CdspSrvReq0_gateHigh}
 *
 *     //Service Request configuration from DMA to CPU if buffer is full.
 *     IfxAdc_Cdsp_DmaSrvReq dmaresSrvReq = {IFX_INTPRIO_DMA_TO_CPU, IfxSrc_Tos_cpu0, IfxSrc_VmId_0};
 *
 *     //11. DMA configuration
 *     IfxAdc_Cdsp_DmaConfig dmaConfig;
 *     dmaConfig.channelId    = IfxDma_ChannelId_1;
 *     dmaConfig.dmaId        = IfxDma_Index_0;
 *     dmaConfig.dmaSrvReqCfg = &dmaresSrvReq;
 *
 *     //12. Queue configuration
 *     IfxAdc_Cdsp_QueueConfig queueCfg;
 *     queueCfg.dmaCfg            = &dmaConfig;
 *     queueCfg.bufferPtr         = (uint16 *)&resultBuffer;
 *     queueCfg.size              = IfxAdc_Cdsp_BufferSize_32;  //Buffer size in bytes
 *     queueCfg.bufferType        = IfxAdc_Cdsp_BufferType_linear;
 *     queueCfg.bufferFullHandler = NULL_PTR;
 *
 *     dspConfig.resSrvReqCfg   = &resSrvReq;      //Result Service request
 *
 *     dspConfig.queueCfg       = &queueCfg;
 *
 *     // Configure memory and other required configuration as shown in Module initialization section
 *
 *     //Initialize DSP core.
 *     IfxAdc_Cdsp_initDspCore(&dspCore0Handle, &dspConfig);
 *
 * \endcode
 *
 * \subsection IfxLld_Adc_Cdsp_Queue_Dma CDSP Queue Circular buffer configuration with DMA
 *  The conversion result in the CDSP result register is copied in software buffer on result service request event through DMA.
 *
 *  Circular buffer Configuration with DMA
 *  \code
 *      #define BUFFER_SIZE 16
 *      static uint16 __attribute__ ((aligned(64))) resultBuffer[BUFFER_SIZE];
 *
 *     //Refer Module initialization section above for below points
 *     //1. Enable ADC module
 *     //2. Declare a CDSP module structure
 *     //3. Set the global configuration of CDSP to default values.
 *     //4. Declare the handle of the CDSP driver
 *     //5. Module initialization. Global clock enable and Handle update will happen in module initialization
 *     //6. Declare a "config" structure of CDSP core configuration
 *     //7. Declare a handle structure of Dsp Core.
 *     //8. Set the configuration to default values
 *     //9. Modify the configuration as per the application need
 *
 *     //10. Result Service request configuration
 *     IfxAdc_Cdsp_ResultSrvReq resSrvReq = {NULL_PTR, IfxDma_ChannelId_1, IfxSrc_Tos_dma0, IfxSrc_VmId_0, IfxAdc_CdspSrvReq0_gateHigh}
 *
 *
 *     //11. DMA configuration
 *     IfxAdc_Cdsp_DmaConfig dmaConfig;
 *     dmaConfig.channelId    = IfxDma_ChannelId_1;
 *     dmaConfig.dmaId        = IfxDma_Index_0;
 *     dmaConfig.dmaSrvReqCfg = NULL_PTR;
 *
 *     //12. Queue configuration
 *     IfxAdc_Cdsp_QueueConfig queueCfg;
 *     queueCfg.dmaCfg            = &dmaConfig;
 *     queueCfg.bufferPtr         = (uint16 *)&resultBuffer;
 *     queueCfg.size              = IfxAdc_Cdsp_BufferSize_32;  //Buffer size in bytes
 *     queueCfg.bufferType        = IfxAdc_Cdsp_BufferType_circular;
 *     queueCfg.bufferFullHandler = NULL_PTR;
 *
 *     dspConfig.resSrvReqCfg   = &resSrvReq;      //Result Service request
 *
 *     dspConfig.queueCfg       = &queueCfg;
 *
 *     // Configure memory and other required configuration as shown in Module initialization section
 *
 *     //Initialize DSP core.
 *     IfxAdc_Cdsp_initDspCore(&dspCore0Handle, &dspConfig);
 *
 *  //Reading result from circular buffer
 *  uint16 numOfResult;
 *  sint16 result;
 *  numOfResult = IfxAdc_Cdsp_getNumberOfResults(&dspCore0Handle);
 *
 *  for(uint16 index = 0; index < numOfResult; index++)
 *  {
 *       result = IfxAdc_Cdsp_readCircularBufferResult(&dspCore0Handle);
 *  }
 * \endcode
 *
 * \defgroup IfxLld_Adc_Cdsp CDSP
 * \ingroup IfxLld_Adc
 * \defgroup IfxLld_Adc_Cdsp_Data_Structures Data Structures
 * \ingroup IfxLld_Adc_Cdsp
 * \defgroup IfxLld_Adc_Cdsp_Module_Initializaton Module Initialization
 * \ingroup IfxLld_Adc_Cdsp
 * \defgroup IfxLld_Adc_Cdsp_Result Result
 * \ingroup IfxLld_Adc_Cdsp
 * \defgroup IfxLld_Adc_Cdsp_Enum Enumerations
 * \ingroup IfxLld_Adc_Cdsp
 */

#ifndef IFXADC_CDSP_H
#define IFXADC_CDSP_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "Adc/Std/IfxAdc.h"
#include "_Impl/IfxAdcCdspFw_cfg.h"
#include "Dma/Dma/IfxDma_Dma.h"

/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/

/** \brief MACRO to get DCCM address for Dsp Core
 */
#define IFXADC_CDSP_GETDCCM_ADDRESS(coreId) ((uint32)ADC_CDSP_DSP0_DCCM + (coreId * IFXADC_ICCM_DCCM_OFFSET))

/** \brief MACRO to get ICCM address for Dsp Core
 */
#define IFXADC_CDSP_GETICCM_ADDRESS(coreId) ((uint32)ADC_CDSP_DSP0_ICCM + (coreId * IFXADC_ICCM_DCCM_OFFSET))

/** \brief MACRO to get linear buffer type with timestamp
 */
#define IFXADC_CDSP_RESULT_BUFFER_WITH_TS(typeName, numOfResults) \
    typedef struct {                                              \
        uint16 timeStamp;                                         \
        sint16 results[numOfResults];                             \
    } typeName;

/** \brief MACRO to calculate the offset for accessing FFT filter results in DCCM memory
 */
#define IFXADC_CDSP_FFT_DCCM_OFFSET              (0x88U)

/** \brief offset to get the number of input samples used for calculating FFT or size of the FFT from DCCM memory
 */
#define IFXADC_CDSP_FFT_INPUT_SAMPLE_DCCM_OFFSET (0x0004U)

/** \brief Macro to calculate the offset for accessing STAT0 results in DCCM memory
 */
#define IFXADC_CDSP_STAT0_DCCM_OFFSET            (0x0008U)

/******************************************************************************/
/*------------------------------Type Definitions------------------------------*/
/******************************************************************************/

/** \brief Type definition for Callback functions
 * \return None
 */
typedef void (*IfxAdc_Cdsp_Callback)(void);

/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Cdsp_Enum
 * \{ */
/** \brief Enumeration describing BufferSize
 * Note: Enum matches the DMA circular buffer size limitations.
 * Possible buffer sizes of the circular buffer can be (1,2,4,8..64K)
 */
typedef enum
{
    IfxAdc_Cdsp_BufferSize_none  = 0,   /**< \brief Buffer not configured */
    IfxAdc_Cdsp_BufferSize_2     = 1,   /**< \brief Buffer Size is 2 byte */
    IfxAdc_Cdsp_BufferSize_4     = 2,   /**< \brief Buffer size is 4 byte */
    IfxAdc_Cdsp_BufferSize_8     = 3,   /**< \brief Buffer size is 8 byte */
    IfxAdc_Cdsp_BufferSize_16    = 4,   /**< \brief Buffer size is 16 byte */
    IfxAdc_Cdsp_BufferSize_32    = 5,   /**< \brief Buffer size is 32 byte */
    IfxAdc_Cdsp_BufferSize_64    = 6,   /**< \brief Buffer size is 64 byte */
    IfxAdc_Cdsp_BufferSize_128   = 7,   /**< \brief Buffer size is 128 byte */
    IfxAdc_Cdsp_BufferSize_256   = 8,   /**< \brief Buffer size is 256 byte */
    IfxAdc_Cdsp_BufferSize_512   = 9,   /**< \brief Buffer size is 512 byte */
    IfxAdc_Cdsp_BufferSize_1024  = 10,  /**< \brief Buffer size is 1024 byte */
    IfxAdc_Cdsp_BufferSize_2048  = 11,  /**< \brief Buffer size is 2048 byte */
    IfxAdc_Cdsp_BufferSize_4096  = 12,  /**< \brief Buffer size is 4096 byte */
    IfxAdc_Cdsp_BufferSize_8192  = 13,  /**< \brief Buffer size is 8192 byte */
    IfxAdc_Cdsp_BufferSize_16384 = 14,  /**< \brief Buffer size is 16384 byte */
    IfxAdc_Cdsp_BufferSize_32768 = 15   /**< \brief Buffer size is 32768 byte */
} IfxAdc_Cdsp_BufferSize;

/** \brief Enumeration describing buffer types.
 */
typedef enum
{
    IfxAdc_Cdsp_BufferType_linear              = 0,  /**< \brief Configured buffer is linear buffer */
    IfxAdc_Cdsp_BufferType_linearWithTimestamp = 1,  /**< \brief Configured buffer is Linear buffer with timestamp */
    IfxAdc_Cdsp_BufferType_circular            = 2   /**< \brief Configured buffer is circular buffer */
} IfxAdc_Cdsp_BufferType;

/** \brief Enumeration describing various states of DSP core
 */
typedef enum
{
    IfxAdc_Cdsp_CoreState_uninitialized = 0,  /**< \brief uninitialized state */
    IfxAdc_Cdsp_CoreState_initialized   = 1,  /**< \brief initialized and enabled */
    IfxAdc_Cdsp_CoreState_softwareError = 2   /**< \brief error in driver */
} IfxAdc_Cdsp_CoreState;

/** \brief Enumeration describing list of filterchain
 */
typedef enum
{
    IfxAdc_Cdsp_FilterChainSel_basic                 = 0,  /**< \brief DSP Basic AURIX */
    IfxAdc_Cdsp_FilterChainSel_fir                   = 1,  /**< \brief DSP FIR */
    IfxAdc_Cdsp_FilterChainSel_avg1                  = 2,  /**< \brief DSP Advanced Average 1 */
    IfxAdc_Cdsp_FilterChainSel_dataAcc               = 3,  /**< \brief DSP Basic Data Accumulation */
    IfxAdc_Cdsp_FilterChainSel_median                = 4,  /**< \brief DSP Advanced Median */
    IfxAdc_Cdsp_FilterChainSel_avg2                  = 5,  /**< \brief DSP Advanced Average 2 */
    IfxAdc_Cdsp_FilterChainSel_luenbergerObserver    = 6,  /**< \brief DSP Luenberger Observer */
    IfxAdc_Cdsp_FilterChainSel_fft                   = 7,  /**< \brief DSP FFT */
    IfxAdc_Cdsp_FilterChainSel_sda                   = 8,  /**< \brief DSP Basic Simple Data Accumulation */
    IfxAdc_Cdsp_FilterChainSel_basicAvg              = 9,  /**< \brief DSP Basic Average */
    IfxAdc_Cdsp_FilterChainSel_basicMedian           = 10, /**< \brief DSP Basic Median */
    IfxAdc_Cdsp_FilterChainSel_predictiveMaintenance = 11  /**< \brief DSP Predictive Maintenance */
} IfxAdc_Cdsp_FilterChainSel;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Adc_Cdsp_Data_Structures
 * \{ */
/** \brief Data structure holding service request configuration raised by DMA to CPU.
 * If configured buffer is of type linear then buffer full interrupt.
 */
typedef struct
{
    Ifx_Priority priority;            /**< \brief Interrupt priority */
    IfxSrc_Tos   typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
} IfxAdc_Cdsp_DmaSrvReq;

/** \} */

/** \addtogroup IfxLld_Adc_Cdsp_Data_Structures
 * \{ */
/** \brief Cdsp DMA handle
 */
typedef struct
{
    IfxDma_Dma_Channel channel;       /**< \brief DMA channel handle */
    IfxDma_Index       dmaId;         /**< \brief Dma Module Index */
    boolean            useDma;        /**< \brief use Dma for Data transfer/s */
} IfxAdc_Cdsp_Dma;

/** \brief Dma configuration
 */
typedef struct
{
    IfxAdc_Cdsp_DmaSrvReq *dmaSrvReqCfg;       /**< \brief ISR configuration from DMA to CPU on buffer full */
    IfxDma_ChannelId       channelId;          /**< \brief DMA channel number */
    IfxDma_Index           dmaId;              /**< \brief Dma Module Index */
} IfxAdc_Cdsp_DmaConfig;

/** \brief Data structure holding trigger configuration
 */
typedef struct
{
    IfxAdc_CdspTriggerSel  triggerSel;       /**< \brief Selection value for trigger */
    IfxAdc_CdspTriggerMode edgeSel;          /**< \brief Edge selection for trigger */
    uint16                 delay;            /**< \brief Trigger delay count */
} IfxAdc_Cdsp_Trigger;

/** \} */

/** \brief Data structure holding service request trigger configuration
 */
typedef struct
{
    IfxAdc_CdspTriggerSel triggerSel;       /**< \brief Selection value for trigger */
    uint16                delay;            /**< \brief Trigger delay count */
} IfxAdc_Cdsp_ServReqTrigger;

/** \brief Data structure holding software trigger configuration
 */
typedef struct
{
    IfxAdc_CdspTriggerSel          triggerSel;       /**< \brief Selection value for trigger */
    IfxAdc_CdspSoftwareTriggerMode edgeSel;          /**< \brief Edge selection for trigger */
    uint16                         delay;            /**< \brief Trigger delay count */
} IfxAdc_Cdsp_SoftwareTrigger;

/** \addtogroup IfxLld_Adc_Cdsp_Data_Structures
 * \{ */
/** \brief Data structure holding alarm service request configuration
 */
typedef struct
{
    Ifx_Priority priority;            /**< \brief Interrupt priority */
    IfxSrc_Tos   typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId  vmId;                /**< \brief Virtual Machine Number */
    boolean      sr2Enable;           /**< \brief Enable service request for Boundary event(SR2) */
} IfxAdc_Cdsp_AlarmSrvReq;

/** \brief Configuration of Boundary Limit Checking
 */
typedef struct
{
    uint16                     upperBound;         /**< \brief Upper boundary (16 Bit) */
    uint16                     lowerBound;         /**< \brief Lower boundary (16 Bit) */
    IfxAdc_CdspBoundaryServReq srvReqConfig;       /**< \brief Service Request configuration */
    IfxAdc_CdspBoundaryCmpMode boundaryMode;       /**< \brief Boundary compare mode */
    boolean                    hystEn;             /**< \brief True --> Enable hysteresis */
} IfxAdc_Cdsp_BoundaryConfig;

/** \brief Data structure holding Timestamp,wakeup event service request configuration
 */
typedef struct
{
    Ifx_Priority       priority;            /**< \brief Interrupt priority */
    IfxSrc_Tos         typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId        vmId;                /**< \brief Virtual Machine Number */
    IfxAdc_CdspSrvReq1 sr1Mode;             /**< \brief Enable service request for special events (Timestamp, Wakeup Error and System halt event). */
} IfxAdc_Cdsp_EventSrvReq;

/** \brief Data structure holding Filter chains detail
 */
typedef struct
{
    IfxAdc_Cdsp_FilterChainSel filterchainId;       /**< \brief Filter Chains Id */
    uint16                     fftSize;             /**< \brief FFT output size (Number of frequency bins) */
} IfxAdc_Cdsp_Filterchain;

/** \brief Data structure holding memory configuration
 */
typedef struct
{
    void  *codeMemSrcAddrPtr;       /**< \brief Pointer to source address */
    void  *dataMemSrcAddrPtr;       /**< \brief Pointer to source address */
    uint16 codeSize;                /**< \brief Code Size to copy in ICCM memory */
    uint16 dataSize;                /**< \brief Data Size to copy in DCCM memory */
} IfxAdc_Cdsp_MemoryConfig;

/** \brief CDSP Queue Handle
 */
typedef struct
{
    void                  *bufferPtr;          /**< \brief Application buffer */
    IfxAdc_Cdsp_Callback   buffHandler;        /**< \brief Call back if Buffer full. Call back is provided only if ToS = CPU */
    IfxAdc_Cdsp_Dma        dma;                /**< \brief Dma Handle */
    IfxAdc_Cdsp_BufferType bufferType;         /**< \brief Type of the buffer */
    uint16                 writeIndex;         /**< \brief Write Index of the buffer. */
    uint16                 readIndex;          /**< \brief Read Index of the buffer. */
    uint16                 size;               /**< \brief Size of the buffer in bytes */
    uint16                 validResult;        /**< \brief Number of valid results */
    boolean                bufferFull;         /**< \brief Flag to indicate if buffer full */
    boolean                queueEnabled;       /**< \brief True --> If queue enabled */
} IfxAdc_Cdsp_Queue;

/** \brief CDSP Queue Configuration
 */
typedef struct
{
    IfxAdc_Cdsp_DmaConfig *dmaCfg;                  /**< \brief Dma Configuration */
    void                  *bufferPtr;               /**< \brief Pointer to the application buffer */
    IfxAdc_Cdsp_Callback   bufferFullHandler;       /**< \brief Buffer full handler */
    IfxAdc_Cdsp_BufferSize size;                    /**< \brief Size of the buffer */
    IfxAdc_Cdsp_BufferType bufferType;              /**< \brief Type of the buffer. */
} IfxAdc_Cdsp_QueueConfig;

/** \brief Data structure holding Result configuration
 */
typedef struct
{
    boolean                  readAsUnsigned;        /**< \brief read result as unsigned (RDM=1) */
    boolean                  enableTimeStamp;       /**< \brief Enable Time Stamp */
    boolean                  disableFifo;           /**< \brief Disable Fifo */
    IfxAdc_CdspFifoSrLevel   fifoSrvLevel;          /**< \brief FIFO fill level for service Request */
    IfxAdc_CdspDataReadWidth dataReadWidth;         /**< \brief Data Read Width */
} IfxAdc_Cdsp_ResultConfig;

/** \brief Result of CDSP core
 */
typedef struct
{
    uint16  timestamp;             /**< \brief Timestamp counter value */
    uint16  result0[4];            /**< \brief Array holding the result values in FIFO */
    boolean timestampStatus;       /**< \brief Gives the status of TIMESTAMP value */
} IfxAdc_Cdsp_ResultFifo;

/** \brief Data structure holding Result service request configuration.
 */
typedef struct
{
    IfxAdc_Cdsp_Callback resHandler;          /**< \brief Result Callback. Callback function will be invoked for each result event. (ToS = CPU) */
    Ifx_Priority         priority;            /**< \brief Interrupt priority.If ToS is DMA, priority should be DMA channel number */
    IfxSrc_Tos           typeOfService;       /**< \brief type of interrupt service */
    IfxSrc_VmId          vmId;                /**< \brief Virtual Machine Number */
    IfxAdc_CdspSrvReq0   sr0Enable;           /**< \brief Enable service request for Result event(SR0) */
} IfxAdc_Cdsp_ResultSrvReq;

/** \brief Data structure holding timestamp configuration
 */
typedef struct
{
    boolean                   startCounter;       /**< \brief True --> Start timestamp counter */
    IfxAdc_CdspTimestampClock clk;                /**< \brief Selection of timestamp counter clock */
} IfxAdc_Cdsp_TimestampConfig;

/** \brief Data structure holding cdsp triggers
 */
typedef struct
{
    IfxAdc_Cdsp_ServReqTrigger  *serviceReqTrig;       /**< \brief Service trigger Configuration. */
    IfxAdc_Cdsp_Trigger         *timestampTrig;        /**< \brief Timestamp trigger Configuration */
    IfxAdc_Cdsp_Trigger         *boundaryTrig;         /**< \brief Boundary trigger Configuration */
    IfxAdc_Cdsp_SoftwareTrigger *softwareTrig;         /**< \brief Software Integrator trigger Configuration */
} IfxAdc_Cdsp_TriggerConfig;

/** \} */

/** \brief Data structure hoding integrator configuration
 */
typedef struct
{
    IfxAdc_CdspSoftwareWindowControl windowSizeControl;       /**< \brief Configuration for integrator window control */
    IfxAdc_CdspSoftwareMode          softwareMode;            /**< \brief Software Mode */
} IfxAdc_Cdsp_SwIntegratorConfig;

/** \addtogroup IfxLld_Adc_Cdsp_Data_Structures
 * \{ */
/** \brief Handle of CDSP module
 */
typedef struct
{
    Ifx_ADC_CDSP *cdspSFR;       /**< \brief pointer to the module SFR set */
} IfxAdc_Cdsp;

/** \brief Data structure holding configuration of CDSP
 */
typedef struct
{
    Ifx_ADC *adcSFR;       /**< \brief pointer to the ADC module SFR set */
} IfxAdc_Cdsp_Config;

/** \brief Handle of DSP Core
 */
typedef struct
{
    IfxAdc_CdspCore          coreId;                 /**< \brief Core ID */
    Ifx_ADC_CDSP            *cdspSFR;                /**< \brief Pointer to Cdsp module sfr */
    Ifx_ADC_CDSP_DSP        *dspSFR;                 /**< \brief pointer to the core SFR set */
    IfxAdc_Cdsp_Callback     resHandler;             /**< \brief Result Handler */
    IfxAdc_Cdsp_CoreState    state;                  /**< \brief State of module */
    boolean                  fifoEnabled;            /**< \brief If TRUE, FIFO is enabled for core */
    boolean                  timeStampEnabled;       /**< \brief If TRUE, time stamp read is enabled for core */
    IfxAdc_CdspDataReadWidth dataReadWidth;          /**< \brief Data Read Width */
    IfxAdc_CdspFifoSrLevel   fifoLevel;              /**< \brief FIFO fill level for service Request */
    IfxAdc_CdspInput         inputSel;               /**< \brief CDSP input selection (TMADC, DSADC and GP register) */
    IfxAdc_Cdsp_ResultFifo   result;                 /**< \brief Structure holding result information */
    IfxAdc_Cdsp_Queue        queue;                  /**< \brief Queue handle information */
    IfxAdc_Cdsp_Filterchain  filterchain;            /**< \brief Filter chains information */
} IfxAdc_Cdsp_Dsp;

/** \brief Data structure holding configuration of DSP core
 */
typedef struct
{
    IfxAdc_CdspCore                 coreId;               /**< \brief DSP core Id */
    IfxAdc_CdspInput                inputSel;             /**< \brief CDSP input selection (TMADC, DSADC and GP register) */
    IfxAdc_CdspInputMonitor         inputMonitor;         /**< \brief Input monitor selection */
    Ifx_ADC                        *adcSFR;               /**< \brief Pointer to Adc module sfr */
    IfxAdc_Cdsp_TimestampConfig    *timestampCfg;         /**< \brief Pointer to timestamp configuration */
    IfxAdc_Cdsp_SwIntegratorConfig *integratorCfg;        /**< \brief Integrator configuration */
    IfxAdc_Cdsp_BoundaryConfig     *bndCfg;               /**< \brief Pointer to boundary configuration */
    IfxAdc_Cdsp_TriggerConfig      *triggerCfg;           /**< \brief Pointer to trigger configuration */
    IfxAdc_Cdsp_ResultSrvReq       *resSrvReqCfg;         /**< \brief Pointer to Result Service Request(SR0) configuration */
    IfxAdc_Cdsp_EventSrvReq        *eventSrvReqCfg;       /**< \brief Pointer to timestamp, wakeup events Service Request(SR1) configuration */
    IfxAdc_Cdsp_AlarmSrvReq        *alarmSrvReqCfg;       /**< \brief Pointer to alarm Service Request(SR2) configuration */
    IfxAdc_Cdsp_MemoryConfig       *memCfg;               /**< \brief Pointer to the memory configuration structure */
    IfxAdc_Cdsp_QueueConfig        *queueCfg;             /**< \brief Queue configuration */
    IfxAdc_Cdsp_ResultConfig        resultCfg;            /**< \brief Result configuration */
    boolean                         runCdspCore;          /**< \brief set TRUE to run DSP core at the end of initialization.
                                                           * FALSE to run multiple core synchronously. \ref IfxAdc_Cdsp_enableMultipleCores */
    IfxAdc_Cdsp_FilterChainSel      filterchainSel;       /**< \brief Filter chains selector */
} IfxAdc_Cdsp_DspCoreConfig;

/** \brief Result of CDSP core
 */
typedef struct
{
    uint16 timestamp;       /**< \brief Timestamp value */
    sint32 result;          /**< \brief result value */
} IfxAdc_Cdsp_Result;

/** \} */

/** \brief Luenberger observer (LO) filter result
 */
typedef struct
{
    float32 angularVelocity;
    float32 estimatedAngle;
    float32 angularError;
} IfxAdc_Cdsp_ResultLo;

/** \brief Predictive Maintenance filter result
 */
typedef struct
{
    sint16 minValue;
    sint16 maxValue;
    sint16 avgValue;
} IfxAdc_Cdsp_ResultPredictiveMaintenance;

/** \addtogroup IfxLld_Adc_Cdsp_Module_Initializaton
 * \{ */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to initialize module.
 * \param cdsp Pointer to module handler
 * \param config Pointer to module configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Cdsp_initModule(IfxAdc_Cdsp *cdsp, const IfxAdc_Cdsp_Config *config);

/** \brief Function to initialize module configuration structure with default values
 * \param config Pointer to module configuration
 * \param adc Pointer to ADC module sfr set
 * \return None
 */
IFX_EXTERN void IfxAdc_Cdsp_initModuleConfig(IfxAdc_Cdsp_Config *config, Ifx_ADC *adc);

/** \brief Function to initialize Dsp core
 * \param dsp Pointer to handle of DSP core
 * \param config Pointer to DSP core configuration
 * \return None
 */
IFX_EXTERN void IfxAdc_Cdsp_initDspCore(IfxAdc_Cdsp_Dsp *dsp, IfxAdc_Cdsp_DspCoreConfig *config);

/** \brief Function to the initialize configuration structure of DSP core
 * \param config Pointer to Dsp core configuration
 * \param adc Pointer to ADC module sfr set
 * \return None
 */
IFX_EXTERN void IfxAdc_Cdsp_initDspCoreConfig(IfxAdc_Cdsp_DspCoreConfig *config, Ifx_ADC *adc);

/** \} */

/** \addtogroup IfxLld_Adc_Cdsp_Result
 * \{ */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to read secondary DSP core result.(RES1)
 * \param dsp Pointer to dsp core handle
 * \return Return secondary result (RES1)
 */
IFX_INLINE sint32 IfxAdc_Cdsp_readSecondaryResult(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to read tertiary DSP core result.(RES2)
 * \param dsp Pointer to dsp core handle
 * \return Return tertiary result (RES2)
 */
IFX_INLINE sint32 IfxAdc_Cdsp_readTertiaryResult(IfxAdc_Cdsp_Dsp *dsp);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to read DSP core result
 * If the FIFO is disabled, recommanded to use the IfxAdc_Cdsp_readResult API [DRM = 01, DisableFIFO = TRUE]
 * \param dsp Pointer to dsp core handle
 * \return Return 16-bit result value.
 * Returns previous result if result flag not set.
 */
IFX_EXTERN uint16 IfxAdc_Cdsp_readDspCoreResult(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to read DSP core result from hardware register when FiFO is disabled. (DRM-1)
 * \param dsp Pointer to dsp core handle
 * \return Return result with timestamp(if enabled)
 */
IFX_EXTERN IfxAdc_Cdsp_Result IfxAdc_Cdsp_readResult(IfxAdc_Cdsp_Dsp *dsp);

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Returns timestamp counter value
 * \param dsp Pointer to handle of DSP core
 * \return Returns timestamp counter value
 */
IFX_INLINE uint16 IfxAdc_Cdsp_readTimestampCounter(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Returns timestamp counter value
 * \param dsp Pointer to handle of DSP core
 * \return Returns latched timestamp value
 */
IFX_INLINE uint16 IfxAdc_Cdsp_readTimestampValue(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to read intermediate integration value.
 * \param dsp Pointer to handle of DSP core
 * \return Returns intermediate integrator value
 */
IFX_INLINE uint32 IfxAdc_Cdsp_readIntegratorIntermediateValue(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to start timestamp counter.
 * \param dsp Pointer to handle of DSP core
 * \return None
 */
IFX_INLINE void IfxAdc_Cdsp_startTimestampCounter(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to start timestamp counter.
 * \param dsp Pointer to handle of DSP core
 * \return None
 */
IFX_INLINE void IfxAdc_Cdsp_stopTimestampCounter(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to clear buffer
 * \param dsp Pointer to handle of DSP core
 * \return None
 */
IFX_INLINE void IfxAdc_Cdsp_clearBuffer(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to check if buffer full
 * \param dsp Pointer to handle of DSP core
 * \return Return buffer full status.
 * TRUE --> Buffer full
 */
IFX_INLINE boolean IfxAdc_Cdsp_isBufferFull(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to check if buffer empty
 * \param dsp Pointer to handle of DSP core
 * \return Return buffer empty status.
 * TRUE --> Buffer empty
 */
IFX_INLINE boolean IfxAdc_Cdsp_isBufferEmpty(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Parallelize the CDSP core execution
 * \param cdsp pointer to cdsp handle
 * \param dspCoresEnableValue value to enable the DSP cores (setting the each bit in this specifies the run of
 * DSP core in corresponding CDSP. For example bit 0 of this variable controls the run of CDSP0)
 * \return None
 *
 * Coding example:
 *
 * \code
 *      IfxAdc_CdspCore_0, IfxAdc_CdspCore_2, IfxAdc_CdspCore_3 DSP cores need to run .
 *      update the vlaue in dspCoresEnableValue = (1u << IfxAdc_CdspCore_0) | (1u << IfxAdc_CdspCore_2) | (1u << IfxAdc_CdspCore_3)
 *      uint32 dspCoresEnableValue = 13u;
 *      IfxAdc_Cdsp_enableMultipleCores(dsp, dspCoresEnableValue)
 * \endcode
 *
 */
IFX_INLINE void IfxAdc_Cdsp_enableMultipleCores(IfxAdc_Cdsp *cdsp, uint32 dspCoresEnableValue);

/** \brief Function to get the number of input samples used for calculating FFT or size of the FFT
 * \param dsp pointer to dsp core handle
 * \return Number of samples
 */
IFX_INLINE uint16 IfxAdc_Cdsp_getNumOfSamples(IfxAdc_Cdsp_Dsp *dsp);

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/

/** \brief Function to get number of new results from the buffer
 * \param dsp Pointer to handle of DSP core
 * \return Returns number of new results from the buffer
 */
IFX_EXTERN uint16 IfxAdc_Cdsp_getNumberOfResults(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to copy data from hardware FIFO to software buffer.
 * \param dsp Pointer to dsp core handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Cdsp_writeBuffer(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to read immediate conversion result from circular buffer
 * \param dsp Pointer to dsp core handle
 * \return Returns immediate unread data from the buffer.
 */
IFX_EXTERN sint16 IfxAdc_Cdsp_readCircularBufferResult(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to copy conversion results from application buffer to another linear buffer.
 * \param dsp Pointer to dsp core handle
 * \param resBuff Buffer to store result
 * \param size Size of data to be read
 * \return Returns read status
 * IfxAdc_Status_success --> Read result successful
 * IfxAdc_Status_failure --> Buffer empty,read failed
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Cdsp_readStreamResult(IfxAdc_Cdsp_Dsp *dsp, uint16 *resBuff, uint16 size);

/** \brief Isr for writing data from hardware buffer to software Fifo.
 * \param dsp Pointer to dsp core handle
 * \return None
 */
IFX_EXTERN void IfxAdc_Cdsp_resultIsr(IfxAdc_Cdsp_Dsp *dsp);

/** \brief Function to setup the result buffer.
 * \param dsp Pointer to dsp core handle
 * \param buffer Pointer to the buffer
 * \param size Size of the buffer
 * \return Return
 * IfxAdc_Status_success --> Setting up of result buffer is successful
 * IfxAdc_Status_failure --> Issue in setting up of result buffer
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Cdsp_setupResultBuffer(IfxAdc_Cdsp_Dsp *dsp, void *buffer, IfxAdc_Cdsp_BufferSize size);

/** \brief Function to get the result for Luenberger observer (LO) filter. [DRM = 01, Timestamp = FALSE]
 * Result type in Radian
 * \param dsp Pointer to dsp core handle
 * \param resultPtr result pointer to get the LO filter result
 * \return Return
 * IfxAdc_Status_success --> Update result to  buffer is successful
 * IfxAdc_Status_failure --> Buffer is null pointer
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Cdsp_readLoFilterResult(IfxAdc_Cdsp_Dsp *dsp, IfxAdc_Cdsp_ResultLo *resultPtr);

/** \brief Function to read the FFT filter result
 * \param dsp pointer to dsp core handle
 * \param resultBuff result buffer for FFT filter
 * \return Return
 * IfxAdc_Status_success --> Update result to  buffer is successful
 * IfxAdc_Status_failure --> Buffer is null pointer
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Cdsp_readFftFilterResult(IfxAdc_Cdsp_Dsp *dsp, uint32 *resultBuff);

/** \brief Function to get the result for Predictive Maintenance
 * \param dsp Pointer to dsp core handle
 * \param resultPtr result pointer to get the Predictive Maintenance filter result
 * \return Return
 * IfxAdc_Status_success --> Update result to  buffer is successful
 * IfxAdc_Status_failure --> Buffer is null pointer
 */
IFX_EXTERN IfxAdc_Status IfxAdc_Cdsp_readPredictiveMaintenanceResult(IfxAdc_Cdsp_Dsp *dsp, IfxAdc_Cdsp_ResultPredictiveMaintenance *resultPtr);

/******************************************************************************/
/*---------------------Inline Function Implementations------------------------*/
/******************************************************************************/

IFX_INLINE uint16 IfxAdc_Cdsp_readTimestampCounter(IfxAdc_Cdsp_Dsp *dsp)
{
    return (uint16)(dsp->dspSFR->TSCNT.B.TSCOUNT);
}


IFX_INLINE uint16 IfxAdc_Cdsp_readTimestampValue(IfxAdc_Cdsp_Dsp *dsp)
{
    uint16 timestamp = 0;

    if (dsp->dspSFR->TSTMP.B.TSVAL)
    {
        timestamp = (uint16)(dsp->dspSFR->TSTMP.B.TIMESTAMP);
    }

    return timestamp;
}


IFX_INLINE uint32 IfxAdc_Cdsp_readIntegratorIntermediateValue(IfxAdc_Cdsp_Dsp *dsp)
{
    return (uint32)(dsp->dspSFR->INTIVAL.U);
}


IFX_INLINE void IfxAdc_Cdsp_startTimestampCounter(IfxAdc_Cdsp_Dsp *dsp)
{
    dsp->dspSFR->DSPCFG.B.TSCRUN = 1u;
}


IFX_INLINE void IfxAdc_Cdsp_stopTimestampCounter(IfxAdc_Cdsp_Dsp *dsp)
{
    dsp->dspSFR->DSPCFG.B.TSCRUN = 0u;
}


IFX_INLINE void IfxAdc_Cdsp_clearBuffer(IfxAdc_Cdsp_Dsp *dsp)
{
    uint16  bufferSize     = dsp->queue.size;
    uint16 *localBufferPtr = (uint16 *)(dsp->queue.bufferPtr);
    uint16  index          = 0;

    for (index = 0; index < bufferSize; index++)
    {
        localBufferPtr[index] = 0;
    }
}


IFX_INLINE boolean IfxAdc_Cdsp_isBufferFull(IfxAdc_Cdsp_Dsp *dsp)
{
    return dsp->queue.bufferFull;
}


IFX_INLINE boolean IfxAdc_Cdsp_isBufferEmpty(IfxAdc_Cdsp_Dsp *dsp)
{
    boolean status = FALSE;

    if (dsp->queue.validResult == 0u)
    {
        status = TRUE;
    }

    return status;
}


IFX_INLINE sint32 IfxAdc_Cdsp_readSecondaryResult(IfxAdc_Cdsp_Dsp *dsp)
{
    sint32 result = 0u;

    //RES 1
    if (IfxAdc_getCdspResultEvent(dsp->cdspSFR, dsp->coreId, IfxAdc_CdspResultReg_1))
    {
        result = dsp->dspSFR->RES[IfxAdc_CdspResultReg_1].U;
    }

    return result;
}


IFX_INLINE sint32 IfxAdc_Cdsp_readTertiaryResult(IfxAdc_Cdsp_Dsp *dsp)
{
    sint32 result = 0u;

    //RES 2
    if (IfxAdc_getCdspResultEvent(dsp->cdspSFR, dsp->coreId, IfxAdc_CdspResultReg_2))
    {
        result = dsp->dspSFR->RES[IfxAdc_CdspResultReg_2].U;
    }

    return result;
}


IFX_INLINE void IfxAdc_Cdsp_enableMultipleCores(IfxAdc_Cdsp *cdsp, uint32 dspCoresEnableValue)
{
    cdsp->cdspSFR->GLOBRCD.B.CHRUND |= dspCoresEnableValue;
}


IFX_INLINE uint16 IfxAdc_Cdsp_getNumOfSamples(IfxAdc_Cdsp_Dsp *dsp)
{
    uint32 *fftSamples = (uint32 *)(IFXADC_CDSP_GETDCCM_ADDRESS(dsp->coreId) + IFXADC_CDSP_FFT_INPUT_SAMPLE_DCCM_OFFSET);

    return (uint16)*fftSamples;
}


#endif /* IFXADC_CDSP_H */
