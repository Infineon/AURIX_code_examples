/**
 * \file IfxScrRtc.h
 * \brief SCR RTC  basic functionality
 * \ingroup IfxLld_ScrRtc
 *
 * \version iLLD-TC4-v2.1.1
 * \copyright Copyright (c) 2020 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such
 * terms of use are agreed, use of this file is subject to following:
 *
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or
 * organization obtaining a copy of the software and accompanying
 * documentation covered by this license (the "Software") to use, reproduce,
 * display, distribute, execute, and transmit the Software, and to prepare
 * derivative works of the Software, and to permit third-parties to whom the
 * Software is furnished to do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 * \defgroup IfxLld_ScrRtc_Std_Enumerations Enum
 * \ingroup IfxLld_ScrRtc_Std
 * \defgroup IfxLld_ScrRtc_Std_DataStructures Data structures
 * \ingroup IfxLld_ScrRtc_Std
 * \defgroup IfxLld_ScrRtc_Std_Rtc RTC Functionality
 * \ingroup IfxLld_ScrRtc_Std
 * \defgroup IfxLld_ScrRtc_Std_Rtc_init RTC init Functionality
 * \ingroup IfxLld_ScrRtc_Std
 */

#ifndef IFXSCRRTC_H
#define IFXSCRRTC_H 1

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include "_Impl/IfxScrRtc_cfg.h"
#include "_Reg/IfxScr_bf.h"
#include "_Reg/IfxScr_reg.h"

/******************************************************************************/
/*-------------------------------Enumerations---------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrRtc_Std_Enumerations
 * \{ */
/** \brief Enumeration for RTC clock input selection
 */
typedef enum
{
    IfxScrRtc_ClockSel_70Khz     = 0,   /**< \brief 70Khz clock is selected */
    IfxScrRtc_ClockSel_pclk      = 1,   /**< \brief PCLK clock is selected */
    IfxScrRtc_ClockSel_extOscPin = 2,   /**< \brief External clock oscillator input from pin */
    IfxScrRtc_ClockSel_fosc32    = 3    /**< \brief External clock oscillator from PMS */
} IfxScrRtc_ClockSel;

/** \} */

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrRtc_Std_DataStructures
 * \{ */

typedef struct
{
    IfxScrRtc_ClockSel clockSource;                       /**< \brief Clock source selection */
    uint32             initialCountValue;                 /**< \brief Count value for RTC */
    uint32             compareValue;                      /**< \brief Compare value for RTC */
    boolean            bypassPrescaler;                   /**< \brief Enable/Disable Prescalar bypass */
    boolean            enableInterruptOnCompare;          /**< \brief Enable/Disable Compare Interrupt */
}IfxScrRtc_Config;

/** \} */

/******************************************************************************/
/*-------------------------Inline Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrRtc_Std_Rtc
 * \{ */
/** \brief Start RTC operation.
 *	After being written to RTC_CON.RTCC, it
 *	takes 6 RTC Clock cycles for the RTC to be actually enabled or disabled
 * \return None
 */
IFX_INLINE void IfxScrRtc_enableRtc(void);

/** \brief Stop RTC operation.
 *	After being written to RTC_CON.RTCC, it
 *	takes 6 RTC Clock cycles for the RTC to be actually enabled or disabled
 * \return None
 */
IFX_INLINE void IfxScrRtc_disableRtc(void);

/** \brief Selects clock source for RTC.
 * Clock source cannot be changed while RTC is  in operation.So RTC is stopped before clock source is changed.
 * \param clockSource Clock source to be use for RTC.
 * \return TRUE --> Clock source selection is successful
 *         FALSE --> CLock source selection failed as RTC was running
 */
IFX_INLINE boolean IfxScrRtc_selectClockSource(IfxScrRtc_ClockSel clockSource);

/** \brief Loads the value of count from which RTC shall start counting upwards
 * \param initialValue Start value of count to be loaded into RTC_CNT
 * \return None
 */
IFX_INLINE void IfxScrRtc_loadInitialValue(uint32 initialValue);

/** \brief Loads the value of count on reaching which the RTC shall trigger interrupt(if enabled) and trigger Tricore wakeup(if enabled.)
 * \param compareValue Value to be compared against, loaded into RTC_CR register
 * \return None
 */
IFX_INLINE void IfxScrRtc_loadCompareValue(uint32 compareValue);

/** \brief Bypass the 9-bit pre-scalar. The prescalar would basically act as a divide by 512 divider for f_RTC
 * \return None
 */
IFX_INLINE void IfxScrRtc_bypassPrescalar(void);

/** \brief Use the 9-bit prescalar. It basically would act as a divide by 512 divider for f_RTC
 * \return None
 */
IFX_INLINE void IfxScrRtc_usePrescalar(void);

/** \brief Get the RTC count value
 * \return None
 */
IFX_INLINE void IfxScrRtc_triggerCapture(void);

/** \brief Clears the flag indicating the RTC reaching the compare value
 * \return None
 */
IFX_INLINE void IfxScrRtc_clearCompareFlag(void);

/** \brief Reads the captured value as a 32-bit int from RTC_CRn(n=0-3) registers
 * \return Capture value
 */
IFX_INLINE uint32 IfxScrRtc_readCaptureValue(void);

/** \brief Reads the RTC timer value
 * \return Returns RTC timer value
 */
IFX_INLINE uint32 IfxScrRtc_readTimerValue(void);

/** \brief Enable generation of interrupt in case compare match between RTC counter and compare value in RTC_CR
 * \return None
 */
IFX_INLINE void IfxScrRtc_enableCompareInterrupt(void);

/** \brief Disable generation of interrupt in case compare match between RTC counter and compare value in RTC_CR
 * \return None
 */
IFX_INLINE void IfxScrRtc_disableCompareInterrupt(void);

/** \brief Check if Compare match interrupt is enabled
 * \return Returns status of enabling of compare interrupt.
 */
IFX_INLINE boolean IfxScrRtc_isCompareInterruptEnabled(void);

/** \brief Check if Compare match interrupt has occured
 * \return Returns status of compare interrupt.
 */
IFX_INLINE boolean IfxScrRtc_isCompareInterruptOccured(void);

/** \brief Fill the RTC config structure with default values
 * \param pointer to RTC config structure
 * \return None
 */
//IFX_INLINE void IfxScrRtc_initModuleConfig(IfxScrRtc_Config* rtcConfig);

/** \} */

/******************************************************************************/
/*-------------------------Global Function Prototypes-------------------------*/
/******************************************************************************/
/** \addtogroup IfxLld_ScrRtc_Std_Rtc_init
 * \{ */
/** \brief Initialize the RTC module with default configuration
 * \param pointer to RTC config structure
 * \return None
 */
IFX_EXTERN void IfxScrRtc_initModule(IfxScrRtc_Config *rtcConfig);

/** \} */
/******************************************************************************/
/*-------------------------Inline Function Implementation-------------------------*/
/******************************************************************************/

IFX_INLINE void IfxScrRtc_enableRtc(void)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U = (SCR_RTC_CON.U | 1U);
}


IFX_INLINE void IfxScrRtc_disableRtc(void)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U = (SCR_RTC_CON.U & ~(1u << IFX_SCR_RTC_CON_RTCC_OFF));
}


IFX_INLINE boolean IfxScrRtc_selectClockSource(IfxScrRtc_ClockSel clockSource)
{
    Ifx_SCR_RTC_CON rtc_con;
    boolean         retVal = TRUE;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);

    /*Check if RTC is running*/
    if (!(SCR_RTC_CON.U & (1u << IFX_SCR_RTC_CON_RTCC_OFF)))
    {
        rtc_con.U     = (SCR_RTC_CON.U & ~(IFX_SCR_RTC_CON_RTCCLKSEL_MSK << IFX_SCR_RTC_CON_RTCCLKSEL_OFF));
        rtc_con.U    |= (clockSource << IFX_SCR_RTC_CON_RTCCLKSEL_OFF) | (1u << IFX_SCR_RTC_CON_RTCCLKSEL_P_OFF);
        SCR_RTC_CON.U = rtc_con.U;
    }
    else
    {
        retVal = FALSE;
    }

    return retVal;
}


IFX_INLINE void IfxScrRtc_loadInitialValue(uint32 initialValue)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
/* Stop RTC counter*/
    SCR_RTC_CON.U = (SCR_RTC_CON.U & ~(1u << IFX_SCR_RTC_CON_RTCC_OFF));

/* Enable bit protection write access */
    SCR_PASSWD.U = ((SCR_PASSWD.U & (unsigned char)0x07) | (0x13 << IFX_SCR_PASSWD_PASS_OFF));

/* Loading the 32-bit initial count value */
    SCR_RTC_CNT0.U = (uint8)initialValue;
    SCR_RTC_CNT1.U = (uint8)(initialValue >> 8);
    SCR_RTC_CNT2.U = (uint8)(initialValue >> 16);
    SCR_RTC_CNT3.U = (uint8)(initialValue >> 24);

/* Disable bit protection write access */
    SCR_PASSWD.U = ((SCR_PASSWD.U & (unsigned char)0x07) | (0x15 << IFX_SCR_PASSWD_PASS_OFF));
}


IFX_INLINE void IfxScrRtc_loadCompareValue(uint32 compareValue)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CR0.U = (uint8)compareValue;
    SCR_RTC_CR1.U = (uint8)(compareValue >> 8);
    SCR_RTC_CR2.U = (uint8)(compareValue >> 16);
    SCR_RTC_CR3.U = (uint8)(compareValue >> 24);
}


IFX_INLINE void IfxScrRtc_bypassPrescalar(void)
{
    SCR_SYSCON0.U  = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U |= (1u << IFX_SCR_RTC_CON_RTPBYP_OFF);
}


IFX_INLINE void IfxScrRtc_usePrescalar(void)
{
    SCR_SYSCON0.U  = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U &= ~(1u << IFX_SCR_RTC_CON_RTPBYP_OFF);
}


IFX_INLINE void IfxScrRtc_triggerCapture(void)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U = (SCR_RTC_CON.U | (1u << IFX_SCR_RTC_CON_RTCCT_OFF));

    while ((SCR_RTC_CON.U & (1u << IFX_SCR_RTC_CON_RTCCT_OFF)) != 0U)
    {}
}


IFX_INLINE void IfxScrRtc_clearCompareFlag(void)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U = SCR_RTC_CON.U & ~(1u << IFX_SCR_RTC_CON_CFRTC_OFF);
}


IFX_INLINE void IfxScrRtc_enableCompareInterrupt(void)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U = SCR_RTC_CON.U | (1u << IFX_SCR_RTC_CON_ECRTC_OFF);
}


IFX_INLINE void IfxScrRtc_disableCompareInterrupt(void)
{
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    SCR_RTC_CON.U = SCR_RTC_CON.U & ~(1u << IFX_SCR_RTC_CON_ECRTC_OFF);
}


IFX_INLINE boolean IfxScrRtc_isCompareInterruptEnabled(void)
{
    return (boolean)((SCR_RTC_CON.U & (1u << IFX_SCR_RTC_CON_ECRTC_OFF)) >> IFX_SCR_RTC_CON_ECRTC_OFF);
}


IFX_INLINE boolean IfxScrRtc_isCompareInterruptOccured(void)
{
    return (boolean)((SCR_RTC_CON.U & (1u << IFX_SCR_RTC_CON_CFRTC_OFF)) >> IFX_SCR_RTC_CON_CFRTC_OFF);
}


IFX_INLINE uint32 IfxScrRtc_readCaptureValue(void)
{
    uint32 captureValue = 0;
    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);
    captureValue |= ((uint32)SCR_RTC_CR0.U);
    captureValue |= ((uint32)SCR_RTC_CR1.U << 8);
    captureValue |= ((uint32)SCR_RTC_CR2.U << 16);
    captureValue |= ((uint32)SCR_RTC_CR3.U << 24);

    return captureValue;
}

IFX_INLINE uint32 IfxScrRtc_readTimerValue(void)
{
	uint32 tval = 0u;

    SCR_SYSCON0.U = SCR_SYSCON0.U & (uint8)(0xFE);

	/* Read 32-bit RTC count value */
	tval  = (uint32)SCR_RTC_CNT0.U;
	tval |= (uint32)SCR_RTC_CNT1.U << 8u;
	tval |= (uint32)SCR_RTC_CNT2.U << 16u;
	tval |= (uint32)SCR_RTC_CNT3.U << 24u;

	return tval;
}

#endif /* IFXSCRRTC_H */
